{"file_name": "/home/qj213/afp-2021-10-22/thys/Buildings/Chamber.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Buildings", "problem_names": ["lemmas faces                     = faces", "lemmas singleton_simplex         = singleton_simplex", "lemmas chamberI                  = maxsimpI", "lemmas chamberD_simplex          = maxsimpD_simplex", "lemmas chamberD_maximal          = maxsimpD_maximal", "lemmas finite_chamber            = finite_maxsimp", "lemmas chamber_nempty            = maxsimp_nempty", "lemmas chamber_vertices          = maxsimp_vertices", "lemmas gallery_def               = maxsimpchain_def", "lemmas gallery_snocI             = maxsimpchain_snocI", "lemmas galleryD_chamber          = maxsimpchainD_maxsimp", "lemmas galleryD_adj              = maxsimpchainD_adj", "lemmas gallery_CConsI            = maxsimpchain_CConsI", "lemmas gallery_Cons_reduce       = maxsimpchain_Cons_reduce", "lemmas gallery_append_reduce1    = maxsimpchain_append_reduce1", "lemmas gallery_append_reduce2    = maxsimpchain_append_reduce2", "lemmas gallery_remdup_adj        = maxsimpchain_remdup_adj", "lemmas gallery_obtain_pgallery   = maxsimpchain_obtain_pmaxsimpchain", "lemmas pgallery_def              = pmaxsimpchain_def", "lemmas pgalleryI_gallery         = pmaxsimpchainI_maxsimpchain", "lemmas pgalleryD_chamber         = pmaxsimpchainD_maxsimp", "lemmas pgalleryD_adj             = pmaxsimpchainD_adj", "lemmas pgalleryD_distinct        = pmaxsimpchainD_distinct", "lemmas pgallery_Cons_reduce      = pmaxsimpchain_Cons_reduce", "lemmas pgallery_append_reduce1   = pmaxsimpchain_append_reduce1", "lemmas pgallery                  = pmaxsimpchain", "lemmas min_gallery_simps         = min_maxsimpchain.simps", "lemmas min_galleryI_betw         = min_maxsimpchainI_betw", "lemmas min_galleryI_betw_compare = min_maxsimpchainI_betw_compare", "lemmas min_galleryD_min_betw     = min_maxsimpchainD_min_betw", "lemmas min_galleryD_gallery      = min_maxsimpchainD_maxsimpchain", "lemmas min_gallery_pgallery      = min_maxsimpchain_pmaxsimpchain", "lemmas min_gallery_rev           = min_maxsimpchain_rev", "lemmas min_gallery_adj           = min_maxsimpchain_adj", "lemmas not_min_galleryI_betw     = not_min_maxsimpchainI_betw", "lemmas min_gallery_betw_CCons_reduce =\n  min_maxsimpchain_betw_CCons_reduce", "lemmas min_gallery_betw_uniform_length =\n  min_maxsimpchain_betw_uniform_length", "lemmas vertex_set_int = vertex_set_int[OF ChamberComplex.axioms(1)]", "lemma chamber_pconnect:\n  \"\\<lbrakk> x \\<noteq> y; chamber x; chamber y \\<rbrakk> \\<Longrightarrow> \\<exists>xs. pgallery (x#xs@[y])\"", "lemma supchamberD:\n  assumes \"v\\<in>\\<Union>X\"\n  defines \"C \\<equiv> supchamber v\"\n  shows   \"chamber C\" \"v\\<in>C\"", "lemma ChamberSubcomplexI:\n  assumes \"Y\\<subseteq>X\" \"ChamberComplex Y\"\n          \"\\<And>y. ChamberComplex.chamber Y y \\<Longrightarrow> chamber y\"\n  shows   \"ChamberSubcomplex Y\"", "lemma ChamberSubcomplexD_sub: \"ChamberSubcomplex Y \\<Longrightarrow> Y \\<subseteq> X\"", "lemma ChamberSubcomplexD_complex:\n  \"ChamberSubcomplex Y \\<Longrightarrow> ChamberComplex Y\"", "lemma chambersub_imp_sub: \"ChamberSubcomplex Y \\<Longrightarrow> Subcomplex Y\"", "lemma chamber_in_subcomplex:\n  \"\\<lbrakk> ChamberSubcomplex Y; C \\<in> Y; chamber C \\<rbrakk> \\<Longrightarrow>\n    ChamberComplex.chamber Y C\"", "lemma subcomplex_chamber:\n  \"ChamberSubcomplex Y \\<Longrightarrow> ChamberComplex.chamber Y C \\<Longrightarrow> chamber C\"", "lemma gallery_in_subcomplex:\n  \"\\<lbrakk> ChamberSubcomplex Y; set ys \\<subseteq> Y; gallery ys \\<rbrakk> \\<Longrightarrow>\n    ChamberComplex.gallery Y ys\"", "lemma subcomplex_gallery:\n  \"ChamberSubcomplex Y \\<Longrightarrow> ChamberComplex.gallery Y Cs \\<Longrightarrow> gallery Cs\"", "lemma subcomplex_pgallery:\n  \"ChamberSubcomplex Y \\<Longrightarrow> ChamberComplex.pgallery Y Cs \\<Longrightarrow> pgallery Cs\"", "lemma min_gallery_in_subcomplex:\n  assumes \"ChamberSubcomplex Y\" \"min_gallery Cs\" \"set Cs \\<subseteq> Y\"\n  shows   \"ChamberComplex.min_gallery Y Cs\"", "lemma chamber_card: \"chamber C \\<Longrightarrow> chamber D \\<Longrightarrow> card C = card D\"", "lemma chamber_facet_is_chamber_facet:\n  \"\\<lbrakk> chamber C; chamber D; z\\<lhd>C; z\\<subseteq>D \\<rbrakk> \\<Longrightarrow> z\\<lhd>D\"", "lemma chamber_adj:\n  assumes \"chamber C\" \"D\\<in>X\" \"C \\<sim> D\"\n  shows   \"chamber D\"", "lemma chambers_share_facet:\n  assumes \"chamber C\" \"chamber (insert v z)\" \"z\\<lhd>C\"\n  shows   \"z\\<lhd>insert v z\"", "lemma adjacentset_chamber: \"chamber C \\<Longrightarrow> D\\<in>adjacentset C \\<Longrightarrow> chamber D\"", "lemma chamber_shared_facet: \"\\<lbrakk> chamber C; z\\<lhd>C; D\\<in>X; z\\<lhd>D \\<rbrakk> \\<Longrightarrow> chamber D\"", "lemma adjacentset_conv_facetchambersets:\n  assumes \"X \\<noteq> {{}}\" \"chamber C\"\n  shows   \"adjacentset C = (\\<Union>v\\<in>C. {D\\<in>X. C-{v}\\<lhd>D})\"", "lemma chamber_system_simplices: \"\\<C> \\<subseteq> X\"", "lemma gallery_chamber_system: \"gallery Cs \\<Longrightarrow> set Cs \\<subseteq> \\<C>\"", "lemmas pgallery_chamber_system = gallery_chamber_system[OF pgallery]", "lemma chamber_distance_le:\n  \"gallery (C#Cs@[D]) \\<Longrightarrow> chamber_distance C D \\<le> Suc (length Cs)\"", "lemma min_gallery_betw_chamber_distance:\n  \"min_gallery (C#Cs@[D]) \\<Longrightarrow> chamber_distance C D = Suc (length Cs)\"", "lemma min_galleryI_chamber_distance_betw:\n  \"gallery (C#Cs@[D]) \\<Longrightarrow> Suc (length Cs) = chamber_distance C D \\<Longrightarrow>\n    min_gallery (C#Cs@[D])\"", "lemma gallery_least_length:\n  assumes \"chamber C\" \"chamber D\" \"C\\<noteq>D\"\n  defines \"Cs \\<equiv> ARG_MIN length Cs. gallery (C#Cs@[D])\"\n  shows   \"gallery (C#Cs@[D])\"", "lemma min_gallery_least_length:\n  assumes   \"chamber C\" \"chamber D\" \"C\\<noteq>D\"\n  defines   \"Cs \\<equiv> ARG_MIN length Cs. gallery (C#Cs@[D])\"\n  shows     \"min_gallery (C#Cs@[D])\"", "lemma pgallery_least_length:\n  assumes \"chamber C\" \"chamber D\" \"C\\<noteq>D\"\n  defines \"Cs \\<equiv> ARG_MIN length Cs. gallery (C#Cs@[D])\"\n  shows   \"pgallery (C#Cs@[D])\"", "lemma closest_supchamberD:\n  assumes   \"F\\<in>X\" \"chamber D\"\n  shows     \"chamber (closest_supchamber F D)\" \"F \\<subseteq> closest_supchamber F D\"", "lemma closest_supchamber_closest:\n  \"chamber C \\<Longrightarrow> F\\<subseteq>C \\<Longrightarrow>\n    chamber_distance (closest_supchamber F D) D \\<le> chamber_distance C D\"", "lemma face_distance_le:\n  \"chamber C \\<Longrightarrow> F\\<subseteq>C \\<Longrightarrow> face_distance F D \\<le> chamber_distance C D\"", "lemma face_distance_eq_0: \"chamber C \\<Longrightarrow> F\\<subseteq>C \\<Longrightarrow> face_distance F C = 0\"", "lemma label_wrtD: \"label_wrt B f \\<Longrightarrow> C\\<in>\\<C> \\<Longrightarrow> bij_betw f C B\"", "lemma label_wrtD': \"label_wrt B f \\<Longrightarrow> chamber C \\<Longrightarrow> bij_betw f C B\"", "lemma label_wrt_adjacent:\n  assumes \"label_wrt B f\" \"chamber C\" \"chamber D\" \"C\\<sim>D\" \"v\\<in>C-D\" \"w\\<in>D-C\"\n  shows   \"f v = f w\"", "lemma label_wrt_adjacent_shared_facet:\n  \"\\<lbrakk> label_wrt B f; chamber (insert v z); chamber (insert w z); v\\<notin>z; w\\<notin>z \\<rbrakk> \\<Longrightarrow>\n    f v = f w\"", "lemma label_wrt_elt_image: \"label_wrt B f \\<Longrightarrow> v\\<in>\\<Union>X \\<Longrightarrow> f v \\<in> B\"", "lemma (in ChamberComplex) trivial_morphism:\n  \"ChamberComplexMorphism X X id\"", "lemma (in ChamberComplex) inclusion_morphism:\n  assumes \"ChamberSubcomplex Y\"\n  shows   \"ChamberComplexMorphism Y X id\"", "lemmas domain_complex = domain.ChamberComplex_axioms", "lemmas codomain_complex = codomain.ChamberComplex_axioms", "lemmas simplicialcomplex_image = domain.map_is_simplicial_morph[of f]", "lemma cong: \"fun_eq_on g f (\\<Union>X) \\<Longrightarrow> ChamberComplexMorphism X Y g\"", "lemma comp:\n  assumes \"ChamberComplexMorphism Y Z g\"\n  shows   \"ChamberComplexMorphism X Z (g\\<circ>f)\"", "lemma restrict_domain:\n  assumes \"domain.ChamberSubcomplex W\"\n  shows   \"ChamberComplexMorphism W Y f\"", "lemma restrict_codomain:\n  assumes \"codomain.ChamberSubcomplex Z\" \"f\\<turnstile>X \\<subseteq> Z\"\n  shows   \"ChamberComplexMorphism X Z f\"", "lemma inj_on_chamber: \"domain.chamber C \\<Longrightarrow> inj_on f C\"", "lemma bij_betw_chambers: \"domain.chamber C \\<Longrightarrow> bij_betw f C (f`C)\"", "lemma card_map: \"x\\<in>X \\<Longrightarrow> card (f`x) = card x\"", "lemma codim_map:\n  assumes \"domain.chamber C\" \"y \\<subseteq> C\"\n  shows   \"card (f`C - f`y) = card (C-y)\"", "lemma simplex_map: \"x\\<in>X \\<Longrightarrow> f`x\\<in>Y\"", "lemma simplices_map: \"f\\<turnstile>X \\<subseteq> Y\"", "lemma vertex_map: \"x \\<in> \\<Union>X \\<Longrightarrow> f x \\<in> \\<Union>Y\"", "lemma facet_map: \"domain.chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> f`z \\<lhd> f`C\"", "lemma adj_int_im:\n  assumes \"domain.chamber C\" \"domain.chamber D\" \"C \\<sim> D\" \"f`C \\<noteq> f`D\"\n  shows   \"(f`C \\<inter> f`D) \\<lhd> f`C\"", "lemma adj_map':\n  assumes \"domain.chamber C\" \"domain.chamber D\" \"C \\<sim> D\" \"f`C \\<noteq> f`D\"\n  shows   \"f`C \\<sim> f`D\"", "lemma adj_map:\n  \"\\<lbrakk> domain.chamber C; domain.chamber D; C \\<sim> D \\<rbrakk> \\<Longrightarrow> f`C \\<sim> f`D\"", "lemma chamber_vertex_outside_facet_image:\n  assumes \"v\\<notin>z\" \"domain.chamber (insert v z)\"\n  shows   \"f v \\<notin> f`z\"", "lemma expand_codomain:\n  assumes \"ChamberComplex Z\" \"ChamberComplex.ChamberSubcomplex Z Y\"\n  shows   \"ChamberComplexMorphism X Z f\"", "lemma gallery_map: \"domain.gallery Cs \\<Longrightarrow> codomain.gallery (f\\<Turnstile>Cs)\"", "lemma gallery_betw_map:\n  \"domain.gallery (C#Cs@[D]) \\<Longrightarrow> codomain.gallery (f`C # f\\<Turnstile>Cs @ [f`D])\"", "lemma subcomplex_image: \"codomain.Subcomplex (f\\<turnstile>X)\"", "lemmas chamber_in_image = codomain.max_in_subcomplex[OF subcomplex_image]", "lemma maxsimp_map_into_image:\n  assumes \"domain.chamber x\"\n  shows   \"SimplicialComplex.maxsimp (f\\<turnstile>X) (f`x)\"", "lemma maxsimp_preimage:\n  assumes \"C\\<in>X\" \"SimplicialComplex.maxsimp (f\\<turnstile>X) (f`C)\"\n  shows \"domain.chamber C\"", "lemma chamber_preimage:\n  \"C\\<in>X \\<Longrightarrow> codomain.chamber (f`C) \\<Longrightarrow> domain.chamber C\"", "lemma chambercomplex_image: \"ChamberComplex (f\\<turnstile>X)\"", "lemma chambersubcomplex_image: \"codomain.ChamberSubcomplex (f\\<turnstile>X)\"", "lemma restrict_codomain_to_image: \"ChamberComplexMorphism X (f\\<turnstile>X) f\"", "lemma chamber_system_into: \"f\\<turnstile>domain.\\<C> \\<subseteq> codomain.\\<C>\"", "lemma chamber_system_image: \"f\\<turnstile>domain.\\<C> = codomain.\\<C> \\<inter> (f\\<turnstile>X)\"", "lemma image_chamber_system: \"ChamberComplex.\\<C> (f\\<turnstile>X) = f \\<turnstile> domain.\\<C>\"", "lemma image_chamber_system_image:\n  \"ChamberComplex.\\<C> (f\\<turnstile>X) = codomain.\\<C> \\<inter> (f\\<turnstile>X)\"", "lemma face_distance_eq_chamber_distance_map:\n  assumes \"domain.chamber C\" \"domain.chamber D\" \"C\\<noteq>D\" \"z\\<subseteq>C\"\n          \"codomain.face_distance (f`z) (f`D) = domain.face_distance z D\"\n          \"domain.face_distance z D = domain.chamber_distance C D\"\n  shows   \"codomain.face_distance (f`z) (f`D) =\n            codomain.chamber_distance (f`C) (f`D)\"", "lemma face_distance_eq_chamber_distance_min_gallery_betw_map:\n  assumes \"domain.chamber C\" \"domain.chamber D\" \"C\\<noteq>D\" \"z\\<subseteq>C\"\n          \"codomain.face_distance (f`z) (f`D) = domain.face_distance z D\"\n          \"domain.face_distance z D = domain.chamber_distance C D\"\n          \"domain.min_gallery (C#Cs@[D])\"\n  shows   \"codomain.min_gallery (f\\<Turnstile>(C#Cs@[D]))\"", "lemma (in ChamberComplexIsomorphism) inj: \"inj_on f (\\<Union>X)\"", "lemma (in ChamberComplex) trivial_isomorphism:\n  \"ChamberComplexIsomorphism X X id\"", "lemma (in ChamberComplexMorphism) isoI_inverse:\n  assumes \"ChamberComplexMorphism Y X g\"\n          \"fixespointwise (g\\<circ>f) (\\<Union>X)\" \"fixespointwise (f\\<circ>g) (\\<Union>Y)\"\n  shows   \"ChamberComplexIsomorphism X Y f\"", "lemmas domain_complex   = domain_complex", "lemmas chamber_map      = chamber_map", "lemmas dim_map          = dim_map", "lemmas gallery_map      = gallery_map", "lemmas simplex_map      = simplex_map", "lemmas chamber_preimage = chamber_preimage", "lemma chamber_morphism: \"ChamberComplexMorphism X Y f\"", "lemma pgallery_map: \"domain.pgallery Cs \\<Longrightarrow> codomain.pgallery (f\\<Turnstile>Cs)\"", "lemma iso_cong:\n  assumes \"fun_eq_on g f (\\<Union>X)\"\n  shows   \"ChamberComplexIsomorphism X Y g\"", "lemma iso_comp:\n  assumes \"ChamberComplexIsomorphism Y Z g\"\n  shows   \"ChamberComplexIsomorphism X Z (g\\<circ>f)\"", "lemma inj_on_chamber_system: \"inj_on ((`) f) domain.\\<C>\"", "lemma inv: \"ChamberComplexIsomorphism Y X (the_inv_into (\\<Union>X) f)\"", "lemma chamber_distance_map:\n  assumes \"domain.chamber C\" \"domain.chamber D\"\n  shows   \"codomain.chamber_distance (f`C) (f`D) =\n            domain.chamber_distance C D\"", "lemma face_distance_map:\n  assumes \"domain.chamber C\" \"F\\<in>X\"\n  shows   \"codomain.face_distance (f`F) (f`C) = domain.face_distance F C\"", "lemma (in ChamberComplex) trivial_endomorphism:\n  \"ChamberComplexEndomorphism X id\"", "lemmas dim_map                 = dim_map", "lemmas simplex_map             = simplex_map", "lemmas vertex_map              = vertex_map", "lemmas chamber_map             = chamber_map", "lemmas adj_map                 = adj_map", "lemmas facet_map               = facet_map", "lemmas bij_betw_chambers       = bij_betw_chambers", "lemmas chamber_system_into     = chamber_system_into", "lemmas chamber_system_image    = chamber_system_image", "lemmas image_chamber_system    = image_chamber_system", "lemmas chambercomplex_image    = chambercomplex_image", "lemmas chambersubcomplex_image = chambersubcomplex_image", "lemmas face_distance_eq_chamber_distance_map =\n  face_distance_eq_chamber_distance_map", "lemmas face_distance_eq_chamber_distance_min_gallery_betw_map =\n  face_distance_eq_chamber_distance_min_gallery_betw_map", "lemmas facedist_chdist_mingal_btwmap =\n  face_distance_eq_chamber_distance_min_gallery_betw_map", "lemmas trivial_endomorphism     = domain.trivial_endomorphism", "lemmas finite_simplices         = domain.finite_simplices", "lemmas faces                    = domain.faces", "lemmas maxsimp_connect          = domain.maxsimp_connect", "lemmas simplex_in_max           = domain.simplex_in_max", "lemmas chamberD_simplex         = domain.chamberD_simplex", "lemmas chamber_system_def       = domain.chamber_system_def", "lemmas chamber_system_simplices = domain.chamber_system_simplices", "lemmas galleryD_chamber         = domain.galleryD_chamber", "lemmas galleryD_adj             = domain.galleryD_adj", "lemmas gallery_append_reduce1   = domain.gallery_append_reduce1", "lemmas gallery_Cons_reduce      = domain.gallery_Cons_reduce", "lemmas gallery_chamber_system   = domain.gallery_chamber_system", "lemmas label_wrtD               = domain.label_wrtD", "lemmas label_wrt_adjacent       = domain.label_wrt_adjacent", "lemma endo_comp:\n  assumes \"ChamberComplexEndomorphism X g\"\n  shows   \"ChamberComplexEndomorphism X (g\\<circ>f)\"", "lemma restrict_endo:\n  assumes \"ChamberSubcomplex Y\" \"f\\<turnstile>Y \\<subseteq> Y\"\n  shows   \"ChamberComplexEndomorphism Y (restrict1 f (\\<Union>Y))\"", "lemma funpower_endomorphism:\n  \"ChamberComplexEndomorphism X (f^^n)\"", "lemma (in ChamberComplex) fold_chamber_complex_endomorph_list:\n  \"\\<forall>x\\<in>set xs. ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n    ChamberComplexEndomorphism X (fold f xs)\"", "lemma split_gallery:\n  \"\\<lbrakk> C\\<in>f\\<turnstile>\\<C>; D\\<in>\\<C>-f\\<turnstile>\\<C>; gallery (C#Cs@[D]) \\<rbrakk> \\<Longrightarrow>\n    \\<exists>As A B Bs. A\\<in>f\\<turnstile>\\<C> \\<and> B\\<in>\\<C>-f\\<turnstile>\\<C> \\<and> C#Cs@[D] = As@A#B#Bs\"", "lemma respects_labels_adjacent:\n  assumes \"label_wrt B \\<phi>\" \"chamber C\" \"chamber D\" \"C\\<sim>D\" \"\\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\"\n  shows   \"\\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\"", "lemma respects_labels_gallery:\n  assumes \"label_wrt B \\<phi>\" \"\\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\"\n  shows   \"gallery (C#Cs@[D]) \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\"", "lemma respect_label_fix_chamber_imp_fun_eq_on:\n  assumes label  :  \"label_wrt B \\<phi>\"\n  and     chamber:  \"chamber C\" \"f`C = g`C\"\n  and     respect:  \"\\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\" \"\\<forall>v\\<in>C. \\<phi> (g v) = \\<phi> v\"\n  shows   \"fun_eq_on f g C\"", "lemmas respects_label_fixes_chamber_imp_fixespointwise =\n  respect_label_fix_chamber_imp_fun_eq_on[of _ _ _ id, simplified]", "lemma (in ChamberComplex) trivial_automorphism:\n  \"ChamberComplexAutomorphism X id\"", "lemmas facet_map         = facet_map", "lemmas chamber_map       = chamber_map", "lemmas chamber_morphism  = chamber_morphism", "lemmas bij_betw_vertices = bij_betw_vertices", "lemmas surj_simplex_map  = surj_simplex_map", "lemma bij: \"bij f\"", "lemma comp:\n  assumes \"ChamberComplexAutomorphism X g\"\n  shows   \"ChamberComplexAutomorphism X (g\\<circ>f)\"", "lemma equality:\n  assumes \"ChamberComplexAutomorphism X g\" \"fun_eq_on f g (\\<Union>X)\"\n  shows   \"f = g\"", "lemmas simplex_map = simplex_map", "lemmas chamber_map = chamber_map", "lemmas gallery_map = gallery_map", "lemma vertex_retraction: \"v\\<in>f`(\\<Union>X) \\<Longrightarrow> f v = v\"", "lemma simplex_retraction1: \"x\\<in>f\\<turnstile>X \\<Longrightarrow> fixespointwise f x\"", "lemma simplex_retraction2: \"x\\<in>f\\<turnstile>X \\<Longrightarrow> f`x = x\"", "lemma chamber_retraction1: \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> fixespointwise f C\"", "lemma chamber_retraction2: \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> f`C = C\"", "lemma respects_labels:\n  assumes \"label_wrt B \\<phi>\" \"v\\<in>(\\<Union>X)\"\n  shows   \"\\<phi> (f v) = \\<phi> v\"", "lemmas folding_ex          = ex1_implies_ex[OF folding]", "lemmas chamber_system_into = chamber_system_into", "lemmas gallery_map         = gallery_map", "lemmas chamber_retraction1 = chamber_retraction1", "lemmas chamber_retraction2 = chamber_retraction2", "lemma opp_half_apartment_subset_complex: \"Y\\<subseteq>X\"", "lemma simplicialcomplex_opp_half_apartment: \"SimplicialComplex Y\"", "lemma subcomplex_opp_half_apartment: \"Subcomplex Y\"", "lemma opp_half_apartmentI: \"\\<lbrakk> x\\<in>X; C\\<in>\\<C>-f\\<turnstile>\\<C>; x\\<subseteq>C \\<rbrakk> \\<Longrightarrow> x\\<in>Y\"", "lemma opp_chambers_subset_opp_half_apartment: \"\\<C>-f\\<turnstile>\\<C> \\<subseteq> Y\"", "lemma maxsimp_in_opp_half_apartment:\n  assumes \"SimplicialComplex.maxsimp Y C\"\n  shows   \"C \\<in> \\<C>-f\\<turnstile>\\<C>\"", "lemma chamber_in_opp_half_apartment:\n  \"SimplicialComplex.maxsimp Y C \\<Longrightarrow> chamber C\"", "lemma inj_on_opp_chambers':\n  assumes \"chamber C\" \"C\\<notin>f\\<turnstile>X\" \"chamber D\" \"D\\<notin>f\\<turnstile>X\" \"f`C = f`D\"\n  shows   \"C=D\"", "lemma inj_on_opp_chambers'':\n  \"\\<lbrakk> C \\<in> \\<C>-f\\<turnstile>\\<C>; D \\<in> \\<C>-f\\<turnstile>\\<C>; f`C = f`D \\<rbrakk> \\<Longrightarrow> C=D\"", "lemma inj_on_opp_chambers: \"inj_on ((`) f) (\\<C>-f\\<turnstile>\\<C>)\"", "lemma opp_chambers_surj: \"f\\<turnstile>(\\<C>-(f\\<turnstile>\\<C>)) = f\\<turnstile>\\<C>\"", "lemma opp_chambers_bij: \"bij_betw ((`) f) (\\<C>-(f\\<turnstile>\\<C>)) (f\\<turnstile>\\<C>)\"", "lemma folding':\n  assumes \"C\\<in>f\\<turnstile>\\<C>\"\n  shows   \"\\<exists>!D\\<in>\\<C>-f\\<turnstile>\\<C>. f`D = C\"", "lemma opp_chambers_distinct_map:\n  \"set Cs \\<subseteq> \\<C>-f\\<turnstile>\\<C> \\<Longrightarrow> distinct Cs \\<Longrightarrow> distinct (f\\<Turnstile>Cs)\"", "lemma opp_chamberD1: \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> opp_chamber C \\<in> \\<C>-f\\<turnstile>\\<C>\"", "lemma opp_chamberD2: \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> f`(opp_chamber C) = C\"", "lemma opp_chamber_reverse: \"C\\<in>\\<C>-f\\<turnstile>\\<C> \\<Longrightarrow> opp_chamber (f`C) = C\"", "lemma f_opp_chamber_list:\n  \"set Cs \\<subseteq> f\\<turnstile>\\<C> \\<Longrightarrow> f\\<Turnstile>(map opp_chamber Cs) = Cs\"", "lemma flop_chamber: \"chamber C \\<Longrightarrow> chamber (flop C)\"", "lemma facet_unique_other_chamber:\n  \"\\<lbrakk> chamber B; z\\<lhd>B; chamber C; z\\<lhd>C; chamber D; z\\<lhd>D; C\\<noteq>B; D\\<noteq>B \\<rbrakk>\n    \\<Longrightarrow> C=D\"", "lemma finite_adjacentset:\n  assumes \"chamber C\"\n  shows   \"finite (adjacentset C)\"", "lemma label_wrt_eq_on_adjacent_vertex:\n  fixes   v v' :: 'a\n  and     z z' :: \"'a set\"\n  defines D : \"D \\<equiv> insert v z\"\n  and     D': \"D' \\<equiv> insert v' z'\"\n  assumes label   : \"label_wrt B f\" \"f v = f v'\"\n  and     chambers: \"chamber C\" \"chamber D\" \"chamber D'\" \"z\\<lhd>C\" \"z'\\<lhd>C\" \"D\\<noteq>C\" \"D'\\<noteq>C\" \n  shows   \"D = D'\"", "lemma face_distance_eq_chamber_distance_compare_other_chamber:\n  assumes   \"chamber C\" \"chamber D\" \"z\\<lhd>C\" \"z\\<lhd>D\" \"C\\<noteq>D\"\n            \"chamber_distance C E \\<le> chamber_distance D E\"\n  shows     \"face_distance z E = chamber_distance C E\"", "lemma (in ChamberComplexIsomorphism) thinish_image_shared_facet:\n  assumes dom:  \"domain.chamber C\" \"domain.chamber D\" \"z\\<lhd>C\" \"z\\<lhd>D\" \"C\\<noteq>D\"\n  and     cod:  \"ThinishChamberComplex Y\" \"codomain.chamber D'\" \"f`z \\<lhd> D'\"\n                \"D' \\<noteq> f`C\"\n  shows   \"f`D = D'\"", "lemma thinish: \"ThinishChamberComplex X\"", "lemmas face_distance_eq_chamber_distance_compare_other_chamber =\n  face_distance_eq_chamber_distance_compare_other_chamber", "lemma the_adj_chamber_simplex:\n  \"chamber C \\<Longrightarrow> z \\<lhd> C \\<Longrightarrow> the_adj_chamber C z \\<in> X\"", "lemma the_adj_chamber_facet: \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> z \\<lhd> the_adj_chamber C z\"", "lemma the_adj_chamber_is_adjacent:\n  \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> C \\<sim> the_adj_chamber C z\"", "lemma the_adj_chamber:\n  \"chamber C \\<Longrightarrow> z \\<lhd> C \\<Longrightarrow> chamber (the_adj_chamber C z)\"", "lemma the_adj_chamber_neq:\n  \"chamber C \\<Longrightarrow> z \\<lhd> C \\<Longrightarrow> the_adj_chamber C z \\<noteq> C\"", "lemma the_adj_chamber_adjacentset:\n  \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> the_adj_chamber C z \\<in> adjacentset C\"", "lemmas (in ChamberComplexIsomorphism) thin_image_shared_facet =\n  thinish_image_shared_facet[OF _ _ _ _ _ ThinChamberComplex.thinish]", "lemma standard_uniqueness_dbl:\n  assumes morph   : \"ChamberComplexMorphism W X f\"\n                    \"ChamberComplexMorphism W X g\"\n  and     chambers: \"ChamberComplex.chamber W C\"\n                    \"ChamberComplex.chamber W D\"\n                    \"C\\<sim>D\" \"f`D \\<noteq> f`C\" \"g`D \\<noteq> g`C\" \"chamber (g`D)\"\n  and     funeq   : \"fun_eq_on f g C\"\n  shows \"fun_eq_on f g D\"", "lemma standard_uniqueness_pgallery_betw:\n  assumes morph   : \"ChamberComplexMorphism W X f\"\n                    \"ChamberComplexMorphism W X g\"\n  and     chambers: \"fun_eq_on f g C\" \"ChamberComplex.gallery W (C#Cs@[D])\"\n                    \"pgallery (f\\<Turnstile>(C#Cs@[D]))\" \"pgallery (g\\<Turnstile>(C#Cs@[D]))\"\n  shows   \"fun_eq_on f g D\"", "lemma standard_uniqueness:\n  assumes morph   : \"ChamberComplexMorphism W X f\"\n                    \"ChamberComplexMorphism W X g\"\n  and     chamber : \"ChamberComplex.chamber W C\" \"fun_eq_on f g C\"\n  and     map_gals:\n    \"\\<And>Cs. ChamberComplex.min_gallery W (C#Cs) \\<Longrightarrow> pgallery (f\\<Turnstile>(C#Cs))\"\n    \"\\<And>Cs. ChamberComplex.min_gallery W (C#Cs) \\<Longrightarrow> pgallery (g\\<Turnstile>(C#Cs))\"\n  shows   \"fun_eq_on f g (\\<Union>W)\"", "lemma standard_uniqueness_isomorphs:\n  assumes \"ChamberComplexIsomorphism W X f\"\n          \"ChamberComplexIsomorphism W X g\"\n          \"ChamberComplex.chamber W C\" \"fun_eq_on f g C\"\n  shows   \"fun_eq_on f g (\\<Union>W)\"", "lemma standard_uniqueness_automorphs:\n  assumes \"ChamberComplexAutomorphism X f\"\n          \"ChamberComplexAutomorphism X g\"\n          \"chamber C\" \"fun_eq_on f g C\"\n  shows   \"f=g\"", "lemmas standard_uniqueness               = standard_uniqueness", "lemmas standard_uniqueness_isomorphs     = standard_uniqueness_isomorphs", "lemmas standard_uniqueness_pgallery_betw = standard_uniqueness_pgallery_betw", "lemma adjacent_half_chamber_system_image:\n  assumes chambers: \"C \\<in> f\\<turnstile>\\<C>\" \"D \\<in> \\<C>-f\\<turnstile>\\<C>\"\n  and     adjacent: \"C\\<sim>D\"\n  shows   \"f`D = C\"", "lemma adjacent_half_chamber_system_image_reverse:\n  \"\\<lbrakk> C \\<in> f\\<turnstile>\\<C>; D \\<in> \\<C>-f\\<turnstile>\\<C>; C\\<sim>D \\<rbrakk> \\<Longrightarrow> opp_chamber C = D\"", "lemma chamber_image_closer:\n  assumes \"D\\<in>\\<C>-f\\<turnstile>\\<C>\" \"B\\<in>f\\<turnstile>\\<C>\" \"B\\<noteq>f`D\" \"gallery (B#Ds@[D])\"\n  shows   \"\\<exists>Cs. gallery (B#Cs@[f`D]) \\<and> length Cs < length Ds\"", "lemma chamber_image_subset:\n  assumes D: \"D\\<in>\\<C>-f\\<turnstile>\\<C>\"\n  defines C: \"C \\<equiv> f`D\"\n  defines \"closerToC \\<equiv> {B\\<in>\\<C>. chamber_distance B C < chamber_distance B D}\"\n  shows   \"f\\<turnstile>\\<C> \\<subseteq> closerToC\"", "lemma gallery_double_cross_not_minimal_Cons1:\n  \"\\<lbrakk> B\\<in>f\\<turnstile>\\<C>; C\\<in>\\<C>-f\\<turnstile>\\<C>; D\\<in>f\\<turnstile>\\<C>; gallery (B#C#Cs@[D]) \\<rbrakk> \\<Longrightarrow>\n    \\<not> min_gallery (B#C#Cs@[D])\"", "lemma gallery_double_cross_not_minimal1:\n  \"\\<lbrakk> B\\<in>f\\<turnstile>\\<C>; C\\<in>\\<C>-f\\<turnstile>\\<C>; D\\<in>f\\<turnstile>\\<C>; gallery (B#Bs@C#Cs@[D]) \\<rbrakk> \\<Longrightarrow>\n    \\<not> min_gallery (B#Bs@C#Cs@[D])\"", "lemmas adjacent_half_chamber_system_image = adjacent_half_chamber_system_image", "lemmas gallery_double_cross_not_minimal1  = gallery_double_cross_not_minimal1", "lemmas gallery_double_cross_not_minimal_Cons1 =\n  gallery_double_cross_not_minimal_Cons1", "lemma adjacent_preimage:\n  assumes chambers: \"C \\<in> \\<C>-f\\<turnstile>\\<C>\" \"D \\<in> \\<C>-f\\<turnstile>\\<C>\"\n  and     adjacent: \"f`C \\<sim> f`D\"\n  shows \"C \\<sim> D\"", "lemma adjacent_opp_chamber:\n  \"\\<lbrakk> C\\<in>f\\<turnstile>\\<C>; D\\<in>f\\<turnstile>\\<C>; C\\<sim>D \\<rbrakk> \\<Longrightarrow> opp_chamber C \\<sim> opp_chamber D\"", "lemma adjacentchain_preimage: \n  \"set Cs \\<subseteq> \\<C>-f\\<turnstile>\\<C> \\<Longrightarrow> adjacentchain (f\\<Turnstile>Cs) \\<Longrightarrow> adjacentchain Cs\"", "lemma gallery_preimage: \"set Cs \\<subseteq> \\<C>-f\\<turnstile>\\<C> \\<Longrightarrow> gallery (f\\<Turnstile>Cs) \\<Longrightarrow> gallery Cs\"", "lemma chambercomplex_opp_half_apartment: \"ChamberComplex folding.Y\"", "lemma flop_adj:\n  assumes \"chamber C\" \"chamber D\" \"C\\<sim>D\"\n  shows   \"flop C \\<sim> flop D\"", "lemma flop_gallery: \"gallery Cs \\<Longrightarrow> gallery (map flop Cs)\"", "lemma morphism_half_apartments: \"ChamberComplexMorphism folding.Y (f\\<turnstile>X) f\"", "lemma chamber_image_complement_closer:\n  \"\\<lbrakk> D\\<in>\\<C>-f\\<turnstile>\\<C>; B\\<in>\\<C>-f\\<turnstile>\\<C>; B\\<noteq>D; gallery (B#Cs@[f`D]) \\<rbrakk> \\<Longrightarrow>\n      \\<exists>Ds. gallery (B#Ds@[D]) \\<and> length Ds < length Cs\"", "lemma chamber_image_complement_subset:\n  assumes D: \"D\\<in>\\<C>-f\\<turnstile>\\<C>\"\n  defines C: \"C \\<equiv> f`D\"\n  defines \"closerToD \\<equiv> {B\\<in>\\<C>. chamber_distance B D < chamber_distance B C}\"\n  shows   \"\\<C>-f\\<turnstile>\\<C> \\<subseteq> closerToD\"", "lemma chamber_image_and_complement:\n  assumes D: \"D\\<in>\\<C>-f\\<turnstile>\\<C>\"\n  defines C: \"C \\<equiv> f`D\"\n  defines \"closerToC \\<equiv> {B\\<in>\\<C>. chamber_distance B C < chamber_distance B D}\"\n  and     \"closerToD \\<equiv> {B\\<in>\\<C>. chamber_distance B D < chamber_distance B C}\"\n  shows \"f\\<turnstile>\\<C> = closerToC\" \"\\<C>-f\\<turnstile>\\<C> = closerToD\"", "lemmas chamber_D0 = folding_g.chamber_map[OF chambers(1)]", "lemma ThinChamberComplexFolding_f: \"ThinChamberComplexFolding X f\"", "lemma ThinChamberComplexFolding_g: \"ThinChamberComplexFolding X g\"", "lemmas foldf = ThinChamberComplexFolding_f", "lemmas foldg = ThinChamberComplexFolding_g", "lemma fg_symmetric: \"OpposedThinChamberComplexFoldings X g f D0\"", "lemma basechambers_half_chamber_systems: \"C0\\<in>f\\<turnstile>\\<C>\" \"D0\\<in>g\\<turnstile>\\<C>\"", "lemmas basech_halfchsys =\n  basechambers_half_chamber_systems", "lemma f_trivial_C0: \"v\\<in>C0 \\<Longrightarrow> f v = v\"", "lemmas g_trivial_D0 =\n  OpposedThinChamberComplexFoldings.f_trivial_C0[OF fg_symmetric]", "lemma double_fold_D0:\n  assumes \"v \\<in> D0 - C0\"\n  shows   \"g (f v) = v\"", "lemmas double_fold_C0 =\n  OpposedThinChamberComplexFoldings.double_fold_D0[OF fg_symmetric]", "lemma flopped_half_chamber_systems_fg: \"\\<C>-f\\<turnstile>\\<C> = g\\<turnstile>\\<C>\"", "lemmas flopped_half_chamber_systems_gf =\n  OpposedThinChamberComplexFoldings.flopped_half_chamber_systems_fg[\n    OF fg_symmetric\n  ]", "lemma flopped_half_apartments_fg: \"folding_f.opp_half_apartment = g\\<turnstile>X\"", "lemmas flopped_half_apartments_gf =\n  OpposedThinChamberComplexFoldings.flopped_half_apartments_fg[\n    OF fg_symmetric\n  ]", "lemma vertex_set_split: \"\\<Union>X = f`(\\<Union>X) \\<union> g`(\\<Union>X)\"\n\\<comment> \\<open>@{term f} and @{term g} will both be the identity on the intersection\\<close>", "lemma half_chamber_system_disjoint_union:\n  \"\\<C> = f\\<turnstile>\\<C> \\<union> g\\<turnstile>\\<C>\" \"(f\\<turnstile>\\<C>) \\<inter> (g\\<turnstile>\\<C>) = {}\"", "lemmas halfchsys_decomp =\n  half_chamber_system_disjoint_union", "lemma chamber_in_other_half_fg: \"chamber C \\<Longrightarrow> C\\<notin>f\\<turnstile>\\<C> \\<Longrightarrow> C\\<in>g\\<turnstile>\\<C>\"", "lemma adjacent_half_chamber_system_image_fg:\n  \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> D\\<in>g\\<turnstile>\\<C> \\<Longrightarrow> C\\<sim>D \\<Longrightarrow> f`D = C\"", "lemmas adjacent_half_chamber_system_image_gf =\n  OpposedThinChamberComplexFoldings.adjacent_half_chamber_system_image_fg[\n    OF fg_symmetric\n  ]", "lemmas adjhalfchsys_image_gf =\n  adjacent_half_chamber_system_image_gf", "lemma switch_basechamber:\n  assumes \"C\\<in>f\\<turnstile>\\<C>\" \"C\\<sim>g`C\"\n  shows   \"OpposedThinChamberComplexFoldings X f g C\"", "lemma unique_half_chamber_system_f:\n  assumes \"OpposedThinChamberComplexFoldings X f' g' C0\" \"g'`C0 = D0\"\n  shows   \"f'\\<turnstile>\\<C> = f\\<turnstile>\\<C>\"", "lemma unique_half_chamber_system_g:\n  \"OpposedThinChamberComplexFoldings X f' g' C0 \\<Longrightarrow> g'`C0 = D0 \\<Longrightarrow>\n    g'\\<turnstile>\\<C> = g\\<turnstile>\\<C>\"", "lemma split_gallery_fg:\n  \"\\<lbrakk> C\\<in>f\\<turnstile>\\<C>; D\\<in>g\\<turnstile>\\<C>; gallery (C#Cs@[D]) \\<rbrakk> \\<Longrightarrow>\n    \\<exists>As A B Bs. A\\<in>f\\<turnstile>\\<C> \\<and> B\\<in>g\\<turnstile>\\<C> \\<and> C#Cs@[D] = As@A#B#Bs\"", "lemmas split_gallery_gf =\n  OpposedThinChamberComplexFoldings.split_gallery_fg[OF fg_symmetric]", "lemma induced_automorphism_fg_symmetric:\n  \"\\<s> = OpposedThinChamberComplexFoldings.\\<s> X g f\"", "lemma induced_automorphism_on_simplices_fg: \"x\\<in>f\\<turnstile>X \\<Longrightarrow> v\\<in>x \\<Longrightarrow> \\<s> v = g v\"", "lemma induced_automorphism_eq_foldings_on_chambers_fg:\n  \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> fun_eq_on \\<s> g C\"", "lemmas indaut_eq_foldch_fg =\n  induced_automorphism_eq_foldings_on_chambers_fg", "lemma induced_automorphism_eq_foldings_on_chambers_gf:\n  \"C\\<in>g\\<turnstile>\\<C> \\<Longrightarrow> fun_eq_on \\<s> f C\"", "lemma induced_automorphism_on_chamber_vertices_f:\n  \"chamber C \\<Longrightarrow> v\\<in>C \\<Longrightarrow> \\<s> v = (if C\\<in>f\\<turnstile>\\<C> then g v else f v)\"", "lemma induced_automorphism_simplex_image:\n  \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> x\\<subseteq>C \\<Longrightarrow> \\<s>`x = g`x\" \"C\\<in>g\\<turnstile>\\<C> \\<Longrightarrow> x\\<subseteq>C \\<Longrightarrow> \\<s>`x = f`x\"", "lemma induced_automorphism_chamber_list_image_fg:\n  \"set Cs \\<subseteq> f\\<turnstile>\\<C> \\<Longrightarrow> \\<s>\\<Turnstile>Cs = g\\<Turnstile>Cs\"", "lemma induced_automorphism_chamber_image_fg:\n  \"chamber C \\<Longrightarrow> \\<s>`C = (if C\\<in>f\\<turnstile>\\<C> then g`C else f`C)\"", "lemma induced_automorphism_C0: \"\\<s>`C0 = D0\"", "lemma induced_automorphism_fixespointwise_C0_int_D0:\n  \"fixespointwise \\<s> (C0\\<inter>D0)\"", "lemmas indaut_fixes_fundfacet =\n  induced_automorphism_fixespointwise_C0_int_D0", "lemma induced_automorphism_adjacent_half_chamber_system_image_fg:\n  \"\\<lbrakk> C\\<in>f\\<turnstile>\\<C>; D\\<in>g\\<turnstile>\\<C>; C\\<sim>D \\<rbrakk> \\<Longrightarrow> \\<s>`D = C\"", "lemmas indaut_adj_halfchsys_im_fg =\n  induced_automorphism_adjacent_half_chamber_system_image_fg", "lemma induced_automorphism_chamber_map: \"chamber C \\<Longrightarrow> chamber (\\<s>`C)\"", "lemmas indaut_chmap = induced_automorphism_chamber_map", "lemma induced_automorphism_ntrivial: \"\\<s> \\<noteq> id\"", "lemma induced_automorphism_bij_between_half_chamber_systems_f:\n  \"bij_betw ((`) \\<s>) (\\<C>-f\\<turnstile>\\<C>) (f\\<turnstile>\\<C>)\"", "lemmas indaut_bij_btw_halfchsys_f =\n  induced_automorphism_bij_between_half_chamber_systems_f", "lemma induced_automorphism_bij_between_half_chamber_systems_g:\n  \"bij_betw ((`) \\<s>) (\\<C>-g\\<turnstile>\\<C>) (g\\<turnstile>\\<C>)\"", "lemma induced_automorphism_halfmorphism_fopp_to_fimage:\n  \"ChamberComplexMorphism folding_f.opp_half_apartment (f\\<turnstile>X) \\<s>\"", "lemmas indaut_halfmorph_fopp_fim =\n  induced_automorphism_halfmorphism_fopp_to_fimage", "lemma induced_automorphism_half_chamber_system_gallery_map_f:\n  \"set Cs \\<subseteq> f\\<turnstile>\\<C> \\<Longrightarrow> gallery Cs \\<Longrightarrow> gallery (\\<s>\\<Turnstile>Cs)\"", "lemma induced_automorphism_half_chamber_system_pgallery_map_f:\n  \"set Cs \\<subseteq> f\\<turnstile>\\<C> \\<Longrightarrow> pgallery Cs \\<Longrightarrow> pgallery (\\<s>\\<Turnstile>Cs)\"", "lemmas indaut_halfchsys_pgal_map_f =\n  induced_automorphism_half_chamber_system_pgallery_map_f", "lemma induced_automorphism_half_chamber_system_pgallery_map_g:\n  \"set Cs \\<subseteq> g\\<turnstile>\\<C> \\<Longrightarrow> pgallery Cs \\<Longrightarrow> pgallery (\\<s>\\<Turnstile>Cs)\"", "lemma induced_automorphism_halfmorphism_fimage_to_fopp:\n  \"ChamberComplexMorphism (f\\<turnstile>X) folding_f.opp_half_apartment \\<s>\"", "lemma induced_automorphism_selfcomp_halfmorphism_f:\n  \"ChamberComplexMorphism (f\\<turnstile>X) (f\\<turnstile>X) (\\<s>\\<circ>\\<s>)\"", "lemma induced_automorphism_selfcomp_halftrivial_f: \"fixespointwise (\\<s>\\<circ>\\<s>) (\\<Union>(f\\<turnstile>X))\"", "lemmas indaut_selfcomp_halftriv_f =\n  induced_automorphism_selfcomp_halftrivial_f", "lemma induced_automorphism_selfcomp_halftrivial_g: \"fixespointwise (\\<s>\\<circ>\\<s>) (\\<Union>(g\\<turnstile>X))\"", "lemma induced_automorphism_trivial_outside:\n  assumes \"v\\<notin>\\<Union>X\"\n  shows   \"\\<s> v = v\"", "lemma induced_automorphism_morphism: \"ChamberComplexEndomorphism X \\<s>\"", "lemmas indaut_morph = induced_automorphism_morphism", "lemma induced_automorphism_morphism_order2: \"\\<s>\\<circ>\\<s> = id\"", "lemmas indaut_order2 = induced_automorphism_morphism_order2", "lemmas induced_automorphism_bij =\n  o_bij[OF\n    induced_automorphism_morphism_order2\n    induced_automorphism_morphism_order2\n  ]", "lemma induced_automorphism_surj_on_vertexset: \"\\<s>`(\\<Union>X) = \\<Union>X\"", "lemma induced_automorphism_bij_betw_vertexset: \"bij_betw \\<s> (\\<Union>X) (\\<Union>X)\"", "lemma induced_automorphism_surj_on_simplices: \"\\<s>\\<turnstile>X = X\"", "lemma induced_automorphism_automorphism:\n  \"ChamberComplexAutomorphism X \\<s>\"", "lemmas indaut_aut = induced_automorphism_automorphism", "lemma induced_automorphism_unique_automorphism':\n  assumes \"ChamberComplexAutomorphism X s\" \"s\\<noteq>id\" \"fixespointwise s (C0\\<inter>D0)\"\n  shows   \"fun_eq_on s \\<s> C0\"", "lemma induced_automorphism_unique_automorphism:\n  \"\\<lbrakk> ChamberComplexAutomorphism X s; s\\<noteq>id; fixespointwise s (C0\\<inter>D0) \\<rbrakk>\n    \\<Longrightarrow> s = \\<s>\"", "lemmas indaut_uniq_aut =\n  induced_automorphism_unique_automorphism", "lemma induced_automorphism_unique:\n  \"OpposedThinChamberComplexFoldings X f' g' C0 \\<Longrightarrow> g'`C0 = g`C0 \\<Longrightarrow>\n    OpposedThinChamberComplexFoldings.induced_automorphism X f' g' = \\<s>\"", "lemma induced_automorphism_sym:\n  \"OpposedThinChamberComplexFoldings.induced_automorphism X g f = \\<s>\"", "lemma induced_automorphism_respects_labels:\n  assumes \"label_wrt B \\<phi>\" \"v\\<in>(\\<Union>X)\"\n  shows   \"\\<phi> (\\<s> v) = \\<phi> v\"", "lemmas indaut_resplabels =\n  induced_automorphism_respects_labels", "lemma foldpairs_sym: \"(f,g)\\<in>foldpairs \\<Longrightarrow> (g,f)\\<in>foldpairs\"", "lemma not_self_separated_by_wall: \"H\\<in>walls \\<Longrightarrow> \\<not> separated_by H C C\"", "lemma the_wall_betw_nempty:\n  assumes \"the_wall_betw C D \\<noteq> {}\"\n  shows   \"the_wall_betw C D \\<in> walls\" \"separated_by (the_wall_betw C D) C D\"", "lemma the_wall_betw_self_empty: \"the_wall_betw C C = {}\"", "lemma length_wall_crossings: \"length (wall_crossings Cs) = length Cs - 1\"", "lemma wall_crossings_snoc:\n  \"wall_crossings (Cs@[D,E]) = wall_crossings (Cs@[D]) @ [the_wall_betw D E]\"", "lemma wall_crossings_are_walls:\n  \"H\\<in>set (wall_crossings Cs) \\<Longrightarrow> H\\<noteq>{} \\<Longrightarrow> H\\<in>walls\"", "lemma in_set_wall_crossings_decomp:\n  \"H\\<in>set (wall_crossings Cs) \\<Longrightarrow>\n    \\<exists>As A B Bs. Cs = As@[A,B]@Bs \\<and> H = the_wall_betw A B\"", "lemma foldpair: \"(f,g)\\<in>foldpairs\"", "lemma separated_by_this_wall_fg:\n  \"separated_by {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} C D \\<Longrightarrow> C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> D\\<in>g\\<turnstile>\\<C>\"", "lemmas separated_by_this_wall_gf =\n  OpposedThinChamberComplexFoldings.separated_by_this_wall_fg[\n    OF fg_symmetric\n  ]", "lemma induced_automorphism_this_wall_vertex:\n  assumes \"C\\<in>f\\<turnstile>\\<C>\" \"D\\<in>g\\<turnstile>\\<C>\" \"v\\<in>C\\<inter>D\"\n  shows   \"\\<s> v = v\"", "lemmas indaut_wallvertex =\n  induced_automorphism_this_wall_vertex", "lemma unique_wall:\n  assumes opp'    : \"OpposedThinChamberComplexFoldings X f' g' C'\"\n  and     chambers: \"A\\<in>f\\<turnstile>\\<C>\" \"A\\<in>f'\\<turnstile>\\<C>\" \"B\\<in>g\\<turnstile>\\<C>\" \"B\\<in>g'\\<turnstile>\\<C>\" \"A\\<sim>B\"\n  shows   \"{f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} = {f'\\<turnstile>\\<C>,g'\\<turnstile>\\<C>}\"", "lemma separated_by_wall_ex_foldpair:\n  assumes \"H\\<in>walls\" \"separated_by H C D\"\n  shows   \"\\<exists>(f,g)\\<in>foldpairs. H = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} \\<and> C\\<in>f\\<turnstile>\\<C> \\<and> D\\<in>g\\<turnstile>\\<C>\"", "lemma not_separated_by_wall_ex_foldpair:\n  assumes chambers: \"chamber C\" \"chamber D\"\n  and     wall    : \"H\\<in>walls\" \"\\<not> separated_by H C D\"\n  shows   \"\\<exists>(f,g)\\<in>foldpairs. H = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} \\<and> C\\<in>f\\<turnstile>\\<C> \\<and> D\\<in>f\\<turnstile>\\<C>\"", "lemma adj_wall_imp_ex1_wall:\n  assumes adj : \"C\\<sim>D\"\n  and     wall: \"H0\\<in>walls\" \"separated_by H0 C D\"\n  shows \"\\<exists>!H\\<in>walls. separated_by H C D\"", "lemma this_wall_betwI:\n  assumes \"C\\<in>f\\<turnstile>\\<C>\" \"D\\<in>g\\<turnstile>\\<C>\" \"C\\<sim>D\"\n  shows   \"the_wall_betw C D = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\"", "lemma this_wall_betw_basechambers:\n  \"the_wall_betw C0 D0 = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\"", "lemma this_wall_in_crossingsI_fg:\n  defines H: \"H \\<equiv> {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\"\n  assumes D: \"D\\<in>g\\<turnstile>\\<C>\"\n  shows   \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> gallery (C#Cs@[D]) \\<Longrightarrow> H \\<in> set (wall_crossings (C#Cs@[D]))\"", "lemma (in ThinChamberComplex) walls_betw_subset_wall_crossings:\n  assumes \"gallery (C#Cs@[D])\"\n  shows   \"walls_betw C D \\<subseteq> set (wall_crossings (C#Cs@[D]))\"", "lemma same_side_this_wall_wall_crossings_not_distinct_f:\n  \"gallery (C#Cs@[D]) \\<Longrightarrow> C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> D\\<in>f\\<turnstile>\\<C> \\<Longrightarrow>\n    {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\\<in>set (wall_crossings (C#Cs@[D])) \\<Longrightarrow>\n    \\<not> distinct (wall_crossings (C#Cs@[D]))\"", "lemmas sside_wcrossings_ndistinct_f =\n  same_side_this_wall_wall_crossings_not_distinct_f", "lemma separated_by_this_wall_chain3_fg:\n  assumes \"B\\<in>f\\<turnstile>\\<C>\" \"chamber C\" \"chamber D\"\n          \"separated_by {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} B C\" \"separated_by {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} C D\"\n  shows   \"C\\<in>g\\<turnstile>\\<C>\" \"D\\<in>f\\<turnstile>\\<C>\"", "lemmas sepwall_chain3_fg =\n  separated_by_this_wall_chain3_fg", "lemma wall_crossings_min_gallery_betwI:\n  assumes \"gallery (C#Cs@[D])\"\n          \"distinct (wall_crossings (C#Cs@[D]))\"\n          \"\\<forall>H\\<in>set (wall_crossings (C#Cs@[D])). separated_by H C D\"\n  shows   \"min_gallery (C#Cs@[D])\"", "lemma ex_nonseparating_wall_imp_wall_crossings_not_distinct:\n  assumes gal : \"gallery (C#Cs@[D])\"\n  and     wall: \"H\\<in>set (wall_crossings (C#Cs@[D]))\" \"H\\<noteq>{}\"\n                \"\\<not> separated_by H C D\"\n  shows   \"\\<not> distinct (wall_crossings (C#Cs@[D]))\"", "lemma not_min_gallery_double_crosses_wall:\n  assumes \"gallery Cs\" \"\\<not> min_gallery Cs\" \"{} \\<notin> set (wall_crossings Cs)\"\n  shows   \"\\<not> distinct (wall_crossings Cs)\"", "lemma not_distinct_crossings_split_gallery:\n  \"\\<lbrakk> gallery Cs; {} \\<notin> set (wall_crossings Cs); \\<not> distinct (wall_crossings Cs) \\<rbrakk> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n      (f,g)\\<in>foldpairs \\<and> A\\<in>f\\<turnstile>\\<C> \\<and> B\\<in>g\\<turnstile>\\<C> \\<and> E\\<in>g\\<turnstile>\\<C> \\<and> F\\<in>f\\<turnstile>\\<C> \\<and>\n      ( Cs = As@[A,B,F]@Fs \\<or> Cs = As@[A,B]@Bs@[E,F]@Fs )\"", "lemma not_min_gallery_double_split:\n  \"\\<lbrakk> gallery Cs; \\<not> min_gallery Cs; {} \\<notin> set (wall_crossings Cs) \\<rbrakk> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n      (f,g)\\<in>foldpairs \\<and> A\\<in>f\\<turnstile>\\<C> \\<and> B\\<in>g\\<turnstile>\\<C> \\<and> E\\<in>g\\<turnstile>\\<C> \\<and> F\\<in>f\\<turnstile>\\<C> \\<and>\n      ( Cs = As@[A,B,F]@Fs \\<or> Cs = As@[A,B]@Bs@[E,F]@Fs )\"", "lemma (in ThinChamberComplex) ThinChamberComplexManyFoldingsI:\n  assumes \"chamber C0\"\n  and     \"\\<And>C D. \\<lbrakk> chamber C; chamber D; C\\<sim>D; C\\<noteq>D \\<rbrakk> \\<Longrightarrow>\n            \\<exists>f g. OpposedThinChamberComplexFoldings X f g C \\<and> D=g`C\"\n  shows   \"ThinChamberComplexManyFoldings X C0\"", "lemma (in ThinChamberComplexManyFoldings) wall_crossings_subset_walls_betw:\n  assumes \"min_gallery (C#Cs@[D])\"\n  shows   \"set (wall_crossings (C#Cs@[D])) \\<subseteq> walls_betw C D\"", "lemma fundfoldpairs_induced_autormorph_bij:\n  \"(f,g) \\<in> fundfoldpairs \\<Longrightarrow> bij (induced_automorph f g)\"", "lemmas permutation_conv_induced_automorph =\n  Abs_permutation_inverse[OF CollectI, OF fundfoldpairs_induced_autormorph_bij]", "lemma fundfoldpairs_induced_autormorph_order2:\n  \"(f,g) \\<in> fundfoldpairs \\<Longrightarrow> induced_automorph f g \\<circ> induced_automorph f g = id\"", "lemma fundfoldpairs_induced_autormorph_ntrivial:\n  \"(f,g) \\<in> fundfoldpairs \\<Longrightarrow> induced_automorph f g \\<noteq> id\"", "lemma fundfoldpairs_fundchamber_image:\n  \"(f,g)\\<in>fundfoldpairs \\<Longrightarrow> Abs_induced_automorph f g `\\<rightarrow> C0 = g`C0\"", "lemma fundfoldpair_fundchamber_in_half_chamber_system_f:\n  \"(f,g)\\<in>fundfoldpairs \\<Longrightarrow> C0\\<in>f\\<turnstile>\\<C>\"", "lemma fundfoldpair_unique_half_chamber_system_f:\n  assumes \"(f,g)\\<in>fundfoldpairs\" \"(f',g')\\<in>fundfoldpairs\"\n          \"Abs_induced_automorph f' g' = Abs_induced_automorph f g\"\n  shows   \"f'\\<turnstile>\\<C> = f\\<turnstile>\\<C>\"", "lemma fundfoldpair_unique_half_chamber_systems_chamber_ng_f:\n  assumes \"(f,g)\\<in>fundfoldpairs\" \"(f',g')\\<in>fundfoldpairs\"\n          \"Abs_induced_automorph f' g' = Abs_induced_automorph f g\"\n          \"chamber C\" \"C\\<notin>g\\<turnstile>\\<C>\"\n  shows   \"C\\<in>f'\\<turnstile>\\<C>\"", "lemma the_wall_betw_adj_fundchamber:\n  \"(f,g)\\<in>fundfoldpairs \\<Longrightarrow>\n    the_wall_betw C0 (Abs_induced_automorph f g `\\<rightarrow> C0) = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\"", "lemma zero_notin_S: \"0\\<notin>S\"", "lemma S_order2_add: \"s\\<in>S \\<Longrightarrow> s + s = 0\"", "lemma S_add_order2:\n  assumes \"s\\<in>S\"\n  shows   \"add_order s = 2\"", "lemmas S_uminus = minus_unique[OF S_order2_add]", "lemma S_sym: \"uminus ` S \\<subseteq> S\"", "lemmas sum_list_S_in_W  = sum_list_lists_in_genby_sym[OF S_sym]", "lemmas W_conv_sum_lists = genby_sym_eq_sum_lists[OF S_sym]", "lemma S_endomorphism:\n  \"s\\<in>S \\<Longrightarrow> ChamberComplexEndomorphism X (permutation s)\"", "lemma S_list_endomorphism:\n  \"ss\\<in>lists S \\<Longrightarrow> ChamberComplexEndomorphism X (permutation (sum_list ss))\"", "lemma W_endomorphism:\n  \"w\\<in>W \\<Longrightarrow> ChamberComplexEndomorphism X (permutation w)\"", "lemma S_automorphism:\n  \"s\\<in>S \\<Longrightarrow> ChamberComplexAutomorphism X (permutation s)\"", "lemma S_list_automorphism:\n  \"ss\\<in>lists S \\<Longrightarrow> ChamberComplexAutomorphism X (permutation (sum_list ss))\"", "lemma W_automorphism:\n  \"w\\<in>W \\<Longrightarrow> ChamberComplexAutomorphism X (permutation w)\"", "lemma S_respects_labels: \"\\<lbrakk> label_wrt B \\<phi>; s\\<in>S; v\\<in>(\\<Union>X) \\<rbrakk> \\<Longrightarrow> \\<phi> (s \\<rightarrow> v) = \\<phi> v\"", "lemma S_list_respects_labels:\n  \"\\<lbrakk> label_wrt B \\<phi>; ss\\<in>lists S; v\\<in>(\\<Union>X) \\<rbrakk> \\<Longrightarrow> \\<phi> (sum_list ss \\<rightarrow> v) = \\<phi> v\"", "lemma W_respects_labels:\n  \"\\<lbrakk> label_wrt B \\<phi>; w\\<in>W; v\\<in>(\\<Union>X) \\<rbrakk> \\<Longrightarrow> \\<phi> (w\\<rightarrow>v) = \\<phi> v\"", "lemma fundchamber_S_chamber: \"s\\<in>S \\<Longrightarrow> chamber (s`\\<rightarrow>C0)\"", "lemma fundchamber_W_image_chamber:\n  \"w\\<in>W \\<Longrightarrow> chamber (w`\\<rightarrow>C0)\"", "lemma fundchamber_S_adjacent: \"s\\<in>S \\<Longrightarrow> C0 \\<sim> (s`\\<rightarrow>C0)\"", "lemma fundchamber_WS_image_adjacent:\n  \"w\\<in>W \\<Longrightarrow> s\\<in>S \\<Longrightarrow> (w`\\<rightarrow>C0) \\<sim> ((w+s)`\\<rightarrow>C0)\"", "lemma fundchamber_S_image_neq_fundchamber: \"s\\<in>S \\<Longrightarrow> s`\\<rightarrow>C0 \\<noteq> C0\"", "lemma fundchamber_next_WS_image_neq:\n  assumes \"s\\<in>S\"\n  shows   \"(w+s) `\\<rightarrow> C0 \\<noteq> w `\\<rightarrow> C0\"", "lemma fundchamber_S_fundadjset: \"s\\<in>S \\<Longrightarrow> s`\\<rightarrow>C0 \\<in> fundadjset\"", "lemma fundadjset_eq_S_image: \"D\\<in>fundadjset \\<Longrightarrow> \\<exists>s\\<in>S. D = s`\\<rightarrow>C0\"", "lemma S_fixespointwise_fundchamber_image_int:\n  assumes \"s\\<in>S\"\n  shows   \"fixespointwise ((\\<rightarrow>) s) (C0\\<inter>s`\\<rightarrow>C0)\"", "lemma S_fixes_fundchamber_image_int:\n  \"s\\<in>S \\<Longrightarrow> s`\\<rightarrow>(C0\\<inter>s`\\<rightarrow>C0) = C0\\<inter>s`\\<rightarrow>C0\"", "lemma fundfacets:\n  assumes \"s\\<in>S\"\n  shows   \"C0\\<inter>s`\\<rightarrow>C0 \\<lhd> C0\" \"C0\\<inter>s`\\<rightarrow>C0 \\<lhd> s`\\<rightarrow>C0\"", "lemma fundadjset_ex1_eq_S_image:\n  assumes \"D\\<in>fundadjset\"\n  shows   \"\\<exists>!s\\<in>S. D = s`\\<rightarrow>C0\"", "lemma fundchamber_S_image_inj_on: \"inj_on (\\<lambda>s. s`\\<rightarrow>C0) S\"", "lemma S_list_image_gallery:\n  \"ss\\<in>lists S \\<Longrightarrow> gallery (map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss))\"", "lemma pgallery_last_eq_W_image:\n  \"pgallery (C0#Cs@[C]) \\<Longrightarrow> \\<exists>w\\<in>W. C = w`\\<rightarrow>C0\"", "lemma chamber_eq_W_image:\n  assumes \"chamber C\"\n  shows   \"\\<exists>w\\<in>W. C = w`\\<rightarrow>C0\"", "lemma S_list_image_crosses_walls:\n  \"ss \\<in> lists S \\<Longrightarrow> {} \\<notin> set (wall_crossings (map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss)))\"", "lemma Spair_fundfoldpair: \"s\\<in>S \\<Longrightarrow> Spair s \\<in> fundfoldpairs\"", "lemma Spair_induced_automorph:\n  \"s\\<in>S \\<Longrightarrow> s = case_prod Abs_induced_automorph (Spair s)\"", "lemma S_list_pgallery_decomp1:\n  assumes ss: \"set ss = S\" and gal: \"Cs\\<noteq>[]\" \"pgallery (C0#Cs)\"\n  shows   \"\\<exists>s\\<in>set ss. \\<exists>C\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n            s = Abs_induced_automorph f g \\<longrightarrow> C \\<in> g\\<turnstile>\\<C>\"", "lemma S_list_pgallery_decomp2:\n  assumes \"set ss = S\" \"Cs\\<noteq>[]\" \"pgallery (C0#Cs)\"\n  shows\n    \"\\<exists>rs s ts. ss = rs@s#ts \\<and>\n      (\\<exists>C\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow> C \\<in> g\\<turnstile>\\<C>) \\<and>\n        (\\<forall>r\\<in>set rs. \\<forall>C\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n          r = Abs_induced_automorph f g \\<longrightarrow> C\\<in>f\\<turnstile>\\<C>)\"", "lemma S_list_pgallery_decomp3:\n  assumes \"set ss = S\" \"Cs\\<noteq>[]\" \"pgallery (C0#Cs)\"\n  shows\n    \"\\<exists>rs s ts As B Bs. ss = rs@s#ts \\<and> Cs = As@B#Bs \\<and>\n      (\\<forall>(f,g)\\<in>fundfoldpairs. s = Abs_induced_automorph f g \\<longrightarrow> B\\<in>g\\<turnstile>\\<C>) \\<and>\n      (\\<forall>A\\<in>set As. \\<forall>(f,g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow> A\\<in>f\\<turnstile>\\<C>) \\<and>\n      (\\<forall>r\\<in>set rs. \\<forall>C\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow> C\\<in>f\\<turnstile>\\<C>)\"", "lemma fundfold_trivial_f\\<C>:\n  \"r\\<in>S \\<Longrightarrow> \\<forall>(f,g)\\<in>fundfoldpairs. r = Abs_induced_automorph f g \\<longrightarrow> C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow>\n    fst (Spair r) ` C = C\"", "lemma fundfold_comp_trivial_f\\<C>:\n  \"set rs \\<subseteq> S \\<Longrightarrow>\n    \\<forall>r\\<in>set rs. \\<forall>(f,g)\\<in>fundfoldpairs.\n      r = Abs_induced_automorph f g \\<longrightarrow> C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow>\n    fold fst (map Spair rs) ` C = C\"", "lemma fundfold_trivial_f\\<C>_list:\n  \"r\\<in>S \\<Longrightarrow>\n    \\<forall>C\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n      r = Abs_induced_automorph f g \\<longrightarrow> C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow>\n    fst (Spair r) \\<Turnstile> Cs = Cs\"", "lemma fundfold_comp_trivial_f\\<C>_list:\n  \"set rs \\<subseteq> S \\<Longrightarrow>\n    \\<forall>r\\<in>set rs. \\<forall>C\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n      r = Abs_induced_automorph f g \\<longrightarrow> C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow>\n    fold fst (map Spair rs) \\<Turnstile> Cs = Cs\"", "lemma fundfold_gallery_map:\n  \"s\\<in>S \\<Longrightarrow> gallery Cs \\<Longrightarrow> gallery (fst (Spair s) \\<Turnstile> Cs)\"", "lemma fundfold_comp_gallery_map:\n  assumes pregal: \"gallery Cs\"\n  shows   \"set ss \\<subseteq> S \\<Longrightarrow> gallery (fold fst (map Spair ss) \\<Turnstile> Cs)\"", "lemma fundfold_comp_pgallery_ex_funpow:\n  assumes ss: \"set ss = S\"\n  shows   \"pgallery (C0#Cs@[C]) \\<Longrightarrow>\n            \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\"", "lemma fundfold_comp_chamber_ex_funpow:\n  assumes ss: \"set ss = S\" and C: \"chamber C\"\n  shows   \"\\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\"", "lemma fundfold_comp_fixespointwise_C0:\n  assumes \"set ss \\<subseteq> S\"\n  shows   \"fixespointwise (fold fst (map Spair ss)) C0\"", "lemma fundfold_comp_endomorphism:\n  assumes \"set ss \\<subseteq> S\"\n  shows   \"ChamberComplexEndomorphism X (fold fst (map Spair ss))\"", "lemma finite_S: \"finite S\"", "lemma ex_label_retraction: \"\\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0\"", "lemma ex_label_map: \"\\<exists>\\<phi>. label_wrt C0 \\<phi>\"", "lemma fundchamber_W_image_ker:\n  assumes \"w\\<in>W\" \"w`\\<rightarrow>C0 = C0\"\n  shows   \"w = 0\"", "lemma fundchamber_W_image_inj_on:\n  \"inj_on (\\<lambda>w. w`\\<rightarrow>C0) W\"", "lemma fundantivertex: \"s\\<in>S \\<Longrightarrow> fundantivertex s \\<in> C0-s`\\<rightarrow>C0\"", "lemma fundantivertex_fundchamber_decomp:\n  \"s\\<in>S \\<Longrightarrow> C0 = insert (fundantivertex s) (C0\\<inter>s`\\<rightarrow>C0)\"", "lemma fundantivertex_unstable:\n  \"s\\<in>S \\<Longrightarrow> s \\<rightarrow> fundantivertex s \\<noteq> fundantivertex s\"", "lemma fundantivertex_inj_on: \"inj_on fundantivertex S\"", "lemma fundantivertex_surj_on: \"fundantivertex ` S = C0\"", "lemma fundantivertex_bij_betw: \"bij_betw fundantivertex S C0\"", "lemma card_S_fundchamber: \"card S = card C0\"", "lemma card_S_chamber:\n  \"chamber C \\<Longrightarrow> card C = card S\"", "lemma fundantipermutation1:\n  \"v\\<in>C0 \\<Longrightarrow> fundantipermutation v \\<in> S\"", "lemma facet_ex_third_chamber: \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> \\<exists>E\\<in>X-{C,D}. z\\<lhd>E\"", "lemma some_third_chamberD_facet:\n  \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> z \\<lhd> some_third_chamber C D z\"", "lemma some_third_chamberD_simplex:\n  \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> some_third_chamber C D z \\<in> X\"", "lemma some_third_chamberD_adj:\n  \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> C \\<sim> some_third_chamber C D z\"", "lemma chamber_some_third_chamber:\n  \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> chamber (some_third_chamber C D z)\"", "lemma some_third_chamberD_ne:\n  assumes \"chamber C\" \"z\\<lhd>C\"\n  shows   \"some_third_chamber C D z \\<noteq> C\" \"some_third_chamber C D z \\<noteq> D\""], "translations": [["", "lemmas faces                     = faces"], ["", "lemmas singleton_simplex         = singleton_simplex"], ["", "lemmas chamberI                  = maxsimpI"], ["", "lemmas chamberD_simplex          = maxsimpD_simplex"], ["", "lemmas chamberD_maximal          = maxsimpD_maximal"], ["", "lemmas finite_chamber            = finite_maxsimp"], ["", "lemmas chamber_nempty            = maxsimp_nempty"], ["", "lemmas chamber_vertices          = maxsimp_vertices"], ["", "lemmas gallery_def               = maxsimpchain_def"], ["", "lemmas gallery_snocI             = maxsimpchain_snocI"], ["", "lemmas galleryD_chamber          = maxsimpchainD_maxsimp"], ["", "lemmas galleryD_adj              = maxsimpchainD_adj"], ["", "lemmas gallery_CConsI            = maxsimpchain_CConsI"], ["", "lemmas gallery_Cons_reduce       = maxsimpchain_Cons_reduce"], ["", "lemmas gallery_append_reduce1    = maxsimpchain_append_reduce1"], ["", "lemmas gallery_append_reduce2    = maxsimpchain_append_reduce2"], ["", "lemmas gallery_remdup_adj        = maxsimpchain_remdup_adj"], ["", "lemmas gallery_obtain_pgallery   = maxsimpchain_obtain_pmaxsimpchain"], ["", "lemmas pgallery_def              = pmaxsimpchain_def"], ["", "lemmas pgalleryI_gallery         = pmaxsimpchainI_maxsimpchain"], ["", "lemmas pgalleryD_chamber         = pmaxsimpchainD_maxsimp"], ["", "lemmas pgalleryD_adj             = pmaxsimpchainD_adj"], ["", "lemmas pgalleryD_distinct        = pmaxsimpchainD_distinct"], ["", "lemmas pgallery_Cons_reduce      = pmaxsimpchain_Cons_reduce"], ["", "lemmas pgallery_append_reduce1   = pmaxsimpchain_append_reduce1"], ["", "lemmas pgallery                  = pmaxsimpchain"], ["", "lemmas min_gallery_simps         = min_maxsimpchain.simps"], ["", "lemmas min_galleryI_betw         = min_maxsimpchainI_betw"], ["", "lemmas min_galleryI_betw_compare = min_maxsimpchainI_betw_compare"], ["", "lemmas min_galleryD_min_betw     = min_maxsimpchainD_min_betw"], ["", "lemmas min_galleryD_gallery      = min_maxsimpchainD_maxsimpchain"], ["", "lemmas min_gallery_pgallery      = min_maxsimpchain_pmaxsimpchain"], ["", "lemmas min_gallery_rev           = min_maxsimpchain_rev"], ["", "lemmas min_gallery_adj           = min_maxsimpchain_adj"], ["", "lemmas not_min_galleryI_betw     = not_min_maxsimpchainI_betw"], ["", "lemmas min_gallery_betw_CCons_reduce =\n  min_maxsimpchain_betw_CCons_reduce"], ["", "lemmas min_gallery_betw_uniform_length =\n  min_maxsimpchain_betw_uniform_length"], ["", "lemmas vertex_set_int = vertex_set_int[OF ChamberComplex.axioms(1)]"], ["", "lemma chamber_pconnect:\n  \"\\<lbrakk> x \\<noteq> y; chamber x; chamber y \\<rbrakk> \\<Longrightarrow> \\<exists>xs. pgallery (x#xs@[y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; chamber x; chamber y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs. pgallery (x # xs @ [y])", "using maxsimp_connect[of x y] gallery_obtain_pgallery[of x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<noteq> y; chamber x; chamber y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs. gallery (x # xs @ [y])\n  \\<lbrakk>x \\<noteq> y; gallery (x # ?xs @ [y])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ys.\n                       order.greater_eq (set ?xs) (set ys) \\<and>\n                       order.greater_eq (length ?xs) (length ys) \\<and>\n                       pgallery (x # ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; chamber x; chamber y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs. pgallery (x # xs @ [y])", "by fast"], ["", "lemma supchamberD:\n  assumes \"v\\<in>\\<Union>X\"\n  defines \"C \\<equiv> supchamber v\"\n  shows   \"chamber C\" \"v\\<in>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chamber C &&& v \\<in> C", "using   assms simplex_in_max someI[of \"\\<lambda>C. chamber C \\<and> v\\<in>C\"]"], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> X\n  C \\<equiv> supchamber v\n  ?y \\<in> X \\<Longrightarrow>\n  \\<exists>x. chamber x \\<and> order.greater_eq x ?y\n  chamber ?x \\<and> v \\<in> ?x \\<Longrightarrow>\n  chamber (supchamber v) \\<and> v \\<in> supchamber v\n\ngoal (1 subgoal):\n 1. chamber C &&& v \\<in> C", "by      auto"], ["", "definition\n  \"ChamberSubcomplex Y \\<equiv> Y \\<subseteq> X \\<and> ChamberComplex Y \\<and>\n    (\\<forall>C. ChamberComplex.chamber Y C \\<longrightarrow> chamber C)\""], ["", "lemma ChamberSubcomplexI:\n  assumes \"Y\\<subseteq>X\" \"ChamberComplex Y\"\n          \"\\<And>y. ChamberComplex.chamber Y y \\<Longrightarrow> chamber y\"\n  shows   \"ChamberSubcomplex Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberSubcomplex Y", "using   assms ChamberSubcomplex_def"], ["proof (prove)\nusing this:\n  order.greater_eq X Y\n  ChamberComplex Y\n  SimplicialComplex.maxsimp Y ?y \\<Longrightarrow> chamber ?y\n  ChamberSubcomplex ?Y \\<equiv>\n  order.greater_eq X ?Y \\<and>\n  ChamberComplex ?Y \\<and>\n  (\\<forall>C. SimplicialComplex.maxsimp ?Y C \\<longrightarrow> chamber C)\n\ngoal (1 subgoal):\n 1. ChamberSubcomplex Y", "by      fast"], ["", "lemma ChamberSubcomplexD_sub: \"ChamberSubcomplex Y \\<Longrightarrow> Y \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberSubcomplex Y \\<Longrightarrow> order.greater_eq X Y", "using ChamberSubcomplex_def"], ["proof (prove)\nusing this:\n  ChamberSubcomplex ?Y \\<equiv>\n  order.greater_eq X ?Y \\<and>\n  ChamberComplex ?Y \\<and>\n  (\\<forall>C. SimplicialComplex.maxsimp ?Y C \\<longrightarrow> chamber C)\n\ngoal (1 subgoal):\n 1. ChamberSubcomplex Y \\<Longrightarrow> order.greater_eq X Y", "by fast"], ["", "lemma ChamberSubcomplexD_complex:\n  \"ChamberSubcomplex Y \\<Longrightarrow> ChamberComplex Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberSubcomplex Y \\<Longrightarrow> ChamberComplex Y", "unfolding ChamberSubcomplex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq X Y \\<and>\n    ChamberComplex Y \\<and>\n    (\\<forall>C.\n        SimplicialComplex.maxsimp Y C \\<longrightarrow>\n        chamber C) \\<Longrightarrow>\n    ChamberComplex Y", "by fast"], ["", "lemma chambersub_imp_sub: \"ChamberSubcomplex Y \\<Longrightarrow> Subcomplex Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberSubcomplex Y \\<Longrightarrow>\n    order.greater_eq X Y \\<and> SimplicialComplex Y", "using ChamberSubcomplex_def ChamberComplex.axioms(1)"], ["proof (prove)\nusing this:\n  ChamberSubcomplex ?Y \\<equiv>\n  order.greater_eq X ?Y \\<and>\n  ChamberComplex ?Y \\<and>\n  (\\<forall>C. SimplicialComplex.maxsimp ?Y C \\<longrightarrow> chamber C)\n  ChamberComplex ?X \\<Longrightarrow> SimplicialComplex ?X\n\ngoal (1 subgoal):\n 1. ChamberSubcomplex Y \\<Longrightarrow>\n    order.greater_eq X Y \\<and> SimplicialComplex Y", "by fast"], ["", "lemma chamber_in_subcomplex:\n  \"\\<lbrakk> ChamberSubcomplex Y; C \\<in> Y; chamber C \\<rbrakk> \\<Longrightarrow>\n    ChamberComplex.chamber Y C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ChamberSubcomplex Y; C \\<in> Y; chamber C\\<rbrakk>\n    \\<Longrightarrow> SimplicialComplex.maxsimp Y C", "using chambersub_imp_sub max_in_subcomplex"], ["proof (prove)\nusing this:\n  ChamberSubcomplex ?Y \\<Longrightarrow>\n  order.greater_eq X ?Y \\<and> SimplicialComplex ?Y\n  \\<lbrakk>order.greater_eq X ?Y \\<and> SimplicialComplex ?Y; ?y \\<in> ?Y;\n   chamber ?y\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp ?Y ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ChamberSubcomplex Y; C \\<in> Y; chamber C\\<rbrakk>\n    \\<Longrightarrow> SimplicialComplex.maxsimp Y C", "by simp"], ["", "lemma subcomplex_chamber:\n  \"ChamberSubcomplex Y \\<Longrightarrow> ChamberComplex.chamber Y C \\<Longrightarrow> chamber C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ChamberSubcomplex Y; SimplicialComplex.maxsimp Y C\\<rbrakk>\n    \\<Longrightarrow> chamber C", "unfolding ChamberSubcomplex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq X Y \\<and>\n             ChamberComplex Y \\<and>\n             (\\<forall>C.\n                 SimplicialComplex.maxsimp Y C \\<longrightarrow> chamber C);\n     SimplicialComplex.maxsimp Y C\\<rbrakk>\n    \\<Longrightarrow> chamber C", "by fast"], ["", "lemma gallery_in_subcomplex:\n  \"\\<lbrakk> ChamberSubcomplex Y; set ys \\<subseteq> Y; gallery ys \\<rbrakk> \\<Longrightarrow>\n    ChamberComplex.gallery Y ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ChamberSubcomplex Y; order.greater_eq Y (set ys);\n     gallery ys\\<rbrakk>\n    \\<Longrightarrow> SimplicialComplex.maxsimpchain Y ys", "using chambersub_imp_sub maxsimpchain_in_subcomplex"], ["proof (prove)\nusing this:\n  ChamberSubcomplex ?Y \\<Longrightarrow>\n  order.greater_eq X ?Y \\<and> SimplicialComplex ?Y\n  \\<lbrakk>order.greater_eq X ?Y \\<and> SimplicialComplex ?Y;\n   order.greater_eq ?Y (set ?ys); gallery ?ys\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimpchain ?Y ?ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ChamberSubcomplex Y; order.greater_eq Y (set ys);\n     gallery ys\\<rbrakk>\n    \\<Longrightarrow> SimplicialComplex.maxsimpchain Y ys", "by simp"], ["", "lemma subcomplex_gallery:\n  \"ChamberSubcomplex Y \\<Longrightarrow> ChamberComplex.gallery Y Cs \\<Longrightarrow> gallery Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ChamberSubcomplex Y;\n     SimplicialComplex.maxsimpchain Y Cs\\<rbrakk>\n    \\<Longrightarrow> gallery Cs", "using ChamberSubcomplex_def gallery_def ChamberComplex.gallery_def"], ["proof (prove)\nusing this:\n  ChamberSubcomplex ?Y \\<equiv>\n  order.greater_eq X ?Y \\<and>\n  ChamberComplex ?Y \\<and>\n  (\\<forall>C. SimplicialComplex.maxsimp ?Y C \\<longrightarrow> chamber C)\n  gallery ?xs \\<equiv> Ball (set ?xs) chamber \\<and> adjacentchain ?xs\n  ChamberComplex ?X \\<Longrightarrow>\n  SimplicialComplex.maxsimpchain ?X ?xs \\<equiv>\n  (\\<forall>x\\<in>set ?xs. SimplicialComplex.maxsimp ?X x) \\<and>\n  adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ChamberSubcomplex Y;\n     SimplicialComplex.maxsimpchain Y Cs\\<rbrakk>\n    \\<Longrightarrow> gallery Cs", "by    fastforce"], ["", "lemma subcomplex_pgallery:\n  \"ChamberSubcomplex Y \\<Longrightarrow> ChamberComplex.pgallery Y Cs \\<Longrightarrow> pgallery Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ChamberSubcomplex Y;\n     SimplicialComplex.pmaxsimpchain Y Cs\\<rbrakk>\n    \\<Longrightarrow> pgallery Cs", "using ChamberSubcomplex_def pgallery_def ChamberComplex.pgallery_def"], ["proof (prove)\nusing this:\n  ChamberSubcomplex ?Y \\<equiv>\n  order.greater_eq X ?Y \\<and>\n  ChamberComplex ?Y \\<and>\n  (\\<forall>C. SimplicialComplex.maxsimp ?Y C \\<longrightarrow> chamber C)\n  pgallery ?xs \\<equiv> Ball (set ?xs) chamber \\<and> padjacentchain ?xs\n  ChamberComplex ?X \\<Longrightarrow>\n  SimplicialComplex.pmaxsimpchain ?X ?xs \\<equiv>\n  (\\<forall>x\\<in>set ?xs. SimplicialComplex.maxsimp ?X x) \\<and>\n  padjacentchain ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ChamberSubcomplex Y;\n     SimplicialComplex.pmaxsimpchain Y Cs\\<rbrakk>\n    \\<Longrightarrow> pgallery Cs", "by    fastforce"], ["", "lemma min_gallery_in_subcomplex:\n  assumes \"ChamberSubcomplex Y\" \"min_gallery Cs\" \"set Cs \\<subseteq> Y\"\n  shows   \"ChamberComplex.min_gallery Y Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplex.min_maxsimpchain Y Cs", "proof (cases Cs rule: list_cases_Cons_snoc)"], ["proof (state)\ngoal (3 subgoals):\n 1. Cs = [] \\<Longrightarrow> SimplicialComplex.min_maxsimpchain Y Cs\n 2. \\<And>x.\n       Cs = [x] \\<Longrightarrow> SimplicialComplex.min_maxsimpchain Y Cs\n 3. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       SimplicialComplex.min_maxsimpchain Y Cs", "case Nil"], ["proof (state)\nthis:\n  Cs = []\n\ngoal (3 subgoals):\n 1. Cs = [] \\<Longrightarrow> SimplicialComplex.min_maxsimpchain Y Cs\n 2. \\<And>x.\n       Cs = [x] \\<Longrightarrow> SimplicialComplex.min_maxsimpchain Y Cs\n 3. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       SimplicialComplex.min_maxsimpchain Y Cs", "with assms(1)"], ["proof (chain)\npicking this:\n  ChamberSubcomplex Y\n  Cs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  ChamberSubcomplex Y\n  Cs = []\n\ngoal (1 subgoal):\n 1. SimplicialComplex.min_maxsimpchain Y Cs", "using ChamberSubcomplexD_complex ChamberComplex.min_gallery_simps(1)"], ["proof (prove)\nusing this:\n  ChamberSubcomplex Y\n  Cs = []\n  ChamberSubcomplex ?Y \\<Longrightarrow> ChamberComplex ?Y\n  ChamberComplex ?X \\<Longrightarrow>\n  SimplicialComplex.min_maxsimpchain ?X [] = True\n\ngoal (1 subgoal):\n 1. SimplicialComplex.min_maxsimpchain Y Cs", "by    fast"], ["proof (state)\nthis:\n  SimplicialComplex.min_maxsimpchain Y Cs\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       Cs = [x] \\<Longrightarrow> SimplicialComplex.min_maxsimpchain Y Cs\n 2. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       SimplicialComplex.min_maxsimpchain Y Cs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       Cs = [x] \\<Longrightarrow> SimplicialComplex.min_maxsimpchain Y Cs\n 2. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       SimplicialComplex.min_maxsimpchain Y Cs", "case Single"], ["proof (state)\nthis:\n  Cs = [x_]\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       Cs = [x] \\<Longrightarrow> SimplicialComplex.min_maxsimpchain Y Cs\n 2. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       SimplicialComplex.min_maxsimpchain Y Cs", "with assms"], ["proof (chain)\npicking this:\n  ChamberSubcomplex Y\n  min_gallery Cs\n  order.greater_eq Y (set Cs)\n  Cs = [x_]", "show ?thesis"], ["proof (prove)\nusing this:\n  ChamberSubcomplex Y\n  min_gallery Cs\n  order.greater_eq Y (set Cs)\n  Cs = [x_]\n\ngoal (1 subgoal):\n 1. SimplicialComplex.min_maxsimpchain Y Cs", "using min_galleryD_gallery galleryD_chamber chamber_in_subcomplex\n          ChamberComplex.min_gallery_simps(2) ChamberSubcomplexD_complex"], ["proof (prove)\nusing this:\n  ChamberSubcomplex Y\n  min_gallery Cs\n  order.greater_eq Y (set Cs)\n  Cs = [x_]\n  min_gallery ?xs \\<Longrightarrow> gallery ?xs\n  \\<lbrakk>gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> chamber ?x\n  \\<lbrakk>ChamberSubcomplex ?Y; ?C \\<in> ?Y; chamber ?C\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp ?Y ?C\n  ChamberComplex ?X \\<Longrightarrow>\n  SimplicialComplex.min_maxsimpchain ?X [?x] =\n  SimplicialComplex.maxsimp ?X ?x\n  ChamberSubcomplex ?Y \\<Longrightarrow> ChamberComplex ?Y\n\ngoal (1 subgoal):\n 1. SimplicialComplex.min_maxsimpchain Y Cs", "by    force"], ["proof (state)\nthis:\n  SimplicialComplex.min_maxsimpchain Y Cs\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       SimplicialComplex.min_maxsimpchain Y Cs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       SimplicialComplex.min_maxsimpchain Y Cs", "case (Cons_snoc C Ds D)"], ["proof (state)\nthis:\n  Cs = C # Ds @ [D]\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       SimplicialComplex.min_maxsimpchain Y Cs", "with assms"], ["proof (chain)\npicking this:\n  ChamberSubcomplex Y\n  min_gallery Cs\n  order.greater_eq Y (set Cs)\n  Cs = C # Ds @ [D]", "show ?thesis"], ["proof (prove)\nusing this:\n  ChamberSubcomplex Y\n  min_gallery Cs\n  order.greater_eq Y (set Cs)\n  Cs = C # Ds @ [D]\n\ngoal (1 subgoal):\n 1. SimplicialComplex.min_maxsimpchain Y Cs", "using ChamberSubcomplexD_complex min_gallery_pgallery\n          pgalleryD_distinct[of \"C#Ds@[D]\"] pgallery\n          gallery_in_subcomplex[of Y] subcomplex_gallery\n          min_galleryD_min_betw\n          ChamberComplex.min_galleryI_betw[of Y]"], ["proof (prove)\nusing this:\n  ChamberSubcomplex Y\n  min_gallery Cs\n  order.greater_eq Y (set Cs)\n  Cs = C # Ds @ [D]\n  ChamberSubcomplex ?Y \\<Longrightarrow> ChamberComplex ?Y\n  min_gallery ?xs \\<Longrightarrow> pgallery ?xs\n  pgallery (C # Ds @ [D]) \\<Longrightarrow> distinct (C # Ds @ [D])\n  pgallery ?xs \\<Longrightarrow> gallery ?xs\n  \\<lbrakk>ChamberSubcomplex Y; order.greater_eq Y (set ?ys);\n   gallery ?ys\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimpchain Y ?ys\n  \\<lbrakk>ChamberSubcomplex ?Y;\n   SimplicialComplex.maxsimpchain ?Y ?Cs\\<rbrakk>\n  \\<Longrightarrow> gallery ?Cs\n  \\<lbrakk>min_gallery (?x # ?xs @ [?y]); gallery (?x # ?ys @ [?y])\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length ?ys) (length ?xs)\n  \\<lbrakk>ChamberComplex Y; ?x \\<noteq> ?y;\n   SimplicialComplex.maxsimpchain Y (?x # ?xs @ [?y]);\n   \\<And>ys.\n      SimplicialComplex.maxsimpchain Y (?x # ys @ [?y]) \\<Longrightarrow>\n      order.greater_eq (length ys) (length ?xs)\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.min_maxsimpchain Y (?x # ?xs @ [?y])\n\ngoal (1 subgoal):\n 1. SimplicialComplex.min_maxsimpchain Y Cs", "by    force"], ["proof (state)\nthis:\n  SimplicialComplex.min_maxsimpchain Y Cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chamber_card: \"chamber C \\<Longrightarrow> chamber D \\<Longrightarrow> card C = card D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; chamber D\\<rbrakk> \\<Longrightarrow> card C = card D", "using maxsimp_connect[of C D] galleryD_adj adjacentchain_card"], ["proof (prove)\nusing this:\n  \\<lbrakk>C \\<noteq> D; chamber C; chamber D\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs. gallery (C # xs @ [D])\n  gallery ?xs \\<Longrightarrow> adjacentchain ?xs\n  adjacentchain (?x # ?xs @ [?y]) \\<Longrightarrow> card ?x = card ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; chamber D\\<rbrakk> \\<Longrightarrow> card C = card D", "by    (cases \"C=D\") auto"], ["", "lemma chamber_facet_is_chamber_facet:\n  \"\\<lbrakk> chamber C; chamber D; z\\<lhd>C; z\\<subseteq>D \\<rbrakk> \\<Longrightarrow> z\\<lhd>D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; chamber D; z \\<lhd> C; order.greater_eq D z\\<rbrakk>\n    \\<Longrightarrow> z \\<lhd> D", "using finite_chamber finite_facetrel_card chamber_card[of C]"], ["proof (prove)\nusing this:\n  chamber ?x \\<Longrightarrow> finite ?x\n  \\<lbrakk>finite ?x; ?y \\<lhd> ?x\\<rbrakk>\n  \\<Longrightarrow> card ?x = Suc (card ?y)\n  \\<lbrakk>chamber C; chamber ?D\\<rbrakk> \\<Longrightarrow> card C = card ?D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; chamber D; z \\<lhd> C; order.greater_eq D z\\<rbrakk>\n    \\<Longrightarrow> z \\<lhd> D", "by    (fastforce intro: facetrelI_cardSuc)"], ["", "lemma chamber_adj:\n  assumes \"chamber C\" \"D\\<in>X\" \"C \\<sim> D\"\n  shows   \"chamber D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chamber D", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. chamber D", "from assms(2)"], ["proof (chain)\npicking this:\n  D \\<in> X", "obtain B where B: \"chamber B\" \"D\\<subseteq>B\""], ["proof (prove)\nusing this:\n  D \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>chamber B; order.greater_eq B D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using simplex_in_max"], ["proof (prove)\nusing this:\n  D \\<in> X\n  ?y \\<in> X \\<Longrightarrow>\n  \\<exists>x. chamber x \\<and> order.greater_eq x ?y\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>chamber B; order.greater_eq B D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  chamber B\n  order.greater_eq B D\n\ngoal (1 subgoal):\n 1. chamber D", "with assms(1,3)"], ["proof (chain)\npicking this:\n  chamber C\n  C \\<sim> D\n  chamber B\n  order.greater_eq B D", "show ?thesis"], ["proof (prove)\nusing this:\n  chamber C\n  C \\<sim> D\n  chamber B\n  order.greater_eq B D\n\ngoal (1 subgoal):\n 1. chamber D", "using chamber_card[of B] adjacent_card finite_chamber card_subset_eq[of B D]"], ["proof (prove)\nusing this:\n  chamber C\n  C \\<sim> D\n  chamber B\n  order.greater_eq B D\n  \\<lbrakk>chamber B; chamber ?D\\<rbrakk> \\<Longrightarrow> card B = card ?D\n  ?x \\<sim> ?y \\<Longrightarrow> card ?x = card ?y\n  chamber ?x \\<Longrightarrow> finite ?x\n  \\<lbrakk>finite B; order.greater_eq B D; card D = card B\\<rbrakk>\n  \\<Longrightarrow> D = B\n\ngoal (1 subgoal):\n 1. chamber D", "by    force"], ["proof (state)\nthis:\n  chamber D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chambers_share_facet:\n  assumes \"chamber C\" \"chamber (insert v z)\" \"z\\<lhd>C\"\n  shows   \"z\\<lhd>insert v z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<lhd> insert v z", "proof (rule facetrelI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?v \\<notin> z\n 2. insert v z = insert ?v z", "from assms"], ["proof (chain)\npicking this:\n  chamber C\n  chamber (insert v z)\n  z \\<lhd> C", "show \"v\\<notin>z\""], ["proof (prove)\nusing this:\n  chamber C\n  chamber (insert v z)\n  z \\<lhd> C\n\ngoal (1 subgoal):\n 1. v \\<notin> z", "using finite_chamber[of C] finite_chamber[of \"insert v z\"] card_insert_if[of z v]"], ["proof (prove)\nusing this:\n  chamber C\n  chamber (insert v z)\n  z \\<lhd> C\n  chamber C \\<Longrightarrow> finite C\n  chamber (insert v z) \\<Longrightarrow> finite (insert v z)\n  finite z \\<Longrightarrow>\n  card (insert v z) = (if v \\<in> z then card z else Suc (card z))\n\ngoal (1 subgoal):\n 1. v \\<notin> z", "by    (auto simp add: finite_facetrel_card chamber_card)"], ["proof (state)\nthis:\n  v \\<notin> z\n\ngoal (1 subgoal):\n 1. insert v z = insert v z", "qed simp"], ["", "lemma adjacentset_chamber: \"chamber C \\<Longrightarrow> D\\<in>adjacentset C \\<Longrightarrow> chamber D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; D \\<in> adjacentset C\\<rbrakk>\n    \\<Longrightarrow> chamber D", "using adjacentset_def chamber_adj"], ["proof (prove)\nusing this:\n  adjacentset ?x = {y \\<in> X. ?x \\<sim> y}\n  \\<lbrakk>chamber ?C; ?D \\<in> X; ?C \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> chamber ?D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; D \\<in> adjacentset C\\<rbrakk>\n    \\<Longrightarrow> chamber D", "by fast"], ["", "lemma chamber_shared_facet: \"\\<lbrakk> chamber C; z\\<lhd>C; D\\<in>X; z\\<lhd>D \\<rbrakk> \\<Longrightarrow> chamber D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C; D \\<in> X; z \\<lhd> D\\<rbrakk>\n    \\<Longrightarrow> chamber D", "by (fast intro: chamber_adj adjacentI)"], ["", "lemma adjacentset_conv_facetchambersets:\n  assumes \"X \\<noteq> {{}}\" \"chamber C\"\n  shows   \"adjacentset C = (\\<Union>v\\<in>C. {D\\<in>X. C-{v}\\<lhd>D})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacentset C = (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> adjacentset C \\<Longrightarrow>\n       x \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})\n 2. \\<And>x.\n       x \\<in> (\\<Union>v\\<in>C.\n                   {D \\<in> X. C - {v} \\<lhd> D}) \\<Longrightarrow>\n       x \\<in> adjacentset C", "fix D"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> adjacentset C \\<Longrightarrow>\n       x \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})\n 2. \\<And>x.\n       x \\<in> (\\<Union>v\\<in>C.\n                   {D \\<in> X. C - {v} \\<lhd> D}) \\<Longrightarrow>\n       x \\<in> adjacentset C", "assume D: \"D \\<in> adjacentset C\""], ["proof (state)\nthis:\n  D \\<in> adjacentset C\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> adjacentset C \\<Longrightarrow>\n       x \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})\n 2. \\<And>x.\n       x \\<in> (\\<Union>v\\<in>C.\n                   {D \\<in> X. C - {v} \\<lhd> D}) \\<Longrightarrow>\n       x \\<in> adjacentset C", "show \"D \\<in> (\\<Union>v\\<in>C. {D\\<in>X. C-{v}\\<lhd>D})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "proof (cases \"D=C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. D = C \\<Longrightarrow>\n    D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})\n 2. D \\<noteq> C \\<Longrightarrow>\n    D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "case True"], ["proof (state)\nthis:\n  D = C\n\ngoal (2 subgoals):\n 1. D = C \\<Longrightarrow>\n    D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})\n 2. D \\<noteq> C \\<Longrightarrow>\n    D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "with assms"], ["proof (chain)\npicking this:\n  X \\<noteq> {{}}\n  chamber C\n  D = C", "have \"C \\<noteq> {}\" and \"C \\<in> X\""], ["proof (prove)\nusing this:\n  X \\<noteq> {{}}\n  chamber C\n  D = C\n\ngoal (1 subgoal):\n 1. C \\<noteq> {} &&& C \\<in> X", "using chamber_nempty chamberD_simplex"], ["proof (prove)\nusing this:\n  X \\<noteq> {{}}\n  chamber C\n  D = C\n  \\<lbrakk>X \\<noteq> {{}}; chamber ?x\\<rbrakk>\n  \\<Longrightarrow> ?x \\<noteq> {}\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n\ngoal (1 subgoal):\n 1. C \\<noteq> {} &&& C \\<in> X", "by auto"], ["proof (state)\nthis:\n  C \\<noteq> {}\n  C \\<in> X\n\ngoal (2 subgoals):\n 1. D = C \\<Longrightarrow>\n    D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})\n 2. D \\<noteq> C \\<Longrightarrow>\n    D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "with True assms"], ["proof (chain)\npicking this:\n  D = C\n  X \\<noteq> {{}}\n  chamber C\n  C \\<noteq> {}\n  C \\<in> X", "show ?thesis"], ["proof (prove)\nusing this:\n  D = C\n  X \\<noteq> {{}}\n  chamber C\n  C \\<noteq> {}\n  C \\<in> X\n\ngoal (1 subgoal):\n 1. D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "using facetrel_diff_vertex"], ["proof (prove)\nusing this:\n  D = C\n  X \\<noteq> {{}}\n  chamber C\n  C \\<noteq> {}\n  C \\<in> X\n  ?v \\<in> ?x \\<Longrightarrow> ?x - {?v} \\<lhd> ?x\n\ngoal (1 subgoal):\n 1. D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "by fastforce"], ["proof (state)\nthis:\n  D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})\n\ngoal (1 subgoal):\n 1. D \\<noteq> C \\<Longrightarrow>\n    D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D \\<noteq> C \\<Longrightarrow>\n    D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "case False"], ["proof (state)\nthis:\n  D \\<noteq> C\n\ngoal (1 subgoal):\n 1. D \\<noteq> C \\<Longrightarrow>\n    D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "from D"], ["proof (chain)\npicking this:\n  D \\<in> adjacentset C", "have D': \"C\\<sim>D\""], ["proof (prove)\nusing this:\n  D \\<in> adjacentset C\n\ngoal (1 subgoal):\n 1. C \\<sim> D", "using adjacentsetD_adj"], ["proof (prove)\nusing this:\n  D \\<in> adjacentset C\n  ?y \\<in> adjacentset ?x \\<Longrightarrow> ?x \\<sim> ?y\n\ngoal (1 subgoal):\n 1. C \\<sim> D", "by fast"], ["proof (state)\nthis:\n  C \\<sim> D\n\ngoal (1 subgoal):\n 1. D \\<noteq> C \\<Longrightarrow>\n    D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "with False"], ["proof (chain)\npicking this:\n  D \\<noteq> C\n  C \\<sim> D", "obtain v where v: \"v\\<notin>D\" \"C = insert v (C\\<inter>D)\""], ["proof (prove)\nusing this:\n  D \\<noteq> C\n  C \\<sim> D\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<notin> D; C = insert v (C \\<inter> D)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using adjacent_int_decomp"], ["proof (prove)\nusing this:\n  D \\<noteq> C\n  C \\<sim> D\n  \\<lbrakk>?x \\<sim> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v.\n                       v \\<notin> ?y \\<and> ?x = insert v (?x \\<inter> ?y)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<notin> D; C = insert v (C \\<inter> D)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  v \\<notin> D\n  C = insert v (C \\<inter> D)\n\ngoal (1 subgoal):\n 1. D \\<noteq> C \\<Longrightarrow>\n    D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "hence \"C-{v} = C\\<inter>D\""], ["proof (prove)\nusing this:\n  v \\<notin> D\n  C = insert v (C \\<inter> D)\n\ngoal (1 subgoal):\n 1. C - {v} = C \\<inter> D", "by auto"], ["proof (state)\nthis:\n  C - {v} = C \\<inter> D\n\ngoal (1 subgoal):\n 1. D \\<noteq> C \\<Longrightarrow>\n    D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "with D' False"], ["proof (chain)\npicking this:\n  C \\<sim> D\n  D \\<noteq> C\n  C - {v} = C \\<inter> D", "have \"C-{v} \\<lhd> D\""], ["proof (prove)\nusing this:\n  C \\<sim> D\n  D \\<noteq> C\n  C - {v} = C \\<inter> D\n\ngoal (1 subgoal):\n 1. C - {v} \\<lhd> D", "using adjacent_int_facet2"], ["proof (prove)\nusing this:\n  C \\<sim> D\n  D \\<noteq> C\n  C - {v} = C \\<inter> D\n  \\<lbrakk>?x \\<sim> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<inter> ?y \\<lhd> ?y\n\ngoal (1 subgoal):\n 1. C - {v} \\<lhd> D", "by auto"], ["proof (state)\nthis:\n  C - {v} \\<lhd> D\n\ngoal (1 subgoal):\n 1. D \\<noteq> C \\<Longrightarrow>\n    D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "with assms(2) D v(2)"], ["proof (chain)\npicking this:\n  chamber C\n  D \\<in> adjacentset C\n  C = insert v (C \\<inter> D)\n  C - {v} \\<lhd> D", "show ?thesis"], ["proof (prove)\nusing this:\n  chamber C\n  D \\<in> adjacentset C\n  C = insert v (C \\<inter> D)\n  C - {v} \\<lhd> D\n\ngoal (1 subgoal):\n 1. D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "using adjacentset_def"], ["proof (prove)\nusing this:\n  chamber C\n  D \\<in> adjacentset C\n  C = insert v (C \\<inter> D)\n  C - {v} \\<lhd> D\n  adjacentset ?x = {y \\<in> X. ?x \\<sim> y}\n\ngoal (1 subgoal):\n 1. D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "by fast"], ["proof (state)\nthis:\n  D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D \\<in> (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>v\\<in>C.\n                   {D \\<in> X. C - {v} \\<lhd> D}) \\<Longrightarrow>\n       x \\<in> adjacentset C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>v\\<in>C.\n                   {D \\<in> X. C - {v} \\<lhd> D}) \\<Longrightarrow>\n       x \\<in> adjacentset C", "from assms(2)"], ["proof (chain)\npicking this:\n  chamber C", "show  \"\\<And>D. D \\<in> (\\<Union>v\\<in>C. {E\\<in>X. C-{v}\\<lhd>E}) \\<Longrightarrow>\n            D \\<in> adjacentset C\""], ["proof (prove)\nusing this:\n  chamber C\n\ngoal (1 subgoal):\n 1. \\<And>D.\n       D \\<in> (\\<Union>v\\<in>C.\n                   {E \\<in> X. C - {v} \\<lhd> E}) \\<Longrightarrow>\n       D \\<in> adjacentset C", "using     facetrel_diff_vertex adjacentI"], ["proof (prove)\nusing this:\n  chamber C\n  ?v \\<in> ?x \\<Longrightarrow> ?x - {?v} \\<lhd> ?x\n  \\<lbrakk>?z \\<lhd> ?x; ?z \\<lhd> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<sim> ?y\n\ngoal (1 subgoal):\n 1. \\<And>D.\n       D \\<in> (\\<Union>v\\<in>C.\n                   {E \\<in> X. C - {v} \\<lhd> E}) \\<Longrightarrow>\n       D \\<in> adjacentset C", "unfolding adjacentset_def"], ["proof (prove)\nusing this:\n  chamber C\n  ?v \\<in> ?x \\<Longrightarrow> ?x - {?v} \\<lhd> ?x\n  \\<lbrakk>?z \\<lhd> ?x; ?z \\<lhd> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<sim> ?y\n\ngoal (1 subgoal):\n 1. \\<And>D.\n       D \\<in> (\\<Union>v\\<in>C.\n                   {E \\<in> X. C - {v} \\<lhd> E}) \\<Longrightarrow>\n       D \\<in> {y \\<in> X. C \\<sim> y}", "by        fastforce"], ["proof (state)\nthis:\n  ?D \\<in> (\\<Union>v\\<in>C.\n               {E \\<in> X. C - {v} \\<lhd> E}) \\<Longrightarrow>\n  ?D \\<in> adjacentset C\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ChamberComplex *)"], ["", "subsection \\<open>The system of chambers and distance between chambers\\<close>"], ["", "text \\<open>\n  We now examine the system of all chambers in more detail, and explore the distance function on\n  this system provided by lengths of minimal galleries.\n\\<close>"], ["", "context ChamberComplex\nbegin"], ["", "definition chamber_system :: \"'a set set\"\n  where \"chamber_system \\<equiv> {C. chamber C}\""], ["", "abbreviation \"\\<C> \\<equiv> chamber_system\""], ["", "definition chamber_distance :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> nat\"\n  where \"chamber_distance C D =\n          (if C=D then 0 else\n            Suc (length (ARG_MIN length Cs. gallery (C#Cs@[D]))))\""], ["", "definition closest_supchamber :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set\"\n  where \"closest_supchamber F D =\n          (ARG_MIN (\\<lambda>C. chamber_distance C D) C.\n            chamber C \\<and> F\\<subseteq>C)\""], ["", "definition \"face_distance F D \\<equiv> chamber_distance (closest_supchamber F D) D\""], ["", "lemma chamber_system_simplices: \"\\<C> \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq X \\<C>", "using chamberD_simplex"], ["proof (prove)\nusing this:\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n\ngoal (1 subgoal):\n 1. order.greater_eq X \\<C>", "unfolding chamber_system_def"], ["proof (prove)\nusing this:\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n\ngoal (1 subgoal):\n 1. order.greater_eq X (Collect chamber)", "by fast"], ["", "lemma gallery_chamber_system: \"gallery Cs \\<Longrightarrow> set Cs \\<subseteq> \\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gallery Cs \\<Longrightarrow> order.greater_eq \\<C> (set Cs)", "using galleryD_chamber chamber_system_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> chamber ?x\n  \\<C> \\<equiv> Collect chamber\n\ngoal (1 subgoal):\n 1. gallery Cs \\<Longrightarrow> order.greater_eq \\<C> (set Cs)", "by fast"], ["", "lemmas pgallery_chamber_system = gallery_chamber_system[OF pgallery]"], ["", "lemma chamber_distance_le:\n  \"gallery (C#Cs@[D]) \\<Longrightarrow> chamber_distance C D \\<le> Suc (length Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gallery (C # Cs @ [D]) \\<Longrightarrow>\n    order.greater_eq (Suc (length Cs)) (chamber_distance C D)", "using chamber_distance_def\n        arg_min_nat_le[of \"\\<lambda>Cs. gallery (C#Cs@[D])\" _ length]"], ["proof (prove)\nusing this:\n  chamber_distance ?C ?D =\n  (if ?C = ?D then 0\n   else Suc (length (ARG_MIN length Cs. gallery (?C # Cs @ [?D]))))\n  gallery (C # ?x @ [D]) \\<Longrightarrow>\n  order.greater_eq (length ?x)\n   (length (ARG_MIN length Cs. gallery (C # Cs @ [D])))\n\ngoal (1 subgoal):\n 1. gallery (C # Cs @ [D]) \\<Longrightarrow>\n    order.greater_eq (Suc (length Cs)) (chamber_distance C D)", "by    auto"], ["", "lemma min_gallery_betw_chamber_distance:\n  \"min_gallery (C#Cs@[D]) \\<Longrightarrow> chamber_distance C D = Suc (length Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_gallery (C # Cs @ [D]) \\<Longrightarrow>\n    chamber_distance C D = Suc (length Cs)", "using chamber_distance_def[of C D] is_arg_min_size[of length _ Cs]"], ["proof (prove)\nusing this:\n  chamber_distance C D =\n  (if C = D then 0\n   else Suc (length (ARG_MIN length Cs. gallery (C # Cs @ [D]))))\n  is_arg_min length ?P Cs \\<Longrightarrow>\n  length Cs = length (arg_min length ?P)\n\ngoal (1 subgoal):\n 1. min_gallery (C # Cs @ [D]) \\<Longrightarrow>\n    chamber_distance C D = Suc (length Cs)", "by auto"], ["", "lemma min_galleryI_chamber_distance_betw:\n  \"gallery (C#Cs@[D]) \\<Longrightarrow> Suc (length Cs) = chamber_distance C D \\<Longrightarrow>\n    min_gallery (C#Cs@[D])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gallery (C # Cs @ [D]);\n     Suc (length Cs) = chamber_distance C D\\<rbrakk>\n    \\<Longrightarrow> min_gallery (C # Cs @ [D])", "using chamber_distance_def chamber_distance_le min_galleryI_betw[of C D]"], ["proof (prove)\nusing this:\n  chamber_distance ?C ?D =\n  (if ?C = ?D then 0\n   else Suc (length (ARG_MIN length Cs. gallery (?C # Cs @ [?D]))))\n  gallery (?C # ?Cs @ [?D]) \\<Longrightarrow>\n  order.greater_eq (Suc (length ?Cs)) (chamber_distance ?C ?D)\n  \\<lbrakk>C \\<noteq> D; gallery (C # ?xs @ [D]);\n   \\<And>ys.\n      gallery (C # ys @ [D]) \\<Longrightarrow>\n      order.greater_eq (length ys) (length ?xs)\\<rbrakk>\n  \\<Longrightarrow> min_gallery (C # ?xs @ [D])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>gallery (C # Cs @ [D]);\n     Suc (length Cs) = chamber_distance C D\\<rbrakk>\n    \\<Longrightarrow> min_gallery (C # Cs @ [D])", "by    fastforce"], ["", "lemma gallery_least_length:\n  assumes \"chamber C\" \"chamber D\" \"C\\<noteq>D\"\n  defines \"Cs \\<equiv> ARG_MIN length Cs. gallery (C#Cs@[D])\"\n  shows   \"gallery (C#Cs@[D])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gallery (C # Cs @ [D])", "using   assms maxsimp_connect[of C D] arg_min_natI"], ["proof (prove)\nusing this:\n  chamber C\n  chamber D\n  C \\<noteq> D\n  Cs \\<equiv> ARG_MIN length Cs. gallery (C # Cs @ [D])\n  \\<lbrakk>C \\<noteq> D; chamber C; chamber D\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs. gallery (C # xs @ [D])\n  ?P ?k \\<Longrightarrow> ?P (arg_min ?m ?P)\n\ngoal (1 subgoal):\n 1. gallery (C # Cs @ [D])", "by      fast"], ["", "lemma min_gallery_least_length:\n  assumes   \"chamber C\" \"chamber D\" \"C\\<noteq>D\"\n  defines   \"Cs \\<equiv> ARG_MIN length Cs. gallery (C#Cs@[D])\"\n  shows     \"min_gallery (C#Cs@[D])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_gallery (C # Cs @ [D])", "unfolding Cs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_gallery (C # (ARG_MIN length Cs. gallery (C # Cs @ [D])) @ [D])", "using     assms gallery_least_length"], ["proof (prove)\nusing this:\n  chamber C\n  chamber D\n  C \\<noteq> D\n  Cs \\<equiv> ARG_MIN length Cs. gallery (C # Cs @ [D])\n  \\<lbrakk>chamber ?C; chamber ?D; ?C \\<noteq> ?D\\<rbrakk>\n  \\<Longrightarrow> gallery\n                     (?C #\n                      (ARG_MIN length Cs. gallery (?C # Cs @ [?D])) @ [?D])\n\ngoal (1 subgoal):\n 1. min_gallery (C # (ARG_MIN length Cs. gallery (C # Cs @ [D])) @ [D])", "by        (blast intro: min_galleryI_betw arg_min_nat_le)"], ["", "lemma pgallery_least_length:\n  assumes \"chamber C\" \"chamber D\" \"C\\<noteq>D\"\n  defines \"Cs \\<equiv> ARG_MIN length Cs. gallery (C#Cs@[D])\"\n  shows   \"pgallery (C#Cs@[D])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pgallery (C # Cs @ [D])", "using   assms min_gallery_least_length min_gallery_pgallery"], ["proof (prove)\nusing this:\n  chamber C\n  chamber D\n  C \\<noteq> D\n  Cs \\<equiv> ARG_MIN length Cs. gallery (C # Cs @ [D])\n  \\<lbrakk>chamber ?C; chamber ?D; ?C \\<noteq> ?D\\<rbrakk>\n  \\<Longrightarrow> min_gallery\n                     (?C #\n                      (ARG_MIN length Cs. gallery (?C # Cs @ [?D])) @ [?D])\n  min_gallery ?xs \\<Longrightarrow> pgallery ?xs\n\ngoal (1 subgoal):\n 1. pgallery (C # Cs @ [D])", "by      fast"], ["", "lemma closest_supchamberD:\n  assumes   \"F\\<in>X\" \"chamber D\"\n  shows     \"chamber (closest_supchamber F D)\" \"F \\<subseteq> closest_supchamber F D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chamber (closest_supchamber F D) &&&\n    order.greater_eq (closest_supchamber F D) F", "using     assms arg_min_natI[of \"\\<lambda>C. chamber C \\<and> F\\<subseteq>C\" ] simplex_in_max[of F]"], ["proof (prove)\nusing this:\n  F \\<in> X\n  chamber D\n  chamber ?k \\<and> order.greater_eq ?k F \\<Longrightarrow>\n  chamber (ARG_MIN ?m C. chamber C \\<and> order.greater_eq C F) \\<and>\n  order.greater_eq (ARG_MIN ?m C. chamber C \\<and> order.greater_eq C F) F\n  F \\<in> X \\<Longrightarrow>\n  \\<exists>x. chamber x \\<and> order.greater_eq x F\n\ngoal (1 subgoal):\n 1. chamber (closest_supchamber F D) &&&\n    order.greater_eq (closest_supchamber F D) F", "unfolding closest_supchamber_def"], ["proof (prove)\nusing this:\n  F \\<in> X\n  chamber D\n  chamber ?k \\<and> order.greater_eq ?k F \\<Longrightarrow>\n  chamber (ARG_MIN ?m C. chamber C \\<and> order.greater_eq C F) \\<and>\n  order.greater_eq (ARG_MIN ?m C. chamber C \\<and> order.greater_eq C F) F\n  F \\<in> X \\<Longrightarrow>\n  \\<exists>x. chamber x \\<and> order.greater_eq x F\n\ngoal (1 subgoal):\n 1. chamber\n     (ARG_MIN (\\<lambda>C. chamber_distance C D) C.\n         chamber C \\<and> order.greater_eq C F) &&&\n    order.greater_eq\n     (ARG_MIN (\\<lambda>C. chamber_distance C D) C.\n         chamber C \\<and> order.greater_eq C F)\n     F", "by        auto"], ["", "lemma closest_supchamber_closest:\n  \"chamber C \\<Longrightarrow> F\\<subseteq>C \\<Longrightarrow>\n    chamber_distance (closest_supchamber F D) D \\<le> chamber_distance C D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; order.greater_eq C F\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq (chamber_distance C D)\n                       (chamber_distance (closest_supchamber F D) D)", "using arg_min_nat_le[of \"\\<lambda>C. chamber C \\<and> F\\<subseteq>C\" C] closest_supchamber_def"], ["proof (prove)\nusing this:\n  chamber C \\<and> order.greater_eq C F \\<Longrightarrow>\n  order.greater_eq (?m C)\n   (?m (ARG_MIN ?m C. chamber C \\<and> order.greater_eq C F))\n  closest_supchamber ?F ?D =\n  (ARG_MIN (\\<lambda>C. chamber_distance C ?D) C.\n      chamber C \\<and> order.greater_eq C ?F)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; order.greater_eq C F\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq (chamber_distance C D)\n                       (chamber_distance (closest_supchamber F D) D)", "by simp"], ["", "lemma face_distance_le:\n  \"chamber C \\<Longrightarrow> F\\<subseteq>C \\<Longrightarrow> face_distance F D \\<le> chamber_distance C D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; order.greater_eq C F\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq (chamber_distance C D)\n                       (face_distance F D)", "unfolding face_distance_def closest_supchamber_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; order.greater_eq C F\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq (chamber_distance C D)\n                       (chamber_distance\n                         (ARG_MIN (\\<lambda>C. chamber_distance C D) C.\n                             chamber C \\<and> order.greater_eq C F)\n                         D)", "by (auto intro: arg_min_nat_le)"], ["", "lemma face_distance_eq_0: \"chamber C \\<Longrightarrow> F\\<subseteq>C \\<Longrightarrow> face_distance F C = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; order.greater_eq C F\\<rbrakk>\n    \\<Longrightarrow> face_distance F C = 0", "using chamber_distance_def closest_supchamber_def face_distance_def\n        arg_min_equality[\n          of \"\\<lambda>C. chamber C \\<and> F\\<subseteq>C\" C \"\\<lambda>D. chamber_distance D C\"\n        ]"], ["proof (prove)\nusing this:\n  chamber_distance ?C ?D =\n  (if ?C = ?D then 0\n   else Suc (length (ARG_MIN length Cs. gallery (?C # Cs @ [?D]))))\n  closest_supchamber ?F ?D =\n  (ARG_MIN (\\<lambda>C. chamber_distance C ?D) C.\n      chamber C \\<and> order.greater_eq C ?F)\n  face_distance ?F ?D \\<equiv>\n  chamber_distance (closest_supchamber ?F ?D) ?D\n  \\<lbrakk>chamber C \\<and> order.greater_eq C F;\n   \\<And>x.\n      chamber x \\<and> order.greater_eq x F \\<Longrightarrow>\n      order.greater_eq (chamber_distance x C)\n       (chamber_distance C C)\\<rbrakk>\n  \\<Longrightarrow> chamber_distance\n                     (ARG_MIN (\\<lambda>D. chamber_distance D C) C.\n                         chamber C \\<and> order.greater_eq C F)\n                     C =\n                    chamber_distance C C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; order.greater_eq C F\\<rbrakk>\n    \\<Longrightarrow> face_distance F C = 0", "by simp"], ["", "end"], ["", "(* context ChamberComplex *)"], ["", "subsection \\<open>Labelling a chamber complex\\<close>"], ["", "text \\<open>\n  A labelling of a chamber complex is a function on the vertex set so that each chamber is in\n  bijective correspondence with the label set (chambers all have the same number of vertices).\n\\<close>"], ["", "context ChamberComplex\nbegin"], ["", "definition label_wrt :: \"'b set \\<Rightarrow> ('a\\<Rightarrow>'b) \\<Rightarrow> bool\"\n  where \"label_wrt B f \\<equiv> (\\<forall>C\\<in>\\<C>. bij_betw f C B)\""], ["", "lemma label_wrtD: \"label_wrt B f \\<Longrightarrow> C\\<in>\\<C> \\<Longrightarrow> bij_betw f C B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>label_wrt B f; C \\<in> \\<C>\\<rbrakk>\n    \\<Longrightarrow> bij_betw f C B", "using label_wrt_def"], ["proof (prove)\nusing this:\n  label_wrt ?B ?f \\<equiv> \\<forall>C\\<in>\\<C>. bij_betw ?f C ?B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>label_wrt B f; C \\<in> \\<C>\\<rbrakk>\n    \\<Longrightarrow> bij_betw f C B", "by fast"], ["", "lemma label_wrtD': \"label_wrt B f \\<Longrightarrow> chamber C \\<Longrightarrow> bij_betw f C B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>label_wrt B f; chamber C\\<rbrakk>\n    \\<Longrightarrow> bij_betw f C B", "using label_wrt_def chamber_system_def"], ["proof (prove)\nusing this:\n  label_wrt ?B ?f \\<equiv> \\<forall>C\\<in>\\<C>. bij_betw ?f C ?B\n  \\<C> \\<equiv> Collect chamber\n\ngoal (1 subgoal):\n 1. \\<lbrakk>label_wrt B f; chamber C\\<rbrakk>\n    \\<Longrightarrow> bij_betw f C B", "by fast"], ["", "lemma label_wrt_adjacent:\n  assumes \"label_wrt B f\" \"chamber C\" \"chamber D\" \"C\\<sim>D\" \"v\\<in>C-D\" \"w\\<in>D-C\"\n  shows   \"f v = f w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f v = f w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. f v = f w", "from assms(5)"], ["proof (chain)\npicking this:\n  v \\<in> C - D", "have \"f`D = insert (f v) (f`(C\\<inter>D))\""], ["proof (prove)\nusing this:\n  v \\<in> C - D\n\ngoal (1 subgoal):\n 1. f ` D = insert (f v) (f ` (C \\<inter> D))", "using adjacent_conv_insert[OF assms(4), of v] label_wrtD'[OF assms(1,2)]\n          label_wrtD'[OF assms(1,3)]\n          bij_betw_imp_surj_on[of f]"], ["proof (prove)\nusing this:\n  v \\<in> C - D\n  v \\<in> C - D \\<Longrightarrow> C = insert v (C \\<inter> D)\n  bij_betw f C B\n  bij_betw f D B\n  bij_betw f ?A ?B \\<Longrightarrow> f ` ?A = ?B\n\ngoal (1 subgoal):\n 1. f ` D = insert (f v) (f ` (C \\<inter> D))", "by    force"], ["proof (state)\nthis:\n  f ` D = insert (f v) (f ` (C \\<inter> D))\n\ngoal (1 subgoal):\n 1. f v = f w", "with assms(6)"], ["proof (chain)\npicking this:\n  w \\<in> D - C\n  f ` D = insert (f v) (f ` (C \\<inter> D))", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<in> D - C\n  f ` D = insert (f v) (f ` (C \\<inter> D))\n\ngoal (1 subgoal):\n 1. f v = f w", "using adjacent_sym[OF assms(4)] adjacent_conv_insert[of D C]\n          inj_on_insert[of f w \"C\\<inter>D\"]\n          bij_betw_imp_inj_on[OF label_wrtD', OF assms(1,3)]"], ["proof (prove)\nusing this:\n  w \\<in> D - C\n  f ` D = insert (f v) (f ` (C \\<inter> D))\n  D \\<sim> C\n  \\<lbrakk>D \\<sim> C; ?v \\<in> D - C\\<rbrakk>\n  \\<Longrightarrow> D = insert ?v (D \\<inter> C)\n  inj_on f (insert w (C \\<inter> D)) =\n  (inj_on f (C \\<inter> D) \\<and> f w \\<notin> f ` (C \\<inter> D - {w}))\n  inj_on f D\n\ngoal (1 subgoal):\n 1. f v = f w", "by    (force simp add: Int_commute)"], ["proof (state)\nthis:\n  f v = f w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma label_wrt_adjacent_shared_facet:\n  \"\\<lbrakk> label_wrt B f; chamber (insert v z); chamber (insert w z); v\\<notin>z; w\\<notin>z \\<rbrakk> \\<Longrightarrow>\n    f v = f w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>label_wrt B f; chamber (insert v z); chamber (insert w z);\n     v \\<notin> z; w \\<notin> z\\<rbrakk>\n    \\<Longrightarrow> f v = f w", "by (auto intro: label_wrt_adjacent adjacentI facetrelI)"], ["", "lemma label_wrt_elt_image: \"label_wrt B f \\<Longrightarrow> v\\<in>\\<Union>X \\<Longrightarrow> f v \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>label_wrt B f; v \\<in> \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> f v \\<in> B", "using simplex_in_max label_wrtD' bij_betw_imp_surj_on"], ["proof (prove)\nusing this:\n  ?y \\<in> X \\<Longrightarrow>\n  \\<exists>x. chamber x \\<and> order.greater_eq x ?y\n  \\<lbrakk>label_wrt ?B ?f; chamber ?C\\<rbrakk>\n  \\<Longrightarrow> bij_betw ?f ?C ?B\n  bij_betw ?f ?A ?B \\<Longrightarrow> ?f ` ?A = ?B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>label_wrt B f; v \\<in> \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> f v \\<in> B", "by fast"], ["", "end"], ["", "(* context ChamberComplex *)"], ["", "subsection \\<open>Morphisms of chamber complexes\\<close>"], ["", "text \\<open>\n  While any function on the vertex set of a simplicial complex can be considered a morphism of\n  simplicial complexes onto its image, for chamber complexes we require the function send chambers\n  onto chambers of the same cardinality in some chamber complex of the codomain.\n\\<close>"], ["", "subsubsection \\<open>Morphism locale and basic facts\\<close>"], ["", "locale ChamberComplexMorphism = domain: ChamberComplex X + codomain: ChamberComplex Y\n  for     X :: \"'a set set\"\n  and     Y :: \"'b set set\"\n+ fixes   f :: \"'a\\<Rightarrow>'b\"\n  assumes chamber_map:  \"domain.chamber C \\<Longrightarrow> codomain.chamber (f`C)\"\n  and     dim_map    :  \"domain.chamber C \\<Longrightarrow> card (f`C) = card C\""], ["", "lemma (in ChamberComplex) trivial_morphism:\n  \"ChamberComplexMorphism X X id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexMorphism X X id", "by unfold_locales auto"], ["", "lemma (in ChamberComplex) inclusion_morphism:\n  assumes \"ChamberSubcomplex Y\"\n  shows   \"ChamberComplexMorphism Y X id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexMorphism Y X id", "by      (\n            rule ChamberComplexMorphism.intro,\n            rule ChamberSubcomplexD_complex,\n            rule assms, unfold_locales\n          )\n          (auto simp add: subcomplex_chamber[OF assms])"], ["", "context ChamberComplexMorphism\nbegin"], ["", "lemmas domain_complex = domain.ChamberComplex_axioms"], ["", "lemmas codomain_complex = codomain.ChamberComplex_axioms"], ["", "lemmas simplicialcomplex_image = domain.map_is_simplicial_morph[of f]"], ["", "lemma cong: \"fun_eq_on g f (\\<Union>X) \\<Longrightarrow> ChamberComplexMorphism X Y g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_eq_on g f (\\<Union> X) \\<Longrightarrow>\n    ChamberComplexMorphism X Y g", "using chamber_map domain.chamber_vertices fun_eq_on_im[of g f] dim_map\n        domain.chamber_vertices"], ["proof (prove)\nusing this:\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n  domain.chamber ?x \\<Longrightarrow> order.greater_eq (\\<Union> X) ?x\n  \\<lbrakk>fun_eq_on g f ?A; order.greater_eq ?A ?B\\<rbrakk>\n  \\<Longrightarrow> g ` ?B = f ` ?B\n  domain.chamber ?C \\<Longrightarrow> card (f ` ?C) = card ?C\n  domain.chamber ?x \\<Longrightarrow> order.greater_eq (\\<Union> X) ?x\n\ngoal (1 subgoal):\n 1. fun_eq_on g f (\\<Union> X) \\<Longrightarrow>\n    ChamberComplexMorphism X Y g", "by    unfold_locales auto"], ["", "lemma comp:\n  assumes \"ChamberComplexMorphism Y Z g\"\n  shows   \"ChamberComplexMorphism X Z (g\\<circ>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexMorphism X Z (g \\<circ> f)", "proof (\n  rule ChamberComplexMorphism.intro, rule domain_complex,\n  rule ChamberComplexMorphism.axioms(2), rule assms, unfold_locales\n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       domain.chamber C \\<Longrightarrow>\n       SimplicialComplex.maxsimp Z ((g \\<circ> f) ` C)\n 2. \\<And>C.\n       domain.chamber C \\<Longrightarrow> card ((g \\<circ> f) ` C) = card C", "fix C"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       domain.chamber C \\<Longrightarrow>\n       SimplicialComplex.maxsimp Z ((g \\<circ> f) ` C)\n 2. \\<And>C.\n       domain.chamber C \\<Longrightarrow> card ((g \\<circ> f) ` C) = card C", "assume C: \"domain.chamber C\""], ["proof (state)\nthis:\n  domain.chamber C\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       domain.chamber C \\<Longrightarrow>\n       SimplicialComplex.maxsimp Z ((g \\<circ> f) ` C)\n 2. \\<And>C.\n       domain.chamber C \\<Longrightarrow> card ((g \\<circ> f) ` C) = card C", "from C"], ["proof (chain)\npicking this:\n  domain.chamber C", "show \"SimplicialComplex.maxsimp Z ((g\\<circ>f)`C)\""], ["proof (prove)\nusing this:\n  domain.chamber C\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp Z ((g \\<circ> f) ` C)", "using chamber_map ChamberComplexMorphism.chamber_map[OF assms]"], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n  codomain.chamber ?C \\<Longrightarrow> SimplicialComplex.maxsimp Z (g ` ?C)\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp Z ((g \\<circ> f) ` C)", "by    (force simp add: image_comp[THEN sym])"], ["proof (state)\nthis:\n  SimplicialComplex.maxsimp Z ((g \\<circ> f) ` C)\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       domain.chamber C \\<Longrightarrow> card ((g \\<circ> f) ` C) = card C", "from C"], ["proof (chain)\npicking this:\n  domain.chamber C", "show \"card ((g \\<circ> f)`C) = card C\""], ["proof (prove)\nusing this:\n  domain.chamber C\n\ngoal (1 subgoal):\n 1. card ((g \\<circ> f) ` C) = card C", "using chamber_map dim_map ChamberComplexMorphism.dim_map[OF assms]"], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n  domain.chamber ?C \\<Longrightarrow> card (f ` ?C) = card ?C\n  codomain.chamber ?C \\<Longrightarrow> card (g ` ?C) = card ?C\n\ngoal (1 subgoal):\n 1. card ((g \\<circ> f) ` C) = card C", "by    (force simp add: image_comp[THEN sym])"], ["proof (state)\nthis:\n  card ((g \\<circ> f) ` C) = card C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restrict_domain:\n  assumes \"domain.ChamberSubcomplex W\"\n  shows   \"ChamberComplexMorphism W Y f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexMorphism W Y f", "proof (\n  rule ChamberComplexMorphism.intro, rule domain.ChamberSubcomplexD_complex,\n  rule assms, rule codomain_complex, unfold_locales\n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       SimplicialComplex.maxsimp W C \\<Longrightarrow>\n       codomain.chamber (f ` C)\n 2. \\<And>C.\n       SimplicialComplex.maxsimp W C \\<Longrightarrow> card (f ` C) = card C", "fix C"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       SimplicialComplex.maxsimp W C \\<Longrightarrow>\n       codomain.chamber (f ` C)\n 2. \\<And>C.\n       SimplicialComplex.maxsimp W C \\<Longrightarrow> card (f ` C) = card C", "assume \"ChamberComplex.chamber W C\""], ["proof (state)\nthis:\n  SimplicialComplex.maxsimp W C\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       SimplicialComplex.maxsimp W C \\<Longrightarrow>\n       codomain.chamber (f ` C)\n 2. \\<And>C.\n       SimplicialComplex.maxsimp W C \\<Longrightarrow> card (f ` C) = card C", "with assms"], ["proof (chain)\npicking this:\n  domain.ChamberSubcomplex W\n  SimplicialComplex.maxsimp W C", "show \"codomain.chamber (f`C)\" \"card (f`C) = card C\""], ["proof (prove)\nusing this:\n  domain.ChamberSubcomplex W\n  SimplicialComplex.maxsimp W C\n\ngoal (1 subgoal):\n 1. codomain.chamber (f ` C) &&& card (f ` C) = card C", "using domain.subcomplex_chamber chamber_map dim_map"], ["proof (prove)\nusing this:\n  domain.ChamberSubcomplex W\n  SimplicialComplex.maxsimp W C\n  \\<lbrakk>domain.ChamberSubcomplex ?Y;\n   SimplicialComplex.maxsimp ?Y ?C\\<rbrakk>\n  \\<Longrightarrow> domain.chamber ?C\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n  domain.chamber ?C \\<Longrightarrow> card (f ` ?C) = card ?C\n\ngoal (1 subgoal):\n 1. codomain.chamber (f ` C) &&& card (f ` C) = card C", "by auto"], ["proof (state)\nthis:\n  codomain.chamber (f ` C)\n  card (f ` C) = card C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restrict_codomain:\n  assumes \"codomain.ChamberSubcomplex Z\" \"f\\<turnstile>X \\<subseteq> Z\"\n  shows   \"ChamberComplexMorphism X Z f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexMorphism X Z f", "proof (\n  rule ChamberComplexMorphism.intro, rule domain_complex,\n  rule codomain.ChamberSubcomplexD_complex,\n  rule assms, unfold_locales\n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       domain.chamber C \\<Longrightarrow>\n       SimplicialComplex.maxsimp Z (f ` C)\n 2. \\<And>C. domain.chamber C \\<Longrightarrow> card (f ` C) = card C", "fix C"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       domain.chamber C \\<Longrightarrow>\n       SimplicialComplex.maxsimp Z (f ` C)\n 2. \\<And>C. domain.chamber C \\<Longrightarrow> card (f ` C) = card C", "assume \"domain.chamber C\""], ["proof (state)\nthis:\n  domain.chamber C\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       domain.chamber C \\<Longrightarrow>\n       SimplicialComplex.maxsimp Z (f ` C)\n 2. \\<And>C. domain.chamber C \\<Longrightarrow> card (f ` C) = card C", "with assms"], ["proof (chain)\npicking this:\n  codomain.ChamberSubcomplex Z\n  order.greater_eq Z (f \\<turnstile> X)\n  domain.chamber C", "show \"SimplicialComplex.maxsimp Z (f`C)\" \"card (f ` C) = card C\""], ["proof (prove)\nusing this:\n  codomain.ChamberSubcomplex Z\n  order.greater_eq Z (f \\<turnstile> X)\n  domain.chamber C\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp Z (f ` C) &&& card (f ` C) = card C", "using domain.chamberD_simplex[of C] chamber_map\n          codomain.chamber_in_subcomplex dim_map"], ["proof (prove)\nusing this:\n  codomain.ChamberSubcomplex Z\n  order.greater_eq Z (f \\<turnstile> X)\n  domain.chamber C\n  domain.chamber C \\<Longrightarrow> C \\<in> X\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n  \\<lbrakk>codomain.ChamberSubcomplex ?Y; ?C \\<in> ?Y;\n   codomain.chamber ?C\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp ?Y ?C\n  domain.chamber ?C \\<Longrightarrow> card (f ` ?C) = card ?C\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp Z (f ` C) &&& card (f ` C) = card C", "by    auto"], ["proof (state)\nthis:\n  SimplicialComplex.maxsimp Z (f ` C)\n  card (f ` C) = card C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_on_chamber: \"domain.chamber C \\<Longrightarrow> inj_on f C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain.chamber C \\<Longrightarrow> inj_on f C", "using domain.finite_chamber dim_map"], ["proof (prove)\nusing this:\n  domain.chamber ?x \\<Longrightarrow> finite ?x\n  domain.chamber ?C \\<Longrightarrow> card (f ` ?C) = card ?C\n\ngoal (1 subgoal):\n 1. domain.chamber C \\<Longrightarrow> inj_on f C", "by (fast intro: eq_card_imp_inj_on)"], ["", "lemma bij_betw_chambers: \"domain.chamber C \\<Longrightarrow> bij_betw f C (f`C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain.chamber C \\<Longrightarrow> bij_betw f C (f ` C)", "using inj_on_chamber"], ["proof (prove)\nusing this:\n  domain.chamber ?C \\<Longrightarrow> inj_on f ?C\n\ngoal (1 subgoal):\n 1. domain.chamber C \\<Longrightarrow> bij_betw f C (f ` C)", "by (fast intro: bij_betw_imageI)"], ["", "lemma card_map: \"x\\<in>X \\<Longrightarrow> card (f`x) = card x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> card (f ` x) = card x", "using domain.simplex_in_max subset_inj_on[OF inj_on_chamber]\n        domain.finite_simplex inj_on_iff_eq_card"], ["proof (prove)\nusing this:\n  ?y \\<in> X \\<Longrightarrow>\n  \\<exists>x. domain.chamber x \\<and> order.greater_eq x ?y\n  \\<lbrakk>domain.chamber ?B; order.greater_eq ?B ?A\\<rbrakk>\n  \\<Longrightarrow> inj_on f ?A\n  ?x \\<in> X \\<Longrightarrow> finite ?x\n  finite ?A \\<Longrightarrow> inj_on ?f ?A = (card (?f ` ?A) = card ?A)\n\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> card (f ` x) = card x", "by    blast"], ["", "lemma codim_map:\n  assumes \"domain.chamber C\" \"y \\<subseteq> C\"\n  shows   \"card (f`C - f`y) = card (C-y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (f ` C - f ` y) = card (C - y)", "using   assms dim_map domain.chamberD_simplex domain.faces[of C y]\n          domain.finite_simplex card_Diff_subset[of \"f`y\" \"f`C\"]\n          card_map card_Diff_subset[of y C]"], ["proof (prove)\nusing this:\n  domain.chamber C\n  order.greater_eq C y\n  domain.chamber ?C \\<Longrightarrow> card (f ` ?C) = card ?C\n  domain.chamber ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>C \\<in> X; order.greater_eq C y\\<rbrakk>\n  \\<Longrightarrow> y \\<in> X\n  ?x \\<in> X \\<Longrightarrow> finite ?x\n  \\<lbrakk>finite (f ` y); order.greater_eq (f ` C) (f ` y)\\<rbrakk>\n  \\<Longrightarrow> card (f ` C - f ` y) = card (f ` C) - card (f ` y)\n  ?x \\<in> X \\<Longrightarrow> card (f ` ?x) = card ?x\n  \\<lbrakk>finite y; order.greater_eq C y\\<rbrakk>\n  \\<Longrightarrow> card (C - y) = card C - card y\n\ngoal (1 subgoal):\n 1. card (f ` C - f ` y) = card (C - y)", "by      auto"], ["", "lemma simplex_map: \"x\\<in>X \\<Longrightarrow> f`x\\<in>Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> f ` x \\<in> Y", "using chamber_map domain.simplex_in_max codomain.chamberD_simplex\n        codomain.faces[of _ \"f`x\"]"], ["proof (prove)\nusing this:\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n  ?y \\<in> X \\<Longrightarrow>\n  \\<exists>x. domain.chamber x \\<and> order.greater_eq x ?y\n  codomain.chamber ?x \\<Longrightarrow> ?x \\<in> Y\n  \\<lbrakk>?x \\<in> Y; order.greater_eq ?x (f ` x)\\<rbrakk>\n  \\<Longrightarrow> f ` x \\<in> Y\n\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> f ` x \\<in> Y", "by    force"], ["", "lemma simplices_map: \"f\\<turnstile>X \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq Y (f \\<turnstile> X)", "using simplex_map"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> f ` ?x \\<in> Y\n\ngoal (1 subgoal):\n 1. order.greater_eq Y (f \\<turnstile> X)", "by fast"], ["", "lemma vertex_map: \"x \\<in> \\<Union>X \\<Longrightarrow> f x \\<in> \\<Union>Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> X \\<Longrightarrow> f x \\<in> \\<Union> Y", "using simplex_map"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> f ` ?x \\<in> Y\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> X \\<Longrightarrow> f x \\<in> \\<Union> Y", "by fast"], ["", "lemma facet_map: \"domain.chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> f`z \\<lhd> f`C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>domain.chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> f ` z \\<lhd> f ` C", "using facetrel_subset facetrel_card codim_map[of C z]"], ["proof (prove)\nusing this:\n  ?y \\<lhd> ?x \\<Longrightarrow> order.greater_eq ?x ?y\n  ?y \\<lhd> ?x \\<Longrightarrow> card (?x - ?y) = 1\n  \\<lbrakk>domain.chamber C; order.greater_eq C z\\<rbrakk>\n  \\<Longrightarrow> card (f ` C - f ` z) = card (C - z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>domain.chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> f ` z \\<lhd> f ` C", "by    (fastforce intro: facetrelI_card)"], ["", "lemma adj_int_im:\n  assumes \"domain.chamber C\" \"domain.chamber D\" \"C \\<sim> D\" \"f`C \\<noteq> f`D\"\n  shows   \"(f`C \\<inter> f`D) \\<lhd> f`C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` C \\<inter> f ` D \\<lhd> f ` C", "proof (rule facetrelI_card)"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq (f ` C) (f ` C \\<inter> f ` D)\n 2. card (f ` C - f ` C \\<inter> f ` D) = 1", "from assms(1,2) chamber_map"], ["proof (chain)\npicking this:\n  domain.chamber C\n  domain.chamber D\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)", "have 1: \"f`C \\<subseteq> f`D \\<Longrightarrow> f`C = f`D\""], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n\ngoal (1 subgoal):\n 1. order.greater_eq (f ` D) (f ` C) \\<Longrightarrow> f ` C = f ` D", "using codomain.chamberD_simplex codomain.chamberD_maximal[of \"f`C\" \"f`D\"]"], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n  codomain.chamber ?x \\<Longrightarrow> ?x \\<in> Y\n  \\<lbrakk>codomain.chamber (f ` C); f ` D \\<in> Y;\n   order.greater_eq (f ` D) (f ` C)\\<rbrakk>\n  \\<Longrightarrow> f ` D = f ` C\n\ngoal (1 subgoal):\n 1. order.greater_eq (f ` D) (f ` C) \\<Longrightarrow> f ` C = f ` D", "by    simp"], ["proof (state)\nthis:\n  order.greater_eq (f ` D) (f ` C) \\<Longrightarrow> f ` C = f ` D\n\ngoal (2 subgoals):\n 1. order.greater_eq (f ` C) (f ` C \\<inter> f ` D)\n 2. card (f ` C - f ` C \\<inter> f ` D) = 1", "thus \"f ` C \\<inter> f ` D \\<subseteq> f ` C\""], ["proof (prove)\nusing this:\n  order.greater_eq (f ` D) (f ` C) \\<Longrightarrow> f ` C = f ` D\n\ngoal (1 subgoal):\n 1. order.greater_eq (f ` C) (f ` C \\<inter> f ` D)", "by fast"], ["proof (state)\nthis:\n  order.greater_eq (f ` C) (f ` C \\<inter> f ` D)\n\ngoal (1 subgoal):\n 1. card (f ` C - f ` C \\<inter> f ` D) = 1", "from assms(1)"], ["proof (chain)\npicking this:\n  domain.chamber C", "have \"card (f`C - f`C \\<inter> f`D) \\<le> card (f`C - f`(C\\<inter>D))\""], ["proof (prove)\nusing this:\n  domain.chamber C\n\ngoal (1 subgoal):\n 1. order.greater_eq (card (f ` C - f ` (C \\<inter> D)))\n     (card (f ` C - f ` C \\<inter> f ` D))", "using domain.finite_chamber\n          card_mono[of \"f`C - f`(C\\<inter>D)\" \"f`C - f`C \\<inter> f`D\"]"], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber ?x \\<Longrightarrow> finite ?x\n  \\<lbrakk>finite (f ` C - f ` (C \\<inter> D));\n   order.greater_eq (f ` C - f ` (C \\<inter> D))\n    (f ` C - f ` C \\<inter> f ` D)\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (card (f ` C - f ` (C \\<inter> D)))\n                     (card (f ` C - f ` C \\<inter> f ` D))\n\ngoal (1 subgoal):\n 1. order.greater_eq (card (f ` C - f ` (C \\<inter> D)))\n     (card (f ` C - f ` C \\<inter> f ` D))", "by    fast"], ["proof (state)\nthis:\n  order.greater_eq (card (f ` C - f ` (C \\<inter> D)))\n   (card (f ` C - f ` C \\<inter> f ` D))\n\ngoal (1 subgoal):\n 1. card (f ` C - f ` C \\<inter> f ` D) = 1", "moreover"], ["proof (state)\nthis:\n  order.greater_eq (card (f ` C - f ` (C \\<inter> D)))\n   (card (f ` C - f ` C \\<inter> f ` D))\n\ngoal (1 subgoal):\n 1. card (f ` C - f ` C \\<inter> f ` D) = 1", "from assms(1,3,4)"], ["proof (chain)\npicking this:\n  domain.chamber C\n  C \\<sim> D\n  f ` C \\<noteq> f ` D", "have \"card (f`C - f`(C\\<inter>D)) = 1\""], ["proof (prove)\nusing this:\n  domain.chamber C\n  C \\<sim> D\n  f ` C \\<noteq> f ` D\n\ngoal (1 subgoal):\n 1. card (f ` C - f ` (C \\<inter> D)) = 1", "using codim_map[of C \"C\\<inter>D\"] adjacent_int_facet1 facetrel_card"], ["proof (prove)\nusing this:\n  domain.chamber C\n  C \\<sim> D\n  f ` C \\<noteq> f ` D\n  \\<lbrakk>domain.chamber C; order.greater_eq C (C \\<inter> D)\\<rbrakk>\n  \\<Longrightarrow> card (f ` C - f ` (C \\<inter> D)) =\n                    card (C - C \\<inter> D)\n  \\<lbrakk>?x \\<sim> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<inter> ?y \\<lhd> ?x\n  ?y \\<lhd> ?x \\<Longrightarrow> card (?x - ?y) = 1\n\ngoal (1 subgoal):\n 1. card (f ` C - f ` (C \\<inter> D)) = 1", "by    fastforce"], ["proof (state)\nthis:\n  card (f ` C - f ` (C \\<inter> D)) = 1\n\ngoal (1 subgoal):\n 1. card (f ` C - f ` C \\<inter> f ` D) = 1", "ultimately"], ["proof (chain)\npicking this:\n  order.greater_eq (card (f ` C - f ` (C \\<inter> D)))\n   (card (f ` C - f ` C \\<inter> f ` D))\n  card (f ` C - f ` (C \\<inter> D)) = 1", "have \"card (f`C - f`C \\<inter> f`D) \\<le> 1\""], ["proof (prove)\nusing this:\n  order.greater_eq (card (f ` C - f ` (C \\<inter> D)))\n   (card (f ` C - f ` C \\<inter> f ` D))\n  card (f ` C - f ` (C \\<inter> D)) = 1\n\ngoal (1 subgoal):\n 1. order.greater_eq 1 (card (f ` C - f ` C \\<inter> f ` D))", "by simp"], ["proof (state)\nthis:\n  order.greater_eq 1 (card (f ` C - f ` C \\<inter> f ` D))\n\ngoal (1 subgoal):\n 1. card (f ` C - f ` C \\<inter> f ` D) = 1", "moreover"], ["proof (state)\nthis:\n  order.greater_eq 1 (card (f ` C - f ` C \\<inter> f ` D))\n\ngoal (1 subgoal):\n 1. card (f ` C - f ` C \\<inter> f ` D) = 1", "from 1 assms(1,4)"], ["proof (chain)\npicking this:\n  order.greater_eq (f ` D) (f ` C) \\<Longrightarrow> f ` C = f ` D\n  domain.chamber C\n  f ` C \\<noteq> f ` D", "have \"card (f`C - f`C \\<inter> f`D) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  order.greater_eq (f ` D) (f ` C) \\<Longrightarrow> f ` C = f ` D\n  domain.chamber C\n  f ` C \\<noteq> f ` D\n\ngoal (1 subgoal):\n 1. card (f ` C - f ` C \\<inter> f ` D) \\<noteq> 0", "using domain.finite_chamber"], ["proof (prove)\nusing this:\n  order.greater_eq (f ` D) (f ` C) \\<Longrightarrow> f ` C = f ` D\n  domain.chamber C\n  f ` C \\<noteq> f ` D\n  domain.chamber ?x \\<Longrightarrow> finite ?x\n\ngoal (1 subgoal):\n 1. card (f ` C - f ` C \\<inter> f ` D) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card (f ` C - f ` C \\<inter> f ` D) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (f ` C - f ` C \\<inter> f ` D) = 1", "ultimately"], ["proof (chain)\npicking this:\n  order.greater_eq 1 (card (f ` C - f ` C \\<inter> f ` D))\n  card (f ` C - f ` C \\<inter> f ` D) \\<noteq> 0", "show \"card (f`C - f`C \\<inter> f`D) = 1\""], ["proof (prove)\nusing this:\n  order.greater_eq 1 (card (f ` C - f ` C \\<inter> f ` D))\n  card (f ` C - f ` C \\<inter> f ` D) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (f ` C - f ` C \\<inter> f ` D) = 1", "by simp"], ["proof (state)\nthis:\n  card (f ` C - f ` C \\<inter> f ` D) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adj_map':\n  assumes \"domain.chamber C\" \"domain.chamber D\" \"C \\<sim> D\" \"f`C \\<noteq> f`D\"\n  shows   \"f`C \\<sim> f`D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` C \\<sim> f ` D", "using   assms(3,4) adj_int_im[OF assms] adjacent_sym\n          adj_int_im[OF assms(2) assms(1)]"], ["proof (prove)\nusing this:\n  C \\<sim> D\n  f ` C \\<noteq> f ` D\n  f ` C \\<inter> f ` D \\<lhd> f ` C\n  ?x \\<sim> ?y \\<Longrightarrow> ?y \\<sim> ?x\n  \\<lbrakk>D \\<sim> C; f ` D \\<noteq> f ` C\\<rbrakk>\n  \\<Longrightarrow> f ` D \\<inter> f ` C \\<lhd> f ` D\n\ngoal (1 subgoal):\n 1. f ` C \\<sim> f ` D", "by      (auto simp add: Int_commute intro: adjacentI)"], ["", "lemma adj_map:\n  \"\\<lbrakk> domain.chamber C; domain.chamber D; C \\<sim> D \\<rbrakk> \\<Longrightarrow> f`C \\<sim> f`D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>domain.chamber C; domain.chamber D; C \\<sim> D\\<rbrakk>\n    \\<Longrightarrow> f ` C \\<sim> f ` D", "using adjacent_refl[of \"f`C\"] adj_map' empty_not_adjacent[of D]"], ["proof (prove)\nusing this:\n  f ` C \\<noteq> {} \\<Longrightarrow> f ` C \\<sim> f ` C\n  \\<lbrakk>domain.chamber ?C; domain.chamber ?D; ?C \\<sim> ?D;\n   f ` ?C \\<noteq> f ` ?D\\<rbrakk>\n  \\<Longrightarrow> f ` ?C \\<sim> f ` ?D\n  \\<not> {} \\<sim> D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>domain.chamber C; domain.chamber D; C \\<sim> D\\<rbrakk>\n    \\<Longrightarrow> f ` C \\<sim> f ` D", "by fastforce"], ["", "lemma chamber_vertex_outside_facet_image:\n  assumes \"v\\<notin>z\" \"domain.chamber (insert v z)\"\n  shows   \"f v \\<notin> f`z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f v \\<notin> f ` z", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. f v \\<notin> f ` z", "from assms(1)"], ["proof (chain)\npicking this:\n  v \\<notin> z", "have \"insert v z - z = {v}\""], ["proof (prove)\nusing this:\n  v \\<notin> z\n\ngoal (1 subgoal):\n 1. insert v z - z = {v}", "by force"], ["proof (state)\nthis:\n  insert v z - z = {v}\n\ngoal (1 subgoal):\n 1. f v \\<notin> f ` z", "with assms(2)"], ["proof (chain)\npicking this:\n  domain.chamber (insert v z)\n  insert v z - z = {v}", "show ?thesis"], ["proof (prove)\nusing this:\n  domain.chamber (insert v z)\n  insert v z - z = {v}\n\ngoal (1 subgoal):\n 1. f v \\<notin> f ` z", "using codim_map"], ["proof (prove)\nusing this:\n  domain.chamber (insert v z)\n  insert v z - z = {v}\n  \\<lbrakk>domain.chamber ?C; order.greater_eq ?C ?y\\<rbrakk>\n  \\<Longrightarrow> card (f ` ?C - f ` ?y) = card (?C - ?y)\n\ngoal (1 subgoal):\n 1. f v \\<notin> f ` z", "by fastforce"], ["proof (state)\nthis:\n  f v \\<notin> f ` z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expand_codomain:\n  assumes \"ChamberComplex Z\" \"ChamberComplex.ChamberSubcomplex Z Y\"\n  shows   \"ChamberComplexMorphism X Z f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexMorphism X Z f", "proof (\n  rule ChamberComplexMorphism.intro, rule domain_complex, rule assms(1),\n  unfold_locales\n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       domain.chamber C \\<Longrightarrow>\n       SimplicialComplex.maxsimp Z (f ` C)\n 2. \\<And>C. domain.chamber C \\<Longrightarrow> card (f ` C) = card C", "from assms"], ["proof (chain)\npicking this:\n  ChamberComplex Z\n  ChamberComplex.ChamberSubcomplex Z Y", "show\n    \"\\<And>x. domain.chamber x \\<Longrightarrow> SimplicialComplex.maxsimp Z (f ` x)\""], ["proof (prove)\nusing this:\n  ChamberComplex Z\n  ChamberComplex.ChamberSubcomplex Z Y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       domain.chamber x \\<Longrightarrow>\n       SimplicialComplex.maxsimp Z (f ` x)", "using chamber_map ChamberComplex.subcomplex_chamber"], ["proof (prove)\nusing this:\n  ChamberComplex Z\n  ChamberComplex.ChamberSubcomplex Z Y\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n  \\<lbrakk>ChamberComplex ?X; ChamberComplex.ChamberSubcomplex ?X ?Y;\n   SimplicialComplex.maxsimp ?Y ?C\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp ?X ?C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       domain.chamber x \\<Longrightarrow>\n       SimplicialComplex.maxsimp Z (f ` x)", "by fast"], ["proof (state)\nthis:\n  domain.chamber ?x1 \\<Longrightarrow> SimplicialComplex.maxsimp Z (f ` ?x1)\n\ngoal (1 subgoal):\n 1. \\<And>C. domain.chamber C \\<Longrightarrow> card (f ` C) = card C", "qed (auto simp add: dim_map)"], ["", "end"], ["", "(* context ChamberComplexMorphism *)"], ["", "subsubsection \\<open>Action on pregalleries and galleries\\<close>"], ["", "context ChamberComplexMorphism\nbegin"], ["", "lemma gallery_map: \"domain.gallery Cs \\<Longrightarrow> codomain.gallery (f\\<Turnstile>Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain.gallery Cs \\<Longrightarrow> codomain.gallery (f \\<Turnstile> Cs)", "proof (induct Cs rule: list_induct_CCons)"], ["proof (state)\ngoal (3 subgoals):\n 1. domain.gallery [] \\<Longrightarrow> codomain.gallery (f \\<Turnstile> [])\n 2. \\<And>x.\n       domain.gallery [x] \\<Longrightarrow>\n       codomain.gallery (f \\<Turnstile> [x])\n 3. \\<And>x y xs.\n       \\<lbrakk>domain.gallery (y # xs) \\<Longrightarrow>\n                codomain.gallery (f \\<Turnstile> (y # xs));\n        domain.gallery (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> codomain.gallery (f \\<Turnstile> (x # y # xs))", "case (Single C)"], ["proof (state)\nthis:\n  domain.gallery [C]\n\ngoal (3 subgoals):\n 1. domain.gallery [] \\<Longrightarrow> codomain.gallery (f \\<Turnstile> [])\n 2. \\<And>x.\n       domain.gallery [x] \\<Longrightarrow>\n       codomain.gallery (f \\<Turnstile> [x])\n 3. \\<And>x y xs.\n       \\<lbrakk>domain.gallery (y # xs) \\<Longrightarrow>\n                codomain.gallery (f \\<Turnstile> (y # xs));\n        domain.gallery (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> codomain.gallery (f \\<Turnstile> (x # y # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  domain.gallery [C]\n\ngoal (1 subgoal):\n 1. codomain.gallery (f \\<Turnstile> [C])", "using domain.galleryD_chamber chamber_map codomain.gallery_def"], ["proof (prove)\nusing this:\n  domain.gallery [C]\n  \\<lbrakk>domain.gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> domain.chamber ?x\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n  codomain.gallery ?xs \\<equiv>\n  Ball (set ?xs) codomain.chamber \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. codomain.gallery (f \\<Turnstile> [C])", "by auto"], ["proof (state)\nthis:\n  codomain.gallery (f \\<Turnstile> [C])\n\ngoal (2 subgoals):\n 1. domain.gallery [] \\<Longrightarrow> codomain.gallery (f \\<Turnstile> [])\n 2. \\<And>x y xs.\n       \\<lbrakk>domain.gallery (y # xs) \\<Longrightarrow>\n                codomain.gallery (f \\<Turnstile> (y # xs));\n        domain.gallery (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> codomain.gallery (f \\<Turnstile> (x # y # xs))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. domain.gallery [] \\<Longrightarrow> codomain.gallery (f \\<Turnstile> [])\n 2. \\<And>x y xs.\n       \\<lbrakk>domain.gallery (y # xs) \\<Longrightarrow>\n                codomain.gallery (f \\<Turnstile> (y # xs));\n        domain.gallery (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> codomain.gallery (f \\<Turnstile> (x # y # xs))", "case (CCons B C Cs)"], ["proof (state)\nthis:\n  domain.gallery (C # Cs) \\<Longrightarrow>\n  codomain.gallery (f \\<Turnstile> (C # Cs))\n  domain.gallery (B # C # Cs)\n\ngoal (2 subgoals):\n 1. domain.gallery [] \\<Longrightarrow> codomain.gallery (f \\<Turnstile> [])\n 2. \\<And>x y xs.\n       \\<lbrakk>domain.gallery (y # xs) \\<Longrightarrow>\n                codomain.gallery (f \\<Turnstile> (y # xs));\n        domain.gallery (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> codomain.gallery (f \\<Turnstile> (x # y # xs))", "have \"codomain.gallery (f`B # f`C # f\\<Turnstile>Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomain.gallery (f ` B # f ` C # f \\<Turnstile> Cs)", "proof (rule codomain.gallery_CConsI)"], ["proof (state)\ngoal (3 subgoals):\n 1. codomain.chamber (f ` B)\n 2. codomain.gallery (f ` C # f \\<Turnstile> Cs)\n 3. f ` B \\<sim> f ` C", "from CCons(2)"], ["proof (chain)\npicking this:\n  domain.gallery (B # C # Cs)", "show \"codomain.chamber (f ` B)\""], ["proof (prove)\nusing this:\n  domain.gallery (B # C # Cs)\n\ngoal (1 subgoal):\n 1. codomain.chamber (f ` B)", "using domain.galleryD_chamber chamber_map"], ["proof (prove)\nusing this:\n  domain.gallery (B # C # Cs)\n  \\<lbrakk>domain.gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> domain.chamber ?x\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n\ngoal (1 subgoal):\n 1. codomain.chamber (f ` B)", "by simp"], ["proof (state)\nthis:\n  codomain.chamber (f ` B)\n\ngoal (2 subgoals):\n 1. codomain.gallery (f ` C # f \\<Turnstile> Cs)\n 2. f ` B \\<sim> f ` C", "from CCons"], ["proof (chain)\npicking this:\n  domain.gallery (C # Cs) \\<Longrightarrow>\n  codomain.gallery (f \\<Turnstile> (C # Cs))\n  domain.gallery (B # C # Cs)", "show \"codomain.gallery (f`C # f\\<Turnstile>Cs)\""], ["proof (prove)\nusing this:\n  domain.gallery (C # Cs) \\<Longrightarrow>\n  codomain.gallery (f \\<Turnstile> (C # Cs))\n  domain.gallery (B # C # Cs)\n\ngoal (1 subgoal):\n 1. codomain.gallery (f ` C # f \\<Turnstile> Cs)", "using domain.gallery_Cons_reduce"], ["proof (prove)\nusing this:\n  domain.gallery (C # Cs) \\<Longrightarrow>\n  codomain.gallery (f \\<Turnstile> (C # Cs))\n  domain.gallery (B # C # Cs)\n  domain.gallery (?x # ?xs) \\<Longrightarrow> domain.gallery ?xs\n\ngoal (1 subgoal):\n 1. codomain.gallery (f ` C # f \\<Turnstile> Cs)", "by auto"], ["proof (state)\nthis:\n  codomain.gallery (f ` C # f \\<Turnstile> Cs)\n\ngoal (1 subgoal):\n 1. f ` B \\<sim> f ` C", "from CCons(2)"], ["proof (chain)\npicking this:\n  domain.gallery (B # C # Cs)", "show \"f`B \\<sim>  f`C\""], ["proof (prove)\nusing this:\n  domain.gallery (B # C # Cs)\n\ngoal (1 subgoal):\n 1. f ` B \\<sim> f ` C", "using domain.gallery_Cons_reduce[of B \"C#Cs\"] domain.galleryD_adj\n            domain.galleryD_chamber adj_map"], ["proof (prove)\nusing this:\n  domain.gallery (B # C # Cs)\n  domain.gallery (B # C # Cs) \\<Longrightarrow> domain.gallery (C # Cs)\n  domain.gallery ?xs \\<Longrightarrow> adjacentchain ?xs\n  \\<lbrakk>domain.gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> domain.chamber ?x\n  \\<lbrakk>domain.chamber ?C; domain.chamber ?D; ?C \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> f ` ?C \\<sim> f ` ?D\n\ngoal (1 subgoal):\n 1. f ` B \\<sim> f ` C", "by    fastforce"], ["proof (state)\nthis:\n  f ` B \\<sim> f ` C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  codomain.gallery (f ` B # f ` C # f \\<Turnstile> Cs)\n\ngoal (2 subgoals):\n 1. domain.gallery [] \\<Longrightarrow> codomain.gallery (f \\<Turnstile> [])\n 2. \\<And>x y xs.\n       \\<lbrakk>domain.gallery (y # xs) \\<Longrightarrow>\n                codomain.gallery (f \\<Turnstile> (y # xs));\n        domain.gallery (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> codomain.gallery (f \\<Turnstile> (x # y # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  codomain.gallery (f ` B # f ` C # f \\<Turnstile> Cs)\n\ngoal (1 subgoal):\n 1. codomain.gallery (f \\<Turnstile> (B # C # Cs))", "by simp"], ["proof (state)\nthis:\n  codomain.gallery (f \\<Turnstile> (B # C # Cs))\n\ngoal (1 subgoal):\n 1. domain.gallery [] \\<Longrightarrow> codomain.gallery (f \\<Turnstile> [])", "qed (simp add: codomain.maxsimpchain_def)"], ["", "lemma gallery_betw_map:\n  \"domain.gallery (C#Cs@[D]) \\<Longrightarrow> codomain.gallery (f`C # f\\<Turnstile>Cs @ [f`D])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain.gallery (C # Cs @ [D]) \\<Longrightarrow>\n    codomain.gallery (f ` C # f \\<Turnstile> Cs @ [f ` D])", "using gallery_map"], ["proof (prove)\nusing this:\n  domain.gallery ?Cs \\<Longrightarrow> codomain.gallery (f \\<Turnstile> ?Cs)\n\ngoal (1 subgoal):\n 1. domain.gallery (C # Cs @ [D]) \\<Longrightarrow>\n    codomain.gallery (f ` C # f \\<Turnstile> Cs @ [f ` D])", "by fastforce"], ["", "end"], ["", "(* context ChamberComplexMorphism *)"], ["", "subsubsection \\<open>Properties of the image\\<close>"], ["", "context ChamberComplexMorphism\nbegin"], ["", "lemma subcomplex_image: \"codomain.Subcomplex (f\\<turnstile>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq Y (f \\<turnstile> X) \\<and>\n    SimplicialComplex (f \\<turnstile> X)", "using simplicialcomplex_image simplex_map"], ["proof (prove)\nusing this:\n  SimplicialComplex (f \\<turnstile> X)\n  ?x \\<in> X \\<Longrightarrow> f ` ?x \\<in> Y\n\ngoal (1 subgoal):\n 1. order.greater_eq Y (f \\<turnstile> X) \\<and>\n    SimplicialComplex (f \\<turnstile> X)", "by fast"], ["", "lemmas chamber_in_image = codomain.max_in_subcomplex[OF subcomplex_image]"], ["", "lemma maxsimp_map_into_image:\n  assumes \"domain.chamber x\"\n  shows   \"SimplicialComplex.maxsimp (f\\<turnstile>X) (f`x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` x)", "proof (\n  rule SimplicialComplex.maxsimpI, rule simplicialcomplex_image, rule imageI,\n  rule domain.chamberD_simplex, rule assms\n)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> f \\<turnstile> X;\n        order.greater_eq z (f ` x)\\<rbrakk>\n       \\<Longrightarrow> z = f ` x", "from assms"], ["proof (chain)\npicking this:\n  domain.chamber x", "show \"\\<And>z. z\\<in>f\\<turnstile>X \\<Longrightarrow> f`x \\<subseteq> z \\<Longrightarrow> z = f`x\""], ["proof (prove)\nusing this:\n  domain.chamber x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> f \\<turnstile> X;\n        order.greater_eq z (f ` x)\\<rbrakk>\n       \\<Longrightarrow> z = f ` x", "using chamber_map[of x] simplex_map codomain.chamberD_maximal[of \"f`x\"]"], ["proof (prove)\nusing this:\n  domain.chamber x\n  domain.chamber x \\<Longrightarrow> codomain.chamber (f ` x)\n  ?x \\<in> X \\<Longrightarrow> f ` ?x \\<in> Y\n  \\<lbrakk>codomain.chamber (f ` x); ?z \\<in> Y;\n   order.greater_eq ?z (f ` x)\\<rbrakk>\n  \\<Longrightarrow> ?z = f ` x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> f \\<turnstile> X;\n        order.greater_eq z (f ` x)\\<rbrakk>\n       \\<Longrightarrow> z = f ` x", "by    blast"], ["proof (state)\nthis:\n  \\<lbrakk>?z1 \\<in> f \\<turnstile> X; order.greater_eq ?z1 (f ` x)\\<rbrakk>\n  \\<Longrightarrow> ?z1 = f ` x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maxsimp_preimage:\n  assumes \"C\\<in>X\" \"SimplicialComplex.maxsimp (f\\<turnstile>X) (f`C)\"\n  shows \"domain.chamber C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain.chamber C", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. domain.chamber C", "from assms(1)"], ["proof (chain)\npicking this:\n  C \\<in> X", "obtain D where D: \"domain.chamber D\" \"C\\<subseteq>D\""], ["proof (prove)\nusing this:\n  C \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>domain.chamber D; order.greater_eq D C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using domain.simplex_in_max"], ["proof (prove)\nusing this:\n  C \\<in> X\n  ?y \\<in> X \\<Longrightarrow>\n  \\<exists>x. domain.chamber x \\<and> order.greater_eq x ?y\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>domain.chamber D; order.greater_eq D C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  domain.chamber D\n  order.greater_eq D C\n\ngoal (1 subgoal):\n 1. domain.chamber C", "have \"C=D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C = D", "proof (rule card_subset_eq)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite D\n 2. order.greater_eq D C\n 3. card C = card D", "from D(1)"], ["proof (chain)\npicking this:\n  domain.chamber D", "show \"finite D\""], ["proof (prove)\nusing this:\n  domain.chamber D\n\ngoal (1 subgoal):\n 1. finite D", "using domain.finite_chamber"], ["proof (prove)\nusing this:\n  domain.chamber D\n  domain.chamber ?x \\<Longrightarrow> finite ?x\n\ngoal (1 subgoal):\n 1. finite D", "by fast"], ["proof (state)\nthis:\n  finite D\n\ngoal (2 subgoals):\n 1. order.greater_eq D C\n 2. card C = card D", "with assms D"], ["proof (chain)\npicking this:\n  C \\<in> X\n  SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` C)\n  domain.chamber D\n  order.greater_eq D C\n  finite D", "show \"card C = card D\""], ["proof (prove)\nusing this:\n  C \\<in> X\n  SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` C)\n  domain.chamber D\n  order.greater_eq D C\n  finite D\n\ngoal (1 subgoal):\n 1. card C = card D", "using domain.chamberD_simplex simplicialcomplex_image\n            SimplicialComplex.maxsimpD_maximal[of \"f\\<turnstile>X\" \"f`C\" \"f`D\"]\n            card_mono[of D C] domain.finite_simplex card_image_le[of C f] dim_map"], ["proof (prove)\nusing this:\n  C \\<in> X\n  SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` C)\n  domain.chamber D\n  order.greater_eq D C\n  finite D\n  domain.chamber ?x \\<Longrightarrow> ?x \\<in> X\n  SimplicialComplex (f \\<turnstile> X)\n  \\<lbrakk>SimplicialComplex (f \\<turnstile> X);\n   SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` C);\n   f ` D \\<in> f \\<turnstile> X; order.greater_eq (f ` D) (f ` C)\\<rbrakk>\n  \\<Longrightarrow> f ` D = f ` C\n  \\<lbrakk>finite D; order.greater_eq D C\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (card D) (card C)\n  ?x \\<in> X \\<Longrightarrow> finite ?x\n  finite C \\<Longrightarrow> order.greater_eq (card C) (card (f ` C))\n  domain.chamber ?C \\<Longrightarrow> card (f ` ?C) = card ?C\n\ngoal (1 subgoal):\n 1. card C = card D", "by    force"], ["proof (state)\nthis:\n  card C = card D\n\ngoal (1 subgoal):\n 1. order.greater_eq D C", "qed (rule D(2))"], ["proof (state)\nthis:\n  C = D\n\ngoal (1 subgoal):\n 1. domain.chamber C", "with D(1)"], ["proof (chain)\npicking this:\n  domain.chamber D\n  C = D", "show ?thesis"], ["proof (prove)\nusing this:\n  domain.chamber D\n  C = D\n\ngoal (1 subgoal):\n 1. domain.chamber C", "by fast"], ["proof (state)\nthis:\n  domain.chamber C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chamber_preimage:\n  \"C\\<in>X \\<Longrightarrow> codomain.chamber (f`C) \\<Longrightarrow> domain.chamber C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> X; codomain.chamber (f ` C)\\<rbrakk>\n    \\<Longrightarrow> domain.chamber C", "using chamber_in_image maxsimp_preimage"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> f \\<turnstile> X; codomain.chamber ?y\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp (f \\<turnstile> X) ?y\n  \\<lbrakk>?C \\<in> X;\n   SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` ?C)\\<rbrakk>\n  \\<Longrightarrow> domain.chamber ?C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> X; codomain.chamber (f ` C)\\<rbrakk>\n    \\<Longrightarrow> domain.chamber C", "by simp"], ["", "lemma chambercomplex_image: \"ChamberComplex (f\\<turnstile>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplex (f \\<turnstile> X)", "proof (intro_locales, rule simplicialcomplex_image, unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> f \\<turnstile> X \\<Longrightarrow>\n       \\<exists>x.\n          SimplicialComplex.maxsimp (f \\<turnstile> X) x \\<and>\n          order.greater_eq x y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) x;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain\n                             (f \\<turnstile> X) (x # xs @ [y])", "show \"\\<And>y. y\\<in>f\\<turnstile>X \\<Longrightarrow> \\<exists>x. SimplicialComplex.maxsimp (f\\<turnstile>X) x \\<and> y \\<subseteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> f \\<turnstile> X \\<Longrightarrow>\n       \\<exists>x.\n          SimplicialComplex.maxsimp (f \\<turnstile> X) x \\<and>\n          order.greater_eq x y", "using domain.simplex_in_max maxsimp_map_into_image"], ["proof (prove)\nusing this:\n  ?y \\<in> X \\<Longrightarrow>\n  \\<exists>x. domain.chamber x \\<and> order.greater_eq x ?y\n  domain.chamber ?x \\<Longrightarrow>\n  SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` ?x)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> f \\<turnstile> X \\<Longrightarrow>\n       \\<exists>x.\n          SimplicialComplex.maxsimp (f \\<turnstile> X) x \\<and>\n          order.greater_eq x y", "by fast"], ["proof (state)\nthis:\n  ?y1 \\<in> f \\<turnstile> X \\<Longrightarrow>\n  \\<exists>x.\n     SimplicialComplex.maxsimp (f \\<turnstile> X) x \\<and>\n     order.greater_eq x ?y1\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) x;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain\n                             (f \\<turnstile> X) (x # xs @ [y])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) x;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain\n                             (f \\<turnstile> X) (x # xs @ [y])", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) x;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain\n                             (f \\<turnstile> X) (x # xs @ [y])", "assume xy:  \"x\\<noteq>y\" \"SimplicialComplex.maxsimp (f\\<turnstile>X) x\"\n              \"SimplicialComplex.maxsimp (f\\<turnstile>X) y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n  SimplicialComplex.maxsimp (f \\<turnstile> X) x\n  SimplicialComplex.maxsimp (f \\<turnstile> X) y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) x;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain\n                             (f \\<turnstile> X) (x # xs @ [y])", "from xy(2,3)"], ["proof (chain)\npicking this:\n  SimplicialComplex.maxsimp (f \\<turnstile> X) x\n  SimplicialComplex.maxsimp (f \\<turnstile> X) y", "obtain zx zy where zxy: \"zx\\<in>X\" \"x = f`zx\" \"zy\\<in>X\" \"y = f`zy \""], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp (f \\<turnstile> X) x\n  SimplicialComplex.maxsimp (f \\<turnstile> X) y\n\ngoal (1 subgoal):\n 1. (\\<And>zx zy.\n        \\<lbrakk>zx \\<in> X; x = f ` zx; zy \\<in> X; y = f ` zy\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using SimplicialComplex.maxsimpD_simplex[OF simplicialcomplex_image, of x]\n          SimplicialComplex.maxsimpD_simplex[OF simplicialcomplex_image, of y]"], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp (f \\<turnstile> X) x\n  SimplicialComplex.maxsimp (f \\<turnstile> X) y\n  SimplicialComplex.maxsimp (f \\<turnstile> X) x \\<Longrightarrow>\n  x \\<in> f \\<turnstile> X\n  SimplicialComplex.maxsimp (f \\<turnstile> X) y \\<Longrightarrow>\n  y \\<in> f \\<turnstile> X\n\ngoal (1 subgoal):\n 1. (\\<And>zx zy.\n        \\<lbrakk>zx \\<in> X; x = f ` zx; zy \\<in> X; y = f ` zy\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  zx \\<in> X\n  x = f ` zx\n  zy \\<in> X\n  y = f ` zy\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) x;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain\n                             (f \\<turnstile> X) (x # xs @ [y])", "with xy"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  SimplicialComplex.maxsimp (f \\<turnstile> X) x\n  SimplicialComplex.maxsimp (f \\<turnstile> X) y\n  zx \\<in> X\n  x = f ` zx\n  zy \\<in> X\n  y = f ` zy", "obtain ws where ws: \"domain.gallery (zx#ws@[zy])\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  SimplicialComplex.maxsimp (f \\<turnstile> X) x\n  SimplicialComplex.maxsimp (f \\<turnstile> X) y\n  zx \\<in> X\n  x = f ` zx\n  zy \\<in> X\n  y = f ` zy\n\ngoal (1 subgoal):\n 1. (\\<And>ws.\n        domain.gallery (zx # ws @ [zy]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using maxsimp_preimage domain.maxsimp_connect[of zx zy]"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  SimplicialComplex.maxsimp (f \\<turnstile> X) x\n  SimplicialComplex.maxsimp (f \\<turnstile> X) y\n  zx \\<in> X\n  x = f ` zx\n  zy \\<in> X\n  y = f ` zy\n  \\<lbrakk>?C \\<in> X;\n   SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` ?C)\\<rbrakk>\n  \\<Longrightarrow> domain.chamber ?C\n  \\<lbrakk>zx \\<noteq> zy; domain.chamber zx; domain.chamber zy\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs. domain.gallery (zx # xs @ [zy])\n\ngoal (1 subgoal):\n 1. (\\<And>ws.\n        domain.gallery (zx # ws @ [zy]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  domain.gallery (zx # ws @ [zy])\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) x;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain\n                             (f \\<turnstile> X) (x # xs @ [y])", "with ws zxy(2,4)"], ["proof (chain)\npicking this:\n  domain.gallery (zx # ws @ [zy])\n  x = f ` zx\n  y = f ` zy\n  domain.gallery (zx # ws @ [zy])", "have \"SimplicialComplex.maxsimpchain (f\\<turnstile>X) (x#(f\\<Turnstile>ws)@[y])\""], ["proof (prove)\nusing this:\n  domain.gallery (zx # ws @ [zy])\n  x = f ` zx\n  y = f ` zy\n  domain.gallery (zx # ws @ [zy])\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimpchain (f \\<turnstile> X)\n     (x # f \\<Turnstile> ws @ [y])", "using gallery_map[of \"zx#ws@[zy]\"] domain.galleryD_chamber\n          domain.chamberD_simplex codomain.galleryD_chamber\n          codomain.max_in_subcomplex[OF subcomplex_image]\n          codomain.galleryD_adj\n          SimplicialComplex.maxsimpchain_def[OF simplicialcomplex_image]"], ["proof (prove)\nusing this:\n  domain.gallery (zx # ws @ [zy])\n  x = f ` zx\n  y = f ` zy\n  domain.gallery (zx # ws @ [zy])\n  domain.gallery (zx # ws @ [zy]) \\<Longrightarrow>\n  codomain.gallery (f \\<Turnstile> (zx # ws @ [zy]))\n  \\<lbrakk>domain.gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> domain.chamber ?x\n  domain.chamber ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>codomain.gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> codomain.chamber ?x\n  \\<lbrakk>?y \\<in> f \\<turnstile> X; codomain.chamber ?y\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp (f \\<turnstile> X) ?y\n  codomain.gallery ?xs \\<Longrightarrow> adjacentchain ?xs\n  SimplicialComplex.maxsimpchain (f \\<turnstile> X) ?xs \\<equiv>\n  (\\<forall>x\\<in>set ?xs.\n      SimplicialComplex.maxsimp (f \\<turnstile> X) x) \\<and>\n  adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimpchain (f \\<turnstile> X)\n     (x # f \\<Turnstile> ws @ [y])", "by    auto"], ["proof (state)\nthis:\n  SimplicialComplex.maxsimpchain (f \\<turnstile> X)\n   (x # f \\<Turnstile> ws @ [y])\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) x;\n        SimplicialComplex.maxsimp (f \\<turnstile> X) y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain\n                             (f \\<turnstile> X) (x # xs @ [y])", "thus \"\\<exists>xs. SimplicialComplex.maxsimpchain (f\\<turnstile>X) (x#xs@[y])\""], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimpchain (f \\<turnstile> X)\n   (x # f \\<Turnstile> ws @ [y])\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       SimplicialComplex.maxsimpchain (f \\<turnstile> X) (x # xs @ [y])", "by fast"], ["proof (state)\nthis:\n  \\<exists>xs.\n     SimplicialComplex.maxsimpchain (f \\<turnstile> X) (x # xs @ [y])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chambersubcomplex_image: \"codomain.ChamberSubcomplex (f\\<turnstile>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomain.ChamberSubcomplex (f \\<turnstile> X)", "using simplices_map chambercomplex_image ChamberComplex.chamberD_simplex\n        chambercomplex_image maxsimp_preimage chamber_map"], ["proof (prove)\nusing this:\n  order.greater_eq Y (f \\<turnstile> X)\n  ChamberComplex (f \\<turnstile> X)\n  \\<lbrakk>ChamberComplex ?X; SimplicialComplex.maxsimp ?X ?x\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ?X\n  ChamberComplex (f \\<turnstile> X)\n  \\<lbrakk>?C \\<in> X;\n   SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` ?C)\\<rbrakk>\n  \\<Longrightarrow> domain.chamber ?C\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n\ngoal (1 subgoal):\n 1. codomain.ChamberSubcomplex (f \\<turnstile> X)", "by    (force intro: codomain.ChamberSubcomplexI)"], ["", "lemma restrict_codomain_to_image: \"ChamberComplexMorphism X (f\\<turnstile>X) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexMorphism X (f \\<turnstile> X) f", "using restrict_codomain chambersubcomplex_image"], ["proof (prove)\nusing this:\n  \\<lbrakk>codomain.ChamberSubcomplex ?Z;\n   order.greater_eq ?Z (f \\<turnstile> X)\\<rbrakk>\n  \\<Longrightarrow> ChamberComplexMorphism X ?Z f\n  codomain.ChamberSubcomplex (f \\<turnstile> X)\n\ngoal (1 subgoal):\n 1. ChamberComplexMorphism X (f \\<turnstile> X) f", "by fast"], ["", "end"], ["", "(* context ChamberComplexMorphism *)"], ["", "subsubsection \\<open>Action on the chamber system\\<close>"], ["", "context ChamberComplexMorphism\nbegin"], ["", "lemma chamber_system_into: \"f\\<turnstile>domain.\\<C> \\<subseteq> codomain.\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq codomain.\\<C> (f \\<turnstile> domain.\\<C>)", "using chamber_map domain.chamber_system_def codomain.chamber_system_def"], ["proof (prove)\nusing this:\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n  domain.\\<C> \\<equiv> Collect domain.chamber\n  codomain.\\<C> \\<equiv> Collect codomain.chamber\n\ngoal (1 subgoal):\n 1. order.greater_eq codomain.\\<C> (f \\<turnstile> domain.\\<C>)", "by    auto"], ["", "lemma chamber_system_image: \"f\\<turnstile>domain.\\<C> = codomain.\\<C> \\<inter> (f\\<turnstile>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<turnstile> domain.\\<C> = codomain.\\<C> \\<inter> (f \\<turnstile> X)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq (codomain.\\<C> \\<inter> (f \\<turnstile> X))\n     (f \\<turnstile> domain.\\<C>)\n 2. order.greater_eq (f \\<turnstile> domain.\\<C>)\n     (codomain.\\<C> \\<inter> (f \\<turnstile> X))", "show \"f\\<turnstile>domain.\\<C> \\<subseteq> codomain.\\<C> \\<inter> (f\\<turnstile>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (codomain.\\<C> \\<inter> (f \\<turnstile> X))\n     (f \\<turnstile> domain.\\<C>)", "using chamber_system_into domain.chamber_system_simplices"], ["proof (prove)\nusing this:\n  order.greater_eq codomain.\\<C> (f \\<turnstile> domain.\\<C>)\n  order.greater_eq X domain.\\<C>\n\ngoal (1 subgoal):\n 1. order.greater_eq (codomain.\\<C> \\<inter> (f \\<turnstile> X))\n     (f \\<turnstile> domain.\\<C>)", "by fast"], ["proof (state)\nthis:\n  order.greater_eq (codomain.\\<C> \\<inter> (f \\<turnstile> X))\n   (f \\<turnstile> domain.\\<C>)\n\ngoal (1 subgoal):\n 1. order.greater_eq (f \\<turnstile> domain.\\<C>)\n     (codomain.\\<C> \\<inter> (f \\<turnstile> X))", "show \"f\\<turnstile>domain.\\<C> \\<supseteq> codomain.\\<C> \\<inter> (f\\<turnstile>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (f \\<turnstile> domain.\\<C>)\n     (codomain.\\<C> \\<inter> (f \\<turnstile> X))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> codomain.\\<C> \\<inter> (f \\<turnstile> X) \\<Longrightarrow>\n       x \\<in> f \\<turnstile> domain.\\<C>", "fix D"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> codomain.\\<C> \\<inter> (f \\<turnstile> X) \\<Longrightarrow>\n       x \\<in> f \\<turnstile> domain.\\<C>", "assume \"D \\<in> codomain.\\<C> \\<inter> (f\\<turnstile>X)\""], ["proof (state)\nthis:\n  D \\<in> codomain.\\<C> \\<inter> (f \\<turnstile> X)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> codomain.\\<C> \\<inter> (f \\<turnstile> X) \\<Longrightarrow>\n       x \\<in> f \\<turnstile> domain.\\<C>", "hence \"\\<exists>C. domain.chamber C \\<and> f`C = D\""], ["proof (prove)\nusing this:\n  D \\<in> codomain.\\<C> \\<inter> (f \\<turnstile> X)\n\ngoal (1 subgoal):\n 1. \\<exists>C. domain.chamber C \\<and> f ` C = D", "using codomain.chamber_system_def chamber_preimage"], ["proof (prove)\nusing this:\n  D \\<in> codomain.\\<C> \\<inter> (f \\<turnstile> X)\n  codomain.\\<C> \\<equiv> Collect codomain.chamber\n  \\<lbrakk>?C \\<in> X; codomain.chamber (f ` ?C)\\<rbrakk>\n  \\<Longrightarrow> domain.chamber ?C\n\ngoal (1 subgoal):\n 1. \\<exists>C. domain.chamber C \\<and> f ` C = D", "by fast"], ["proof (state)\nthis:\n  \\<exists>C. domain.chamber C \\<and> f ` C = D\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> codomain.\\<C> \\<inter> (f \\<turnstile> X) \\<Longrightarrow>\n       x \\<in> f \\<turnstile> domain.\\<C>", "thus \"D \\<in> f\\<turnstile>domain.\\<C>\""], ["proof (prove)\nusing this:\n  \\<exists>C. domain.chamber C \\<and> f ` C = D\n\ngoal (1 subgoal):\n 1. D \\<in> f \\<turnstile> domain.\\<C>", "using domain.chamber_system_def"], ["proof (prove)\nusing this:\n  \\<exists>C. domain.chamber C \\<and> f ` C = D\n  domain.\\<C> \\<equiv> Collect domain.chamber\n\ngoal (1 subgoal):\n 1. D \\<in> f \\<turnstile> domain.\\<C>", "by auto"], ["proof (state)\nthis:\n  D \\<in> f \\<turnstile> domain.\\<C>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq (f \\<turnstile> domain.\\<C>)\n   (codomain.\\<C> \\<inter> (f \\<turnstile> X))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_chamber_system: \"ChamberComplex.\\<C> (f\\<turnstile>X) = f \\<turnstile> domain.\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplex.chamber_system (f \\<turnstile> X) =\n    f \\<turnstile> domain.\\<C>", "using ChamberComplex.chamber_system_def codomain.subcomplex_chamber\n        ChamberComplex.chamberD_simplex chambercomplex_image\n        chambersubcomplex_image chamber_system_image\n        codomain.chamber_in_subcomplex codomain.chamber_system_def"], ["proof (prove)\nusing this:\n  ChamberComplex ?X \\<Longrightarrow>\n  ChamberComplex.chamber_system ?X \\<equiv>\n  {C. SimplicialComplex.maxsimp ?X C}\n  \\<lbrakk>codomain.ChamberSubcomplex ?Y;\n   SimplicialComplex.maxsimp ?Y ?C\\<rbrakk>\n  \\<Longrightarrow> codomain.chamber ?C\n  \\<lbrakk>ChamberComplex ?X; SimplicialComplex.maxsimp ?X ?x\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ?X\n  ChamberComplex (f \\<turnstile> X)\n  codomain.ChamberSubcomplex (f \\<turnstile> X)\n  f \\<turnstile> domain.\\<C> = codomain.\\<C> \\<inter> (f \\<turnstile> X)\n  \\<lbrakk>codomain.ChamberSubcomplex ?Y; ?C \\<in> ?Y;\n   codomain.chamber ?C\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp ?Y ?C\n  codomain.\\<C> \\<equiv> Collect codomain.chamber\n\ngoal (1 subgoal):\n 1. ChamberComplex.chamber_system (f \\<turnstile> X) =\n    f \\<turnstile> domain.\\<C>", "by    auto"], ["", "lemma image_chamber_system_image:\n  \"ChamberComplex.\\<C> (f\\<turnstile>X) = codomain.\\<C> \\<inter> (f\\<turnstile>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplex.chamber_system (f \\<turnstile> X) =\n    codomain.\\<C> \\<inter> (f \\<turnstile> X)", "using image_chamber_system chamber_system_image"], ["proof (prove)\nusing this:\n  ChamberComplex.chamber_system (f \\<turnstile> X) =\n  f \\<turnstile> domain.\\<C>\n  f \\<turnstile> domain.\\<C> = codomain.\\<C> \\<inter> (f \\<turnstile> X)\n\ngoal (1 subgoal):\n 1. ChamberComplex.chamber_system (f \\<turnstile> X) =\n    codomain.\\<C> \\<inter> (f \\<turnstile> X)", "by simp"], ["", "lemma face_distance_eq_chamber_distance_map:\n  assumes \"domain.chamber C\" \"domain.chamber D\" \"C\\<noteq>D\" \"z\\<subseteq>C\"\n          \"codomain.face_distance (f`z) (f`D) = domain.face_distance z D\"\n          \"domain.face_distance z D = domain.chamber_distance C D\"\n  shows   \"codomain.face_distance (f`z) (f`D) =\n            codomain.chamber_distance (f`C) (f`D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomain.face_distance (f ` z) (f ` D) =\n    codomain.chamber_distance (f ` C) (f ` D)", "using   assms codomain.face_distance_le[of \"f`C\" \"f`z\" \"f`D\"] chamber_map\n          codomain.chamber_distance_le\n          gallery_betw_map[OF domain.gallery_least_length, of C D]\n          domain.chamber_distance_def"], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  C \\<noteq> D\n  order.greater_eq C z\n  codomain.face_distance (f ` z) (f ` D) = domain.face_distance z D\n  domain.face_distance z D = domain.chamber_distance C D\n  \\<lbrakk>codomain.chamber (f ` C);\n   order.greater_eq (f ` C) (f ` z)\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq\n                     (codomain.chamber_distance (f ` C) (f ` D))\n                     (codomain.face_distance (f ` z) (f ` D))\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n  codomain.gallery (?C # ?Cs @ [?D]) \\<Longrightarrow>\n  order.greater_eq (Suc (length ?Cs)) (codomain.chamber_distance ?C ?D)\n  \\<lbrakk>domain.chamber C; domain.chamber D; C \\<noteq> D\\<rbrakk>\n  \\<Longrightarrow> codomain.gallery\n                     (f ` C #\n                      f \\<Turnstile>\n                      (ARG_MIN length Cs. domain.gallery (C # Cs @ [D])) @\n                      [f ` D])\n  domain.chamber_distance ?C ?D =\n  (if ?C = ?D then 0\n   else Suc (length (ARG_MIN length Cs. domain.gallery (?C # Cs @ [?D]))))\n\ngoal (1 subgoal):\n 1. codomain.face_distance (f ` z) (f ` D) =\n    codomain.chamber_distance (f ` C) (f ` D)", "by      force"], ["", "lemma face_distance_eq_chamber_distance_min_gallery_betw_map:\n  assumes \"domain.chamber C\" \"domain.chamber D\" \"C\\<noteq>D\" \"z\\<subseteq>C\"\n          \"codomain.face_distance (f`z) (f`D) = domain.face_distance z D\"\n          \"domain.face_distance z D = domain.chamber_distance C D\"\n          \"domain.min_gallery (C#Cs@[D])\"\n  shows   \"codomain.min_gallery (f\\<Turnstile>(C#Cs@[D]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomain.min_gallery (f \\<Turnstile> (C # Cs @ [D]))", "using   assms face_distance_eq_chamber_distance_map[of C D z]\n          gallery_map[OF domain.min_galleryD_gallery, OF assms(7)]\n          domain.min_gallery_betw_chamber_distance[OF assms(7)] \n          codomain.min_galleryI_chamber_distance_betw[of \"f`C\" \"f\\<Turnstile>Cs\" \"f`D\"]"], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  C \\<noteq> D\n  order.greater_eq C z\n  codomain.face_distance (f ` z) (f ` D) = domain.face_distance z D\n  domain.face_distance z D = domain.chamber_distance C D\n  domain.min_gallery (C # Cs @ [D])\n  \\<lbrakk>domain.chamber C; domain.chamber D; C \\<noteq> D;\n   order.greater_eq C z;\n   codomain.face_distance (f ` z) (f ` D) = domain.face_distance z D;\n   domain.face_distance z D = domain.chamber_distance C D\\<rbrakk>\n  \\<Longrightarrow> codomain.face_distance (f ` z) (f ` D) =\n                    codomain.chamber_distance (f ` C) (f ` D)\n  codomain.gallery (f \\<Turnstile> (C # Cs @ [D]))\n  domain.chamber_distance C D = Suc (length Cs)\n  \\<lbrakk>codomain.gallery (f ` C # f \\<Turnstile> Cs @ [f ` D]);\n   Suc (length (f \\<Turnstile> Cs)) =\n   codomain.chamber_distance (f ` C) (f ` D)\\<rbrakk>\n  \\<Longrightarrow> codomain.min_gallery\n                     (f ` C # f \\<Turnstile> Cs @ [f ` D])\n\ngoal (1 subgoal):\n 1. codomain.min_gallery (f \\<Turnstile> (C # Cs @ [D]))", "by      auto"], ["", "end"], ["", "(* context ChamberComplexMorphism *)"], ["", "subsubsection \\<open>Isomorphisms\\<close>"], ["", "locale ChamberComplexIsomorphism = ChamberComplexMorphism X Y f\n  for X  :: \"'a set set\"\n  and Y  :: \"'b set set\"\n  and f  :: \"'a\\<Rightarrow>'b\"\n+ assumes bij_betw_vertices: \"bij_betw f (\\<Union>X) (\\<Union>Y)\"\n  and     surj_simplex_map : \"f\\<turnstile>X = Y\""], ["", "lemma (in ChamberComplexIsomorphism) inj: \"inj_on f (\\<Union>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (\\<Union> X)", "using bij_betw_vertices bij_betw_def"], ["proof (prove)\nusing this:\n  bij_betw f (\\<Union> X) (\\<Union> Y)\n  bij_betw ?f ?A ?B = (inj_on ?f ?A \\<and> ?f ` ?A = ?B)\n\ngoal (1 subgoal):\n 1. inj_on f (\\<Union> X)", "by fast"], ["", "sublocale ChamberComplexIsomorphism < SimplicialComplexIsomorphism"], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplexIsomorphism X f", "using inj"], ["proof (prove)\nusing this:\n  inj_on f (\\<Union> X)\n\ngoal (1 subgoal):\n 1. SimplicialComplexIsomorphism X f", "by (unfold_locales) fast"], ["", "lemma (in ChamberComplex) trivial_isomorphism:\n  \"ChamberComplexIsomorphism X X id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexIsomorphism X X id", "using trivial_morphism bij_betw_id"], ["proof (prove)\nusing this:\n  ChamberComplexMorphism X X id\n  bij_betw id ?A ?A\n\ngoal (1 subgoal):\n 1. ChamberComplexIsomorphism X X id", "by    unfold_locales (auto intro: ChamberComplexIsomorphism.intro)"], ["", "lemma (in ChamberComplexMorphism) isoI_inverse:\n  assumes \"ChamberComplexMorphism Y X g\"\n          \"fixespointwise (g\\<circ>f) (\\<Union>X)\" \"fixespointwise (f\\<circ>g) (\\<Union>Y)\"\n  shows   \"ChamberComplexIsomorphism X Y f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexIsomorphism X Y f", "proof (rule ChamberComplexIsomorphism.intro)"], ["proof (state)\ngoal (2 subgoals):\n 1. ChamberComplexMorphism X Y f\n 2. ChamberComplexIsomorphism_axioms X Y f", "show \"ChamberComplexMorphism X Y f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexMorphism X Y f", ".."], ["proof (state)\nthis:\n  ChamberComplexMorphism X Y f\n\ngoal (1 subgoal):\n 1. ChamberComplexIsomorphism_axioms X Y f", "show \"ChamberComplexIsomorphism_axioms X Y f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexIsomorphism_axioms X Y f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. bij_betw f (\\<Union> X) (\\<Union> Y)\n 2. f \\<turnstile> X = Y", "from assms"], ["proof (chain)\npicking this:\n  ChamberComplexMorphism Y X g\n  fixespointwise (g \\<circ> f) (\\<Union> X)\n  fixespointwise (f \\<circ> g) (\\<Union> Y)", "show \"bij_betw f (\\<Union>X) (\\<Union>Y)\""], ["proof (prove)\nusing this:\n  ChamberComplexMorphism Y X g\n  fixespointwise (g \\<circ> f) (\\<Union> X)\n  fixespointwise (f \\<circ> g) (\\<Union> Y)\n\ngoal (1 subgoal):\n 1. bij_betw f (\\<Union> X) (\\<Union> Y)", "using vertex_map ChamberComplexMorphism.vertex_map\n            comps_fixpointwise_imp_bij_betw[of f \"\\<Union>X\" \"\\<Union>Y\" g]"], ["proof (prove)\nusing this:\n  ChamberComplexMorphism Y X g\n  fixespointwise (g \\<circ> f) (\\<Union> X)\n  fixespointwise (f \\<circ> g) (\\<Union> Y)\n  ?x \\<in> \\<Union> X \\<Longrightarrow> f ?x \\<in> \\<Union> Y\n  \\<lbrakk>ChamberComplexMorphism ?X ?Y ?f; ?x \\<in> \\<Union> ?X\\<rbrakk>\n  \\<Longrightarrow> ?f ?x \\<in> \\<Union> ?Y\n  \\<lbrakk>order.greater_eq (\\<Union> Y) (f ` \\<Union> X);\n   order.greater_eq (\\<Union> X) (g ` \\<Union> Y);\n   fixespointwise (g \\<circ> f) (\\<Union> X);\n   fixespointwise (f \\<circ> g) (\\<Union> Y)\\<rbrakk>\n  \\<Longrightarrow> bij_betw f (\\<Union> X) (\\<Union> Y)\n\ngoal (1 subgoal):\n 1. bij_betw f (\\<Union> X) (\\<Union> Y)", "by    fast"], ["proof (state)\nthis:\n  bij_betw f (\\<Union> X) (\\<Union> Y)\n\ngoal (1 subgoal):\n 1. f \\<turnstile> X = Y", "show \"f\\<turnstile>X = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<turnstile> X = Y", "proof (rule order.antisym, rule simplices_map, rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Y \\<Longrightarrow> x \\<in> f \\<turnstile> X", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Y \\<Longrightarrow> x \\<in> f \\<turnstile> X", "assume \"y\\<in>Y\""], ["proof (state)\nthis:\n  y \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Y \\<Longrightarrow> x \\<in> f \\<turnstile> X", "moreover"], ["proof (state)\nthis:\n  y \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Y \\<Longrightarrow> x \\<in> f \\<turnstile> X", "hence \"(f\\<circ>g) ` y \\<in> f\\<turnstile>X\""], ["proof (prove)\nusing this:\n  y \\<in> Y\n\ngoal (1 subgoal):\n 1. (f \\<circ> g) ` y \\<in> f \\<turnstile> X", "using ChamberComplexMorphism.simplex_map[OF assms(1)]"], ["proof (prove)\nusing this:\n  y \\<in> Y\n  ?x \\<in> Y \\<Longrightarrow> g ` ?x \\<in> X\n\ngoal (1 subgoal):\n 1. (f \\<circ> g) ` y \\<in> f \\<turnstile> X", "by    (simp add: image_comp[THEN sym])"], ["proof (state)\nthis:\n  (f \\<circ> g) ` y \\<in> f \\<turnstile> X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Y \\<Longrightarrow> x \\<in> f \\<turnstile> X", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> Y\n  (f \\<circ> g) ` y \\<in> f \\<turnstile> X", "show \"y \\<in> f\\<turnstile>X\""], ["proof (prove)\nusing this:\n  y \\<in> Y\n  (f \\<circ> g) ` y \\<in> f \\<turnstile> X\n\ngoal (1 subgoal):\n 1. y \\<in> f \\<turnstile> X", "using fixespointwise_subset[OF assms(3), of y] fixespointwise_im"], ["proof (prove)\nusing this:\n  y \\<in> Y\n  (f \\<circ> g) ` y \\<in> f \\<turnstile> X\n  order.greater_eq (\\<Union> Y) y \\<Longrightarrow>\n  fixespointwise (f \\<circ> g) y\n  \\<lbrakk>fixespointwise ?f ?A; order.greater_eq ?A ?B\\<rbrakk>\n  \\<Longrightarrow> ?f ` ?B = ?B\n\ngoal (1 subgoal):\n 1. y \\<in> f \\<turnstile> X", "by fastforce"], ["proof (state)\nthis:\n  y \\<in> f \\<turnstile> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f \\<turnstile> X = Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ChamberComplexIsomorphism_axioms X Y f\n\ngoal:\nNo subgoals!", "qed"], ["", "context ChamberComplexIsomorphism\nbegin"], ["", "lemmas domain_complex   = domain_complex"], ["", "lemmas chamber_map      = chamber_map"], ["", "lemmas dim_map          = dim_map"], ["", "lemmas gallery_map      = gallery_map"], ["", "lemmas simplex_map      = simplex_map"], ["", "lemmas chamber_preimage = chamber_preimage"], ["", "lemma chamber_morphism: \"ChamberComplexMorphism X Y f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexMorphism X Y f", ".."], ["", "lemma pgallery_map: \"domain.pgallery Cs \\<Longrightarrow> codomain.pgallery (f\\<Turnstile>Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain.pgallery Cs \\<Longrightarrow>\n    codomain.pgallery (f \\<Turnstile> Cs)", "using pmaxsimpchain_map surj_simplex_map"], ["proof (prove)\nusing this:\n  domain.pgallery ?xs \\<Longrightarrow>\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (f \\<Turnstile> ?xs)\n  f \\<turnstile> X = Y\n\ngoal (1 subgoal):\n 1. domain.pgallery Cs \\<Longrightarrow>\n    codomain.pgallery (f \\<Turnstile> Cs)", "by simp"], ["", "lemma iso_cong:\n  assumes \"fun_eq_on g f (\\<Union>X)\"\n  shows   \"ChamberComplexIsomorphism X Y g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexIsomorphism X Y g", "proof (\n  rule ChamberComplexIsomorphism.intro, rule cong, rule assms,\n  unfold_locales\n)"], ["proof (state)\ngoal (2 subgoals):\n 1. bij_betw g (\\<Union> X) (\\<Union> Y)\n 2. g \\<turnstile> X = Y", "from assms"], ["proof (chain)\npicking this:\n  fun_eq_on g f (\\<Union> X)", "show \"bij_betw g (\\<Union>X) (\\<Union>Y)\""], ["proof (prove)\nusing this:\n  fun_eq_on g f (\\<Union> X)\n\ngoal (1 subgoal):\n 1. bij_betw g (\\<Union> X) (\\<Union> Y)", "using bij_betw_vertices fun_eq_on_bij_betw"], ["proof (prove)\nusing this:\n  fun_eq_on g f (\\<Union> X)\n  bij_betw f (\\<Union> X) (\\<Union> Y)\n  fun_eq_on ?f ?g ?A \\<Longrightarrow> bij_betw ?f ?A ?B = bij_betw ?g ?A ?B\n\ngoal (1 subgoal):\n 1. bij_betw g (\\<Union> X) (\\<Union> Y)", "by blast"], ["proof (state)\nthis:\n  bij_betw g (\\<Union> X) (\\<Union> Y)\n\ngoal (1 subgoal):\n 1. g \\<turnstile> X = Y", "show \"g \\<turnstile> X = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<turnstile> X = Y", "using setsetmapim_cong[OF assms] surj_simplex_map"], ["proof (prove)\nusing this:\n  order.greater_eq X ?B \\<Longrightarrow>\n  g \\<turnstile> ?B = f \\<turnstile> ?B\n  f \\<turnstile> X = Y\n\ngoal (1 subgoal):\n 1. g \\<turnstile> X = Y", "by simp"], ["proof (state)\nthis:\n  g \\<turnstile> X = Y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iso_comp:\n  assumes \"ChamberComplexIsomorphism Y Z g\"\n  shows   \"ChamberComplexIsomorphism X Z (g\\<circ>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexIsomorphism X Z (g \\<circ> f)", "by      (\n            rule ChamberComplexIsomorphism.intro, rule comp,\n            rule ChamberComplexIsomorphism.axioms(1),\n            rule assms, unfold_locales, rule bij_betw_trans,\n            rule bij_betw_vertices,\n            rule ChamberComplexIsomorphism.bij_betw_vertices,\n            rule assms\n          )\n          (simp add:\n            setsetmapim_comp surj_simplex_map assms\n            ChamberComplexIsomorphism.surj_simplex_map\n          )"], ["", "lemma inj_on_chamber_system: \"inj_on ((`) f) domain.\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((`) f) domain.\\<C>", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> domain.\\<C>; y \\<in> domain.\\<C>;\n        f ` x = f ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix C D"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> domain.\\<C>; y \\<in> domain.\\<C>;\n        f ` x = f ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"\\<lbrakk> C \\<in> domain.\\<C>; D \\<in> domain.\\<C>; f`C = f`D \\<rbrakk> \\<Longrightarrow> C=D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> domain.\\<C>; D \\<in> domain.\\<C>;\n     f ` C = f ` D\\<rbrakk>\n    \\<Longrightarrow> C = D", "using domain.chamber_system_def domain.chamber_pconnect[of C D]\n          pgallery_map codomain.pgalleryD_distinct"], ["proof (prove)\nusing this:\n  domain.\\<C> \\<equiv> Collect domain.chamber\n  \\<lbrakk>C \\<noteq> D; domain.chamber C; domain.chamber D\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs. domain.pgallery (C # xs @ [D])\n  domain.pgallery ?Cs \\<Longrightarrow>\n  codomain.pgallery (f \\<Turnstile> ?Cs)\n  codomain.pgallery ?xs \\<Longrightarrow> distinct ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> domain.\\<C>; D \\<in> domain.\\<C>;\n     f ` C = f ` D\\<rbrakk>\n    \\<Longrightarrow> C = D", "by    fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<in> domain.\\<C>; D \\<in> domain.\\<C>; f ` C = f ` D\\<rbrakk>\n  \\<Longrightarrow> C = D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inv: \"ChamberComplexIsomorphism Y X (the_inv_into (\\<Union>X) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexIsomorphism Y X (the_inv_into (\\<Union> X) f)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       domain.chamber (the_inv_into (\\<Union> X) f ` C)\n 2. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       card (the_inv_into (\\<Union> X) f ` C) = card C\n 3. bij_betw (the_inv_into (\\<Union> X) f) (\\<Union> Y) (\\<Union> X)\n 4. the_inv_into (\\<Union> X) f \\<turnstile> Y = X", "show \"bij_betw (the_inv_into (\\<Union>X) f) (\\<Union>Y) (\\<Union>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (the_inv_into (\\<Union> X) f) (\\<Union> Y) (\\<Union> X)", "using bij_betw_vertices bij_betw_the_inv_into"], ["proof (prove)\nusing this:\n  bij_betw f (\\<Union> X) (\\<Union> Y)\n  bij_betw ?f ?A ?B \\<Longrightarrow> bij_betw (the_inv_into ?A ?f) ?B ?A\n\ngoal (1 subgoal):\n 1. bij_betw (the_inv_into (\\<Union> X) f) (\\<Union> Y) (\\<Union> X)", "by fast"], ["proof (state)\nthis:\n  bij_betw (the_inv_into (\\<Union> X) f) (\\<Union> Y) (\\<Union> X)\n\ngoal (3 subgoals):\n 1. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       domain.chamber (the_inv_into (\\<Union> X) f ` C)\n 2. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       card (the_inv_into (\\<Union> X) f ` C) = card C\n 3. the_inv_into (\\<Union> X) f \\<turnstile> Y = X", "show 4: \"(the_inv_into (\\<Union>X) f) \\<turnstile> Y = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv_into (\\<Union> X) f \\<turnstile> Y = X", "using bij_betw_imp_inj_on[OF bij_betw_vertices] surj_simplex_map\n          setsetmapim_the_inv_into"], ["proof (prove)\nusing this:\n  inj_on f (\\<Union> X)\n  f \\<turnstile> X = Y\n  inj_on ?f (\\<Union> ?A) \\<Longrightarrow>\n  the_inv_into (\\<Union> ?A) ?f \\<turnstile> (?f \\<turnstile> ?A) = ?A\n\ngoal (1 subgoal):\n 1. the_inv_into (\\<Union> X) f \\<turnstile> Y = X", "by    force"], ["proof (state)\nthis:\n  the_inv_into (\\<Union> X) f \\<turnstile> Y = X\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       domain.chamber (the_inv_into (\\<Union> X) f ` C)\n 2. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       card (the_inv_into (\\<Union> X) f ` C) = card C", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       domain.chamber (the_inv_into (\\<Union> X) f ` C)\n 2. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       card (the_inv_into (\\<Union> X) f ` C) = card C", "fix C"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       domain.chamber (the_inv_into (\\<Union> X) f ` C)\n 2. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       card (the_inv_into (\\<Union> X) f ` C) = card C", "assume C: \"codomain.chamber C\""], ["proof (state)\nthis:\n  codomain.chamber C\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       domain.chamber (the_inv_into (\\<Union> X) f ` C)\n 2. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       card (the_inv_into (\\<Union> X) f ` C) = card C", "hence C': \"C\\<in>f\\<turnstile>X\""], ["proof (prove)\nusing this:\n  codomain.chamber C\n\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> X", "using codomain.chamberD_simplex surj_simplex_map"], ["proof (prove)\nusing this:\n  codomain.chamber C\n  codomain.chamber ?x \\<Longrightarrow> ?x \\<in> Y\n  f \\<turnstile> X = Y\n\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> X", "by fast"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> X\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       domain.chamber (the_inv_into (\\<Union> X) f ` C)\n 2. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       card (the_inv_into (\\<Union> X) f ` C) = card C", "show \"domain.chamber (the_inv_into (\\<Union>X) f ` C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain.chamber (the_inv_into (\\<Union> X) f ` C)", "proof (rule domain.chamberI)"], ["proof (state)\ngoal (2 subgoals):\n 1. the_inv_into (\\<Union> X) f ` C \\<in> X\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> X;\n        order.greater_eq z (the_inv_into (\\<Union> X) f ` C)\\<rbrakk>\n       \\<Longrightarrow> z = the_inv_into (\\<Union> X) f ` C", "from C'"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> X", "obtain D where \"D\\<in>X\" \"the_inv_into (\\<Union>X) f ` C = D\""], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> X\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> X; the_inv_into (\\<Union> X) f ` C = D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using the_inv_into_f_im_f_im[OF inj]"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> X\n  order.greater_eq (\\<Union> X) ?x \\<Longrightarrow>\n  the_inv_into (\\<Union> X) f ` f ` ?x = ?x\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> X; the_inv_into (\\<Union> X) f ` C = D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D \\<in> X\n  the_inv_into (\\<Union> X) f ` C = D\n\ngoal (2 subgoals):\n 1. the_inv_into (\\<Union> X) f ` C \\<in> X\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> X;\n        order.greater_eq z (the_inv_into (\\<Union> X) f ` C)\\<rbrakk>\n       \\<Longrightarrow> z = the_inv_into (\\<Union> X) f ` C", "thus \"the_inv_into (\\<Union>X) f ` C \\<in> X\""], ["proof (prove)\nusing this:\n  D \\<in> X\n  the_inv_into (\\<Union> X) f ` C = D\n\ngoal (1 subgoal):\n 1. the_inv_into (\\<Union> X) f ` C \\<in> X", "by simp"], ["proof (state)\nthis:\n  the_inv_into (\\<Union> X) f ` C \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> X;\n        order.greater_eq z (the_inv_into (\\<Union> X) f ` C)\\<rbrakk>\n       \\<Longrightarrow> z = the_inv_into (\\<Union> X) f ` C", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> X;\n        order.greater_eq z (the_inv_into (\\<Union> X) f ` C)\\<rbrakk>\n       \\<Longrightarrow> z = the_inv_into (\\<Union> X) f ` C", "assume z: \"z\\<in>X\" \"the_inv_into (\\<Union>X) f ` C \\<subseteq> z\""], ["proof (state)\nthis:\n  z \\<in> X\n  order.greater_eq z (the_inv_into (\\<Union> X) f ` C)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> X;\n        order.greater_eq z (the_inv_into (\\<Union> X) f ` C)\\<rbrakk>\n       \\<Longrightarrow> z = the_inv_into (\\<Union> X) f ` C", "with C"], ["proof (chain)\npicking this:\n  codomain.chamber C\n  z \\<in> X\n  order.greater_eq z (the_inv_into (\\<Union> X) f ` C)", "have \"f`z = C\""], ["proof (prove)\nusing this:\n  codomain.chamber C\n  z \\<in> X\n  order.greater_eq z (the_inv_into (\\<Union> X) f ` C)\n\ngoal (1 subgoal):\n 1. f ` z = C", "using C' f_im_the_inv_into_f_im[OF inj, of C] surj_simplex_map\n            codomain.chamberD_maximal[of C \"f`z\"]"], ["proof (prove)\nusing this:\n  codomain.chamber C\n  z \\<in> X\n  order.greater_eq z (the_inv_into (\\<Union> X) f ` C)\n  C \\<in> f \\<turnstile> X\n  order.greater_eq (f ` \\<Union> X) C \\<Longrightarrow>\n  f ` the_inv_into (\\<Union> X) f ` C = C\n  f \\<turnstile> X = Y\n  \\<lbrakk>codomain.chamber C; f ` z \\<in> Y;\n   order.greater_eq (f ` z) C\\<rbrakk>\n  \\<Longrightarrow> f ` z = C\n\ngoal (1 subgoal):\n 1. f ` z = C", "by    blast"], ["proof (state)\nthis:\n  f ` z = C\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> X;\n        order.greater_eq z (the_inv_into (\\<Union> X) f ` C)\\<rbrakk>\n       \\<Longrightarrow> z = the_inv_into (\\<Union> X) f ` C", "with z(1)"], ["proof (chain)\npicking this:\n  z \\<in> X\n  f ` z = C", "show \"z = the_inv_into (\\<Union>X) f ` C\""], ["proof (prove)\nusing this:\n  z \\<in> X\n  f ` z = C\n\ngoal (1 subgoal):\n 1. z = the_inv_into (\\<Union> X) f ` C", "using the_inv_into_f_im_f_im[OF inj]"], ["proof (prove)\nusing this:\n  z \\<in> X\n  f ` z = C\n  order.greater_eq (\\<Union> X) ?x \\<Longrightarrow>\n  the_inv_into (\\<Union> X) f ` f ` ?x = ?x\n\ngoal (1 subgoal):\n 1. z = the_inv_into (\\<Union> X) f ` C", "by auto"], ["proof (state)\nthis:\n  z = the_inv_into (\\<Union> X) f ` C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  domain.chamber (the_inv_into (\\<Union> X) f ` C)\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       codomain.chamber C \\<Longrightarrow>\n       card (the_inv_into (\\<Union> X) f ` C) = card C", "from C"], ["proof (chain)\npicking this:\n  codomain.chamber C", "show \"card (the_inv_into (\\<Union>X) f ` C) = card C\""], ["proof (prove)\nusing this:\n  codomain.chamber C\n\ngoal (1 subgoal):\n 1. card (the_inv_into (\\<Union> X) f ` C) = card C", "using C' codomain.finite_chamber\n          subset_inj_on[OF inj_on_the_inv_into, OF inj, of C]"], ["proof (prove)\nusing this:\n  codomain.chamber C\n  C \\<in> f \\<turnstile> X\n  codomain.chamber ?x \\<Longrightarrow> finite ?x\n  order.greater_eq (f ` \\<Union> X) C \\<Longrightarrow>\n  inj_on (the_inv_into (\\<Union> X) f) C\n\ngoal (1 subgoal):\n 1. card (the_inv_into (\\<Union> X) f ` C) = card C", "by    (fast intro: inj_on_iff_eq_card[THEN iffD1])"], ["proof (state)\nthis:\n  card (the_inv_into (\\<Union> X) f ` C) = card C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chamber_distance_map:\n  assumes \"domain.chamber C\" \"domain.chamber D\"\n  shows   \"codomain.chamber_distance (f`C) (f`D) =\n            domain.chamber_distance C D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "proof (cases \"f`C=f`D\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f ` C = f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D\n 2. f ` C \\<noteq> f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "case True"], ["proof (state)\nthis:\n  f ` C = f ` D\n\ngoal (2 subgoals):\n 1. f ` C = f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D\n 2. f ` C \\<noteq> f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "moreover"], ["proof (state)\nthis:\n  f ` C = f ` D\n\ngoal (2 subgoals):\n 1. f ` C = f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D\n 2. f ` C \\<noteq> f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "with assms"], ["proof (chain)\npicking this:\n  domain.chamber C\n  domain.chamber D\n  f ` C = f ` D", "have \"C=D\""], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  f ` C = f ` D\n\ngoal (1 subgoal):\n 1. C = D", "using inj_onD[OF inj_on_chamber_system] domain.chamber_system_def"], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  f ` C = f ` D\n  \\<lbrakk>f ` ?x = f ` ?y; ?x \\<in> domain.\\<C>;\n   ?y \\<in> domain.\\<C>\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  domain.\\<C> \\<equiv> Collect domain.chamber\n\ngoal (1 subgoal):\n 1. C = D", "by    simp"], ["proof (state)\nthis:\n  C = D\n\ngoal (2 subgoals):\n 1. f ` C = f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D\n 2. f ` C \\<noteq> f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "ultimately"], ["proof (chain)\npicking this:\n  f ` C = f ` D\n  C = D", "show ?thesis"], ["proof (prove)\nusing this:\n  f ` C = f ` D\n  C = D\n\ngoal (1 subgoal):\n 1. codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "using domain.chamber_distance_def codomain.chamber_distance_def"], ["proof (prove)\nusing this:\n  f ` C = f ` D\n  C = D\n  domain.chamber_distance ?C ?D =\n  (if ?C = ?D then 0\n   else Suc (length (ARG_MIN length Cs. domain.gallery (?C # Cs @ [?D]))))\n  codomain.chamber_distance ?C ?D =\n  (if ?C = ?D then 0\n   else Suc (length (ARG_MIN length Cs. codomain.gallery (?C # Cs @ [?D]))))\n\ngoal (1 subgoal):\n 1. codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "by simp"], ["proof (state)\nthis:\n  codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "case False"], ["proof (state)\nthis:\n  f ` C \\<noteq> f ` D\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "define Cs Ds where \"Cs = (ARG_MIN length Cs. domain.gallery (C#Cs@[D]))\"\n    and \"Ds = (ARG_MIN length Ds. codomain.gallery (f`C # Ds @ [f`D]))\""], ["proof (state)\nthis:\n  Cs = (ARG_MIN length Cs. domain.gallery (C # Cs @ [D]))\n  Ds = (ARG_MIN length Ds. codomain.gallery (f ` C # Ds @ [f ` D]))\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "from assms False Cs_def"], ["proof (chain)\npicking this:\n  domain.chamber C\n  domain.chamber D\n  f ` C \\<noteq> f ` D\n  Cs = (ARG_MIN length Cs. domain.gallery (C # Cs @ [D]))", "have \"codomain.gallery (f`C # f\\<Turnstile>Cs @ [f`D])\""], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  f ` C \\<noteq> f ` D\n  Cs = (ARG_MIN length Cs. domain.gallery (C # Cs @ [D]))\n\ngoal (1 subgoal):\n 1. codomain.gallery (f ` C # f \\<Turnstile> Cs @ [f ` D])", "using gallery_map domain.maxsimp_connect[of C D]\n          arg_min_natI[of \"\\<lambda>Cs. domain.gallery (C#Cs@[D])\"]"], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  f ` C \\<noteq> f ` D\n  Cs = (ARG_MIN length Cs. domain.gallery (C # Cs @ [D]))\n  domain.gallery ?Cs \\<Longrightarrow> codomain.gallery (f \\<Turnstile> ?Cs)\n  \\<lbrakk>C \\<noteq> D; domain.chamber C; domain.chamber D\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs. domain.gallery (C # xs @ [D])\n  domain.gallery (C # ?k @ [D]) \\<Longrightarrow>\n  domain.gallery (C # (ARG_MIN ?m Cs. domain.gallery (C # Cs @ [D])) @ [D])\n\ngoal (1 subgoal):\n 1. codomain.gallery (f ` C # f \\<Turnstile> Cs @ [f ` D])", "by    fastforce"], ["proof (state)\nthis:\n  codomain.gallery (f ` C # f \\<Turnstile> Cs @ [f ` D])\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "moreover"], ["proof (state)\nthis:\n  codomain.gallery (f ` C # f \\<Turnstile> Cs @ [f ` D])\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "from assms Cs_def"], ["proof (chain)\npicking this:\n  domain.chamber C\n  domain.chamber D\n  Cs = (ARG_MIN length Cs. domain.gallery (C # Cs @ [D]))", "have  \"\\<And>Es. codomain.gallery (f`C # Es @ [f`D]) \\<Longrightarrow>\n            length (f\\<Turnstile>Cs) \\<le> length Es\""], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  Cs = (ARG_MIN length Cs. domain.gallery (C # Cs @ [D]))\n\ngoal (1 subgoal):\n 1. \\<And>Es.\n       codomain.gallery (f ` C # Es @ [f ` D]) \\<Longrightarrow>\n       order.greater_eq (length Es) (length (f \\<Turnstile> Cs))", "using ChamberComplexIsomorphism.gallery_map[OF inv]\n          the_inv_into_f_im_f_im[OF inj, of C] the_inv_into_f_im_f_im[OF inj, of D]\n          domain.chamberD_simplex[of C] domain.chamberD_simplex[of D]\n          domain.maxsimp_connect[of C D]\n          arg_min_nat_le[of \"\\<lambda>Cs. domain.gallery (C#Cs@[D])\" _ length]"], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  Cs = (ARG_MIN length Cs. domain.gallery (C # Cs @ [D]))\n  codomain.gallery ?Cs \\<Longrightarrow>\n  domain.gallery (the_inv_into (\\<Union> X) f \\<Turnstile> ?Cs)\n  order.greater_eq (\\<Union> X) C \\<Longrightarrow>\n  the_inv_into (\\<Union> X) f ` f ` C = C\n  order.greater_eq (\\<Union> X) D \\<Longrightarrow>\n  the_inv_into (\\<Union> X) f ` f ` D = D\n  domain.chamber C \\<Longrightarrow> C \\<in> X\n  domain.chamber D \\<Longrightarrow> D \\<in> X\n  \\<lbrakk>C \\<noteq> D; domain.chamber C; domain.chamber D\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs. domain.gallery (C # xs @ [D])\n  domain.gallery (C # ?x @ [D]) \\<Longrightarrow>\n  order.greater_eq (length ?x)\n   (length (ARG_MIN length Cs. domain.gallery (C # Cs @ [D])))\n\ngoal (1 subgoal):\n 1. \\<And>Es.\n       codomain.gallery (f ` C # Es @ [f ` D]) \\<Longrightarrow>\n       order.greater_eq (length Es) (length (f \\<Turnstile> Cs))", "by    force"], ["proof (state)\nthis:\n  codomain.gallery (f ` C # ?Es1 @ [f ` D]) \\<Longrightarrow>\n  order.greater_eq (length ?Es1) (length (f \\<Turnstile> Cs))\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "ultimately"], ["proof (chain)\npicking this:\n  codomain.gallery (f ` C # f \\<Turnstile> Cs @ [f ` D])\n  codomain.gallery (f ` C # ?Es1 @ [f ` D]) \\<Longrightarrow>\n  order.greater_eq (length ?Es1) (length (f \\<Turnstile> Cs))", "have \"length Ds = length (f\\<Turnstile>Cs)\""], ["proof (prove)\nusing this:\n  codomain.gallery (f ` C # f \\<Turnstile> Cs @ [f ` D])\n  codomain.gallery (f ` C # ?Es1 @ [f ` D]) \\<Longrightarrow>\n  order.greater_eq (length ?Es1) (length (f \\<Turnstile> Cs))\n\ngoal (1 subgoal):\n 1. length Ds = length (f \\<Turnstile> Cs)", "unfolding Ds_def"], ["proof (prove)\nusing this:\n  codomain.gallery (f ` C # f \\<Turnstile> Cs @ [f ` D])\n  codomain.gallery (f ` C # ?Es1 @ [f ` D]) \\<Longrightarrow>\n  order.greater_eq (length ?Es1) (length (f \\<Turnstile> Cs))\n\ngoal (1 subgoal):\n 1. length (ARG_MIN length Ds. codomain.gallery (f ` C # Ds @ [f ` D])) =\n    length (f \\<Turnstile> Cs)", "by (fast intro: arg_min_equality)"], ["proof (state)\nthis:\n  length Ds = length (f \\<Turnstile> Cs)\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow>\n    codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "with False Cs_def Ds_def"], ["proof (chain)\npicking this:\n  f ` C \\<noteq> f ` D\n  Cs = (ARG_MIN length Cs. domain.gallery (C # Cs @ [D]))\n  Ds = (ARG_MIN length Ds. codomain.gallery (f ` C # Ds @ [f ` D]))\n  length Ds = length (f \\<Turnstile> Cs)", "show ?thesis"], ["proof (prove)\nusing this:\n  f ` C \\<noteq> f ` D\n  Cs = (ARG_MIN length Cs. domain.gallery (C # Cs @ [D]))\n  Ds = (ARG_MIN length Ds. codomain.gallery (f ` C # Ds @ [f ` D]))\n  length Ds = length (f \\<Turnstile> Cs)\n\ngoal (1 subgoal):\n 1. codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "using domain.chamber_distance_def codomain.chamber_distance_def"], ["proof (prove)\nusing this:\n  f ` C \\<noteq> f ` D\n  Cs = (ARG_MIN length Cs. domain.gallery (C # Cs @ [D]))\n  Ds = (ARG_MIN length Ds. codomain.gallery (f ` C # Ds @ [f ` D]))\n  length Ds = length (f \\<Turnstile> Cs)\n  domain.chamber_distance ?C ?D =\n  (if ?C = ?D then 0\n   else Suc (length (ARG_MIN length Cs. domain.gallery (?C # Cs @ [?D]))))\n  codomain.chamber_distance ?C ?D =\n  (if ?C = ?D then 0\n   else Suc (length (ARG_MIN length Cs. codomain.gallery (?C # Cs @ [?D]))))\n\ngoal (1 subgoal):\n 1. codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D", "by auto"], ["proof (state)\nthis:\n  codomain.chamber_distance (f ` C) (f ` D) = domain.chamber_distance C D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma face_distance_map:\n  assumes \"domain.chamber C\" \"F\\<in>X\"\n  shows   \"codomain.face_distance (f`F) (f`C) = domain.face_distance F C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomain.face_distance (f ` F) (f ` C) = domain.face_distance F C", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. codomain.face_distance (f ` F) (f ` C) = domain.face_distance F C", "define D D' invf where \"D = domain.closest_supchamber F C\"\n    and \"D' = codomain.closest_supchamber (f`F) (f`C)\"\n    and \"invf = the_inv_into (\\<Union>X) f\""], ["proof (state)\nthis:\n  D = domain.closest_supchamber F C\n  D' = codomain.closest_supchamber (f ` F) (f ` C)\n  invf = the_inv_into (\\<Union> X) f\n\ngoal (1 subgoal):\n 1. codomain.face_distance (f ` F) (f ` C) = domain.face_distance F C", "from assms D_def D'_def invf_def"], ["proof (chain)\npicking this:\n  domain.chamber C\n  F \\<in> X\n  D = domain.closest_supchamber F C\n  D' = codomain.closest_supchamber (f ` F) (f ` C)\n  invf = the_inv_into (\\<Union> X) f", "have chambers:\n    \"codomain.chamber (f`C)\" \"domain.chamber D\" \"codomain.chamber D'\"\n    \"codomain.chamber (f`D)\" \"domain.chamber (invf`D')\""], ["proof (prove)\nusing this:\n  domain.chamber C\n  F \\<in> X\n  D = domain.closest_supchamber F C\n  D' = codomain.closest_supchamber (f ` F) (f ` C)\n  invf = the_inv_into (\\<Union> X) f\n\ngoal (1 subgoal):\n 1. (codomain.chamber (f ` C) &&& domain.chamber D) &&&\n    codomain.chamber D' &&&\n    codomain.chamber (f ` D) &&& domain.chamber (invf ` D')", "using domain.closest_supchamberD(1) simplex_map\n          codomain.closest_supchamberD(1) chamber_map\n          ChamberComplexIsomorphism.chamber_map[OF inv]"], ["proof (prove)\nusing this:\n  domain.chamber C\n  F \\<in> X\n  D = domain.closest_supchamber F C\n  D' = codomain.closest_supchamber (f ` F) (f ` C)\n  invf = the_inv_into (\\<Union> X) f\n  \\<lbrakk>?F \\<in> X; domain.chamber ?D\\<rbrakk>\n  \\<Longrightarrow> domain.chamber (domain.closest_supchamber ?F ?D)\n  ?x \\<in> X \\<Longrightarrow> f ` ?x \\<in> Y\n  \\<lbrakk>?F \\<in> Y; codomain.chamber ?D\\<rbrakk>\n  \\<Longrightarrow> codomain.chamber (codomain.closest_supchamber ?F ?D)\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n  codomain.chamber ?C \\<Longrightarrow>\n  domain.chamber (the_inv_into (\\<Union> X) f ` ?C)\n\ngoal (1 subgoal):\n 1. (codomain.chamber (f ` C) &&& domain.chamber D) &&&\n    codomain.chamber D' &&&\n    codomain.chamber (f ` D) &&& domain.chamber (invf ` D')", "by    auto"], ["proof (state)\nthis:\n  codomain.chamber (f ` C)\n  domain.chamber D\n  codomain.chamber D'\n  codomain.chamber (f ` D)\n  domain.chamber (invf ` D')\n\ngoal (1 subgoal):\n 1. codomain.face_distance (f ` F) (f ` C) = domain.face_distance F C", "have \"codomain.chamber_distance D' (f`C) \\<le> domain.chamber_distance D C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (domain.chamber_distance D C)\n     (codomain.chamber_distance D' (f ` C))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. order.greater_eq (domain.chamber_distance D C)\n     (codomain.chamber_distance D' (f ` C))", "from assms D_def D'_def"], ["proof (chain)\npicking this:\n  domain.chamber C\n  F \\<in> X\n  D = domain.closest_supchamber F C\n  D' = codomain.closest_supchamber (f ` F) (f ` C)", "have  \"codomain.chamber_distance D' (f`C) \\<le>\n              codomain.chamber_distance (f`D) (f`C)\""], ["proof (prove)\nusing this:\n  domain.chamber C\n  F \\<in> X\n  D = domain.closest_supchamber F C\n  D' = codomain.closest_supchamber (f ` F) (f ` C)\n\ngoal (1 subgoal):\n 1. order.greater_eq (codomain.chamber_distance (f ` D) (f ` C))\n     (codomain.chamber_distance D' (f ` C))", "using chambers(4) domain.closest_supchamberD(2)\n            codomain.closest_supchamber_def"], ["proof (prove)\nusing this:\n  domain.chamber C\n  F \\<in> X\n  D = domain.closest_supchamber F C\n  D' = codomain.closest_supchamber (f ` F) (f ` C)\n  codomain.chamber (f ` D)\n  \\<lbrakk>?F \\<in> X; domain.chamber ?D\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (domain.closest_supchamber ?F ?D) ?F\n  codomain.closest_supchamber ?F ?D =\n  (ARG_MIN (\\<lambda>C. codomain.chamber_distance C ?D) C.\n      codomain.chamber C \\<and> order.greater_eq C ?F)\n\ngoal (1 subgoal):\n 1. order.greater_eq (codomain.chamber_distance (f ` D) (f ` C))\n     (codomain.chamber_distance D' (f ` C))", "by    (fastforce intro: arg_min_nat_le)"], ["proof (state)\nthis:\n  order.greater_eq (codomain.chamber_distance (f ` D) (f ` C))\n   (codomain.chamber_distance D' (f ` C))\n\ngoal (1 subgoal):\n 1. order.greater_eq (domain.chamber_distance D C)\n     (codomain.chamber_distance D' (f ` C))", "with assms D_def D'_def"], ["proof (chain)\npicking this:\n  domain.chamber C\n  F \\<in> X\n  D = domain.closest_supchamber F C\n  D' = codomain.closest_supchamber (f ` F) (f ` C)\n  order.greater_eq (codomain.chamber_distance (f ` D) (f ` C))\n   (codomain.chamber_distance D' (f ` C))", "show ?thesis"], ["proof (prove)\nusing this:\n  domain.chamber C\n  F \\<in> X\n  D = domain.closest_supchamber F C\n  D' = codomain.closest_supchamber (f ` F) (f ` C)\n  order.greater_eq (codomain.chamber_distance (f ` D) (f ` C))\n   (codomain.chamber_distance D' (f ` C))\n\ngoal (1 subgoal):\n 1. order.greater_eq (domain.chamber_distance D C)\n     (codomain.chamber_distance D' (f ` C))", "using chambers(2) chamber_distance_map"], ["proof (prove)\nusing this:\n  domain.chamber C\n  F \\<in> X\n  D = domain.closest_supchamber F C\n  D' = codomain.closest_supchamber (f ` F) (f ` C)\n  order.greater_eq (codomain.chamber_distance (f ` D) (f ` C))\n   (codomain.chamber_distance D' (f ` C))\n  domain.chamber D\n  \\<lbrakk>domain.chamber ?C; domain.chamber ?D\\<rbrakk>\n  \\<Longrightarrow> codomain.chamber_distance (f ` ?C) (f ` ?D) =\n                    domain.chamber_distance ?C ?D\n\ngoal (1 subgoal):\n 1. order.greater_eq (domain.chamber_distance D C)\n     (codomain.chamber_distance D' (f ` C))", "by simp"], ["proof (state)\nthis:\n  order.greater_eq (domain.chamber_distance D C)\n   (codomain.chamber_distance D' (f ` C))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq (domain.chamber_distance D C)\n   (codomain.chamber_distance D' (f ` C))\n\ngoal (1 subgoal):\n 1. codomain.face_distance (f ` F) (f ` C) = domain.face_distance F C", "moreover"], ["proof (state)\nthis:\n  order.greater_eq (domain.chamber_distance D C)\n   (codomain.chamber_distance D' (f ` C))\n\ngoal (1 subgoal):\n 1. codomain.face_distance (f ` F) (f ` C) = domain.face_distance F C", "have \"domain.chamber_distance D C \\<le> codomain.chamber_distance D' (f`C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (codomain.chamber_distance D' (f ` C))\n     (domain.chamber_distance D C)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. order.greater_eq (codomain.chamber_distance D' (f ` C))\n     (domain.chamber_distance D C)", "from assms D'_def"], ["proof (chain)\npicking this:\n  domain.chamber C\n  F \\<in> X\n  D' = codomain.closest_supchamber (f ` F) (f ` C)", "have \"invf`f`F \\<subseteq> invf`D'\""], ["proof (prove)\nusing this:\n  domain.chamber C\n  F \\<in> X\n  D' = codomain.closest_supchamber (f ` F) (f ` C)\n\ngoal (1 subgoal):\n 1. order.greater_eq (invf ` D') (invf ` f ` F)", "using chambers(1) simplex_map codomain.closest_supchamberD(2)"], ["proof (prove)\nusing this:\n  domain.chamber C\n  F \\<in> X\n  D' = codomain.closest_supchamber (f ` F) (f ` C)\n  codomain.chamber (f ` C)\n  ?x \\<in> X \\<Longrightarrow> f ` ?x \\<in> Y\n  \\<lbrakk>?F \\<in> Y; codomain.chamber ?D\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (codomain.closest_supchamber ?F ?D) ?F\n\ngoal (1 subgoal):\n 1. order.greater_eq (invf ` D') (invf ` f ` F)", "by fast"], ["proof (state)\nthis:\n  order.greater_eq (invf ` D') (invf ` f ` F)\n\ngoal (1 subgoal):\n 1. order.greater_eq (codomain.chamber_distance D' (f ` C))\n     (domain.chamber_distance D C)", "with assms(2) invf_def"], ["proof (chain)\npicking this:\n  F \\<in> X\n  invf = the_inv_into (\\<Union> X) f\n  order.greater_eq (invf ` D') (invf ` f ` F)", "have \"F \\<subseteq> invf`D'\""], ["proof (prove)\nusing this:\n  F \\<in> X\n  invf = the_inv_into (\\<Union> X) f\n  order.greater_eq (invf ` D') (invf ` f ` F)\n\ngoal (1 subgoal):\n 1. order.greater_eq (invf ` D') F", "using the_inv_into_f_im_f_im[OF inj, of F]"], ["proof (prove)\nusing this:\n  F \\<in> X\n  invf = the_inv_into (\\<Union> X) f\n  order.greater_eq (invf ` D') (invf ` f ` F)\n  order.greater_eq (\\<Union> X) F \\<Longrightarrow>\n  the_inv_into (\\<Union> X) f ` f ` F = F\n\ngoal (1 subgoal):\n 1. order.greater_eq (invf ` D') F", "by fastforce"], ["proof (state)\nthis:\n  order.greater_eq (invf ` D') F\n\ngoal (1 subgoal):\n 1. order.greater_eq (codomain.chamber_distance D' (f ` C))\n     (domain.chamber_distance D C)", "with D_def"], ["proof (chain)\npicking this:\n  D = domain.closest_supchamber F C\n  order.greater_eq (invf ` D') F", "have  \"domain.chamber_distance D C \\<le>\n              domain.chamber_distance (invf ` D') C\""], ["proof (prove)\nusing this:\n  D = domain.closest_supchamber F C\n  order.greater_eq (invf ` D') F\n\ngoal (1 subgoal):\n 1. order.greater_eq (domain.chamber_distance (invf ` D') C)\n     (domain.chamber_distance D C)", "using chambers(5) domain.closest_supchamber_def"], ["proof (prove)\nusing this:\n  D = domain.closest_supchamber F C\n  order.greater_eq (invf ` D') F\n  domain.chamber (invf ` D')\n  domain.closest_supchamber ?F ?D =\n  (ARG_MIN (\\<lambda>C. domain.chamber_distance C ?D) C.\n      domain.chamber C \\<and> order.greater_eq C ?F)\n\ngoal (1 subgoal):\n 1. order.greater_eq (domain.chamber_distance (invf ` D') C)\n     (domain.chamber_distance D C)", "by    (auto intro: arg_min_nat_le)"], ["proof (state)\nthis:\n  order.greater_eq (domain.chamber_distance (invf ` D') C)\n   (domain.chamber_distance D C)\n\ngoal (1 subgoal):\n 1. order.greater_eq (codomain.chamber_distance D' (f ` C))\n     (domain.chamber_distance D C)", "with assms(1) invf_def"], ["proof (chain)\npicking this:\n  domain.chamber C\n  invf = the_inv_into (\\<Union> X) f\n  order.greater_eq (domain.chamber_distance (invf ` D') C)\n   (domain.chamber_distance D C)", "show ?thesis"], ["proof (prove)\nusing this:\n  domain.chamber C\n  invf = the_inv_into (\\<Union> X) f\n  order.greater_eq (domain.chamber_distance (invf ` D') C)\n   (domain.chamber_distance D C)\n\ngoal (1 subgoal):\n 1. order.greater_eq (codomain.chamber_distance D' (f ` C))\n     (domain.chamber_distance D C)", "using chambers(3,5) surj_simplex_map codomain.chamberD_simplex\n            f_im_the_inv_into_f_im[OF inj, of D']\n            chamber_distance_map[of \"invf`D'\" C]"], ["proof (prove)\nusing this:\n  domain.chamber C\n  invf = the_inv_into (\\<Union> X) f\n  order.greater_eq (domain.chamber_distance (invf ` D') C)\n   (domain.chamber_distance D C)\n  codomain.chamber D'\n  domain.chamber (invf ` D')\n  f \\<turnstile> X = Y\n  codomain.chamber ?x \\<Longrightarrow> ?x \\<in> Y\n  order.greater_eq (f ` \\<Union> X) D' \\<Longrightarrow>\n  f ` the_inv_into (\\<Union> X) f ` D' = D'\n  \\<lbrakk>domain.chamber (invf ` D'); domain.chamber C\\<rbrakk>\n  \\<Longrightarrow> codomain.chamber_distance (f ` invf ` D') (f ` C) =\n                    domain.chamber_distance (invf ` D') C\n\ngoal (1 subgoal):\n 1. order.greater_eq (codomain.chamber_distance D' (f ` C))\n     (domain.chamber_distance D C)", "by    fastforce"], ["proof (state)\nthis:\n  order.greater_eq (codomain.chamber_distance D' (f ` C))\n   (domain.chamber_distance D C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq (codomain.chamber_distance D' (f ` C))\n   (domain.chamber_distance D C)\n\ngoal (1 subgoal):\n 1. codomain.face_distance (f ` F) (f ` C) = domain.face_distance F C", "ultimately"], ["proof (chain)\npicking this:\n  order.greater_eq (domain.chamber_distance D C)\n   (codomain.chamber_distance D' (f ` C))\n  order.greater_eq (codomain.chamber_distance D' (f ` C))\n   (domain.chamber_distance D C)", "show ?thesis"], ["proof (prove)\nusing this:\n  order.greater_eq (domain.chamber_distance D C)\n   (codomain.chamber_distance D' (f ` C))\n  order.greater_eq (codomain.chamber_distance D' (f ` C))\n   (domain.chamber_distance D C)\n\ngoal (1 subgoal):\n 1. codomain.face_distance (f ` F) (f ` C) = domain.face_distance F C", "using D_def D'_def domain.face_distance_def codomain.face_distance_def"], ["proof (prove)\nusing this:\n  order.greater_eq (domain.chamber_distance D C)\n   (codomain.chamber_distance D' (f ` C))\n  order.greater_eq (codomain.chamber_distance D' (f ` C))\n   (domain.chamber_distance D C)\n  D = domain.closest_supchamber F C\n  D' = codomain.closest_supchamber (f ` F) (f ` C)\n  domain.face_distance ?F ?D \\<equiv>\n  domain.chamber_distance (domain.closest_supchamber ?F ?D) ?D\n  codomain.face_distance ?F ?D \\<equiv>\n  codomain.chamber_distance (codomain.closest_supchamber ?F ?D) ?D\n\ngoal (1 subgoal):\n 1. codomain.face_distance (f ` F) (f ` C) = domain.face_distance F C", "by    simp"], ["proof (state)\nthis:\n  codomain.face_distance (f ` F) (f ` C) = domain.face_distance F C\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ChamberComplexIsomorphism *)"], ["", "subsubsection \\<open>Endomorphisms\\<close>"], ["", "locale ChamberComplexEndomorphism = ChamberComplexMorphism X X f\n  for X :: \"'a set set\"\n  and f :: \"'a\\<Rightarrow>'a\"\n+ assumes trivial_outside : \"v\\<notin>\\<Union>X \\<Longrightarrow> f v = v\"\n  \\<comment> \\<open>to facilitate uniqueness arguments\\<close>"], ["", "lemma (in ChamberComplex) trivial_endomorphism:\n  \"ChamberComplexEndomorphism X id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X id", "by  (\n        rule ChamberComplexEndomorphism.intro, rule trivial_morphism,\n        unfold_locales\n      )\n      simp"], ["", "context ChamberComplexEndomorphism\nbegin"], ["", "abbreviation \"ChamberSubcomplex \\<equiv> domain.ChamberSubcomplex\""], ["", "abbreviation \"Subcomplex \\<equiv> domain.Subcomplex\""], ["", "abbreviation \"chamber \\<equiv> domain.chamber\""], ["", "abbreviation \"gallery \\<equiv> domain.gallery\""], ["", "abbreviation \"\\<C> \\<equiv> domain.chamber_system\""], ["", "abbreviation \"label_wrt \\<equiv> domain.label_wrt\""], ["", "lemmas dim_map                 = dim_map"], ["", "lemmas simplex_map             = simplex_map"], ["", "lemmas vertex_map              = vertex_map"], ["", "lemmas chamber_map             = chamber_map"], ["", "lemmas adj_map                 = adj_map"], ["", "lemmas facet_map               = facet_map"], ["", "lemmas bij_betw_chambers       = bij_betw_chambers"], ["", "lemmas chamber_system_into     = chamber_system_into"], ["", "lemmas chamber_system_image    = chamber_system_image"], ["", "lemmas image_chamber_system    = image_chamber_system"], ["", "lemmas chambercomplex_image    = chambercomplex_image"], ["", "lemmas chambersubcomplex_image = chambersubcomplex_image"], ["", "lemmas face_distance_eq_chamber_distance_map =\n  face_distance_eq_chamber_distance_map"], ["", "lemmas face_distance_eq_chamber_distance_min_gallery_betw_map =\n  face_distance_eq_chamber_distance_min_gallery_betw_map"], ["", "lemmas facedist_chdist_mingal_btwmap =\n  face_distance_eq_chamber_distance_min_gallery_betw_map"], ["", "lemmas trivial_endomorphism     = domain.trivial_endomorphism"], ["", "lemmas finite_simplices         = domain.finite_simplices"], ["", "lemmas faces                    = domain.faces"], ["", "lemmas maxsimp_connect          = domain.maxsimp_connect"], ["", "lemmas simplex_in_max           = domain.simplex_in_max"], ["", "lemmas chamberD_simplex         = domain.chamberD_simplex"], ["", "lemmas chamber_system_def       = domain.chamber_system_def"], ["", "lemmas chamber_system_simplices = domain.chamber_system_simplices"], ["", "lemmas galleryD_chamber         = domain.galleryD_chamber"], ["", "lemmas galleryD_adj             = domain.galleryD_adj"], ["", "lemmas gallery_append_reduce1   = domain.gallery_append_reduce1"], ["", "lemmas gallery_Cons_reduce      = domain.gallery_Cons_reduce"], ["", "lemmas gallery_chamber_system   = domain.gallery_chamber_system"], ["", "lemmas label_wrtD               = domain.label_wrtD"], ["", "lemmas label_wrt_adjacent       = domain.label_wrt_adjacent"], ["", "lemma endo_comp:\n  assumes \"ChamberComplexEndomorphism X g\"\n  shows   \"ChamberComplexEndomorphism X (g\\<circ>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (g \\<circ> f)", "proof (rule ChamberComplexEndomorphism.intro)"], ["proof (state)\ngoal (2 subgoals):\n 1. ChamberComplexMorphism X X (g \\<circ> f)\n 2. ChamberComplexEndomorphism_axioms X (g \\<circ> f)", "from assms"], ["proof (chain)\npicking this:\n  ChamberComplexEndomorphism X g", "show \"ChamberComplexMorphism X X (g\\<circ>f)\""], ["proof (prove)\nusing this:\n  ChamberComplexEndomorphism X g\n\ngoal (1 subgoal):\n 1. ChamberComplexMorphism X X (g \\<circ> f)", "using comp ChamberComplexEndomorphism.axioms"], ["proof (prove)\nusing this:\n  ChamberComplexEndomorphism X g\n  ChamberComplexMorphism X ?Z ?g \\<Longrightarrow>\n  ChamberComplexMorphism X ?Z (?g \\<circ> f)\n  ChamberComplexEndomorphism ?X ?f \\<Longrightarrow>\n  ChamberComplexMorphism ?X ?X ?f\n  ChamberComplexEndomorphism ?X ?f \\<Longrightarrow>\n  ChamberComplexEndomorphism_axioms ?X ?f\n\ngoal (1 subgoal):\n 1. ChamberComplexMorphism X X (g \\<circ> f)", "by fast"], ["proof (state)\nthis:\n  ChamberComplexMorphism X X (g \\<circ> f)\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism_axioms X (g \\<circ> f)", "from assms"], ["proof (chain)\npicking this:\n  ChamberComplexEndomorphism X g", "show \"ChamberComplexEndomorphism_axioms X (g\\<circ>f)\""], ["proof (prove)\nusing this:\n  ChamberComplexEndomorphism X g\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism_axioms X (g \\<circ> f)", "using trivial_outside ChamberComplexEndomorphism.trivial_outside"], ["proof (prove)\nusing this:\n  ChamberComplexEndomorphism X g\n  ?v \\<notin> \\<Union> X \\<Longrightarrow> f ?v = ?v\n  \\<lbrakk>ChamberComplexEndomorphism ?X ?f;\n   ?v \\<notin> \\<Union> ?X\\<rbrakk>\n  \\<Longrightarrow> ?f ?v = ?v\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism_axioms X (g \\<circ> f)", "by    unfold_locales auto"], ["proof (state)\nthis:\n  ChamberComplexEndomorphism_axioms X (g \\<circ> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restrict_endo:\n  assumes \"ChamberSubcomplex Y\" \"f\\<turnstile>Y \\<subseteq> Y\"\n  shows   \"ChamberComplexEndomorphism Y (restrict1 f (\\<Union>Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism Y (restrict1 f (\\<Union> Y))", "proof (rule ChamberComplexEndomorphism.intro)"], ["proof (state)\ngoal (2 subgoals):\n 1. ChamberComplexMorphism Y Y (restrict1 f (\\<Union> Y))\n 2. ChamberComplexEndomorphism_axioms Y (restrict1 f (\\<Union> Y))", "from assms"], ["proof (chain)\npicking this:\n  ChamberSubcomplex Y\n  order.greater_eq Y (f \\<turnstile> Y)", "show \"ChamberComplexMorphism Y Y (restrict1 f (\\<Union>Y))\""], ["proof (prove)\nusing this:\n  ChamberSubcomplex Y\n  order.greater_eq Y (f \\<turnstile> Y)\n\ngoal (1 subgoal):\n 1. ChamberComplexMorphism Y Y (restrict1 f (\\<Union> Y))", "using ChamberComplexMorphism.cong[of Y Y]\n          ChamberComplexMorphism.restrict_codomain\n          restrict_domain fun_eq_on_restrict1"], ["proof (prove)\nusing this:\n  ChamberSubcomplex Y\n  order.greater_eq Y (f \\<turnstile> Y)\n  \\<lbrakk>ChamberComplexMorphism Y Y ?f;\n   fun_eq_on ?g ?f (\\<Union> Y)\\<rbrakk>\n  \\<Longrightarrow> ChamberComplexMorphism Y Y ?g\n  \\<lbrakk>ChamberComplexMorphism ?X ?Y ?f;\n   ChamberComplex.ChamberSubcomplex ?Y ?Z;\n   order.greater_eq ?Z (?f \\<turnstile> ?X)\\<rbrakk>\n  \\<Longrightarrow> ChamberComplexMorphism ?X ?Z ?f\n  ChamberSubcomplex ?W \\<Longrightarrow> ChamberComplexMorphism ?W X f\n  fun_eq_on (restrict1 ?f ?A) ?f ?A\n\ngoal (1 subgoal):\n 1. ChamberComplexMorphism Y Y (restrict1 f (\\<Union> Y))", "by    fast"], ["proof (state)\nthis:\n  ChamberComplexMorphism Y Y (restrict1 f (\\<Union> Y))\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism_axioms Y (restrict1 f (\\<Union> Y))", "show \"ChamberComplexEndomorphism_axioms Y (restrict1 f (\\<Union>Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism_axioms Y (restrict1 f (\\<Union> Y))", "by unfold_locales simp"], ["proof (state)\nthis:\n  ChamberComplexEndomorphism_axioms Y (restrict1 f (\\<Union> Y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma funpower_endomorphism:\n  \"ChamberComplexEndomorphism X (f^^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (f ^^ n)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. ChamberComplexEndomorphism X (f ^^ 0)\n 2. \\<And>n.\n       ChamberComplexEndomorphism X (f ^^ n) \\<Longrightarrow>\n       ChamberComplexEndomorphism X (f ^^ Suc n)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. ChamberComplexEndomorphism X (f ^^ 0)\n 2. \\<And>n.\n       ChamberComplexEndomorphism X (f ^^ n) \\<Longrightarrow>\n       ChamberComplexEndomorphism X (f ^^ Suc n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (f ^^ 0)", "using trivial_endomorphism subst[of id]"], ["proof (prove)\nusing this:\n  ChamberComplexEndomorphism X id\n  \\<lbrakk>id = ?t; ?P id\\<rbrakk> \\<Longrightarrow> ?P ?t\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (f ^^ 0)", "by fastforce"], ["proof (state)\nthis:\n  ChamberComplexEndomorphism X (f ^^ 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       ChamberComplexEndomorphism X (f ^^ n) \\<Longrightarrow>\n       ChamberComplexEndomorphism X (f ^^ Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       ChamberComplexEndomorphism X (f ^^ n) \\<Longrightarrow>\n       ChamberComplexEndomorphism X (f ^^ Suc n)", "case (Suc m)"], ["proof (state)\nthis:\n  ChamberComplexEndomorphism X (f ^^ m)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       ChamberComplexEndomorphism X (f ^^ n) \\<Longrightarrow>\n       ChamberComplexEndomorphism X (f ^^ Suc n)", "hence \"ChamberComplexEndomorphism X (f^^m \\<circ> f)\""], ["proof (prove)\nusing this:\n  ChamberComplexEndomorphism X (f ^^ m)\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (f ^^ m \\<circ> f)", "using endo_comp"], ["proof (prove)\nusing this:\n  ChamberComplexEndomorphism X (f ^^ m)\n  ChamberComplexEndomorphism X ?g \\<Longrightarrow>\n  ChamberComplexEndomorphism X (?g \\<circ> f)\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (f ^^ m \\<circ> f)", "by auto"], ["proof (state)\nthis:\n  ChamberComplexEndomorphism X (f ^^ m \\<circ> f)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       ChamberComplexEndomorphism X (f ^^ n) \\<Longrightarrow>\n       ChamberComplexEndomorphism X (f ^^ Suc n)", "moreover"], ["proof (state)\nthis:\n  ChamberComplexEndomorphism X (f ^^ m \\<circ> f)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       ChamberComplexEndomorphism X (f ^^ n) \\<Longrightarrow>\n       ChamberComplexEndomorphism X (f ^^ Suc n)", "have \"f^^m \\<circ> f = f^^(Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ^^ m \\<circ> f = f ^^ Suc m", "by (simp add: funpow_Suc_right[THEN sym])"], ["proof (state)\nthis:\n  f ^^ m \\<circ> f = f ^^ Suc m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       ChamberComplexEndomorphism X (f ^^ n) \\<Longrightarrow>\n       ChamberComplexEndomorphism X (f ^^ Suc n)", "ultimately"], ["proof (chain)\npicking this:\n  ChamberComplexEndomorphism X (f ^^ m \\<circ> f)\n  f ^^ m \\<circ> f = f ^^ Suc m", "show ?case"], ["proof (prove)\nusing this:\n  ChamberComplexEndomorphism X (f ^^ m \\<circ> f)\n  f ^^ m \\<circ> f = f ^^ Suc m\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (f ^^ Suc m)", "using subst[of _ _ \"\\<lambda>f. ChamberComplexEndomorphism X f\"]"], ["proof (prove)\nusing this:\n  ChamberComplexEndomorphism X (f ^^ m \\<circ> f)\n  f ^^ m \\<circ> f = f ^^ Suc m\n  \\<lbrakk>?s = ?t; ChamberComplexEndomorphism X ?s\\<rbrakk>\n  \\<Longrightarrow> ChamberComplexEndomorphism X ?t\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (f ^^ Suc m)", "by fast"], ["proof (state)\nthis:\n  ChamberComplexEndomorphism X (f ^^ Suc m)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ChamberComplexEndomorphism *)"], ["", "lemma (in ChamberComplex) fold_chamber_complex_endomorph_list:\n  \"\\<forall>x\\<in>set xs. ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n    ChamberComplexEndomorphism X (fold f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs.\n       ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n    ChamberComplexEndomorphism X (fold f xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n    ChamberComplexEndomorphism X (fold f [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n                ChamberComplexEndomorphism X (fold f xs);\n        \\<forall>x\\<in>set (a # xs).\n           ChamberComplexEndomorphism X (f x)\\<rbrakk>\n       \\<Longrightarrow> ChamberComplexEndomorphism X (fold f (a # xs))", "case Nil"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set []. ChamberComplexEndomorphism X (f x)\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set [].\n       ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n    ChamberComplexEndomorphism X (fold f [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n                ChamberComplexEndomorphism X (fold f xs);\n        \\<forall>x\\<in>set (a # xs).\n           ChamberComplexEndomorphism X (f x)\\<rbrakk>\n       \\<Longrightarrow> ChamberComplexEndomorphism X (fold f (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (fold f [])", "using trivial_endomorphism subst[of id]"], ["proof (prove)\nusing this:\n  ChamberComplexEndomorphism X id\n  \\<lbrakk>id = ?t; ?P id\\<rbrakk> \\<Longrightarrow> ?P ?t\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (fold f [])", "by fastforce"], ["proof (state)\nthis:\n  ChamberComplexEndomorphism X (fold f [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n                ChamberComplexEndomorphism X (fold f xs);\n        \\<forall>x\\<in>set (a # xs).\n           ChamberComplexEndomorphism X (f x)\\<rbrakk>\n       \\<Longrightarrow> ChamberComplexEndomorphism X (fold f (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n                ChamberComplexEndomorphism X (fold f xs);\n        \\<forall>x\\<in>set (a # xs).\n           ChamberComplexEndomorphism X (f x)\\<rbrakk>\n       \\<Longrightarrow> ChamberComplexEndomorphism X (fold f (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs.\n     ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n  ChamberComplexEndomorphism X (fold f xs)\n  \\<forall>x\\<in>set (x # xs). ChamberComplexEndomorphism X (f x)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n                ChamberComplexEndomorphism X (fold f xs);\n        \\<forall>x\\<in>set (a # xs).\n           ChamberComplexEndomorphism X (f x)\\<rbrakk>\n       \\<Longrightarrow> ChamberComplexEndomorphism X (fold f (a # xs))", "hence \"ChamberComplexEndomorphism X (fold f xs \\<circ> f x)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs.\n     ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n  ChamberComplexEndomorphism X (fold f xs)\n  \\<forall>x\\<in>set (x # xs). ChamberComplexEndomorphism X (f x)\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (fold f xs \\<circ> f x)", "using ChamberComplexEndomorphism.endo_comp"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs.\n     ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n  ChamberComplexEndomorphism X (fold f xs)\n  \\<forall>x\\<in>set (x # xs). ChamberComplexEndomorphism X (f x)\n  \\<lbrakk>ChamberComplexEndomorphism ?X ?f;\n   ChamberComplexEndomorphism ?X ?g\\<rbrakk>\n  \\<Longrightarrow> ChamberComplexEndomorphism ?X (?g \\<circ> ?f)\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (fold f xs \\<circ> f x)", "by auto"], ["proof (state)\nthis:\n  ChamberComplexEndomorphism X (fold f xs \\<circ> f x)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n                ChamberComplexEndomorphism X (fold f xs);\n        \\<forall>x\\<in>set (a # xs).\n           ChamberComplexEndomorphism X (f x)\\<rbrakk>\n       \\<Longrightarrow> ChamberComplexEndomorphism X (fold f (a # xs))", "moreover"], ["proof (state)\nthis:\n  ChamberComplexEndomorphism X (fold f xs \\<circ> f x)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n                ChamberComplexEndomorphism X (fold f xs);\n        \\<forall>x\\<in>set (a # xs).\n           ChamberComplexEndomorphism X (f x)\\<rbrakk>\n       \\<Longrightarrow> ChamberComplexEndomorphism X (fold f (a # xs))", "have \"fold f xs \\<circ> f x = fold f (x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold f xs \\<circ> f x = fold f (x # xs)", "by simp"], ["proof (state)\nthis:\n  fold f xs \\<circ> f x = fold f (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   ChamberComplexEndomorphism X (f x) \\<Longrightarrow>\n                ChamberComplexEndomorphism X (fold f xs);\n        \\<forall>x\\<in>set (a # xs).\n           ChamberComplexEndomorphism X (f x)\\<rbrakk>\n       \\<Longrightarrow> ChamberComplexEndomorphism X (fold f (a # xs))", "ultimately"], ["proof (chain)\npicking this:\n  ChamberComplexEndomorphism X (fold f xs \\<circ> f x)\n  fold f xs \\<circ> f x = fold f (x # xs)", "show ?case"], ["proof (prove)\nusing this:\n  ChamberComplexEndomorphism X (fold f xs \\<circ> f x)\n  fold f xs \\<circ> f x = fold f (x # xs)\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (fold f (x # xs))", "using subst[of _ _ \"\\<lambda>f. ChamberComplexEndomorphism X f\"]"], ["proof (prove)\nusing this:\n  ChamberComplexEndomorphism X (fold f xs \\<circ> f x)\n  fold f xs \\<circ> f x = fold f (x # xs)\n  \\<lbrakk>?s = ?t; ChamberComplexEndomorphism X ?s\\<rbrakk>\n  \\<Longrightarrow> ChamberComplexEndomorphism X ?t\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (fold f (x # xs))", "by fast"], ["proof (state)\nthis:\n  ChamberComplexEndomorphism X (fold f (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "context ChamberComplexEndomorphism\nbegin"], ["", "lemma split_gallery:\n  \"\\<lbrakk> C\\<in>f\\<turnstile>\\<C>; D\\<in>\\<C>-f\\<turnstile>\\<C>; gallery (C#Cs@[D]) \\<rbrakk> \\<Longrightarrow>\n    \\<exists>As A B Bs. A\\<in>f\\<turnstile>\\<C> \\<and> B\\<in>\\<C>-f\\<turnstile>\\<C> \\<and> C#Cs@[D] = As@A#B#Bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n     D \\<in> \\<C> - f \\<turnstile> \\<C>; gallery (C # Cs @ [D])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>As A B Bs.\n                         A \\<in> f \\<turnstile> \\<C> \\<and>\n                         B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                         C # Cs @ [D] = As @ A # B # Bs", "proof (induct Cs arbitrary: C)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n        D \\<in> \\<C> - f \\<turnstile> \\<C>; gallery (C # [] @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>As A B Bs.\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                            C # [] @ [D] = As @ A # B # Bs\n 2. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n                    D \\<in> \\<C> - f \\<turnstile> \\<C>;\n                    gallery (C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>As A B Bs.\n  A \\<in> f \\<turnstile> \\<C> \\<and>\n  B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> C # Cs @ [D] = As @ A # B # Bs;\n        C \\<in> f \\<turnstile> \\<C>; D \\<in> \\<C> - f \\<turnstile> \\<C>;\n        gallery (C # (a # Cs) @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>As A B Bs.\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                            C # (a # Cs) @ [D] = As @ A # B # Bs", "case Nil"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> \\<C> - f \\<turnstile> \\<C>\n  gallery (C # [] @ [D])\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n        D \\<in> \\<C> - f \\<turnstile> \\<C>; gallery (C # [] @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>As A B Bs.\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                            C # [] @ [D] = As @ A # B # Bs\n 2. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n                    D \\<in> \\<C> - f \\<turnstile> \\<C>;\n                    gallery (C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>As A B Bs.\n  A \\<in> f \\<turnstile> \\<C> \\<and>\n  B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> C # Cs @ [D] = As @ A # B # Bs;\n        C \\<in> f \\<turnstile> \\<C>; D \\<in> \\<C> - f \\<turnstile> \\<C>;\n        gallery (C # (a # Cs) @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>As A B Bs.\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                            C # (a # Cs) @ [D] = As @ A # B # Bs", "define As :: \"'a set list\" where \"As = []\""], ["proof (state)\nthis:\n  As = []\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n        D \\<in> \\<C> - f \\<turnstile> \\<C>; gallery (C # [] @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>As A B Bs.\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                            C # [] @ [D] = As @ A # B # Bs\n 2. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n                    D \\<in> \\<C> - f \\<turnstile> \\<C>;\n                    gallery (C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>As A B Bs.\n  A \\<in> f \\<turnstile> \\<C> \\<and>\n  B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> C # Cs @ [D] = As @ A # B # Bs;\n        C \\<in> f \\<turnstile> \\<C>; D \\<in> \\<C> - f \\<turnstile> \\<C>;\n        gallery (C # (a # Cs) @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>As A B Bs.\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                            C # (a # Cs) @ [D] = As @ A # B # Bs", "hence \"C#[]@[D] = As@C#D#As\""], ["proof (prove)\nusing this:\n  As = []\n\ngoal (1 subgoal):\n 1. C # [] @ [D] = As @ C # D # As", "by simp"], ["proof (state)\nthis:\n  C # [] @ [D] = As @ C # D # As\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n        D \\<in> \\<C> - f \\<turnstile> \\<C>; gallery (C # [] @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>As A B Bs.\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                            C # [] @ [D] = As @ A # B # Bs\n 2. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n                    D \\<in> \\<C> - f \\<turnstile> \\<C>;\n                    gallery (C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>As A B Bs.\n  A \\<in> f \\<turnstile> \\<C> \\<and>\n  B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> C # Cs @ [D] = As @ A # B # Bs;\n        C \\<in> f \\<turnstile> \\<C>; D \\<in> \\<C> - f \\<turnstile> \\<C>;\n        gallery (C # (a # Cs) @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>As A B Bs.\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                            C # (a # Cs) @ [D] = As @ A # B # Bs", "with Nil(1,2)"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> \\<C> - f \\<turnstile> \\<C>\n  C # [] @ [D] = As @ C # D # As", "show ?case"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> \\<C> - f \\<turnstile> \\<C>\n  C # [] @ [D] = As @ C # D # As\n\ngoal (1 subgoal):\n 1. \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # [] @ [D] = As @ A # B # Bs", "by auto"], ["proof (state)\nthis:\n  \\<exists>As A B Bs.\n     A \\<in> f \\<turnstile> \\<C> \\<and>\n     B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n     C # [] @ [D] = As @ A # B # Bs\n\ngoal (1 subgoal):\n 1. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n                    D \\<in> \\<C> - f \\<turnstile> \\<C>;\n                    gallery (C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>As A B Bs.\n  A \\<in> f \\<turnstile> \\<C> \\<and>\n  B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> C # Cs @ [D] = As @ A # B # Bs;\n        C \\<in> f \\<turnstile> \\<C>; D \\<in> \\<C> - f \\<turnstile> \\<C>;\n        gallery (C # (a # Cs) @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>As A B Bs.\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                            C # (a # Cs) @ [D] = As @ A # B # Bs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n                    D \\<in> \\<C> - f \\<turnstile> \\<C>;\n                    gallery (C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>As A B Bs.\n  A \\<in> f \\<turnstile> \\<C> \\<and>\n  B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> C # Cs @ [D] = As @ A # B # Bs;\n        C \\<in> f \\<turnstile> \\<C>; D \\<in> \\<C> - f \\<turnstile> \\<C>;\n        gallery (C # (a # Cs) @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>As A B Bs.\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                            C # (a # Cs) @ [D] = As @ A # B # Bs", "case (Cons E Es)"], ["proof (state)\nthis:\n  \\<lbrakk>?C2 \\<in> f \\<turnstile> \\<C>;\n   D \\<in> \\<C> - f \\<turnstile> \\<C>; gallery (?C2 # Es @ [D])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>As A B Bs.\n                       A \\<in> f \\<turnstile> \\<C> \\<and>\n                       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                       ?C2 # Es @ [D] = As @ A # B # Bs\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> \\<C> - f \\<turnstile> \\<C>\n  gallery (C # (E # Es) @ [D])\n\ngoal (1 subgoal):\n 1. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n                    D \\<in> \\<C> - f \\<turnstile> \\<C>;\n                    gallery (C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>As A B Bs.\n  A \\<in> f \\<turnstile> \\<C> \\<and>\n  B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> C # Cs @ [D] = As @ A # B # Bs;\n        C \\<in> f \\<turnstile> \\<C>; D \\<in> \\<C> - f \\<turnstile> \\<C>;\n        gallery (C # (a # Cs) @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>As A B Bs.\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                            C # (a # Cs) @ [D] = As @ A # B # Bs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "proof (cases \"E\\<in>f\\<turnstile>\\<C>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. E \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs\n 2. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "case True"], ["proof (state)\nthis:\n  E \\<in> f \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. E \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs\n 2. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "from Cons(4)"], ["proof (chain)\npicking this:\n  gallery (C # (E # Es) @ [D])", "have \"gallery (E#Es@[D])\""], ["proof (prove)\nusing this:\n  gallery (C # (E # Es) @ [D])\n\ngoal (1 subgoal):\n 1. gallery (E # Es @ [D])", "using gallery_Cons_reduce"], ["proof (prove)\nusing this:\n  gallery (C # (E # Es) @ [D])\n  gallery (?x # ?xs) \\<Longrightarrow> gallery ?xs\n\ngoal (1 subgoal):\n 1. gallery (E # Es @ [D])", "by simp"], ["proof (state)\nthis:\n  gallery (E # Es @ [D])\n\ngoal (2 subgoals):\n 1. E \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs\n 2. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "with True"], ["proof (chain)\npicking this:\n  E \\<in> f \\<turnstile> \\<C>\n  gallery (E # Es @ [D])", "obtain As A B Bs\n      where 1: \"A\\<in>f\\<turnstile>\\<C>\" \"B\\<in>\\<C>-f\\<turnstile>\\<C>\" \"E#Es@[D] = As@A#B#Bs\""], ["proof (prove)\nusing this:\n  E \\<in> f \\<turnstile> \\<C>\n  gallery (E # Es @ [D])\n\ngoal (1 subgoal):\n 1. (\\<And>A B As Bs.\n        \\<lbrakk>A \\<in> f \\<turnstile> \\<C>;\n         B \\<in> \\<C> - f \\<turnstile> \\<C>;\n         E # Es @ [D] = As @ A # B # Bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons(1)[of E] Cons(3)"], ["proof (prove)\nusing this:\n  E \\<in> f \\<turnstile> \\<C>\n  gallery (E # Es @ [D])\n  \\<lbrakk>E \\<in> f \\<turnstile> \\<C>; D \\<in> \\<C> - f \\<turnstile> \\<C>;\n   gallery (E # Es @ [D])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>As A B Bs.\n                       A \\<in> f \\<turnstile> \\<C> \\<and>\n                       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                       E # Es @ [D] = As @ A # B # Bs\n  D \\<in> \\<C> - f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. (\\<And>A B As Bs.\n        \\<lbrakk>A \\<in> f \\<turnstile> \\<C>;\n         B \\<in> \\<C> - f \\<turnstile> \\<C>;\n         E # Es @ [D] = As @ A # B # Bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    blast"], ["proof (state)\nthis:\n  A \\<in> f \\<turnstile> \\<C>\n  B \\<in> \\<C> - f \\<turnstile> \\<C>\n  E # Es @ [D] = As @ A # B # Bs\n\ngoal (2 subgoals):\n 1. E \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs\n 2. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "from 1(3)"], ["proof (chain)\npicking this:\n  E # Es @ [D] = As @ A # B # Bs", "have \"C#(E#Es)@[D] = (C#As)@A#B#Bs\""], ["proof (prove)\nusing this:\n  E # Es @ [D] = As @ A # B # Bs\n\ngoal (1 subgoal):\n 1. C # (E # Es) @ [D] = (C # As) @ A # B # Bs", "by simp"], ["proof (state)\nthis:\n  C # (E # Es) @ [D] = (C # As) @ A # B # Bs\n\ngoal (2 subgoals):\n 1. E \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs\n 2. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "with 1(1,2)"], ["proof (chain)\npicking this:\n  A \\<in> f \\<turnstile> \\<C>\n  B \\<in> \\<C> - f \\<turnstile> \\<C>\n  C # (E # Es) @ [D] = (C # As) @ A # B # Bs", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<in> f \\<turnstile> \\<C>\n  B \\<in> \\<C> - f \\<turnstile> \\<C>\n  C # (E # Es) @ [D] = (C # As) @ A # B # Bs\n\ngoal (1 subgoal):\n 1. \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "by blast"], ["proof (state)\nthis:\n  \\<exists>As A B Bs.\n     A \\<in> f \\<turnstile> \\<C> \\<and>\n     B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n     C # (E # Es) @ [D] = As @ A # B # Bs\n\ngoal (1 subgoal):\n 1. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "case False"], ["proof (state)\nthis:\n  E \\<notin> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "hence \"E\\<in>\\<C>-f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  E \\<notin> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. E \\<in> \\<C> - f \\<turnstile> \\<C>", "using gallery_chamber_system[OF Cons(4)]"], ["proof (prove)\nusing this:\n  E \\<notin> f \\<turnstile> \\<C>\n  order.greater_eq \\<C> (set (C # (E # Es) @ [D]))\n\ngoal (1 subgoal):\n 1. E \\<in> \\<C> - f \\<turnstile> \\<C>", "by simp"], ["proof (state)\nthis:\n  E \\<in> \\<C> - f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "moreover"], ["proof (state)\nthis:\n  E \\<in> \\<C> - f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "have \"C#(E#Es)@[D] = []@C#E#(Es@[D])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C # (E # Es) @ [D] = [] @ C # E # Es @ [D]", "by simp"], ["proof (state)\nthis:\n  C # (E # Es) @ [D] = [] @ C # E # Es @ [D]\n\ngoal (1 subgoal):\n 1. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "ultimately"], ["proof (chain)\npicking this:\n  E \\<in> \\<C> - f \\<turnstile> \\<C>\n  C # (E # Es) @ [D] = [] @ C # E # Es @ [D]", "show ?thesis"], ["proof (prove)\nusing this:\n  E \\<in> \\<C> - f \\<turnstile> \\<C>\n  C # (E # Es) @ [D] = [] @ C # E # Es @ [D]\n\ngoal (1 subgoal):\n 1. \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "using Cons(2)"], ["proof (prove)\nusing this:\n  E \\<in> \\<C> - f \\<turnstile> \\<C>\n  C # (E # Es) @ [D] = [] @ C # E # Es @ [D]\n  C \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>As A B Bs.\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n       C # (E # Es) @ [D] = As @ A # B # Bs", "by blast"], ["proof (state)\nthis:\n  \\<exists>As A B Bs.\n     A \\<in> f \\<turnstile> \\<C> \\<and>\n     B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n     C # (E # Es) @ [D] = As @ A # B # Bs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>As A B Bs.\n     A \\<in> f \\<turnstile> \\<C> \\<and>\n     B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n     C # (E # Es) @ [D] = As @ A # B # Bs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma respects_labels_adjacent:\n  assumes \"label_wrt B \\<phi>\" \"chamber C\" \"chamber D\" \"C\\<sim>D\" \"\\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\"\n  shows   \"\\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "proof (cases \"C=D\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C = D \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\n 2. C \\<noteq> D \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "case False"], ["proof (state)\nthis:\n  C \\<noteq> D\n\ngoal (2 subgoals):\n 1. C = D \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\n 2. C \\<noteq> D \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "have CD: \"C\\<noteq>D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<noteq> D", "by fact"], ["proof (state)\nthis:\n  C \\<noteq> D\n\ngoal (2 subgoals):\n 1. C = D \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\n 2. C \\<noteq> D \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "with assms(4)"], ["proof (chain)\npicking this:\n  C \\<sim> D\n  C \\<noteq> D", "obtain w where w: \"w\\<notin>D\" \"C = insert w (C\\<inter>D)\""], ["proof (prove)\nusing this:\n  C \\<sim> D\n  C \\<noteq> D\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<notin> D; C = insert w (C \\<inter> D)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using adjacent_int_decomp"], ["proof (prove)\nusing this:\n  C \\<sim> D\n  C \\<noteq> D\n  \\<lbrakk>?x \\<sim> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v.\n                       v \\<notin> ?y \\<and> ?x = insert v (?x \\<inter> ?y)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<notin> D; C = insert w (C \\<inter> D)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  w \\<notin> D\n  C = insert w (C \\<inter> D)\n\ngoal (2 subgoals):\n 1. C = D \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\n 2. C \\<noteq> D \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "with assms(2)"], ["proof (chain)\npicking this:\n  chamber C\n  w \\<notin> D\n  C = insert w (C \\<inter> D)", "have fC: \"f w \\<notin> f`(C\\<inter>D)\" \"f`C = insert (f w) (f`(C\\<inter>D))\""], ["proof (prove)\nusing this:\n  chamber C\n  w \\<notin> D\n  C = insert w (C \\<inter> D)\n\ngoal (1 subgoal):\n 1. f w \\<notin> f ` (C \\<inter> D) &&&\n    f ` C = insert (f w) (f ` (C \\<inter> D))", "using chamber_vertex_outside_facet_image[of w \"C\\<inter>D\"]"], ["proof (prove)\nusing this:\n  chamber C\n  w \\<notin> D\n  C = insert w (C \\<inter> D)\n  \\<lbrakk>w \\<notin> C \\<inter> D;\n   chamber (insert w (C \\<inter> D))\\<rbrakk>\n  \\<Longrightarrow> f w \\<notin> f ` (C \\<inter> D)\n\ngoal (1 subgoal):\n 1. f w \\<notin> f ` (C \\<inter> D) &&&\n    f ` C = insert (f w) (f ` (C \\<inter> D))", "by auto"], ["proof (state)\nthis:\n  f w \\<notin> f ` (C \\<inter> D)\n  f ` C = insert (f w) (f ` (C \\<inter> D))\n\ngoal (2 subgoals):\n 1. C = D \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\n 2. C \\<noteq> D \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> D \\<Longrightarrow> \\<phi> (f v) = \\<phi> v", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> D \\<Longrightarrow> \\<phi> (f v) = \\<phi> v", "assume v: \"v\\<in>D\""], ["proof (state)\nthis:\n  v \\<in> D\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> D \\<Longrightarrow> \\<phi> (f v) = \\<phi> v", "show \"\\<phi> (f v) = \\<phi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (f v) = \\<phi> v", "proof (cases \"v\\<in>C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> C \\<Longrightarrow> \\<phi> (f v) = \\<phi> v\n 2. v \\<notin> C \\<Longrightarrow> \\<phi> (f v) = \\<phi> v", "case False"], ["proof (state)\nthis:\n  v \\<notin> C\n\ngoal (2 subgoals):\n 1. v \\<in> C \\<Longrightarrow> \\<phi> (f v) = \\<phi> v\n 2. v \\<notin> C \\<Longrightarrow> \\<phi> (f v) = \\<phi> v", "with assms(3,4) v"], ["proof (chain)\npicking this:\n  chamber D\n  C \\<sim> D\n  v \\<in> D\n  v \\<notin> C", "have fD: \"f v \\<notin> f`(D\\<inter>C)\" \"f`D = insert (f v) (f`(D\\<inter>C))\""], ["proof (prove)\nusing this:\n  chamber D\n  C \\<sim> D\n  v \\<in> D\n  v \\<notin> C\n\ngoal (1 subgoal):\n 1. f v \\<notin> f ` (D \\<inter> C) &&&\n    f ` D = insert (f v) (f ` (D \\<inter> C))", "using adjacent_sym[of C D] adjacent_conv_insert[of D C v]\n              chamber_vertex_outside_facet_image[of v \"D\\<inter>C\"]"], ["proof (prove)\nusing this:\n  chamber D\n  C \\<sim> D\n  v \\<in> D\n  v \\<notin> C\n  C \\<sim> D \\<Longrightarrow> D \\<sim> C\n  \\<lbrakk>D \\<sim> C; v \\<in> D - C\\<rbrakk>\n  \\<Longrightarrow> D = insert v (D \\<inter> C)\n  \\<lbrakk>v \\<notin> D \\<inter> C;\n   chamber (insert v (D \\<inter> C))\\<rbrakk>\n  \\<Longrightarrow> f v \\<notin> f ` (D \\<inter> C)\n\ngoal (1 subgoal):\n 1. f v \\<notin> f ` (D \\<inter> C) &&&\n    f ` D = insert (f v) (f ` (D \\<inter> C))", "by    auto"], ["proof (state)\nthis:\n  f v \\<notin> f ` (D \\<inter> C)\n  f ` D = insert (f v) (f ` (D \\<inter> C))\n\ngoal (2 subgoals):\n 1. v \\<in> C \\<Longrightarrow> \\<phi> (f v) = \\<phi> v\n 2. v \\<notin> C \\<Longrightarrow> \\<phi> (f v) = \\<phi> v", "have \"\\<phi> (f v) = \\<phi> (f w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (f v) = \\<phi> (f w)", "proof (cases \"f`C=f`D\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f ` C = f ` D \\<Longrightarrow> \\<phi> (f v) = \\<phi> (f w)\n 2. f ` C \\<noteq> f ` D \\<Longrightarrow> \\<phi> (f v) = \\<phi> (f w)", "case True"], ["proof (state)\nthis:\n  f ` C = f ` D\n\ngoal (2 subgoals):\n 1. f ` C = f ` D \\<Longrightarrow> \\<phi> (f v) = \\<phi> (f w)\n 2. f ` C \\<noteq> f ` D \\<Longrightarrow> \\<phi> (f v) = \\<phi> (f w)", "with fC fD"], ["proof (chain)\npicking this:\n  f w \\<notin> f ` (C \\<inter> D)\n  f ` C = insert (f w) (f ` (C \\<inter> D))\n  f v \\<notin> f ` (D \\<inter> C)\n  f ` D = insert (f v) (f ` (D \\<inter> C))\n  f ` C = f ` D", "have \"f v = f w\""], ["proof (prove)\nusing this:\n  f w \\<notin> f ` (C \\<inter> D)\n  f ` C = insert (f w) (f ` (C \\<inter> D))\n  f v \\<notin> f ` (D \\<inter> C)\n  f ` D = insert (f v) (f ` (D \\<inter> C))\n  f ` C = f ` D\n\ngoal (1 subgoal):\n 1. f v = f w", "by (auto simp add: Int_commute)"], ["proof (state)\nthis:\n  f v = f w\n\ngoal (2 subgoals):\n 1. f ` C = f ` D \\<Longrightarrow> \\<phi> (f v) = \\<phi> (f w)\n 2. f ` C \\<noteq> f ` D \\<Longrightarrow> \\<phi> (f v) = \\<phi> (f w)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f v = f w\n\ngoal (1 subgoal):\n 1. \\<phi> (f v) = \\<phi> (f w)", "by simp"], ["proof (state)\nthis:\n  \\<phi> (f v) = \\<phi> (f w)\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> \\<phi> (f v) = \\<phi> (f w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> \\<phi> (f v) = \\<phi> (f w)", "case False"], ["proof (state)\nthis:\n  f ` C \\<noteq> f ` D\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> \\<phi> (f v) = \\<phi> (f w)", "from assms(2-4)"], ["proof (chain)\npicking this:\n  chamber C\n  chamber D\n  C \\<sim> D", "have \"chamber (f`C)\" \"chamber (f`D)\" and fCfD: \"f`C\\<sim>f`D\""], ["proof (prove)\nusing this:\n  chamber C\n  chamber D\n  C \\<sim> D\n\ngoal (1 subgoal):\n 1. (chamber (f ` C) &&& chamber (f ` D)) &&& f ` C \\<sim> f ` D", "using chamber_map adj_map"], ["proof (prove)\nusing this:\n  chamber C\n  chamber D\n  C \\<sim> D\n  chamber ?C \\<Longrightarrow> chamber (f ` ?C)\n  \\<lbrakk>chamber ?C; chamber ?D; ?C \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> f ` ?C \\<sim> f ` ?D\n\ngoal (1 subgoal):\n 1. (chamber (f ` C) &&& chamber (f ` D)) &&& f ` C \\<sim> f ` D", "by auto"], ["proof (state)\nthis:\n  chamber (f ` C)\n  chamber (f ` D)\n  f ` C \\<sim> f ` D\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> \\<phi> (f v) = \\<phi> (f w)", "moreover"], ["proof (state)\nthis:\n  chamber (f ` C)\n  chamber (f ` D)\n  f ` C \\<sim> f ` D\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> \\<phi> (f v) = \\<phi> (f w)", "from assms(4) fC fCfD False"], ["proof (chain)\npicking this:\n  C \\<sim> D\n  f w \\<notin> f ` (C \\<inter> D)\n  f ` C = insert (f w) (f ` (C \\<inter> D))\n  f ` C \\<sim> f ` D\n  f ` C \\<noteq> f ` D", "have \"f w \\<in> f`C - f`D\""], ["proof (prove)\nusing this:\n  C \\<sim> D\n  f w \\<notin> f ` (C \\<inter> D)\n  f ` C = insert (f w) (f ` (C \\<inter> D))\n  f ` C \\<sim> f ` D\n  f ` C \\<noteq> f ` D\n\ngoal (1 subgoal):\n 1. f w \\<in> f ` C - f ` D", "using adjacent_to_adjacent_int[of C D f]"], ["proof (prove)\nusing this:\n  C \\<sim> D\n  f w \\<notin> f ` (C \\<inter> D)\n  f ` C = insert (f w) (f ` (C \\<inter> D))\n  f ` C \\<sim> f ` D\n  f ` C \\<noteq> f ` D\n  \\<lbrakk>C \\<sim> D; f ` C \\<sim> f ` D; f ` C \\<noteq> f ` D\\<rbrakk>\n  \\<Longrightarrow> f ` (C \\<inter> D) = f ` C \\<inter> f ` D\n\ngoal (1 subgoal):\n 1. f w \\<in> f ` C - f ` D", "by auto"], ["proof (state)\nthis:\n  f w \\<in> f ` C - f ` D\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> \\<phi> (f v) = \\<phi> (f w)", "ultimately"], ["proof (chain)\npicking this:\n  chamber (f ` C)\n  chamber (f ` D)\n  f ` C \\<sim> f ` D\n  f w \\<in> f ` C - f ` D", "show ?thesis"], ["proof (prove)\nusing this:\n  chamber (f ` C)\n  chamber (f ` D)\n  f ` C \\<sim> f ` D\n  f w \\<in> f ` C - f ` D\n\ngoal (1 subgoal):\n 1. \\<phi> (f v) = \\<phi> (f w)", "using assms(4) fD fCfD False adjacent_sym\n                adjacent_to_adjacent_int[of D C f]\n                label_wrt_adjacent[OF assms(1), of \"f`C\" \"f`D\" \"f w\" \"f v\", THEN sym]"], ["proof (prove)\nusing this:\n  chamber (f ` C)\n  chamber (f ` D)\n  f ` C \\<sim> f ` D\n  f w \\<in> f ` C - f ` D\n  C \\<sim> D\n  f v \\<notin> f ` (D \\<inter> C)\n  f ` D = insert (f v) (f ` (D \\<inter> C))\n  f ` C \\<sim> f ` D\n  f ` C \\<noteq> f ` D\n  ?x \\<sim> ?y \\<Longrightarrow> ?y \\<sim> ?x\n  \\<lbrakk>D \\<sim> C; f ` D \\<sim> f ` C; f ` D \\<noteq> f ` C\\<rbrakk>\n  \\<Longrightarrow> f ` (D \\<inter> C) = f ` D \\<inter> f ` C\n  \\<lbrakk>chamber (f ` C); chamber (f ` D); f ` C \\<sim> f ` D;\n   f w \\<in> f ` C - f ` D; f v \\<in> f ` D - f ` C\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (f v) = \\<phi> (f w)\n\ngoal (1 subgoal):\n 1. \\<phi> (f v) = \\<phi> (f w)", "by    auto"], ["proof (state)\nthis:\n  \\<phi> (f v) = \\<phi> (f w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> (f v) = \\<phi> (f w)\n\ngoal (2 subgoals):\n 1. v \\<in> C \\<Longrightarrow> \\<phi> (f v) = \\<phi> v\n 2. v \\<notin> C \\<Longrightarrow> \\<phi> (f v) = \\<phi> v", "with False v w assms(5)"], ["proof (chain)\npicking this:\n  v \\<notin> C\n  v \\<in> D\n  w \\<notin> D\n  C = insert w (C \\<inter> D)\n  \\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\n  \\<phi> (f v) = \\<phi> (f w)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> C\n  v \\<in> D\n  w \\<notin> D\n  C = insert w (C \\<inter> D)\n  \\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\n  \\<phi> (f v) = \\<phi> (f w)\n\ngoal (1 subgoal):\n 1. \\<phi> (f v) = \\<phi> v", "using label_wrt_adjacent[OF assms(1-4), of w v, THEN sym]"], ["proof (prove)\nusing this:\n  v \\<notin> C\n  v \\<in> D\n  w \\<notin> D\n  C = insert w (C \\<inter> D)\n  \\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\n  \\<phi> (f v) = \\<phi> (f w)\n  \\<lbrakk>w \\<in> C - D; v \\<in> D - C\\<rbrakk>\n  \\<Longrightarrow> \\<phi> v = \\<phi> w\n\ngoal (1 subgoal):\n 1. \\<phi> (f v) = \\<phi> v", "by fastforce"], ["proof (state)\nthis:\n  \\<phi> (f v) = \\<phi> v\n\ngoal (1 subgoal):\n 1. v \\<in> C \\<Longrightarrow> \\<phi> (f v) = \\<phi> v", "qed (simp add: assms(5))"], ["proof (state)\nthis:\n  \\<phi> (f v) = \\<phi> v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\n\ngoal (1 subgoal):\n 1. C = D \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "qed (simp add: assms(5))"], ["", "lemma respects_labels_gallery:\n  assumes \"label_wrt B \\<phi>\" \"\\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\"\n  shows   \"gallery (C#Cs@[D]) \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gallery (C # Cs @ [D]) \\<Longrightarrow>\n    \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "proof (induct Cs arbitrary: D rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>D.\n       gallery (C # [] @ [D]) \\<Longrightarrow>\n       \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\n 2. \\<And>x xs D.\n       \\<lbrakk>\\<And>D.\n                   gallery (C # xs @ [D]) \\<Longrightarrow>\n                   \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v;\n        gallery (C # (xs @ [x]) @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "case Nil"], ["proof (state)\nthis:\n  gallery (C # [] @ [D])\n\ngoal (2 subgoals):\n 1. \\<And>D.\n       gallery (C # [] @ [D]) \\<Longrightarrow>\n       \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\n 2. \\<And>x xs D.\n       \\<lbrakk>\\<And>D.\n                   gallery (C # xs @ [D]) \\<Longrightarrow>\n                   \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v;\n        gallery (C # (xs @ [x]) @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "with assms(2)"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\n  gallery (C # [] @ [D])", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\n  gallery (C # [] @ [D])\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "using galleryD_chamber galleryD_adj\n          respects_labels_adjacent[OF assms(1), of C D]"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\n  gallery (C # [] @ [D])\n  \\<lbrakk>gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> chamber ?x\n  gallery ?xs \\<Longrightarrow> adjacentchain ?xs\n  \\<lbrakk>chamber C; chamber D; C \\<sim> D;\n   \\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "by    force"], ["proof (state)\nthis:\n  \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\n\ngoal (1 subgoal):\n 1. \\<And>x xs D.\n       \\<lbrakk>\\<And>D.\n                   gallery (C # xs @ [D]) \\<Longrightarrow>\n                   \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v;\n        gallery (C # (xs @ [x]) @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs D.\n       \\<lbrakk>\\<And>D.\n                   gallery (C # xs @ [D]) \\<Longrightarrow>\n                   \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v;\n        gallery (C # (xs @ [x]) @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "case (snoc E Es)"], ["proof (state)\nthis:\n  gallery (C # Es @ [?D2]) \\<Longrightarrow>\n  \\<forall>v\\<in>?D2. \\<phi> (f v) = \\<phi> v\n  gallery (C # (Es @ [E]) @ [D])\n\ngoal (1 subgoal):\n 1. \\<And>x xs D.\n       \\<lbrakk>\\<And>D.\n                   gallery (C # xs @ [D]) \\<Longrightarrow>\n                   \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v;\n        gallery (C # (xs @ [x]) @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "with assms(2)"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\n  gallery (C # Es @ [?D2]) \\<Longrightarrow>\n  \\<forall>v\\<in>?D2. \\<phi> (f v) = \\<phi> v\n  gallery (C # (Es @ [E]) @ [D])", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\n  gallery (C # Es @ [?D2]) \\<Longrightarrow>\n  \\<forall>v\\<in>?D2. \\<phi> (f v) = \\<phi> v\n  gallery (C # (Es @ [E]) @ [D])\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "using gallery_append_reduce1[of \"C#Es@[E]\"] galleryD_chamber galleryD_adj\n          binrelchain_append_reduce2[of adjacent \"C#Es\" \"[E,D]\"]\n          respects_labels_adjacent[OF assms(1), of E D]"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\n  gallery (C # Es @ [?D2]) \\<Longrightarrow>\n  \\<forall>v\\<in>?D2. \\<phi> (f v) = \\<phi> v\n  gallery (C # (Es @ [E]) @ [D])\n  gallery ((C # Es @ [E]) @ ?ys) \\<Longrightarrow> gallery (C # Es @ [E])\n  \\<lbrakk>gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> chamber ?x\n  gallery ?xs \\<Longrightarrow> adjacentchain ?xs\n  adjacentchain ((C # Es) @ [E, D]) \\<Longrightarrow> adjacentchain [E, D]\n  \\<lbrakk>chamber E; chamber D; E \\<sim> D;\n   \\<forall>v\\<in>E. \\<phi> (f v) = \\<phi> v\\<rbrakk>\n  \\<Longrightarrow> \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v", "by    force"], ["proof (state)\nthis:\n  \\<forall>v\\<in>D. \\<phi> (f v) = \\<phi> v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma respect_label_fix_chamber_imp_fun_eq_on:\n  assumes label  :  \"label_wrt B \\<phi>\"\n  and     chamber:  \"chamber C\" \"f`C = g`C\"\n  and     respect:  \"\\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\" \"\\<forall>v\\<in>C. \\<phi> (g v) = \\<phi> v\"\n  shows   \"fun_eq_on f g C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_eq_on f g C", "proof (rule fun_eq_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C \\<Longrightarrow> f a = g a", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C \\<Longrightarrow> f a = g a", "assume \"v\\<in>C\""], ["proof (state)\nthis:\n  v \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C \\<Longrightarrow> f a = g a", "moreover"], ["proof (state)\nthis:\n  v \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C \\<Longrightarrow> f a = g a", "with respect"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\n  \\<forall>v\\<in>C. \\<phi> (g v) = \\<phi> v\n  v \\<in> C", "have \"\\<phi> (f v) = \\<phi> (g v)\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>C. \\<phi> (f v) = \\<phi> v\n  \\<forall>v\\<in>C. \\<phi> (g v) = \\<phi> v\n  v \\<in> C\n\ngoal (1 subgoal):\n 1. \\<phi> (f v) = \\<phi> (g v)", "by simp"], ["proof (state)\nthis:\n  \\<phi> (f v) = \\<phi> (g v)\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C \\<Longrightarrow> f a = g a", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> C\n  \\<phi> (f v) = \\<phi> (g v)", "show \"f v = g v\""], ["proof (prove)\nusing this:\n  v \\<in> C\n  \\<phi> (f v) = \\<phi> (g v)\n\ngoal (1 subgoal):\n 1. f v = g v", "using label chamber chamber_map chamber_system_def label_wrtD[of B \\<phi> \"f`C\"]\n          bij_betw_imp_inj_on[of \\<phi>] inj_onD"], ["proof (prove)\nusing this:\n  v \\<in> C\n  \\<phi> (f v) = \\<phi> (g v)\n  label_wrt B \\<phi>\n  chamber C\n  f ` C = g ` C\n  chamber ?C \\<Longrightarrow> chamber (f ` ?C)\n  \\<C> \\<equiv> Collect chamber\n  \\<lbrakk>label_wrt B \\<phi>; f ` C \\<in> \\<C>\\<rbrakk>\n  \\<Longrightarrow> bij_betw \\<phi> (f ` C) B\n  bij_betw \\<phi> ?A ?B \\<Longrightarrow> inj_on \\<phi> ?A\n  \\<lbrakk>inj_on ?f ?A; ?f ?x = ?f ?y; ?x \\<in> ?A; ?y \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. f v = g v", "by    fastforce"], ["proof (state)\nthis:\n  f v = g v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas respects_label_fixes_chamber_imp_fixespointwise =\n  respect_label_fix_chamber_imp_fun_eq_on[of _ _ _ id, simplified]"], ["", "end"], ["", "(* context ChamberComplexEndomorphism *)"], ["", "subsubsection \\<open>Automorphisms\\<close>"], ["", "locale ChamberComplexAutomorphism = ChamberComplexIsomorphism X X f\n  for X :: \"'a set set\"\n  and f :: \"'a\\<Rightarrow>'a\"\n+ assumes trivial_outside : \"v\\<notin>\\<Union>X \\<Longrightarrow> f v = v\"\n  \\<comment> \\<open>to facilitate uniqueness arguments\\<close>"], ["", "sublocale ChamberComplexAutomorphism < ChamberComplexEndomorphism"], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X f", "using trivial_outside"], ["proof (prove)\nusing this:\n  ?v \\<notin> \\<Union> X \\<Longrightarrow> f ?v = ?v\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X f", "by unfold_locales fast"], ["", "lemma (in ChamberComplex) trivial_automorphism:\n  \"ChamberComplexAutomorphism X id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexAutomorphism X id", "using trivial_isomorphism"], ["proof (prove)\nusing this:\n  ChamberComplexIsomorphism X X id\n\ngoal (1 subgoal):\n 1. ChamberComplexAutomorphism X id", "by    unfold_locales (auto intro: ChamberComplexAutomorphism.intro)"], ["", "context ChamberComplexAutomorphism\nbegin"], ["", "lemmas facet_map         = facet_map"], ["", "lemmas chamber_map       = chamber_map"], ["", "lemmas chamber_morphism  = chamber_morphism"], ["", "lemmas bij_betw_vertices = bij_betw_vertices"], ["", "lemmas surj_simplex_map  = surj_simplex_map"], ["", "lemma bij: \"bij f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij f", "proof (rule bijI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj f\n 2. surj f", "show \"inj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj f", "proof (rule injI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. f x = f y \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. f x = f y \\<Longrightarrow> x = y", "assume \"f x = f y\""], ["proof (state)\nthis:\n  f x = f y\n\ngoal (1 subgoal):\n 1. \\<And>x y. f x = f y \\<Longrightarrow> x = y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  f x = f y\n\ngoal (1 subgoal):\n 1. x = y", "using bij_betw_imp_inj_on[OF bij_betw_vertices] inj_onD[of f \"\\<Union>X\" x y]\n            vertex_map trivial_outside"], ["proof (prove)\nusing this:\n  f x = f y\n  inj_on f (\\<Union> X)\n  \\<lbrakk>inj_on f (\\<Union> X); f x = f y; x \\<in> \\<Union> X;\n   y \\<in> \\<Union> X\\<rbrakk>\n  \\<Longrightarrow> x = y\n  ?x \\<in> \\<Union> X \\<Longrightarrow> f ?x \\<in> \\<Union> X\n  ?v \\<notin> \\<Union> X \\<Longrightarrow> f ?v = ?v\n\ngoal (1 subgoal):\n 1. x = y", "by    (cases \"x\\<in>\\<Union>X\" \"y\\<in>\\<Union>X\" rule: two_cases) auto"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj f\n\ngoal (1 subgoal):\n 1. surj f", "show \"surj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj f", "unfolding surj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. y = f x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x. y = f x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. \\<exists>x. y = f x", "show \"\\<exists>x. y = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. y = f x", "using bij_betw_imp_surj_on[OF bij_betw_vertices]\n            trivial_outside[THEN sym, of y]"], ["proof (prove)\nusing this:\n  f ` \\<Union> X = \\<Union> X\n  y \\<notin> \\<Union> X \\<Longrightarrow> y = f y\n\ngoal (1 subgoal):\n 1. \\<exists>x. y = f x", "by    (cases \"y\\<in>\\<Union>X\") auto"], ["proof (state)\nthis:\n  \\<exists>x. y = f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  surj f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp:\n  assumes \"ChamberComplexAutomorphism X g\"\n  shows   \"ChamberComplexAutomorphism X (g\\<circ>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexAutomorphism X (g \\<circ> f)", "proof (\n  rule ChamberComplexAutomorphism.intro,\n  rule ChamberComplexIsomorphism.intro,\n  rule ChamberComplexMorphism.comp\n)"], ["proof (state)\ngoal (4 subgoals):\n 1. ChamberComplexMorphism X ?Y6 f\n 2. ChamberComplexMorphism ?Y6 X g\n 3. ChamberComplexIsomorphism_axioms X X (g \\<circ> f)\n 4. ChamberComplexAutomorphism_axioms X (g \\<circ> f)", "from assms"], ["proof (chain)\npicking this:\n  ChamberComplexAutomorphism X g", "show \"ChamberComplexMorphism X X g\""], ["proof (prove)\nusing this:\n  ChamberComplexAutomorphism X g\n\ngoal (1 subgoal):\n 1. ChamberComplexMorphism X X g", "using ChamberComplexAutomorphism.chamber_morphism"], ["proof (prove)\nusing this:\n  ChamberComplexAutomorphism X g\n  ChamberComplexAutomorphism ?X ?f \\<Longrightarrow>\n  ChamberComplexMorphism ?X ?X ?f\n\ngoal (1 subgoal):\n 1. ChamberComplexMorphism X X g", "by fast"], ["proof (state)\nthis:\n  ChamberComplexMorphism X X g\n\ngoal (3 subgoals):\n 1. ChamberComplexMorphism X X f\n 2. ChamberComplexIsomorphism_axioms X X (g \\<circ> f)\n 3. ChamberComplexAutomorphism_axioms X (g \\<circ> f)", "show \"ChamberComplexIsomorphism_axioms X X (g \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexIsomorphism_axioms X X (g \\<circ> f)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. bij_betw (g \\<circ> f) (\\<Union> X) (\\<Union> X)\n 2. (g \\<circ> f) \\<turnstile> X = X", "from assms"], ["proof (chain)\npicking this:\n  ChamberComplexAutomorphism X g", "show \"bij_betw (g\\<circ>f) (\\<Union>X) (\\<Union>X)\""], ["proof (prove)\nusing this:\n  ChamberComplexAutomorphism X g\n\ngoal (1 subgoal):\n 1. bij_betw (g \\<circ> f) (\\<Union> X) (\\<Union> X)", "using bij_betw_vertices ChamberComplexAutomorphism.bij_betw_vertices\n            bij_betw_trans"], ["proof (prove)\nusing this:\n  ChamberComplexAutomorphism X g\n  bij_betw f (\\<Union> X) (\\<Union> X)\n  ChamberComplexAutomorphism ?X ?f \\<Longrightarrow>\n  bij_betw ?f (\\<Union> ?X) (\\<Union> ?X)\n  \\<lbrakk>bij_betw ?f ?A ?B; bij_betw ?g ?B ?C\\<rbrakk>\n  \\<Longrightarrow> bij_betw (?g \\<circ> ?f) ?A ?C\n\ngoal (1 subgoal):\n 1. bij_betw (g \\<circ> f) (\\<Union> X) (\\<Union> X)", "by    fast"], ["proof (state)\nthis:\n  bij_betw (g \\<circ> f) (\\<Union> X) (\\<Union> X)\n\ngoal (1 subgoal):\n 1. (g \\<circ> f) \\<turnstile> X = X", "from assms"], ["proof (chain)\npicking this:\n  ChamberComplexAutomorphism X g", "show \"(g\\<circ>f) \\<turnstile> X = X\""], ["proof (prove)\nusing this:\n  ChamberComplexAutomorphism X g\n\ngoal (1 subgoal):\n 1. (g \\<circ> f) \\<turnstile> X = X", "using surj_simplex_map ChamberComplexAutomorphism.surj_simplex_map"], ["proof (prove)\nusing this:\n  ChamberComplexAutomorphism X g\n  f \\<turnstile> X = X\n  ChamberComplexAutomorphism ?X ?f \\<Longrightarrow> ?f \\<turnstile> ?X = ?X\n\ngoal (1 subgoal):\n 1. (g \\<circ> f) \\<turnstile> X = X", "by    (force simp add: setsetmapim_comp)"], ["proof (state)\nthis:\n  (g \\<circ> f) \\<turnstile> X = X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ChamberComplexIsomorphism_axioms X X (g \\<circ> f)\n\ngoal (2 subgoals):\n 1. ChamberComplexMorphism X X f\n 2. ChamberComplexAutomorphism_axioms X (g \\<circ> f)", "show \"ChamberComplexAutomorphism_axioms X (g \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexAutomorphism_axioms X (g \\<circ> f)", "using trivial_outside ChamberComplexAutomorphism.trivial_outside[OF assms]"], ["proof (prove)\nusing this:\n  ?v \\<notin> \\<Union> X \\<Longrightarrow> f ?v = ?v\n  ?v \\<notin> \\<Union> X \\<Longrightarrow> g ?v = ?v\n\ngoal (1 subgoal):\n 1. ChamberComplexAutomorphism_axioms X (g \\<circ> f)", "by    unfold_locales auto"], ["proof (state)\nthis:\n  ChamberComplexAutomorphism_axioms X (g \\<circ> f)\n\ngoal (1 subgoal):\n 1. ChamberComplexMorphism X X f", "qed unfold_locales"], ["", "lemma equality:\n  assumes \"ChamberComplexAutomorphism X g\" \"fun_eq_on f g (\\<Union>X)\"\n  shows   \"f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "show \"f x = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = g x", "using trivial_outside fun_eq_onD[OF assms(2)] \n          ChamberComplexAutomorphism.trivial_outside[OF assms(1)]"], ["proof (prove)\nusing this:\n  ?v \\<notin> \\<Union> X \\<Longrightarrow> f ?v = ?v\n  ?a \\<in> \\<Union> X \\<Longrightarrow> f ?a = g ?a\n  ?v \\<notin> \\<Union> X \\<Longrightarrow> g ?v = ?v\n\ngoal (1 subgoal):\n 1. f x = g x", "by    force"], ["proof (state)\nthis:\n  f x = g x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ChamberComplexAutomorphism *)"], ["", "subsubsection \\<open>Retractions\\<close>"], ["", "text \\<open>A retraction of a chamber complex is an endomorphism that is the identity on its image.\\<close>"], ["", "locale ChamberComplexRetraction = ChamberComplexEndomorphism X f\n  for X :: \"'a set set\"\n  and f :: \"'a\\<Rightarrow>'a\"\n+ assumes retraction: \"v\\<in>\\<Union>X \\<Longrightarrow> f (f v) = f v\"\nbegin"], ["", "lemmas simplex_map = simplex_map"], ["", "lemmas chamber_map = chamber_map"], ["", "lemmas gallery_map = gallery_map"], ["", "lemma vertex_retraction: \"v\\<in>f`(\\<Union>X) \\<Longrightarrow> f v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> f ` \\<Union> X \\<Longrightarrow> f v = v", "using retraction"], ["proof (prove)\nusing this:\n  ?v \\<in> \\<Union> X \\<Longrightarrow> f (f ?v) = f ?v\n\ngoal (1 subgoal):\n 1. v \\<in> f ` \\<Union> X \\<Longrightarrow> f v = v", "by fast"], ["", "lemma simplex_retraction1: \"x\\<in>f\\<turnstile>X \\<Longrightarrow> fixespointwise f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> f \\<turnstile> X \\<Longrightarrow> fixespointwise f x", "using retraction fixespointwiseI[of x f]"], ["proof (prove)\nusing this:\n  ?v \\<in> \\<Union> X \\<Longrightarrow> f (f ?v) = f ?v\n  (\\<And>a. a \\<in> x \\<Longrightarrow> f a = id a) \\<Longrightarrow>\n  fixespointwise f x\n\ngoal (1 subgoal):\n 1. x \\<in> f \\<turnstile> X \\<Longrightarrow> fixespointwise f x", "by auto"], ["", "lemma simplex_retraction2: \"x\\<in>f\\<turnstile>X \\<Longrightarrow> f`x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> f \\<turnstile> X \\<Longrightarrow> f ` x = x", "using retraction retraction[THEN sym]"], ["proof (prove)\nusing this:\n  ?v \\<in> \\<Union> X \\<Longrightarrow> f (f ?v) = f ?v\n  ?v1 \\<in> \\<Union> X \\<Longrightarrow> f ?v1 = f (f ?v1)\n\ngoal (1 subgoal):\n 1. x \\<in> f \\<turnstile> X \\<Longrightarrow> f ` x = x", "by blast"], ["", "lemma chamber_retraction1: \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> fixespointwise f C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow> fixespointwise f C", "using chamber_system_simplices simplex_retraction1"], ["proof (prove)\nusing this:\n  order.greater_eq X \\<C>\n  ?x \\<in> f \\<turnstile> X \\<Longrightarrow> fixespointwise f ?x\n\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow> fixespointwise f C", "by auto"], ["", "lemma chamber_retraction2: \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> f`C = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow> f ` C = C", "using chamber_system_simplices simplex_retraction2[of C]"], ["proof (prove)\nusing this:\n  order.greater_eq X \\<C>\n  C \\<in> f \\<turnstile> X \\<Longrightarrow> f ` C = C\n\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow> f ` C = C", "by auto"], ["", "lemma respects_labels:\n  assumes \"label_wrt B \\<phi>\" \"v\\<in>(\\<Union>X)\"\n  shows   \"\\<phi> (f v) = \\<phi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (f v) = \\<phi> v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> (f v) = \\<phi> v", "from assms(2)"], ["proof (chain)\npicking this:\n  v \\<in> \\<Union> X", "obtain C where \"chamber C\" \"v\\<in>C\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>chamber C; v \\<in> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using simplex_in_max"], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> X\n  ?y \\<in> X \\<Longrightarrow>\n  \\<exists>x. chamber x \\<and> order.greater_eq x ?y\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>chamber C; v \\<in> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  chamber C\n  v \\<in> C\n\ngoal (1 subgoal):\n 1. \\<phi> (f v) = \\<phi> v", "thus ?thesis"], ["proof (prove)\nusing this:\n  chamber C\n  v \\<in> C\n\ngoal (1 subgoal):\n 1. \\<phi> (f v) = \\<phi> v", "using chamber_retraction1[of C] chamber_system_def chamber_map\n          maxsimp_connect[of \"f`C\" C] chamber_retraction1[of \"f`C\"]\n          respects_labels_gallery[OF assms(1), THEN bspec, of \"f`C\" _ C v]"], ["proof (prove)\nusing this:\n  chamber C\n  v \\<in> C\n  C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow> fixespointwise f C\n  \\<C> \\<equiv> Collect chamber\n  chamber ?C \\<Longrightarrow> chamber (f ` ?C)\n  \\<lbrakk>f ` C \\<noteq> C; chamber (f ` C); chamber C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs. gallery (f ` C # xs @ [C])\n  f ` C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow> fixespointwise f (f ` C)\n  \\<lbrakk>\\<forall>x\\<in>f ` C. \\<phi> (f x) = \\<phi> x;\n   gallery (f ` C # ?Cs1 @ [C]); v \\<in> C\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (f v) = \\<phi> v\n\ngoal (1 subgoal):\n 1. \\<phi> (f v) = \\<phi> v", "by    (force simp add: fixespointwiseD)"], ["proof (state)\nthis:\n  \\<phi> (f v) = \\<phi> v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ChamberComplexRetraction *)"], ["", "subsubsection \\<open>Foldings of chamber complexes\\<close>"], ["", "text \\<open>\n  A folding of a chamber complex is a retraction that literally folds the complex in half, in that\n  each chamber in the image is the image of precisely two chambers: itself (since a folding is a\n  retraction) and a unique chamber outside the image.\n\\<close>"], ["", "paragraph \\<open>Locale definition\\<close>"], ["", "text \\<open>\n  Here we define the locale and collect some lemmas inherited from the\n  @{const ChamberComplexRetraction} locale.\n\\<close>"], ["", "locale ChamberComplexFolding = ChamberComplexRetraction X f\n  for X :: \"'a set set\"\n  and f :: \"'a\\<Rightarrow>'a\"\n+ assumes folding:\n    \"chamber C \\<Longrightarrow> C\\<in>f\\<turnstile>X \\<Longrightarrow>\n      \\<exists>!D. chamber D \\<and> D\\<notin>f\\<turnstile>X \\<and> f`D = C\"\nbegin"], ["", "lemmas folding_ex          = ex1_implies_ex[OF folding]"], ["", "lemmas chamber_system_into = chamber_system_into"], ["", "lemmas gallery_map         = gallery_map"], ["", "lemmas chamber_retraction1 = chamber_retraction1"], ["", "lemmas chamber_retraction2 = chamber_retraction2"], ["", "end"], ["", "(* context ChamberComplexFolding *)"], ["", "paragraph \\<open>Decomposition into half chamber systems and half apartments\\<close>"], ["", "text \\<open>\n  Here we describe how a folding splits the chamber system of the complex into its image and the\n  complement of its image. The chamber subcomplex consisting of all simplices contained in a\n  chamber of a given half of the chamber system is called a half-apartment.\n\\<close>"], ["", "context ChamberComplexFolding\nbegin"], ["", "definition opp_half_apartment :: \"'a set set\"\n  where \"opp_half_apartment \\<equiv> {x\\<in>X. \\<exists>C\\<in>\\<C>-f\\<turnstile>\\<C>. x\\<subseteq>C}\""], ["", "abbreviation \"Y \\<equiv> opp_half_apartment\""], ["", "lemma opp_half_apartment_subset_complex: \"Y\\<subseteq>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq X Y", "using opp_half_apartment_def"], ["proof (prove)\nusing this:\n  Y \\<equiv>\n  {x \\<in> X.\n   \\<exists>C\\<in>\\<C> - f \\<turnstile> \\<C>. order.greater_eq C x}\n\ngoal (1 subgoal):\n 1. order.greater_eq X Y", "by fast"], ["", "lemma simplicialcomplex_opp_half_apartment: \"SimplicialComplex Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplex Y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>Y. finite x\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> Y; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> Y", "show \"\\<forall>x\\<in>Y. finite x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Y. finite x", "using opp_half_apartment_subset_complex finite_simplices"], ["proof (prove)\nusing this:\n  order.greater_eq X Y\n  \\<forall>x\\<in>X. finite x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Y. finite x", "by fast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>Y. finite x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Y; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> Y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Y; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> Y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Y; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> Y", "assume \"x\\<in>Y\" \"y\\<subseteq>x\""], ["proof (state)\nthis:\n  x \\<in> Y\n  order.greater_eq x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Y; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> Y", "thus \"y\\<in>Y\""], ["proof (prove)\nusing this:\n  x \\<in> Y\n  order.greater_eq x y\n\ngoal (1 subgoal):\n 1. y \\<in> Y", "using     opp_half_apartment_subset_complex faces[of x y]"], ["proof (prove)\nusing this:\n  x \\<in> Y\n  order.greater_eq x y\n  order.greater_eq X Y\n  \\<lbrakk>x \\<in> X; order.greater_eq x y\\<rbrakk>\n  \\<Longrightarrow> y \\<in> X\n\ngoal (1 subgoal):\n 1. y \\<in> Y", "unfolding opp_half_apartment_def"], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> X.\n           \\<exists>C\\<in>\\<C> - f \\<turnstile> \\<C>. order.greater_eq C x}\n  order.greater_eq x y\n  order.greater_eq X\n   {x \\<in> X.\n    \\<exists>C\\<in>\\<C> - f \\<turnstile> \\<C>. order.greater_eq C x}\n  \\<lbrakk>x \\<in> X; order.greater_eq x y\\<rbrakk>\n  \\<Longrightarrow> y \\<in> X\n\ngoal (1 subgoal):\n 1. y \\<in> {x \\<in> X.\n             \\<exists>C\\<in>\\<C> - f \\<turnstile> \\<C>.\n                order.greater_eq C x}", "by        auto"], ["proof (state)\nthis:\n  y \\<in> Y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subcomplex_opp_half_apartment: \"Subcomplex Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq X Y \\<and> SimplicialComplex Y", "using opp_half_apartment_subset_complex simplicialcomplex_opp_half_apartment"], ["proof (prove)\nusing this:\n  order.greater_eq X Y\n  SimplicialComplex Y\n\ngoal (1 subgoal):\n 1. order.greater_eq X Y \\<and> SimplicialComplex Y", "by    fast"], ["", "lemma opp_half_apartmentI: \"\\<lbrakk> x\\<in>X; C\\<in>\\<C>-f\\<turnstile>\\<C>; x\\<subseteq>C \\<rbrakk> \\<Longrightarrow> x\\<in>Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X; C \\<in> \\<C> - f \\<turnstile> \\<C>;\n     order.greater_eq C x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> Y", "using opp_half_apartment_def"], ["proof (prove)\nusing this:\n  Y \\<equiv>\n  {x \\<in> X.\n   \\<exists>C\\<in>\\<C> - f \\<turnstile> \\<C>. order.greater_eq C x}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X; C \\<in> \\<C> - f \\<turnstile> \\<C>;\n     order.greater_eq C x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> Y", "by auto"], ["", "lemma opp_chambers_subset_opp_half_apartment: \"\\<C>-f\\<turnstile>\\<C> \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq Y (\\<C> - f \\<turnstile> \\<C>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<C> - f \\<turnstile> \\<C> \\<Longrightarrow> x \\<in> Y", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<C> - f \\<turnstile> \\<C> \\<Longrightarrow> x \\<in> Y", "assume \"C \\<in> \\<C>-f\\<turnstile>\\<C>\""], ["proof (state)\nthis:\n  C \\<in> \\<C> - f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<C> - f \\<turnstile> \\<C> \\<Longrightarrow> x \\<in> Y", "thus \"C \\<in> Y\""], ["proof (prove)\nusing this:\n  C \\<in> \\<C> - f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<in> Y", "using chamber_system_simplices opp_half_apartmentI"], ["proof (prove)\nusing this:\n  C \\<in> \\<C> - f \\<turnstile> \\<C>\n  order.greater_eq X \\<C>\n  \\<lbrakk>?x \\<in> X; ?C \\<in> \\<C> - f \\<turnstile> \\<C>;\n   order.greater_eq ?C ?x\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> Y\n\ngoal (1 subgoal):\n 1. C \\<in> Y", "by auto"], ["proof (state)\nthis:\n  C \\<in> Y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maxsimp_in_opp_half_apartment:\n  assumes \"SimplicialComplex.maxsimp Y C\"\n  shows   \"C \\<in> \\<C>-f\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> \\<C> - f \\<turnstile> \\<C>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<in> \\<C> - f \\<turnstile> \\<C>", "from assms"], ["proof (chain)\npicking this:\n  SimplicialComplex.maxsimp Y C", "obtain D where D: \"D\\<in>\\<C>-f\\<turnstile>\\<C>\" \"C\\<subseteq>D\""], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp Y C\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> \\<C> - f \\<turnstile> \\<C>;\n         order.greater_eq D C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using SimplicialComplex.maxsimpD_simplex[\n            OF simplicialcomplex_opp_half_apartment, of C\n          ]\n          opp_half_apartment_def"], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp Y C\n  SimplicialComplex.maxsimp Y C \\<Longrightarrow> C \\<in> Y\n  Y \\<equiv>\n  {x \\<in> X.\n   \\<exists>C\\<in>\\<C> - f \\<turnstile> \\<C>. order.greater_eq C x}\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> \\<C> - f \\<turnstile> \\<C>;\n         order.greater_eq D C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  D \\<in> \\<C> - f \\<turnstile> \\<C>\n  order.greater_eq D C\n\ngoal (1 subgoal):\n 1. C \\<in> \\<C> - f \\<turnstile> \\<C>", "with assms"], ["proof (chain)\npicking this:\n  SimplicialComplex.maxsimp Y C\n  D \\<in> \\<C> - f \\<turnstile> \\<C>\n  order.greater_eq D C", "show ?thesis"], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp Y C\n  D \\<in> \\<C> - f \\<turnstile> \\<C>\n  order.greater_eq D C\n\ngoal (1 subgoal):\n 1. C \\<in> \\<C> - f \\<turnstile> \\<C>", "using opp_chambers_subset_opp_half_apartment \n          SimplicialComplex.maxsimpD_maximal[\n            OF simplicialcomplex_opp_half_apartment\n          ]"], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp Y C\n  D \\<in> \\<C> - f \\<turnstile> \\<C>\n  order.greater_eq D C\n  order.greater_eq Y (\\<C> - f \\<turnstile> \\<C>)\n  \\<lbrakk>SimplicialComplex.maxsimp Y ?x; ?z \\<in> Y;\n   order.greater_eq ?z ?x\\<rbrakk>\n  \\<Longrightarrow> ?z = ?x\n\ngoal (1 subgoal):\n 1. C \\<in> \\<C> - f \\<turnstile> \\<C>", "by    force"], ["proof (state)\nthis:\n  C \\<in> \\<C> - f \\<turnstile> \\<C>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chamber_in_opp_half_apartment:\n  \"SimplicialComplex.maxsimp Y C \\<Longrightarrow> chamber C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp Y C \\<Longrightarrow> chamber C", "using maxsimp_in_opp_half_apartment chamber_system_def"], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp Y ?C \\<Longrightarrow>\n  ?C \\<in> \\<C> - f \\<turnstile> \\<C>\n  \\<C> \\<equiv> Collect chamber\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp Y C \\<Longrightarrow> chamber C", "by fast"], ["", "end"], ["", "(* context ChamberComplexFolding *)"], ["", "paragraph \\<open>Mapping between half chamber systems for foldings\\<close>"], ["", "text \\<open>\n  Since each chamber in the image of the folding is the image of a unique chamber in the complement\n  of the image, we obtain well-defined functions from one half chamber system to the other.\n\\<close>"], ["", "context ChamberComplexFolding\nbegin"], ["", "abbreviation \"opp_chamber C \\<equiv> THE D. D\\<in>\\<C>-f\\<turnstile>\\<C> \\<and> f`D = C\""], ["", "abbreviation \"flop C \\<equiv> if C \\<in> f\\<turnstile>\\<C> then opp_chamber C else f`C\""], ["", "lemma inj_on_opp_chambers':\n  assumes \"chamber C\" \"C\\<notin>f\\<turnstile>X\" \"chamber D\" \"D\\<notin>f\\<turnstile>X\" \"f`C = f`D\"\n  shows   \"C=D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C = D", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. C = D", "from assms(1) folding"], ["proof (chain)\npicking this:\n  chamber C\n  \\<lbrakk>chamber ?C; ?C \\<in> f \\<turnstile> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!D.\n                       chamber D \\<and>\n                       D \\<notin> f \\<turnstile> X \\<and> f ` D = ?C", "have ex1: \"\\<exists>!B. chamber B \\<and> B\\<notin>f\\<turnstile>X \\<and> f`B = f`C\""], ["proof (prove)\nusing this:\n  chamber C\n  \\<lbrakk>chamber ?C; ?C \\<in> f \\<turnstile> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!D.\n                       chamber D \\<and>\n                       D \\<notin> f \\<turnstile> X \\<and> f ` D = ?C\n\ngoal (1 subgoal):\n 1. \\<exists>!B.\n       chamber B \\<and> B \\<notin> f \\<turnstile> X \\<and> f ` B = f ` C", "using chamberD_simplex chamber_map"], ["proof (prove)\nusing this:\n  chamber C\n  \\<lbrakk>chamber ?C; ?C \\<in> f \\<turnstile> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!D.\n                       chamber D \\<and>\n                       D \\<notin> f \\<turnstile> X \\<and> f ` D = ?C\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n  chamber ?C \\<Longrightarrow> chamber (f ` ?C)\n\ngoal (1 subgoal):\n 1. \\<exists>!B.\n       chamber B \\<and> B \\<notin> f \\<turnstile> X \\<and> f ` B = f ` C", "by auto"], ["proof (state)\nthis:\n  \\<exists>!B.\n     chamber B \\<and> B \\<notin> f \\<turnstile> X \\<and> f ` B = f ` C\n\ngoal (1 subgoal):\n 1. C = D", "from assms"], ["proof (chain)\npicking this:\n  chamber C\n  C \\<notin> f \\<turnstile> X\n  chamber D\n  D \\<notin> f \\<turnstile> X\n  f ` C = f ` D", "show ?thesis"], ["proof (prove)\nusing this:\n  chamber C\n  C \\<notin> f \\<turnstile> X\n  chamber D\n  D \\<notin> f \\<turnstile> X\n  f ` C = f ` D\n\ngoal (1 subgoal):\n 1. C = D", "using ex1_unique[OF ex1, of C D]"], ["proof (prove)\nusing this:\n  chamber C\n  C \\<notin> f \\<turnstile> X\n  chamber D\n  D \\<notin> f \\<turnstile> X\n  f ` C = f ` D\n  \\<lbrakk>chamber C \\<and>\n           C \\<notin> f \\<turnstile> X \\<and> f ` C = f ` C;\n   chamber D \\<and>\n   D \\<notin> f \\<turnstile> X \\<and> f ` D = f ` C\\<rbrakk>\n  \\<Longrightarrow> C = D\n\ngoal (1 subgoal):\n 1. C = D", "by blast"], ["proof (state)\nthis:\n  C = D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_on_opp_chambers'':\n  \"\\<lbrakk> C \\<in> \\<C>-f\\<turnstile>\\<C>; D \\<in> \\<C>-f\\<turnstile>\\<C>; f`C = f`D \\<rbrakk> \\<Longrightarrow> C=D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> \\<C> - f \\<turnstile> \\<C>;\n     D \\<in> \\<C> - f \\<turnstile> \\<C>; f ` C = f ` D\\<rbrakk>\n    \\<Longrightarrow> C = D", "using chamber_system_def chamber_system_image inj_on_opp_chambers'"], ["proof (prove)\nusing this:\n  \\<C> \\<equiv> Collect chamber\n  f \\<turnstile> \\<C> = \\<C> \\<inter> (f \\<turnstile> X)\n  \\<lbrakk>chamber ?C; ?C \\<notin> f \\<turnstile> X; chamber ?D;\n   ?D \\<notin> f \\<turnstile> X; f ` ?C = f ` ?D\\<rbrakk>\n  \\<Longrightarrow> ?C = ?D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> \\<C> - f \\<turnstile> \\<C>;\n     D \\<in> \\<C> - f \\<turnstile> \\<C>; f ` C = f ` D\\<rbrakk>\n    \\<Longrightarrow> C = D", "by auto"], ["", "lemma inj_on_opp_chambers: \"inj_on ((`) f) (\\<C>-f\\<turnstile>\\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((`) f) (\\<C> - f \\<turnstile> \\<C>)", "using inj_on_opp_chambers'' inj_onI[of \"\\<C>-f\\<turnstile>\\<C>\" \"(`) f\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?C \\<in> \\<C> - f \\<turnstile> \\<C>;\n   ?D \\<in> \\<C> - f \\<turnstile> \\<C>; f ` ?C = f ` ?D\\<rbrakk>\n  \\<Longrightarrow> ?C = ?D\n  (\\<And>x y.\n      \\<lbrakk>x \\<in> \\<C> - f \\<turnstile> \\<C>;\n       y \\<in> \\<C> - f \\<turnstile> \\<C>; f ` x = f ` y\\<rbrakk>\n      \\<Longrightarrow> x = y) \\<Longrightarrow>\n  inj_on ((`) f) (\\<C> - f \\<turnstile> \\<C>)\n\ngoal (1 subgoal):\n 1. inj_on ((`) f) (\\<C> - f \\<turnstile> \\<C>)", "by fast"], ["", "lemma opp_chambers_surj: \"f\\<turnstile>(\\<C>-(f\\<turnstile>\\<C>)) = f\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<turnstile> (\\<C> - f \\<turnstile> \\<C>) = f \\<turnstile> \\<C>", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f \\<turnstile> (\\<C> - f \\<turnstile> \\<C>) \\<Longrightarrow>\n       x \\<in> f \\<turnstile> \\<C>\n 2. \\<And>x.\n       x \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n       x \\<in> f \\<turnstile> (\\<C> - f \\<turnstile> \\<C>)", "fix D"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f \\<turnstile> (\\<C> - f \\<turnstile> \\<C>) \\<Longrightarrow>\n       x \\<in> f \\<turnstile> \\<C>\n 2. \\<And>x.\n       x \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n       x \\<in> f \\<turnstile> (\\<C> - f \\<turnstile> \\<C>)", "assume D: \"D \\<in> f\\<turnstile>\\<C>\""], ["proof (state)\nthis:\n  D \\<in> f \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f \\<turnstile> (\\<C> - f \\<turnstile> \\<C>) \\<Longrightarrow>\n       x \\<in> f \\<turnstile> \\<C>\n 2. \\<And>x.\n       x \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n       x \\<in> f \\<turnstile> (\\<C> - f \\<turnstile> \\<C>)", "from this"], ["proof (chain)\npicking this:\n  D \\<in> f \\<turnstile> \\<C>", "obtain B where \"chamber B\" \"B\\<notin>f\\<turnstile>X\" \"f`B = D\""], ["proof (prove)\nusing this:\n  D \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>chamber B; B \\<notin> f \\<turnstile> X; f ` B = D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using chamber_system_def chamber_map chamberD_simplex folding_ex[of D]"], ["proof (prove)\nusing this:\n  D \\<in> f \\<turnstile> \\<C>\n  \\<C> \\<equiv> Collect chamber\n  chamber ?C \\<Longrightarrow> chamber (f ` ?C)\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>chamber D; D \\<in> f \\<turnstile> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x.\n                       chamber x \\<and>\n                       x \\<notin> f \\<turnstile> X \\<and> f ` x = D\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>chamber B; B \\<notin> f \\<turnstile> X; f ` B = D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  chamber B\n  B \\<notin> f \\<turnstile> X\n  f ` B = D\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f \\<turnstile> (\\<C> - f \\<turnstile> \\<C>) \\<Longrightarrow>\n       x \\<in> f \\<turnstile> \\<C>\n 2. \\<And>x.\n       x \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n       x \\<in> f \\<turnstile> (\\<C> - f \\<turnstile> \\<C>)", "thus \"D \\<in> f\\<turnstile>(\\<C> - f\\<turnstile>\\<C>)\""], ["proof (prove)\nusing this:\n  chamber B\n  B \\<notin> f \\<turnstile> X\n  f ` B = D\n\ngoal (1 subgoal):\n 1. D \\<in> f \\<turnstile> (\\<C> - f \\<turnstile> \\<C>)", "using chamber_system_image chamber_system_def"], ["proof (prove)\nusing this:\n  chamber B\n  B \\<notin> f \\<turnstile> X\n  f ` B = D\n  f \\<turnstile> \\<C> = \\<C> \\<inter> (f \\<turnstile> X)\n  \\<C> \\<equiv> Collect chamber\n\ngoal (1 subgoal):\n 1. D \\<in> f \\<turnstile> (\\<C> - f \\<turnstile> \\<C>)", "by auto"], ["proof (state)\nthis:\n  D \\<in> f \\<turnstile> (\\<C> - f \\<turnstile> \\<C>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f \\<turnstile> (\\<C> - f \\<turnstile> \\<C>) \\<Longrightarrow>\n       x \\<in> f \\<turnstile> \\<C>", "qed fast"], ["", "lemma opp_chambers_bij: \"bij_betw ((`) f) (\\<C>-(f\\<turnstile>\\<C>)) (f\\<turnstile>\\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw ((`) f) (\\<C> - f \\<turnstile> \\<C>) (f \\<turnstile> \\<C>)", "using inj_on_opp_chambers opp_chambers_surj bij_betw_def[of \"(`) f\"]"], ["proof (prove)\nusing this:\n  inj_on ((`) f) (\\<C> - f \\<turnstile> \\<C>)\n  f \\<turnstile> (\\<C> - f \\<turnstile> \\<C>) = f \\<turnstile> \\<C>\n  bij_betw ((`) f) ?A ?B = (inj_on ((`) f) ?A \\<and> f \\<turnstile> ?A = ?B)\n\ngoal (1 subgoal):\n 1. bij_betw ((`) f) (\\<C> - f \\<turnstile> \\<C>) (f \\<turnstile> \\<C>)", "by auto"], ["", "lemma folding':\n  assumes \"C\\<in>f\\<turnstile>\\<C>\"\n  shows   \"\\<exists>!D\\<in>\\<C>-f\\<turnstile>\\<C>. f`D = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C", "proof (rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C\n 2. \\<And>D y.\n       \\<lbrakk>D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C;\n        y \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` y = C\\<rbrakk>\n       \\<Longrightarrow> D = y", "from assms"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> \\<C>", "show \"\\<exists>D. D \\<in> \\<C>-f\\<turnstile>\\<C> \\<and> f`D = C\""], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C", "using chamber_system_image chamber_system_def folding_ex[of C]"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> \\<C>\n  f \\<turnstile> \\<C> = \\<C> \\<inter> (f \\<turnstile> X)\n  \\<C> \\<equiv> Collect chamber\n  \\<lbrakk>chamber C; C \\<in> f \\<turnstile> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x.\n                       chamber x \\<and>\n                       x \\<notin> f \\<turnstile> X \\<and> f ` x = C\n\ngoal (1 subgoal):\n 1. \\<exists>D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C", "by auto"], ["proof (state)\nthis:\n  \\<exists>D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C\n\ngoal (1 subgoal):\n 1. \\<And>D y.\n       \\<lbrakk>D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C;\n        y \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` y = C\\<rbrakk>\n       \\<Longrightarrow> D = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D y.\n       \\<lbrakk>D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C;\n        y \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` y = C\\<rbrakk>\n       \\<Longrightarrow> D = y", "fix B D"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D y.\n       \\<lbrakk>D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C;\n        y \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` y = C\\<rbrakk>\n       \\<Longrightarrow> D = y", "assume \"B \\<in> \\<C>-f\\<turnstile>\\<C> \\<and> f`B = C\" \"D \\<in> \\<C>-f\\<turnstile>\\<C> \\<and> f`D = C\""], ["proof (state)\nthis:\n  B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` B = C\n  D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C\n\ngoal (1 subgoal):\n 1. \\<And>D y.\n       \\<lbrakk>D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C;\n        y \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` y = C\\<rbrakk>\n       \\<Longrightarrow> D = y", "with assms"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> \\<C>\n  B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` B = C\n  D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C", "show \"B=D\""], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> \\<C>\n  B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` B = C\n  D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C\n\ngoal (1 subgoal):\n 1. B = D", "using chamber_system_def chamber_system_image chamber_map\n          chamberD_simplex ex1_unique[OF folding, of C B D]"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> \\<C>\n  B \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` B = C\n  D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C\n  \\<C> \\<equiv> Collect chamber\n  f \\<turnstile> \\<C> = \\<C> \\<inter> (f \\<turnstile> X)\n  chamber ?C \\<Longrightarrow> chamber (f ` ?C)\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>chamber C; C \\<in> f \\<turnstile> X;\n   chamber B \\<and> B \\<notin> f \\<turnstile> X \\<and> f ` B = C;\n   chamber D \\<and> D \\<notin> f \\<turnstile> X \\<and> f ` D = C\\<rbrakk>\n  \\<Longrightarrow> B = D\n\ngoal (1 subgoal):\n 1. B = D", "by    auto"], ["proof (state)\nthis:\n  B = D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma opp_chambers_distinct_map:\n  \"set Cs \\<subseteq> \\<C>-f\\<turnstile>\\<C> \\<Longrightarrow> distinct Cs \\<Longrightarrow> distinct (f\\<Turnstile>Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq (\\<C> - f \\<turnstile> \\<C>) (set Cs);\n     distinct Cs\\<rbrakk>\n    \\<Longrightarrow> distinct (f \\<Turnstile> Cs)", "using distinct_map subset_inj_on[OF inj_on_opp_chambers]"], ["proof (prove)\nusing this:\n  distinct (map ?f ?xs) = (distinct ?xs \\<and> inj_on ?f (set ?xs))\n  order.greater_eq (\\<C> - f \\<turnstile> \\<C>) ?A \\<Longrightarrow>\n  inj_on ((`) f) ?A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq (\\<C> - f \\<turnstile> \\<C>) (set Cs);\n     distinct Cs\\<rbrakk>\n    \\<Longrightarrow> distinct (f \\<Turnstile> Cs)", "by auto"], ["", "lemma opp_chamberD1: \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> opp_chamber C \\<in> \\<C>-f\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    (THE D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C)\n    \\<in> \\<C> - f \\<turnstile> \\<C>", "using theI'[OF folding']"], ["proof (prove)\nusing this:\n  ?C1 \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n  (THE x. x \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` x = ?C1)\n  \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n  f ` (THE x. x \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` x = ?C1) = ?C1\n\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    (THE D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C)\n    \\<in> \\<C> - f \\<turnstile> \\<C>", "by simp"], ["", "lemma opp_chamberD2: \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> f`(opp_chamber C) = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    f ` (THE D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C) = C", "using theI'[OF folding']"], ["proof (prove)\nusing this:\n  ?C1 \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n  (THE x. x \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` x = ?C1)\n  \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n  f ` (THE x. x \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` x = ?C1) = ?C1\n\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    f ` (THE D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C) = C", "by simp"], ["", "lemma opp_chamber_reverse: \"C\\<in>\\<C>-f\\<turnstile>\\<C> \\<Longrightarrow> opp_chamber (f`C) = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> \\<C> - f \\<turnstile> \\<C> \\<Longrightarrow>\n    (THE D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = f ` C) = C", "using the1_equality[OF folding']"], ["proof (prove)\nusing this:\n  \\<lbrakk>?C1 \\<in> f \\<turnstile> \\<C>;\n   ?a \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` ?a = ?C1\\<rbrakk>\n  \\<Longrightarrow> (THE x.\n                        x \\<in> \\<C> - f \\<turnstile> \\<C> \\<and>\n                        f ` x = ?C1) =\n                    ?a\n\ngoal (1 subgoal):\n 1. C \\<in> \\<C> - f \\<turnstile> \\<C> \\<Longrightarrow>\n    (THE D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = f ` C) = C", "by simp"], ["", "lemma f_opp_chamber_list:\n  \"set Cs \\<subseteq> f\\<turnstile>\\<C> \\<Longrightarrow> f\\<Turnstile>(map opp_chamber Cs) = Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (f \\<turnstile> \\<C>) (set Cs) \\<Longrightarrow>\n    f \\<Turnstile>\n    map (\\<lambda>C.\n            THE D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C)\n     Cs =\n    Cs", "using opp_chamberD2"], ["proof (prove)\nusing this:\n  ?C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n  f ` (THE D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = ?C) = ?C\n\ngoal (1 subgoal):\n 1. order.greater_eq (f \\<turnstile> \\<C>) (set Cs) \\<Longrightarrow>\n    f \\<Turnstile>\n    map (\\<lambda>C.\n            THE D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C)\n     Cs =\n    Cs", "by (induct Cs) auto"], ["", "lemma flop_chamber: \"chamber C \\<Longrightarrow> chamber (flop C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chamber C \\<Longrightarrow>\n    chamber\n     (if C \\<in> f \\<turnstile> \\<C>\n      then THE D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C\n      else f ` C)", "using chamber_map opp_chamberD1 chamber_system_def"], ["proof (prove)\nusing this:\n  chamber ?C \\<Longrightarrow> chamber (f ` ?C)\n  ?C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n  (THE D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = ?C)\n  \\<in> \\<C> - f \\<turnstile> \\<C>\n  \\<C> \\<equiv> Collect chamber\n\ngoal (1 subgoal):\n 1. chamber C \\<Longrightarrow>\n    chamber\n     (if C \\<in> f \\<turnstile> \\<C>\n      then THE D. D \\<in> \\<C> - f \\<turnstile> \\<C> \\<and> f ` D = C\n      else f ` C)", "by auto"], ["", "end"], ["", "(* context ChamberComplexFolding *)"], ["", "subsection \\<open>Thin chamber complexes\\<close>"], ["", "text \\<open>\n  A thin chamber complex is one in which every facet is a facet in exactly two chambers. Slightly\n  more generally, we first consider the case of a chamber complex in which every facet is a facet\n  of at most two chambers. One of the main results obtained at this point is the so-called standard\n  uniqueness argument, which essentially states that two morphisms on a thin chamber complex that\n  agree on a particular chamber must in fact agree on the entire complex. Following that, foldings\n  of thin chamber complexes are investigated. In particular, we are interested in pairs of opposed\n  foldings.\n\\<close>"], ["", "subsubsection \\<open>Locales and basic facts\\<close>"], ["", "locale ThinishChamberComplex = ChamberComplex X\n  for X :: \"'a set set\"\n+ assumes thinish:\n  \"\\<lbrakk> chamber C; z\\<lhd>C; \\<exists>D\\<in>X-{C}. z\\<lhd>D \\<rbrakk> \\<Longrightarrow> \\<exists>!D\\<in>X-{C}. z\\<lhd>D\"\n  \\<comment> \\<open>being adjacent to a chamber, such a @{term D} would also be a chamber (see lemma\n@{text \"chamber_adj\"})\\<close>\nbegin"], ["", "lemma facet_unique_other_chamber:\n  \"\\<lbrakk> chamber B; z\\<lhd>B; chamber C; z\\<lhd>C; chamber D; z\\<lhd>D; C\\<noteq>B; D\\<noteq>B \\<rbrakk>\n    \\<Longrightarrow> C=D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber B; z \\<lhd> B; chamber C; z \\<lhd> C; chamber D;\n     z \\<lhd> D; C \\<noteq> B; D \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> C = D", "using chamberD_simplex bex1_equality[OF thinish, OF _ _ bexI, of B z C C D]"], ["proof (prove)\nusing this:\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>chamber B; z \\<lhd> B; z \\<lhd> C; C \\<in> X - {B};\n   C \\<in> X - {B}; z \\<lhd> C; D \\<in> X - {B}; z \\<lhd> D\\<rbrakk>\n  \\<Longrightarrow> C = D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber B; z \\<lhd> B; chamber C; z \\<lhd> C; chamber D;\n     z \\<lhd> D; C \\<noteq> B; D \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> C = D", "by    auto"], ["", "lemma finite_adjacentset:\n  assumes \"chamber C\"\n  shows   \"finite (adjacentset C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (adjacentset C)", "proof (cases \"X = {{}}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. X = {{}} \\<Longrightarrow> finite (adjacentset C)\n 2. X \\<noteq> {{}} \\<Longrightarrow> finite (adjacentset C)", "case True"], ["proof (state)\nthis:\n  X = {{}}\n\ngoal (2 subgoals):\n 1. X = {{}} \\<Longrightarrow> finite (adjacentset C)\n 2. X \\<noteq> {{}} \\<Longrightarrow> finite (adjacentset C)", "thus ?thesis"], ["proof (prove)\nusing this:\n  X = {{}}\n\ngoal (1 subgoal):\n 1. finite (adjacentset C)", "using adjacentset_def"], ["proof (prove)\nusing this:\n  X = {{}}\n  adjacentset ?x = {y \\<in> X. ?x \\<sim> y}\n\ngoal (1 subgoal):\n 1. finite (adjacentset C)", "by simp"], ["proof (state)\nthis:\n  finite (adjacentset C)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {{}} \\<Longrightarrow> finite (adjacentset C)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<noteq> {{}} \\<Longrightarrow> finite (adjacentset C)", "case False"], ["proof (state)\nthis:\n  X \\<noteq> {{}}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {{}} \\<Longrightarrow> finite (adjacentset C)", "moreover"], ["proof (state)\nthis:\n  X \\<noteq> {{}}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {{}} \\<Longrightarrow> finite (adjacentset C)", "have \"finite (\\<Union>v\\<in>C. {D\\<in>X. C-{v}\\<lhd>D})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite C\n 2. \\<And>v.\n       v \\<in> C \\<Longrightarrow> finite {D \\<in> X. C - {v} \\<lhd> D}", "from assms"], ["proof (chain)\npicking this:\n  chamber C", "show \"finite C\""], ["proof (prove)\nusing this:\n  chamber C\n\ngoal (1 subgoal):\n 1. finite C", "using finite_chamber"], ["proof (prove)\nusing this:\n  chamber C\n  chamber ?x \\<Longrightarrow> finite ?x\n\ngoal (1 subgoal):\n 1. finite C", "by simp"], ["proof (state)\nthis:\n  finite C\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> C \\<Longrightarrow> finite {D \\<in> X. C - {v} \\<lhd> D}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> C \\<Longrightarrow> finite {D \\<in> X. C - {v} \\<lhd> D}", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> C \\<Longrightarrow> finite {D \\<in> X. C - {v} \\<lhd> D}", "assume \"v\\<in>C\""], ["proof (state)\nthis:\n  v \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> C \\<Longrightarrow> finite {D \\<in> X. C - {v} \\<lhd> D}", "with assms"], ["proof (chain)\npicking this:\n  chamber C\n  v \\<in> C", "have Cv: \"C-{v}\\<lhd>C\""], ["proof (prove)\nusing this:\n  chamber C\n  v \\<in> C\n\ngoal (1 subgoal):\n 1. C - {v} \\<lhd> C", "using chamberD_simplex facetrel_diff_vertex"], ["proof (prove)\nusing this:\n  chamber C\n  v \\<in> C\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n  ?v \\<in> ?x \\<Longrightarrow> ?x - {?v} \\<lhd> ?x\n\ngoal (1 subgoal):\n 1. C - {v} \\<lhd> C", "by fast"], ["proof (state)\nthis:\n  C - {v} \\<lhd> C\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> C \\<Longrightarrow> finite {D \\<in> X. C - {v} \\<lhd> D}", "with assms"], ["proof (chain)\npicking this:\n  chamber C\n  C - {v} \\<lhd> C", "have C: \"C\\<in>{D\\<in>X. C-{v}\\<lhd>D}\""], ["proof (prove)\nusing this:\n  chamber C\n  C - {v} \\<lhd> C\n\ngoal (1 subgoal):\n 1. C \\<in> {D \\<in> X. C - {v} \\<lhd> D}", "using chamberD_simplex"], ["proof (prove)\nusing this:\n  chamber C\n  C - {v} \\<lhd> C\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n\ngoal (1 subgoal):\n 1. C \\<in> {D \\<in> X. C - {v} \\<lhd> D}", "by fast"], ["proof (state)\nthis:\n  C \\<in> {D \\<in> X. C - {v} \\<lhd> D}\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> C \\<Longrightarrow> finite {D \\<in> X. C - {v} \\<lhd> D}", "show \"finite {D\\<in>X. C-{v}\\<lhd>D}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {D \\<in> X. C - {v} \\<lhd> D}", "proof (cases \"{D\\<in>X. C-{v}\\<lhd>D} - {C} = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. {D \\<in> X. C - {v} \\<lhd> D} - {C} = {} \\<Longrightarrow>\n    finite {D \\<in> X. C - {v} \\<lhd> D}\n 2. {D \\<in> X. C - {v} \\<lhd> D} - {C} \\<noteq> {} \\<Longrightarrow>\n    finite {D \\<in> X. C - {v} \\<lhd> D}", "case True"], ["proof (state)\nthis:\n  {D \\<in> X. C - {v} \\<lhd> D} - {C} = {}\n\ngoal (2 subgoals):\n 1. {D \\<in> X. C - {v} \\<lhd> D} - {C} = {} \\<Longrightarrow>\n    finite {D \\<in> X. C - {v} \\<lhd> D}\n 2. {D \\<in> X. C - {v} \\<lhd> D} - {C} \\<noteq> {} \\<Longrightarrow>\n    finite {D \\<in> X. C - {v} \\<lhd> D}", "hence 1: \"{D\\<in>X. C-{v}\\<lhd>D} = {C}\""], ["proof (prove)\nusing this:\n  {D \\<in> X. C - {v} \\<lhd> D} - {C} = {}\n\ngoal (1 subgoal):\n 1. {D \\<in> X. C - {v} \\<lhd> D} = {C}", "using C"], ["proof (prove)\nusing this:\n  {D \\<in> X. C - {v} \\<lhd> D} - {C} = {}\n  C \\<in> {D \\<in> X. C - {v} \\<lhd> D}\n\ngoal (1 subgoal):\n 1. {D \\<in> X. C - {v} \\<lhd> D} = {C}", "by auto"], ["proof (state)\nthis:\n  {D \\<in> X. C - {v} \\<lhd> D} = {C}\n\ngoal (2 subgoals):\n 1. {D \\<in> X. C - {v} \\<lhd> D} - {C} = {} \\<Longrightarrow>\n    finite {D \\<in> X. C - {v} \\<lhd> D}\n 2. {D \\<in> X. C - {v} \\<lhd> D} - {C} \\<noteq> {} \\<Longrightarrow>\n    finite {D \\<in> X. C - {v} \\<lhd> D}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {D \\<in> X. C - {v} \\<lhd> D}", "using ssubst[OF 1, of finite]"], ["proof (prove)\nusing this:\n  finite {C} \\<Longrightarrow> finite {D \\<in> X. C - {v} \\<lhd> D}\n\ngoal (1 subgoal):\n 1. finite {D \\<in> X. C - {v} \\<lhd> D}", "by simp"], ["proof (state)\nthis:\n  finite {D \\<in> X. C - {v} \\<lhd> D}\n\ngoal (1 subgoal):\n 1. {D \\<in> X. C - {v} \\<lhd> D} - {C} \\<noteq> {} \\<Longrightarrow>\n    finite {D \\<in> X. C - {v} \\<lhd> D}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {D \\<in> X. C - {v} \\<lhd> D} - {C} \\<noteq> {} \\<Longrightarrow>\n    finite {D \\<in> X. C - {v} \\<lhd> D}", "case False"], ["proof (state)\nthis:\n  {D \\<in> X. C - {v} \\<lhd> D} - {C} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {D \\<in> X. C - {v} \\<lhd> D} - {C} \\<noteq> {} \\<Longrightarrow>\n    finite {D \\<in> X. C - {v} \\<lhd> D}", "from this"], ["proof (chain)\npicking this:\n  {D \\<in> X. C - {v} \\<lhd> D} - {C} \\<noteq> {}", "obtain D where D: \"D\\<in>X-{C}\" \"C-{v}\\<lhd>D\""], ["proof (prove)\nusing this:\n  {D \\<in> X. C - {v} \\<lhd> D} - {C} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> X - {C}; C - {v} \\<lhd> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  D \\<in> X - {C}\n  C - {v} \\<lhd> D\n\ngoal (1 subgoal):\n 1. {D \\<in> X. C - {v} \\<lhd> D} - {C} \\<noteq> {} \\<Longrightarrow>\n    finite {D \\<in> X. C - {v} \\<lhd> D}", "with assms"], ["proof (chain)\npicking this:\n  chamber C\n  D \\<in> X - {C}\n  C - {v} \\<lhd> D", "have 2: \"{D\\<in>X. C-{v}\\<lhd>D} \\<subseteq> {C,D}\""], ["proof (prove)\nusing this:\n  chamber C\n  D \\<in> X - {C}\n  C - {v} \\<lhd> D\n\ngoal (1 subgoal):\n 1. order.greater_eq {C, D} {D \\<in> X. C - {v} \\<lhd> D}", "using Cv chamber_shared_facet[of C] facet_unique_other_chamber[of C _ D]"], ["proof (prove)\nusing this:\n  chamber C\n  D \\<in> X - {C}\n  C - {v} \\<lhd> D\n  C - {v} \\<lhd> C\n  \\<lbrakk>chamber C; ?z \\<lhd> C; ?D \\<in> X; ?z \\<lhd> ?D\\<rbrakk>\n  \\<Longrightarrow> chamber ?D\n  \\<lbrakk>chamber C; ?z \\<lhd> C; chamber D; ?z \\<lhd> D; chamber ?D;\n   ?z \\<lhd> ?D; D \\<noteq> C; ?D \\<noteq> C\\<rbrakk>\n  \\<Longrightarrow> D = ?D\n\ngoal (1 subgoal):\n 1. order.greater_eq {C, D} {D \\<in> X. C - {v} \\<lhd> D}", "by    fastforce"], ["proof (state)\nthis:\n  order.greater_eq {C, D} {D \\<in> X. C - {v} \\<lhd> D}\n\ngoal (1 subgoal):\n 1. {D \\<in> X. C - {v} \\<lhd> D} - {C} \\<noteq> {} \\<Longrightarrow>\n    finite {D \\<in> X. C - {v} \\<lhd> D}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {D \\<in> X. C - {v} \\<lhd> D}", "using finite_subset[OF 2]"], ["proof (prove)\nusing this:\n  finite {C, D} \\<Longrightarrow> finite {D \\<in> X. C - {v} \\<lhd> D}\n\ngoal (1 subgoal):\n 1. finite {D \\<in> X. C - {v} \\<lhd> D}", "by simp"], ["proof (state)\nthis:\n  finite {D \\<in> X. C - {v} \\<lhd> D}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {D \\<in> X. C - {v} \\<lhd> D}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})\n\ngoal (1 subgoal):\n 1. X \\<noteq> {{}} \\<Longrightarrow> finite (adjacentset C)", "ultimately"], ["proof (chain)\npicking this:\n  X \\<noteq> {{}}\n  finite (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})", "show ?thesis"], ["proof (prove)\nusing this:\n  X \\<noteq> {{}}\n  finite (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})\n\ngoal (1 subgoal):\n 1. finite (adjacentset C)", "using assms adjacentset_conv_facetchambersets"], ["proof (prove)\nusing this:\n  X \\<noteq> {{}}\n  finite (\\<Union>v\\<in>C. {D \\<in> X. C - {v} \\<lhd> D})\n  chamber C\n  \\<lbrakk>X \\<noteq> {{}}; chamber ?C\\<rbrakk>\n  \\<Longrightarrow> adjacentset ?C =\n                    (\\<Union>v\\<in>?C. {D \\<in> X. ?C - {v} \\<lhd> D})\n\ngoal (1 subgoal):\n 1. finite (adjacentset C)", "by simp"], ["proof (state)\nthis:\n  finite (adjacentset C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma label_wrt_eq_on_adjacent_vertex:\n  fixes   v v' :: 'a\n  and     z z' :: \"'a set\"\n  defines D : \"D \\<equiv> insert v z\"\n  and     D': \"D' \\<equiv> insert v' z'\"\n  assumes label   : \"label_wrt B f\" \"f v = f v'\"\n  and     chambers: \"chamber C\" \"chamber D\" \"chamber D'\" \"z\\<lhd>C\" \"z'\\<lhd>C\" \"D\\<noteq>C\" \"D'\\<noteq>C\" \n  shows   \"D = D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = D'", "proof (\n  rule facet_unique_other_chamber, rule chambers(1), rule chambers(4),\n  rule chambers(2)\n)"], ["proof (state)\ngoal (5 subgoals):\n 1. z \\<lhd> D\n 2. chamber D'\n 3. z \\<lhd> D'\n 4. D \\<noteq> C\n 5. D' \\<noteq> C", "from D D' chambers(1-5)"], ["proof (chain)\npicking this:\n  D \\<equiv> insert v z\n  D' \\<equiv> insert v' z'\n  chamber C\n  chamber D\n  chamber D'\n  z \\<lhd> C\n  z' \\<lhd> C", "have z: \"z\\<lhd>D\" and z': \"z'\\<lhd>D'\""], ["proof (prove)\nusing this:\n  D \\<equiv> insert v z\n  D' \\<equiv> insert v' z'\n  chamber C\n  chamber D\n  chamber D'\n  z \\<lhd> C\n  z' \\<lhd> C\n\ngoal (1 subgoal):\n 1. z \\<lhd> D &&& z' \\<lhd> D'", "using chambers_share_facet"], ["proof (prove)\nusing this:\n  D \\<equiv> insert v z\n  D' \\<equiv> insert v' z'\n  chamber C\n  chamber D\n  chamber D'\n  z \\<lhd> C\n  z' \\<lhd> C\n  \\<lbrakk>chamber ?C; chamber (insert ?v ?z); ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> ?z \\<lhd> insert ?v ?z\n\ngoal (1 subgoal):\n 1. z \\<lhd> D &&& z' \\<lhd> D'", "by auto"], ["proof (state)\nthis:\n  z \\<lhd> D\n  z' \\<lhd> D'\n\ngoal (5 subgoals):\n 1. z \\<lhd> D\n 2. chamber D'\n 3. z \\<lhd> D'\n 4. D \\<noteq> C\n 5. D' \\<noteq> C", "show \"z\\<lhd>D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<lhd> D", "by fact"], ["proof (state)\nthis:\n  z \\<lhd> D\n\ngoal (4 subgoals):\n 1. chamber D'\n 2. z \\<lhd> D'\n 3. D \\<noteq> C\n 4. D' \\<noteq> C", "from chambers(4,5)"], ["proof (chain)\npicking this:\n  z \\<lhd> C\n  z' \\<lhd> C", "obtain w w'\n    where w : \"w \\<notin> z \" \"C = insert w  z\"\n    and   w': \"w'\\<notin> z'\" \"C = insert w' z'\""], ["proof (prove)\nusing this:\n  z \\<lhd> C\n  z' \\<lhd> C\n\ngoal (1 subgoal):\n 1. (\\<And>w w'.\n        \\<lbrakk>w \\<notin> z; C = insert w z; w' \\<notin> z';\n         C = insert w' z'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding facetrel_def"], ["proof (prove)\nusing this:\n  \\<exists>v. v \\<notin> z \\<and> C = insert v z\n  \\<exists>v. v \\<notin> z' \\<and> C = insert v z'\n\ngoal (1 subgoal):\n 1. (\\<And>w w'.\n        \\<lbrakk>w \\<notin> z; C = insert w z; w' \\<notin> z';\n         C = insert w' z'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by        fastforce"], ["proof (state)\nthis:\n  w \\<notin> z\n  C = insert w z\n  w' \\<notin> z'\n  C = insert w' z'\n\ngoal (4 subgoals):\n 1. chamber D'\n 2. z \\<lhd> D'\n 3. D \\<noteq> C\n 4. D' \\<noteq> C", "from w' D' chambers(1,3)"], ["proof (chain)\npicking this:\n  w' \\<notin> z'\n  C = insert w' z'\n  D' \\<equiv> insert v' z'\n  chamber C\n  chamber D'", "have \"f`z' = f`C - {f v'}\""], ["proof (prove)\nusing this:\n  w' \\<notin> z'\n  C = insert w' z'\n  D' \\<equiv> insert v' z'\n  chamber C\n  chamber D'\n\ngoal (1 subgoal):\n 1. f ` z' = f ` C - {f v'}", "using z' label_wrtD'[OF label(1), of C] bij_betw_imp_inj_on[of f C]\n          facetrel_complement_vertex[of z']\n          label_wrt_adjacent_shared_facet[OF label(1), of v']"], ["proof (prove)\nusing this:\n  w' \\<notin> z'\n  C = insert w' z'\n  D' \\<equiv> insert v' z'\n  chamber C\n  chamber D'\n  z' \\<lhd> D'\n  chamber C \\<Longrightarrow> bij_betw f C B\n  bij_betw f C ?B \\<Longrightarrow> inj_on f C\n  \\<lbrakk>z' \\<lhd> ?x; ?x = insert ?v z'\\<rbrakk>\n  \\<Longrightarrow> ?v \\<notin> z'\n  \\<lbrakk>chamber (insert v' ?z); chamber (insert ?w ?z); v' \\<notin> ?z;\n   ?w \\<notin> ?z\\<rbrakk>\n  \\<Longrightarrow> f v' = f ?w\n\ngoal (1 subgoal):\n 1. f ` z' = f ` C - {f v'}", "by    simp"], ["proof (state)\nthis:\n  f ` z' = f ` C - {f v'}\n\ngoal (4 subgoals):\n 1. chamber D'\n 2. z \\<lhd> D'\n 3. D \\<noteq> C\n 4. D' \\<noteq> C", "moreover"], ["proof (state)\nthis:\n  f ` z' = f ` C - {f v'}\n\ngoal (4 subgoals):\n 1. chamber D'\n 2. z \\<lhd> D'\n 3. D \\<noteq> C\n 4. D' \\<noteq> C", "from w D chambers(1,2)"], ["proof (chain)\npicking this:\n  w \\<notin> z\n  C = insert w z\n  D \\<equiv> insert v z\n  chamber C\n  chamber D", "have \"f`z = f`C - {f v}\""], ["proof (prove)\nusing this:\n  w \\<notin> z\n  C = insert w z\n  D \\<equiv> insert v z\n  chamber C\n  chamber D\n\ngoal (1 subgoal):\n 1. f ` z = f ` C - {f v}", "using z label_wrtD'[OF label(1), of C] bij_betw_imp_inj_on[of f C]\n          facetrel_complement_vertex[of z]\n          label_wrt_adjacent_shared_facet[OF label(1), of v]"], ["proof (prove)\nusing this:\n  w \\<notin> z\n  C = insert w z\n  D \\<equiv> insert v z\n  chamber C\n  chamber D\n  z \\<lhd> D\n  chamber C \\<Longrightarrow> bij_betw f C B\n  bij_betw f C ?B \\<Longrightarrow> inj_on f C\n  \\<lbrakk>z \\<lhd> ?x; ?x = insert ?v z\\<rbrakk>\n  \\<Longrightarrow> ?v \\<notin> z\n  \\<lbrakk>chamber (insert v ?z); chamber (insert ?w ?z); v \\<notin> ?z;\n   ?w \\<notin> ?z\\<rbrakk>\n  \\<Longrightarrow> f v = f ?w\n\ngoal (1 subgoal):\n 1. f ` z = f ` C - {f v}", "by    simp"], ["proof (state)\nthis:\n  f ` z = f ` C - {f v}\n\ngoal (4 subgoals):\n 1. chamber D'\n 2. z \\<lhd> D'\n 3. D \\<noteq> C\n 4. D' \\<noteq> C", "ultimately"], ["proof (chain)\npicking this:\n  f ` z' = f ` C - {f v'}\n  f ` z = f ` C - {f v}", "show \"z\\<lhd>D'\""], ["proof (prove)\nusing this:\n  f ` z' = f ` C - {f v'}\n  f ` z = f ` C - {f v}\n\ngoal (1 subgoal):\n 1. z \\<lhd> D'", "using z' chambers(1,4,5) label(2) facetrel_subset\n          label_wrtD'[OF label(1), of C]\n          bij_betw_imp_inj_on[of f] inj_on_eq_image[of f C z' z]"], ["proof (prove)\nusing this:\n  f ` z' = f ` C - {f v'}\n  f ` z = f ` C - {f v}\n  z' \\<lhd> D'\n  chamber C\n  z \\<lhd> C\n  z' \\<lhd> C\n  f v = f v'\n  ?y \\<lhd> ?x \\<Longrightarrow> order.greater_eq ?x ?y\n  chamber C \\<Longrightarrow> bij_betw f C B\n  bij_betw f ?A ?B \\<Longrightarrow> inj_on f ?A\n  \\<lbrakk>inj_on f C; order.greater_eq C z'; order.greater_eq C z;\n   f ` z' = f ` z\\<rbrakk>\n  \\<Longrightarrow> z' = z\n\ngoal (1 subgoal):\n 1. z \\<lhd> D'", "by    force"], ["proof (state)\nthis:\n  z \\<lhd> D'\n\ngoal (3 subgoals):\n 1. chamber D'\n 2. D \\<noteq> C\n 3. D' \\<noteq> C", "qed (rule chambers(3), rule chambers(6), rule chambers(7))"], ["", "lemma face_distance_eq_chamber_distance_compare_other_chamber:\n  assumes   \"chamber C\" \"chamber D\" \"z\\<lhd>C\" \"z\\<lhd>D\" \"C\\<noteq>D\"\n            \"chamber_distance C E \\<le> chamber_distance D E\"\n  shows     \"face_distance z E = chamber_distance C E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. face_distance z E = chamber_distance C E", "unfolding face_distance_def closest_supchamber_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. chamber_distance\n     (ARG_MIN (\\<lambda>C. chamber_distance C E) C.\n         chamber C \\<and> order.greater_eq C z)\n     E =\n    chamber_distance C E", "proof (\n  rule arg_min_equality, rule conjI, rule assms(1), rule facetrel_subset,\n  rule assms(3)\n)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       chamber x \\<and> order.greater_eq x z \\<Longrightarrow>\n       order.greater_eq (chamber_distance x E) (chamber_distance C E)", "from assms"], ["proof (chain)\npicking this:\n  chamber C\n  chamber D\n  z \\<lhd> C\n  z \\<lhd> D\n  C \\<noteq> D\n  order.greater_eq (chamber_distance D E) (chamber_distance C E)", "show  \"\\<And>B. chamber B \\<and> z \\<subseteq> B \\<Longrightarrow>\n            chamber_distance C E \\<le> chamber_distance B E\""], ["proof (prove)\nusing this:\n  chamber C\n  chamber D\n  z \\<lhd> C\n  z \\<lhd> D\n  C \\<noteq> D\n  order.greater_eq (chamber_distance D E) (chamber_distance C E)\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       chamber B \\<and> order.greater_eq B z \\<Longrightarrow>\n       order.greater_eq (chamber_distance B E) (chamber_distance C E)", "using chamber_facet_is_chamber_facet facet_unique_other_chamber"], ["proof (prove)\nusing this:\n  chamber C\n  chamber D\n  z \\<lhd> C\n  z \\<lhd> D\n  C \\<noteq> D\n  order.greater_eq (chamber_distance D E) (chamber_distance C E)\n  \\<lbrakk>chamber ?C; chamber ?D; ?z \\<lhd> ?C;\n   order.greater_eq ?D ?z\\<rbrakk>\n  \\<Longrightarrow> ?z \\<lhd> ?D\n  \\<lbrakk>chamber ?B; ?z \\<lhd> ?B; chamber ?C; ?z \\<lhd> ?C; chamber ?D;\n   ?z \\<lhd> ?D; ?C \\<noteq> ?B; ?D \\<noteq> ?B\\<rbrakk>\n  \\<Longrightarrow> ?C = ?D\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       chamber B \\<and> order.greater_eq B z \\<Longrightarrow>\n       order.greater_eq (chamber_distance B E) (chamber_distance C E)", "by    blast"], ["proof (state)\nthis:\n  chamber ?B1 \\<and> order.greater_eq ?B1 z \\<Longrightarrow>\n  order.greater_eq (chamber_distance ?B1 E) (chamber_distance C E)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ThinishChamberComplex *)"], ["", "lemma (in ChamberComplexIsomorphism) thinish_image_shared_facet:\n  assumes dom:  \"domain.chamber C\" \"domain.chamber D\" \"z\\<lhd>C\" \"z\\<lhd>D\" \"C\\<noteq>D\"\n  and     cod:  \"ThinishChamberComplex Y\" \"codomain.chamber D'\" \"f`z \\<lhd> D'\"\n                \"D' \\<noteq> f`C\"\n  shows   \"f`D = D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` D = D'", "proof (rule ThinishChamberComplex.facet_unique_other_chamber, rule cod(1))"], ["proof (state)\ngoal (8 subgoals):\n 1. codomain.chamber ?B\n 2. ?z \\<lhd> ?B\n 3. codomain.chamber (f ` D)\n 4. ?z \\<lhd> f ` D\n 5. codomain.chamber D'\n 6. ?z \\<lhd> D'\n 7. f ` D \\<noteq> ?B\n 8. D' \\<noteq> ?B", "from dom(1,2)"], ["proof (chain)\npicking this:\n  domain.chamber C\n  domain.chamber D", "show \"codomain.chamber (f`C)\" \"codomain.chamber (f`D)\""], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n\ngoal (1 subgoal):\n 1. codomain.chamber (f ` C) &&& codomain.chamber (f ` D)", "using chamber_map"], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  domain.chamber ?C \\<Longrightarrow> codomain.chamber (f ` ?C)\n\ngoal (1 subgoal):\n 1. codomain.chamber (f ` C) &&& codomain.chamber (f ` D)", "by auto"], ["proof (state)\nthis:\n  codomain.chamber (f ` C)\n  codomain.chamber (f ` D)\n\ngoal (6 subgoals):\n 1. ?z \\<lhd> f ` C\n 2. ?z \\<lhd> f ` D\n 3. codomain.chamber D'\n 4. ?z \\<lhd> D'\n 5. f ` D \\<noteq> f ` C\n 6. D' \\<noteq> f ` C", "from dom"], ["proof (chain)\npicking this:\n  domain.chamber C\n  domain.chamber D\n  z \\<lhd> C\n  z \\<lhd> D\n  C \\<noteq> D", "show \"f`z \\<lhd> f`C\" \"f`z \\<lhd> f`D\""], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  z \\<lhd> C\n  z \\<lhd> D\n  C \\<noteq> D\n\ngoal (1 subgoal):\n 1. f ` z \\<lhd> f ` C &&& f ` z \\<lhd> f ` D", "using facet_map"], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  z \\<lhd> C\n  z \\<lhd> D\n  C \\<noteq> D\n  \\<lbrakk>domain.chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> f ` ?z \\<lhd> f ` ?C\n\ngoal (1 subgoal):\n 1. f ` z \\<lhd> f ` C &&& f ` z \\<lhd> f ` D", "by auto"], ["proof (state)\nthis:\n  f ` z \\<lhd> f ` C\n  f ` z \\<lhd> f ` D\n\ngoal (4 subgoals):\n 1. codomain.chamber D'\n 2. f ` z \\<lhd> D'\n 3. f ` D \\<noteq> f ` C\n 4. D' \\<noteq> f ` C", "from dom"], ["proof (chain)\npicking this:\n  domain.chamber C\n  domain.chamber D\n  z \\<lhd> C\n  z \\<lhd> D\n  C \\<noteq> D", "have \"domain.pgallery [C,D]\""], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  z \\<lhd> C\n  z \\<lhd> D\n  C \\<noteq> D\n\ngoal (1 subgoal):\n 1. domain.pgallery [C, D]", "using domain.pgallery_def adjacentI"], ["proof (prove)\nusing this:\n  domain.chamber C\n  domain.chamber D\n  z \\<lhd> C\n  z \\<lhd> D\n  C \\<noteq> D\n  domain.pgallery ?xs \\<equiv>\n  Ball (set ?xs) domain.chamber \\<and> padjacentchain ?xs\n  \\<lbrakk>?z \\<lhd> ?x; ?z \\<lhd> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<sim> ?y\n\ngoal (1 subgoal):\n 1. domain.pgallery [C, D]", "by fastforce"], ["proof (state)\nthis:\n  domain.pgallery [C, D]\n\ngoal (4 subgoals):\n 1. codomain.chamber D'\n 2. f ` z \\<lhd> D'\n 3. f ` D \\<noteq> f ` C\n 4. D' \\<noteq> f ` C", "hence \"codomain.pgallery [f`C,f`D]\""], ["proof (prove)\nusing this:\n  domain.pgallery [C, D]\n\ngoal (1 subgoal):\n 1. codomain.pgallery [f ` C, f ` D]", "using pgallery_map[of \"[C,D]\"]"], ["proof (prove)\nusing this:\n  domain.pgallery [C, D]\n  domain.pgallery [C, D] \\<Longrightarrow>\n  codomain.pgallery (f \\<Turnstile> [C, D])\n\ngoal (1 subgoal):\n 1. codomain.pgallery [f ` C, f ` D]", "by simp"], ["proof (state)\nthis:\n  codomain.pgallery [f ` C, f ` D]\n\ngoal (4 subgoals):\n 1. codomain.chamber D'\n 2. f ` z \\<lhd> D'\n 3. f ` D \\<noteq> f ` C\n 4. D' \\<noteq> f ` C", "thus \"f`D \\<noteq> f`C\""], ["proof (prove)\nusing this:\n  codomain.pgallery [f ` C, f ` D]\n\ngoal (1 subgoal):\n 1. f ` D \\<noteq> f ` C", "using codomain.pgalleryD_distinct"], ["proof (prove)\nusing this:\n  codomain.pgallery [f ` C, f ` D]\n  codomain.pgallery ?xs \\<Longrightarrow> distinct ?xs\n\ngoal (1 subgoal):\n 1. f ` D \\<noteq> f ` C", "by fastforce"], ["proof (state)\nthis:\n  f ` D \\<noteq> f ` C\n\ngoal (3 subgoals):\n 1. codomain.chamber D'\n 2. f ` z \\<lhd> D'\n 3. D' \\<noteq> f ` C", "qed (rule cod(2), rule cod(3), rule cod(4))"], ["", "locale ThinChamberComplex = ChamberComplex X\n  for X :: \"'a set set\"\n+ assumes thin:  \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> \\<exists>!D\\<in>X-{C}. z\\<lhd>D\""], ["", "sublocale ThinChamberComplex < ThinishChamberComplex"], ["proof (prove)\ngoal (1 subgoal):\n 1. ThinishChamberComplex X", "using thin"], ["proof (prove)\nusing this:\n  \\<lbrakk>chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!D. D \\<in> X - {?C} \\<and> ?z \\<lhd> D\n\ngoal (1 subgoal):\n 1. ThinishChamberComplex X", "by unfold_locales simp"], ["", "context ThinChamberComplex\nbegin"], ["", "lemma thinish: \"ThinishChamberComplex X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ThinishChamberComplex X", ".."], ["", "lemmas face_distance_eq_chamber_distance_compare_other_chamber =\n  face_distance_eq_chamber_distance_compare_other_chamber"], ["", "abbreviation \"the_adj_chamber C z \\<equiv> THE D. D\\<in>X-{C} \\<and> z \\<lhd> D\""], ["", "lemma the_adj_chamber_simplex:\n  \"chamber C \\<Longrightarrow> z \\<lhd> C \\<Longrightarrow> the_adj_chamber C z \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> the_adj_chamber C z \\<in> X", "using theI'[OF thin]"], ["proof (prove)\nusing this:\n  \\<lbrakk>chamber ?C1; ?z1 \\<lhd> ?C1\\<rbrakk>\n  \\<Longrightarrow> the_adj_chamber ?C1 ?z1 \\<in> X - {?C1} \\<and>\n                    ?z1 \\<lhd> the_adj_chamber ?C1 ?z1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> the_adj_chamber C z \\<in> X", "by fast"], ["", "lemma the_adj_chamber_facet: \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> z \\<lhd> the_adj_chamber C z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> z \\<lhd> the_adj_chamber C z", "using theI'[OF thin]"], ["proof (prove)\nusing this:\n  \\<lbrakk>chamber ?C1; ?z1 \\<lhd> ?C1\\<rbrakk>\n  \\<Longrightarrow> the_adj_chamber ?C1 ?z1 \\<in> X - {?C1} \\<and>\n                    ?z1 \\<lhd> the_adj_chamber ?C1 ?z1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> z \\<lhd> the_adj_chamber C z", "by fast"], ["", "lemma the_adj_chamber_is_adjacent:\n  \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> C \\<sim> the_adj_chamber C z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> C \\<sim> the_adj_chamber C z", "using the_adj_chamber_facet"], ["proof (prove)\nusing this:\n  \\<lbrakk>chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> ?z \\<lhd> the_adj_chamber ?C ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> C \\<sim> the_adj_chamber C z", "by (auto intro: adjacentI)"], ["", "lemma the_adj_chamber:\n  \"chamber C \\<Longrightarrow> z \\<lhd> C \\<Longrightarrow> chamber (the_adj_chamber C z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> chamber (the_adj_chamber C z)", "using the_adj_chamber_simplex the_adj_chamber_is_adjacent"], ["proof (prove)\nusing this:\n  \\<lbrakk>chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> the_adj_chamber ?C ?z \\<in> X\n  \\<lbrakk>chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> ?C \\<sim> the_adj_chamber ?C ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> chamber (the_adj_chamber C z)", "by    (fast intro: chamber_adj)"], ["", "lemma the_adj_chamber_neq:\n  \"chamber C \\<Longrightarrow> z \\<lhd> C \\<Longrightarrow> the_adj_chamber C z \\<noteq> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> the_adj_chamber C z \\<noteq> C", "using theI'[OF thin]"], ["proof (prove)\nusing this:\n  \\<lbrakk>chamber ?C1; ?z1 \\<lhd> ?C1\\<rbrakk>\n  \\<Longrightarrow> the_adj_chamber ?C1 ?z1 \\<in> X - {?C1} \\<and>\n                    ?z1 \\<lhd> the_adj_chamber ?C1 ?z1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> the_adj_chamber C z \\<noteq> C", "by fast"], ["", "lemma the_adj_chamber_adjacentset:\n  \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> the_adj_chamber C z \\<in> adjacentset C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> the_adj_chamber C z \\<in> adjacentset C", "using adjacentset_def the_adj_chamber_simplex the_adj_chamber_is_adjacent"], ["proof (prove)\nusing this:\n  adjacentset ?x = {y \\<in> X. ?x \\<sim> y}\n  \\<lbrakk>chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> the_adj_chamber ?C ?z \\<in> X\n  \\<lbrakk>chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> ?C \\<sim> the_adj_chamber ?C ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> the_adj_chamber C z \\<in> adjacentset C", "by    fast"], ["", "end"], ["", "(* context ThinChamberComplex *)"], ["", "lemmas (in ChamberComplexIsomorphism) thin_image_shared_facet =\n  thinish_image_shared_facet[OF _ _ _ _ _ ThinChamberComplex.thinish]"], ["", "subsubsection \\<open>The standard uniqueness argument for chamber morphisms of thin chamber complexes\\<close>"], ["", "context ThinishChamberComplex\nbegin"], ["", "lemma standard_uniqueness_dbl:\n  assumes morph   : \"ChamberComplexMorphism W X f\"\n                    \"ChamberComplexMorphism W X g\"\n  and     chambers: \"ChamberComplex.chamber W C\"\n                    \"ChamberComplex.chamber W D\"\n                    \"C\\<sim>D\" \"f`D \\<noteq> f`C\" \"g`D \\<noteq> g`C\" \"chamber (g`D)\"\n  and     funeq   : \"fun_eq_on f g C\"\n  shows \"fun_eq_on f g D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_eq_on f g D", "proof (rule fun_eq_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> D \\<Longrightarrow> f a = g a", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> D \\<Longrightarrow> f a = g a", "assume v: \"v\\<in>D\""], ["proof (state)\nthis:\n  v \\<in> D\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> D \\<Longrightarrow> f a = g a", "show \"f v = g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f v = g v", "proof (cases \"v\\<in>C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> C \\<Longrightarrow> f v = g v\n 2. v \\<notin> C \\<Longrightarrow> f v = g v", "case True"], ["proof (state)\nthis:\n  v \\<in> C\n\ngoal (2 subgoals):\n 1. v \\<in> C \\<Longrightarrow> f v = g v\n 2. v \\<notin> C \\<Longrightarrow> f v = g v", "with funeq"], ["proof (chain)\npicking this:\n  fun_eq_on f g C\n  v \\<in> C", "show ?thesis"], ["proof (prove)\nusing this:\n  fun_eq_on f g C\n  v \\<in> C\n\ngoal (1 subgoal):\n 1. f v = g v", "using fun_eq_onD"], ["proof (prove)\nusing this:\n  fun_eq_on f g C\n  v \\<in> C\n  \\<lbrakk>fun_eq_on ?f ?g ?A; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f ?a = ?g ?a\n\ngoal (1 subgoal):\n 1. f v = g v", "by fast"], ["proof (state)\nthis:\n  f v = g v\n\ngoal (1 subgoal):\n 1. v \\<notin> C \\<Longrightarrow> f v = g v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> C \\<Longrightarrow> f v = g v", "case False"], ["proof (state)\nthis:\n  v \\<notin> C\n\ngoal (1 subgoal):\n 1. v \\<notin> C \\<Longrightarrow> f v = g v", "define F G where \"F = f`C \\<inter> f`D\" and \"G = g`C \\<inter> g`D\""], ["proof (state)\nthis:\n  F = f ` C \\<inter> f ` D\n  G = g ` C \\<inter> g ` D\n\ngoal (1 subgoal):\n 1. v \\<notin> C \\<Longrightarrow> f v = g v", "from morph(1) chambers(1-4)"], ["proof (chain)\npicking this:\n  ChamberComplexMorphism W X f\n  SimplicialComplex.maxsimp W C\n  SimplicialComplex.maxsimp W D\n  C \\<sim> D\n  f ` D \\<noteq> f ` C", "have 1: \"f`C \\<sim> f`D\""], ["proof (prove)\nusing this:\n  ChamberComplexMorphism W X f\n  SimplicialComplex.maxsimp W C\n  SimplicialComplex.maxsimp W D\n  C \\<sim> D\n  f ` D \\<noteq> f ` C\n\ngoal (1 subgoal):\n 1. f ` C \\<sim> f ` D", "using ChamberComplexMorphism.adj_map'"], ["proof (prove)\nusing this:\n  ChamberComplexMorphism W X f\n  SimplicialComplex.maxsimp W C\n  SimplicialComplex.maxsimp W D\n  C \\<sim> D\n  f ` D \\<noteq> f ` C\n  \\<lbrakk>ChamberComplexMorphism ?X ?Y ?f; SimplicialComplex.maxsimp ?X ?C;\n   SimplicialComplex.maxsimp ?X ?D; ?C \\<sim> ?D;\n   ?f ` ?C \\<noteq> ?f ` ?D\\<rbrakk>\n  \\<Longrightarrow> ?f ` ?C \\<sim> ?f ` ?D\n\ngoal (1 subgoal):\n 1. f ` C \\<sim> f ` D", "by fast"], ["proof (state)\nthis:\n  f ` C \\<sim> f ` D\n\ngoal (1 subgoal):\n 1. v \\<notin> C \\<Longrightarrow> f v = g v", "with F_def chambers(4)"], ["proof (chain)\npicking this:\n  F = f ` C \\<inter> f ` D\n  f ` D \\<noteq> f ` C\n  f ` C \\<sim> f ` D", "have F_facet: \"F\\<lhd>f`C\" \"F\\<lhd>f`D\""], ["proof (prove)\nusing this:\n  F = f ` C \\<inter> f ` D\n  f ` D \\<noteq> f ` C\n  f ` C \\<sim> f ` D\n\ngoal (1 subgoal):\n 1. F \\<lhd> f ` C &&& F \\<lhd> f ` D", "using adjacent_int_facet1[of \"f`C\"] adjacent_int_facet2[of \"f`C\"]"], ["proof (prove)\nusing this:\n  F = f ` C \\<inter> f ` D\n  f ` D \\<noteq> f ` C\n  f ` C \\<sim> f ` D\n  \\<lbrakk>f ` C \\<sim> ?y; f ` C \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> f ` C \\<inter> ?y \\<lhd> f ` C\n  \\<lbrakk>f ` C \\<sim> ?y; f ` C \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> f ` C \\<inter> ?y \\<lhd> ?y\n\ngoal (1 subgoal):\n 1. F \\<lhd> f ` C &&& F \\<lhd> f ` D", "by auto"], ["proof (state)\nthis:\n  F \\<lhd> f ` C\n  F \\<lhd> f ` D\n\ngoal (1 subgoal):\n 1. v \\<notin> C \\<Longrightarrow> f v = g v", "from F_def G_def chambers"], ["proof (chain)\npicking this:\n  F = f ` C \\<inter> f ` D\n  G = g ` C \\<inter> g ` D\n  SimplicialComplex.maxsimp W C\n  SimplicialComplex.maxsimp W D\n  C \\<sim> D\n  f ` D \\<noteq> f ` C\n  g ` D \\<noteq> g ` C\n  chamber (g ` D)", "have \"G = F\""], ["proof (prove)\nusing this:\n  F = f ` C \\<inter> f ` D\n  G = g ` C \\<inter> g ` D\n  SimplicialComplex.maxsimp W C\n  SimplicialComplex.maxsimp W D\n  C \\<sim> D\n  f ` D \\<noteq> f ` C\n  g ` D \\<noteq> g ` C\n  chamber (g ` D)\n\ngoal (1 subgoal):\n 1. G = F", "using ChamberComplexMorphism.adj_map'[OF morph(2)]\n            adjacent_to_adjacent_int[of C D g] 1\n            adjacent_to_adjacent_int[of C D f] funeq fun_eq_on_im[of f g]"], ["proof (prove)\nusing this:\n  F = f ` C \\<inter> f ` D\n  G = g ` C \\<inter> g ` D\n  SimplicialComplex.maxsimp W C\n  SimplicialComplex.maxsimp W D\n  C \\<sim> D\n  f ` D \\<noteq> f ` C\n  g ` D \\<noteq> g ` C\n  chamber (g ` D)\n  \\<lbrakk>SimplicialComplex.maxsimp W ?C; SimplicialComplex.maxsimp W ?D;\n   ?C \\<sim> ?D; g ` ?C \\<noteq> g ` ?D\\<rbrakk>\n  \\<Longrightarrow> g ` ?C \\<sim> g ` ?D\n  \\<lbrakk>C \\<sim> D; g ` C \\<sim> g ` D; g ` C \\<noteq> g ` D\\<rbrakk>\n  \\<Longrightarrow> g ` (C \\<inter> D) = g ` C \\<inter> g ` D\n  f ` C \\<sim> f ` D\n  \\<lbrakk>C \\<sim> D; f ` C \\<sim> f ` D; f ` C \\<noteq> f ` D\\<rbrakk>\n  \\<Longrightarrow> f ` (C \\<inter> D) = f ` C \\<inter> f ` D\n  fun_eq_on f g C\n  \\<lbrakk>fun_eq_on f g ?A; order.greater_eq ?A ?B\\<rbrakk>\n  \\<Longrightarrow> f ` ?B = g ` ?B\n\ngoal (1 subgoal):\n 1. G = F", "by    force"], ["proof (state)\nthis:\n  G = F\n\ngoal (1 subgoal):\n 1. v \\<notin> C \\<Longrightarrow> f v = g v", "with G_def morph(2) chambers"], ["proof (chain)\npicking this:\n  G = g ` C \\<inter> g ` D\n  ChamberComplexMorphism W X g\n  SimplicialComplex.maxsimp W C\n  SimplicialComplex.maxsimp W D\n  C \\<sim> D\n  f ` D \\<noteq> f ` C\n  g ` D \\<noteq> g ` C\n  chamber (g ` D)\n  G = F", "have F_facet': \"F\\<lhd>g`D\""], ["proof (prove)\nusing this:\n  G = g ` C \\<inter> g ` D\n  ChamberComplexMorphism W X g\n  SimplicialComplex.maxsimp W C\n  SimplicialComplex.maxsimp W D\n  C \\<sim> D\n  f ` D \\<noteq> f ` C\n  g ` D \\<noteq> g ` C\n  chamber (g ` D)\n  G = F\n\ngoal (1 subgoal):\n 1. F \\<lhd> g ` D", "using ChamberComplexMorphism.adj_map' adjacent_int_facet2"], ["proof (prove)\nusing this:\n  G = g ` C \\<inter> g ` D\n  ChamberComplexMorphism W X g\n  SimplicialComplex.maxsimp W C\n  SimplicialComplex.maxsimp W D\n  C \\<sim> D\n  f ` D \\<noteq> f ` C\n  g ` D \\<noteq> g ` C\n  chamber (g ` D)\n  G = F\n  \\<lbrakk>ChamberComplexMorphism ?X ?Y ?f; SimplicialComplex.maxsimp ?X ?C;\n   SimplicialComplex.maxsimp ?X ?D; ?C \\<sim> ?D;\n   ?f ` ?C \\<noteq> ?f ` ?D\\<rbrakk>\n  \\<Longrightarrow> ?f ` ?C \\<sim> ?f ` ?D\n  \\<lbrakk>?x \\<sim> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<inter> ?y \\<lhd> ?y\n\ngoal (1 subgoal):\n 1. F \\<lhd> g ` D", "by blast"], ["proof (state)\nthis:\n  F \\<lhd> g ` D\n\ngoal (1 subgoal):\n 1. v \\<notin> C \\<Longrightarrow> f v = g v", "with chambers(1,2,4,5)"], ["proof (chain)\npicking this:\n  SimplicialComplex.maxsimp W C\n  SimplicialComplex.maxsimp W D\n  f ` D \\<noteq> f ` C\n  g ` D \\<noteq> g ` C\n  F \\<lhd> g ` D", "have 2: \"g`D = f`D\""], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp W C\n  SimplicialComplex.maxsimp W D\n  f ` D \\<noteq> f ` C\n  g ` D \\<noteq> g ` C\n  F \\<lhd> g ` D\n\ngoal (1 subgoal):\n 1. g ` D = f ` D", "using ChamberComplexMorphism.chamber_map[OF morph(1)] F_facet\n            ChamberComplexMorphism.chamber_map[OF morph(2)]\n            fun_eq_on_im[OF funeq]\n            facet_unique_other_chamber[of \"f`C\" F \"g`D\" \"f`D\"]"], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp W C\n  SimplicialComplex.maxsimp W D\n  f ` D \\<noteq> f ` C\n  g ` D \\<noteq> g ` C\n  F \\<lhd> g ` D\n  SimplicialComplex.maxsimp W ?C \\<Longrightarrow> chamber (f ` ?C)\n  F \\<lhd> f ` C\n  F \\<lhd> f ` D\n  SimplicialComplex.maxsimp W ?C \\<Longrightarrow> chamber (g ` ?C)\n  order.greater_eq C ?B \\<Longrightarrow> f ` ?B = g ` ?B\n  \\<lbrakk>chamber (f ` C); F \\<lhd> f ` C; chamber (g ` D); F \\<lhd> g ` D;\n   chamber (f ` D); F \\<lhd> f ` D; g ` D \\<noteq> f ` C;\n   f ` D \\<noteq> f ` C\\<rbrakk>\n  \\<Longrightarrow> g ` D = f ` D\n\ngoal (1 subgoal):\n 1. g ` D = f ` D", "by    auto"], ["proof (state)\nthis:\n  g ` D = f ` D\n\ngoal (1 subgoal):\n 1. v \\<notin> C \\<Longrightarrow> f v = g v", "from chambers(3) v False"], ["proof (chain)\npicking this:\n  C \\<sim> D\n  v \\<in> D\n  v \\<notin> C", "have 3: \"D = insert v (D\\<inter>C)\""], ["proof (prove)\nusing this:\n  C \\<sim> D\n  v \\<in> D\n  v \\<notin> C\n\ngoal (1 subgoal):\n 1. D = insert v (D \\<inter> C)", "using adjacent_sym adjacent_conv_insert"], ["proof (prove)\nusing this:\n  C \\<sim> D\n  v \\<in> D\n  v \\<notin> C\n  ?x \\<sim> ?y \\<Longrightarrow> ?y \\<sim> ?x\n  \\<lbrakk>?x \\<sim> ?y; ?v \\<in> ?x - ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = insert ?v (?x \\<inter> ?y)\n\ngoal (1 subgoal):\n 1. D = insert v (D \\<inter> C)", "by fast"], ["proof (state)\nthis:\n  D = insert v (D \\<inter> C)\n\ngoal (1 subgoal):\n 1. v \\<notin> C \\<Longrightarrow> f v = g v", "from chambers(4)"], ["proof (chain)\npicking this:\n  f ` D \\<noteq> f ` C", "obtain w where w: \"w \\<notin> f`C\" \"w \\<in> f`D\""], ["proof (prove)\nusing this:\n  f ` D \\<noteq> f ` C\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<notin> f ` C; w \\<in> f ` D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using adjacent_int_decomp[OF adjacent_sym, OF 1]"], ["proof (prove)\nusing this:\n  f ` D \\<noteq> f ` C\n  f ` D \\<noteq> f ` C \\<Longrightarrow>\n  \\<exists>v.\n     v \\<notin> f ` C \\<and> f ` D = insert v (f ` D \\<inter> f ` C)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<notin> f ` C; w \\<in> f ` D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w \\<notin> f ` C\n  w \\<in> f ` D\n\ngoal (1 subgoal):\n 1. v \\<notin> C \\<Longrightarrow> f v = g v", "with 3"], ["proof (chain)\npicking this:\n  D = insert v (D \\<inter> C)\n  w \\<notin> f ` C\n  w \\<in> f ` D", "have \"w = f v\""], ["proof (prove)\nusing this:\n  D = insert v (D \\<inter> C)\n  w \\<notin> f ` C\n  w \\<in> f ` D\n\ngoal (1 subgoal):\n 1. w = f v", "by fast"], ["proof (state)\nthis:\n  w = f v\n\ngoal (1 subgoal):\n 1. v \\<notin> C \\<Longrightarrow> f v = g v", "moreover"], ["proof (state)\nthis:\n  w = f v\n\ngoal (1 subgoal):\n 1. v \\<notin> C \\<Longrightarrow> f v = g v", "from 2 w(2)"], ["proof (chain)\npicking this:\n  g ` D = f ` D\n  w \\<in> f ` D", "obtain v' where \"v'\\<in>D\" \"w = g v'\""], ["proof (prove)\nusing this:\n  g ` D = f ` D\n  w \\<in> f ` D\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<lbrakk>v' \\<in> D; w = g v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v' \\<in> D\n  w = g v'\n\ngoal (1 subgoal):\n 1. v \\<notin> C \\<Longrightarrow> f v = g v", "ultimately"], ["proof (chain)\npicking this:\n  w = f v\n  v' \\<in> D\n  w = g v'", "show ?thesis"], ["proof (prove)\nusing this:\n  w = f v\n  v' \\<in> D\n  w = g v'\n\ngoal (1 subgoal):\n 1. f v = g v", "using w(1) 3 funeq"], ["proof (prove)\nusing this:\n  w = f v\n  v' \\<in> D\n  w = g v'\n  w \\<notin> f ` C\n  D = insert v (D \\<inter> C)\n  fun_eq_on f g C\n\ngoal (1 subgoal):\n 1. f v = g v", "by (fastforce simp add: fun_eq_on_im)"], ["proof (state)\nthis:\n  f v = g v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f v = g v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma standard_uniqueness_pgallery_betw:\n  assumes morph   : \"ChamberComplexMorphism W X f\"\n                    \"ChamberComplexMorphism W X g\"\n  and     chambers: \"fun_eq_on f g C\" \"ChamberComplex.gallery W (C#Cs@[D])\"\n                    \"pgallery (f\\<Turnstile>(C#Cs@[D]))\" \"pgallery (g\\<Turnstile>(C#Cs@[D]))\"\n  shows   \"fun_eq_on f g D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_eq_on f g D", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. fun_eq_on f g D", "from morph(1)"], ["proof (chain)\npicking this:\n  ChamberComplexMorphism W X f", "have W: \"ChamberComplex W\""], ["proof (prove)\nusing this:\n  ChamberComplexMorphism W X f\n\ngoal (1 subgoal):\n 1. ChamberComplex W", "using ChamberComplexMorphism.domain_complex"], ["proof (prove)\nusing this:\n  ChamberComplexMorphism W X f\n  ChamberComplexMorphism ?X ?Y ?f \\<Longrightarrow> ChamberComplex ?X\n\ngoal (1 subgoal):\n 1. ChamberComplex W", "by fast"], ["proof (state)\nthis:\n  ChamberComplex W\n\ngoal (1 subgoal):\n 1. fun_eq_on f g D", "have \"\\<lbrakk> fun_eq_on f g C; ChamberComplex.gallery W (C#Cs@[D]);\n          pgallery (f\\<Turnstile>(C#Cs@[D])); pgallery (g\\<Turnstile>(C#Cs@[D])) \\<rbrakk> \\<Longrightarrow>\n          fun_eq_on f g D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_eq_on f g C;\n     SimplicialComplex.maxsimpchain W (C # Cs @ [D]);\n     pgallery (f \\<Turnstile> (C # Cs @ [D]));\n     pgallery (g \\<Turnstile> (C # Cs @ [D]))\\<rbrakk>\n    \\<Longrightarrow> fun_eq_on f g D", "proof (induct Cs arbitrary: C)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>fun_eq_on f g C;\n        SimplicialComplex.maxsimpchain W (C # [] @ [D]);\n        pgallery (f \\<Turnstile> (C # [] @ [D]));\n        pgallery (g \\<Turnstile> (C # [] @ [D]))\\<rbrakk>\n       \\<Longrightarrow> fun_eq_on f g D\n 2. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>fun_eq_on f g C;\n                    SimplicialComplex.maxsimpchain W (C # Cs @ [D]);\n                    pgallery (f \\<Turnstile> (C # Cs @ [D]));\n                    pgallery (g \\<Turnstile> (C # Cs @ [D]))\\<rbrakk>\n                   \\<Longrightarrow> fun_eq_on f g D;\n        fun_eq_on f g C;\n        SimplicialComplex.maxsimpchain W (C # (a # Cs) @ [D]);\n        pgallery (f \\<Turnstile> (C # (a # Cs) @ [D]));\n        pgallery (g \\<Turnstile> (C # (a # Cs) @ [D]))\\<rbrakk>\n       \\<Longrightarrow> fun_eq_on f g D", "case Nil"], ["proof (state)\nthis:\n  fun_eq_on f g C\n  SimplicialComplex.maxsimpchain W (C # [] @ [D])\n  pgallery (f \\<Turnstile> (C # [] @ [D]))\n  pgallery (g \\<Turnstile> (C # [] @ [D]))\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>fun_eq_on f g C;\n        SimplicialComplex.maxsimpchain W (C # [] @ [D]);\n        pgallery (f \\<Turnstile> (C # [] @ [D]));\n        pgallery (g \\<Turnstile> (C # [] @ [D]))\\<rbrakk>\n       \\<Longrightarrow> fun_eq_on f g D\n 2. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>fun_eq_on f g C;\n                    SimplicialComplex.maxsimpchain W (C # Cs @ [D]);\n                    pgallery (f \\<Turnstile> (C # Cs @ [D]));\n                    pgallery (g \\<Turnstile> (C # Cs @ [D]))\\<rbrakk>\n                   \\<Longrightarrow> fun_eq_on f g D;\n        fun_eq_on f g C;\n        SimplicialComplex.maxsimpchain W (C # (a # Cs) @ [D]);\n        pgallery (f \\<Turnstile> (C # (a # Cs) @ [D]));\n        pgallery (g \\<Turnstile> (C # (a # Cs) @ [D]))\\<rbrakk>\n       \\<Longrightarrow> fun_eq_on f g D", "from assms Nil(1)"], ["proof (chain)\npicking this:\n  ChamberComplexMorphism W X f\n  ChamberComplexMorphism W X g\n  fun_eq_on f g C\n  SimplicialComplex.maxsimpchain W (C # Cs @ [D])\n  pgallery (f \\<Turnstile> (C # Cs @ [D]))\n  pgallery (g \\<Turnstile> (C # Cs @ [D]))\n  fun_eq_on f g C", "show ?case"], ["proof (prove)\nusing this:\n  ChamberComplexMorphism W X f\n  ChamberComplexMorphism W X g\n  fun_eq_on f g C\n  SimplicialComplex.maxsimpchain W (C # Cs @ [D])\n  pgallery (f \\<Turnstile> (C # Cs @ [D]))\n  pgallery (g \\<Turnstile> (C # Cs @ [D]))\n  fun_eq_on f g C\n\ngoal (1 subgoal):\n 1. fun_eq_on f g D", "using ChamberComplex.galleryD_chamber[OF W Nil(2)]\n            ChamberComplex.galleryD_adj[OF W Nil(2)]\n            pgalleryD_distinct[OF Nil(3)] pgalleryD_distinct[OF Nil(4)]\n            pgalleryD_chamber[OF Nil(4)] standard_uniqueness_dbl[of W f g C D]"], ["proof (prove)\nusing this:\n  ChamberComplexMorphism W X f\n  ChamberComplexMorphism W X g\n  fun_eq_on f g C\n  SimplicialComplex.maxsimpchain W (C # Cs @ [D])\n  pgallery (f \\<Turnstile> (C # Cs @ [D]))\n  pgallery (g \\<Turnstile> (C # Cs @ [D]))\n  fun_eq_on f g C\n  ?x \\<in> set (C # [] @ [D]) \\<Longrightarrow>\n  SimplicialComplex.maxsimp W ?x\n  adjacentchain (C # [] @ [D])\n  distinct (f \\<Turnstile> (C # [] @ [D]))\n  distinct (g \\<Turnstile> (C # [] @ [D]))\n  ?x \\<in> set (g \\<Turnstile> (C # [] @ [D])) \\<Longrightarrow> chamber ?x\n  \\<lbrakk>ChamberComplexMorphism W X f; ChamberComplexMorphism W X g;\n   SimplicialComplex.maxsimp W C; SimplicialComplex.maxsimp W D; C \\<sim> D;\n   f ` D \\<noteq> f ` C; g ` D \\<noteq> g ` C; chamber (g ` D);\n   fun_eq_on f g C\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on f g D\n\ngoal (1 subgoal):\n 1. fun_eq_on f g D", "by    auto"], ["proof (state)\nthis:\n  fun_eq_on f g D\n\ngoal (1 subgoal):\n 1. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>fun_eq_on f g C;\n                    SimplicialComplex.maxsimpchain W (C # Cs @ [D]);\n                    pgallery (f \\<Turnstile> (C # Cs @ [D]));\n                    pgallery (g \\<Turnstile> (C # Cs @ [D]))\\<rbrakk>\n                   \\<Longrightarrow> fun_eq_on f g D;\n        fun_eq_on f g C;\n        SimplicialComplex.maxsimpchain W (C # (a # Cs) @ [D]);\n        pgallery (f \\<Turnstile> (C # (a # Cs) @ [D]));\n        pgallery (g \\<Turnstile> (C # (a # Cs) @ [D]))\\<rbrakk>\n       \\<Longrightarrow> fun_eq_on f g D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>fun_eq_on f g C;\n                    SimplicialComplex.maxsimpchain W (C # Cs @ [D]);\n                    pgallery (f \\<Turnstile> (C # Cs @ [D]));\n                    pgallery (g \\<Turnstile> (C # Cs @ [D]))\\<rbrakk>\n                   \\<Longrightarrow> fun_eq_on f g D;\n        fun_eq_on f g C;\n        SimplicialComplex.maxsimpchain W (C # (a # Cs) @ [D]);\n        pgallery (f \\<Turnstile> (C # (a # Cs) @ [D]));\n        pgallery (g \\<Turnstile> (C # (a # Cs) @ [D]))\\<rbrakk>\n       \\<Longrightarrow> fun_eq_on f g D", "case (Cons B Bs)"], ["proof (state)\nthis:\n  \\<lbrakk>fun_eq_on f g ?C1;\n   SimplicialComplex.maxsimpchain W (?C1 # Bs @ [D]);\n   pgallery (f \\<Turnstile> (?C1 # Bs @ [D]));\n   pgallery (g \\<Turnstile> (?C1 # Bs @ [D]))\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on f g D\n  fun_eq_on f g C\n  SimplicialComplex.maxsimpchain W (C # (B # Bs) @ [D])\n  pgallery (f \\<Turnstile> (C # (B # Bs) @ [D]))\n  pgallery (g \\<Turnstile> (C # (B # Bs) @ [D]))\n\ngoal (1 subgoal):\n 1. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>fun_eq_on f g C;\n                    SimplicialComplex.maxsimpchain W (C # Cs @ [D]);\n                    pgallery (f \\<Turnstile> (C # Cs @ [D]));\n                    pgallery (g \\<Turnstile> (C # Cs @ [D]))\\<rbrakk>\n                   \\<Longrightarrow> fun_eq_on f g D;\n        fun_eq_on f g C;\n        SimplicialComplex.maxsimpchain W (C # (a # Cs) @ [D]);\n        pgallery (f \\<Turnstile> (C # (a # Cs) @ [D]));\n        pgallery (g \\<Turnstile> (C # (a # Cs) @ [D]))\\<rbrakk>\n       \\<Longrightarrow> fun_eq_on f g D", "have \"fun_eq_on f g B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_eq_on f g B", "proof (rule standard_uniqueness_dbl, rule morph(1), rule morph(2))"], ["proof (state)\ngoal (7 subgoals):\n 1. SimplicialComplex.maxsimp W ?C\n 2. SimplicialComplex.maxsimp W B\n 3. ?C \\<sim> B\n 4. f ` B \\<noteq> f ` ?C\n 5. g ` B \\<noteq> g ` ?C\n 6. chamber (g ` B)\n 7. fun_eq_on f g ?C", "show \"ChamberComplex.chamber W C\" \"ChamberComplex.chamber W B\" \"C\\<sim>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp W C &&&\n    SimplicialComplex.maxsimp W B &&& C \\<sim> B", "using ChamberComplex.galleryD_chamber[OF W Cons(3)]\n              ChamberComplex.galleryD_adj[OF W Cons(3)]"], ["proof (prove)\nusing this:\n  ?x \\<in> set (C # (B # Bs) @ [D]) \\<Longrightarrow>\n  SimplicialComplex.maxsimp W ?x\n  adjacentchain (C # (B # Bs) @ [D])\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp W C &&&\n    SimplicialComplex.maxsimp W B &&& C \\<sim> B", "by    auto"], ["proof (state)\nthis:\n  SimplicialComplex.maxsimp W C\n  SimplicialComplex.maxsimp W B\n  C \\<sim> B\n\ngoal (4 subgoals):\n 1. f ` B \\<noteq> f ` C\n 2. g ` B \\<noteq> g ` C\n 3. chamber (g ` B)\n 4. fun_eq_on f g C", "show \"f`B \\<noteq> f`C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` B \\<noteq> f ` C", "using pgalleryD_distinct[OF Cons(4)]"], ["proof (prove)\nusing this:\n  distinct (f \\<Turnstile> (C # (B # Bs) @ [D]))\n\ngoal (1 subgoal):\n 1. f ` B \\<noteq> f ` C", "by fastforce"], ["proof (state)\nthis:\n  f ` B \\<noteq> f ` C\n\ngoal (3 subgoals):\n 1. g ` B \\<noteq> g ` C\n 2. chamber (g ` B)\n 3. fun_eq_on f g C", "show \"g`B \\<noteq> g`C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g ` B \\<noteq> g ` C", "using pgalleryD_distinct[OF Cons(5)]"], ["proof (prove)\nusing this:\n  distinct (g \\<Turnstile> (C # (B # Bs) @ [D]))\n\ngoal (1 subgoal):\n 1. g ` B \\<noteq> g ` C", "by fastforce"], ["proof (state)\nthis:\n  g ` B \\<noteq> g ` C\n\ngoal (2 subgoals):\n 1. chamber (g ` B)\n 2. fun_eq_on f g C", "show \"chamber (g`B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chamber (g ` B)", "using pgalleryD_chamber[OF Cons(5)]"], ["proof (prove)\nusing this:\n  ?x \\<in> set (g \\<Turnstile> (C # (B # Bs) @ [D])) \\<Longrightarrow>\n  chamber ?x\n\ngoal (1 subgoal):\n 1. chamber (g ` B)", "by fastforce"], ["proof (state)\nthis:\n  chamber (g ` B)\n\ngoal (1 subgoal):\n 1. fun_eq_on f g C", "qed (rule Cons(2))"], ["proof (state)\nthis:\n  fun_eq_on f g B\n\ngoal (1 subgoal):\n 1. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>fun_eq_on f g C;\n                    SimplicialComplex.maxsimpchain W (C # Cs @ [D]);\n                    pgallery (f \\<Turnstile> (C # Cs @ [D]));\n                    pgallery (g \\<Turnstile> (C # Cs @ [D]))\\<rbrakk>\n                   \\<Longrightarrow> fun_eq_on f g D;\n        fun_eq_on f g C;\n        SimplicialComplex.maxsimpchain W (C # (a # Cs) @ [D]);\n        pgallery (f \\<Turnstile> (C # (a # Cs) @ [D]));\n        pgallery (g \\<Turnstile> (C # (a # Cs) @ [D]))\\<rbrakk>\n       \\<Longrightarrow> fun_eq_on f g D", "with Cons(1,3-5)"], ["proof (chain)\npicking this:\n  \\<lbrakk>fun_eq_on f g ?C1;\n   SimplicialComplex.maxsimpchain W (?C1 # Bs @ [D]);\n   pgallery (f \\<Turnstile> (?C1 # Bs @ [D]));\n   pgallery (g \\<Turnstile> (?C1 # Bs @ [D]))\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on f g D\n  SimplicialComplex.maxsimpchain W (C # (B # Bs) @ [D])\n  pgallery (f \\<Turnstile> (C # (B # Bs) @ [D]))\n  pgallery (g \\<Turnstile> (C # (B # Bs) @ [D]))\n  fun_eq_on f g B", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>fun_eq_on f g ?C1;\n   SimplicialComplex.maxsimpchain W (?C1 # Bs @ [D]);\n   pgallery (f \\<Turnstile> (?C1 # Bs @ [D]));\n   pgallery (g \\<Turnstile> (?C1 # Bs @ [D]))\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on f g D\n  SimplicialComplex.maxsimpchain W (C # (B # Bs) @ [D])\n  pgallery (f \\<Turnstile> (C # (B # Bs) @ [D]))\n  pgallery (g \\<Turnstile> (C # (B # Bs) @ [D]))\n  fun_eq_on f g B\n\ngoal (1 subgoal):\n 1. fun_eq_on f g D", "using ChamberComplex.gallery_Cons_reduce[OF W, of C \"B#Bs@[D]\"]\n            pgallery_Cons_reduce[of \"f`C\" \"f\\<Turnstile>(B#Bs@[D])\"]\n            pgallery_Cons_reduce[of \"g`C\" \"g\\<Turnstile>(B#Bs@[D])\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>fun_eq_on f g ?C1;\n   SimplicialComplex.maxsimpchain W (?C1 # Bs @ [D]);\n   pgallery (f \\<Turnstile> (?C1 # Bs @ [D]));\n   pgallery (g \\<Turnstile> (?C1 # Bs @ [D]))\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on f g D\n  SimplicialComplex.maxsimpchain W (C # (B # Bs) @ [D])\n  pgallery (f \\<Turnstile> (C # (B # Bs) @ [D]))\n  pgallery (g \\<Turnstile> (C # (B # Bs) @ [D]))\n  fun_eq_on f g B\n  SimplicialComplex.maxsimpchain W (C # B # Bs @ [D]) \\<Longrightarrow>\n  SimplicialComplex.maxsimpchain W (B # Bs @ [D])\n  pgallery (f ` C # f \\<Turnstile> (B # Bs @ [D])) \\<Longrightarrow>\n  pgallery (f \\<Turnstile> (B # Bs @ [D]))\n  pgallery (g ` C # g \\<Turnstile> (B # Bs @ [D])) \\<Longrightarrow>\n  pgallery (g \\<Turnstile> (B # Bs @ [D]))\n\ngoal (1 subgoal):\n 1. fun_eq_on f g D", "by    force"], ["proof (state)\nthis:\n  fun_eq_on f g D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>fun_eq_on f g C; SimplicialComplex.maxsimpchain W (C # Cs @ [D]);\n   pgallery (f \\<Turnstile> (C # Cs @ [D]));\n   pgallery (g \\<Turnstile> (C # Cs @ [D]))\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on f g D\n\ngoal (1 subgoal):\n 1. fun_eq_on f g D", "with chambers"], ["proof (chain)\npicking this:\n  fun_eq_on f g C\n  SimplicialComplex.maxsimpchain W (C # Cs @ [D])\n  pgallery (f \\<Turnstile> (C # Cs @ [D]))\n  pgallery (g \\<Turnstile> (C # Cs @ [D]))\n  \\<lbrakk>fun_eq_on f g C; SimplicialComplex.maxsimpchain W (C # Cs @ [D]);\n   pgallery (f \\<Turnstile> (C # Cs @ [D]));\n   pgallery (g \\<Turnstile> (C # Cs @ [D]))\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on f g D", "show ?thesis"], ["proof (prove)\nusing this:\n  fun_eq_on f g C\n  SimplicialComplex.maxsimpchain W (C # Cs @ [D])\n  pgallery (f \\<Turnstile> (C # Cs @ [D]))\n  pgallery (g \\<Turnstile> (C # Cs @ [D]))\n  \\<lbrakk>fun_eq_on f g C; SimplicialComplex.maxsimpchain W (C # Cs @ [D]);\n   pgallery (f \\<Turnstile> (C # Cs @ [D]));\n   pgallery (g \\<Turnstile> (C # Cs @ [D]))\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on f g D\n\ngoal (1 subgoal):\n 1. fun_eq_on f g D", "by simp"], ["proof (state)\nthis:\n  fun_eq_on f g D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma standard_uniqueness:\n  assumes morph   : \"ChamberComplexMorphism W X f\"\n                    \"ChamberComplexMorphism W X g\"\n  and     chamber : \"ChamberComplex.chamber W C\" \"fun_eq_on f g C\"\n  and     map_gals:\n    \"\\<And>Cs. ChamberComplex.min_gallery W (C#Cs) \\<Longrightarrow> pgallery (f\\<Turnstile>(C#Cs))\"\n    \"\\<And>Cs. ChamberComplex.min_gallery W (C#Cs) \\<Longrightarrow> pgallery (g\\<Turnstile>(C#Cs))\"\n  shows   \"fun_eq_on f g (\\<Union>W)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_eq_on f g (\\<Union> W)", "proof (rule fun_eq_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> \\<Union> W \\<Longrightarrow> f a = g a", "from morph(1)"], ["proof (chain)\npicking this:\n  ChamberComplexMorphism W X f", "have W: \"ChamberComplex W\""], ["proof (prove)\nusing this:\n  ChamberComplexMorphism W X f\n\ngoal (1 subgoal):\n 1. ChamberComplex W", "using ChamberComplexMorphism.axioms(1)"], ["proof (prove)\nusing this:\n  ChamberComplexMorphism W X f\n  ChamberComplexMorphism ?X ?Y ?f \\<Longrightarrow> ChamberComplex ?X\n\ngoal (1 subgoal):\n 1. ChamberComplex W", "by fast"], ["proof (state)\nthis:\n  ChamberComplex W\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> \\<Union> W \\<Longrightarrow> f a = g a", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> \\<Union> W \\<Longrightarrow> f a = g a", "assume \"v \\<in> \\<Union>W\""], ["proof (state)\nthis:\n  v \\<in> \\<Union> W\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> \\<Union> W \\<Longrightarrow> f a = g a", "from this"], ["proof (chain)\npicking this:\n  v \\<in> \\<Union> W", "obtain D where \"ChamberComplex.chamber W D\" \"v\\<in>D\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> W\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>SimplicialComplex.maxsimp W D; v \\<in> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ChamberComplex.simplex_in_max[OF W]"], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> W\n  ?y \\<in> W \\<Longrightarrow>\n  \\<exists>x. SimplicialComplex.maxsimp W x \\<and> order.greater_eq x ?y\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>SimplicialComplex.maxsimp W D; v \\<in> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  SimplicialComplex.maxsimp W D\n  v \\<in> D\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> \\<Union> W \\<Longrightarrow> f a = g a", "moreover"], ["proof (state)\nthis:\n  SimplicialComplex.maxsimp W D\n  v \\<in> D\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> \\<Union> W \\<Longrightarrow> f a = g a", "define Cs where \"Cs = (ARG_MIN length Cs. ChamberComplex.gallery W (C#Cs@[D]))\""], ["proof (state)\nthis:\n  Cs = (ARG_MIN length Cs. SimplicialComplex.maxsimpchain W (C # Cs @ [D]))\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> \\<Union> W \\<Longrightarrow> f a = g a", "ultimately"], ["proof (chain)\npicking this:\n  SimplicialComplex.maxsimp W D\n  v \\<in> D\n  Cs = (ARG_MIN length Cs. SimplicialComplex.maxsimpchain W (C # Cs @ [D]))", "show \"f v = g v\""], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp W D\n  v \\<in> D\n  Cs = (ARG_MIN length Cs. SimplicialComplex.maxsimpchain W (C # Cs @ [D]))\n\ngoal (1 subgoal):\n 1. f v = g v", "using chamber map_gals[of \"Cs@[D]\"]\n          ChamberComplex.gallery_least_length[OF W]\n          ChamberComplex.min_gallery_least_length[OF W]\n          standard_uniqueness_pgallery_betw[OF morph(1,2) chamber(2), of Cs]\n          fun_eq_onD[of f g D]"], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp W D\n  v \\<in> D\n  Cs = (ARG_MIN length Cs. SimplicialComplex.maxsimpchain W (C # Cs @ [D]))\n  SimplicialComplex.maxsimp W C\n  fun_eq_on f g C\n  SimplicialComplex.min_maxsimpchain W (C # Cs @ [D]) \\<Longrightarrow>\n  pgallery (f \\<Turnstile> (C # Cs @ [D]))\n  SimplicialComplex.min_maxsimpchain W (C # Cs @ [D]) \\<Longrightarrow>\n  pgallery (g \\<Turnstile> (C # Cs @ [D]))\n  \\<lbrakk>SimplicialComplex.maxsimp W ?C; SimplicialComplex.maxsimp W ?D;\n   ?C \\<noteq> ?D\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimpchain W\n                     (?C #\n                      (ARG_MIN length Cs.\n                          SimplicialComplex.maxsimpchain W\n                           (?C # Cs @ [?D])) @\n                      [?D])\n  \\<lbrakk>SimplicialComplex.maxsimp W ?C; SimplicialComplex.maxsimp W ?D;\n   ?C \\<noteq> ?D\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.min_maxsimpchain W\n                     (?C #\n                      (ARG_MIN length Cs.\n                          SimplicialComplex.maxsimpchain W\n                           (?C # Cs @ [?D])) @\n                      [?D])\n  \\<lbrakk>SimplicialComplex.maxsimpchain W (C # Cs @ [?D]);\n   pgallery (f \\<Turnstile> (C # Cs @ [?D]));\n   pgallery (g \\<Turnstile> (C # Cs @ [?D]))\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on f g ?D\n  \\<lbrakk>fun_eq_on f g D; ?a \\<in> D\\<rbrakk>\n  \\<Longrightarrow> f ?a = g ?a\n\ngoal (1 subgoal):\n 1. f v = g v", "by    (cases \"D=C\") auto"], ["proof (state)\nthis:\n  f v = g v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma standard_uniqueness_isomorphs:\n  assumes \"ChamberComplexIsomorphism W X f\"\n          \"ChamberComplexIsomorphism W X g\"\n          \"ChamberComplex.chamber W C\" \"fun_eq_on f g C\"\n  shows   \"fun_eq_on f g (\\<Union>W)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_eq_on f g (\\<Union> W)", "using   assms ChamberComplexIsomorphism.chamber_morphism\n          ChamberComplexIsomorphism.domain_complex\n          ChamberComplex.min_gallery_pgallery\n          ChamberComplexIsomorphism.pgallery_map"], ["proof (prove)\nusing this:\n  ChamberComplexIsomorphism W X f\n  ChamberComplexIsomorphism W X g\n  SimplicialComplex.maxsimp W C\n  fun_eq_on f g C\n  ChamberComplexIsomorphism ?X ?Y ?f \\<Longrightarrow>\n  ChamberComplexMorphism ?X ?Y ?f\n  ChamberComplexIsomorphism ?X ?Y ?f \\<Longrightarrow> ChamberComplex ?X\n  \\<lbrakk>ChamberComplex ?X;\n   SimplicialComplex.min_maxsimpchain ?X ?xs\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.pmaxsimpchain ?X ?xs\n  \\<lbrakk>ChamberComplexIsomorphism ?X ?Y ?f;\n   SimplicialComplex.pmaxsimpchain ?X ?Cs\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.pmaxsimpchain ?Y (?f \\<Turnstile> ?Cs)\n\ngoal (1 subgoal):\n 1. fun_eq_on f g (\\<Union> W)", "by      (blast intro: standard_uniqueness)"], ["", "lemma standard_uniqueness_automorphs:\n  assumes \"ChamberComplexAutomorphism X f\"\n          \"ChamberComplexAutomorphism X g\"\n          \"chamber C\" \"fun_eq_on f g C\"\n  shows   \"f=g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g", "using   assms ChamberComplexAutomorphism.equality\n          standard_uniqueness_isomorphs\n          ChamberComplexAutomorphism.axioms(1)"], ["proof (prove)\nusing this:\n  ChamberComplexAutomorphism X f\n  ChamberComplexAutomorphism X g\n  chamber C\n  fun_eq_on f g C\n  \\<lbrakk>ChamberComplexAutomorphism ?X ?f;\n   ChamberComplexAutomorphism ?X ?g; fun_eq_on ?f ?g (\\<Union> ?X)\\<rbrakk>\n  \\<Longrightarrow> ?f = ?g\n  \\<lbrakk>ChamberComplexIsomorphism ?W X ?f;\n   ChamberComplexIsomorphism ?W X ?g; SimplicialComplex.maxsimp ?W ?C;\n   fun_eq_on ?f ?g ?C\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on ?f ?g (\\<Union> ?W)\n  ChamberComplexAutomorphism ?X ?f \\<Longrightarrow>\n  ChamberComplexIsomorphism ?X ?X ?f\n\ngoal (1 subgoal):\n 1. f = g", "by      blast"], ["", "end"], ["", "(* context ThinishChamberComplex *)"], ["", "context ThinChamberComplex\nbegin"], ["", "lemmas standard_uniqueness               = standard_uniqueness"], ["", "lemmas standard_uniqueness_isomorphs     = standard_uniqueness_isomorphs"], ["", "lemmas standard_uniqueness_pgallery_betw = standard_uniqueness_pgallery_betw"], ["", "end"], ["", "(* context ThinChamberComplex *)"], ["", "subsection \\<open>Foldings of thin chamber complexes\\<close>"], ["", "subsubsection \\<open>Locale definition and basic facts\\<close>"], ["", "locale ThinishChamberComplexFolding =\n  ThinishChamberComplex X + folding: ChamberComplexFolding X f\n  for X :: \"'a set set\"\n  and f :: \"'a\\<Rightarrow>'a\"\nbegin"], ["", "abbreviation \"opp_chamber \\<equiv> folding.opp_chamber\""], ["", "lemma adjacent_half_chamber_system_image:\n  assumes chambers: \"C \\<in> f\\<turnstile>\\<C>\" \"D \\<in> \\<C>-f\\<turnstile>\\<C>\"\n  and     adjacent: \"C\\<sim>D\"\n  shows   \"f`D = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` D = C", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. f ` D = C", "from adjacent"], ["proof (chain)\npicking this:\n  C \\<sim> D", "obtain z where z: \"z\\<lhd>C\" \"z\\<lhd>D\""], ["proof (prove)\nusing this:\n  C \\<sim> D\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<lhd> C; z \\<lhd> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using adjacent_def"], ["proof (prove)\nusing this:\n  C \\<sim> D\n  ?x \\<sim> ?y \\<equiv> \\<exists>z. z \\<lhd> ?x \\<and> z \\<lhd> ?y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<lhd> C; z \\<lhd> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  z \\<lhd> C\n  z \\<lhd> D\n\ngoal (1 subgoal):\n 1. f ` D = C", "moreover"], ["proof (state)\nthis:\n  z \\<lhd> C\n  z \\<lhd> D\n\ngoal (1 subgoal):\n 1. f ` D = C", "from z(1) chambers(1)"], ["proof (chain)\npicking this:\n  z \\<lhd> C\n  C \\<in> f \\<turnstile> folding.\\<C>", "have fz: \"f`z = z\""], ["proof (prove)\nusing this:\n  z \\<lhd> C\n  C \\<in> f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. f ` z = z", "using facetrel_subset[of z C] chamber_system_simplices\n          folding.simplicialcomplex_image\n          SimplicialComplex.faces[of \"f\\<turnstile>X\" C z]\n          folding.simplex_retraction2[of z]"], ["proof (prove)\nusing this:\n  z \\<lhd> C\n  C \\<in> f \\<turnstile> folding.\\<C>\n  z \\<lhd> C \\<Longrightarrow> order.greater_eq C z\n  order.greater_eq X folding.\\<C>\n  SimplicialComplex (f \\<turnstile> X)\n  \\<lbrakk>SimplicialComplex (f \\<turnstile> X); C \\<in> f \\<turnstile> X;\n   order.greater_eq C z\\<rbrakk>\n  \\<Longrightarrow> z \\<in> f \\<turnstile> X\n  z \\<in> f \\<turnstile> X \\<Longrightarrow> f ` z = z\n\ngoal (1 subgoal):\n 1. f ` z = z", "by    auto"], ["proof (state)\nthis:\n  f ` z = z\n\ngoal (1 subgoal):\n 1. f ` D = C", "moreover"], ["proof (state)\nthis:\n  f ` z = z\n\ngoal (1 subgoal):\n 1. f ` D = C", "from chambers"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>", "have \"f`D \\<noteq> D\" \"C\\<noteq>D\""], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. f ` D \\<noteq> D &&& C \\<noteq> D", "by auto"], ["proof (state)\nthis:\n  f ` D \\<noteq> D\n  C \\<noteq> D\n\ngoal (1 subgoal):\n 1. f ` D = C", "ultimately"], ["proof (chain)\npicking this:\n  z \\<lhd> C\n  z \\<lhd> D\n  f ` z = z\n  f ` D \\<noteq> D\n  C \\<noteq> D", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<lhd> C\n  z \\<lhd> D\n  f ` z = z\n  f ` D \\<noteq> D\n  C \\<noteq> D\n\ngoal (1 subgoal):\n 1. f ` D = C", "using chambers chamber_system_def folding.chamber_map\n          folding.facet_map[of D z]\n          facet_unique_other_chamber[of D z \"f`D\" C]"], ["proof (prove)\nusing this:\n  z \\<lhd> C\n  z \\<lhd> D\n  f ` z = z\n  f ` D \\<noteq> D\n  C \\<noteq> D\n  C \\<in> f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  folding.\\<C> \\<equiv> Collect folding.chamber\n  folding.chamber ?C \\<Longrightarrow> folding.chamber (f ` ?C)\n  \\<lbrakk>folding.chamber D; z \\<lhd> D\\<rbrakk>\n  \\<Longrightarrow> f ` z \\<lhd> f ` D\n  \\<lbrakk>folding.chamber D; z \\<lhd> D; folding.chamber (f ` D);\n   z \\<lhd> f ` D; folding.chamber C; z \\<lhd> C; f ` D \\<noteq> D;\n   C \\<noteq> D\\<rbrakk>\n  \\<Longrightarrow> f ` D = C\n\ngoal (1 subgoal):\n 1. f ` D = C", "by    force"], ["proof (state)\nthis:\n  f ` D = C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adjacent_half_chamber_system_image_reverse:\n  \"\\<lbrakk> C \\<in> f\\<turnstile>\\<C>; D \\<in> \\<C>-f\\<turnstile>\\<C>; C\\<sim>D \\<rbrakk> \\<Longrightarrow> opp_chamber C = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding.\\<C>;\n     D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>; C \\<sim> D\\<rbrakk>\n    \\<Longrightarrow> (THE D.\n                          D \\<in> folding.\\<C> -\n                                  f \\<turnstile> folding.\\<C> \\<and>\n                          f ` D = C) =\n                      D", "using adjacent_half_chamber_system_image[of C D]\n        the1_equality[OF folding.folding']"], ["proof (prove)\nusing this:\n  \\<lbrakk>C \\<in> f \\<turnstile> folding.\\<C>;\n   D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>; C \\<sim> D\\<rbrakk>\n  \\<Longrightarrow> f ` D = C\n  \\<lbrakk>?C1 \\<in> f \\<turnstile> folding.\\<C>;\n   ?a \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n   f ` ?a = ?C1\\<rbrakk>\n  \\<Longrightarrow> (THE x.\n                        x \\<in> folding.\\<C> -\n                                f \\<turnstile> folding.\\<C> \\<and>\n                        f ` x = ?C1) =\n                    ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding.\\<C>;\n     D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>; C \\<sim> D\\<rbrakk>\n    \\<Longrightarrow> (THE D.\n                          D \\<in> folding.\\<C> -\n                                  f \\<turnstile> folding.\\<C> \\<and>\n                          f ` D = C) =\n                      D", "by    fastforce"], ["", "lemma chamber_image_closer:\n  assumes \"D\\<in>\\<C>-f\\<turnstile>\\<C>\" \"B\\<in>f\\<turnstile>\\<C>\" \"B\\<noteq>f`D\" \"gallery (B#Ds@[D])\"\n  shows   \"\\<exists>Cs. gallery (B#Cs@[f`D]) \\<and> length Cs < length Ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)", "from assms(1,2,4)"], ["proof (chain)\npicking this:\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<in> f \\<turnstile> folding.\\<C>\n  folding.gallery (B # Ds @ [D])", "obtain As A E Es\n    where split: \"A\\<in>f\\<turnstile>\\<C>\" \"E\\<in>\\<C>-f\\<turnstile>\\<C>\" \"B#Ds@[D] = As@A#E#Es\""], ["proof (prove)\nusing this:\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<in> f \\<turnstile> folding.\\<C>\n  folding.gallery (B # Ds @ [D])\n\ngoal (1 subgoal):\n 1. (\\<And>A E As Es.\n        \\<lbrakk>A \\<in> f \\<turnstile> folding.\\<C>;\n         E \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n         B # Ds @ [D] = As @ A # E # Es\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using folding.split_gallery[of B D Ds]"], ["proof (prove)\nusing this:\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<in> f \\<turnstile> folding.\\<C>\n  folding.gallery (B # Ds @ [D])\n  \\<lbrakk>B \\<in> f \\<turnstile> folding.\\<C>;\n   D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   folding.gallery (B # Ds @ [D])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>As A Ba Bs.\n                       A \\<in> f \\<turnstile> folding.\\<C> \\<and>\n                       Ba \\<in> folding.\\<C> -\n                                f \\<turnstile> folding.\\<C> \\<and>\n                       B # Ds @ [D] = As @ A # Ba # Bs\n\ngoal (1 subgoal):\n 1. (\\<And>A E As Es.\n        \\<lbrakk>A \\<in> f \\<turnstile> folding.\\<C>;\n         E \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n         B # Ds @ [D] = As @ A # E # Es\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    blast"], ["proof (state)\nthis:\n  A \\<in> f \\<turnstile> folding.\\<C>\n  E \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B # Ds @ [D] = As @ A # E # Es\n\ngoal (1 subgoal):\n 1. \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)", "from assms(4) split(3)"], ["proof (chain)\npicking this:\n  folding.gallery (B # Ds @ [D])\n  B # Ds @ [D] = As @ A # E # Es", "have \"A\\<sim>E\""], ["proof (prove)\nusing this:\n  folding.gallery (B # Ds @ [D])\n  B # Ds @ [D] = As @ A # E # Es\n\ngoal (1 subgoal):\n 1. A \\<sim> E", "using gallery_append_reduce2[of As \"A#E#Es\"] galleryD_adj[of \"A#E#Es\"]"], ["proof (prove)\nusing this:\n  folding.gallery (B # Ds @ [D])\n  B # Ds @ [D] = As @ A # E # Es\n  folding.gallery (As @ A # E # Es) \\<Longrightarrow>\n  folding.gallery (A # E # Es)\n  folding.gallery (A # E # Es) \\<Longrightarrow> adjacentchain (A # E # Es)\n\ngoal (1 subgoal):\n 1. A \\<sim> E", "by    simp"], ["proof (state)\nthis:\n  A \\<sim> E\n\ngoal (1 subgoal):\n 1. \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)", "with assms(2) split(1,2)"], ["proof (chain)\npicking this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  A \\<in> f \\<turnstile> folding.\\<C>\n  E \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  A \\<sim> E", "have  fB: \"f`B = B\" and fA: \"f`A = A\" and fE: \"f`E = A\""], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  A \\<in> f \\<turnstile> folding.\\<C>\n  E \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  A \\<sim> E\n\ngoal (1 subgoal):\n 1. f ` B = B &&& f ` A = A &&& f ` E = A", "using folding.chamber_retraction2 adjacent_half_chamber_system_image[of A E]"], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  A \\<in> f \\<turnstile> folding.\\<C>\n  E \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  A \\<sim> E\n  ?C \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow> f ` ?C = ?C\n  \\<lbrakk>A \\<in> f \\<turnstile> folding.\\<C>;\n   E \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>; A \\<sim> E\\<rbrakk>\n  \\<Longrightarrow> f ` E = A\n\ngoal (1 subgoal):\n 1. f ` B = B &&& f ` A = A &&& f ` E = A", "by    auto"], ["proof (state)\nthis:\n  f ` B = B\n  f ` A = A\n  f ` E = A\n\ngoal (1 subgoal):\n 1. \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)", "show \"\\<exists>Cs. gallery (B#Cs@[f`D]) \\<and> length Cs < length Ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)", "proof (cases As)"], ["proof (state)\ngoal (2 subgoals):\n 1. As = [] \\<Longrightarrow>\n    \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)\n 2. \\<And>a list.\n       As = a # list \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "case Nil"], ["proof (state)\nthis:\n  As = []\n\ngoal (2 subgoals):\n 1. As = [] \\<Longrightarrow>\n    \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)\n 2. \\<And>a list.\n       As = a # list \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "have As: \"As = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. As = []", "by fact"], ["proof (state)\nthis:\n  As = []\n\ngoal (2 subgoals):\n 1. As = [] \\<Longrightarrow>\n    \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)\n 2. \\<And>a list.\n       As = a # list \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)", "proof (cases Es rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. Es = [] \\<Longrightarrow>\n    \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)\n 2. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "case Nil"], ["proof (state)\nthis:\n  Es = []\n\ngoal (2 subgoals):\n 1. Es = [] \\<Longrightarrow>\n    \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)\n 2. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "with split(3) As assms(3) fE"], ["proof (chain)\npicking this:\n  B # Ds @ [D] = As @ A # E # Es\n  As = []\n  B \\<noteq> f ` D\n  f ` E = A\n  Es = []", "show ?thesis"], ["proof (prove)\nusing this:\n  B # Ds @ [D] = As @ A # E # Es\n  As = []\n  B \\<noteq> f ` D\n  f ` E = A\n  Es = []\n\ngoal (1 subgoal):\n 1. \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)", "by simp"], ["proof (state)\nthis:\n  \\<exists>Cs.\n     folding.gallery (B # Cs @ [f ` D]) \\<and>\n     order.greater (length Ds) (length Cs)\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "case (snoc Fs F)"], ["proof (state)\nthis:\n  Es = Fs @ [F]\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "with assms(4) split(3) As fE"], ["proof (chain)\npicking this:\n  folding.gallery (B # Ds @ [D])\n  B # Ds @ [D] = As @ A # E # Es\n  As = []\n  f ` E = A\n  Es = Fs @ [F]", "have  \"Ds = E#Fs\" \"gallery (B # f\\<Turnstile>Fs @ [f`D])\""], ["proof (prove)\nusing this:\n  folding.gallery (B # Ds @ [D])\n  B # Ds @ [D] = As @ A # E # Es\n  As = []\n  f ` E = A\n  Es = Fs @ [F]\n\ngoal (1 subgoal):\n 1. Ds = E # Fs &&& folding.gallery (B # f \\<Turnstile> Fs @ [f ` D])", "using fB folding.gallery_map[of \"B#E#Fs@[D]\"] gallery_Cons_reduce"], ["proof (prove)\nusing this:\n  folding.gallery (B # Ds @ [D])\n  B # Ds @ [D] = As @ A # E # Es\n  As = []\n  f ` E = A\n  Es = Fs @ [F]\n  f ` B = B\n  folding.gallery (B # E # Fs @ [D]) \\<Longrightarrow>\n  folding.gallery (f \\<Turnstile> (B # E # Fs @ [D]))\n  folding.gallery (?x # ?xs) \\<Longrightarrow> folding.gallery ?xs\n\ngoal (1 subgoal):\n 1. Ds = E # Fs &&& folding.gallery (B # f \\<Turnstile> Fs @ [f ` D])", "by    auto"], ["proof (state)\nthis:\n  Ds = E # Fs\n  folding.gallery (B # f \\<Turnstile> Fs @ [f ` D])\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Ds = E # Fs\n  folding.gallery (B # f \\<Turnstile> Fs @ [f ` D])\n\ngoal (1 subgoal):\n 1. \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)", "by auto"], ["proof (state)\nthis:\n  \\<exists>Cs.\n     folding.gallery (B # Cs @ [f ` D]) \\<and>\n     order.greater (length Ds) (length Cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Cs.\n     folding.gallery (B # Cs @ [f ` D]) \\<and>\n     order.greater (length Ds) (length Cs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       As = a # list \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       As = a # list \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "case (Cons H Hs)"], ["proof (state)\nthis:\n  As = H # Hs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       As = a # list \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)", "proof (cases Es rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. Es = [] \\<Longrightarrow>\n    \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)\n 2. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "case Nil"], ["proof (state)\nthis:\n  Es = []\n\ngoal (2 subgoals):\n 1. Es = [] \\<Longrightarrow>\n    \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)\n 2. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "with assms(4) Cons split(3)"], ["proof (chain)\npicking this:\n  folding.gallery (B # Ds @ [D])\n  As = H # Hs\n  B # Ds @ [D] = As @ A # E # Es\n  Es = []", "have  decomp: \"Ds = Hs@[A]\" \"D=E\" \"gallery (B#Hs@[A,D])\""], ["proof (prove)\nusing this:\n  folding.gallery (B # Ds @ [D])\n  As = H # Hs\n  B # Ds @ [D] = As @ A # E # Es\n  Es = []\n\ngoal (1 subgoal):\n 1. Ds = Hs @ [A] &&& D = E &&& folding.gallery (B # Hs @ [A, D])", "by    auto"], ["proof (state)\nthis:\n  Ds = Hs @ [A]\n  D = E\n  folding.gallery (B # Hs @ [A, D])\n\ngoal (2 subgoals):\n 1. Es = [] \\<Longrightarrow>\n    \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)\n 2. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "from decomp(2,3) fB fA fE"], ["proof (chain)\npicking this:\n  D = E\n  folding.gallery (B # Hs @ [A, D])\n  f ` B = B\n  f ` A = A\n  f ` E = A", "have \"gallery (B # f\\<Turnstile>Hs @ [f`D])\""], ["proof (prove)\nusing this:\n  D = E\n  folding.gallery (B # Hs @ [A, D])\n  f ` B = B\n  f ` A = A\n  f ` E = A\n\ngoal (1 subgoal):\n 1. folding.gallery (B # f \\<Turnstile> Hs @ [f ` D])", "using folding.gallery_map gallery_append_reduce1[of \"B # f\\<Turnstile>Hs @ [f`D]\"]"], ["proof (prove)\nusing this:\n  D = E\n  folding.gallery (B # Hs @ [A, D])\n  f ` B = B\n  f ` A = A\n  f ` E = A\n  folding.gallery ?Cs \\<Longrightarrow> folding.gallery (f \\<Turnstile> ?Cs)\n  folding.gallery\n   ((B # f \\<Turnstile> Hs @ [f ` D]) @ ?ys) \\<Longrightarrow>\n  folding.gallery (B # f \\<Turnstile> Hs @ [f ` D])\n\ngoal (1 subgoal):\n 1. folding.gallery (B # f \\<Turnstile> Hs @ [f ` D])", "by    force"], ["proof (state)\nthis:\n  folding.gallery (B # f \\<Turnstile> Hs @ [f ` D])\n\ngoal (2 subgoals):\n 1. Es = [] \\<Longrightarrow>\n    \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)\n 2. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "with decomp(1)"], ["proof (chain)\npicking this:\n  Ds = Hs @ [A]\n  folding.gallery (B # f \\<Turnstile> Hs @ [f ` D])", "show ?thesis"], ["proof (prove)\nusing this:\n  Ds = Hs @ [A]\n  folding.gallery (B # f \\<Turnstile> Hs @ [f ` D])\n\ngoal (1 subgoal):\n 1. \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)", "by auto"], ["proof (state)\nthis:\n  \\<exists>Cs.\n     folding.gallery (B # Cs @ [f ` D]) \\<and>\n     order.greater (length Ds) (length Cs)\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "case (snoc Fs F)"], ["proof (state)\nthis:\n  Es = Fs @ [F]\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "with split(3) Cons assms(4) fB fA fE"], ["proof (chain)\npicking this:\n  B # Ds @ [D] = As @ A # E # Es\n  As = H # Hs\n  folding.gallery (B # Ds @ [D])\n  f ` B = B\n  f ` A = A\n  f ` E = A\n  Es = Fs @ [F]", "have  decomp: \"Ds = Hs@A#E#Fs\" \"gallery (B # f\\<Turnstile>(Hs@A#Fs) @ [f`D])\""], ["proof (prove)\nusing this:\n  B # Ds @ [D] = As @ A # E # Es\n  As = H # Hs\n  folding.gallery (B # Ds @ [D])\n  f ` B = B\n  f ` A = A\n  f ` E = A\n  Es = Fs @ [F]\n\ngoal (1 subgoal):\n 1. Ds = Hs @ A # E # Fs &&&\n    folding.gallery (B # f \\<Turnstile> (Hs @ A # Fs) @ [f ` D])", "using folding.gallery_map[of \"B#Hs@A#E#Fs@[D]\"]\n              gallery_remdup_adj[of \"B#f\\<Turnstile>Hs\" A \"f\\<Turnstile>Fs@[f`D]\"]"], ["proof (prove)\nusing this:\n  B # Ds @ [D] = As @ A # E # Es\n  As = H # Hs\n  folding.gallery (B # Ds @ [D])\n  f ` B = B\n  f ` A = A\n  f ` E = A\n  Es = Fs @ [F]\n  folding.gallery (B # Hs @ A # E # Fs @ [D]) \\<Longrightarrow>\n  folding.gallery (f \\<Turnstile> (B # Hs @ A # E # Fs @ [D]))\n  folding.gallery\n   ((B # f \\<Turnstile> Hs) @\n    [A, A] @ f \\<Turnstile> Fs @ [f ` D]) \\<Longrightarrow>\n  folding.gallery\n   ((B # f \\<Turnstile> Hs) @ [A] @ f \\<Turnstile> Fs @ [f ` D])\n\ngoal (1 subgoal):\n 1. Ds = Hs @ A # E # Fs &&&\n    folding.gallery (B # f \\<Turnstile> (Hs @ A # Fs) @ [f ` D])", "by    auto"], ["proof (state)\nthis:\n  Ds = Hs @ A # E # Fs\n  folding.gallery (B # f \\<Turnstile> (Hs @ A # Fs) @ [f ` D])\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "from decomp(1)"], ["proof (chain)\npicking this:\n  Ds = Hs @ A # E # Fs", "have \"length (f\\<Turnstile>(Hs@A#Fs)) < length Ds\""], ["proof (prove)\nusing this:\n  Ds = Hs @ A # E # Fs\n\ngoal (1 subgoal):\n 1. order.greater (length Ds) (length (f \\<Turnstile> (Hs @ A # Fs)))", "by simp"], ["proof (state)\nthis:\n  order.greater (length Ds) (length (f \\<Turnstile> (Hs @ A # Fs)))\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       Es = ys @ [y] \\<Longrightarrow>\n       \\<exists>Cs.\n          folding.gallery (B # Cs @ [f ` D]) \\<and>\n          order.greater (length Ds) (length Cs)", "with decomp(2)"], ["proof (chain)\npicking this:\n  folding.gallery (B # f \\<Turnstile> (Hs @ A # Fs) @ [f ` D])\n  order.greater (length Ds) (length (f \\<Turnstile> (Hs @ A # Fs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  folding.gallery (B # f \\<Turnstile> (Hs @ A # Fs) @ [f ` D])\n  order.greater (length Ds) (length (f \\<Turnstile> (Hs @ A # Fs)))\n\ngoal (1 subgoal):\n 1. \\<exists>Cs.\n       folding.gallery (B # Cs @ [f ` D]) \\<and>\n       order.greater (length Ds) (length Cs)", "by blast"], ["proof (state)\nthis:\n  \\<exists>Cs.\n     folding.gallery (B # Cs @ [f ` D]) \\<and>\n     order.greater (length Ds) (length Cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Cs.\n     folding.gallery (B # Cs @ [f ` D]) \\<and>\n     order.greater (length Ds) (length Cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Cs.\n     folding.gallery (B # Cs @ [f ` D]) \\<and>\n     order.greater (length Ds) (length Cs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chamber_image_subset:\n  assumes D: \"D\\<in>\\<C>-f\\<turnstile>\\<C>\"\n  defines C: \"C \\<equiv> f`D\"\n  defines \"closerToC \\<equiv> {B\\<in>\\<C>. chamber_distance B C < chamber_distance B D}\"\n  shows   \"f\\<turnstile>\\<C> \\<subseteq> closerToC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq closerToC (f \\<turnstile> folding.\\<C>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n       x \\<in> closerToC", "fix B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n       x \\<in> closerToC", "assume B: \"B\\<in>f\\<turnstile>\\<C>\""], ["proof (state)\nthis:\n  B \\<in> f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n       x \\<in> closerToC", "hence B': \"B\\<in>\\<C>\""], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. B \\<in> folding.\\<C>", "using folding.chamber_system_into"], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  order.greater_eq folding.\\<C> (f \\<turnstile> folding.\\<C>)\n\ngoal (1 subgoal):\n 1. B \\<in> folding.\\<C>", "by fast"], ["proof (state)\nthis:\n  B \\<in> folding.\\<C>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n       x \\<in> closerToC", "show \"B \\<in> closerToC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> closerToC", "proof (cases \"B=C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. B = C \\<Longrightarrow> B \\<in> closerToC\n 2. B \\<noteq> C \\<Longrightarrow> B \\<in> closerToC", "case True"], ["proof (state)\nthis:\n  B = C\n\ngoal (2 subgoals):\n 1. B = C \\<Longrightarrow> B \\<in> closerToC\n 2. B \\<noteq> C \\<Longrightarrow> B \\<in> closerToC", "with B D closerToC_def"], ["proof (chain)\npicking this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  closerToC \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B D) (chamber_distance B C)}\n  B = C", "show ?thesis"], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  closerToC \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B D) (chamber_distance B C)}\n  B = C\n\ngoal (1 subgoal):\n 1. B \\<in> closerToC", "using B' chamber_distance_def"], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  closerToC \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B D) (chamber_distance B C)}\n  B = C\n  B \\<in> folding.\\<C>\n  chamber_distance ?C ?D =\n  (if ?C = ?D then 0\n   else Suc (length (ARG_MIN length Cs. folding.gallery (?C # Cs @ [?D]))))\n\ngoal (1 subgoal):\n 1. B \\<in> closerToC", "by auto"], ["proof (state)\nthis:\n  B \\<in> closerToC\n\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> B \\<in> closerToC", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> B \\<in> closerToC", "case False"], ["proof (state)\nthis:\n  B \\<noteq> C\n\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> B \\<in> closerToC", "define Ds where \"Ds = (ARG_MIN length Ds. gallery (B#Ds@[D]))\""], ["proof (state)\nthis:\n  Ds = (ARG_MIN length Ds. folding.gallery (B # Ds @ [D]))\n\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> B \\<in> closerToC", "with B C D False closerToC_def"], ["proof (chain)\npicking this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  C \\<equiv> f ` D\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<noteq> C\n  closerToC \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B D) (chamber_distance B C)}\n  Ds = (ARG_MIN length Ds. folding.gallery (B # Ds @ [D]))", "show ?thesis"], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  C \\<equiv> f ` D\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<noteq> C\n  closerToC \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B D) (chamber_distance B C)}\n  Ds = (ARG_MIN length Ds. folding.gallery (B # Ds @ [D]))\n\ngoal (1 subgoal):\n 1. B \\<in> closerToC", "using chamber_system_def folding.chamber_map gallery_least_length[of B D]\n            chamber_image_closer[of D B Ds]\n            chamber_distance_le chamber_distance_def[of B D]"], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  C \\<equiv> f ` D\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<noteq> C\n  closerToC \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B D) (chamber_distance B C)}\n  Ds = (ARG_MIN length Ds. folding.gallery (B # Ds @ [D]))\n  folding.\\<C> \\<equiv> Collect folding.chamber\n  folding.chamber ?C \\<Longrightarrow> folding.chamber (f ` ?C)\n  \\<lbrakk>folding.chamber B; folding.chamber D; B \\<noteq> D\\<rbrakk>\n  \\<Longrightarrow> folding.gallery\n                     (B #\n                      (ARG_MIN length Cs. folding.gallery (B # Cs @ [D])) @\n                      [D])\n  \\<lbrakk>D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   B \\<in> f \\<turnstile> folding.\\<C>; B \\<noteq> f ` D;\n   folding.gallery (B # Ds @ [D])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Cs.\n                       folding.gallery (B # Cs @ [f ` D]) \\<and>\n                       order.greater (length Ds) (length Cs)\n  folding.gallery (?C # ?Cs @ [?D]) \\<Longrightarrow>\n  order.greater_eq (Suc (length ?Cs)) (chamber_distance ?C ?D)\n  chamber_distance B D =\n  (if B = D then 0\n   else Suc (length (ARG_MIN length Cs. folding.gallery (B # Cs @ [D]))))\n\ngoal (1 subgoal):\n 1. B \\<in> closerToC", "by    fastforce"], ["proof (state)\nthis:\n  B \\<in> closerToC\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B \\<in> closerToC\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gallery_double_cross_not_minimal_Cons1:\n  \"\\<lbrakk> B\\<in>f\\<turnstile>\\<C>; C\\<in>\\<C>-f\\<turnstile>\\<C>; D\\<in>f\\<turnstile>\\<C>; gallery (B#C#Cs@[D]) \\<rbrakk> \\<Longrightarrow>\n    \\<not> min_gallery (B#C#Cs@[D])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<in> f \\<turnstile> folding.\\<C>;\n     C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>;\n     folding.gallery (B # C # Cs @ [D])\\<rbrakk>\n    \\<Longrightarrow> \\<not> min_gallery (B # C # Cs @ [D])", "using galleryD_adj[of \"B#C#Cs@[D]\"]\n        adjacent_half_chamber_system_image[of B C]\n        folding.gallery_map[of \"B#C#Cs@[D]\"]\n        gallery_Cons_reduce[of B \"B # f\\<Turnstile>Cs @ [D]\"]\n        is_arg_minD2[of length \"(\\<lambda>Ds. maxsimpchain (B#Ds@[D]))\" _ \"f\\<Turnstile>Cs\"]\n        min_maxsimpchain.simps(3)[of B \"C#Cs\" D]"], ["proof (prove)\nusing this:\n  folding.gallery (B # C # Cs @ [D]) \\<Longrightarrow>\n  adjacentchain (B # C # Cs @ [D])\n  \\<lbrakk>B \\<in> f \\<turnstile> folding.\\<C>;\n   C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>; B \\<sim> C\\<rbrakk>\n  \\<Longrightarrow> f ` C = B\n  folding.gallery (B # C # Cs @ [D]) \\<Longrightarrow>\n  folding.gallery (f \\<Turnstile> (B # C # Cs @ [D]))\n  folding.gallery (B # B # f \\<Turnstile> Cs @ [D]) \\<Longrightarrow>\n  folding.gallery (B # f \\<Turnstile> Cs @ [D])\n  \\<lbrakk>is_arg_min length (\\<lambda>Ds. folding.gallery (B # Ds @ [D]))\n            ?x;\n   folding.gallery (B # f \\<Turnstile> Cs @ [D])\\<rbrakk>\n  \\<Longrightarrow> \\<not> order.greater (length ?x)\n                            (length (f \\<Turnstile> Cs))\n  min_gallery (B # (C # Cs) @ [D]) =\n  (B \\<noteq> D \\<and>\n   is_arg_min length (\\<lambda>zs. folding.gallery (B # zs @ [D])) (C # Cs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<in> f \\<turnstile> folding.\\<C>;\n     C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>;\n     folding.gallery (B # C # Cs @ [D])\\<rbrakk>\n    \\<Longrightarrow> \\<not> min_gallery (B # C # Cs @ [D])", "by(simp add: folding.chamber_retraction2)(meson impossible_Cons not_less)"], ["", "lemma gallery_double_cross_not_minimal1:\n  \"\\<lbrakk> B\\<in>f\\<turnstile>\\<C>; C\\<in>\\<C>-f\\<turnstile>\\<C>; D\\<in>f\\<turnstile>\\<C>; gallery (B#Bs@C#Cs@[D]) \\<rbrakk> \\<Longrightarrow>\n    \\<not> min_gallery (B#Bs@C#Cs@[D])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<in> f \\<turnstile> folding.\\<C>;\n     C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>;\n     folding.gallery (B # Bs @ C # Cs @ [D])\\<rbrakk>\n    \\<Longrightarrow> \\<not> min_gallery (B # Bs @ C # Cs @ [D])", "proof (induct Bs arbitrary: B)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>B \\<in> f \\<turnstile> folding.\\<C>;\n        C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n        D \\<in> f \\<turnstile> folding.\\<C>;\n        folding.gallery (B # [] @ C # Cs @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<not> min_gallery (B # [] @ C # Cs @ [D])\n 2. \\<And>a Bs B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>B \\<in> f \\<turnstile> folding.\\<C>;\n                    C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n                    D \\<in> f \\<turnstile> folding.\\<C>;\n                    folding.gallery (B # Bs @ C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> \\<not> min_gallery\n       (B # Bs @ C # Cs @ [D]);\n        B \\<in> f \\<turnstile> folding.\\<C>;\n        C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n        D \\<in> f \\<turnstile> folding.\\<C>;\n        folding.gallery (B # (a # Bs) @ C # Cs @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<not> min_gallery (B # (a # Bs) @ C # Cs @ [D])", "case Nil"], ["proof (state)\nthis:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n  folding.gallery (B # [] @ C # Cs @ [D])\n\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>B \\<in> f \\<turnstile> folding.\\<C>;\n        C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n        D \\<in> f \\<turnstile> folding.\\<C>;\n        folding.gallery (B # [] @ C # Cs @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<not> min_gallery (B # [] @ C # Cs @ [D])\n 2. \\<And>a Bs B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>B \\<in> f \\<turnstile> folding.\\<C>;\n                    C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n                    D \\<in> f \\<turnstile> folding.\\<C>;\n                    folding.gallery (B # Bs @ C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> \\<not> min_gallery\n       (B # Bs @ C # Cs @ [D]);\n        B \\<in> f \\<turnstile> folding.\\<C>;\n        C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n        D \\<in> f \\<turnstile> folding.\\<C>;\n        folding.gallery (B # (a # Bs) @ C # Cs @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<not> min_gallery (B # (a # Bs) @ C # Cs @ [D])", "thus ?case"], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n  folding.gallery (B # [] @ C # Cs @ [D])\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (B # [] @ C # Cs @ [D])", "using gallery_double_cross_not_minimal_Cons1"], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n  folding.gallery (B # [] @ C # Cs @ [D])\n  \\<lbrakk>?B \\<in> f \\<turnstile> folding.\\<C>;\n   ?C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   ?D \\<in> f \\<turnstile> folding.\\<C>;\n   folding.gallery (?B # ?C # ?Cs @ [?D])\\<rbrakk>\n  \\<Longrightarrow> \\<not> min_gallery (?B # ?C # ?Cs @ [?D])\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (B # [] @ C # Cs @ [D])", "by simp"], ["proof (state)\nthis:\n  \\<not> min_gallery (B # [] @ C # Cs @ [D])\n\ngoal (1 subgoal):\n 1. \\<And>a Bs B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>B \\<in> f \\<turnstile> folding.\\<C>;\n                    C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n                    D \\<in> f \\<turnstile> folding.\\<C>;\n                    folding.gallery (B # Bs @ C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> \\<not> min_gallery\n       (B # Bs @ C # Cs @ [D]);\n        B \\<in> f \\<turnstile> folding.\\<C>;\n        C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n        D \\<in> f \\<turnstile> folding.\\<C>;\n        folding.gallery (B # (a # Bs) @ C # Cs @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<not> min_gallery (B # (a # Bs) @ C # Cs @ [D])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Bs B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>B \\<in> f \\<turnstile> folding.\\<C>;\n                    C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n                    D \\<in> f \\<turnstile> folding.\\<C>;\n                    folding.gallery (B # Bs @ C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> \\<not> min_gallery\n       (B # Bs @ C # Cs @ [D]);\n        B \\<in> f \\<turnstile> folding.\\<C>;\n        C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n        D \\<in> f \\<turnstile> folding.\\<C>;\n        folding.gallery (B # (a # Bs) @ C # Cs @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<not> min_gallery (B # (a # Bs) @ C # Cs @ [D])", "case (Cons E Es)"], ["proof (state)\nthis:\n  \\<lbrakk>?B2 \\<in> f \\<turnstile> folding.\\<C>;\n   C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   D \\<in> f \\<turnstile> folding.\\<C>;\n   folding.gallery (?B2 # Es @ C # Cs @ [D])\\<rbrakk>\n  \\<Longrightarrow> \\<not> min_gallery (?B2 # Es @ C # Cs @ [D])\n  B \\<in> f \\<turnstile> folding.\\<C>\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n  folding.gallery (B # (E # Es) @ C # Cs @ [D])\n\ngoal (1 subgoal):\n 1. \\<And>a Bs B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>B \\<in> f \\<turnstile> folding.\\<C>;\n                    C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n                    D \\<in> f \\<turnstile> folding.\\<C>;\n                    folding.gallery (B # Bs @ C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> \\<not> min_gallery\n       (B # Bs @ C # Cs @ [D]);\n        B \\<in> f \\<turnstile> folding.\\<C>;\n        C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n        D \\<in> f \\<turnstile> folding.\\<C>;\n        folding.gallery (B # (a # Bs) @ C # Cs @ [D])\\<rbrakk>\n       \\<Longrightarrow> \\<not> min_gallery (B # (a # Bs) @ C # Cs @ [D])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])", "proof (cases \"E\\<in>f\\<turnstile>\\<C>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. E \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n    \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])\n 2. E \\<notin> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n    \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])", "case True"], ["proof (state)\nthis:\n  E \\<in> f \\<turnstile> folding.\\<C>\n\ngoal (2 subgoals):\n 1. E \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n    \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])\n 2. E \\<notin> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n    \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])", "with Cons(1,3-5)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?B2 \\<in> f \\<turnstile> folding.\\<C>;\n   C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   D \\<in> f \\<turnstile> folding.\\<C>;\n   folding.gallery (?B2 # Es @ C # Cs @ [D])\\<rbrakk>\n  \\<Longrightarrow> \\<not> min_gallery (?B2 # Es @ C # Cs @ [D])\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n  folding.gallery (B # (E # Es) @ C # Cs @ [D])\n  E \\<in> f \\<turnstile> folding.\\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?B2 \\<in> f \\<turnstile> folding.\\<C>;\n   C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   D \\<in> f \\<turnstile> folding.\\<C>;\n   folding.gallery (?B2 # Es @ C # Cs @ [D])\\<rbrakk>\n  \\<Longrightarrow> \\<not> min_gallery (?B2 # Es @ C # Cs @ [D])\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n  folding.gallery (B # (E # Es) @ C # Cs @ [D])\n  E \\<in> f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])", "using gallery_Cons_reduce[of B \"E#Es@C#Cs@[D]\"]\n            min_gallery_betw_CCons_reduce[of B E \"Es@C#Cs\" D]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?B2 \\<in> f \\<turnstile> folding.\\<C>;\n   C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   D \\<in> f \\<turnstile> folding.\\<C>;\n   folding.gallery (?B2 # Es @ C # Cs @ [D])\\<rbrakk>\n  \\<Longrightarrow> \\<not> min_gallery (?B2 # Es @ C # Cs @ [D])\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n  folding.gallery (B # (E # Es) @ C # Cs @ [D])\n  E \\<in> f \\<turnstile> folding.\\<C>\n  folding.gallery (B # E # Es @ C # Cs @ [D]) \\<Longrightarrow>\n  folding.gallery (E # Es @ C # Cs @ [D])\n  min_gallery (B # E # (Es @ C # Cs) @ [D]) \\<Longrightarrow>\n  min_gallery (E # (Es @ C # Cs) @ [D])\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])", "by    auto"], ["proof (state)\nthis:\n  \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])\n\ngoal (1 subgoal):\n 1. E \\<notin> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n    \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. E \\<notin> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n    \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])", "case False"], ["proof (state)\nthis:\n  E \\<notin> f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. E \\<notin> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n    \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])", "with Cons(2,4,5)"], ["proof (chain)\npicking this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n  folding.gallery (B # (E # Es) @ C # Cs @ [D])\n  E \\<notin> f \\<turnstile> folding.\\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n  folding.gallery (B # (E # Es) @ C # Cs @ [D])\n  E \\<notin> f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])", "using gallery_chamber_system\n            gallery_double_cross_not_minimal_Cons1[of B E D \"Es@C#Cs\"]"], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n  folding.gallery (B # (E # Es) @ C # Cs @ [D])\n  E \\<notin> f \\<turnstile> folding.\\<C>\n  folding.gallery ?Cs \\<Longrightarrow>\n  order.greater_eq folding.\\<C> (set ?Cs)\n  \\<lbrakk>B \\<in> f \\<turnstile> folding.\\<C>;\n   E \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   D \\<in> f \\<turnstile> folding.\\<C>;\n   folding.gallery (B # E # (Es @ C # Cs) @ [D])\\<rbrakk>\n  \\<Longrightarrow> \\<not> min_gallery (B # E # (Es @ C # Cs) @ [D])\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])", "by    force"], ["proof (state)\nthis:\n  \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> min_gallery (B # (E # Es) @ C # Cs @ [D])\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* ThinishChamberComplexFolding *)"], ["", "locale ThinChamberComplexFolding =\n  ThinChamberComplex X + folding: ChamberComplexFolding X f\n  for X :: \"'a set set\"\n  and f :: \"'a\\<Rightarrow>'a\""], ["", "sublocale ThinChamberComplexFolding < ThinishChamberComplexFolding"], ["proof (prove)\ngoal (1 subgoal):\n 1. ThinishChamberComplexFolding X f", ".."], ["", "context ThinChamberComplexFolding\nbegin"], ["", "abbreviation \"flop \\<equiv> folding.flop\""], ["", "lemmas adjacent_half_chamber_system_image = adjacent_half_chamber_system_image"], ["", "lemmas gallery_double_cross_not_minimal1  = gallery_double_cross_not_minimal1"], ["", "lemmas gallery_double_cross_not_minimal_Cons1 =\n  gallery_double_cross_not_minimal_Cons1"], ["", "lemma adjacent_preimage:\n  assumes chambers: \"C \\<in> \\<C>-f\\<turnstile>\\<C>\" \"D \\<in> \\<C>-f\\<turnstile>\\<C>\"\n  and     adjacent: \"f`C \\<sim> f`D\"\n  shows \"C \\<sim> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<sim> D", "proof (cases \"f`C=f`D\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f ` C = f ` D \\<Longrightarrow> C \\<sim> D\n 2. f ` C \\<noteq> f ` D \\<Longrightarrow> C \\<sim> D", "case True"], ["proof (state)\nthis:\n  f ` C = f ` D\n\ngoal (2 subgoals):\n 1. f ` C = f ` D \\<Longrightarrow> C \\<sim> D\n 2. f ` C \\<noteq> f ` D \\<Longrightarrow> C \\<sim> D", "with chambers"], ["proof (chain)\npicking this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  f ` C = f ` D", "show \"C \\<sim> D\""], ["proof (prove)\nusing this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  f ` C = f ` D\n\ngoal (1 subgoal):\n 1. C \\<sim> D", "using folding.inj_on_opp_chambers''[of C D] adjacent_refl[of C]"], ["proof (prove)\nusing this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  f ` C = f ` D\n  \\<lbrakk>C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   f ` C = f ` D\\<rbrakk>\n  \\<Longrightarrow> C = D\n  C \\<noteq> {} \\<Longrightarrow> C \\<sim> C\n\ngoal (1 subgoal):\n 1. C \\<sim> D", "by auto"], ["proof (state)\nthis:\n  C \\<sim> D\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> C \\<sim> D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> C \\<sim> D", "case False"], ["proof (state)\nthis:\n  f ` C \\<noteq> f ` D\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> C \\<sim> D", "from chambers"], ["proof (chain)\npicking this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>", "have CD: \"chamber C\" \"chamber D\""], ["proof (prove)\nusing this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. folding.chamber C &&& folding.chamber D", "using chamber_system_def"], ["proof (prove)\nusing this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  folding.\\<C> \\<equiv> Collect folding.chamber\n\ngoal (1 subgoal):\n 1. folding.chamber C &&& folding.chamber D", "by auto"], ["proof (state)\nthis:\n  folding.chamber C\n  folding.chamber D\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> C \\<sim> D", "hence ch_fCD: \"chamber (f`C)\" \"chamber (f`D)\""], ["proof (prove)\nusing this:\n  folding.chamber C\n  folding.chamber D\n\ngoal (1 subgoal):\n 1. folding.chamber (f ` C) &&& folding.chamber (f ` D)", "using chamber_system_def folding.chamber_map"], ["proof (prove)\nusing this:\n  folding.chamber C\n  folding.chamber D\n  folding.\\<C> \\<equiv> Collect folding.chamber\n  folding.chamber ?C \\<Longrightarrow> folding.chamber (f ` ?C)\n\ngoal (1 subgoal):\n 1. folding.chamber (f ` C) &&& folding.chamber (f ` D)", "by auto"], ["proof (state)\nthis:\n  folding.chamber (f ` C)\n  folding.chamber (f ` D)\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> C \\<sim> D", "from adjacent"], ["proof (chain)\npicking this:\n  f ` C \\<sim> f ` D", "obtain z where z: \"z \\<lhd> f`C\" \"z \\<lhd> f`D\""], ["proof (prove)\nusing this:\n  f ` C \\<sim> f ` D\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<lhd> f ` C; z \\<lhd> f ` D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using adjacent_def"], ["proof (prove)\nusing this:\n  f ` C \\<sim> f ` D\n  ?x \\<sim> ?y \\<equiv> \\<exists>z. z \\<lhd> ?x \\<and> z \\<lhd> ?y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<lhd> f ` C; z \\<lhd> f ` D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  z \\<lhd> f ` C\n  z \\<lhd> f ` D\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> C \\<sim> D", "from chambers(1) z(1)"], ["proof (chain)\npicking this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  z \\<lhd> f ` C", "obtain y where y: \"y \\<lhd> C\" \"f`y = z\""], ["proof (prove)\nusing this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  z \\<lhd> f ` C\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<lhd> C; f ` y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using chamber_system_def folding.inj_on_chamber[of C]\n          inj_on_pullback_facet[of f C z]"], ["proof (prove)\nusing this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  z \\<lhd> f ` C\n  folding.\\<C> \\<equiv> Collect folding.chamber\n  folding.chamber C \\<Longrightarrow> inj_on f C\n  \\<lbrakk>inj_on f C; z \\<lhd> f ` C;\n   \\<And>y.\n      \\<lbrakk>y \\<lhd> C; f ` y = z\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<lhd> C; f ` y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  y \\<lhd> C\n  f ` y = z\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> C \\<sim> D", "define B where \"B = the_adj_chamber C y\""], ["proof (state)\nthis:\n  B = the_adj_chamber C y\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> C \\<sim> D", "with CD(1) y(1)"], ["proof (chain)\npicking this:\n  folding.chamber C\n  y \\<lhd> C\n  B = the_adj_chamber C y", "have B: \"chamber B\" \"y\\<lhd>B\" \"B\\<noteq>C\""], ["proof (prove)\nusing this:\n  folding.chamber C\n  y \\<lhd> C\n  B = the_adj_chamber C y\n\ngoal (1 subgoal):\n 1. folding.chamber B &&& y \\<lhd> B &&& B \\<noteq> C", "using the_adj_chamber the_adj_chamber_facet the_adj_chamber_neq"], ["proof (prove)\nusing this:\n  folding.chamber C\n  y \\<lhd> C\n  B = the_adj_chamber C y\n  \\<lbrakk>folding.chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> folding.chamber (the_adj_chamber ?C ?z)\n  \\<lbrakk>folding.chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> ?z \\<lhd> the_adj_chamber ?C ?z\n  \\<lbrakk>folding.chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> the_adj_chamber ?C ?z \\<noteq> ?C\n\ngoal (1 subgoal):\n 1. folding.chamber B &&& y \\<lhd> B &&& B \\<noteq> C", "by auto"], ["proof (state)\nthis:\n  folding.chamber B\n  y \\<lhd> B\n  B \\<noteq> C\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> C \\<sim> D", "have \"f`B \\<noteq> f`C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` B \\<noteq> f ` C", "proof (cases \"B \\<in> f\\<turnstile>\\<C>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. B \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n    f ` B \\<noteq> f ` C\n 2. B \\<notin> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n    f ` B \\<noteq> f ` C", "case False"], ["proof (state)\nthis:\n  B \\<notin> f \\<turnstile> folding.\\<C>\n\ngoal (2 subgoals):\n 1. B \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n    f ` B \\<noteq> f ` C\n 2. B \\<notin> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n    f ` B \\<noteq> f ` C", "with chambers(1)"], ["proof (chain)\npicking this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<notin> f \\<turnstile> folding.\\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<notin> f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. f ` B \\<noteq> f ` C", "using B(1,3) chamber_system_def folding.inj_on_opp_chambers''[of B]"], ["proof (prove)\nusing this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<notin> f \\<turnstile> folding.\\<C>\n  folding.chamber B\n  B \\<noteq> C\n  folding.\\<C> \\<equiv> Collect folding.chamber\n  \\<lbrakk>B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   ?D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   f ` B = f ` ?D\\<rbrakk>\n  \\<Longrightarrow> B = ?D\n\ngoal (1 subgoal):\n 1. f ` B \\<noteq> f ` C", "by    auto"], ["proof (state)\nthis:\n  f ` B \\<noteq> f ` C\n\ngoal (1 subgoal):\n 1. B \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n    f ` B \\<noteq> f ` C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n    f ` B \\<noteq> f ` C", "case True"], ["proof (state)\nthis:\n  B \\<in> f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. B \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n    f ` B \\<noteq> f ` C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` B \\<noteq> f ` C", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. f ` B = f ` C \\<Longrightarrow> False", "assume fB_fC: \"f`B = f`C\""], ["proof (state)\nthis:\n  f ` B = f ` C\n\ngoal (1 subgoal):\n 1. f ` B = f ` C \\<Longrightarrow> False", "with True"], ["proof (chain)\npicking this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  f ` B = f ` C", "have \"B = f`C\""], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  f ` B = f ` C\n\ngoal (1 subgoal):\n 1. B = f ` C", "using folding.chamber_retraction2"], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding.\\<C>\n  f ` B = f ` C\n  ?C \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow> f ` ?C = ?C\n\ngoal (1 subgoal):\n 1. B = f ` C", "by auto"], ["proof (state)\nthis:\n  B = f ` C\n\ngoal (1 subgoal):\n 1. f ` B = f ` C \\<Longrightarrow> False", "with z(1) y(2) B(2) chambers(1)"], ["proof (chain)\npicking this:\n  z \\<lhd> f ` C\n  f ` y = z\n  y \\<lhd> B\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B = f ` C", "have \"y = z\""], ["proof (prove)\nusing this:\n  z \\<lhd> f ` C\n  f ` y = z\n  y \\<lhd> B\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B = f ` C\n\ngoal (1 subgoal):\n 1. y = z", "using facetrel_subset[of y B] chamber_system_def chamberD_simplex face_im\n              folding.simplex_retraction2[of y]"], ["proof (prove)\nusing this:\n  z \\<lhd> f ` C\n  f ` y = z\n  y \\<lhd> B\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B = f ` C\n  y \\<lhd> B \\<Longrightarrow> order.greater_eq B y\n  folding.\\<C> \\<equiv> Collect folding.chamber\n  folding.chamber ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>?w \\<in> X; order.greater_eq (?f ` ?w) ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> ?f \\<turnstile> X\n  y \\<in> f \\<turnstile> X \\<Longrightarrow> f ` y = y\n\ngoal (1 subgoal):\n 1. y = z", "by    force"], ["proof (state)\nthis:\n  y = z\n\ngoal (1 subgoal):\n 1. f ` B = f ` C \\<Longrightarrow> False", "with chambers y(1) z(2)"], ["proof (chain)\npicking this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  y \\<lhd> C\n  z \\<lhd> f ` D\n  y = z", "have \"f`D = B\""], ["proof (prove)\nusing this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  y \\<lhd> C\n  z \\<lhd> f ` D\n  y = z\n\ngoal (1 subgoal):\n 1. f ` D = B", "using CD(1) ch_fCD(2) B facet_unique_other_chamber[of C y]"], ["proof (prove)\nusing this:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  y \\<lhd> C\n  z \\<lhd> f ` D\n  y = z\n  folding.chamber C\n  folding.chamber (f ` D)\n  folding.chamber B\n  y \\<lhd> B\n  B \\<noteq> C\n  \\<lbrakk>folding.chamber C; y \\<lhd> C; folding.chamber ?C; y \\<lhd> ?C;\n   folding.chamber ?D; y \\<lhd> ?D; ?C \\<noteq> C; ?D \\<noteq> C\\<rbrakk>\n  \\<Longrightarrow> ?C = ?D\n\ngoal (1 subgoal):\n 1. f ` D = B", "by auto"], ["proof (state)\nthis:\n  f ` D = B\n\ngoal (1 subgoal):\n 1. f ` B = f ` C \\<Longrightarrow> False", "with z(2) chambers fB_fC False"], ["proof (chain)\npicking this:\n  z \\<lhd> f ` D\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  f ` B = f ` C\n  f ` C \\<noteq> f ` D\n  f ` D = B", "show False"], ["proof (prove)\nusing this:\n  z \\<lhd> f ` D\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  f ` B = f ` C\n  f ` C \\<noteq> f ` D\n  f ` D = B\n\ngoal (1 subgoal):\n 1. False", "using folding.chamber_retraction2"], ["proof (prove)\nusing this:\n  z \\<lhd> f ` D\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  f ` B = f ` C\n  f ` C \\<noteq> f ` D\n  f ` D = B\n  ?C \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow> f ` ?C = ?C\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f ` B \\<noteq> f ` C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f ` B \\<noteq> f ` C\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> C \\<sim> D", "with False z y(2)"], ["proof (chain)\npicking this:\n  f ` C \\<noteq> f ` D\n  z \\<lhd> f ` C\n  z \\<lhd> f ` D\n  f ` y = z\n  f ` B \\<noteq> f ` C", "have fB_fD: \"f`B = f`D\""], ["proof (prove)\nusing this:\n  f ` C \\<noteq> f ` D\n  z \\<lhd> f ` C\n  z \\<lhd> f ` D\n  f ` y = z\n  f ` B \\<noteq> f ` C\n\ngoal (1 subgoal):\n 1. f ` B = f ` D", "using ch_fCD B(1,2) folding.chamber_map folding.facet_map\n          facet_unique_other_chamber[of \"f`C\" z]"], ["proof (prove)\nusing this:\n  f ` C \\<noteq> f ` D\n  z \\<lhd> f ` C\n  z \\<lhd> f ` D\n  f ` y = z\n  f ` B \\<noteq> f ` C\n  folding.chamber (f ` C)\n  folding.chamber (f ` D)\n  folding.chamber B\n  y \\<lhd> B\n  folding.chamber ?C \\<Longrightarrow> folding.chamber (f ` ?C)\n  \\<lbrakk>folding.chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> f ` ?z \\<lhd> f ` ?C\n  \\<lbrakk>folding.chamber (f ` C); z \\<lhd> f ` C; folding.chamber ?C;\n   z \\<lhd> ?C; folding.chamber ?D; z \\<lhd> ?D; ?C \\<noteq> f ` C;\n   ?D \\<noteq> f ` C\\<rbrakk>\n  \\<Longrightarrow> ?C = ?D\n\ngoal (1 subgoal):\n 1. f ` B = f ` D", "by    force"], ["proof (state)\nthis:\n  f ` B = f ` D\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> C \\<sim> D", "have \"B = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = D", "proof (cases \"B \\<in> f\\<turnstile>\\<C>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. B \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow> B = D\n 2. B \\<notin> f \\<turnstile> folding.\\<C> \\<Longrightarrow> B = D", "case False"], ["proof (state)\nthis:\n  B \\<notin> f \\<turnstile> folding.\\<C>\n\ngoal (2 subgoals):\n 1. B \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow> B = D\n 2. B \\<notin> f \\<turnstile> folding.\\<C> \\<Longrightarrow> B = D", "with B(1) chambers(2)"], ["proof (chain)\npicking this:\n  folding.chamber B\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<notin> f \\<turnstile> folding.\\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  folding.chamber B\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<notin> f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. B = D", "using chamber_system_def fB_fD folding.inj_on_opp_chambers''"], ["proof (prove)\nusing this:\n  folding.chamber B\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<notin> f \\<turnstile> folding.\\<C>\n  folding.\\<C> \\<equiv> Collect folding.chamber\n  f ` B = f ` D\n  \\<lbrakk>?C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   ?D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   f ` ?C = f ` ?D\\<rbrakk>\n  \\<Longrightarrow> ?C = ?D\n\ngoal (1 subgoal):\n 1. B = D", "by simp"], ["proof (state)\nthis:\n  B = D\n\ngoal (1 subgoal):\n 1. B \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow> B = D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow> B = D", "case True"], ["proof (state)\nthis:\n  B \\<in> f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. B \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow> B = D", "with fB_fD"], ["proof (chain)\npicking this:\n  f ` B = f ` D\n  B \\<in> f \\<turnstile> folding.\\<C>", "have \"B = f`D\""], ["proof (prove)\nusing this:\n  f ` B = f ` D\n  B \\<in> f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. B = f ` D", "using folding.chamber_retraction2"], ["proof (prove)\nusing this:\n  f ` B = f ` D\n  B \\<in> f \\<turnstile> folding.\\<C>\n  ?C \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow> f ` ?C = ?C\n\ngoal (1 subgoal):\n 1. B = f ` D", "by auto"], ["proof (state)\nthis:\n  B = f ` D\n\ngoal (1 subgoal):\n 1. B \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow> B = D", "moreover"], ["proof (state)\nthis:\n  B = f ` D\n\ngoal (1 subgoal):\n 1. B \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow> B = D", "with z(1) y(2) B(2) chambers(2)"], ["proof (chain)\npicking this:\n  z \\<lhd> f ` C\n  f ` y = z\n  y \\<lhd> B\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B = f ` D", "have \"y = z\""], ["proof (prove)\nusing this:\n  z \\<lhd> f ` C\n  f ` y = z\n  y \\<lhd> B\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B = f ` D\n\ngoal (1 subgoal):\n 1. y = z", "using facetrel_subset[of y B] chamber_system_def chamberD_simplex face_im\n            folding.simplex_retraction2[of y]"], ["proof (prove)\nusing this:\n  z \\<lhd> f ` C\n  f ` y = z\n  y \\<lhd> B\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B = f ` D\n  y \\<lhd> B \\<Longrightarrow> order.greater_eq B y\n  folding.\\<C> \\<equiv> Collect folding.chamber\n  folding.chamber ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>?w \\<in> X; order.greater_eq (?f ` ?w) ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> ?f \\<turnstile> X\n  y \\<in> f \\<turnstile> X \\<Longrightarrow> f ` y = y\n\ngoal (1 subgoal):\n 1. y = z", "by    force"], ["proof (state)\nthis:\n  y = z\n\ngoal (1 subgoal):\n 1. B \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow> B = D", "ultimately"], ["proof (chain)\npicking this:\n  B = f ` D\n  y = z", "show ?thesis"], ["proof (prove)\nusing this:\n  B = f ` D\n  y = z\n\ngoal (1 subgoal):\n 1. B = D", "using CD y(1) B ch_fCD(1) z(1) False chambers(1)\n            facet_unique_other_chamber[of B y C \"f`C\"]"], ["proof (prove)\nusing this:\n  B = f ` D\n  y = z\n  folding.chamber C\n  folding.chamber D\n  y \\<lhd> C\n  folding.chamber B\n  y \\<lhd> B\n  B \\<noteq> C\n  folding.chamber (f ` C)\n  z \\<lhd> f ` C\n  f ` C \\<noteq> f ` D\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  \\<lbrakk>folding.chamber B; y \\<lhd> B; folding.chamber C; y \\<lhd> C;\n   folding.chamber (f ` C); y \\<lhd> f ` C; C \\<noteq> B;\n   f ` C \\<noteq> B\\<rbrakk>\n  \\<Longrightarrow> C = f ` C\n\ngoal (1 subgoal):\n 1. B = D", "by    auto"], ["proof (state)\nthis:\n  B = D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B = D\n\ngoal (1 subgoal):\n 1. f ` C \\<noteq> f ` D \\<Longrightarrow> C \\<sim> D", "with y(1) B(2)"], ["proof (chain)\npicking this:\n  y \\<lhd> C\n  y \\<lhd> B\n  B = D", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<lhd> C\n  y \\<lhd> B\n  B = D\n\ngoal (1 subgoal):\n 1. C \\<sim> D", "using adjacentI"], ["proof (prove)\nusing this:\n  y \\<lhd> C\n  y \\<lhd> B\n  B = D\n  \\<lbrakk>?z \\<lhd> ?x; ?z \\<lhd> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<sim> ?y\n\ngoal (1 subgoal):\n 1. C \\<sim> D", "by fast"], ["proof (state)\nthis:\n  C \\<sim> D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adjacent_opp_chamber:\n  \"\\<lbrakk> C\\<in>f\\<turnstile>\\<C>; D\\<in>f\\<turnstile>\\<C>; C\\<sim>D \\<rbrakk> \\<Longrightarrow> opp_chamber C \\<sim> opp_chamber D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>; C \\<sim> D\\<rbrakk>\n    \\<Longrightarrow> (THE D.\n                          D \\<in> folding.\\<C> -\n                                  f \\<turnstile> folding.\\<C> \\<and>\n                          f ` D = C) \\<sim>\n                      (THE Da.\n                          Da \\<in> folding.\\<C> -\n                                   f \\<turnstile> folding.\\<C> \\<and>\n                          f ` Da = D)", "using folding.opp_chamberD1 folding.opp_chamberD2 adjacent_preimage"], ["proof (prove)\nusing this:\n  ?C \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n  (THE D.\n      D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and> f ` D = ?C)\n  \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  ?C \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n  f `\n  (THE D.\n      D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n      f ` D = ?C) =\n  ?C\n  \\<lbrakk>?C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   ?D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   f ` ?C \\<sim> f ` ?D\\<rbrakk>\n  \\<Longrightarrow> ?C \\<sim> ?D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>; C \\<sim> D\\<rbrakk>\n    \\<Longrightarrow> (THE D.\n                          D \\<in> folding.\\<C> -\n                                  f \\<turnstile> folding.\\<C> \\<and>\n                          f ` D = C) \\<sim>\n                      (THE Da.\n                          Da \\<in> folding.\\<C> -\n                                   f \\<turnstile> folding.\\<C> \\<and>\n                          f ` Da = D)", "by simp"], ["", "lemma adjacentchain_preimage: \n  \"set Cs \\<subseteq> \\<C>-f\\<turnstile>\\<C> \\<Longrightarrow> adjacentchain (f\\<Turnstile>Cs) \\<Longrightarrow> adjacentchain Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n              (set Cs);\n     adjacentchain (f \\<Turnstile> Cs)\\<rbrakk>\n    \\<Longrightarrow> adjacentchain Cs", "using adjacent_preimage"], ["proof (prove)\nusing this:\n  \\<lbrakk>?C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   ?D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   f ` ?C \\<sim> f ` ?D\\<rbrakk>\n  \\<Longrightarrow> ?C \\<sim> ?D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n              (set Cs);\n     adjacentchain (f \\<Turnstile> Cs)\\<rbrakk>\n    \\<Longrightarrow> adjacentchain Cs", "by (induct Cs rule: list_induct_CCons) auto"], ["", "lemma gallery_preimage: \"set Cs \\<subseteq> \\<C>-f\\<turnstile>\\<C> \\<Longrightarrow> gallery (f\\<Turnstile>Cs) \\<Longrightarrow> gallery Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n              (set Cs);\n     folding.gallery (f \\<Turnstile> Cs)\\<rbrakk>\n    \\<Longrightarrow> folding.gallery Cs", "using galleryD_adj adjacentchain_preimage chamber_system_def gallery_def"], ["proof (prove)\nusing this:\n  folding.gallery ?xs \\<Longrightarrow> adjacentchain ?xs\n  \\<lbrakk>order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n            (set ?Cs);\n   adjacentchain (f \\<Turnstile> ?Cs)\\<rbrakk>\n  \\<Longrightarrow> adjacentchain ?Cs\n  folding.\\<C> \\<equiv> Collect folding.chamber\n  folding.gallery ?xs \\<equiv>\n  Ball (set ?xs) folding.chamber \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n              (set Cs);\n     folding.gallery (f \\<Turnstile> Cs)\\<rbrakk>\n    \\<Longrightarrow> folding.gallery Cs", "by    fast"], ["", "lemma chambercomplex_opp_half_apartment: \"ChamberComplex folding.Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplex folding.Y", "proof (intro_locales, rule folding.simplicialcomplex_opp_half_apartment, unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> folding.Y \\<Longrightarrow>\n       \\<exists>x.\n          SimplicialComplex.maxsimp folding.Y x \\<and> order.greater_eq x y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "define Y where \"Y = folding.Y\""], ["proof (state)\nthis:\n  Y = folding.Y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> folding.Y \\<Longrightarrow>\n       \\<exists>x.\n          SimplicialComplex.maxsimp folding.Y x \\<and> order.greater_eq x y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> folding.Y \\<Longrightarrow>\n       \\<exists>x.\n          SimplicialComplex.maxsimp folding.Y x \\<and> order.greater_eq x y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "assume \"y\\<in>Y\""], ["proof (state)\nthis:\n  y \\<in> Y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> folding.Y \\<Longrightarrow>\n       \\<exists>x.\n          SimplicialComplex.maxsimp folding.Y x \\<and> order.greater_eq x y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "with Y_def"], ["proof (chain)\npicking this:\n  Y = folding.Y\n  y \\<in> Y", "obtain C where \"C\\<in>\\<C>-f\\<turnstile>\\<C>\" \"y\\<subseteq>C\""], ["proof (prove)\nusing this:\n  Y = folding.Y\n  y \\<in> Y\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n         order.greater_eq C y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using folding.opp_half_apartment_def"], ["proof (prove)\nusing this:\n  Y = folding.Y\n  y \\<in> Y\n  folding.Y \\<equiv>\n  {x \\<in> X.\n   \\<exists>C\\<in>folding.\\<C> - f \\<turnstile> folding.\\<C>.\n      order.greater_eq C x}\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n         order.greater_eq C y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  order.greater_eq C y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> folding.Y \\<Longrightarrow>\n       \\<exists>x.\n          SimplicialComplex.maxsimp folding.Y x \\<and> order.greater_eq x y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "with Y_def"], ["proof (chain)\npicking this:\n  Y = folding.Y\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  order.greater_eq C y", "show \"\\<exists>x. SimplicialComplex.maxsimp Y x \\<and> y \\<subseteq> x\""], ["proof (prove)\nusing this:\n  Y = folding.Y\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  order.greater_eq C y\n\ngoal (1 subgoal):\n 1. \\<exists>x. SimplicialComplex.maxsimp Y x \\<and> order.greater_eq x y", "using folding.subcomplex_opp_half_apartment\n          folding.opp_chambers_subset_opp_half_apartment\n          chamber_system_def max_in_subcomplex[of Y]"], ["proof (prove)\nusing this:\n  Y = folding.Y\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  order.greater_eq C y\n  order.greater_eq X folding.Y \\<and> SimplicialComplex folding.Y\n  order.greater_eq folding.Y (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n  folding.\\<C> \\<equiv> Collect folding.chamber\n  \\<lbrakk>order.greater_eq X Y \\<and> SimplicialComplex Y; ?y \\<in> Y;\n   folding.chamber ?y\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp Y ?y\n\ngoal (1 subgoal):\n 1. \\<exists>x. SimplicialComplex.maxsimp Y x \\<and> order.greater_eq x y", "by    force"], ["proof (state)\nthis:\n  \\<exists>x. SimplicialComplex.maxsimp Y x \\<and> order.greater_eq x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "define Y where \"Y = folding.Y\""], ["proof (state)\nthis:\n  Y = folding.Y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "fix C D"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "assume CD:  \"SimplicialComplex.maxsimp Y C\" \"SimplicialComplex.maxsimp Y D\"\n              \"C\\<noteq>D\""], ["proof (state)\nthis:\n  SimplicialComplex.maxsimp Y C\n  SimplicialComplex.maxsimp Y D\n  C \\<noteq> D\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "from CD(1,2) Y_def"], ["proof (chain)\npicking this:\n  SimplicialComplex.maxsimp Y C\n  SimplicialComplex.maxsimp Y D\n  Y = folding.Y", "have CD': \"C \\<in> \\<C>-f\\<turnstile>\\<C>\" \"D \\<in> \\<C>-f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp Y C\n  SimplicialComplex.maxsimp Y D\n  Y = folding.Y\n\ngoal (1 subgoal):\n 1. C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> &&&\n    D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>", "using folding.maxsimp_in_opp_half_apartment"], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp Y C\n  SimplicialComplex.maxsimp Y D\n  Y = folding.Y\n  SimplicialComplex.maxsimp folding.Y ?C \\<Longrightarrow>\n  ?C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> &&&\n    D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>", "by auto"], ["proof (state)\nthis:\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "with CD(3)"], ["proof (chain)\npicking this:\n  C \\<noteq> D\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>", "obtain Ds\n    where Ds: \"ChamberComplex.gallery (f\\<turnstile>X) ((f`C)#Ds@[f`D])\""], ["proof (prove)\nusing this:\n  C \\<noteq> D\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. (\\<And>Ds.\n        SimplicialComplex.maxsimpchain (f \\<turnstile> X)\n         (f ` C # Ds @ [f ` D]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using folding.inj_on_opp_chambers''[of C D] chamber_system_def\n          folding.maxsimp_map_into_image folding.chambercomplex_image\n          ChamberComplex.maxsimp_connect[of \"f\\<turnstile>X\" \"f`C\" \"f`D\"]"], ["proof (prove)\nusing this:\n  C \\<noteq> D\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  \\<lbrakk>C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   f ` C = f ` D\\<rbrakk>\n  \\<Longrightarrow> C = D\n  folding.\\<C> \\<equiv> Collect folding.chamber\n  folding.chamber ?x \\<Longrightarrow>\n  SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` ?x)\n  ChamberComplex (f \\<turnstile> X)\n  \\<lbrakk>ChamberComplex (f \\<turnstile> X); f ` C \\<noteq> f ` D;\n   SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` C);\n   SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` D)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       SimplicialComplex.maxsimpchain (f \\<turnstile> X)\n                        (f ` C # xs @ [f ` D])\n\ngoal (1 subgoal):\n 1. (\\<And>Ds.\n        SimplicialComplex.maxsimpchain (f \\<turnstile> X)\n         (f ` C # Ds @ [f ` D]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  SimplicialComplex.maxsimpchain (f \\<turnstile> X) (f ` C # Ds @ [f ` D])\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "define Cs where \"Cs = map opp_chamber Ds\""], ["proof (state)\nthis:\n  Cs =\n  map (\\<lambda>C.\n          THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C)\n   Ds\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "from Ds"], ["proof (chain)\npicking this:\n  SimplicialComplex.maxsimpchain (f \\<turnstile> X) (f ` C # Ds @ [f ` D])", "have Ds': \"gallery ((f`C)#Ds@[f`D])\""], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimpchain (f \\<turnstile> X) (f ` C # Ds @ [f ` D])\n\ngoal (1 subgoal):\n 1. folding.gallery (f ` C # Ds @ [f ` D])", "using folding.chambersubcomplex_image subcomplex_gallery"], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimpchain (f \\<turnstile> X) (f ` C # Ds @ [f ` D])\n  folding.ChamberSubcomplex (f \\<turnstile> X)\n  \\<lbrakk>folding.ChamberSubcomplex ?Y;\n   SimplicialComplex.maxsimpchain ?Y ?Cs\\<rbrakk>\n  \\<Longrightarrow> folding.gallery ?Cs\n\ngoal (1 subgoal):\n 1. folding.gallery (f ` C # Ds @ [f ` D])", "by fast"], ["proof (state)\nthis:\n  folding.gallery (f ` C # Ds @ [f ` D])\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "with Ds"], ["proof (chain)\npicking this:\n  SimplicialComplex.maxsimpchain (f \\<turnstile> X) (f ` C # Ds @ [f ` D])\n  folding.gallery (f ` C # Ds @ [f ` D])", "have Ds'': \"set Ds \\<subseteq> f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimpchain (f \\<turnstile> X) (f ` C # Ds @ [f ` D])\n  folding.gallery (f ` C # Ds @ [f ` D])\n\ngoal (1 subgoal):\n 1. order.greater_eq (f \\<turnstile> folding.\\<C>) (set Ds)", "using folding.chambercomplex_image folding.chamber_system_image\n          ChamberComplex.galleryD_chamber ChamberComplex.chamberD_simplex\n          gallery_chamber_system"], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimpchain (f \\<turnstile> X) (f ` C # Ds @ [f ` D])\n  folding.gallery (f ` C # Ds @ [f ` D])\n  ChamberComplex (f \\<turnstile> X)\n  f \\<turnstile> folding.\\<C> = folding.\\<C> \\<inter> (f \\<turnstile> X)\n  \\<lbrakk>ChamberComplex ?X; SimplicialComplex.maxsimpchain ?X ?xs;\n   ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp ?X ?x\n  \\<lbrakk>ChamberComplex ?X; SimplicialComplex.maxsimp ?X ?x\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ?X\n  folding.gallery ?Cs \\<Longrightarrow>\n  order.greater_eq folding.\\<C> (set ?Cs)\n\ngoal (1 subgoal):\n 1. order.greater_eq (f \\<turnstile> folding.\\<C>) (set Ds)", "by    fastforce"], ["proof (state)\nthis:\n  order.greater_eq (f \\<turnstile> folding.\\<C>) (set Ds)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "have *: \"set Cs \\<subseteq> \\<C>-f\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>) (set Cs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set Cs \\<Longrightarrow>\n       x \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>", "fix B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set Cs \\<Longrightarrow>\n       x \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>", "assume \"B \\<in> set Cs\""], ["proof (state)\nthis:\n  B \\<in> set Cs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set Cs \\<Longrightarrow>\n       x \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>", "with Cs_def"], ["proof (chain)\npicking this:\n  Cs =\n  map (\\<lambda>C.\n          THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C)\n   Ds\n  B \\<in> set Cs", "obtain A where \"A\\<in>set Ds\" \"B = opp_chamber A\""], ["proof (prove)\nusing this:\n  Cs =\n  map (\\<lambda>C.\n          THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C)\n   Ds\n  B \\<in> set Cs\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>A \\<in> set Ds;\n         B =\n         (THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<in> set Ds\n  B =\n  (THE D.\n      D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and> f ` D = A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set Cs \\<Longrightarrow>\n       x \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>", "with Ds''"], ["proof (chain)\npicking this:\n  order.greater_eq (f \\<turnstile> folding.\\<C>) (set Ds)\n  A \\<in> set Ds\n  B =\n  (THE D.\n      D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and> f ` D = A)", "show \"B \\<in> \\<C>-f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  order.greater_eq (f \\<turnstile> folding.\\<C>) (set Ds)\n  A \\<in> set Ds\n  B =\n  (THE D.\n      D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and> f ` D = A)\n\ngoal (1 subgoal):\n 1. B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>", "using folding.opp_chamberD1[of A]"], ["proof (prove)\nusing this:\n  order.greater_eq (f \\<turnstile> folding.\\<C>) (set Ds)\n  A \\<in> set Ds\n  B =\n  (THE D.\n      D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and> f ` D = A)\n  A \\<in> f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n  (THE D.\n      D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and> f ` D = A)\n  \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>", "by auto"], ["proof (state)\nthis:\n  B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>) (set Cs)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "moreover"], ["proof (state)\nthis:\n  order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>) (set Cs)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "from Cs_def CD' Ds' Ds'' *"], ["proof (chain)\npicking this:\n  Cs =\n  map (\\<lambda>C.\n          THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C)\n   Ds\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  folding.gallery (f ` C # Ds @ [f ` D])\n  order.greater_eq (f \\<turnstile> folding.\\<C>) (set Ds)\n  order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>) (set Cs)", "have \"gallery (C#Cs@[D])\""], ["proof (prove)\nusing this:\n  Cs =\n  map (\\<lambda>C.\n          THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C)\n   Ds\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  folding.gallery (f ` C # Ds @ [f ` D])\n  order.greater_eq (f \\<turnstile> folding.\\<C>) (set Ds)\n  order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>) (set Cs)\n\ngoal (1 subgoal):\n 1. folding.gallery (C # Cs @ [D])", "using folding.f_opp_chamber_list gallery_preimage[of \"C#Cs@[D]\"]"], ["proof (prove)\nusing this:\n  Cs =\n  map (\\<lambda>C.\n          THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C)\n   Ds\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  folding.gallery (f ` C # Ds @ [f ` D])\n  order.greater_eq (f \\<turnstile> folding.\\<C>) (set Ds)\n  order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>) (set Cs)\n  order.greater_eq (f \\<turnstile> folding.\\<C>) (set ?Cs) \\<Longrightarrow>\n  f \\<Turnstile>\n  map (\\<lambda>C.\n          THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C)\n   ?Cs =\n  ?Cs\n  \\<lbrakk>order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n            (set (C # Cs @ [D]));\n   folding.gallery (f \\<Turnstile> (C # Cs @ [D]))\\<rbrakk>\n  \\<Longrightarrow> folding.gallery (C # Cs @ [D])\n\ngoal (1 subgoal):\n 1. folding.gallery (C # Cs @ [D])", "by simp"], ["proof (state)\nthis:\n  folding.gallery (C # Cs @ [D])\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; SimplicialComplex.maxsimp folding.Y x;\n        SimplicialComplex.maxsimp folding.Y y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            SimplicialComplex.maxsimpchain folding.Y\n                             (x # xs @ [y])", "ultimately"], ["proof (chain)\npicking this:\n  order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>) (set Cs)\n  folding.gallery (C # Cs @ [D])", "show \"\\<exists>Cs. SimplicialComplex.maxsimpchain Y (C # Cs @ [D])\""], ["proof (prove)\nusing this:\n  order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>) (set Cs)\n  folding.gallery (C # Cs @ [D])\n\ngoal (1 subgoal):\n 1. \\<exists>Cs. SimplicialComplex.maxsimpchain Y (C # Cs @ [D])", "using Y_def CD' folding.subcomplex_opp_half_apartment\n          folding.opp_chambers_subset_opp_half_apartment\n          maxsimpchain_in_subcomplex[of Y \"C#Cs@[D]\"]"], ["proof (prove)\nusing this:\n  order.greater_eq (folding.\\<C> - f \\<turnstile> folding.\\<C>) (set Cs)\n  folding.gallery (C # Cs @ [D])\n  Y = folding.Y\n  C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  order.greater_eq X folding.Y \\<and> SimplicialComplex folding.Y\n  order.greater_eq folding.Y (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n  \\<lbrakk>order.greater_eq X Y \\<and> SimplicialComplex Y;\n   order.greater_eq Y (set (C # Cs @ [D]));\n   folding.gallery (C # Cs @ [D])\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimpchain Y (C # Cs @ [D])\n\ngoal (1 subgoal):\n 1. \\<exists>Cs. SimplicialComplex.maxsimpchain Y (C # Cs @ [D])", "by    fastforce"], ["proof (state)\nthis:\n  \\<exists>Cs. SimplicialComplex.maxsimpchain Y (C # Cs @ [D])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flop_adj:\n  assumes \"chamber C\" \"chamber D\" \"C\\<sim>D\"\n  shows   \"flop C \\<sim> flop D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C) \\<sim>\n    (if D \\<in> f \\<turnstile> folding.\\<C>\n     then THE Da.\n             Da \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` Da = D\n     else f ` D)", "proof (cases \"C\\<in>f\\<turnstile>\\<C>\" \"D\\<in>f\\<turnstile>\\<C>\" rule: two_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 2. \\<lbrakk>C \\<in> f \\<turnstile> folding.\\<C>;\n     D \\<notin> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 3. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 4. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<notin> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)", "case both"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 2. \\<lbrakk>C \\<in> f \\<turnstile> folding.\\<C>;\n     D \\<notin> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 3. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 4. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<notin> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)", "with assms(3)"], ["proof (chain)\npicking this:\n  C \\<sim> D\n  C \\<in> f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<sim> D\n  C \\<in> f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. (if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C) \\<sim>\n    (if D \\<in> f \\<turnstile> folding.\\<C>\n     then THE Da.\n             Da \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` Da = D\n     else f ` D)", "using adjacent_opp_chamber"], ["proof (prove)\nusing this:\n  C \\<sim> D\n  C \\<in> f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n  \\<lbrakk>?C \\<in> f \\<turnstile> folding.\\<C>;\n   ?D \\<in> f \\<turnstile> folding.\\<C>; ?C \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> (THE D.\n                        D \\<in> folding.\\<C> -\n                                f \\<turnstile> folding.\\<C> \\<and>\n                        f ` D = ?C) \\<sim>\n                    (THE D.\n                        D \\<in> folding.\\<C> -\n                                f \\<turnstile> folding.\\<C> \\<and>\n                        f ` D = ?D)\n\ngoal (1 subgoal):\n 1. (if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C) \\<sim>\n    (if D \\<in> f \\<turnstile> folding.\\<C>\n     then THE Da.\n             Da \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` Da = D\n     else f ` D)", "by simp"], ["proof (state)\nthis:\n  (if C \\<in> f \\<turnstile> folding.\\<C>\n   then THE D.\n           D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n           f ` D = C\n   else f ` C) \\<sim>\n  (if D \\<in> f \\<turnstile> folding.\\<C>\n   then THE Da.\n           Da \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n           f ` Da = D\n   else f ` D)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding.\\<C>;\n     D \\<notin> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 2. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 3. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<notin> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding.\\<C>;\n     D \\<notin> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 2. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 3. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<notin> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)", "case one"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> folding.\\<C>\n  D \\<notin> f \\<turnstile> folding.\\<C>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding.\\<C>;\n     D \\<notin> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 2. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 3. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<notin> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)", "with assms(2,3)"], ["proof (chain)\npicking this:\n  folding.chamber D\n  C \\<sim> D\n  C \\<in> f \\<turnstile> folding.\\<C>\n  D \\<notin> f \\<turnstile> folding.\\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  folding.chamber D\n  C \\<sim> D\n  C \\<in> f \\<turnstile> folding.\\<C>\n  D \\<notin> f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. (if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C) \\<sim>\n    (if D \\<in> f \\<turnstile> folding.\\<C>\n     then THE Da.\n             Da \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` Da = D\n     else f ` D)", "using chamber_system_def adjacent_half_chamber_system_image[of C]\n          adjacent_half_chamber_system_image_reverse adjacent_sym"], ["proof (prove)\nusing this:\n  folding.chamber D\n  C \\<sim> D\n  C \\<in> f \\<turnstile> folding.\\<C>\n  D \\<notin> f \\<turnstile> folding.\\<C>\n  folding.\\<C> \\<equiv> Collect folding.chamber\n  \\<lbrakk>C \\<in> f \\<turnstile> folding.\\<C>;\n   ?D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>; C \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> f ` ?D = C\n  \\<lbrakk>?C \\<in> f \\<turnstile> folding.\\<C>;\n   ?D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   ?C \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> (THE D.\n                        D \\<in> folding.\\<C> -\n                                f \\<turnstile> folding.\\<C> \\<and>\n                        f ` D = ?C) =\n                    ?D\n  ?x \\<sim> ?y \\<Longrightarrow> ?y \\<sim> ?x\n\ngoal (1 subgoal):\n 1. (if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C) \\<sim>\n    (if D \\<in> f \\<turnstile> folding.\\<C>\n     then THE Da.\n             Da \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` Da = D\n     else f ` D)", "by    simp"], ["proof (state)\nthis:\n  (if C \\<in> f \\<turnstile> folding.\\<C>\n   then THE D.\n           D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n           f ` D = C\n   else f ` C) \\<sim>\n  (if D \\<in> f \\<turnstile> folding.\\<C>\n   then THE Da.\n           Da \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n           f ` Da = D\n   else f ` D)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 2. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<notin> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 2. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<notin> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)", "case other"], ["proof (state)\nthis:\n  C \\<notin> f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<in> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)\n 2. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<notin> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)", "with assms(1)"], ["proof (chain)\npicking this:\n  folding.chamber C\n  C \\<notin> f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  folding.chamber C\n  C \\<notin> f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. (if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C) \\<sim>\n    (if D \\<in> f \\<turnstile> folding.\\<C>\n     then THE Da.\n             Da \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` Da = D\n     else f ` D)", "using chamber_system_def adjacent_sym[OF assms(3)]\n          adjacent_half_chamber_system_image[of D] \n          adjacent_half_chamber_system_image_reverse"], ["proof (prove)\nusing this:\n  folding.chamber C\n  C \\<notin> f \\<turnstile> folding.\\<C>\n  D \\<in> f \\<turnstile> folding.\\<C>\n  folding.\\<C> \\<equiv> Collect folding.chamber\n  D \\<sim> C\n  \\<lbrakk>D \\<in> f \\<turnstile> folding.\\<C>;\n   ?D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>; D \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> f ` ?D = D\n  \\<lbrakk>?C \\<in> f \\<turnstile> folding.\\<C>;\n   ?D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   ?C \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> (THE D.\n                        D \\<in> folding.\\<C> -\n                                f \\<turnstile> folding.\\<C> \\<and>\n                        f ` D = ?C) =\n                    ?D\n\ngoal (1 subgoal):\n 1. (if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C) \\<sim>\n    (if D \\<in> f \\<turnstile> folding.\\<C>\n     then THE Da.\n             Da \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` Da = D\n     else f ` D)", "by    auto"], ["proof (state)\nthis:\n  (if C \\<in> f \\<turnstile> folding.\\<C>\n   then THE D.\n           D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n           f ` D = C\n   else f ` C) \\<sim>\n  (if D \\<in> f \\<turnstile> folding.\\<C>\n   then THE Da.\n           Da \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n           f ` Da = D\n   else f ` D)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<notin> f \\<turnstile> folding.\\<C>;\n     D \\<notin> f \\<turnstile> folding.\\<C>\\<rbrakk>\n    \\<Longrightarrow> (if C \\<in> f \\<turnstile> folding.\\<C>\n                       then THE D.\n                               D \\<in> folding.\\<C> -\n f \\<turnstile> folding.\\<C> \\<and>\n                               f ` D = C\n                       else f ` C) \\<sim>\n                      (if D \\<in> f \\<turnstile> folding.\\<C>\n                       then THE Da.\n                               Da \\<in> folding.\\<C> -\n  f \\<turnstile> folding.\\<C> \\<and>\n                               f ` Da = D\n                       else f ` D)", "qed (simp add: assms folding.adj_map)"], ["", "lemma flop_gallery: \"gallery Cs \\<Longrightarrow> gallery (map flop Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. folding.gallery Cs \\<Longrightarrow>\n    folding.gallery\n     (map (\\<lambda>C.\n              if C \\<in> f \\<turnstile> folding.\\<C>\n              then THE D.\n                      D \\<in> folding.\\<C> -\n                              f \\<turnstile> folding.\\<C> \\<and>\n                      f ` D = C\n              else f ` C)\n       Cs)", "proof (induct Cs rule: list_induct_CCons)"], ["proof (state)\ngoal (3 subgoals):\n 1. folding.gallery [] \\<Longrightarrow>\n    folding.gallery\n     (map (\\<lambda>C.\n              if C \\<in> f \\<turnstile> folding.\\<C>\n              then THE D.\n                      D \\<in> folding.\\<C> -\n                              f \\<turnstile> folding.\\<C> \\<and>\n                      f ` D = C\n              else f ` C)\n       [])\n 2. \\<And>x.\n       folding.gallery [x] \\<Longrightarrow>\n       folding.gallery\n        (map (\\<lambda>C.\n                 if C \\<in> f \\<turnstile> folding.\\<C>\n                 then THE D.\n                         D \\<in> folding.\\<C> -\n                                 f \\<turnstile> folding.\\<C> \\<and>\n                         f ` D = C\n                 else f ` C)\n          [x])\n 3. \\<And>x y xs.\n       \\<lbrakk>folding.gallery (y # xs) \\<Longrightarrow>\n                folding.gallery\n                 (map (\\<lambda>C.\n                          if C \\<in> f \\<turnstile> folding.\\<C>\n                          then THE D.\n                                  D \\<in> folding.\\<C> -\n    f \\<turnstile> folding.\\<C> \\<and>\n                                  f ` D = C\n                          else f ` C)\n                   (y # xs));\n        folding.gallery (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> folding.gallery\n                          (map (\\<lambda>C.\n                                   if C \\<in> f \\<turnstile> folding.\\<C>\n                                   then THE D.\n     D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and> f ` D = C\n                                   else f ` C)\n                            (x # y # xs))", "case (CCons B C Cs)"], ["proof (state)\nthis:\n  folding.gallery (C # Cs) \\<Longrightarrow>\n  folding.gallery\n   (map (\\<lambda>C.\n            if C \\<in> f \\<turnstile> folding.\\<C>\n            then THE D.\n                    D \\<in> folding.\\<C> -\n                            f \\<turnstile> folding.\\<C> \\<and>\n                    f ` D = C\n            else f ` C)\n     (C # Cs))\n  folding.gallery (B # C # Cs)\n\ngoal (3 subgoals):\n 1. folding.gallery [] \\<Longrightarrow>\n    folding.gallery\n     (map (\\<lambda>C.\n              if C \\<in> f \\<turnstile> folding.\\<C>\n              then THE D.\n                      D \\<in> folding.\\<C> -\n                              f \\<turnstile> folding.\\<C> \\<and>\n                      f ` D = C\n              else f ` C)\n       [])\n 2. \\<And>x.\n       folding.gallery [x] \\<Longrightarrow>\n       folding.gallery\n        (map (\\<lambda>C.\n                 if C \\<in> f \\<turnstile> folding.\\<C>\n                 then THE D.\n                         D \\<in> folding.\\<C> -\n                                 f \\<turnstile> folding.\\<C> \\<and>\n                         f ` D = C\n                 else f ` C)\n          [x])\n 3. \\<And>x y xs.\n       \\<lbrakk>folding.gallery (y # xs) \\<Longrightarrow>\n                folding.gallery\n                 (map (\\<lambda>C.\n                          if C \\<in> f \\<turnstile> folding.\\<C>\n                          then THE D.\n                                  D \\<in> folding.\\<C> -\n    f \\<turnstile> folding.\\<C> \\<and>\n                                  f ` D = C\n                          else f ` C)\n                   (y # xs));\n        folding.gallery (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> folding.gallery\n                          (map (\\<lambda>C.\n                                   if C \\<in> f \\<turnstile> folding.\\<C>\n                                   then THE D.\n     D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and> f ` D = C\n                                   else f ` C)\n                            (x # y # xs))", "have \"gallery (flop B # (flop C) # map flop Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. folding.gallery\n     ((if B \\<in> f \\<turnstile> folding.\\<C>\n       then THE D.\n               D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n               f ` D = B\n       else f ` B) #\n      (if C \\<in> f \\<turnstile> folding.\\<C>\n       then THE D.\n               D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n               f ` D = C\n       else f ` C) #\n      map (\\<lambda>C.\n              if C \\<in> f \\<turnstile> folding.\\<C>\n              then THE D.\n                      D \\<in> folding.\\<C> -\n                              f \\<turnstile> folding.\\<C> \\<and>\n                      f ` D = C\n              else f ` C)\n       Cs)", "proof (rule gallery_CConsI)"], ["proof (state)\ngoal (3 subgoals):\n 1. folding.chamber\n     (if B \\<in> f \\<turnstile> folding.\\<C>\n      then THE D.\n              D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n              f ` D = B\n      else f ` B)\n 2. folding.gallery\n     ((if C \\<in> f \\<turnstile> folding.\\<C>\n       then THE D.\n               D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n               f ` D = C\n       else f ` C) #\n      map (\\<lambda>C.\n              if C \\<in> f \\<turnstile> folding.\\<C>\n              then THE D.\n                      D \\<in> folding.\\<C> -\n                              f \\<turnstile> folding.\\<C> \\<and>\n                      f ` D = C\n              else f ` C)\n       Cs)\n 3. (if B \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = B\n     else f ` B) \\<sim>\n    (if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C)", "from CCons(2)"], ["proof (chain)\npicking this:\n  folding.gallery (B # C # Cs)", "show \"chamber (flop B)\""], ["proof (prove)\nusing this:\n  folding.gallery (B # C # Cs)\n\ngoal (1 subgoal):\n 1. folding.chamber\n     (if B \\<in> f \\<turnstile> folding.\\<C>\n      then THE D.\n              D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n              f ` D = B\n      else f ` B)", "using galleryD_chamber folding.flop_chamber"], ["proof (prove)\nusing this:\n  folding.gallery (B # C # Cs)\n  \\<lbrakk>folding.gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> folding.chamber ?x\n  folding.chamber ?C \\<Longrightarrow>\n  folding.chamber\n   (if ?C \\<in> f \\<turnstile> folding.\\<C>\n    then THE D.\n            D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n            f ` D = ?C\n    else f ` ?C)\n\ngoal (1 subgoal):\n 1. folding.chamber\n     (if B \\<in> f \\<turnstile> folding.\\<C>\n      then THE D.\n              D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n              f ` D = B\n      else f ` B)", "by simp"], ["proof (state)\nthis:\n  folding.chamber\n   (if B \\<in> f \\<turnstile> folding.\\<C>\n    then THE D.\n            D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n            f ` D = B\n    else f ` B)\n\ngoal (2 subgoals):\n 1. folding.gallery\n     ((if C \\<in> f \\<turnstile> folding.\\<C>\n       then THE D.\n               D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n               f ` D = C\n       else f ` C) #\n      map (\\<lambda>C.\n              if C \\<in> f \\<turnstile> folding.\\<C>\n              then THE D.\n                      D \\<in> folding.\\<C> -\n                              f \\<turnstile> folding.\\<C> \\<and>\n                      f ` D = C\n              else f ` C)\n       Cs)\n 2. (if B \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = B\n     else f ` B) \\<sim>\n    (if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C)", "from CCons(1)"], ["proof (chain)\npicking this:\n  folding.gallery (C # Cs) \\<Longrightarrow>\n  folding.gallery\n   (map (\\<lambda>C.\n            if C \\<in> f \\<turnstile> folding.\\<C>\n            then THE D.\n                    D \\<in> folding.\\<C> -\n                            f \\<turnstile> folding.\\<C> \\<and>\n                    f ` D = C\n            else f ` C)\n     (C # Cs))", "show \"gallery (flop C # map flop Cs)\""], ["proof (prove)\nusing this:\n  folding.gallery (C # Cs) \\<Longrightarrow>\n  folding.gallery\n   (map (\\<lambda>C.\n            if C \\<in> f \\<turnstile> folding.\\<C>\n            then THE D.\n                    D \\<in> folding.\\<C> -\n                            f \\<turnstile> folding.\\<C> \\<and>\n                    f ` D = C\n            else f ` C)\n     (C # Cs))\n\ngoal (1 subgoal):\n 1. folding.gallery\n     ((if C \\<in> f \\<turnstile> folding.\\<C>\n       then THE D.\n               D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n               f ` D = C\n       else f ` C) #\n      map (\\<lambda>C.\n              if C \\<in> f \\<turnstile> folding.\\<C>\n              then THE D.\n                      D \\<in> folding.\\<C> -\n                              f \\<turnstile> folding.\\<C> \\<and>\n                      f ` D = C\n              else f ` C)\n       Cs)", "using gallery_Cons_reduce[OF CCons(2)]"], ["proof (prove)\nusing this:\n  folding.gallery (C # Cs) \\<Longrightarrow>\n  folding.gallery\n   (map (\\<lambda>C.\n            if C \\<in> f \\<turnstile> folding.\\<C>\n            then THE D.\n                    D \\<in> folding.\\<C> -\n                            f \\<turnstile> folding.\\<C> \\<and>\n                    f ` D = C\n            else f ` C)\n     (C # Cs))\n  folding.gallery (C # Cs)\n\ngoal (1 subgoal):\n 1. folding.gallery\n     ((if C \\<in> f \\<turnstile> folding.\\<C>\n       then THE D.\n               D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n               f ` D = C\n       else f ` C) #\n      map (\\<lambda>C.\n              if C \\<in> f \\<turnstile> folding.\\<C>\n              then THE D.\n                      D \\<in> folding.\\<C> -\n                              f \\<turnstile> folding.\\<C> \\<and>\n                      f ` D = C\n              else f ` C)\n       Cs)", "by simp"], ["proof (state)\nthis:\n  folding.gallery\n   ((if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C) #\n    map (\\<lambda>C.\n            if C \\<in> f \\<turnstile> folding.\\<C>\n            then THE D.\n                    D \\<in> folding.\\<C> -\n                            f \\<turnstile> folding.\\<C> \\<and>\n                    f ` D = C\n            else f ` C)\n     Cs)\n\ngoal (1 subgoal):\n 1. (if B \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = B\n     else f ` B) \\<sim>\n    (if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C)", "from CCons(2)"], ["proof (chain)\npicking this:\n  folding.gallery (B # C # Cs)", "show \"flop B \\<sim> flop C\""], ["proof (prove)\nusing this:\n  folding.gallery (B # C # Cs)\n\ngoal (1 subgoal):\n 1. (if B \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = B\n     else f ` B) \\<sim>\n    (if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C)", "using galleryD_chamber galleryD_adj flop_adj[of B C]"], ["proof (prove)\nusing this:\n  folding.gallery (B # C # Cs)\n  \\<lbrakk>folding.gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> folding.chamber ?x\n  folding.gallery ?xs \\<Longrightarrow> adjacentchain ?xs\n  \\<lbrakk>folding.chamber B; folding.chamber C; B \\<sim> C\\<rbrakk>\n  \\<Longrightarrow> (if B \\<in> f \\<turnstile> folding.\\<C>\n                     then THE D.\n                             D \\<in> folding.\\<C> -\n                                     f \\<turnstile> folding.\\<C> \\<and>\n                             f ` D = B\n                     else f ` B) \\<sim>\n                    (if C \\<in> f \\<turnstile> folding.\\<C>\n                     then THE D.\n                             D \\<in> folding.\\<C> -\n                                     f \\<turnstile> folding.\\<C> \\<and>\n                             f ` D = C\n                     else f ` C)\n\ngoal (1 subgoal):\n 1. (if B \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = B\n     else f ` B) \\<sim>\n    (if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C)", "by fastforce"], ["proof (state)\nthis:\n  (if B \\<in> f \\<turnstile> folding.\\<C>\n   then THE D.\n           D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n           f ` D = B\n   else f ` B) \\<sim>\n  (if C \\<in> f \\<turnstile> folding.\\<C>\n   then THE D.\n           D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n           f ` D = C\n   else f ` C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  folding.gallery\n   ((if B \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = B\n     else f ` B) #\n    (if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C) #\n    map (\\<lambda>C.\n            if C \\<in> f \\<turnstile> folding.\\<C>\n            then THE D.\n                    D \\<in> folding.\\<C> -\n                            f \\<turnstile> folding.\\<C> \\<and>\n                    f ` D = C\n            else f ` C)\n     Cs)\n\ngoal (3 subgoals):\n 1. folding.gallery [] \\<Longrightarrow>\n    folding.gallery\n     (map (\\<lambda>C.\n              if C \\<in> f \\<turnstile> folding.\\<C>\n              then THE D.\n                      D \\<in> folding.\\<C> -\n                              f \\<turnstile> folding.\\<C> \\<and>\n                      f ` D = C\n              else f ` C)\n       [])\n 2. \\<And>x.\n       folding.gallery [x] \\<Longrightarrow>\n       folding.gallery\n        (map (\\<lambda>C.\n                 if C \\<in> f \\<turnstile> folding.\\<C>\n                 then THE D.\n                         D \\<in> folding.\\<C> -\n                                 f \\<turnstile> folding.\\<C> \\<and>\n                         f ` D = C\n                 else f ` C)\n          [x])\n 3. \\<And>x y xs.\n       \\<lbrakk>folding.gallery (y # xs) \\<Longrightarrow>\n                folding.gallery\n                 (map (\\<lambda>C.\n                          if C \\<in> f \\<turnstile> folding.\\<C>\n                          then THE D.\n                                  D \\<in> folding.\\<C> -\n    f \\<turnstile> folding.\\<C> \\<and>\n                                  f ` D = C\n                          else f ` C)\n                   (y # xs));\n        folding.gallery (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> folding.gallery\n                          (map (\\<lambda>C.\n                                   if C \\<in> f \\<turnstile> folding.\\<C>\n                                   then THE D.\n     D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and> f ` D = C\n                                   else f ` C)\n                            (x # y # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  folding.gallery\n   ((if B \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = B\n     else f ` B) #\n    (if C \\<in> f \\<turnstile> folding.\\<C>\n     then THE D.\n             D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n             f ` D = C\n     else f ` C) #\n    map (\\<lambda>C.\n            if C \\<in> f \\<turnstile> folding.\\<C>\n            then THE D.\n                    D \\<in> folding.\\<C> -\n                            f \\<turnstile> folding.\\<C> \\<and>\n                    f ` D = C\n            else f ` C)\n     Cs)\n\ngoal (1 subgoal):\n 1. folding.gallery\n     (map (\\<lambda>C.\n              if C \\<in> f \\<turnstile> folding.\\<C>\n              then THE D.\n                      D \\<in> folding.\\<C> -\n                              f \\<turnstile> folding.\\<C> \\<and>\n                      f ` D = C\n              else f ` C)\n       (B # C # Cs))", "by simp"], ["proof (state)\nthis:\n  folding.gallery\n   (map (\\<lambda>C.\n            if C \\<in> f \\<turnstile> folding.\\<C>\n            then THE D.\n                    D \\<in> folding.\\<C> -\n                            f \\<turnstile> folding.\\<C> \\<and>\n                    f ` D = C\n            else f ` C)\n     (B # C # Cs))\n\ngoal (2 subgoals):\n 1. folding.gallery [] \\<Longrightarrow>\n    folding.gallery\n     (map (\\<lambda>C.\n              if C \\<in> f \\<turnstile> folding.\\<C>\n              then THE D.\n                      D \\<in> folding.\\<C> -\n                              f \\<turnstile> folding.\\<C> \\<and>\n                      f ` D = C\n              else f ` C)\n       [])\n 2. \\<And>x.\n       folding.gallery [x] \\<Longrightarrow>\n       folding.gallery\n        (map (\\<lambda>C.\n                 if C \\<in> f \\<turnstile> folding.\\<C>\n                 then THE D.\n                         D \\<in> folding.\\<C> -\n                                 f \\<turnstile> folding.\\<C> \\<and>\n                         f ` D = C\n                 else f ` C)\n          [x])", "qed (auto simp add: galleryD_chamber folding.flop_chamber gallery_def)"], ["", "lemma morphism_half_apartments: \"ChamberComplexMorphism folding.Y (f\\<turnstile>X) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexMorphism folding.Y (f \\<turnstile> X) f", "proof (\n  rule ChamberComplexMorphism.intro, rule chambercomplex_opp_half_apartment,\n  rule folding.chambercomplex_image, unfold_locales\n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       SimplicialComplex.maxsimp folding.Y C \\<Longrightarrow>\n       SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` C)\n 2. \\<And>C.\n       SimplicialComplex.maxsimp folding.Y C \\<Longrightarrow>\n       card (f ` C) = card C", "show\n    \"\\<And>C. SimplicialComplex.maxsimp folding.Y C \\<Longrightarrow>\n      SimplicialComplex.maxsimp (f\\<turnstile>X) (f`C)\"\n    \"\\<And>C. SimplicialComplex.maxsimp folding.Y C \\<Longrightarrow> card (f`C) = card C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C.\n        SimplicialComplex.maxsimp folding.Y C \\<Longrightarrow>\n        SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` C)) &&&\n    (\\<And>C.\n        SimplicialComplex.maxsimp folding.Y C \\<Longrightarrow>\n        card (f ` C) = card C)", "using folding.chamber_in_opp_half_apartment folding.chamber_map\n          folding.chambersubcomplex_image chamber_in_subcomplex\n          chamberD_simplex folding.dim_map"], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp folding.Y ?C \\<Longrightarrow>\n  folding.chamber ?C\n  folding.chamber ?C \\<Longrightarrow> folding.chamber (f ` ?C)\n  folding.ChamberSubcomplex (f \\<turnstile> X)\n  \\<lbrakk>folding.ChamberSubcomplex ?Y; ?C \\<in> ?Y;\n   folding.chamber ?C\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp ?Y ?C\n  folding.chamber ?x \\<Longrightarrow> ?x \\<in> X\n  folding.chamber ?C \\<Longrightarrow> card (f ` ?C) = card ?C\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        SimplicialComplex.maxsimp folding.Y C \\<Longrightarrow>\n        SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` C)) &&&\n    (\\<And>C.\n        SimplicialComplex.maxsimp folding.Y C \\<Longrightarrow>\n        card (f ` C) = card C)", "by    auto"], ["proof (state)\nthis:\n  SimplicialComplex.maxsimp folding.Y ?C2 \\<Longrightarrow>\n  SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` ?C2)\n  SimplicialComplex.maxsimp folding.Y ?C2 \\<Longrightarrow>\n  card (f ` ?C2) = card ?C2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chamber_image_complement_closer:\n  \"\\<lbrakk> D\\<in>\\<C>-f\\<turnstile>\\<C>; B\\<in>\\<C>-f\\<turnstile>\\<C>; B\\<noteq>D; gallery (B#Cs@[f`D]) \\<rbrakk> \\<Longrightarrow>\n      \\<exists>Ds. gallery (B#Ds@[D]) \\<and> length Ds < length Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n     B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>; B \\<noteq> D;\n     folding.gallery (B # Cs @ [f ` D])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ds.\n                         folding.gallery (B # Ds @ [D]) \\<and>\n                         order.greater (length Cs) (length Ds)", "using flop_gallery chamber_image_closer[of D \"f`B\" \"map flop Cs\"]\n        folding.opp_chamber_reverse folding.inj_on_opp_chambers''[of B D]"], ["proof (prove)\nusing this:\n  folding.gallery ?Cs \\<Longrightarrow>\n  folding.gallery\n   (map (\\<lambda>C.\n            if C \\<in> f \\<turnstile> folding.\\<C>\n            then THE D.\n                    D \\<in> folding.\\<C> -\n                            f \\<turnstile> folding.\\<C> \\<and>\n                    f ` D = C\n            else f ` C)\n     ?Cs)\n  \\<lbrakk>D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   f ` B \\<in> f \\<turnstile> folding.\\<C>; f ` B \\<noteq> f ` D;\n   folding.gallery\n    (f ` B #\n     map (\\<lambda>C.\n             if C \\<in> f \\<turnstile> folding.\\<C>\n             then THE D.\n                     D \\<in> folding.\\<C> -\n                             f \\<turnstile> folding.\\<C> \\<and>\n                     f ` D = C\n             else f ` C)\n      Cs @\n     [D])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Csa.\n                       folding.gallery (f ` B # Csa @ [f ` D]) \\<and>\n                       order.greater\n                        (length\n                          (map (\\<lambda>C.\n                                   if C \\<in> f \\<turnstile> folding.\\<C>\n                                   then THE D.\n     D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and> f ` D = C\n                                   else f ` C)\n                            Cs))\n                        (length Csa)\n  ?C \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n  (THE D.\n      D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<and>\n      f ` D = f ` ?C) =\n  ?C\n  \\<lbrakk>B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   f ` B = f ` D\\<rbrakk>\n  \\<Longrightarrow> B = D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n     B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>; B \\<noteq> D;\n     folding.gallery (B # Cs @ [f ` D])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ds.\n                         folding.gallery (B # Ds @ [D]) \\<and>\n                         order.greater (length Cs) (length Ds)", "by    force"], ["", "lemma chamber_image_complement_subset:\n  assumes D: \"D\\<in>\\<C>-f\\<turnstile>\\<C>\"\n  defines C: \"C \\<equiv> f`D\"\n  defines \"closerToD \\<equiv> {B\\<in>\\<C>. chamber_distance B D < chamber_distance B C}\"\n  shows   \"\\<C>-f\\<turnstile>\\<C> \\<subseteq> closerToD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq closerToD (folding.\\<C> - f \\<turnstile> folding.\\<C>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n       x \\<in> closerToD", "fix B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n       x \\<in> closerToD", "assume B: \"B\\<in>\\<C>-f\\<turnstile>\\<C>\""], ["proof (state)\nthis:\n  B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n       x \\<in> closerToD", "show \"B \\<in> closerToD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> closerToD", "proof (cases \"B=D\")"], ["proof (state)\ngoal (2 subgoals):\n 1. B = D \\<Longrightarrow> B \\<in> closerToD\n 2. B \\<noteq> D \\<Longrightarrow> B \\<in> closerToD", "case True"], ["proof (state)\nthis:\n  B = D\n\ngoal (2 subgoals):\n 1. B = D \\<Longrightarrow> B \\<in> closerToD\n 2. B \\<noteq> D \\<Longrightarrow> B \\<in> closerToD", "with B C closerToD_def"], ["proof (chain)\npicking this:\n  B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  C \\<equiv> f ` D\n  closerToD \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B C) (chamber_distance B D)}\n  B = D", "show ?thesis"], ["proof (prove)\nusing this:\n  B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  C \\<equiv> f ` D\n  closerToD \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B C) (chamber_distance B D)}\n  B = D\n\ngoal (1 subgoal):\n 1. B \\<in> closerToD", "using chamber_distance_def"], ["proof (prove)\nusing this:\n  B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  C \\<equiv> f ` D\n  closerToD \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B C) (chamber_distance B D)}\n  B = D\n  chamber_distance ?C ?D =\n  (if ?C = ?D then 0\n   else Suc (length (ARG_MIN length Cs. folding.gallery (?C # Cs @ [?D]))))\n\ngoal (1 subgoal):\n 1. B \\<in> closerToD", "by auto"], ["proof (state)\nthis:\n  B \\<in> closerToD\n\ngoal (1 subgoal):\n 1. B \\<noteq> D \\<Longrightarrow> B \\<in> closerToD", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B \\<noteq> D \\<Longrightarrow> B \\<in> closerToD", "case False"], ["proof (state)\nthis:\n  B \\<noteq> D\n\ngoal (1 subgoal):\n 1. B \\<noteq> D \\<Longrightarrow> B \\<in> closerToD", "define Cs where \"Cs = (ARG_MIN length Cs. gallery (B#Cs@[C]))\""], ["proof (state)\nthis:\n  Cs = (ARG_MIN length Cs. folding.gallery (B # Cs @ [C]))\n\ngoal (1 subgoal):\n 1. B \\<noteq> D \\<Longrightarrow> B \\<in> closerToD", "with B C D False closerToD_def"], ["proof (chain)\npicking this:\n  B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  C \\<equiv> f ` D\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<noteq> D\n  closerToD \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B C) (chamber_distance B D)}\n  Cs = (ARG_MIN length Cs. folding.gallery (B # Cs @ [C]))", "show ?thesis"], ["proof (prove)\nusing this:\n  B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  C \\<equiv> f ` D\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<noteq> D\n  closerToD \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B C) (chamber_distance B D)}\n  Cs = (ARG_MIN length Cs. folding.gallery (B # Cs @ [C]))\n\ngoal (1 subgoal):\n 1. B \\<in> closerToD", "using chamber_system_def folding.chamber_map[of D]\n            gallery_least_length[of B C] chamber_distance_le\n            chamber_image_complement_closer[of D B Cs]\n            chamber_distance_def[of B C]"], ["proof (prove)\nusing this:\n  B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  C \\<equiv> f ` D\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  B \\<noteq> D\n  closerToD \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B C) (chamber_distance B D)}\n  Cs = (ARG_MIN length Cs. folding.gallery (B # Cs @ [C]))\n  folding.\\<C> \\<equiv> Collect folding.chamber\n  folding.chamber D \\<Longrightarrow> folding.chamber (f ` D)\n  \\<lbrakk>folding.chamber B; folding.chamber C; B \\<noteq> C\\<rbrakk>\n  \\<Longrightarrow> folding.gallery\n                     (B #\n                      (ARG_MIN length Cs. folding.gallery (B # Cs @ [C])) @\n                      [C])\n  folding.gallery (?C # ?Cs @ [?D]) \\<Longrightarrow>\n  order.greater_eq (Suc (length ?Cs)) (chamber_distance ?C ?D)\n  \\<lbrakk>D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>;\n   B \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>; B \\<noteq> D;\n   folding.gallery (B # Cs @ [f ` D])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Ds.\n                       folding.gallery (B # Ds @ [D]) \\<and>\n                       order.greater (length Cs) (length Ds)\n  chamber_distance B C =\n  (if B = C then 0\n   else Suc (length (ARG_MIN length Cs. folding.gallery (B # Cs @ [C]))))\n\ngoal (1 subgoal):\n 1. B \\<in> closerToD", "by    fastforce"], ["proof (state)\nthis:\n  B \\<in> closerToD\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B \\<in> closerToD\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chamber_image_and_complement:\n  assumes D: \"D\\<in>\\<C>-f\\<turnstile>\\<C>\"\n  defines C: \"C \\<equiv> f`D\"\n  defines \"closerToC \\<equiv> {B\\<in>\\<C>. chamber_distance B C < chamber_distance B D}\"\n  and     \"closerToD \\<equiv> {B\\<in>\\<C>. chamber_distance B D < chamber_distance B C}\"\n  shows \"f\\<turnstile>\\<C> = closerToC\" \"\\<C>-f\\<turnstile>\\<C> = closerToD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<turnstile> folding.\\<C> = closerToC &&&\n    folding.\\<C> - f \\<turnstile> folding.\\<C> = closerToD", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<turnstile> folding.\\<C> = closerToC\n 2. folding.\\<C> - f \\<turnstile> folding.\\<C> = closerToD", "from closerToC_def closerToD_def"], ["proof (chain)\npicking this:\n  closerToC \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B D) (chamber_distance B C)}\n  closerToD \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B C) (chamber_distance B D)}", "have \"closerToC \\<inter> closerToD = {}\""], ["proof (prove)\nusing this:\n  closerToC \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B D) (chamber_distance B C)}\n  closerToD \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B C) (chamber_distance B D)}\n\ngoal (1 subgoal):\n 1. closerToC \\<inter> closerToD = {}", "by auto"], ["proof (state)\nthis:\n  closerToC \\<inter> closerToD = {}\n\ngoal (2 subgoals):\n 1. f \\<turnstile> folding.\\<C> = closerToC\n 2. folding.\\<C> - f \\<turnstile> folding.\\<C> = closerToD", "moreover"], ["proof (state)\nthis:\n  closerToC \\<inter> closerToD = {}\n\ngoal (2 subgoals):\n 1. f \\<turnstile> folding.\\<C> = closerToC\n 2. folding.\\<C> - f \\<turnstile> folding.\\<C> = closerToD", "from C D closerToC_def closerToD_def"], ["proof (chain)\npicking this:\n  C \\<equiv> f ` D\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  closerToC \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B D) (chamber_distance B C)}\n  closerToD \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B C) (chamber_distance B D)}", "have \"\\<C> = f \\<turnstile> \\<C> \\<union> (\\<C>-f\\<turnstile>\\<C>)\" \"closerToC \\<subseteq> \\<C>\" \"closerToD \\<subseteq> \\<C>\""], ["proof (prove)\nusing this:\n  C \\<equiv> f ` D\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  closerToC \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B D) (chamber_distance B C)}\n  closerToD \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B C) (chamber_distance B D)}\n\ngoal (1 subgoal):\n 1. folding.\\<C> =\n    f \\<turnstile> folding.\\<C> \\<union>\n    (folding.\\<C> - f \\<turnstile> folding.\\<C>) &&&\n    order.greater_eq folding.\\<C> closerToC &&&\n    order.greater_eq folding.\\<C> closerToD", "using folding.chamber_system_into"], ["proof (prove)\nusing this:\n  C \\<equiv> f ` D\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  closerToC \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B D) (chamber_distance B C)}\n  closerToD \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B C) (chamber_distance B D)}\n  order.greater_eq folding.\\<C> (f \\<turnstile> folding.\\<C>)\n\ngoal (1 subgoal):\n 1. folding.\\<C> =\n    f \\<turnstile> folding.\\<C> \\<union>\n    (folding.\\<C> - f \\<turnstile> folding.\\<C>) &&&\n    order.greater_eq folding.\\<C> closerToC &&&\n    order.greater_eq folding.\\<C> closerToD", "by    auto"], ["proof (state)\nthis:\n  folding.\\<C> =\n  f \\<turnstile> folding.\\<C> \\<union>\n  (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n  order.greater_eq folding.\\<C> closerToC\n  order.greater_eq folding.\\<C> closerToD\n\ngoal (2 subgoals):\n 1. f \\<turnstile> folding.\\<C> = closerToC\n 2. folding.\\<C> - f \\<turnstile> folding.\\<C> = closerToD", "moreover"], ["proof (state)\nthis:\n  folding.\\<C> =\n  f \\<turnstile> folding.\\<C> \\<union>\n  (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n  order.greater_eq folding.\\<C> closerToC\n  order.greater_eq folding.\\<C> closerToD\n\ngoal (2 subgoals):\n 1. f \\<turnstile> folding.\\<C> = closerToC\n 2. folding.\\<C> - f \\<turnstile> folding.\\<C> = closerToD", "from assms"], ["proof (chain)\npicking this:\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  C \\<equiv> f ` D\n  closerToC \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B D) (chamber_distance B C)}\n  closerToD \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B C) (chamber_distance B D)}", "have \"f\\<turnstile>\\<C> \\<subseteq> closerToC\" \"\\<C>-f\\<turnstile>\\<C> \\<subseteq> closerToD\""], ["proof (prove)\nusing this:\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  C \\<equiv> f ` D\n  closerToC \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B D) (chamber_distance B C)}\n  closerToD \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B C) (chamber_distance B D)}\n\ngoal (1 subgoal):\n 1. order.greater_eq closerToC (f \\<turnstile> folding.\\<C>) &&&\n    order.greater_eq closerToD (folding.\\<C> - f \\<turnstile> folding.\\<C>)", "using chamber_image_subset chamber_image_complement_subset"], ["proof (prove)\nusing this:\n  D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C>\n  C \\<equiv> f ` D\n  closerToC \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B D) (chamber_distance B C)}\n  closerToD \\<equiv>\n  {B \\<in> folding.\\<C>.\n   order.greater (chamber_distance B C) (chamber_distance B D)}\n  ?D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n  order.greater_eq\n   {B \\<in> folding.\\<C>.\n    order.greater (chamber_distance B ?D) (chamber_distance B (f ` ?D))}\n   (f \\<turnstile> folding.\\<C>)\n  ?D \\<in> folding.\\<C> - f \\<turnstile> folding.\\<C> \\<Longrightarrow>\n  order.greater_eq\n   {B \\<in> folding.\\<C>.\n    order.greater (chamber_distance B (f ` ?D)) (chamber_distance B ?D)}\n   (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n\ngoal (1 subgoal):\n 1. order.greater_eq closerToC (f \\<turnstile> folding.\\<C>) &&&\n    order.greater_eq closerToD (folding.\\<C> - f \\<turnstile> folding.\\<C>)", "by auto"], ["proof (state)\nthis:\n  order.greater_eq closerToC (f \\<turnstile> folding.\\<C>)\n  order.greater_eq closerToD (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n\ngoal (2 subgoals):\n 1. f \\<turnstile> folding.\\<C> = closerToC\n 2. folding.\\<C> - f \\<turnstile> folding.\\<C> = closerToD", "ultimately"], ["proof (chain)\npicking this:\n  closerToC \\<inter> closerToD = {}\n  folding.\\<C> =\n  f \\<turnstile> folding.\\<C> \\<union>\n  (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n  order.greater_eq folding.\\<C> closerToC\n  order.greater_eq folding.\\<C> closerToD\n  order.greater_eq closerToC (f \\<turnstile> folding.\\<C>)\n  order.greater_eq closerToD (folding.\\<C> - f \\<turnstile> folding.\\<C>)", "show \"f\\<turnstile>\\<C> = closerToC\" \"\\<C>-f\\<turnstile>\\<C> = closerToD\""], ["proof (prove)\nusing this:\n  closerToC \\<inter> closerToD = {}\n  folding.\\<C> =\n  f \\<turnstile> folding.\\<C> \\<union>\n  (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n  order.greater_eq folding.\\<C> closerToC\n  order.greater_eq folding.\\<C> closerToD\n  order.greater_eq closerToC (f \\<turnstile> folding.\\<C>)\n  order.greater_eq closerToD (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n\ngoal (1 subgoal):\n 1. f \\<turnstile> folding.\\<C> = closerToC &&&\n    folding.\\<C> - f \\<turnstile> folding.\\<C> = closerToD", "using set_decomp_subset[of \\<C> \"f\\<turnstile>\\<C>\"] set_decomp_subset[of \\<C> \"\\<C>-f\\<turnstile>\\<C>\"]"], ["proof (prove)\nusing this:\n  closerToC \\<inter> closerToD = {}\n  folding.\\<C> =\n  f \\<turnstile> folding.\\<C> \\<union>\n  (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n  order.greater_eq folding.\\<C> closerToC\n  order.greater_eq folding.\\<C> closerToD\n  order.greater_eq closerToC (f \\<turnstile> folding.\\<C>)\n  order.greater_eq closerToD (folding.\\<C> - f \\<turnstile> folding.\\<C>)\n  \\<lbrakk>folding.\\<C> = f \\<turnstile> folding.\\<C> \\<union> ?B;\n   order.greater_eq ?X (f \\<turnstile> folding.\\<C>);\n   order.greater_eq ?Y ?B; order.greater_eq folding.\\<C> ?X;\n   ?X \\<inter> ?Y = {}\\<rbrakk>\n  \\<Longrightarrow> f \\<turnstile> folding.\\<C> = ?X\n  \\<lbrakk>folding.\\<C> =\n           folding.\\<C> - f \\<turnstile> folding.\\<C> \\<union> ?B;\n   order.greater_eq ?X (folding.\\<C> - f \\<turnstile> folding.\\<C>);\n   order.greater_eq ?Y ?B; order.greater_eq folding.\\<C> ?X;\n   ?X \\<inter> ?Y = {}\\<rbrakk>\n  \\<Longrightarrow> folding.\\<C> - f \\<turnstile> folding.\\<C> = ?X\n\ngoal (1 subgoal):\n 1. f \\<turnstile> folding.\\<C> = closerToC &&&\n    folding.\\<C> - f \\<turnstile> folding.\\<C> = closerToD", "by auto"], ["proof (state)\nthis:\n  f \\<turnstile> folding.\\<C> = closerToC\n  folding.\\<C> - f \\<turnstile> folding.\\<C> = closerToD\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ThinChamberComplexFolding *)"], ["", "subsubsection \\<open>Pairs of opposed foldings\\<close>"], ["", "text \\<open>\n  A pair of foldings of a thin chamber complex are opposed or opposite if there is a corresponding\n  pair of adjacent chambers, where each folding sends its corresponding chamber to the other\n  chamber.\n\\<close>"], ["", "locale OpposedThinChamberComplexFoldings =\n  ThinChamberComplex X\n+ folding_f: ChamberComplexFolding X f\n+ folding_g: ChamberComplexFolding X g\n  for X :: \"'a set set\"\n  and f :: \"'a\\<Rightarrow>'a\"\n  and g :: \"'a\\<Rightarrow>'a\"\n+ fixes C0 :: \"'a set\"\n  assumes chambers: \"chamber C0\" \"C0\\<sim>g`C0\" \"C0\\<noteq>g`C0\" \"f`g`C0 = C0\"\nbegin"], ["", "abbreviation \"D0 \\<equiv> g`C0\""], ["", "lemmas chamber_D0 = folding_g.chamber_map[OF chambers(1)]"], ["", "lemma ThinChamberComplexFolding_f: \"ThinChamberComplexFolding X f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ThinChamberComplexFolding X f", ".."], ["", "lemma ThinChamberComplexFolding_g: \"ThinChamberComplexFolding X g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ThinChamberComplexFolding X g", ".."], ["", "lemmas foldf = ThinChamberComplexFolding_f"], ["", "lemmas foldg = ThinChamberComplexFolding_g"], ["", "lemma fg_symmetric: \"OpposedThinChamberComplexFoldings X g f D0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings X g f D0", "using chambers(2-4) chamber_D0 adjacent_sym"], ["proof (prove)\nusing this:\n  C0 \\<sim> D0\n  C0 \\<noteq> D0\n  f ` D0 = C0\n  folding_g.chamber D0\n  ?x \\<sim> ?y \\<Longrightarrow> ?y \\<sim> ?x\n\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings X g f D0", "by unfold_locales auto"], ["", "lemma basechambers_half_chamber_systems: \"C0\\<in>f\\<turnstile>\\<C>\" \"D0\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C0 \\<in> f \\<turnstile> folding_g.\\<C> &&&\n    D0 \\<in> g \\<turnstile> folding_g.\\<C>", "using chambers(1,4) chamber_D0 chamber_system_def"], ["proof (prove)\nusing this:\n  folding_g.chamber C0\n  f ` D0 = C0\n  folding_g.chamber D0\n  folding_g.\\<C> \\<equiv> Collect folding_g.chamber\n\ngoal (1 subgoal):\n 1. C0 \\<in> f \\<turnstile> folding_g.\\<C> &&&\n    D0 \\<in> g \\<turnstile> folding_g.\\<C>", "by auto"], ["", "lemmas basech_halfchsys =\n  basechambers_half_chamber_systems"], ["", "lemma f_trivial_C0: \"v\\<in>C0 \\<Longrightarrow> f v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> C0 \\<Longrightarrow> f v = v", "using chambers(4) chamber_D0 chamberD_simplex[of D0]\n        folding_f.vertex_retraction"], ["proof (prove)\nusing this:\n  f ` D0 = C0\n  folding_g.chamber D0\n  folding_g.chamber D0 \\<Longrightarrow> D0 \\<in> X\n  ?v \\<in> f ` \\<Union> X \\<Longrightarrow> f ?v = ?v\n\ngoal (1 subgoal):\n 1. v \\<in> C0 \\<Longrightarrow> f v = v", "by    fast"], ["", "lemmas g_trivial_D0 =\n  OpposedThinChamberComplexFoldings.f_trivial_C0[OF fg_symmetric]"], ["", "lemma double_fold_D0:\n  assumes \"v \\<in> D0 - C0\"\n  shows   \"g (f v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (f v) = v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. g (f v) = v", "from assms chambers(2)"], ["proof (chain)\npicking this:\n  v \\<in> D0 - C0\n  C0 \\<sim> D0", "have 1: \"D0 = insert v (C0\\<inter>D0)\""], ["proof (prove)\nusing this:\n  v \\<in> D0 - C0\n  C0 \\<sim> D0\n\ngoal (1 subgoal):\n 1. D0 = insert v (C0 \\<inter> D0)", "using adjacent_sym adjacent_conv_insert"], ["proof (prove)\nusing this:\n  v \\<in> D0 - C0\n  C0 \\<sim> D0\n  ?x \\<sim> ?y \\<Longrightarrow> ?y \\<sim> ?x\n  \\<lbrakk>?x \\<sim> ?y; ?v \\<in> ?x - ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = insert ?v (?x \\<inter> ?y)\n\ngoal (1 subgoal):\n 1. D0 = insert v (C0 \\<inter> D0)", "by fast"], ["proof (state)\nthis:\n  D0 = insert v (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. g (f v) = v", "hence \"f`D0 = insert (f v) (f`(C0\\<inter>D0))\""], ["proof (prove)\nusing this:\n  D0 = insert v (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. f ` D0 = insert (f v) (f ` (C0 \\<inter> D0))", "by fast"], ["proof (state)\nthis:\n  f ` D0 = insert (f v) (f ` (C0 \\<inter> D0))\n\ngoal (1 subgoal):\n 1. g (f v) = v", "moreover"], ["proof (state)\nthis:\n  f ` D0 = insert (f v) (f ` (C0 \\<inter> D0))\n\ngoal (1 subgoal):\n 1. g (f v) = v", "have \"f`(C0\\<inter>D0) = C0\\<inter>D0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` (C0 \\<inter> D0) = C0 \\<inter> D0", "using f_trivial_C0"], ["proof (prove)\nusing this:\n  ?v \\<in> C0 \\<Longrightarrow> f ?v = ?v\n\ngoal (1 subgoal):\n 1. f ` (C0 \\<inter> D0) = C0 \\<inter> D0", "by force"], ["proof (state)\nthis:\n  f ` (C0 \\<inter> D0) = C0 \\<inter> D0\n\ngoal (1 subgoal):\n 1. g (f v) = v", "ultimately"], ["proof (chain)\npicking this:\n  f ` D0 = insert (f v) (f ` (C0 \\<inter> D0))\n  f ` (C0 \\<inter> D0) = C0 \\<inter> D0", "have \"C0 = insert (f v) (C0\\<inter>D0)\""], ["proof (prove)\nusing this:\n  f ` D0 = insert (f v) (f ` (C0 \\<inter> D0))\n  f ` (C0 \\<inter> D0) = C0 \\<inter> D0\n\ngoal (1 subgoal):\n 1. C0 = insert (f v) (C0 \\<inter> D0)", "using chambers(4)"], ["proof (prove)\nusing this:\n  f ` D0 = insert (f v) (f ` (C0 \\<inter> D0))\n  f ` (C0 \\<inter> D0) = C0 \\<inter> D0\n  f ` D0 = C0\n\ngoal (1 subgoal):\n 1. C0 = insert (f v) (C0 \\<inter> D0)", "by simp"], ["proof (state)\nthis:\n  C0 = insert (f v) (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. g (f v) = v", "hence \"g`C0 = insert (g (f v)) (g`(C0\\<inter>D0))\""], ["proof (prove)\nusing this:\n  C0 = insert (f v) (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. D0 = insert (g (f v)) (g ` (C0 \\<inter> D0))", "by force"], ["proof (state)\nthis:\n  D0 = insert (g (f v)) (g ` (C0 \\<inter> D0))\n\ngoal (1 subgoal):\n 1. g (f v) = v", "moreover"], ["proof (state)\nthis:\n  D0 = insert (g (f v)) (g ` (C0 \\<inter> D0))\n\ngoal (1 subgoal):\n 1. g (f v) = v", "have \"g`(C0\\<inter>D0) = C0\\<inter>D0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g ` (C0 \\<inter> D0) = C0 \\<inter> D0", "using g_trivial_D0 fixespointwise_im[of g D0 \"C0\\<inter>D0\"]"], ["proof (prove)\nusing this:\n  ?v \\<in> D0 \\<Longrightarrow> g ?v = ?v\n  \\<lbrakk>fixespointwise g D0;\n   order.greater_eq D0 (C0 \\<inter> D0)\\<rbrakk>\n  \\<Longrightarrow> g ` (C0 \\<inter> D0) = C0 \\<inter> D0\n\ngoal (1 subgoal):\n 1. g ` (C0 \\<inter> D0) = C0 \\<inter> D0", "by    (fastforce intro: fixespointwiseI)"], ["proof (state)\nthis:\n  g ` (C0 \\<inter> D0) = C0 \\<inter> D0\n\ngoal (1 subgoal):\n 1. g (f v) = v", "ultimately"], ["proof (chain)\npicking this:\n  D0 = insert (g (f v)) (g ` (C0 \\<inter> D0))\n  g ` (C0 \\<inter> D0) = C0 \\<inter> D0", "have \"D0 = insert (g (f v)) (C0\\<inter>D0)\""], ["proof (prove)\nusing this:\n  D0 = insert (g (f v)) (g ` (C0 \\<inter> D0))\n  g ` (C0 \\<inter> D0) = C0 \\<inter> D0\n\ngoal (1 subgoal):\n 1. D0 = insert (g (f v)) (C0 \\<inter> D0)", "by simp"], ["proof (state)\nthis:\n  D0 = insert (g (f v)) (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. g (f v) = v", "with assms"], ["proof (chain)\npicking this:\n  v \\<in> D0 - C0\n  D0 = insert (g (f v)) (C0 \\<inter> D0)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> D0 - C0\n  D0 = insert (g (f v)) (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. g (f v) = v", "using 1"], ["proof (prove)\nusing this:\n  v \\<in> D0 - C0\n  D0 = insert (g (f v)) (C0 \\<inter> D0)\n  D0 = insert v (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. g (f v) = v", "by force"], ["proof (state)\nthis:\n  g (f v) = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas double_fold_C0 =\n  OpposedThinChamberComplexFoldings.double_fold_D0[OF fg_symmetric]"], ["", "lemma flopped_half_chamber_systems_fg: \"\\<C>-f\\<turnstile>\\<C> = g\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> =\n    g \\<turnstile> folding_g.\\<C>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> =\n    g \\<turnstile> folding_g.\\<C>", "from chambers(1,3,4)"], ["proof (chain)\npicking this:\n  folding_g.chamber C0\n  C0 \\<noteq> D0\n  f ` D0 = C0", "have \"D0\\<in>\\<C>-f\\<turnstile>\\<C>\" \"C0\\<in>\\<C>-g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  folding_g.chamber C0\n  C0 \\<noteq> D0\n  f ` D0 = C0\n\ngoal (1 subgoal):\n 1. D0 \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> &&&\n    C0 \\<in> folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>", "using chamber_system_def chamber_D0 folding_f.chamber_retraction2[of D0]\n          folding_g.chamber_retraction2[of C0]"], ["proof (prove)\nusing this:\n  folding_g.chamber C0\n  C0 \\<noteq> D0\n  f ` D0 = C0\n  folding_g.\\<C> \\<equiv> Collect folding_g.chamber\n  folding_g.chamber D0\n  D0 \\<in> f \\<turnstile> folding_g.\\<C> \\<Longrightarrow> f ` D0 = D0\n  C0 \\<in> g \\<turnstile> folding_g.\\<C> \\<Longrightarrow> D0 = C0\n\ngoal (1 subgoal):\n 1. D0 \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> &&&\n    C0 \\<in> folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>", "by    auto"], ["proof (state)\nthis:\n  D0 \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>\n  C0 \\<in> folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> =\n    g \\<turnstile> folding_g.\\<C>", "with chambers(2,4)"], ["proof (chain)\npicking this:\n  C0 \\<sim> D0\n  f ` D0 = C0\n  D0 \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>\n  C0 \\<in> folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  C0 \\<sim> D0\n  f ` D0 = C0\n  D0 \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>\n  C0 \\<in> folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> =\n    g \\<turnstile> folding_g.\\<C>", "using ThinChamberComplexFolding.chamber_image_and_complement[\n            OF ThinChamberComplexFolding_g, of C0\n          ]\n          ThinChamberComplexFolding.chamber_image_and_complement[\n            OF ThinChamberComplexFolding_f, of D0\n          ]\n          adjacent_sym[of C0 D0]"], ["proof (prove)\nusing this:\n  C0 \\<sim> D0\n  f ` D0 = C0\n  D0 \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>\n  C0 \\<in> folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>\n  C0 \\<in> folding_g.\\<C> - g \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n  g \\<turnstile> folding_g.\\<C> =\n  {B \\<in> folding_g.\\<C>.\n   order.greater (chamber_distance B C0) (chamber_distance B D0)}\n  C0 \\<in> folding_g.\\<C> - g \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n  folding_g.\\<C> - g \\<turnstile> folding_g.\\<C> =\n  {B \\<in> folding_g.\\<C>.\n   order.greater (chamber_distance B D0) (chamber_distance B C0)}\n  D0 \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n  f \\<turnstile> folding_g.\\<C> =\n  {B \\<in> folding_g.\\<C>.\n   order.greater (chamber_distance B D0) (chamber_distance B (f ` D0))}\n  D0 \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n  folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> =\n  {B \\<in> folding_g.\\<C>.\n   order.greater (chamber_distance B (f ` D0)) (chamber_distance B D0)}\n  C0 \\<sim> D0 \\<Longrightarrow> D0 \\<sim> C0\n\ngoal (1 subgoal):\n 1. folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> =\n    g \\<turnstile> folding_g.\\<C>", "by    force"], ["proof (state)\nthis:\n  folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> =\n  g \\<turnstile> folding_g.\\<C>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas flopped_half_chamber_systems_gf =\n  OpposedThinChamberComplexFoldings.flopped_half_chamber_systems_fg[\n    OF fg_symmetric\n  ]"], ["", "lemma flopped_half_apartments_fg: \"folding_f.opp_half_apartment = g\\<turnstile>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. folding_f.Y = g \\<turnstile> X", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> folding_f.Y \\<Longrightarrow> x \\<in> g \\<turnstile> X\n 2. \\<And>x. x \\<in> g \\<turnstile> X \\<Longrightarrow> x \\<in> folding_f.Y", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> folding_f.Y \\<Longrightarrow> x \\<in> g \\<turnstile> X\n 2. \\<And>x. x \\<in> g \\<turnstile> X \\<Longrightarrow> x \\<in> folding_f.Y", "assume \"a \\<in> folding_f.Y\""], ["proof (state)\nthis:\n  a \\<in> folding_f.Y\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> folding_f.Y \\<Longrightarrow> x \\<in> g \\<turnstile> X\n 2. \\<And>x. x \\<in> g \\<turnstile> X \\<Longrightarrow> x \\<in> folding_f.Y", "from this"], ["proof (chain)\npicking this:\n  a \\<in> folding_f.Y", "obtain C where \"C\\<in>g\\<turnstile>\\<C>\" \"a\\<subseteq>C\""], ["proof (prove)\nusing this:\n  a \\<in> folding_f.Y\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> g \\<turnstile> folding_g.\\<C>;\n         order.greater_eq C a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using folding_f.opp_half_apartment_def flopped_half_chamber_systems_fg"], ["proof (prove)\nusing this:\n  a \\<in> folding_f.Y\n  folding_f.Y \\<equiv>\n  {x \\<in> X.\n   \\<exists>C\\<in>folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>.\n      order.greater_eq C x}\n  folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> =\n  g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> g \\<turnstile> folding_g.\\<C>;\n         order.greater_eq C a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> g \\<turnstile> folding_g.\\<C>\n  order.greater_eq C a\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> folding_f.Y \\<Longrightarrow> x \\<in> g \\<turnstile> X\n 2. \\<And>x. x \\<in> g \\<turnstile> X \\<Longrightarrow> x \\<in> folding_f.Y", "thus \"a\\<in>g\\<turnstile>X\""], ["proof (prove)\nusing this:\n  C \\<in> g \\<turnstile> folding_g.\\<C>\n  order.greater_eq C a\n\ngoal (1 subgoal):\n 1. a \\<in> g \\<turnstile> X", "using chamber_system_simplices\n          ChamberComplex.faces[OF folding_g.chambercomplex_image, of C]"], ["proof (prove)\nusing this:\n  C \\<in> g \\<turnstile> folding_g.\\<C>\n  order.greater_eq C a\n  order.greater_eq X folding_g.\\<C>\n  \\<lbrakk>C \\<in> g \\<turnstile> X; order.greater_eq C ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> g \\<turnstile> X\n\ngoal (1 subgoal):\n 1. a \\<in> g \\<turnstile> X", "by    auto"], ["proof (state)\nthis:\n  a \\<in> g \\<turnstile> X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> g \\<turnstile> X \\<Longrightarrow> x \\<in> folding_f.Y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> g \\<turnstile> X \\<Longrightarrow> x \\<in> folding_f.Y", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> g \\<turnstile> X \\<Longrightarrow> x \\<in> folding_f.Y", "assume b: \"b \\<in> g\\<turnstile>X\""], ["proof (state)\nthis:\n  b \\<in> g \\<turnstile> X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> g \\<turnstile> X \\<Longrightarrow> x \\<in> folding_f.Y", "from this"], ["proof (chain)\npicking this:\n  b \\<in> g \\<turnstile> X", "obtain C where C: \"C\\<in>\\<C>\" \"b \\<subseteq> g`C\""], ["proof (prove)\nusing this:\n  b \\<in> g \\<turnstile> X\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> folding_g.\\<C>; order.greater_eq (g ` C) b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using simplex_in_max chamber_system_def"], ["proof (prove)\nusing this:\n  b \\<in> g \\<turnstile> X\n  ?y \\<in> X \\<Longrightarrow>\n  \\<exists>x. folding_g.chamber x \\<and> order.greater_eq x ?y\n  folding_g.\\<C> \\<equiv> Collect folding_g.chamber\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> folding_g.\\<C>; order.greater_eq (g ` C) b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  C \\<in> folding_g.\\<C>\n  order.greater_eq (g ` C) b\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> g \\<turnstile> X \\<Longrightarrow> x \\<in> folding_f.Y", "from C(1)"], ["proof (chain)\npicking this:\n  C \\<in> folding_g.\\<C>", "have \"g`C \\<in> g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  C \\<in> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. g ` C \\<in> g \\<turnstile> folding_g.\\<C>", "by fast"], ["proof (state)\nthis:\n  g ` C \\<in> g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> g \\<turnstile> X \\<Longrightarrow> x \\<in> folding_f.Y", "hence \"g`C \\<in> \\<C>-f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  g ` C \\<in> g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. g ` C \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>", "using flopped_half_chamber_systems_fg"], ["proof (prove)\nusing this:\n  g ` C \\<in> g \\<turnstile> folding_g.\\<C>\n  folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> =\n  g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. g ` C \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>", "by simp"], ["proof (state)\nthis:\n  g ` C \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> g \\<turnstile> X \\<Longrightarrow> x \\<in> folding_f.Y", "with C(2)"], ["proof (chain)\npicking this:\n  order.greater_eq (g ` C) b\n  g ` C \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>", "have \"\\<exists>C\\<in>\\<C>-f\\<turnstile>\\<C>. b\\<subseteq>C\""], ["proof (prove)\nusing this:\n  order.greater_eq (g ` C) b\n  g ` C \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>C\\<in>folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>.\n       order.greater_eq C b", "by auto"], ["proof (state)\nthis:\n  \\<exists>C\\<in>folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>.\n     order.greater_eq C b\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> g \\<turnstile> X \\<Longrightarrow> x \\<in> folding_f.Y", "moreover"], ["proof (state)\nthis:\n  \\<exists>C\\<in>folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>.\n     order.greater_eq C b\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> g \\<turnstile> X \\<Longrightarrow> x \\<in> folding_f.Y", "from b"], ["proof (chain)\npicking this:\n  b \\<in> g \\<turnstile> X", "have \"b\\<in>X\""], ["proof (prove)\nusing this:\n  b \\<in> g \\<turnstile> X\n\ngoal (1 subgoal):\n 1. b \\<in> X", "using folding_g.simplex_map"], ["proof (prove)\nusing this:\n  b \\<in> g \\<turnstile> X\n  ?x \\<in> X \\<Longrightarrow> g ` ?x \\<in> X\n\ngoal (1 subgoal):\n 1. b \\<in> X", "by fast"], ["proof (state)\nthis:\n  b \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> g \\<turnstile> X \\<Longrightarrow> x \\<in> folding_f.Y", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>C\\<in>folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>.\n     order.greater_eq C b\n  b \\<in> X", "show \"b \\<in> folding_f.Y\""], ["proof (prove)\nusing this:\n  \\<exists>C\\<in>folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>.\n     order.greater_eq C b\n  b \\<in> X\n\ngoal (1 subgoal):\n 1. b \\<in> folding_f.Y", "unfolding folding_f.opp_half_apartment_def"], ["proof (prove)\nusing this:\n  \\<exists>C\\<in>folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>.\n     order.greater_eq C b\n  b \\<in> X\n\ngoal (1 subgoal):\n 1. b \\<in> {x \\<in> X.\n             \\<exists>C\\<in>folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>.\n                order.greater_eq C x}", "by simp"], ["proof (state)\nthis:\n  b \\<in> folding_f.Y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas flopped_half_apartments_gf =\n  OpposedThinChamberComplexFoldings.flopped_half_apartments_fg[\n    OF fg_symmetric\n  ]"], ["", "lemma vertex_set_split: \"\\<Union>X = f`(\\<Union>X) \\<union> g`(\\<Union>X)\"\n\\<comment> \\<open>@{term f} and @{term g} will both be the identity on the intersection\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> X = f ` \\<Union> X \\<union> g ` \\<Union> X", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq (f ` \\<Union> X \\<union> g ` \\<Union> X) (\\<Union> X)\n 2. order.greater_eq (\\<Union> X) (f ` \\<Union> X \\<union> g ` \\<Union> X)", "show \"\\<Union>X \\<supseteq> f`(\\<Union>X) \\<union> g`(\\<Union>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (\\<Union> X) (f ` \\<Union> X \\<union> g ` \\<Union> X)", "using folding_f.simplex_map folding_g.simplex_map"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> f ` ?x \\<in> X\n  ?x \\<in> X \\<Longrightarrow> g ` ?x \\<in> X\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<Union> X) (f ` \\<Union> X \\<union> g ` \\<Union> X)", "by auto"], ["proof (state)\nthis:\n  order.greater_eq (\\<Union> X) (f ` \\<Union> X \\<union> g ` \\<Union> X)\n\ngoal (1 subgoal):\n 1. order.greater_eq (f ` \\<Union> X \\<union> g ` \\<Union> X) (\\<Union> X)", "show \"\\<Union>X \\<subseteq> f`(\\<Union>X) \\<union> g`(\\<Union>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (f ` \\<Union> X \\<union> g ` \\<Union> X) (\\<Union> X)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> X \\<Longrightarrow>\n       x \\<in> f ` \\<Union> X \\<union> g ` \\<Union> X", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> X \\<Longrightarrow>\n       x \\<in> f ` \\<Union> X \\<union> g ` \\<Union> X", "assume \"a\\<in>\\<Union>X\""], ["proof (state)\nthis:\n  a \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> X \\<Longrightarrow>\n       x \\<in> f ` \\<Union> X \\<union> g ` \\<Union> X", "from this"], ["proof (chain)\npicking this:\n  a \\<in> \\<Union> X", "obtain C where C: \"chamber C\" \"a\\<in>C\""], ["proof (prove)\nusing this:\n  a \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>folding_g.chamber C; a \\<in> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using simplex_in_max"], ["proof (prove)\nusing this:\n  a \\<in> \\<Union> X\n  ?y \\<in> X \\<Longrightarrow>\n  \\<exists>x. folding_g.chamber x \\<and> order.greater_eq x ?y\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>folding_g.chamber C; a \\<in> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  folding_g.chamber C\n  a \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> X \\<Longrightarrow>\n       x \\<in> f ` \\<Union> X \\<union> g ` \\<Union> X", "from C(1)"], ["proof (chain)\npicking this:\n  folding_g.chamber C", "have \"C\\<in>f\\<turnstile>\\<C> \\<or> C\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  folding_g.chamber C\n\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> folding_g.\\<C> \\<or>\n    C \\<in> g \\<turnstile> folding_g.\\<C>", "using chamber_system_def flopped_half_chamber_systems_fg"], ["proof (prove)\nusing this:\n  folding_g.chamber C\n  folding_g.\\<C> \\<equiv> Collect folding_g.chamber\n  folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> =\n  g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> folding_g.\\<C> \\<or>\n    C \\<in> g \\<turnstile> folding_g.\\<C>", "by auto"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> folding_g.\\<C> \\<or>\n  C \\<in> g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> X \\<Longrightarrow>\n       x \\<in> f ` \\<Union> X \\<union> g ` \\<Union> X", "with C(2)"], ["proof (chain)\npicking this:\n  a \\<in> C\n  C \\<in> f \\<turnstile> folding_g.\\<C> \\<or>\n  C \\<in> g \\<turnstile> folding_g.\\<C>", "show \"a \\<in> (f`\\<Union>X) \\<union> (g`\\<Union>X)\""], ["proof (prove)\nusing this:\n  a \\<in> C\n  C \\<in> f \\<turnstile> folding_g.\\<C> \\<or>\n  C \\<in> g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. a \\<in> f ` \\<Union> X \\<union> g ` \\<Union> X", "using chamber_system_simplices"], ["proof (prove)\nusing this:\n  a \\<in> C\n  C \\<in> f \\<turnstile> folding_g.\\<C> \\<or>\n  C \\<in> g \\<turnstile> folding_g.\\<C>\n  order.greater_eq X folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. a \\<in> f ` \\<Union> X \\<union> g ` \\<Union> X", "by fast"], ["proof (state)\nthis:\n  a \\<in> f ` \\<Union> X \\<union> g ` \\<Union> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq (f ` \\<Union> X \\<union> g ` \\<Union> X) (\\<Union> X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma half_chamber_system_disjoint_union:\n  \"\\<C> = f\\<turnstile>\\<C> \\<union> g\\<turnstile>\\<C>\" \"(f\\<turnstile>\\<C>) \\<inter> (g\\<turnstile>\\<C>) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. folding_g.\\<C> =\n    f \\<turnstile> folding_g.\\<C> \\<union> g \\<turnstile> folding_g.\\<C> &&&\n    f \\<turnstile> folding_g.\\<C> \\<inter> (g \\<turnstile> folding_g.\\<C>) =\n    {}", "using folding_f.chamber_system_into\n        flopped_half_chamber_systems_fg[THEN sym]"], ["proof (prove)\nusing this:\n  order.greater_eq folding_g.\\<C> (f \\<turnstile> folding_g.\\<C>)\n  g \\<turnstile> folding_g.\\<C> =\n  folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. folding_g.\\<C> =\n    f \\<turnstile> folding_g.\\<C> \\<union> g \\<turnstile> folding_g.\\<C> &&&\n    f \\<turnstile> folding_g.\\<C> \\<inter> (g \\<turnstile> folding_g.\\<C>) =\n    {}", "by    auto"], ["", "lemmas halfchsys_decomp =\n  half_chamber_system_disjoint_union"], ["", "lemma chamber_in_other_half_fg: \"chamber C \\<Longrightarrow> C\\<notin>f\\<turnstile>\\<C> \\<Longrightarrow> C\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>folding_g.chamber C;\n     C \\<notin> f \\<turnstile> folding_g.\\<C>\\<rbrakk>\n    \\<Longrightarrow> C \\<in> g \\<turnstile> folding_g.\\<C>", "using chamber_system_def half_chamber_system_disjoint_union(1)"], ["proof (prove)\nusing this:\n  folding_g.\\<C> \\<equiv> Collect folding_g.chamber\n  folding_g.\\<C> =\n  f \\<turnstile> folding_g.\\<C> \\<union> g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>folding_g.chamber C;\n     C \\<notin> f \\<turnstile> folding_g.\\<C>\\<rbrakk>\n    \\<Longrightarrow> C \\<in> g \\<turnstile> folding_g.\\<C>", "by blast"], ["", "lemma adjacent_half_chamber_system_image_fg:\n  \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> D\\<in>g\\<turnstile>\\<C> \\<Longrightarrow> C\\<sim>D \\<Longrightarrow> f`D = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n     D \\<in> g \\<turnstile> folding_g.\\<C>; C \\<sim> D\\<rbrakk>\n    \\<Longrightarrow> f ` D = C", "using ThinChamberComplexFolding.adjacent_half_chamber_system_image[\n          OF ThinChamberComplexFolding_f\n        ]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?C \\<in> f \\<turnstile> folding_g.\\<C>;\n   ?D \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>;\n   ?C \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> f ` ?D = ?C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n     D \\<in> g \\<turnstile> folding_g.\\<C>; C \\<sim> D\\<rbrakk>\n    \\<Longrightarrow> f ` D = C", "by    (simp add: flopped_half_chamber_systems_fg)"], ["", "lemmas adjacent_half_chamber_system_image_gf =\n  OpposedThinChamberComplexFoldings.adjacent_half_chamber_system_image_fg[\n    OF fg_symmetric\n  ]"], ["", "lemmas adjhalfchsys_image_gf =\n  adjacent_half_chamber_system_image_gf"], ["", "lemma switch_basechamber:\n  assumes \"C\\<in>f\\<turnstile>\\<C>\" \"C\\<sim>g`C\"\n  shows   \"OpposedThinChamberComplexFoldings X f g C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings X f g C", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. folding_g.chamber C\n 2. C \\<sim> g ` C\n 3. C \\<noteq> g ` C\n 4. f ` g ` C = C", "from assms(1)"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>", "have \"C\\<in>\\<C>-g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. C \\<in> folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>", "using flopped_half_chamber_systems_gf"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  folding_g.\\<C> - g \\<turnstile> folding_g.\\<C> =\n  f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. C \\<in> folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>", "by simp"], ["proof (state)\nthis:\n  C \\<in> folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>\n\ngoal (4 subgoals):\n 1. folding_g.chamber C\n 2. C \\<sim> g ` C\n 3. C \\<noteq> g ` C\n 4. f ` g ` C = C", "with assms"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  C \\<sim> g ` C\n  C \\<in> folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>", "show \"chamber C\" \"C \\<noteq> g`C\" \"f`g`C = C\""], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  C \\<sim> g ` C\n  C \\<in> folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. folding_g.chamber C &&& C \\<noteq> g ` C &&& f ` g ` C = C", "using chamber_system_def adjacent_half_chamber_system_image_fg[of C \"g`C\"]"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  C \\<sim> g ` C\n  C \\<in> folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>\n  folding_g.\\<C> \\<equiv> Collect folding_g.chamber\n  \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n   g ` C \\<in> g \\<turnstile> folding_g.\\<C>; C \\<sim> g ` C\\<rbrakk>\n  \\<Longrightarrow> f ` g ` C = C\n\ngoal (1 subgoal):\n 1. folding_g.chamber C &&& C \\<noteq> g ` C &&& f ` g ` C = C", "by    auto"], ["proof (state)\nthis:\n  folding_g.chamber C\n  C \\<noteq> g ` C\n  f ` g ` C = C\n\ngoal (1 subgoal):\n 1. C \\<sim> g ` C", "qed (rule assms(2))"], ["", "lemma unique_half_chamber_system_f:\n  assumes \"OpposedThinChamberComplexFoldings X f' g' C0\" \"g'`C0 = D0\"\n  shows   \"f'\\<turnstile>\\<C> = f\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' \\<turnstile> folding_g.\\<C> = f \\<turnstile> folding_g.\\<C>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. f' \\<turnstile> folding_g.\\<C> = f \\<turnstile> folding_g.\\<C>", "have 1: \"OpposedThinChamberComplexFoldings X f g' C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings X f g' C0", "proof (rule OpposedThinChamberComplexFoldings.intro)"], ["proof (state)\ngoal (4 subgoals):\n 1. ThinChamberComplex X\n 2. ChamberComplexFolding X f\n 3. ChamberComplexFolding X g'\n 4. OpposedThinChamberComplexFoldings_axioms X f g' C0", "show \"ChamberComplexFolding X f\" \"ThinChamberComplex X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexFolding X f &&& ThinChamberComplex X", ".."], ["proof (state)\nthis:\n  ChamberComplexFolding X f\n  ThinChamberComplex X\n\ngoal (2 subgoals):\n 1. ChamberComplexFolding X g'\n 2. OpposedThinChamberComplexFoldings_axioms X f g' C0", "from assms(1)"], ["proof (chain)\npicking this:\n  OpposedThinChamberComplexFoldings X f' g' C0", "show \"ChamberComplexFolding X g'\""], ["proof (prove)\nusing this:\n  OpposedThinChamberComplexFoldings X f' g' C0\n\ngoal (1 subgoal):\n 1. ChamberComplexFolding X g'", "using OpposedThinChamberComplexFoldings.axioms(3)"], ["proof (prove)\nusing this:\n  OpposedThinChamberComplexFoldings X f' g' C0\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  ChamberComplexFolding ?X ?g\n\ngoal (1 subgoal):\n 1. ChamberComplexFolding X g'", "by fastforce"], ["proof (state)\nthis:\n  ChamberComplexFolding X g'\n\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings_axioms X f g' C0", "from assms(2) chambers"], ["proof (chain)\npicking this:\n  g' ` C0 = D0\n  folding_g.chamber C0\n  C0 \\<sim> D0\n  C0 \\<noteq> D0\n  f ` D0 = C0", "show  \"OpposedThinChamberComplexFoldings_axioms X f g' C0\""], ["proof (prove)\nusing this:\n  g' ` C0 = D0\n  folding_g.chamber C0\n  C0 \\<sim> D0\n  C0 \\<noteq> D0\n  f ` D0 = C0\n\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings_axioms X f g' C0", "by    unfold_locales auto"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings_axioms X f g' C0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g' C0\n\ngoal (1 subgoal):\n 1. f' \\<turnstile> folding_g.\\<C> = f \\<turnstile> folding_g.\\<C>", "define a b where \"a = f'\\<turnstile>\\<C>\" and \"b = f\\<turnstile>\\<C>\""], ["proof (state)\nthis:\n  a = f' \\<turnstile> folding_g.\\<C>\n  b = f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. f' \\<turnstile> folding_g.\\<C> = f \\<turnstile> folding_g.\\<C>", "hence \"a\\<subseteq>\\<C>\" \"b\\<subseteq>\\<C>\" \"\\<C>-a = \\<C>-b\""], ["proof (prove)\nusing this:\n  a = f' \\<turnstile> folding_g.\\<C>\n  b = f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. order.greater_eq folding_g.\\<C> a &&&\n    order.greater_eq folding_g.\\<C> b &&&\n    folding_g.\\<C> - a = folding_g.\\<C> - b", "using OpposedThinChamberComplexFoldings.axioms(2)[OF assms(1)]\n          OpposedThinChamberComplexFoldings.axioms(2)[OF 1]\n          ChamberComplexFolding.chamber_system_into[of X f]\n          ChamberComplexFolding.chamber_system_into[of X f']\n          OpposedThinChamberComplexFoldings.flopped_half_chamber_systems_fg[\n            OF assms(1)\n          ]\n          OpposedThinChamberComplexFoldings.flopped_half_chamber_systems_fg[\n            OF 1\n          ]"], ["proof (prove)\nusing this:\n  a = f' \\<turnstile> folding_g.\\<C>\n  b = f \\<turnstile> folding_g.\\<C>\n  ChamberComplexFolding X f'\n  ChamberComplexFolding X f\n  ChamberComplexFolding X f \\<Longrightarrow>\n  order.greater_eq folding_g.\\<C> (f \\<turnstile> folding_g.\\<C>)\n  ChamberComplexFolding X f' \\<Longrightarrow>\n  order.greater_eq folding_g.\\<C> (f' \\<turnstile> folding_g.\\<C>)\n  folding_g.\\<C> - f' \\<turnstile> folding_g.\\<C> =\n  g' \\<turnstile> folding_g.\\<C>\n  folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> =\n  g' \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. order.greater_eq folding_g.\\<C> a &&&\n    order.greater_eq folding_g.\\<C> b &&&\n    folding_g.\\<C> - a = folding_g.\\<C> - b", "by    auto"], ["proof (state)\nthis:\n  order.greater_eq folding_g.\\<C> a\n  order.greater_eq folding_g.\\<C> b\n  folding_g.\\<C> - a = folding_g.\\<C> - b\n\ngoal (1 subgoal):\n 1. f' \\<turnstile> folding_g.\\<C> = f \\<turnstile> folding_g.\\<C>", "hence \"a=b\""], ["proof (prove)\nusing this:\n  order.greater_eq folding_g.\\<C> a\n  order.greater_eq folding_g.\\<C> b\n  folding_g.\\<C> - a = folding_g.\\<C> - b\n\ngoal (1 subgoal):\n 1. a = b", "by fast"], ["proof (state)\nthis:\n  a = b\n\ngoal (1 subgoal):\n 1. f' \\<turnstile> folding_g.\\<C> = f \\<turnstile> folding_g.\\<C>", "with a_def b_def"], ["proof (chain)\npicking this:\n  a = f' \\<turnstile> folding_g.\\<C>\n  b = f \\<turnstile> folding_g.\\<C>\n  a = b", "show ?thesis"], ["proof (prove)\nusing this:\n  a = f' \\<turnstile> folding_g.\\<C>\n  b = f \\<turnstile> folding_g.\\<C>\n  a = b\n\ngoal (1 subgoal):\n 1. f' \\<turnstile> folding_g.\\<C> = f \\<turnstile> folding_g.\\<C>", "by simp"], ["proof (state)\nthis:\n  f' \\<turnstile> folding_g.\\<C> = f \\<turnstile> folding_g.\\<C>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_half_chamber_system_g:\n  \"OpposedThinChamberComplexFoldings X f' g' C0 \\<Longrightarrow> g'`C0 = D0 \\<Longrightarrow>\n    g'\\<turnstile>\\<C> = g\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OpposedThinChamberComplexFoldings X f' g' C0;\n     g' ` C0 = D0\\<rbrakk>\n    \\<Longrightarrow> g' \\<turnstile> folding_g.\\<C> =\n                      g \\<turnstile> folding_g.\\<C>", "using unique_half_chamber_system_f flopped_half_chamber_systems_fg\n        OpposedThinChamberComplexFoldings.flopped_half_chamber_systems_fg[\n          of X f' g'\n        ]"], ["proof (prove)\nusing this:\n  \\<lbrakk>OpposedThinChamberComplexFoldings X ?f' ?g' C0;\n   ?g' ` C0 = D0\\<rbrakk>\n  \\<Longrightarrow> ?f' \\<turnstile> folding_g.\\<C> =\n                    f \\<turnstile> folding_g.\\<C>\n  folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> =\n  g \\<turnstile> folding_g.\\<C>\n  OpposedThinChamberComplexFoldings X f' g' ?C0.0 \\<Longrightarrow>\n  folding_g.\\<C> - f' \\<turnstile> folding_g.\\<C> =\n  g' \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>OpposedThinChamberComplexFoldings X f' g' C0;\n     g' ` C0 = D0\\<rbrakk>\n    \\<Longrightarrow> g' \\<turnstile> folding_g.\\<C> =\n                      g \\<turnstile> folding_g.\\<C>", "by    simp"], ["", "lemma split_gallery_fg:\n  \"\\<lbrakk> C\\<in>f\\<turnstile>\\<C>; D\\<in>g\\<turnstile>\\<C>; gallery (C#Cs@[D]) \\<rbrakk> \\<Longrightarrow>\n    \\<exists>As A B Bs. A\\<in>f\\<turnstile>\\<C> \\<and> B\\<in>g\\<turnstile>\\<C> \\<and> C#Cs@[D] = As@A#B#Bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n     D \\<in> g \\<turnstile> folding_g.\\<C>;\n     folding_g.gallery (C # Cs @ [D])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>As A B Bs.\n                         A \\<in> f \\<turnstile> folding_g.\\<C> \\<and>\n                         B \\<in> g \\<turnstile> folding_g.\\<C> \\<and>\n                         C # Cs @ [D] = As @ A # B # Bs", "using folding_f.split_gallery flopped_half_chamber_systems_fg"], ["proof (prove)\nusing this:\n  \\<lbrakk>?C \\<in> f \\<turnstile> folding_g.\\<C>;\n   ?D \\<in> folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>;\n   folding_g.gallery (?C # ?Cs @ [?D])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>As A B Bs.\n                       A \\<in> f \\<turnstile> folding_g.\\<C> \\<and>\n                       B \\<in> folding_g.\\<C> -\n                               f \\<turnstile> folding_g.\\<C> \\<and>\n                       ?C # ?Cs @ [?D] = As @ A # B # Bs\n  folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> =\n  g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n     D \\<in> g \\<turnstile> folding_g.\\<C>;\n     folding_g.gallery (C # Cs @ [D])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>As A B Bs.\n                         A \\<in> f \\<turnstile> folding_g.\\<C> \\<and>\n                         B \\<in> g \\<turnstile> folding_g.\\<C> \\<and>\n                         C # Cs @ [D] = As @ A # B # Bs", "by simp"], ["", "lemmas split_gallery_gf =\n  OpposedThinChamberComplexFoldings.split_gallery_fg[OF fg_symmetric]"], ["", "end"], ["", "(* context OpposedThinChamberComplexFoldings *)"], ["", "subsubsection \\<open>The automorphism induced by a pair of opposed foldings\\<close>"], ["", "text \\<open>\n  Recall that a folding of a chamber complex is a special kind of chamber complex retraction, and\n  so is the identity on its image. Hence a pair of opposed foldings will be the identity on the\n  intersection of their images and so we can stitch them together to create an automorphism of the\n  chamber complex, by allowing each folding to act on the complement of its image.\n  This automorphism will be of order two, and will be the unique automorphism of the chamber\n  complex that fixes pointwise the facet shared by the pair of adjacent chambers associated to the\n  opposed foldings.\n\\<close>"], ["", "context OpposedThinChamberComplexFoldings\nbegin"], ["", "definition induced_automorphism :: \"'a\\<Rightarrow>'a\"\n  where \"induced_automorphism v \\<equiv>\n          if v\\<in>f`(\\<Union>X) then g v else if v\\<in>g`(\\<Union>X) then f v else v\"\n\\<comment> \\<open>@{term f} and @{term g} will both be the identity on the intersection of their images\\<close>"], ["", "abbreviation \"\\<s> \\<equiv> induced_automorphism\""], ["", "lemma induced_automorphism_fg_symmetric:\n  \"\\<s> = OpposedThinChamberComplexFoldings.\\<s> X g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<s> = OpposedThinChamberComplexFoldings.induced_automorphism X g f", "by  (auto simp add:\n        folding_f.vertex_retraction folding_g.vertex_retraction\n        induced_automorphism_def\n        OpposedThinChamberComplexFoldings.induced_automorphism_def[\n          OF fg_symmetric\n        ]\n      )"], ["", "lemma induced_automorphism_on_simplices_fg: \"x\\<in>f\\<turnstile>X \\<Longrightarrow> v\\<in>x \\<Longrightarrow> \\<s> v = g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> f \\<turnstile> X; v \\<in> x\\<rbrakk>\n    \\<Longrightarrow> \\<s> v = g v", "using induced_automorphism_def"], ["proof (prove)\nusing this:\n  \\<s> ?v \\<equiv>\n  if ?v \\<in> f ` \\<Union> X then g ?v else restrict1 f (g ` \\<Union> X) ?v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> f \\<turnstile> X; v \\<in> x\\<rbrakk>\n    \\<Longrightarrow> \\<s> v = g v", "by auto"], ["", "lemma induced_automorphism_eq_foldings_on_chambers_fg:\n  \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> fun_eq_on \\<s> g C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n    fun_eq_on \\<s> g C", "using chamber_system_simplices induced_automorphism_on_simplices_fg[of C]"], ["proof (prove)\nusing this:\n  order.greater_eq X folding_g.\\<C>\n  \\<lbrakk>C \\<in> f \\<turnstile> X; ?v \\<in> C\\<rbrakk>\n  \\<Longrightarrow> \\<s> ?v = g ?v\n\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n    fun_eq_on \\<s> g C", "by    (fast intro: fun_eq_onI)"], ["", "lemmas indaut_eq_foldch_fg =\n  induced_automorphism_eq_foldings_on_chambers_fg"], ["", "lemma induced_automorphism_eq_foldings_on_chambers_gf:\n  \"C\\<in>g\\<turnstile>\\<C> \\<Longrightarrow> fun_eq_on \\<s> f C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> g \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n    fun_eq_on \\<s> f C", "by  (auto simp add:\n        OpposedThinChamberComplexFoldings.indaut_eq_foldch_fg[\n          OF fg_symmetric\n        ]\n        induced_automorphism_fg_symmetric\n      )"], ["", "lemma induced_automorphism_on_chamber_vertices_f:\n  \"chamber C \\<Longrightarrow> v\\<in>C \\<Longrightarrow> \\<s> v = (if C\\<in>f\\<turnstile>\\<C> then g v else f v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>folding_g.chamber C; v \\<in> C\\<rbrakk>\n    \\<Longrightarrow> \\<s> v =\n                      (if C \\<in> f \\<turnstile> folding_g.\\<C> then g v\n                       else f v)", "using chamber_system_def induced_automorphism_eq_foldings_on_chambers_fg\n        induced_automorphism_eq_foldings_on_chambers_gf\n        flopped_half_chamber_systems_fg[THEN sym]\n        fun_eq_onD[of \\<s> g C] fun_eq_onD[of \\<s> f C]"], ["proof (prove)\nusing this:\n  folding_g.\\<C> \\<equiv> Collect folding_g.chamber\n  ?C \\<in> f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n  fun_eq_on \\<s> g ?C\n  ?C \\<in> g \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n  fun_eq_on \\<s> f ?C\n  g \\<turnstile> folding_g.\\<C> =\n  folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>\n  \\<lbrakk>fun_eq_on \\<s> g C; ?a \\<in> C\\<rbrakk>\n  \\<Longrightarrow> \\<s> ?a = g ?a\n  \\<lbrakk>fun_eq_on \\<s> f C; ?a \\<in> C\\<rbrakk>\n  \\<Longrightarrow> \\<s> ?a = f ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>folding_g.chamber C; v \\<in> C\\<rbrakk>\n    \\<Longrightarrow> \\<s> v =\n                      (if C \\<in> f \\<turnstile> folding_g.\\<C> then g v\n                       else f v)", "by    auto"], ["", "lemma induced_automorphism_simplex_image:\n  \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> x\\<subseteq>C \\<Longrightarrow> \\<s>`x = g`x\" \"C\\<in>g\\<turnstile>\\<C> \\<Longrightarrow> x\\<subseteq>C \\<Longrightarrow> \\<s>`x = f`x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n      order.greater_eq C x\\<rbrakk>\n     \\<Longrightarrow> \\<s> ` x = g ` x) &&&\n    (\\<lbrakk>C \\<in> g \\<turnstile> folding_g.\\<C>;\n      order.greater_eq C x\\<rbrakk>\n     \\<Longrightarrow> \\<s> ` x = f ` x)", "using fun_eq_on_im[of \\<s> g C] fun_eq_on_im[of \\<s> f C]\n        induced_automorphism_eq_foldings_on_chambers_fg\n        induced_automorphism_eq_foldings_on_chambers_gf"], ["proof (prove)\nusing this:\n  \\<lbrakk>fun_eq_on \\<s> g C; order.greater_eq C ?B\\<rbrakk>\n  \\<Longrightarrow> \\<s> ` ?B = g ` ?B\n  \\<lbrakk>fun_eq_on \\<s> f C; order.greater_eq C ?B\\<rbrakk>\n  \\<Longrightarrow> \\<s> ` ?B = f ` ?B\n  ?C \\<in> f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n  fun_eq_on \\<s> g ?C\n  ?C \\<in> g \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n  fun_eq_on \\<s> f ?C\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n      order.greater_eq C x\\<rbrakk>\n     \\<Longrightarrow> \\<s> ` x = g ` x) &&&\n    (\\<lbrakk>C \\<in> g \\<turnstile> folding_g.\\<C>;\n      order.greater_eq C x\\<rbrakk>\n     \\<Longrightarrow> \\<s> ` x = f ` x)", "by    auto"], ["", "lemma induced_automorphism_chamber_list_image_fg:\n  \"set Cs \\<subseteq> f\\<turnstile>\\<C> \\<Longrightarrow> \\<s>\\<Turnstile>Cs = g\\<Turnstile>Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (f \\<turnstile> folding_g.\\<C>)\n     (set Cs) \\<Longrightarrow>\n    \\<s> \\<Turnstile> Cs = g \\<Turnstile> Cs", "proof (induct Cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq (f \\<turnstile> folding_g.\\<C>)\n     (set []) \\<Longrightarrow>\n    \\<s> \\<Turnstile> [] = g \\<Turnstile> []\n 2. \\<And>a Cs.\n       \\<lbrakk>order.greater_eq (f \\<turnstile> folding_g.\\<C>)\n                 (set Cs) \\<Longrightarrow>\n                \\<s> \\<Turnstile> Cs = g \\<Turnstile> Cs;\n        order.greater_eq (f \\<turnstile> folding_g.\\<C>)\n         (set (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> \\<s> \\<Turnstile> (a # Cs) =\n                         g \\<Turnstile> (a # Cs)", "case (Cons C Cs)"], ["proof (state)\nthis:\n  order.greater_eq (f \\<turnstile> folding_g.\\<C>)\n   (set Cs) \\<Longrightarrow>\n  \\<s> \\<Turnstile> Cs = g \\<Turnstile> Cs\n  order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set (C # Cs))\n\ngoal (2 subgoals):\n 1. order.greater_eq (f \\<turnstile> folding_g.\\<C>)\n     (set []) \\<Longrightarrow>\n    \\<s> \\<Turnstile> [] = g \\<Turnstile> []\n 2. \\<And>a Cs.\n       \\<lbrakk>order.greater_eq (f \\<turnstile> folding_g.\\<C>)\n                 (set Cs) \\<Longrightarrow>\n                \\<s> \\<Turnstile> Cs = g \\<Turnstile> Cs;\n        order.greater_eq (f \\<turnstile> folding_g.\\<C>)\n         (set (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> \\<s> \\<Turnstile> (a # Cs) =\n                         g \\<Turnstile> (a # Cs)", "thus ?case"], ["proof (prove)\nusing this:\n  order.greater_eq (f \\<turnstile> folding_g.\\<C>)\n   (set Cs) \\<Longrightarrow>\n  \\<s> \\<Turnstile> Cs = g \\<Turnstile> Cs\n  order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set (C # Cs))\n\ngoal (1 subgoal):\n 1. \\<s> \\<Turnstile> (C # Cs) = g \\<Turnstile> (C # Cs)", "using induced_automorphism_simplex_image(1)[of C]"], ["proof (prove)\nusing this:\n  order.greater_eq (f \\<turnstile> folding_g.\\<C>)\n   (set Cs) \\<Longrightarrow>\n  \\<s> \\<Turnstile> Cs = g \\<Turnstile> Cs\n  order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set (C # Cs))\n  \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n   order.greater_eq C ?x\\<rbrakk>\n  \\<Longrightarrow> \\<s> ` ?x = g ` ?x\n\ngoal (1 subgoal):\n 1. \\<s> \\<Turnstile> (C # Cs) = g \\<Turnstile> (C # Cs)", "by simp"], ["proof (state)\nthis:\n  \\<s> \\<Turnstile> (C # Cs) = g \\<Turnstile> (C # Cs)\n\ngoal (1 subgoal):\n 1. order.greater_eq (f \\<turnstile> folding_g.\\<C>)\n     (set []) \\<Longrightarrow>\n    \\<s> \\<Turnstile> [] = g \\<Turnstile> []", "qed simp"], ["", "lemma induced_automorphism_chamber_image_fg:\n  \"chamber C \\<Longrightarrow> \\<s>`C = (if C\\<in>f\\<turnstile>\\<C> then g`C else f`C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. folding_g.chamber C \\<Longrightarrow>\n    \\<s> ` C =\n    (if C \\<in> f \\<turnstile> folding_g.\\<C> then g ` C else f ` C)", "using chamber_system_def induced_automorphism_simplex_image\n        flopped_half_chamber_systems_fg[THEN sym]"], ["proof (prove)\nusing this:\n  folding_g.\\<C> \\<equiv> Collect folding_g.chamber\n  \\<lbrakk>?C \\<in> f \\<turnstile> folding_g.\\<C>;\n   order.greater_eq ?C ?x\\<rbrakk>\n  \\<Longrightarrow> \\<s> ` ?x = g ` ?x\n  \\<lbrakk>?C \\<in> g \\<turnstile> folding_g.\\<C>;\n   order.greater_eq ?C ?x\\<rbrakk>\n  \\<Longrightarrow> \\<s> ` ?x = f ` ?x\n  g \\<turnstile> folding_g.\\<C> =\n  folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. folding_g.chamber C \\<Longrightarrow>\n    \\<s> ` C =\n    (if C \\<in> f \\<turnstile> folding_g.\\<C> then g ` C else f ` C)", "by    auto"], ["", "lemma induced_automorphism_C0: \"\\<s>`C0 = D0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<s> ` C0 = D0", "using chambers(1,4) basechambers_half_chamber_systems(1)\n        induced_automorphism_chamber_image_fg"], ["proof (prove)\nusing this:\n  folding_g.chamber C0\n  f ` D0 = C0\n  C0 \\<in> f \\<turnstile> folding_g.\\<C>\n  folding_g.chamber ?C \\<Longrightarrow>\n  \\<s> ` ?C =\n  (if ?C \\<in> f \\<turnstile> folding_g.\\<C> then g ` ?C else f ` ?C)\n\ngoal (1 subgoal):\n 1. \\<s> ` C0 = D0", "by    auto"], ["", "lemma induced_automorphism_fixespointwise_C0_int_D0:\n  \"fixespointwise \\<s> (C0\\<inter>D0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise \\<s> (C0 \\<inter> D0)", "using fun_eq_on_trans[of \\<s> g] fun_eq_on_subset[of \\<s> g C0]\n        fixespointwise_subset[of g D0]\n        induced_automorphism_eq_foldings_on_chambers_fg\n        basechambers_half_chamber_systems\n        folding_g.chamber_retraction1"], ["proof (prove)\nusing this:\n  \\<lbrakk>fun_eq_on \\<s> g ?A; fun_eq_on g ?h ?A\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on \\<s> ?h ?A\n  \\<lbrakk>fun_eq_on \\<s> g C0; order.greater_eq C0 ?B\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on \\<s> g ?B\n  \\<lbrakk>fixespointwise g D0; order.greater_eq D0 ?B\\<rbrakk>\n  \\<Longrightarrow> fixespointwise g ?B\n  ?C \\<in> f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n  fun_eq_on \\<s> g ?C\n  C0 \\<in> f \\<turnstile> folding_g.\\<C>\n  D0 \\<in> g \\<turnstile> folding_g.\\<C>\n  ?C \\<in> g \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n  fixespointwise g ?C\n\ngoal (1 subgoal):\n 1. fixespointwise \\<s> (C0 \\<inter> D0)", "by    auto"], ["", "lemmas indaut_fixes_fundfacet =\n  induced_automorphism_fixespointwise_C0_int_D0"], ["", "lemma induced_automorphism_adjacent_half_chamber_system_image_fg:\n  \"\\<lbrakk> C\\<in>f\\<turnstile>\\<C>; D\\<in>g\\<turnstile>\\<C>; C\\<sim>D \\<rbrakk> \\<Longrightarrow> \\<s>`D = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n     D \\<in> g \\<turnstile> folding_g.\\<C>; C \\<sim> D\\<rbrakk>\n    \\<Longrightarrow> \\<s> ` D = C", "using adjacent_half_chamber_system_image_fg[of C D]\n        induced_automorphism_simplex_image(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n   D \\<in> g \\<turnstile> folding_g.\\<C>; C \\<sim> D\\<rbrakk>\n  \\<Longrightarrow> f ` D = C\n  \\<lbrakk>?C \\<in> g \\<turnstile> folding_g.\\<C>;\n   order.greater_eq ?C ?x\\<rbrakk>\n  \\<Longrightarrow> \\<s> ` ?x = f ` ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n     D \\<in> g \\<turnstile> folding_g.\\<C>; C \\<sim> D\\<rbrakk>\n    \\<Longrightarrow> \\<s> ` D = C", "by    auto"], ["", "lemmas indaut_adj_halfchsys_im_fg =\n  induced_automorphism_adjacent_half_chamber_system_image_fg"], ["", "lemma induced_automorphism_chamber_map: \"chamber C \\<Longrightarrow> chamber (\\<s>`C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. folding_g.chamber C \\<Longrightarrow> folding_g.chamber (\\<s> ` C)", "using induced_automorphism_chamber_image_fg folding_f.chamber_map\n        folding_g.chamber_map"], ["proof (prove)\nusing this:\n  folding_g.chamber ?C \\<Longrightarrow>\n  \\<s> ` ?C =\n  (if ?C \\<in> f \\<turnstile> folding_g.\\<C> then g ` ?C else f ` ?C)\n  folding_g.chamber ?C \\<Longrightarrow> folding_g.chamber (f ` ?C)\n  folding_g.chamber ?C \\<Longrightarrow> folding_g.chamber (g ` ?C)\n\ngoal (1 subgoal):\n 1. folding_g.chamber C \\<Longrightarrow> folding_g.chamber (\\<s> ` C)", "by    auto"], ["", "lemmas indaut_chmap = induced_automorphism_chamber_map"], ["", "lemma induced_automorphism_ntrivial: \"\\<s> \\<noteq> id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<s> \\<noteq> id", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<s> = id \\<Longrightarrow> False", "assume \\<s>: \"\\<s> = id\""], ["proof (state)\nthis:\n  \\<s> = id\n\ngoal (1 subgoal):\n 1. \\<s> = id \\<Longrightarrow> False", "from chambers(2,3)"], ["proof (chain)\npicking this:\n  C0 \\<sim> D0\n  C0 \\<noteq> D0", "obtain v where v: \"v \\<notin> D0\" \"C0 = insert v (C0\\<inter>D0)\""], ["proof (prove)\nusing this:\n  C0 \\<sim> D0\n  C0 \\<noteq> D0\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<notin> D0; C0 = insert v (C0 \\<inter> D0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using adjacent_int_decomp[of C0 D0]"], ["proof (prove)\nusing this:\n  C0 \\<sim> D0\n  C0 \\<noteq> D0\n  \\<lbrakk>C0 \\<sim> D0; C0 \\<noteq> D0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v.\n                       v \\<notin> D0 \\<and> C0 = insert v (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<notin> D0; C0 = insert v (C0 \\<inter> D0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  v \\<notin> D0\n  C0 = insert v (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. \\<s> = id \\<Longrightarrow> False", "from chambers(4) \\<s> v(2)"], ["proof (chain)\npicking this:\n  f ` D0 = C0\n  \\<s> = id\n  C0 = insert v (C0 \\<inter> D0)", "have gv: \"g v = v\""], ["proof (prove)\nusing this:\n  f ` D0 = C0\n  \\<s> = id\n  C0 = insert v (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. g v = v", "using chamberD_simplex[OF chamber_D0]\n          induced_automorphism_on_simplices_fg[of C0 v, THEN sym]"], ["proof (prove)\nusing this:\n  f ` D0 = C0\n  \\<s> = id\n  C0 = insert v (C0 \\<inter> D0)\n  D0 \\<in> X\n  \\<lbrakk>C0 \\<in> f \\<turnstile> X; v \\<in> C0\\<rbrakk>\n  \\<Longrightarrow> g v = \\<s> v\n\ngoal (1 subgoal):\n 1. g v = v", "by    auto"], ["proof (state)\nthis:\n  g v = v\n\ngoal (1 subgoal):\n 1. \\<s> = id \\<Longrightarrow> False", "have \"g`C0 = C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D0 = C0", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> D0 \\<Longrightarrow> x \\<in> C0\n 2. \\<And>x. x \\<in> C0 \\<Longrightarrow> x \\<in> D0", "from v(2) gv"], ["proof (chain)\npicking this:\n  C0 = insert v (C0 \\<inter> D0)\n  g v = v", "show \"\\<And>x. x\\<in>C0 \\<Longrightarrow> x\\<in>g`C0\""], ["proof (prove)\nusing this:\n  C0 = insert v (C0 \\<inter> D0)\n  g v = v\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C0 \\<Longrightarrow> x \\<in> D0", "using g_trivial_D0"], ["proof (prove)\nusing this:\n  C0 = insert v (C0 \\<inter> D0)\n  g v = v\n  ?v \\<in> D0 \\<Longrightarrow> g ?v = ?v\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C0 \\<Longrightarrow> x \\<in> D0", "by force"], ["proof (state)\nthis:\n  ?x2 \\<in> C0 \\<Longrightarrow> ?x2 \\<in> D0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> D0 \\<Longrightarrow> x \\<in> C0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> D0 \\<Longrightarrow> x \\<in> C0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> D0 \\<Longrightarrow> x \\<in> C0", "assume \"x\\<in>g`C0\""], ["proof (state)\nthis:\n  x \\<in> D0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> D0 \\<Longrightarrow> x \\<in> C0", "from this"], ["proof (chain)\npicking this:\n  x \\<in> D0", "obtain y where y: \"y\\<in>C0\" \"x = g y\""], ["proof (prove)\nusing this:\n  x \\<in> D0\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C0; x = g y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  y \\<in> C0\n  x = g y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> D0 \\<Longrightarrow> x \\<in> C0", "moreover"], ["proof (state)\nthis:\n  y \\<in> C0\n  x = g y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> D0 \\<Longrightarrow> x \\<in> C0", "from y(1) v(2) gv"], ["proof (chain)\npicking this:\n  y \\<in> C0\n  C0 = insert v (C0 \\<inter> D0)\n  g v = v", "have \"g y = y\""], ["proof (prove)\nusing this:\n  y \\<in> C0\n  C0 = insert v (C0 \\<inter> D0)\n  g v = v\n\ngoal (1 subgoal):\n 1. g y = y", "using g_trivial_D0[of y]"], ["proof (prove)\nusing this:\n  y \\<in> C0\n  C0 = insert v (C0 \\<inter> D0)\n  g v = v\n  y \\<in> D0 \\<Longrightarrow> g y = y\n\ngoal (1 subgoal):\n 1. g y = y", "by (cases \"y=v\") auto"], ["proof (state)\nthis:\n  g y = y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> D0 \\<Longrightarrow> x \\<in> C0", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> C0\n  x = g y\n  g y = y", "show \"x\\<in>C0\""], ["proof (prove)\nusing this:\n  y \\<in> C0\n  x = g y\n  g y = y\n\ngoal (1 subgoal):\n 1. x \\<in> C0", "using y"], ["proof (prove)\nusing this:\n  y \\<in> C0\n  x = g y\n  g y = y\n  y \\<in> C0\n  x = g y\n\ngoal (1 subgoal):\n 1. x \\<in> C0", "by simp"], ["proof (state)\nthis:\n  x \\<in> C0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D0 = C0\n\ngoal (1 subgoal):\n 1. \\<s> = id \\<Longrightarrow> False", "with chambers(3)"], ["proof (chain)\npicking this:\n  C0 \\<noteq> D0\n  D0 = C0", "show False"], ["proof (prove)\nusing this:\n  C0 \\<noteq> D0\n  D0 = C0\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma induced_automorphism_bij_between_half_chamber_systems_f:\n  \"bij_betw ((`) \\<s>) (\\<C>-f\\<turnstile>\\<C>) (f\\<turnstile>\\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw ((`) \\<s>) (folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>)\n     (f \\<turnstile> folding_g.\\<C>)", "using induced_automorphism_simplex_image(2)\n        flopped_half_chamber_systems_fg\n        folding_f.opp_chambers_bij bij_betw_cong[of \"\\<C>-f\\<turnstile>\\<C>\" \"(`) \\<s>\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?C \\<in> g \\<turnstile> folding_g.\\<C>;\n   order.greater_eq ?C ?x\\<rbrakk>\n  \\<Longrightarrow> \\<s> ` ?x = f ` ?x\n  folding_g.\\<C> - f \\<turnstile> folding_g.\\<C> =\n  g \\<turnstile> folding_g.\\<C>\n  bij_betw ((`) f) (folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>)\n   (f \\<turnstile> folding_g.\\<C>)\n  (\\<And>a.\n      a \\<in> folding_g.\\<C> -\n              f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n      \\<s> ` a = ?g a) \\<Longrightarrow>\n  bij_betw ((`) \\<s>) (folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>) ?A' =\n  bij_betw ?g (folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>) ?A'\n\ngoal (1 subgoal):\n 1. bij_betw ((`) \\<s>) (folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>)\n     (f \\<turnstile> folding_g.\\<C>)", "by    auto"], ["", "lemmas indaut_bij_btw_halfchsys_f =\n  induced_automorphism_bij_between_half_chamber_systems_f"], ["", "lemma induced_automorphism_bij_between_half_chamber_systems_g:\n  \"bij_betw ((`) \\<s>) (\\<C>-g\\<turnstile>\\<C>) (g\\<turnstile>\\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw ((`) \\<s>) (folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>)\n     (g \\<turnstile> folding_g.\\<C>)", "using induced_automorphism_fg_symmetric\n        OpposedThinChamberComplexFoldings.indaut_bij_btw_halfchsys_f[\n          OF fg_symmetric\n        ]"], ["proof (prove)\nusing this:\n  \\<s> = OpposedThinChamberComplexFoldings.induced_automorphism X g f\n  bij_betw\n   ((`) (OpposedThinChamberComplexFoldings.induced_automorphism X g f))\n   (folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>)\n   (g \\<turnstile> folding_g.\\<C>)\n\ngoal (1 subgoal):\n 1. bij_betw ((`) \\<s>) (folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>)\n     (g \\<turnstile> folding_g.\\<C>)", "by    simp"], ["", "lemma induced_automorphism_halfmorphism_fopp_to_fimage:\n  \"ChamberComplexMorphism folding_f.opp_half_apartment (f\\<turnstile>X) \\<s>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexMorphism folding_f.Y (f \\<turnstile> X) \\<s>", "proof (\n  rule ChamberComplexMorphism.cong,\n  rule ThinChamberComplexFolding.morphism_half_apartments,\n  rule ThinChamberComplexFolding_f, rule fun_eq_onI\n)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> \\<Union> folding_f.Y \\<Longrightarrow> \\<s> a = f a", "show \"\\<And>v. v \\<in> \\<Union>folding_f.Y \\<Longrightarrow> \\<s> v = f v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> \\<Union> folding_f.Y \\<Longrightarrow> \\<s> v = f v", "using folding_f.opp_half_apartment_def chamber_system_simplices"], ["proof (prove)\nusing this:\n  folding_f.Y \\<equiv>\n  {x \\<in> X.\n   \\<exists>C\\<in>folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>.\n      order.greater_eq C x}\n  order.greater_eq X folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> \\<Union> folding_f.Y \\<Longrightarrow> \\<s> v = f v", "by    (force simp add:\n            flopped_half_chamber_systems_fg\n            induced_automorphism_fg_symmetric\n            OpposedThinChamberComplexFoldings.induced_automorphism_def[\n              OF fg_symmetric\n            ]\n          )"], ["proof (state)\nthis:\n  ?v2 \\<in> \\<Union> folding_f.Y \\<Longrightarrow> \\<s> ?v2 = f ?v2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas indaut_halfmorph_fopp_fim =\n  induced_automorphism_halfmorphism_fopp_to_fimage"], ["", "lemma induced_automorphism_half_chamber_system_gallery_map_f:\n  \"set Cs \\<subseteq> f\\<turnstile>\\<C> \\<Longrightarrow> gallery Cs \\<Longrightarrow> gallery (\\<s>\\<Turnstile>Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set Cs);\n     folding_g.gallery Cs\\<rbrakk>\n    \\<Longrightarrow> folding_g.gallery (\\<s> \\<Turnstile> Cs)", "using folding_g.gallery_map[of Cs]\n        induced_automorphism_chamber_list_image_fg[THEN sym]"], ["proof (prove)\nusing this:\n  folding_g.gallery Cs \\<Longrightarrow>\n  folding_g.gallery (g \\<Turnstile> Cs)\n  order.greater_eq (f \\<turnstile> folding_g.\\<C>)\n   (set ?Cs1) \\<Longrightarrow>\n  g \\<Turnstile> ?Cs1 = \\<s> \\<Turnstile> ?Cs1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set Cs);\n     folding_g.gallery Cs\\<rbrakk>\n    \\<Longrightarrow> folding_g.gallery (\\<s> \\<Turnstile> Cs)", "by    auto"], ["", "lemma induced_automorphism_half_chamber_system_pgallery_map_f:\n  \"set Cs \\<subseteq> f\\<turnstile>\\<C> \\<Longrightarrow> pgallery Cs \\<Longrightarrow> pgallery (\\<s>\\<Turnstile>Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set Cs);\n     pgallery Cs\\<rbrakk>\n    \\<Longrightarrow> pgallery (\\<s> \\<Turnstile> Cs)", "using induced_automorphism_half_chamber_system_gallery_map_f pgallery\n        flopped_half_chamber_systems_gf pgalleryD_distinct\n        folding_g.opp_chambers_distinct_map\n        induced_automorphism_chamber_list_image_fg[THEN sym]"], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set ?Cs);\n   folding_g.gallery ?Cs\\<rbrakk>\n  \\<Longrightarrow> folding_g.gallery (\\<s> \\<Turnstile> ?Cs)\n  pgallery ?xs \\<Longrightarrow> folding_g.gallery ?xs\n  folding_g.\\<C> - g \\<turnstile> folding_g.\\<C> =\n  f \\<turnstile> folding_g.\\<C>\n  pgallery ?xs \\<Longrightarrow> distinct ?xs\n  \\<lbrakk>order.greater_eq (folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>)\n            (set ?Cs);\n   distinct ?Cs\\<rbrakk>\n  \\<Longrightarrow> distinct (g \\<Turnstile> ?Cs)\n  order.greater_eq (f \\<turnstile> folding_g.\\<C>)\n   (set ?Cs1) \\<Longrightarrow>\n  g \\<Turnstile> ?Cs1 = \\<s> \\<Turnstile> ?Cs1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set Cs);\n     pgallery Cs\\<rbrakk>\n    \\<Longrightarrow> pgallery (\\<s> \\<Turnstile> Cs)", "by    (auto intro: pgalleryI_gallery)"], ["", "lemmas indaut_halfchsys_pgal_map_f =\n  induced_automorphism_half_chamber_system_pgallery_map_f"], ["", "lemma induced_automorphism_half_chamber_system_pgallery_map_g:\n  \"set Cs \\<subseteq> g\\<turnstile>\\<C> \\<Longrightarrow> pgallery Cs \\<Longrightarrow> pgallery (\\<s>\\<Turnstile>Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq (g \\<turnstile> folding_g.\\<C>) (set Cs);\n     pgallery Cs\\<rbrakk>\n    \\<Longrightarrow> pgallery (\\<s> \\<Turnstile> Cs)", "using induced_automorphism_fg_symmetric\n        OpposedThinChamberComplexFoldings.indaut_halfchsys_pgal_map_f[\n          OF fg_symmetric\n        ]"], ["proof (prove)\nusing this:\n  \\<s> = OpposedThinChamberComplexFoldings.induced_automorphism X g f\n  \\<lbrakk>order.greater_eq (g \\<turnstile> folding_g.\\<C>) (set ?Cs);\n   pgallery ?Cs\\<rbrakk>\n  \\<Longrightarrow> pgallery\n                     (OpposedThinChamberComplexFoldings.induced_automorphism\n                       X g f \\<Turnstile>\n                      ?Cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq (g \\<turnstile> folding_g.\\<C>) (set Cs);\n     pgallery Cs\\<rbrakk>\n    \\<Longrightarrow> pgallery (\\<s> \\<Turnstile> Cs)", "by    simp"], ["", "lemma induced_automorphism_halfmorphism_fimage_to_fopp:\n  \"ChamberComplexMorphism (f\\<turnstile>X) folding_f.opp_half_apartment \\<s>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexMorphism (f \\<turnstile> X) folding_f.Y \\<s>", "using OpposedThinChamberComplexFoldings.indaut_halfmorph_fopp_fim[\n          OF fg_symmetric\n        ]"], ["proof (prove)\nusing this:\n  ChamberComplexMorphism folding_g.Y (g \\<turnstile> X)\n   (OpposedThinChamberComplexFoldings.induced_automorphism X g f)\n\ngoal (1 subgoal):\n 1. ChamberComplexMorphism (f \\<turnstile> X) folding_f.Y \\<s>", "by    (auto simp add:\n          flopped_half_apartments_gf flopped_half_apartments_fg\n          induced_automorphism_fg_symmetric\n        )"], ["", "lemma induced_automorphism_selfcomp_halfmorphism_f:\n  \"ChamberComplexMorphism (f\\<turnstile>X) (f\\<turnstile>X) (\\<s>\\<circ>\\<s>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexMorphism (f \\<turnstile> X) (f \\<turnstile> X)\n     (\\<s> \\<circ> \\<s>)", "using induced_automorphism_halfmorphism_fimage_to_fopp\n        induced_automorphism_halfmorphism_fopp_to_fimage"], ["proof (prove)\nusing this:\n  ChamberComplexMorphism (f \\<turnstile> X) folding_f.Y \\<s>\n  ChamberComplexMorphism folding_f.Y (f \\<turnstile> X) \\<s>\n\ngoal (1 subgoal):\n 1. ChamberComplexMorphism (f \\<turnstile> X) (f \\<turnstile> X)\n     (\\<s> \\<circ> \\<s>)", "by    (auto intro: ChamberComplexMorphism.comp)"], ["", "lemma induced_automorphism_selfcomp_halftrivial_f: \"fixespointwise (\\<s>\\<circ>\\<s>) (\\<Union>(f\\<turnstile>X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise (\\<s> \\<circ> \\<s>) (\\<Union> (f \\<turnstile> X))", "proof (\n  rule standard_uniqueness, rule ChamberComplexMorphism.expand_codomain,\n  rule induced_automorphism_selfcomp_halfmorphism_f\n)"], ["proof (state)\ngoal (7 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. ChamberComplexMorphism (f \\<turnstile> X) X id\n 4. SimplicialComplex.maxsimp (f \\<turnstile> X) ?C\n 5. fixespointwise (\\<s> \\<circ> \\<s>) ?C\n 6. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (?C # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (?C # Cs))\n 7. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (?C # Cs) \\<Longrightarrow>\n       pgallery (id \\<Turnstile> (?C # Cs))", "show \"ChamberComplexMorphism (f\\<turnstile>X) X id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexMorphism (f \\<turnstile> X) X id", "using folding_f.chambersubcomplex_image inclusion_morphism"], ["proof (prove)\nusing this:\n  folding_g.ChamberSubcomplex (f \\<turnstile> X)\n  folding_g.ChamberSubcomplex ?Y \\<Longrightarrow>\n  ChamberComplexMorphism ?Y X id\n\ngoal (1 subgoal):\n 1. ChamberComplexMorphism (f \\<turnstile> X) X id", "by fast"], ["proof (state)\nthis:\n  ChamberComplexMorphism (f \\<turnstile> X) X id\n\ngoal (6 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. SimplicialComplex.maxsimp (f \\<turnstile> X) ?C\n 4. fixespointwise (\\<s> \\<circ> \\<s>) ?C\n 5. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (?C # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (?C # Cs))\n 6. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (?C # Cs) \\<Longrightarrow>\n       pgallery (id \\<Turnstile> (?C # Cs))", "show \"SimplicialComplex.maxsimp (f\\<turnstile>X) C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp (f \\<turnstile> X) C0", "using chambers(1,4) chamberD_simplex[OF chamber_D0]\n          chamber_in_subcomplex[OF folding_f.chambersubcomplex_image, of C0]"], ["proof (prove)\nusing this:\n  folding_g.chamber C0\n  f ` D0 = C0\n  D0 \\<in> X\n  \\<lbrakk>C0 \\<in> f \\<turnstile> X; folding_g.chamber C0\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp (f \\<turnstile> X) C0\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp (f \\<turnstile> X) C0", "by    auto"], ["proof (state)\nthis:\n  SimplicialComplex.maxsimp (f \\<turnstile> X) C0\n\ngoal (5 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. fixespointwise (\\<s> \\<circ> \\<s>) C0\n 4. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))\n 5. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery (id \\<Turnstile> (C0 # Cs))", "show \"fixespointwise (\\<s>\\<circ>\\<s>) C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise (\\<s> \\<circ> \\<s>) C0", "proof (rule fixespointwiseI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 \\<Longrightarrow> (\\<s> \\<circ> \\<s>) a = id a", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 \\<Longrightarrow> (\\<s> \\<circ> \\<s>) a = id a", "assume v: \"v\\<in>C0\""], ["proof (state)\nthis:\n  v \\<in> C0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 \\<Longrightarrow> (\\<s> \\<circ> \\<s>) a = id a", "with chambers(4)"], ["proof (chain)\npicking this:\n  f ` D0 = C0\n  v \\<in> C0", "have \"v\\<in>f`(\\<Union>X)\""], ["proof (prove)\nusing this:\n  f ` D0 = C0\n  v \\<in> C0\n\ngoal (1 subgoal):\n 1. v \\<in> f ` \\<Union> X", "using chamber_D0 chamberD_simplex"], ["proof (prove)\nusing this:\n  f ` D0 = C0\n  v \\<in> C0\n  folding_g.chamber D0\n  folding_g.chamber ?x \\<Longrightarrow> ?x \\<in> X\n\ngoal (1 subgoal):\n 1. v \\<in> f ` \\<Union> X", "by fast"], ["proof (state)\nthis:\n  v \\<in> f ` \\<Union> X\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 \\<Longrightarrow> (\\<s> \\<circ> \\<s>) a = id a", "hence 1: \"\\<s> v = g v\""], ["proof (prove)\nusing this:\n  v \\<in> f ` \\<Union> X\n\ngoal (1 subgoal):\n 1. \\<s> v = g v", "using induced_automorphism_def"], ["proof (prove)\nusing this:\n  v \\<in> f ` \\<Union> X\n  \\<s> ?v \\<equiv>\n  if ?v \\<in> f ` \\<Union> X then g ?v else restrict1 f (g ` \\<Union> X) ?v\n\ngoal (1 subgoal):\n 1. \\<s> v = g v", "by simp"], ["proof (state)\nthis:\n  \\<s> v = g v\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 \\<Longrightarrow> (\\<s> \\<circ> \\<s>) a = id a", "show \"(\\<s>\\<circ>\\<s>) v = id v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<s> \\<circ> \\<s>) v = id v", "proof (cases \"v\\<in>D0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> D0 \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 2. v \\<notin> D0 \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "case True"], ["proof (state)\nthis:\n  v \\<in> D0\n\ngoal (2 subgoals):\n 1. v \\<in> D0 \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 2. v \\<notin> D0 \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "with v"], ["proof (chain)\npicking this:\n  v \\<in> C0\n  v \\<in> D0", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> C0\n  v \\<in> D0\n\ngoal (1 subgoal):\n 1. (\\<s> \\<circ> \\<s>) v = id v", "using 1 g_trivial_D0"], ["proof (prove)\nusing this:\n  v \\<in> C0\n  v \\<in> D0\n  \\<s> v = g v\n  ?v \\<in> D0 \\<Longrightarrow> g ?v = ?v\n\ngoal (1 subgoal):\n 1. (\\<s> \\<circ> \\<s>) v = id v", "by simp"], ["proof (state)\nthis:\n  (\\<s> \\<circ> \\<s>) v = id v\n\ngoal (1 subgoal):\n 1. v \\<notin> D0 \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> D0 \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "case False"], ["proof (state)\nthis:\n  v \\<notin> D0\n\ngoal (1 subgoal):\n 1. v \\<notin> D0 \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "from v chambers(1,4)"], ["proof (chain)\npicking this:\n  v \\<in> C0\n  folding_g.chamber C0\n  f ` D0 = C0", "have \"\\<s> (g v) = f (g v)\""], ["proof (prove)\nusing this:\n  v \\<in> C0\n  folding_g.chamber C0\n  f ` D0 = C0\n\ngoal (1 subgoal):\n 1. \\<s> (g v) = f (g v)", "using chamberD_simplex induced_automorphism_fg_symmetric\n              OpposedThinChamberComplexFoldings.induced_automorphism_def[\n                OF fg_symmetric, of \"g v\"\n              ]"], ["proof (prove)\nusing this:\n  v \\<in> C0\n  folding_g.chamber C0\n  f ` D0 = C0\n  folding_g.chamber ?x \\<Longrightarrow> ?x \\<in> X\n  \\<s> = OpposedThinChamberComplexFoldings.induced_automorphism X g f\n  OpposedThinChamberComplexFoldings.induced_automorphism X g f\n   (g v) \\<equiv>\n  if g v \\<in> g ` \\<Union> X then f (g v)\n  else restrict1 g (f ` \\<Union> X) (g v)\n\ngoal (1 subgoal):\n 1. \\<s> (g v) = f (g v)", "by    force"], ["proof (state)\nthis:\n  \\<s> (g v) = f (g v)\n\ngoal (1 subgoal):\n 1. v \\<notin> D0 \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "with v False chambers(4)"], ["proof (chain)\npicking this:\n  v \\<in> C0\n  v \\<notin> D0\n  f ` D0 = C0\n  \\<s> (g v) = f (g v)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> C0\n  v \\<notin> D0\n  f ` D0 = C0\n  \\<s> (g v) = f (g v)\n\ngoal (1 subgoal):\n 1. (\\<s> \\<circ> \\<s>) v = id v", "using double_fold_C0 1"], ["proof (prove)\nusing this:\n  v \\<in> C0\n  v \\<notin> D0\n  f ` D0 = C0\n  \\<s> (g v) = f (g v)\n  ?v \\<in> f ` D0 - D0 \\<Longrightarrow> f (g ?v) = ?v\n  \\<s> v = g v\n\ngoal (1 subgoal):\n 1. (\\<s> \\<circ> \\<s>) v = id v", "by simp"], ["proof (state)\nthis:\n  (\\<s> \\<circ> \\<s>) v = id v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<s> \\<circ> \\<s>) v = id v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fixespointwise (\\<s> \\<circ> \\<s>) C0\n\ngoal (4 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))\n 4. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery (id \\<Turnstile> (C0 # Cs))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))\n 4. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery (id \\<Turnstile> (C0 # Cs))", "fix Cs"], ["proof (state)\ngoal (4 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))\n 4. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery (id \\<Turnstile> (C0 # Cs))", "assume \"ChamberComplex.min_gallery (f\\<turnstile>X) (C0#Cs)\""], ["proof (state)\nthis:\n  SimplicialComplex.min_maxsimpchain (f \\<turnstile> X) (C0 # Cs)\n\ngoal (4 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))\n 4. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery (id \\<Turnstile> (C0 # Cs))", "hence Cs: \"ChamberComplex.pgallery (f\\<turnstile>X) (C0#Cs)\""], ["proof (prove)\nusing this:\n  SimplicialComplex.min_maxsimpchain (f \\<turnstile> X) (C0 # Cs)\n\ngoal (1 subgoal):\n 1. SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (C0 # Cs)", "using ChamberComplex.min_gallery_pgallery folding_f.chambercomplex_image"], ["proof (prove)\nusing this:\n  SimplicialComplex.min_maxsimpchain (f \\<turnstile> X) (C0 # Cs)\n  \\<lbrakk>ChamberComplex ?X;\n   SimplicialComplex.min_maxsimpchain ?X ?xs\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.pmaxsimpchain ?X ?xs\n  ChamberComplex (f \\<turnstile> X)\n\ngoal (1 subgoal):\n 1. SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (C0 # Cs)", "by    fast"], ["proof (state)\nthis:\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (C0 # Cs)\n\ngoal (4 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))\n 4. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery (id \\<Turnstile> (C0 # Cs))", "hence pCs: \"pgallery (C0#Cs)\""], ["proof (prove)\nusing this:\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (C0 # Cs)\n\ngoal (1 subgoal):\n 1. pgallery (C0 # Cs)", "using folding_f.chambersubcomplex_image subcomplex_pgallery"], ["proof (prove)\nusing this:\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (C0 # Cs)\n  folding_g.ChamberSubcomplex (f \\<turnstile> X)\n  \\<lbrakk>folding_g.ChamberSubcomplex ?Y;\n   SimplicialComplex.pmaxsimpchain ?Y ?Cs\\<rbrakk>\n  \\<Longrightarrow> pgallery ?Cs\n\ngoal (1 subgoal):\n 1. pgallery (C0 # Cs)", "by auto"], ["proof (state)\nthis:\n  pgallery (C0 # Cs)\n\ngoal (4 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))\n 4. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery (id \\<Turnstile> (C0 # Cs))", "thus \"pgallery (id\\<Turnstile>(C0#Cs))\""], ["proof (prove)\nusing this:\n  pgallery (C0 # Cs)\n\ngoal (1 subgoal):\n 1. pgallery (id \\<Turnstile> (C0 # Cs))", "by simp"], ["proof (state)\nthis:\n  pgallery (id \\<Turnstile> (C0 # Cs))\n\ngoal (3 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))", "have set_Cs: \"set (C0#Cs) \\<subseteq> f\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set (C0 # Cs))", "using Cs pCs folding_f.chambersubcomplex_image\n          ChamberSubcomplexD_complex ChamberComplex.pgalleryD_chamber\n          ChamberComplex.chamberD_simplex pgallery_chamber_system\n          folding_f.chamber_system_image"], ["proof (prove)\nusing this:\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (C0 # Cs)\n  pgallery (C0 # Cs)\n  folding_g.ChamberSubcomplex (f \\<turnstile> X)\n  folding_g.ChamberSubcomplex ?Y \\<Longrightarrow> ChamberComplex ?Y\n  \\<lbrakk>ChamberComplex ?X; SimplicialComplex.pmaxsimpchain ?X ?xs;\n   ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp ?X ?x\n  \\<lbrakk>ChamberComplex ?X; SimplicialComplex.maxsimp ?X ?x\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ?X\n  pgallery ?Cs \\<Longrightarrow> order.greater_eq folding_g.\\<C> (set ?Cs)\n  f \\<turnstile> folding_g.\\<C> = folding_g.\\<C> \\<inter> (f \\<turnstile> X)\n\ngoal (1 subgoal):\n 1. order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set (C0 # Cs))", "by    fastforce"], ["proof (state)\nthis:\n  order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set (C0 # Cs))\n\ngoal (3 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))", "hence \"pgallery (\\<s>\\<Turnstile>(C0#Cs))\""], ["proof (prove)\nusing this:\n  order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set (C0 # Cs))\n\ngoal (1 subgoal):\n 1. pgallery (\\<s> \\<Turnstile> (C0 # Cs))", "using pCs induced_automorphism_half_chamber_system_pgallery_map_f[of \"C0#Cs\"]"], ["proof (prove)\nusing this:\n  order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set (C0 # Cs))\n  pgallery (C0 # Cs)\n  \\<lbrakk>order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set (C0 # Cs));\n   pgallery (C0 # Cs)\\<rbrakk>\n  \\<Longrightarrow> pgallery (\\<s> \\<Turnstile> (C0 # Cs))\n\ngoal (1 subgoal):\n 1. pgallery (\\<s> \\<Turnstile> (C0 # Cs))", "by    auto"], ["proof (state)\nthis:\n  pgallery (\\<s> \\<Turnstile> (C0 # Cs))\n\ngoal (3 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))", "moreover"], ["proof (state)\nthis:\n  pgallery (\\<s> \\<Turnstile> (C0 # Cs))\n\ngoal (3 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))", "have \"set (\\<s>\\<Turnstile>(C0#Cs)) \\<subseteq> g\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (g \\<turnstile> folding_g.\\<C>)\n     (set (\\<s> \\<Turnstile> (C0 # Cs)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. order.greater_eq (g \\<turnstile> folding_g.\\<C>)\n     (set (\\<s> \\<Turnstile> (C0 # Cs)))", "have \"set (\\<s>\\<Turnstile>(C0#Cs)) \\<subseteq> \\<s>\\<turnstile>(\\<C>-g\\<turnstile>\\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq\n     (\\<s> \\<turnstile> (folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>))\n     (set (\\<s> \\<Turnstile> (C0 # Cs)))", "using set_Cs flopped_half_chamber_systems_gf"], ["proof (prove)\nusing this:\n  order.greater_eq (f \\<turnstile> folding_g.\\<C>) (set (C0 # Cs))\n  folding_g.\\<C> - g \\<turnstile> folding_g.\\<C> =\n  f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. order.greater_eq\n     (\\<s> \\<turnstile> (folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>))\n     (set (\\<s> \\<Turnstile> (C0 # Cs)))", "by auto"], ["proof (state)\nthis:\n  order.greater_eq\n   (\\<s> \\<turnstile> (folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>))\n   (set (\\<s> \\<Turnstile> (C0 # Cs)))\n\ngoal (1 subgoal):\n 1. order.greater_eq (g \\<turnstile> folding_g.\\<C>)\n     (set (\\<s> \\<Turnstile> (C0 # Cs)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  order.greater_eq\n   (\\<s> \\<turnstile> (folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>))\n   (set (\\<s> \\<Turnstile> (C0 # Cs)))\n\ngoal (1 subgoal):\n 1. order.greater_eq (g \\<turnstile> folding_g.\\<C>)\n     (set (\\<s> \\<Turnstile> (C0 # Cs)))", "using bij_betw_imp_surj_on[\n              OF induced_automorphism_bij_between_half_chamber_systems_g\n            ]"], ["proof (prove)\nusing this:\n  order.greater_eq\n   (\\<s> \\<turnstile> (folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>))\n   (set (\\<s> \\<Turnstile> (C0 # Cs)))\n  \\<s> \\<turnstile> (folding_g.\\<C> - g \\<turnstile> folding_g.\\<C>) =\n  g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. order.greater_eq (g \\<turnstile> folding_g.\\<C>)\n     (set (\\<s> \\<Turnstile> (C0 # Cs)))", "by    simp"], ["proof (state)\nthis:\n  order.greater_eq (g \\<turnstile> folding_g.\\<C>)\n   (set (\\<s> \\<Turnstile> (C0 # Cs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq (g \\<turnstile> folding_g.\\<C>)\n   (set (\\<s> \\<Turnstile> (C0 # Cs)))\n\ngoal (3 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))", "ultimately"], ["proof (chain)\npicking this:\n  pgallery (\\<s> \\<Turnstile> (C0 # Cs))\n  order.greater_eq (g \\<turnstile> folding_g.\\<C>)\n   (set (\\<s> \\<Turnstile> (C0 # Cs)))", "have \"pgallery (\\<s>\\<Turnstile>(\\<s>\\<Turnstile>(C0#Cs)))\""], ["proof (prove)\nusing this:\n  pgallery (\\<s> \\<Turnstile> (C0 # Cs))\n  order.greater_eq (g \\<turnstile> folding_g.\\<C>)\n   (set (\\<s> \\<Turnstile> (C0 # Cs)))\n\ngoal (1 subgoal):\n 1. pgallery (\\<s> \\<Turnstile> (\\<s> \\<Turnstile> (C0 # Cs)))", "using induced_automorphism_half_chamber_system_pgallery_map_g[\n            of \"\\<s>\\<Turnstile>(C0#Cs)\"\n          ]"], ["proof (prove)\nusing this:\n  pgallery (\\<s> \\<Turnstile> (C0 # Cs))\n  order.greater_eq (g \\<turnstile> folding_g.\\<C>)\n   (set (\\<s> \\<Turnstile> (C0 # Cs)))\n  \\<lbrakk>order.greater_eq (g \\<turnstile> folding_g.\\<C>)\n            (set (\\<s> \\<Turnstile> (C0 # Cs)));\n   pgallery (\\<s> \\<Turnstile> (C0 # Cs))\\<rbrakk>\n  \\<Longrightarrow> pgallery\n                     (\\<s> \\<Turnstile> (\\<s> \\<Turnstile> (C0 # Cs)))\n\ngoal (1 subgoal):\n 1. pgallery (\\<s> \\<Turnstile> (\\<s> \\<Turnstile> (C0 # Cs)))", "by    auto"], ["proof (state)\nthis:\n  pgallery (\\<s> \\<Turnstile> (\\<s> \\<Turnstile> (C0 # Cs)))\n\ngoal (3 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)\n 3. \\<And>Cs.\n       SimplicialComplex.min_maxsimpchain (f \\<turnstile> X)\n        (C0 # Cs) \\<Longrightarrow>\n       pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))", "thus \"pgallery ((\\<s>\\<circ>\\<s>)\\<Turnstile>(C0#Cs))\""], ["proof (prove)\nusing this:\n  pgallery (\\<s> \\<Turnstile> (\\<s> \\<Turnstile> (C0 # Cs)))\n\ngoal (1 subgoal):\n 1. pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))", "using ssubst[OF setlistmapim_comp, of pgallery, of \\<s> \\<s> \"C0#Cs\"]"], ["proof (prove)\nusing this:\n  pgallery (\\<s> \\<Turnstile> (\\<s> \\<Turnstile> (C0 # Cs)))\n  pgallery\n   (\\<s> \\<Turnstile> (\\<s> \\<Turnstile> (C0 # Cs))) \\<Longrightarrow>\n  pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))\n\ngoal (1 subgoal):\n 1. pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))", "by fast"], ["proof (state)\nthis:\n  pgallery ((\\<s> \\<circ> \\<s>) \\<Turnstile> (C0 # Cs))\n\ngoal (2 subgoals):\n 1. ChamberComplex X\n 2. folding_g.ChamberSubcomplex (f \\<turnstile> X)", "qed (unfold_locales, rule folding_f.chambersubcomplex_image)"], ["", "lemmas indaut_selfcomp_halftriv_f =\n  induced_automorphism_selfcomp_halftrivial_f"], ["", "lemma induced_automorphism_selfcomp_halftrivial_g: \"fixespointwise (\\<s>\\<circ>\\<s>) (\\<Union>(g\\<turnstile>X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise (\\<s> \\<circ> \\<s>) (\\<Union> (g \\<turnstile> X))", "using induced_automorphism_fg_symmetric\n        OpposedThinChamberComplexFoldings.indaut_selfcomp_halftriv_f[\n          OF fg_symmetric\n        ]"], ["proof (prove)\nusing this:\n  \\<s> = OpposedThinChamberComplexFoldings.induced_automorphism X g f\n  fixespointwise\n   (OpposedThinChamberComplexFoldings.induced_automorphism X g f \\<circ>\n    OpposedThinChamberComplexFoldings.induced_automorphism X g f)\n   (\\<Union> (g \\<turnstile> X))\n\ngoal (1 subgoal):\n 1. fixespointwise (\\<s> \\<circ> \\<s>) (\\<Union> (g \\<turnstile> X))", "by    simp"], ["", "lemma induced_automorphism_trivial_outside:\n  assumes \"v\\<notin>\\<Union>X\"\n  shows   \"\\<s> v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<s> v = v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<s> v = v", "from assms"], ["proof (chain)\npicking this:\n  v \\<notin> \\<Union> X", "have \"v \\<notin> f`(\\<Union>X) \\<and> v \\<notin> g`(\\<Union>X)\""], ["proof (prove)\nusing this:\n  v \\<notin> \\<Union> X\n\ngoal (1 subgoal):\n 1. v \\<notin> f ` \\<Union> X \\<and> v \\<notin> g ` \\<Union> X", "using vertex_set_split"], ["proof (prove)\nusing this:\n  v \\<notin> \\<Union> X\n  \\<Union> X = f ` \\<Union> X \\<union> g ` \\<Union> X\n\ngoal (1 subgoal):\n 1. v \\<notin> f ` \\<Union> X \\<and> v \\<notin> g ` \\<Union> X", "by fast"], ["proof (state)\nthis:\n  v \\<notin> f ` \\<Union> X \\<and> v \\<notin> g ` \\<Union> X\n\ngoal (1 subgoal):\n 1. \\<s> v = v", "thus \"\\<s> v = v\""], ["proof (prove)\nusing this:\n  v \\<notin> f ` \\<Union> X \\<and> v \\<notin> g ` \\<Union> X\n\ngoal (1 subgoal):\n 1. \\<s> v = v", "using induced_automorphism_def"], ["proof (prove)\nusing this:\n  v \\<notin> f ` \\<Union> X \\<and> v \\<notin> g ` \\<Union> X\n  \\<s> ?v \\<equiv>\n  if ?v \\<in> f ` \\<Union> X then g ?v else restrict1 f (g ` \\<Union> X) ?v\n\ngoal (1 subgoal):\n 1. \\<s> v = v", "by simp"], ["proof (state)\nthis:\n  \\<s> v = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma induced_automorphism_morphism: \"ChamberComplexEndomorphism X \\<s>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X \\<s>", "proof (unfold_locales, rule induced_automorphism_chamber_map, simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C. folding_g.chamber C \\<Longrightarrow> card (\\<s> ` C) = card C\n 2. \\<And>v. v \\<notin> \\<Union> X \\<Longrightarrow> \\<s> v = v", "fix C"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C. folding_g.chamber C \\<Longrightarrow> card (\\<s> ` C) = card C\n 2. \\<And>v. v \\<notin> \\<Union> X \\<Longrightarrow> \\<s> v = v", "assume \"chamber C\""], ["proof (state)\nthis:\n  folding_g.chamber C\n\ngoal (2 subgoals):\n 1. \\<And>C. folding_g.chamber C \\<Longrightarrow> card (\\<s> ` C) = card C\n 2. \\<And>v. v \\<notin> \\<Union> X \\<Longrightarrow> \\<s> v = v", "thus \"card (\\<s>`C) = card C\""], ["proof (prove)\nusing this:\n  folding_g.chamber C\n\ngoal (1 subgoal):\n 1. card (\\<s> ` C) = card C", "using induced_automorphism_chamber_image_fg folding_f.dim_map\n          folding_g.dim_map\n          flopped_half_chamber_systems_fg[THEN sym]"], ["proof (prove)\nusing this:\n  folding_g.chamber C\n  folding_g.chamber ?C \\<Longrightarrow>\n  \\<s> ` ?C =\n  (if ?C \\<in> f \\<turnstile> folding_g.\\<C> then g ` ?C else f ` ?C)\n  folding_g.chamber ?C \\<Longrightarrow> card (f ` ?C) = card ?C\n  folding_g.chamber ?C \\<Longrightarrow> card (g ` ?C) = card ?C\n  g \\<turnstile> folding_g.\\<C> =\n  folding_g.\\<C> - f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. card (\\<s> ` C) = card C", "by    (cases \"C\\<in>f\\<turnstile>\\<C>\") auto"], ["proof (state)\nthis:\n  card (\\<s> ` C) = card C\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<notin> \\<Union> X \\<Longrightarrow> \\<s> v = v", "qed (rule induced_automorphism_trivial_outside)"], ["", "lemmas indaut_morph = induced_automorphism_morphism"], ["", "lemma induced_automorphism_morphism_order2: \"\\<s>\\<circ>\\<s> = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<s> \\<circ> \\<s> = id", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<s> \\<circ> \\<s>) x = id x", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<s> \\<circ> \\<s>) x = id x", "show \"(\\<s>\\<circ>\\<s>) v = id v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<s> \\<circ> \\<s>) v = id v", "proof (cases \"v\\<in>f`(\\<Union>X)\" \"v\\<in>g`(\\<Union>X)\" rule: two_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>v \\<in> f ` \\<Union> X; v \\<in> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 2. \\<lbrakk>v \\<in> f ` \\<Union> X; v \\<notin> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 3. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<in> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 4. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<notin> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "case both"], ["proof (state)\nthis:\n  v \\<in> f ` \\<Union> X\n  v \\<in> g ` \\<Union> X\n\ngoal (4 subgoals):\n 1. \\<lbrakk>v \\<in> f ` \\<Union> X; v \\<in> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 2. \\<lbrakk>v \\<in> f ` \\<Union> X; v \\<notin> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 3. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<in> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 4. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<notin> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "from both(1)"], ["proof (chain)\npicking this:\n  v \\<in> f ` \\<Union> X", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> f ` \\<Union> X\n\ngoal (1 subgoal):\n 1. (\\<s> \\<circ> \\<s>) v = id v", "using induced_automorphism_selfcomp_halftrivial_f fixespointwiseD[of \"\\<s>\\<circ>\\<s>\"]"], ["proof (prove)\nusing this:\n  v \\<in> f ` \\<Union> X\n  fixespointwise (\\<s> \\<circ> \\<s>) (\\<Union> (f \\<turnstile> X))\n  \\<lbrakk>fixespointwise (\\<s> \\<circ> \\<s>) ?A; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> (\\<s> \\<circ> \\<s>) ?a = id ?a\n\ngoal (1 subgoal):\n 1. (\\<s> \\<circ> \\<s>) v = id v", "by    auto"], ["proof (state)\nthis:\n  (\\<s> \\<circ> \\<s>) v = id v\n\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<in> f ` \\<Union> X; v \\<notin> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 2. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<in> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 3. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<notin> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<in> f ` \\<Union> X; v \\<notin> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 2. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<in> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 3. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<notin> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "case one"], ["proof (state)\nthis:\n  v \\<in> f ` \\<Union> X\n  v \\<notin> g ` \\<Union> X\n\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<in> f ` \\<Union> X; v \\<notin> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 2. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<in> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 3. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<notin> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> f ` \\<Union> X\n  v \\<notin> g ` \\<Union> X\n\ngoal (1 subgoal):\n 1. (\\<s> \\<circ> \\<s>) v = id v", "using induced_automorphism_selfcomp_halftrivial_f fixespointwiseD[of \"\\<s>\\<circ>\\<s>\"]"], ["proof (prove)\nusing this:\n  v \\<in> f ` \\<Union> X\n  v \\<notin> g ` \\<Union> X\n  fixespointwise (\\<s> \\<circ> \\<s>) (\\<Union> (f \\<turnstile> X))\n  \\<lbrakk>fixespointwise (\\<s> \\<circ> \\<s>) ?A; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> (\\<s> \\<circ> \\<s>) ?a = id ?a\n\ngoal (1 subgoal):\n 1. (\\<s> \\<circ> \\<s>) v = id v", "by    fastforce"], ["proof (state)\nthis:\n  (\\<s> \\<circ> \\<s>) v = id v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<in> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 2. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<notin> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<in> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 2. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<notin> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "case other"], ["proof (state)\nthis:\n  v \\<notin> f ` \\<Union> X\n  v \\<in> g ` \\<Union> X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<in> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v\n 2. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<notin> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> f ` \\<Union> X\n  v \\<in> g ` \\<Union> X\n\ngoal (1 subgoal):\n 1. (\\<s> \\<circ> \\<s>) v = id v", "using induced_automorphism_selfcomp_halftrivial_g fixespointwiseD[of \"\\<s>\\<circ>\\<s>\"]"], ["proof (prove)\nusing this:\n  v \\<notin> f ` \\<Union> X\n  v \\<in> g ` \\<Union> X\n  fixespointwise (\\<s> \\<circ> \\<s>) (\\<Union> (g \\<turnstile> X))\n  \\<lbrakk>fixespointwise (\\<s> \\<circ> \\<s>) ?A; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> (\\<s> \\<circ> \\<s>) ?a = id ?a\n\ngoal (1 subgoal):\n 1. (\\<s> \\<circ> \\<s>) v = id v", "by    fastforce"], ["proof (state)\nthis:\n  (\\<s> \\<circ> \\<s>) v = id v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> f ` \\<Union> X; v \\<notin> g ` \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> (\\<s> \\<circ> \\<s>) v = id v", "qed (simp add: induced_automorphism_def)"], ["proof (state)\nthis:\n  (\\<s> \\<circ> \\<s>) v = id v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas indaut_order2 = induced_automorphism_morphism_order2"], ["", "lemmas induced_automorphism_bij =\n  o_bij[OF\n    induced_automorphism_morphism_order2\n    induced_automorphism_morphism_order2\n  ]"], ["", "lemma induced_automorphism_surj_on_vertexset: \"\\<s>`(\\<Union>X) = \\<Union>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<s> ` \\<Union> X = \\<Union> X", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq (\\<Union> X) (\\<s> ` \\<Union> X)\n 2. order.greater_eq (\\<s> ` \\<Union> X) (\\<Union> X)", "show \"\\<s>`(\\<Union>X) \\<subseteq> \\<Union>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (\\<Union> X) (\\<s> ` \\<Union> X)", "using induced_automorphism_morphism\n          ChamberComplexEndomorphism.vertex_map"], ["proof (prove)\nusing this:\n  ChamberComplexEndomorphism X \\<s>\n  \\<lbrakk>ChamberComplexEndomorphism ?X ?f; ?x \\<in> \\<Union> ?X\\<rbrakk>\n  \\<Longrightarrow> ?f ?x \\<in> \\<Union> ?X\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<Union> X) (\\<s> ` \\<Union> X)", "by    fast"], ["proof (state)\nthis:\n  order.greater_eq (\\<Union> X) (\\<s> ` \\<Union> X)\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<s> ` \\<Union> X) (\\<Union> X)", "hence \"(\\<s>\\<circ>\\<s>)`(\\<Union>X) \\<subseteq> \\<s>`(\\<Union>X)\""], ["proof (prove)\nusing this:\n  order.greater_eq (\\<Union> X) (\\<s> ` \\<Union> X)\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<s> ` \\<Union> X) ((\\<s> \\<circ> \\<s>) ` \\<Union> X)", "by fastforce"], ["proof (state)\nthis:\n  order.greater_eq (\\<s> ` \\<Union> X) ((\\<s> \\<circ> \\<s>) ` \\<Union> X)\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<s> ` \\<Union> X) (\\<Union> X)", "thus \"\\<Union>X \\<subseteq> \\<s>`(\\<Union>X)\""], ["proof (prove)\nusing this:\n  order.greater_eq (\\<s> ` \\<Union> X) ((\\<s> \\<circ> \\<s>) ` \\<Union> X)\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<s> ` \\<Union> X) (\\<Union> X)", "using induced_automorphism_morphism_order2"], ["proof (prove)\nusing this:\n  order.greater_eq (\\<s> ` \\<Union> X) ((\\<s> \\<circ> \\<s>) ` \\<Union> X)\n  \\<s> \\<circ> \\<s> = id\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<s> ` \\<Union> X) (\\<Union> X)", "by simp"], ["proof (state)\nthis:\n  order.greater_eq (\\<s> ` \\<Union> X) (\\<Union> X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma induced_automorphism_bij_betw_vertexset: \"bij_betw \\<s> (\\<Union>X) (\\<Union>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw \\<s> (\\<Union> X) (\\<Union> X)", "using induced_automorphism_bij induced_automorphism_surj_on_vertexset"], ["proof (prove)\nusing this:\n  bij \\<s>\n  \\<s> ` \\<Union> X = \\<Union> X\n\ngoal (1 subgoal):\n 1. bij_betw \\<s> (\\<Union> X) (\\<Union> X)", "by    (auto intro: bij_betw_subset)"], ["", "lemma induced_automorphism_surj_on_simplices: \"\\<s>\\<turnstile>X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<s> \\<turnstile> X = X", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq X (\\<s> \\<turnstile> X)\n 2. order.greater_eq (\\<s> \\<turnstile> X) X", "show \"\\<s>\\<turnstile>X \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq X (\\<s> \\<turnstile> X)", "using induced_automorphism_morphism\n          ChamberComplexEndomorphism.simplex_map"], ["proof (prove)\nusing this:\n  ChamberComplexEndomorphism X \\<s>\n  \\<lbrakk>ChamberComplexEndomorphism ?X ?f; ?x \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> ?f ` ?x \\<in> ?X\n\ngoal (1 subgoal):\n 1. order.greater_eq X (\\<s> \\<turnstile> X)", "by    fast"], ["proof (state)\nthis:\n  order.greater_eq X (\\<s> \\<turnstile> X)\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<s> \\<turnstile> X) X", "hence \"\\<s>\\<turnstile>(\\<s>\\<turnstile>X) \\<subseteq> \\<s>\\<turnstile>X\""], ["proof (prove)\nusing this:\n  order.greater_eq X (\\<s> \\<turnstile> X)\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<s> \\<turnstile> X)\n     (\\<s> \\<turnstile> (\\<s> \\<turnstile> X))", "by auto"], ["proof (state)\nthis:\n  order.greater_eq (\\<s> \\<turnstile> X)\n   (\\<s> \\<turnstile> (\\<s> \\<turnstile> X))\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<s> \\<turnstile> X) X", "thus \"X \\<subseteq> \\<s>\\<turnstile>X\""], ["proof (prove)\nusing this:\n  order.greater_eq (\\<s> \\<turnstile> X)\n   (\\<s> \\<turnstile> (\\<s> \\<turnstile> X))\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<s> \\<turnstile> X) X", "by  (simp add:\n          setsetmapim_comp[THEN sym] induced_automorphism_morphism_order2\n        )"], ["proof (state)\nthis:\n  order.greater_eq (\\<s> \\<turnstile> X) X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma induced_automorphism_automorphism:\n  \"ChamberComplexAutomorphism X \\<s>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexAutomorphism X \\<s>", "using induced_automorphism_chamber_map\n        ChamberComplexEndomorphism.dim_map\n        induced_automorphism_morphism\n        induced_automorphism_bij_betw_vertexset\n        induced_automorphism_surj_on_simplices\n        induced_automorphism_trivial_outside"], ["proof (prove)\nusing this:\n  folding_g.chamber ?C \\<Longrightarrow> folding_g.chamber (\\<s> ` ?C)\n  \\<lbrakk>ChamberComplexEndomorphism ?X ?f;\n   SimplicialComplex.maxsimp ?X ?C\\<rbrakk>\n  \\<Longrightarrow> card (?f ` ?C) = card ?C\n  ChamberComplexEndomorphism X \\<s>\n  bij_betw \\<s> (\\<Union> X) (\\<Union> X)\n  \\<s> \\<turnstile> X = X\n  ?v \\<notin> \\<Union> X \\<Longrightarrow> \\<s> ?v = ?v\n\ngoal (1 subgoal):\n 1. ChamberComplexAutomorphism X \\<s>", "by    (intro_locales, unfold_locales, fast)"], ["", "lemmas indaut_aut = induced_automorphism_automorphism"], ["", "lemma induced_automorphism_unique_automorphism':\n  assumes \"ChamberComplexAutomorphism X s\" \"s\\<noteq>id\" \"fixespointwise s (C0\\<inter>D0)\"\n  shows   \"fun_eq_on s \\<s> C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_eq_on s \\<s> C0", "proof (rule fun_eq_on_subset_and_diff_imp_eq_on)"], ["proof (state)\ngoal (3 subgoals):\n 1. order.greater_eq C0 ?A\n 2. fun_eq_on s \\<s> ?A\n 3. fun_eq_on s \\<s> (C0 - ?A)", "from assms(3)"], ["proof (chain)\npicking this:\n  fixespointwise s (C0 \\<inter> D0)", "show \"fun_eq_on s \\<s> (C0\\<inter>D0)\""], ["proof (prove)\nusing this:\n  fixespointwise s (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. fun_eq_on s \\<s> (C0 \\<inter> D0)", "using induced_automorphism_fixespointwise_C0_int_D0\n          fixespointwise2_imp_eq_on"], ["proof (prove)\nusing this:\n  fixespointwise s (C0 \\<inter> D0)\n  fixespointwise \\<s> (C0 \\<inter> D0)\n  \\<lbrakk>fixespointwise ?f ?A; fixespointwise ?g ?A\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on ?f ?g ?A\n\ngoal (1 subgoal):\n 1. fun_eq_on s \\<s> (C0 \\<inter> D0)", "by    fast"], ["proof (state)\nthis:\n  fun_eq_on s \\<s> (C0 \\<inter> D0)\n\ngoal (2 subgoals):\n 1. order.greater_eq C0 (C0 \\<inter> D0)\n 2. fun_eq_on s \\<s> (C0 - C0 \\<inter> D0)", "show \"fun_eq_on s \\<s> (C0 - (C0\\<inter>D0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_eq_on s \\<s> (C0 - C0 \\<inter> D0)", "proof (rule fun_eq_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "assume v: \"v \\<in> C0 - C0\\<inter>D0\""], ["proof (state)\nthis:\n  v \\<in> C0 - C0 \\<inter> D0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "with chambers(2)"], ["proof (chain)\npicking this:\n  C0 \\<sim> D0\n  v \\<in> C0 - C0 \\<inter> D0", "have C0_insert: \"C0 = insert v (C0\\<inter>D0)\""], ["proof (prove)\nusing this:\n  C0 \\<sim> D0\n  v \\<in> C0 - C0 \\<inter> D0\n\ngoal (1 subgoal):\n 1. C0 = insert v (C0 \\<inter> D0)", "using adjacent_conv_insert"], ["proof (prove)\nusing this:\n  C0 \\<sim> D0\n  v \\<in> C0 - C0 \\<inter> D0\n  \\<lbrakk>?x \\<sim> ?y; ?v \\<in> ?x - ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = insert ?v (?x \\<inter> ?y)\n\ngoal (1 subgoal):\n 1. C0 = insert v (C0 \\<inter> D0)", "by fast"], ["proof (state)\nthis:\n  C0 = insert v (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "hence \"s`C0 = insert (s v) (s`(C0\\<inter>D0))\" \"\\<s>`C0 = insert (\\<s> v) (\\<s>`(C0\\<inter>D0))\""], ["proof (prove)\nusing this:\n  C0 = insert v (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. s ` C0 = insert (s v) (s ` (C0 \\<inter> D0)) &&&\n    \\<s> ` C0 = insert (\\<s> v) (\\<s> ` (C0 \\<inter> D0))", "by auto"], ["proof (state)\nthis:\n  s ` C0 = insert (s v) (s ` (C0 \\<inter> D0))\n  \\<s> ` C0 = insert (\\<s> v) (\\<s> ` (C0 \\<inter> D0))\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "with assms(3)"], ["proof (chain)\npicking this:\n  fixespointwise s (C0 \\<inter> D0)\n  s ` C0 = insert (s v) (s ` (C0 \\<inter> D0))\n  \\<s> ` C0 = insert (\\<s> v) (\\<s> ` (C0 \\<inter> D0))", "have  insert: \"s`C0 = insert (s v) (C0\\<inter>D0)\" \"D0 = insert (\\<s> v) (C0\\<inter>D0)\""], ["proof (prove)\nusing this:\n  fixespointwise s (C0 \\<inter> D0)\n  s ` C0 = insert (s v) (s ` (C0 \\<inter> D0))\n  \\<s> ` C0 = insert (\\<s> v) (\\<s> ` (C0 \\<inter> D0))\n\ngoal (1 subgoal):\n 1. s ` C0 = insert (s v) (C0 \\<inter> D0) &&&\n    D0 = insert (\\<s> v) (C0 \\<inter> D0)", "using basechambers_half_chamber_systems\n            induced_automorphism_fixespointwise_C0_int_D0\n            induced_automorphism_simplex_image(1)"], ["proof (prove)\nusing this:\n  fixespointwise s (C0 \\<inter> D0)\n  s ` C0 = insert (s v) (s ` (C0 \\<inter> D0))\n  \\<s> ` C0 = insert (\\<s> v) (\\<s> ` (C0 \\<inter> D0))\n  C0 \\<in> f \\<turnstile> folding_g.\\<C>\n  D0 \\<in> g \\<turnstile> folding_g.\\<C>\n  fixespointwise \\<s> (C0 \\<inter> D0)\n  \\<lbrakk>?C \\<in> f \\<turnstile> folding_g.\\<C>;\n   order.greater_eq ?C ?x\\<rbrakk>\n  \\<Longrightarrow> \\<s> ` ?x = g ` ?x\n\ngoal (1 subgoal):\n 1. s ` C0 = insert (s v) (C0 \\<inter> D0) &&&\n    D0 = insert (\\<s> v) (C0 \\<inter> D0)", "by    (auto simp add: fixespointwise_im)"], ["proof (state)\nthis:\n  s ` C0 = insert (s v) (C0 \\<inter> D0)\n  D0 = insert (\\<s> v) (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "from chambers(2,3)"], ["proof (chain)\npicking this:\n  C0 \\<sim> D0\n  C0 \\<noteq> D0", "have C0D0_C0: \"(C0\\<inter>D0) \\<lhd> C0\""], ["proof (prove)\nusing this:\n  C0 \\<sim> D0\n  C0 \\<noteq> D0\n\ngoal (1 subgoal):\n 1. C0 \\<inter> D0 \\<lhd> C0", "using adjacent_int_facet1"], ["proof (prove)\nusing this:\n  C0 \\<sim> D0\n  C0 \\<noteq> D0\n  \\<lbrakk>?x \\<sim> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<inter> ?y \\<lhd> ?x\n\ngoal (1 subgoal):\n 1. C0 \\<inter> D0 \\<lhd> C0", "by fast"], ["proof (state)\nthis:\n  C0 \\<inter> D0 \\<lhd> C0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "with assms(1) chambers(1)"], ["proof (chain)\npicking this:\n  ChamberComplexAutomorphism X s\n  folding_g.chamber C0\n  C0 \\<inter> D0 \\<lhd> C0", "have \"s`(C0\\<inter>D0) \\<lhd> s`C0\""], ["proof (prove)\nusing this:\n  ChamberComplexAutomorphism X s\n  folding_g.chamber C0\n  C0 \\<inter> D0 \\<lhd> C0\n\ngoal (1 subgoal):\n 1. s ` (C0 \\<inter> D0) \\<lhd> s ` C0", "using ChamberComplexAutomorphism.facet_map"], ["proof (prove)\nusing this:\n  ChamberComplexAutomorphism X s\n  folding_g.chamber C0\n  C0 \\<inter> D0 \\<lhd> C0\n  \\<lbrakk>ChamberComplexAutomorphism ?X ?f;\n   SimplicialComplex.maxsimp ?X ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> ?f ` ?z \\<lhd> ?f ` ?C\n\ngoal (1 subgoal):\n 1. s ` (C0 \\<inter> D0) \\<lhd> s ` C0", "by fast"], ["proof (state)\nthis:\n  s ` (C0 \\<inter> D0) \\<lhd> s ` C0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "with assms(3)"], ["proof (chain)\npicking this:\n  fixespointwise s (C0 \\<inter> D0)\n  s ` (C0 \\<inter> D0) \\<lhd> s ` C0", "have C0D0_sC0: \"(C0\\<inter>D0) \\<lhd> s`C0\""], ["proof (prove)\nusing this:\n  fixespointwise s (C0 \\<inter> D0)\n  s ` (C0 \\<inter> D0) \\<lhd> s ` C0\n\ngoal (1 subgoal):\n 1. C0 \\<inter> D0 \\<lhd> s ` C0", "by (simp add: fixespointwise_im)"], ["proof (state)\nthis:\n  C0 \\<inter> D0 \\<lhd> s ` C0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "hence sv_nin_C0D0: \"s v \\<notin> C0\\<inter>D0\""], ["proof (prove)\nusing this:\n  C0 \\<inter> D0 \\<lhd> s ` C0\n\ngoal (1 subgoal):\n 1. s v \\<notin> C0 \\<inter> D0", "using insert(1) facetrel_psubset"], ["proof (prove)\nusing this:\n  C0 \\<inter> D0 \\<lhd> s ` C0\n  s ` C0 = insert (s v) (C0 \\<inter> D0)\n  ?y \\<lhd> ?x \\<Longrightarrow> order.greater ?x ?y\n\ngoal (1 subgoal):\n 1. s v \\<notin> C0 \\<inter> D0", "by auto"], ["proof (state)\nthis:\n  s v \\<notin> C0 \\<inter> D0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "from assms(1) chambers(1)"], ["proof (chain)\npicking this:\n  ChamberComplexAutomorphism X s\n  folding_g.chamber C0", "have \"chamber (s`C0)\""], ["proof (prove)\nusing this:\n  ChamberComplexAutomorphism X s\n  folding_g.chamber C0\n\ngoal (1 subgoal):\n 1. folding_g.chamber (s ` C0)", "using ChamberComplexAutomorphism.chamber_map"], ["proof (prove)\nusing this:\n  ChamberComplexAutomorphism X s\n  folding_g.chamber C0\n  \\<lbrakk>ChamberComplexAutomorphism ?X ?f;\n   SimplicialComplex.maxsimp ?X ?C\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp ?X (?f ` ?C)\n\ngoal (1 subgoal):\n 1. folding_g.chamber (s ` C0)", "by fast"], ["proof (state)\nthis:\n  folding_g.chamber (s ` C0)\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "moreover"], ["proof (state)\nthis:\n  folding_g.chamber (s ` C0)\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "from chambers(2,3)"], ["proof (chain)\npicking this:\n  C0 \\<sim> D0\n  C0 \\<noteq> D0", "have C0D0_D0: \"(C0\\<inter>D0) \\<lhd> D0\""], ["proof (prove)\nusing this:\n  C0 \\<sim> D0\n  C0 \\<noteq> D0\n\ngoal (1 subgoal):\n 1. C0 \\<inter> D0 \\<lhd> D0", "using adjacent_sym adjacent_int_facet1"], ["proof (prove)\nusing this:\n  C0 \\<sim> D0\n  C0 \\<noteq> D0\n  ?x \\<sim> ?y \\<Longrightarrow> ?y \\<sim> ?x\n  \\<lbrakk>?x \\<sim> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<inter> ?y \\<lhd> ?x\n\ngoal (1 subgoal):\n 1. C0 \\<inter> D0 \\<lhd> D0", "by (fastforce simp add: Int_commute)"], ["proof (state)\nthis:\n  C0 \\<inter> D0 \\<lhd> D0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "ultimately"], ["proof (chain)\npicking this:\n  folding_g.chamber (s ` C0)\n  C0 \\<inter> D0 \\<lhd> D0", "have \"s`C0 = C0 \\<or> s`C0 = D0\""], ["proof (prove)\nusing this:\n  folding_g.chamber (s ` C0)\n  C0 \\<inter> D0 \\<lhd> D0\n\ngoal (1 subgoal):\n 1. s ` C0 = C0 \\<or> s ` C0 = D0", "using chambers(1,3) chamber_D0 C0D0_C0 C0D0_sC0\n            facet_unique_other_chamber[of \"s`C0\" \"C0\\<inter>D0\" C0 D0]"], ["proof (prove)\nusing this:\n  folding_g.chamber (s ` C0)\n  C0 \\<inter> D0 \\<lhd> D0\n  folding_g.chamber C0\n  C0 \\<noteq> D0\n  folding_g.chamber D0\n  C0 \\<inter> D0 \\<lhd> C0\n  C0 \\<inter> D0 \\<lhd> s ` C0\n  \\<lbrakk>folding_g.chamber (s ` C0); C0 \\<inter> D0 \\<lhd> s ` C0;\n   folding_g.chamber C0; C0 \\<inter> D0 \\<lhd> C0; folding_g.chamber D0;\n   C0 \\<inter> D0 \\<lhd> D0; C0 \\<noteq> s ` C0; D0 \\<noteq> s ` C0\\<rbrakk>\n  \\<Longrightarrow> C0 = D0\n\ngoal (1 subgoal):\n 1. s ` C0 = C0 \\<or> s ` C0 = D0", "by    auto"], ["proof (state)\nthis:\n  s ` C0 = C0 \\<or> s ` C0 = D0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "moreover"], ["proof (state)\nthis:\n  s ` C0 = C0 \\<or> s ` C0 = D0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "have \"\\<not> s`C0 = C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s ` C0 \\<noteq> C0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. s ` C0 = C0 \\<Longrightarrow> False", "assume sC0: \"s`C0 = C0\""], ["proof (state)\nthis:\n  s ` C0 = C0\n\ngoal (1 subgoal):\n 1. s ` C0 = C0 \\<Longrightarrow> False", "have \"s = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = id", "proof (\n        rule standard_uniqueness_automorphs, rule assms(1),\n        rule trivial_automorphism, rule chambers(1),\n        rule fixespointwise_subset_and_diff_imp_eq_on,\n        rule Int_lower1, rule assms(3), rule fixespointwiseI\n      )"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = id a", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = id a", "assume \"a \\<in> C0-(C0\\<inter>D0)\""], ["proof (state)\nthis:\n  a \\<in> C0 - C0 \\<inter> D0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = id a", "with v"], ["proof (chain)\npicking this:\n  v \\<in> C0 - C0 \\<inter> D0\n  a \\<in> C0 - C0 \\<inter> D0", "have \"a = v\""], ["proof (prove)\nusing this:\n  v \\<in> C0 - C0 \\<inter> D0\n  a \\<in> C0 - C0 \\<inter> D0\n\ngoal (1 subgoal):\n 1. a = v", "using C0_insert"], ["proof (prove)\nusing this:\n  v \\<in> C0 - C0 \\<inter> D0\n  a \\<in> C0 - C0 \\<inter> D0\n  C0 = insert v (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. a = v", "by fast"], ["proof (state)\nthis:\n  a = v\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = id a", "with sC0"], ["proof (chain)\npicking this:\n  s ` C0 = C0\n  a = v", "show \"s a = id a\""], ["proof (prove)\nusing this:\n  s ` C0 = C0\n  a = v\n\ngoal (1 subgoal):\n 1. s a = id a", "using C0_insert sv_nin_C0D0"], ["proof (prove)\nusing this:\n  s ` C0 = C0\n  a = v\n  C0 = insert v (C0 \\<inter> D0)\n  s v \\<notin> C0 \\<inter> D0\n\ngoal (1 subgoal):\n 1. s a = id a", "by auto"], ["proof (state)\nthis:\n  s a = id a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s = id\n\ngoal (1 subgoal):\n 1. s ` C0 = C0 \\<Longrightarrow> False", "with assms(1,2)"], ["proof (chain)\npicking this:\n  ChamberComplexAutomorphism X s\n  s \\<noteq> id\n  s = id", "show False"], ["proof (prove)\nusing this:\n  ChamberComplexAutomorphism X s\n  s \\<noteq> id\n  s = id\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s ` C0 \\<noteq> C0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "ultimately"], ["proof (chain)\npicking this:\n  s ` C0 = C0 \\<or> s ` C0 = D0\n  s ` C0 \\<noteq> C0", "have sC0_D0: \"s`C0 = D0\""], ["proof (prove)\nusing this:\n  s ` C0 = C0 \\<or> s ` C0 = D0\n  s ` C0 \\<noteq> C0\n\ngoal (1 subgoal):\n 1. s ` C0 = D0", "by fast"], ["proof (state)\nthis:\n  s ` C0 = D0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "have \"\\<s> v \\<notin> C0\\<inter>D0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<s> v \\<notin> C0 \\<inter> D0", "using insert(2) C0D0_D0 facetrel_psubset"], ["proof (prove)\nusing this:\n  D0 = insert (\\<s> v) (C0 \\<inter> D0)\n  C0 \\<inter> D0 \\<lhd> D0\n  ?y \\<lhd> ?x \\<Longrightarrow> order.greater ?x ?y\n\ngoal (1 subgoal):\n 1. \\<s> v \\<notin> C0 \\<inter> D0", "by force"], ["proof (state)\nthis:\n  \\<s> v \\<notin> C0 \\<inter> D0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> C0 - C0 \\<inter> D0 \\<Longrightarrow> s a = \\<s> a", "thus \"s v = \\<s> v\""], ["proof (prove)\nusing this:\n  \\<s> v \\<notin> C0 \\<inter> D0\n\ngoal (1 subgoal):\n 1. s v = \\<s> v", "using insert sC0_D0 sv_nin_C0D0"], ["proof (prove)\nusing this:\n  \\<s> v \\<notin> C0 \\<inter> D0\n  s ` C0 = insert (s v) (C0 \\<inter> D0)\n  D0 = insert (\\<s> v) (C0 \\<inter> D0)\n  s ` C0 = D0\n  s v \\<notin> C0 \\<inter> D0\n\ngoal (1 subgoal):\n 1. s v = \\<s> v", "by auto"], ["proof (state)\nthis:\n  s v = \\<s> v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fun_eq_on s \\<s> (C0 - C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. order.greater_eq C0 (C0 \\<inter> D0)", "qed simp"], ["", "lemma induced_automorphism_unique_automorphism:\n  \"\\<lbrakk> ChamberComplexAutomorphism X s; s\\<noteq>id; fixespointwise s (C0\\<inter>D0) \\<rbrakk>\n    \\<Longrightarrow> s = \\<s>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ChamberComplexAutomorphism X s; s \\<noteq> id;\n     fixespointwise s (C0 \\<inter> D0)\\<rbrakk>\n    \\<Longrightarrow> s = \\<s>", "using chambers(1) induced_automorphism_unique_automorphism'\n        standard_uniqueness_automorphs induced_automorphism_automorphism"], ["proof (prove)\nusing this:\n  folding_g.chamber C0\n  \\<lbrakk>ChamberComplexAutomorphism X ?s; ?s \\<noteq> id;\n   fixespointwise ?s (C0 \\<inter> D0)\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on ?s \\<s> C0\n  \\<lbrakk>ChamberComplexAutomorphism X ?f; ChamberComplexAutomorphism X ?g;\n   folding_g.chamber ?C; fun_eq_on ?f ?g ?C\\<rbrakk>\n  \\<Longrightarrow> ?f = ?g\n  ChamberComplexAutomorphism X \\<s>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ChamberComplexAutomorphism X s; s \\<noteq> id;\n     fixespointwise s (C0 \\<inter> D0)\\<rbrakk>\n    \\<Longrightarrow> s = \\<s>", "by    fastforce"], ["", "lemmas indaut_uniq_aut =\n  induced_automorphism_unique_automorphism"], ["", "lemma induced_automorphism_unique:\n  \"OpposedThinChamberComplexFoldings X f' g' C0 \\<Longrightarrow> g'`C0 = g`C0 \\<Longrightarrow>\n    OpposedThinChamberComplexFoldings.induced_automorphism X f' g' = \\<s>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OpposedThinChamberComplexFoldings X f' g' C0;\n     g' ` C0 = D0\\<rbrakk>\n    \\<Longrightarrow> OpposedThinChamberComplexFoldings.induced_automorphism\n                       X f' g' =\n                      \\<s>", "using induced_automorphism_automorphism induced_automorphism_ntrivial\n        induced_automorphism_fixespointwise_C0_int_D0"], ["proof (prove)\nusing this:\n  ChamberComplexAutomorphism X \\<s>\n  \\<s> \\<noteq> id\n  fixespointwise \\<s> (C0 \\<inter> D0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>OpposedThinChamberComplexFoldings X f' g' C0;\n     g' ` C0 = D0\\<rbrakk>\n    \\<Longrightarrow> OpposedThinChamberComplexFoldings.induced_automorphism\n                       X f' g' =\n                      \\<s>", "by    (auto intro:\n          OpposedThinChamberComplexFoldings.indaut_uniq_aut[\n            THEN sym\n          ]\n        )"], ["", "lemma induced_automorphism_sym:\n  \"OpposedThinChamberComplexFoldings.induced_automorphism X g f = \\<s>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings.induced_automorphism X g f = \\<s>", "using OpposedThinChamberComplexFoldings.indaut_aut[\n          OF fg_symmetric\n        ]\n        OpposedThinChamberComplexFoldings.induced_automorphism_ntrivial[\n          OF fg_symmetric\n        ]\n        OpposedThinChamberComplexFoldings.indaut_fixes_fundfacet[\n          OF fg_symmetric\n        ]\n        induced_automorphism_unique_automorphism"], ["proof (prove)\nusing this:\n  ChamberComplexAutomorphism X\n   (OpposedThinChamberComplexFoldings.induced_automorphism X g f)\n  OpposedThinChamberComplexFoldings.induced_automorphism X g f \\<noteq> id\n  fixespointwise\n   (OpposedThinChamberComplexFoldings.induced_automorphism X g f)\n   (D0 \\<inter> f ` D0)\n  \\<lbrakk>ChamberComplexAutomorphism X ?s; ?s \\<noteq> id;\n   fixespointwise ?s (C0 \\<inter> D0)\\<rbrakk>\n  \\<Longrightarrow> ?s = \\<s>\n\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings.induced_automorphism X g f = \\<s>", "by    (simp add: chambers(4) Int_commute)"], ["", "lemma induced_automorphism_respects_labels:\n  assumes \"label_wrt B \\<phi>\" \"v\\<in>(\\<Union>X)\"\n  shows   \"\\<phi> (\\<s> v) = \\<phi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (\\<s> v) = \\<phi> v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> (\\<s> v) = \\<phi> v", "from assms(2)"], ["proof (chain)\npicking this:\n  v \\<in> \\<Union> X", "obtain C where \"chamber C\" \"v\\<in>C\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>folding_g.chamber C; v \\<in> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using simplex_in_max"], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> X\n  ?y \\<in> X \\<Longrightarrow>\n  \\<exists>x. folding_g.chamber x \\<and> order.greater_eq x ?y\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>folding_g.chamber C; v \\<in> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  folding_g.chamber C\n  v \\<in> C\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<s> v) = \\<phi> v", "with assms"], ["proof (chain)\npicking this:\n  folding_g.label_wrt B \\<phi>\n  v \\<in> \\<Union> X\n  folding_g.chamber C\n  v \\<in> C", "show ?thesis"], ["proof (prove)\nusing this:\n  folding_g.label_wrt B \\<phi>\n  v \\<in> \\<Union> X\n  folding_g.chamber C\n  v \\<in> C\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<s> v) = \\<phi> v", "by  (simp add:\n          induced_automorphism_on_chamber_vertices_f folding_f.respects_labels\n          folding_g.respects_labels\n        )"], ["proof (state)\nthis:\n  \\<phi> (\\<s> v) = \\<phi> v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas indaut_resplabels =\n  induced_automorphism_respects_labels"], ["", "end"], ["", "(* context OpposedThinChamberComplexFoldings *)"], ["", "subsubsection \\<open>Walls\\<close>"], ["", "text \\<open>\n  A pair of opposed foldings of a thin chamber complex defines a decomposition of the chamber\n  system into the two disjoint chamber system images. Call such a decomposition a wall, as we image\n  that disjointness erects a wall between the two half chamber systems. By considering the\n  collection of all possible opposed folding pairs, and their associated walls, we can obtain\n  information about minimality of galleries by considering the walls they cross.\n\\<close>"], ["", "context ThinChamberComplex\nbegin"], ["", "definition foldpairs :: \"(('a\\<Rightarrow>'a) \\<times> ('a\\<Rightarrow>'a)) set\"\n  where \"foldpairs \\<equiv> {(f,g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\""], ["", "abbreviation \"walls \\<equiv> \\<Union>(f,g)\\<in>foldpairs. {{f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}}\""], ["", "abbreviation \"the_wall_betw C D \\<equiv>\n              THE_default {} (\\<lambda>H. H\\<in>walls \\<and> separated_by H C D)\""], ["", "definition walls_betw :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set set set set\"\n  where \"walls_betw C D \\<equiv> {H\\<in>walls. separated_by H C D}\""], ["", "fun wall_crossings :: \"'a set list \\<Rightarrow> 'a set set set list\"\n  where \"wall_crossings [] = []\"\n  |     \"wall_crossings [C] = []\"\n  |     \"wall_crossings (B#C#Cs) = the_wall_betw B C # wall_crossings (C#Cs)\""], ["", "lemma foldpairs_sym: \"(f,g)\\<in>foldpairs \\<Longrightarrow> (g,f)\\<in>foldpairs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> foldpairs \\<Longrightarrow> (g, f) \\<in> foldpairs", "using foldpairs_def OpposedThinChamberComplexFoldings.fg_symmetric"], ["proof (prove)\nusing this:\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  OpposedThinChamberComplexFoldings ?X ?g ?f (?g ` ?C0.0)\n\ngoal (1 subgoal):\n 1. (f, g) \\<in> foldpairs \\<Longrightarrow> (g, f) \\<in> foldpairs", "by fastforce"], ["", "lemma not_self_separated_by_wall: \"H\\<in>walls \\<Longrightarrow> \\<not> separated_by H C C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> \\<C>,\n                  g \\<turnstile> \\<C>}}) \\<Longrightarrow>\n    \\<not> separated_by H C C", "using foldpairs_def OpposedThinChamberComplexFoldings.halfchsys_decomp(2)\n        not_self_separated_by_disjoint"], ["proof (prove)\nusing this:\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  ?f \\<turnstile> ChamberComplex.chamber_system ?X \\<inter>\n  (?g \\<turnstile> ChamberComplex.chamber_system ?X) =\n  {}\n  ?A \\<inter> ?B = {} \\<Longrightarrow> \\<not> separated_by {?A, ?B} ?x ?x\n\ngoal (1 subgoal):\n 1. H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> \\<C>,\n                  g \\<turnstile> \\<C>}}) \\<Longrightarrow>\n    \\<not> separated_by H C C", "by    force"], ["", "lemma the_wall_betw_nempty:\n  assumes \"the_wall_betw C D \\<noteq> {}\"\n  shows   \"the_wall_betw C D \\<in> walls\" \"separated_by (the_wall_betw C D) C D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C D)\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) &&&\n    separated_by\n     (THE_default {}\n       (\\<lambda>H.\n           H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                       {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n           separated_by H C D))\n     C D", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C D)\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n 2. separated_by\n     (THE_default {}\n       (\\<lambda>H.\n           H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                       {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n           separated_by H C D))\n     C D", "from assms"], ["proof (chain)\npicking this:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C D) \\<noteq>\n  {}", "have 1: \"\\<exists>!H'\\<in>walls. separated_by H' C D\""], ["proof (prove)\nusing this:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C D) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>!H'.\n       H' \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                    {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H' C D", "using THE_default_none[of \"\\<lambda>H. H\\<in>walls \\<and> separated_by H C D\" \"{}\"]"], ["proof (prove)\nusing this:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C D) \\<noteq>\n  {}\n  \\<nexists>!x.\n     x \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                 {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n     separated_by x C D \\<Longrightarrow>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C D) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>!H'.\n       H' \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                    {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H' C D", "by fast"], ["proof (state)\nthis:\n  \\<exists>!H'.\n     H' \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                  {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n     separated_by H' C D\n\ngoal (2 subgoals):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C D)\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n 2. separated_by\n     (THE_default {}\n       (\\<lambda>H.\n           H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                       {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n           separated_by H C D))\n     C D", "show \"the_wall_betw C D \\<in> walls\" \"separated_by (the_wall_betw C D) C D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C D)\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) &&&\n    separated_by\n     (THE_default {}\n       (\\<lambda>H.\n           H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                       {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n           separated_by H C D))\n     C D", "using THE_defaultI'[OF 1]"], ["proof (prove)\nusing this:\n  THE_default ?d\n   (\\<lambda>H'.\n       H' \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                    {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H' C D)\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n  separated_by\n   (THE_default ?d\n     (\\<lambda>H'.\n         H' \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                      {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H' C D))\n   C D\n\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C D)\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) &&&\n    separated_by\n     (THE_default {}\n       (\\<lambda>H.\n           H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                       {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n           separated_by H C D))\n     C D", "by auto"], ["proof (state)\nthis:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C D)\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  separated_by\n   (THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C D))\n   C D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma the_wall_betw_self_empty: \"the_wall_betw C C = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C C) =\n    {}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C C) =\n    {}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C C) =\n    {}", "assume *: \"the_wall_betw C C \\<noteq> {}\""], ["proof (state)\nthis:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C C) =\n    {}", "then"], ["proof (chain)\npicking this:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) \\<noteq>\n  {}", "obtain f g\n      where \"(f,g)\\<in>foldpairs\" \"the_wall_betw C C = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\""], ["proof (prove)\nusing this:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         THE_default {}\n          (\\<lambda>H.\n              H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n              separated_by H C C) =\n         {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using the_wall_betw_nempty(1)[of C C]"], ["proof (prove)\nusing this:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) \\<noteq>\n  {}\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) \\<noteq>\n  {} \\<Longrightarrow>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C)\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         THE_default {}\n          (\\<lambda>H.\n              H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n              separated_by H C C) =\n         {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    blast"], ["proof (state)\nthis:\n  (f, g) \\<in> foldpairs\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) =\n  {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C C) =\n    {}", "with *"], ["proof (chain)\npicking this:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) \\<noteq>\n  {}\n  (f, g) \\<in> foldpairs\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) =\n  {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}", "have False"], ["proof (prove)\nusing this:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) \\<noteq>\n  {}\n  (f, g) \\<in> foldpairs\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) =\n  {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n\ngoal (1 subgoal):\n 1. False", "using the_wall_betw_nempty(2)[of C C] foldpairs_def\n            OpposedThinChamberComplexFoldings.halfchsys_decomp(2)[\n              of X\n            ]\n            not_self_separated_by_disjoint[of \"f\\<turnstile>\\<C>\" \"g\\<turnstile>\\<C>\"]"], ["proof (prove)\nusing this:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) \\<noteq>\n  {}\n  (f, g) \\<in> foldpairs\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) =\n  {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) \\<noteq>\n  {} \\<Longrightarrow>\n  separated_by\n   (THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C C))\n   C C\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n  OpposedThinChamberComplexFoldings X ?f ?g ?C0.0 \\<Longrightarrow>\n  ?f \\<turnstile> \\<C> \\<inter> (?g \\<turnstile> \\<C>) = {}\n  f \\<turnstile> \\<C> \\<inter> (g \\<turnstile> \\<C>) = {} \\<Longrightarrow>\n  \\<not> separated_by {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} ?x ?x\n\ngoal (1 subgoal):\n 1. False", "by    auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C C) =\n    {}", "}"], ["proof (state)\nthis:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) \\<noteq>\n  {} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C C) =\n    {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) \\<noteq>\n  {} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C C) =\n    {}", "by fast"], ["proof (state)\nthis:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C C) =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_wall_crossings: \"length (wall_crossings Cs) = length Cs - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (wall_crossings Cs) = length Cs - 1", "by (induct Cs rule: list_induct_CCons) auto"], ["", "lemma wall_crossings_snoc:\n  \"wall_crossings (Cs@[D,E]) = wall_crossings (Cs@[D]) @ [the_wall_betw D E]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wall_crossings (Cs @ [D, E]) =\n    wall_crossings (Cs @ [D]) @\n    [THE_default {}\n      (\\<lambda>H.\n          H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                      {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n          separated_by H D E)]", "by (induct Cs rule: list_induct_CCons) auto"], ["", "lemma wall_crossings_are_walls:\n  \"H\\<in>set (wall_crossings Cs) \\<Longrightarrow> H\\<noteq>{} \\<Longrightarrow> H\\<in>walls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<in> set (wall_crossings Cs); H \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                  {{f \\<turnstile> \\<C>,\n                                    g \\<turnstile> \\<C>}})", "proof (induct Cs arbitrary: H rule: list_induct_CCons)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>H.\n       \\<lbrakk>H \\<in> set (wall_crossings []); H \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                     {{f \\<turnstile> \\<C>,\n g \\<turnstile> \\<C>}})\n 2. \\<And>x H.\n       \\<lbrakk>H \\<in> set (wall_crossings [x]); H \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                     {{f \\<turnstile> \\<C>,\n g \\<turnstile> \\<C>}})\n 3. \\<And>x y xs H.\n       \\<lbrakk>\\<And>H.\n                   \\<lbrakk>H \\<in> set (wall_crossings (y # xs));\n                    H \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n           {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}});\n        H \\<in> set (wall_crossings (x # y # xs)); H \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                     {{f \\<turnstile> \\<C>,\n g \\<turnstile> \\<C>}})", "case (CCons B C Cs)"], ["proof (state)\nthis:\n  \\<lbrakk>?H1 \\<in> set (wall_crossings (C # Cs)); ?H1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?H1\n                    \\<in> (\\<Union>a\\<in>foldpairs.\n                              case a of\n                              (f, g) \\<Rightarrow>\n                                {{f \\<turnstile> \\<C>,\n                                  g \\<turnstile> \\<C>}})\n  H \\<in> set (wall_crossings (B # C # Cs))\n  H \\<noteq> {}\n\ngoal (3 subgoals):\n 1. \\<And>H.\n       \\<lbrakk>H \\<in> set (wall_crossings []); H \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                     {{f \\<turnstile> \\<C>,\n g \\<turnstile> \\<C>}})\n 2. \\<And>x H.\n       \\<lbrakk>H \\<in> set (wall_crossings [x]); H \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                     {{f \\<turnstile> \\<C>,\n g \\<turnstile> \\<C>}})\n 3. \\<And>x y xs H.\n       \\<lbrakk>\\<And>H.\n                   \\<lbrakk>H \\<in> set (wall_crossings (y # xs));\n                    H \\<noteq> {}\\<rbrakk>\n                   \\<Longrightarrow> H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n           {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}});\n        H \\<in> set (wall_crossings (x # y # xs)); H \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                     {{f \\<turnstile> \\<C>,\n g \\<turnstile> \\<C>}})", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?H1 \\<in> set (wall_crossings (C # Cs)); ?H1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?H1\n                    \\<in> (\\<Union>a\\<in>foldpairs.\n                              case a of\n                              (f, g) \\<Rightarrow>\n                                {{f \\<turnstile> \\<C>,\n                                  g \\<turnstile> \\<C>}})\n  H \\<in> set (wall_crossings (B # C # Cs))\n  H \\<noteq> {}\n\ngoal (1 subgoal):\n 1. H \\<in> (\\<Union>a\\<in>foldpairs.\n                case a of\n                (f, g) \\<Rightarrow>\n                  {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})", "using the_wall_betw_nempty(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?H1 \\<in> set (wall_crossings (C # Cs)); ?H1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?H1\n                    \\<in> (\\<Union>a\\<in>foldpairs.\n                              case a of\n                              (f, g) \\<Rightarrow>\n                                {{f \\<turnstile> \\<C>,\n                                  g \\<turnstile> \\<C>}})\n  H \\<in> set (wall_crossings (B # C # Cs))\n  H \\<noteq> {}\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H ?C ?D) \\<noteq>\n  {} \\<Longrightarrow>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H ?C ?D)\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n\ngoal (1 subgoal):\n 1. H \\<in> (\\<Union>a\\<in>foldpairs.\n                case a of\n                (f, g) \\<Rightarrow>\n                  {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})", "by    (cases \"H\\<in>set (wall_crossings (C#Cs))\") auto"], ["proof (state)\nthis:\n  H \\<in> (\\<Union>a\\<in>foldpairs.\n              case a of\n              (f, g) \\<Rightarrow>\n                {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n\ngoal (2 subgoals):\n 1. \\<And>H.\n       \\<lbrakk>H \\<in> set (wall_crossings []); H \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                     {{f \\<turnstile> \\<C>,\n g \\<turnstile> \\<C>}})\n 2. \\<And>x H.\n       \\<lbrakk>H \\<in> set (wall_crossings [x]); H \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                     {{f \\<turnstile> \\<C>,\n g \\<turnstile> \\<C>}})", "qed auto"], ["", "lemma in_set_wall_crossings_decomp:\n  \"H\\<in>set (wall_crossings Cs) \\<Longrightarrow>\n    \\<exists>As A B Bs. Cs = As@[A,B]@Bs \\<and> H = the_wall_betw A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<in> set (wall_crossings Cs) \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       Cs = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                        {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)", "proof (induct Cs rule: list_induct_CCons)"], ["proof (state)\ngoal (3 subgoals):\n 1. H \\<in> set (wall_crossings []) \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       [] = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                        {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)\n 2. \\<And>x.\n       H \\<in> set (wall_crossings [x]) \\<Longrightarrow>\n       \\<exists>As A B Bs.\n          [x] = As @ [A, B] @ Bs \\<and>\n          H =\n          THE_default {}\n           (\\<lambda>H.\n               H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                           {{f \\<turnstile> \\<C>,\n                             g \\<turnstile> \\<C>}}) \\<and>\n               separated_by H A B)\n 3. \\<And>x y xs.\n       \\<lbrakk>H \\<in> set (wall_crossings (y # xs)) \\<Longrightarrow>\n                \\<exists>As A B Bs.\n                   y # xs = As @ [A, B] @ Bs \\<and>\n                   H =\n                   THE_default {}\n                    (\\<lambda>H.\n                        H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                    {{f \\<turnstile> \\<C>,\ng \\<turnstile> \\<C>}}) \\<and>\n                        separated_by H A B);\n        H \\<in> set (wall_crossings (x # y # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>As A B Bs.\n                            x # y # xs = As @ [A, B] @ Bs \\<and>\n                            H =\n                            THE_default {}\n                             (\\<lambda>H.\n                                 H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n       {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n                                 separated_by H A B)", "case (CCons C D Ds)"], ["proof (state)\nthis:\n  H \\<in> set (wall_crossings (D # Ds)) \\<Longrightarrow>\n  \\<exists>As A B Bs.\n     D # Ds = As @ [A, B] @ Bs \\<and>\n     H =\n     THE_default {}\n      (\\<lambda>H.\n          H \\<in> (\\<Union>a\\<in>foldpairs.\n                      case a of\n                      (f, g) \\<Rightarrow>\n                        {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n          separated_by H A B)\n  H \\<in> set (wall_crossings (C # D # Ds))\n\ngoal (3 subgoals):\n 1. H \\<in> set (wall_crossings []) \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       [] = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                        {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)\n 2. \\<And>x.\n       H \\<in> set (wall_crossings [x]) \\<Longrightarrow>\n       \\<exists>As A B Bs.\n          [x] = As @ [A, B] @ Bs \\<and>\n          H =\n          THE_default {}\n           (\\<lambda>H.\n               H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                           {{f \\<turnstile> \\<C>,\n                             g \\<turnstile> \\<C>}}) \\<and>\n               separated_by H A B)\n 3. \\<And>x y xs.\n       \\<lbrakk>H \\<in> set (wall_crossings (y # xs)) \\<Longrightarrow>\n                \\<exists>As A B Bs.\n                   y # xs = As @ [A, B] @ Bs \\<and>\n                   H =\n                   THE_default {}\n                    (\\<lambda>H.\n                        H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                    {{f \\<turnstile> \\<C>,\ng \\<turnstile> \\<C>}}) \\<and>\n                        separated_by H A B);\n        H \\<in> set (wall_crossings (x # y # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>As A B Bs.\n                            x # y # xs = As @ [A, B] @ Bs \\<and>\n                            H =\n                            THE_default {}\n                             (\\<lambda>H.\n                                 H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n       {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n                                 separated_by H A B)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>As A B Bs.\n       C # D # Ds = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>a\\<in>foldpairs.\n                        case a of\n                        (f, g) \\<Rightarrow>\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)", "proof (cases \"H \\<in> set (wall_crossings (D#Ds))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. H \\<in> set (wall_crossings (D # Ds)) \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       C # D # Ds = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>a\\<in>foldpairs.\n                        case a of\n                        (f, g) \\<Rightarrow>\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)\n 2. H \\<notin> set (wall_crossings (D # Ds)) \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       C # D # Ds = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>a\\<in>foldpairs.\n                        case a of\n                        (f, g) \\<Rightarrow>\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)", "case True"], ["proof (state)\nthis:\n  H \\<in> set (wall_crossings (D # Ds))\n\ngoal (2 subgoals):\n 1. H \\<in> set (wall_crossings (D # Ds)) \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       C # D # Ds = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>a\\<in>foldpairs.\n                        case a of\n                        (f, g) \\<Rightarrow>\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)\n 2. H \\<notin> set (wall_crossings (D # Ds)) \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       C # D # Ds = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>a\\<in>foldpairs.\n                        case a of\n                        (f, g) \\<Rightarrow>\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)", "with CCons(1)"], ["proof (chain)\npicking this:\n  H \\<in> set (wall_crossings (D # Ds)) \\<Longrightarrow>\n  \\<exists>As A B Bs.\n     D # Ds = As @ [A, B] @ Bs \\<and>\n     H =\n     THE_default {}\n      (\\<lambda>H.\n          H \\<in> (\\<Union>a\\<in>foldpairs.\n                      case a of\n                      (f, g) \\<Rightarrow>\n                        {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n          separated_by H A B)\n  H \\<in> set (wall_crossings (D # Ds))", "obtain As A B Bs\n      where \"C#(D#Ds) = (C#As)@[A,B]@Bs\" \"H = the_wall_betw A B\""], ["proof (prove)\nusing this:\n  H \\<in> set (wall_crossings (D # Ds)) \\<Longrightarrow>\n  \\<exists>As A B Bs.\n     D # Ds = As @ [A, B] @ Bs \\<and>\n     H =\n     THE_default {}\n      (\\<lambda>H.\n          H \\<in> (\\<Union>a\\<in>foldpairs.\n                      case a of\n                      (f, g) \\<Rightarrow>\n                        {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n          separated_by H A B)\n  H \\<in> set (wall_crossings (D # Ds))\n\ngoal (1 subgoal):\n 1. (\\<And>As A B Bs.\n        \\<lbrakk>C # D # Ds = (C # As) @ [A, B] @ Bs;\n         H =\n         THE_default {}\n          (\\<lambda>H.\n              H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n              separated_by H A B)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fastforce"], ["proof (state)\nthis:\n  C # D # Ds = (C # As) @ [A, B] @ Bs\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B)\n\ngoal (2 subgoals):\n 1. H \\<in> set (wall_crossings (D # Ds)) \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       C # D # Ds = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>a\\<in>foldpairs.\n                        case a of\n                        (f, g) \\<Rightarrow>\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)\n 2. H \\<notin> set (wall_crossings (D # Ds)) \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       C # D # Ds = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>a\\<in>foldpairs.\n                        case a of\n                        (f, g) \\<Rightarrow>\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)", "thus ?thesis"], ["proof (prove)\nusing this:\n  C # D # Ds = (C # As) @ [A, B] @ Bs\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B)\n\ngoal (1 subgoal):\n 1. \\<exists>As A B Bs.\n       C # D # Ds = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>a\\<in>foldpairs.\n                        case a of\n                        (f, g) \\<Rightarrow>\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)", "by fast"], ["proof (state)\nthis:\n  \\<exists>As A B Bs.\n     C # D # Ds = As @ [A, B] @ Bs \\<and>\n     H =\n     THE_default {}\n      (\\<lambda>H.\n          H \\<in> (\\<Union>a\\<in>foldpairs.\n                      case a of\n                      (f, g) \\<Rightarrow>\n                        {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n          separated_by H A B)\n\ngoal (1 subgoal):\n 1. H \\<notin> set (wall_crossings (D # Ds)) \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       C # D # Ds = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>a\\<in>foldpairs.\n                        case a of\n                        (f, g) \\<Rightarrow>\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<notin> set (wall_crossings (D # Ds)) \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       C # D # Ds = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>a\\<in>foldpairs.\n                        case a of\n                        (f, g) \\<Rightarrow>\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)", "case False"], ["proof (state)\nthis:\n  H \\<notin> set (wall_crossings (D # Ds))\n\ngoal (1 subgoal):\n 1. H \\<notin> set (wall_crossings (D # Ds)) \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       C # D # Ds = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>a\\<in>foldpairs.\n                        case a of\n                        (f, g) \\<Rightarrow>\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)", "with CCons(2)"], ["proof (chain)\npicking this:\n  H \\<in> set (wall_crossings (C # D # Ds))\n  H \\<notin> set (wall_crossings (D # Ds))", "have \"C#(D#Ds) = []@[C,D]@Ds\" \"H = the_wall_betw C D\""], ["proof (prove)\nusing this:\n  H \\<in> set (wall_crossings (C # D # Ds))\n  H \\<notin> set (wall_crossings (D # Ds))\n\ngoal (1 subgoal):\n 1. C # D # Ds = [] @ [C, D] @ Ds &&&\n    H =\n    THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C D)", "by auto"], ["proof (state)\nthis:\n  C # D # Ds = [] @ [C, D] @ Ds\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C D)\n\ngoal (1 subgoal):\n 1. H \\<notin> set (wall_crossings (D # Ds)) \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       C # D # Ds = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>a\\<in>foldpairs.\n                        case a of\n                        (f, g) \\<Rightarrow>\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)", "thus ?thesis"], ["proof (prove)\nusing this:\n  C # D # Ds = [] @ [C, D] @ Ds\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C D)\n\ngoal (1 subgoal):\n 1. \\<exists>As A B Bs.\n       C # D # Ds = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>a\\<in>foldpairs.\n                        case a of\n                        (f, g) \\<Rightarrow>\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)", "by fast"], ["proof (state)\nthis:\n  \\<exists>As A B Bs.\n     C # D # Ds = As @ [A, B] @ Bs \\<and>\n     H =\n     THE_default {}\n      (\\<lambda>H.\n          H \\<in> (\\<Union>a\\<in>foldpairs.\n                      case a of\n                      (f, g) \\<Rightarrow>\n                        {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n          separated_by H A B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>As A B Bs.\n     C # D # Ds = As @ [A, B] @ Bs \\<and>\n     H =\n     THE_default {}\n      (\\<lambda>H.\n          H \\<in> (\\<Union>a\\<in>foldpairs.\n                      case a of\n                      (f, g) \\<Rightarrow>\n                        {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n          separated_by H A B)\n\ngoal (2 subgoals):\n 1. H \\<in> set (wall_crossings []) \\<Longrightarrow>\n    \\<exists>As A B Bs.\n       [] = As @ [A, B] @ Bs \\<and>\n       H =\n       THE_default {}\n        (\\<lambda>H.\n            H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                        {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n            separated_by H A B)\n 2. \\<And>x.\n       H \\<in> set (wall_crossings [x]) \\<Longrightarrow>\n       \\<exists>As A B Bs.\n          [x] = As @ [A, B] @ Bs \\<and>\n          H =\n          THE_default {}\n           (\\<lambda>H.\n               H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                           {{f \\<turnstile> \\<C>,\n                             g \\<turnstile> \\<C>}}) \\<and>\n               separated_by H A B)", "qed auto"], ["", "end"], ["", "(* context ThinChamberComplex *)"], ["", "context OpposedThinChamberComplexFoldings\nbegin"], ["", "lemma foldpair: \"(f,g)\\<in>foldpairs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> foldpairs", "unfolding foldpairs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}", "have \"OpposedThinChamberComplexFoldings X f g C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings X f g C0", ".."], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g C0\n\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}", "thus \"(f, g) \\<in> {(f, g).\n          \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\""], ["proof (prove)\nusing this:\n  OpposedThinChamberComplexFoldings X f g C0\n\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}", "by fast"], ["proof (state)\nthis:\n  (f, g)\n  \\<in> {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma separated_by_this_wall_fg:\n  \"separated_by {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} C D \\<Longrightarrow> C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> D\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>separated_by\n              {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n              C D;\n     C \\<in> f \\<turnstile> folding_g.\\<C>\\<rbrakk>\n    \\<Longrightarrow> D \\<in> g \\<turnstile> folding_g.\\<C>", "using separated_by_disjoint[\n          OF _ half_chamber_system_disjoint_union(2), of C D\n        ]"], ["proof (prove)\nusing this:\n  \\<lbrakk>separated_by\n            {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C\n            D;\n   C \\<in> f \\<turnstile> folding_g.\\<C>\\<rbrakk>\n  \\<Longrightarrow> D \\<in> g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>separated_by\n              {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n              C D;\n     C \\<in> f \\<turnstile> folding_g.\\<C>\\<rbrakk>\n    \\<Longrightarrow> D \\<in> g \\<turnstile> folding_g.\\<C>", "by    fast"], ["", "lemmas separated_by_this_wall_gf =\n  OpposedThinChamberComplexFoldings.separated_by_this_wall_fg[\n    OF fg_symmetric\n  ]"], ["", "lemma induced_automorphism_this_wall_vertex:\n  assumes \"C\\<in>f\\<turnstile>\\<C>\" \"D\\<in>g\\<turnstile>\\<C>\" \"v\\<in>C\\<inter>D\"\n  shows   \"\\<s> v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<s> v = v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<s> v = v", "from assms"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  D \\<in> g \\<turnstile> folding_g.\\<C>\n  v \\<in> C \\<inter> D", "have \"\\<s> v = g v\""], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  D \\<in> g \\<turnstile> folding_g.\\<C>\n  v \\<in> C \\<inter> D\n\ngoal (1 subgoal):\n 1. \\<s> v = g v", "using chamber_system_simplices induced_automorphism_on_simplices_fg"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  D \\<in> g \\<turnstile> folding_g.\\<C>\n  v \\<in> C \\<inter> D\n  order.greater_eq X folding_g.\\<C>\n  \\<lbrakk>?x \\<in> f \\<turnstile> X; ?v \\<in> ?x\\<rbrakk>\n  \\<Longrightarrow> \\<s> ?v = g ?v\n\ngoal (1 subgoal):\n 1. \\<s> v = g v", "by    auto"], ["proof (state)\nthis:\n  \\<s> v = g v\n\ngoal (1 subgoal):\n 1. \\<s> v = v", "with assms(2,3)"], ["proof (chain)\npicking this:\n  D \\<in> g \\<turnstile> folding_g.\\<C>\n  v \\<in> C \\<inter> D\n  \\<s> v = g v", "show \"\\<s> v = v\""], ["proof (prove)\nusing this:\n  D \\<in> g \\<turnstile> folding_g.\\<C>\n  v \\<in> C \\<inter> D\n  \\<s> v = g v\n\ngoal (1 subgoal):\n 1. \\<s> v = v", "using chamber_system_simplices folding_g.retraction"], ["proof (prove)\nusing this:\n  D \\<in> g \\<turnstile> folding_g.\\<C>\n  v \\<in> C \\<inter> D\n  \\<s> v = g v\n  order.greater_eq X folding_g.\\<C>\n  ?v \\<in> \\<Union> X \\<Longrightarrow> g (g ?v) = g ?v\n\ngoal (1 subgoal):\n 1. \\<s> v = v", "by auto"], ["proof (state)\nthis:\n  \\<s> v = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas indaut_wallvertex =\n  induced_automorphism_this_wall_vertex"], ["", "lemma unique_wall:\n  assumes opp'    : \"OpposedThinChamberComplexFoldings X f' g' C'\"\n  and     chambers: \"A\\<in>f\\<turnstile>\\<C>\" \"A\\<in>f'\\<turnstile>\\<C>\" \"B\\<in>g\\<turnstile>\\<C>\" \"B\\<in>g'\\<turnstile>\\<C>\" \"A\\<sim>B\"\n  shows   \"{f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} = {f'\\<turnstile>\\<C>,g'\\<turnstile>\\<C>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n    {f' \\<turnstile> folding_g.\\<C>, g' \\<turnstile> folding_g.\\<C>}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n    {f' \\<turnstile> folding_g.\\<C>, g' \\<turnstile> folding_g.\\<C>}", "from chambers"], ["proof (chain)\npicking this:\n  A \\<in> f \\<turnstile> folding_g.\\<C>\n  A \\<in> f' \\<turnstile> folding_g.\\<C>\n  B \\<in> g \\<turnstile> folding_g.\\<C>\n  B \\<in> g' \\<turnstile> folding_g.\\<C>\n  A \\<sim> B", "have B: \"B=g`A\" \"B=g'`A\""], ["proof (prove)\nusing this:\n  A \\<in> f \\<turnstile> folding_g.\\<C>\n  A \\<in> f' \\<turnstile> folding_g.\\<C>\n  B \\<in> g \\<turnstile> folding_g.\\<C>\n  B \\<in> g' \\<turnstile> folding_g.\\<C>\n  A \\<sim> B\n\ngoal (1 subgoal):\n 1. B = g ` A &&& B = g' ` A", "using adjacent_sym[of A B] adjacent_half_chamber_system_image_gf\n          OpposedThinChamberComplexFoldings.adjhalfchsys_image_gf[\n            OF opp'\n          ]"], ["proof (prove)\nusing this:\n  A \\<in> f \\<turnstile> folding_g.\\<C>\n  A \\<in> f' \\<turnstile> folding_g.\\<C>\n  B \\<in> g \\<turnstile> folding_g.\\<C>\n  B \\<in> g' \\<turnstile> folding_g.\\<C>\n  A \\<sim> B\n  A \\<sim> B \\<Longrightarrow> B \\<sim> A\n  \\<lbrakk>?C \\<in> g \\<turnstile> folding_g.\\<C>;\n   ?D \\<in> f \\<turnstile> folding_g.\\<C>; ?C \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> g ` ?D = ?C\n  \\<lbrakk>?C \\<in> g' \\<turnstile> folding_g.\\<C>;\n   ?D \\<in> f' \\<turnstile> folding_g.\\<C>; ?C \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> g' ` ?D = ?C\n\ngoal (1 subgoal):\n 1. B = g ` A &&& B = g' ` A", "by    auto"], ["proof (state)\nthis:\n  B = g ` A\n  B = g' ` A\n\ngoal (1 subgoal):\n 1. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n    {f' \\<turnstile> folding_g.\\<C>, g' \\<turnstile> folding_g.\\<C>}", "with chambers(1,2,5)"], ["proof (chain)\npicking this:\n  A \\<in> f \\<turnstile> folding_g.\\<C>\n  A \\<in> f' \\<turnstile> folding_g.\\<C>\n  A \\<sim> B\n  B = g ` A\n  B = g' ` A", "have  A : \"OpposedThinChamberComplexFoldings X f g A\"\n    and   A': \"OpposedThinChamberComplexFoldings X f' g' A\""], ["proof (prove)\nusing this:\n  A \\<in> f \\<turnstile> folding_g.\\<C>\n  A \\<in> f' \\<turnstile> folding_g.\\<C>\n  A \\<sim> B\n  B = g ` A\n  B = g' ` A\n\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings X f g A &&&\n    OpposedThinChamberComplexFoldings X f' g' A", "using switch_basechamber[of A]\n          OpposedThinChamberComplexFoldings.switch_basechamber[\n            OF opp', of A\n          ]"], ["proof (prove)\nusing this:\n  A \\<in> f \\<turnstile> folding_g.\\<C>\n  A \\<in> f' \\<turnstile> folding_g.\\<C>\n  A \\<sim> B\n  B = g ` A\n  B = g' ` A\n  \\<lbrakk>A \\<in> f \\<turnstile> folding_g.\\<C>; A \\<sim> g ` A\\<rbrakk>\n  \\<Longrightarrow> OpposedThinChamberComplexFoldings X f g A\n  \\<lbrakk>A \\<in> f' \\<turnstile> folding_g.\\<C>; A \\<sim> g' ` A\\<rbrakk>\n  \\<Longrightarrow> OpposedThinChamberComplexFoldings X f' g' A\n\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings X f g A &&&\n    OpposedThinChamberComplexFoldings X f' g' A", "by    auto"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g A\n  OpposedThinChamberComplexFoldings X f' g' A\n\ngoal (1 subgoal):\n 1. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n    {f' \\<turnstile> folding_g.\\<C>, g' \\<turnstile> folding_g.\\<C>}", "with B"], ["proof (chain)\npicking this:\n  B = g ` A\n  B = g' ` A\n  OpposedThinChamberComplexFoldings X f g A\n  OpposedThinChamberComplexFoldings X f' g' A", "show ?thesis"], ["proof (prove)\nusing this:\n  B = g ` A\n  B = g' ` A\n  OpposedThinChamberComplexFoldings X f g A\n  OpposedThinChamberComplexFoldings X f' g' A\n\ngoal (1 subgoal):\n 1. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n    {f' \\<turnstile> folding_g.\\<C>, g' \\<turnstile> folding_g.\\<C>}", "using OpposedThinChamberComplexFoldings.unique_half_chamber_system_f[\n            OF A A'\n          ]\n          OpposedThinChamberComplexFoldings.unique_half_chamber_system_g[\n            OF A A'\n          ]"], ["proof (prove)\nusing this:\n  B = g ` A\n  B = g' ` A\n  OpposedThinChamberComplexFoldings X f g A\n  OpposedThinChamberComplexFoldings X f' g' A\n  g' ` A = g ` A \\<Longrightarrow>\n  f' \\<turnstile> folding_g.\\<C> = f \\<turnstile> folding_g.\\<C>\n  g' ` A = g ` A \\<Longrightarrow>\n  g' \\<turnstile> folding_g.\\<C> = g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n    {f' \\<turnstile> folding_g.\\<C>, g' \\<turnstile> folding_g.\\<C>}", "by    auto"], ["proof (state)\nthis:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n  {f' \\<turnstile> folding_g.\\<C>, g' \\<turnstile> folding_g.\\<C>}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context OpposedThinChamberComplexFoldings *)"], ["", "context ThinChamberComplex\nbegin"], ["", "lemma separated_by_wall_ex_foldpair:\n  assumes \"H\\<in>walls\" \"separated_by H C D\"\n  shows   \"\\<exists>(f,g)\\<in>foldpairs. H = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} \\<and> C\\<in>f\\<turnstile>\\<C> \\<and> D\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "from assms(1)"], ["proof (chain)\npicking this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})", "obtain f g where fg: \"(f,g)\\<in>foldpairs\" \"H = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\""], ["proof (prove)\nusing this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "proof (cases \"C\\<in>f\\<turnstile>\\<C>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>\n 2. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "case True"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>\n 2. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "moreover"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>\n 2. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "with fg assms(2)"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  separated_by H C D\n  C \\<in> f \\<turnstile> \\<C>", "have \"D\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  separated_by H C D\n  C \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. D \\<in> g \\<turnstile> \\<C>", "using foldpairs_def\n            OpposedThinChamberComplexFoldings.separated_by_this_wall_fg[\n              of X f g _ C D\n            ]"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  separated_by H C D\n  C \\<in> f \\<turnstile> \\<C>\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n  \\<lbrakk>OpposedThinChamberComplexFoldings X f g ?C0.0;\n   separated_by {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} C D;\n   C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. D \\<in> g \\<turnstile> \\<C>", "by    auto"], ["proof (state)\nthis:\n  D \\<in> g \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>\n 2. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "ultimately"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "using fg"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "by auto"], ["proof (state)\nthis:\n  \\<exists>(f, g)\\<in>foldpairs.\n     H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n     C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "case False"], ["proof (state)\nthis:\n  C \\<notin> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "with assms(2) fg"], ["proof (chain)\npicking this:\n  separated_by H C D\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<notin> f \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  separated_by H C D\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<notin> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "using foldpairs_sym[of f g] separated_by_in_other[of \"f\\<turnstile>\\<C>\" \"g\\<turnstile>\\<C>\" C D]"], ["proof (prove)\nusing this:\n  separated_by H C D\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<notin> f \\<turnstile> \\<C>\n  (f, g) \\<in> foldpairs \\<Longrightarrow> (g, f) \\<in> foldpairs\n  \\<lbrakk>separated_by {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} C D;\n   C \\<notin> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> C \\<in> g \\<turnstile> \\<C> \\<and>\n                    D \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>", "by auto"], ["proof (state)\nthis:\n  \\<exists>(f, g)\\<in>foldpairs.\n     H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n     C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>(f, g)\\<in>foldpairs.\n     H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n     C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> g \\<turnstile> \\<C>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_separated_by_wall_ex_foldpair:\n  assumes chambers: \"chamber C\" \"chamber D\"\n  and     wall    : \"H\\<in>walls\" \"\\<not> separated_by H C D\"\n  shows   \"\\<exists>(f,g)\\<in>foldpairs. H = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} \\<and> C\\<in>f\\<turnstile>\\<C> \\<and> D\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "from wall(1)"], ["proof (chain)\npicking this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})", "obtain f g where fg: \"(f,g)\\<in>foldpairs\" \"H = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\""], ["proof (prove)\nusing this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "from fg(1)"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs", "obtain A where A: \"OpposedThinChamberComplexFoldings X f g A\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        OpposedThinChamberComplexFoldings X f g A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using foldpairs_def"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        OpposedThinChamberComplexFoldings X f g A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g A\n\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "from chambers"], ["proof (chain)\npicking this:\n  chamber C\n  chamber D", "have chambers': \"C\\<in>f\\<turnstile>\\<C> \\<or> C\\<in>g\\<turnstile>\\<C>\" \"D\\<in>f\\<turnstile>\\<C> \\<or> D\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  chamber C\n  chamber D\n\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> \\<C> \\<or> C \\<in> g \\<turnstile> \\<C> &&&\n    D \\<in> f \\<turnstile> \\<C> \\<or> D \\<in> g \\<turnstile> \\<C>", "using chamber_system_def\n          OpposedThinChamberComplexFoldings.halfchsys_decomp(1)[\n            OF A\n          ]"], ["proof (prove)\nusing this:\n  chamber C\n  chamber D\n  \\<C> \\<equiv> Collect chamber\n  \\<C> = f \\<turnstile> \\<C> \\<union> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> \\<C> \\<or> C \\<in> g \\<turnstile> \\<C> &&&\n    D \\<in> f \\<turnstile> \\<C> \\<or> D \\<in> g \\<turnstile> \\<C>", "by    auto"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> \\<C> \\<or> C \\<in> g \\<turnstile> \\<C>\n  D \\<in> f \\<turnstile> \\<C> \\<or> D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "proof (cases \"C\\<in>f\\<turnstile>\\<C>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>\n 2. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "case True"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>\n 2. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "moreover"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>\n 2. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "with chambers'(2) fg(2) wall(2)"], ["proof (chain)\npicking this:\n  D \\<in> f \\<turnstile> \\<C> \\<or> D \\<in> g \\<turnstile> \\<C>\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  \\<not> separated_by H C D\n  C \\<in> f \\<turnstile> \\<C>", "have \"D\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  D \\<in> f \\<turnstile> \\<C> \\<or> D \\<in> g \\<turnstile> \\<C>\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  \\<not> separated_by H C D\n  C \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. D \\<in> f \\<turnstile> \\<C>", "unfolding separated_by_def"], ["proof (prove)\nusing this:\n  D \\<in> f \\<turnstile> \\<C> \\<or> D \\<in> g \\<turnstile> \\<C>\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  \\<nexists>A B. H = {A, B} \\<and> C \\<in> A \\<and> D \\<in> B\n  C \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. D \\<in> f \\<turnstile> \\<C>", "by auto"], ["proof (state)\nthis:\n  D \\<in> f \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>\n 2. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "ultimately"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> f \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "using fg"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> f \\<turnstile> \\<C>\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "by auto"], ["proof (state)\nthis:\n  \\<exists>(f, g)\\<in>foldpairs.\n     H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n     C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "case False"], ["proof (state)\nthis:\n  C \\<notin> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "with chambers'(1)"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> \\<C> \\<or> C \\<in> g \\<turnstile> \\<C>\n  C \\<notin> f \\<turnstile> \\<C>", "have \"C\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> \\<C> \\<or> C \\<in> g \\<turnstile> \\<C>\n  C \\<notin> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<in> g \\<turnstile> \\<C>", "by simp"], ["proof (state)\nthis:\n  C \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "moreover"], ["proof (state)\nthis:\n  C \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "with chambers'(2) fg(2) wall(2)"], ["proof (chain)\npicking this:\n  D \\<in> f \\<turnstile> \\<C> \\<or> D \\<in> g \\<turnstile> \\<C>\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  \\<not> separated_by H C D\n  C \\<in> g \\<turnstile> \\<C>", "have \"D\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  D \\<in> f \\<turnstile> \\<C> \\<or> D \\<in> g \\<turnstile> \\<C>\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  \\<not> separated_by H C D\n  C \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. D \\<in> g \\<turnstile> \\<C>", "using insert_commute[of \"f\\<turnstile>\\<C>\" \"g\\<turnstile>\\<C>\" \"{}\"]"], ["proof (prove)\nusing this:\n  D \\<in> f \\<turnstile> \\<C> \\<or> D \\<in> g \\<turnstile> \\<C>\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  \\<not> separated_by H C D\n  C \\<in> g \\<turnstile> \\<C>\n  {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} =\n  {g \\<turnstile> \\<C>, f \\<turnstile> \\<C>}\n\ngoal (1 subgoal):\n 1. D \\<in> g \\<turnstile> \\<C>", "unfolding separated_by_def"], ["proof (prove)\nusing this:\n  D \\<in> f \\<turnstile> \\<C> \\<or> D \\<in> g \\<turnstile> \\<C>\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  \\<nexists>A B. H = {A, B} \\<and> C \\<in> A \\<and> D \\<in> B\n  C \\<in> g \\<turnstile> \\<C>\n  {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} =\n  {g \\<turnstile> \\<C>, f \\<turnstile> \\<C>}\n\ngoal (1 subgoal):\n 1. D \\<in> g \\<turnstile> \\<C>", "by auto"], ["proof (state)\nthis:\n  D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "ultimately"], ["proof (chain)\npicking this:\n  C \\<in> g \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> g \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "using fg foldpairs_sym[of f g]"], ["proof (prove)\nusing this:\n  C \\<in> g \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  (f, g) \\<in> foldpairs \\<Longrightarrow> (g, f) \\<in> foldpairs\n\ngoal (1 subgoal):\n 1. \\<exists>(f, g)\\<in>foldpairs.\n       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n       C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>", "by auto"], ["proof (state)\nthis:\n  \\<exists>(f, g)\\<in>foldpairs.\n     H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n     C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>(f, g)\\<in>foldpairs.\n     H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n     C \\<in> f \\<turnstile> \\<C> \\<and> D \\<in> f \\<turnstile> \\<C>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adj_wall_imp_ex1_wall:\n  assumes adj : \"C\\<sim>D\"\n  and     wall: \"H0\\<in>walls\" \"separated_by H0 C D\"\n  shows \"\\<exists>!H\\<in>walls. separated_by H C D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C D", "proof (rule ex1I, rule conjI, rule wall(1), rule wall(2))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C D \\<Longrightarrow>\n       H = H0", "fix H"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C D \\<Longrightarrow>\n       H = H0", "assume H: \"H\\<in>walls \\<and> separated_by H C D\""], ["proof (state)\nthis:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n  separated_by H C D\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C D \\<Longrightarrow>\n       H = H0", "from this"], ["proof (chain)\npicking this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n  separated_by H C D", "obtain f g\n    where fg: \"(f,g)\\<in>foldpairs\" \"H={f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\" \"C\\<in>f\\<turnstile>\\<C>\" \"D\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n  separated_by H C D\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>};\n         C \\<in> f \\<turnstile> \\<C>; D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using separated_by_wall_ex_foldpair[of H C D]"], ["proof (prove)\nusing this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n  separated_by H C D\n  \\<lbrakk>H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                       {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}});\n   separated_by H C D\\<rbrakk>\n  \\<Longrightarrow> \\<exists>(f, g)\\<in>foldpairs.\n                       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n                       C \\<in> f \\<turnstile> \\<C> \\<and>\n                       D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>};\n         C \\<in> f \\<turnstile> \\<C>; D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C D \\<Longrightarrow>\n       H = H0", "from wall"], ["proof (chain)\npicking this:\n  H0 \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n               {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  separated_by H0 C D", "obtain f0 g0\n    where f0g0: \"(f0,g0)\\<in>foldpairs\" \"H0={f0\\<turnstile>\\<C>,g0\\<turnstile>\\<C>}\" \"C\\<in>f0\\<turnstile>\\<C>\" \"D\\<in>g0\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  H0 \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n               {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  separated_by H0 C D\n\ngoal (1 subgoal):\n 1. (\\<And>f0 g0.\n        \\<lbrakk>(f0, g0) \\<in> foldpairs;\n         H0 = {f0 \\<turnstile> \\<C>, g0 \\<turnstile> \\<C>};\n         C \\<in> f0 \\<turnstile> \\<C>; D \\<in> g0 \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using separated_by_wall_ex_foldpair[of H0 C D]"], ["proof (prove)\nusing this:\n  H0 \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n               {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  separated_by H0 C D\n  \\<lbrakk>H0 \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                        {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}});\n   separated_by H0 C D\\<rbrakk>\n  \\<Longrightarrow> \\<exists>(f, g)\\<in>foldpairs.\n                       H0 =\n                       {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n                       C \\<in> f \\<turnstile> \\<C> \\<and>\n                       D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. (\\<And>f0 g0.\n        \\<lbrakk>(f0, g0) \\<in> foldpairs;\n         H0 = {f0 \\<turnstile> \\<C>, g0 \\<turnstile> \\<C>};\n         C \\<in> f0 \\<turnstile> \\<C>; D \\<in> g0 \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  (f0, g0) \\<in> foldpairs\n  H0 = {f0 \\<turnstile> \\<C>, g0 \\<turnstile> \\<C>}\n  C \\<in> f0 \\<turnstile> \\<C>\n  D \\<in> g0 \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C D \\<Longrightarrow>\n       H = H0", "from fg(1) f0g0(1)"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs\n  (f0, g0) \\<in> foldpairs", "obtain A A0\n    where A : \"OpposedThinChamberComplexFoldings X f  g  A\"\n    and   A0: \"OpposedThinChamberComplexFoldings X f0 g0 A0\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  (f0, g0) \\<in> foldpairs\n\ngoal (1 subgoal):\n 1. (\\<And>A A0.\n        \\<lbrakk>OpposedThinChamberComplexFoldings X f g A;\n         OpposedThinChamberComplexFoldings X f0 g0 A0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using foldpairs_def"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  (f0, g0) \\<in> foldpairs\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n\ngoal (1 subgoal):\n 1. (\\<And>A A0.\n        \\<lbrakk>OpposedThinChamberComplexFoldings X f g A;\n         OpposedThinChamberComplexFoldings X f0 g0 A0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g A\n  OpposedThinChamberComplexFoldings X f0 g0 A0\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C D \\<Longrightarrow>\n       H = H0", "from fg(2-4) f0g0(2-4) adj"], ["proof (chain)\npicking this:\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n  H0 = {f0 \\<turnstile> \\<C>, g0 \\<turnstile> \\<C>}\n  C \\<in> f0 \\<turnstile> \\<C>\n  D \\<in> g0 \\<turnstile> \\<C>\n  C \\<sim> D", "show \"H = H0\""], ["proof (prove)\nusing this:\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n  H0 = {f0 \\<turnstile> \\<C>, g0 \\<turnstile> \\<C>}\n  C \\<in> f0 \\<turnstile> \\<C>\n  D \\<in> g0 \\<turnstile> \\<C>\n  C \\<sim> D\n\ngoal (1 subgoal):\n 1. H = H0", "using OpposedThinChamberComplexFoldings.unique_wall[OF A0 A]"], ["proof (prove)\nusing this:\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n  H0 = {f0 \\<turnstile> \\<C>, g0 \\<turnstile> \\<C>}\n  C \\<in> f0 \\<turnstile> \\<C>\n  D \\<in> g0 \\<turnstile> \\<C>\n  C \\<sim> D\n  \\<lbrakk>?A \\<in> f0 \\<turnstile> \\<C>; ?A \\<in> f \\<turnstile> \\<C>;\n   ?B \\<in> g0 \\<turnstile> \\<C>; ?B \\<in> g \\<turnstile> \\<C>;\n   ?A \\<sim> ?B\\<rbrakk>\n  \\<Longrightarrow> {f0 \\<turnstile> \\<C>, g0 \\<turnstile> \\<C>} =\n                    {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n\ngoal (1 subgoal):\n 1. H = H0", "by auto"], ["proof (state)\nthis:\n  H = H0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ThinChamberComplex *)"], ["", "context OpposedThinChamberComplexFoldings\nbegin"], ["", "lemma this_wall_betwI:\n  assumes \"C\\<in>f\\<turnstile>\\<C>\" \"D\\<in>g\\<turnstile>\\<C>\" \"C\\<sim>D\"\n  shows   \"the_wall_betw C D = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> folding_g.\\<C>,\n                       g \\<turnstile> folding_g.\\<C>}}) \\<and>\n         separated_by H C D) =\n    {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}", "proof (rule THE_default1_equality, rule adj_wall_imp_ex1_wall)"], ["proof (state)\ngoal (4 subgoals):\n 1. C \\<sim> D\n 2. ?H0.3\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}})\n 3. separated_by ?H0.3 C D\n 4. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}}) \\<and>\n    separated_by\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C D", "have \"OpposedThinChamberComplexFoldings X f g C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings X f g C0", ".."], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g C0\n\ngoal (4 subgoals):\n 1. C \\<sim> D\n 2. ?H0.3\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}})\n 3. separated_by ?H0.3 C D\n 4. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}}) \\<and>\n    separated_by\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C D", "thus \"{f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\\<in>walls\""], ["proof (prove)\nusing this:\n  OpposedThinChamberComplexFoldings X f g C0\n\ngoal (1 subgoal):\n 1. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}})", "using foldpairs_def"], ["proof (prove)\nusing this:\n  OpposedThinChamberComplexFoldings X f g C0\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n\ngoal (1 subgoal):\n 1. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}})", "by auto"], ["proof (state)\nthis:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> folding_g.\\<C>,\n              g \\<turnstile> folding_g.\\<C>}})\n\ngoal (3 subgoals):\n 1. C \\<sim> D\n 2. separated_by\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C D\n 3. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}}) \\<and>\n    separated_by\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C D", "moreover"], ["proof (state)\nthis:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> folding_g.\\<C>,\n              g \\<turnstile> folding_g.\\<C>}})\n\ngoal (3 subgoals):\n 1. C \\<sim> D\n 2. separated_by\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C D\n 3. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}}) \\<and>\n    separated_by\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C D", "from assms(1,2)"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  D \\<in> g \\<turnstile> folding_g.\\<C>", "show \"separated_by {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} C D\""], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  D \\<in> g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. separated_by\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C D", "by (auto intro: separated_byI)"], ["proof (state)\nthis:\n  separated_by\n   {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C D\n\ngoal (2 subgoals):\n 1. C \\<sim> D\n 2. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}}) \\<and>\n    separated_by\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C D", "ultimately"], ["proof (chain)\npicking this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> folding_g.\\<C>,\n              g \\<turnstile> folding_g.\\<C>}})\n  separated_by\n   {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C D", "show \"{f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\\<in>walls \\<and> separated_by {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} C D\""], ["proof (prove)\nusing this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> folding_g.\\<C>,\n              g \\<turnstile> folding_g.\\<C>}})\n  separated_by\n   {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C D\n\ngoal (1 subgoal):\n 1. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n    \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}}) \\<and>\n    separated_by\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C D", "by simp"], ["proof (state)\nthis:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> folding_g.\\<C>,\n              g \\<turnstile> folding_g.\\<C>}}) \\<and>\n  separated_by\n   {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C D\n\ngoal (1 subgoal):\n 1. C \\<sim> D", "qed (rule assms(3))"], ["", "lemma this_wall_betw_basechambers:\n  \"the_wall_betw C0 D0 = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> folding_g.\\<C>,\n                       g \\<turnstile> folding_g.\\<C>}}) \\<and>\n         separated_by H C0 D0) =\n    {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}", "using basechambers_half_chamber_systems chambers(2) this_wall_betwI"], ["proof (prove)\nusing this:\n  C0 \\<in> f \\<turnstile> folding_g.\\<C>\n  D0 \\<in> g \\<turnstile> folding_g.\\<C>\n  C0 \\<sim> D0\n  \\<lbrakk>?C \\<in> f \\<turnstile> folding_g.\\<C>;\n   ?D \\<in> g \\<turnstile> folding_g.\\<C>; ?C \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> THE_default {}\n                     (\\<lambda>H.\n                         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                     {{f \\<turnstile> folding_g.\\<C>,\n g \\<turnstile> folding_g.\\<C>}}) \\<and>\n                         separated_by H ?C ?D) =\n                    {f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}\n\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> folding_g.\\<C>,\n                       g \\<turnstile> folding_g.\\<C>}}) \\<and>\n         separated_by H C0 D0) =\n    {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}", "by auto"], ["", "lemma this_wall_in_crossingsI_fg:\n  defines H: \"H \\<equiv> {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\"\n  assumes D: \"D\\<in>g\\<turnstile>\\<C>\"\n  shows   \"C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> gallery (C#Cs@[D]) \\<Longrightarrow> H \\<in> set (wall_crossings (C#Cs@[D]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n     folding_g.gallery (C # Cs @ [D])\\<rbrakk>\n    \\<Longrightarrow> H \\<in> set (wall_crossings (C # Cs @ [D]))", "proof (induct Cs arbitrary: C)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n        folding_g.gallery (C # [] @ [D])\\<rbrakk>\n       \\<Longrightarrow> H \\<in> set (wall_crossings (C # [] @ [D]))\n 2. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n                    folding_g.gallery (C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> H \\<in> set\n        (wall_crossings (C # Cs @ [D]));\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        folding_g.gallery (C # (a # Cs) @ [D])\\<rbrakk>\n       \\<Longrightarrow> H \\<in> set (wall_crossings (C # (a # Cs) @ [D]))", "case Nil"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  folding_g.gallery (C # [] @ [D])\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n        folding_g.gallery (C # [] @ [D])\\<rbrakk>\n       \\<Longrightarrow> H \\<in> set (wall_crossings (C # [] @ [D]))\n 2. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n                    folding_g.gallery (C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> H \\<in> set\n        (wall_crossings (C # Cs @ [D]));\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        folding_g.gallery (C # (a # Cs) @ [D])\\<rbrakk>\n       \\<Longrightarrow> H \\<in> set (wall_crossings (C # (a # Cs) @ [D]))", "from Nil(1) assms"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  H \\<equiv> {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  D \\<in> g \\<turnstile> folding_g.\\<C>", "have \"H\\<in>walls\" \"separated_by H C D\""], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  H \\<equiv> {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  D \\<in> g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> folding_g.\\<C>,\n                  g \\<turnstile> folding_g.\\<C>}}) &&&\n    separated_by H C D", "using foldpair"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  H \\<equiv> {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  D \\<in> g \\<turnstile> folding_g.\\<C>\n  (f, g) \\<in> foldpairs\n\ngoal (1 subgoal):\n 1. H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> folding_g.\\<C>,\n                  g \\<turnstile> folding_g.\\<C>}}) &&&\n    separated_by H C D", "by (auto intro: separated_byI)"], ["proof (state)\nthis:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}})\n  separated_by H C D\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n        folding_g.gallery (C # [] @ [D])\\<rbrakk>\n       \\<Longrightarrow> H \\<in> set (wall_crossings (C # [] @ [D]))\n 2. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n                    folding_g.gallery (C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> H \\<in> set\n        (wall_crossings (C # Cs @ [D]));\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        folding_g.gallery (C # (a # Cs) @ [D])\\<rbrakk>\n       \\<Longrightarrow> H \\<in> set (wall_crossings (C # (a # Cs) @ [D]))", "thus ?case"], ["proof (prove)\nusing this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}})\n  separated_by H C D\n\ngoal (1 subgoal):\n 1. H \\<in> set (wall_crossings (C # [] @ [D]))", "using galleryD_adj[OF Nil(2)]\n          THE_default1_equality[OF adj_wall_imp_ex1_wall]"], ["proof (prove)\nusing this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}})\n  separated_by H C D\n  adjacentchain (C # [] @ [D])\n  \\<lbrakk>?C1 \\<sim> ?D1;\n   ?H0.1\n   \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n             {{f \\<turnstile> folding_g.\\<C>,\n               g \\<turnstile> folding_g.\\<C>}});\n   separated_by ?H0.1 ?C1 ?D1;\n   ?a \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> folding_g.\\<C>,\n                  g \\<turnstile> folding_g.\\<C>}}) \\<and>\n   separated_by ?a ?C1 ?D1\\<rbrakk>\n  \\<Longrightarrow> THE_default ?d\n                     (\\<lambda>H.\n                         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                     {{f \\<turnstile> folding_g.\\<C>,\n g \\<turnstile> folding_g.\\<C>}}) \\<and>\n                         separated_by H ?C1 ?D1) =\n                    ?a\n\ngoal (1 subgoal):\n 1. H \\<in> set (wall_crossings (C # [] @ [D]))", "by    auto"], ["proof (state)\nthis:\n  H \\<in> set (wall_crossings (C # [] @ [D]))\n\ngoal (1 subgoal):\n 1. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n                    folding_g.gallery (C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> H \\<in> set\n        (wall_crossings (C # Cs @ [D]));\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        folding_g.gallery (C # (a # Cs) @ [D])\\<rbrakk>\n       \\<Longrightarrow> H \\<in> set (wall_crossings (C # (a # Cs) @ [D]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n                    folding_g.gallery (C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> H \\<in> set\n        (wall_crossings (C # Cs @ [D]));\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        folding_g.gallery (C # (a # Cs) @ [D])\\<rbrakk>\n       \\<Longrightarrow> H \\<in> set (wall_crossings (C # (a # Cs) @ [D]))", "case (Cons B Bs)"], ["proof (state)\nthis:\n  \\<lbrakk>?C2 \\<in> f \\<turnstile> folding_g.\\<C>;\n   folding_g.gallery (?C2 # Bs @ [D])\\<rbrakk>\n  \\<Longrightarrow> H \\<in> set (wall_crossings (?C2 # Bs @ [D]))\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  folding_g.gallery (C # (B # Bs) @ [D])\n\ngoal (1 subgoal):\n 1. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>C \\<in> f \\<turnstile> folding_g.\\<C>;\n                    folding_g.gallery (C # Cs @ [D])\\<rbrakk>\n                   \\<Longrightarrow> H \\<in> set\n        (wall_crossings (C # Cs @ [D]));\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        folding_g.gallery (C # (a # Cs) @ [D])\\<rbrakk>\n       \\<Longrightarrow> H \\<in> set (wall_crossings (C # (a # Cs) @ [D]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))", "proof (cases \"B\\<in>f\\<turnstile>\\<C>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. B \\<in> f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n    H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))\n 2. B \\<notin> f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n    H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))", "case True"], ["proof (state)\nthis:\n  B \\<in> f \\<turnstile> folding_g.\\<C>\n\ngoal (2 subgoals):\n 1. B \\<in> f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n    H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))\n 2. B \\<notin> f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n    H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))", "with Cons(1,3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?C2 \\<in> f \\<turnstile> folding_g.\\<C>;\n   folding_g.gallery (?C2 # Bs @ [D])\\<rbrakk>\n  \\<Longrightarrow> H \\<in> set (wall_crossings (?C2 # Bs @ [D]))\n  folding_g.gallery (C # (B # Bs) @ [D])\n  B \\<in> f \\<turnstile> folding_g.\\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?C2 \\<in> f \\<turnstile> folding_g.\\<C>;\n   folding_g.gallery (?C2 # Bs @ [D])\\<rbrakk>\n  \\<Longrightarrow> H \\<in> set (wall_crossings (?C2 # Bs @ [D]))\n  folding_g.gallery (C # (B # Bs) @ [D])\n  B \\<in> f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))", "using gallery_Cons_reduce"], ["proof (prove)\nusing this:\n  \\<lbrakk>?C2 \\<in> f \\<turnstile> folding_g.\\<C>;\n   folding_g.gallery (?C2 # Bs @ [D])\\<rbrakk>\n  \\<Longrightarrow> H \\<in> set (wall_crossings (?C2 # Bs @ [D]))\n  folding_g.gallery (C # (B # Bs) @ [D])\n  B \\<in> f \\<turnstile> folding_g.\\<C>\n  folding_g.gallery (?x # ?xs) \\<Longrightarrow> folding_g.gallery ?xs\n\ngoal (1 subgoal):\n 1. H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))", "by simp"], ["proof (state)\nthis:\n  H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))\n\ngoal (1 subgoal):\n 1. B \\<notin> f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n    H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B \\<notin> f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n    H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))", "case False"], ["proof (state)\nthis:\n  B \\<notin> f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. B \\<notin> f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n    H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))", "with Cons(2,3) H"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  folding_g.gallery (C # (B # Bs) @ [D])\n  H \\<equiv> {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  B \\<notin> f \\<turnstile> folding_g.\\<C>", "have \"H\\<in>walls\" \"separated_by H C B\""], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  folding_g.gallery (C # (B # Bs) @ [D])\n  H \\<equiv> {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  B \\<notin> f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> folding_g.\\<C>,\n                  g \\<turnstile> folding_g.\\<C>}}) &&&\n    separated_by H C B", "using galleryD_chamber[OF Cons(3)] chamber_in_other_half_fg[of B] foldpair"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  folding_g.gallery (C # (B # Bs) @ [D])\n  H \\<equiv> {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  B \\<notin> f \\<turnstile> folding_g.\\<C>\n  ?x \\<in> set (C # (B # Bs) @ [D]) \\<Longrightarrow> folding_g.chamber ?x\n  \\<lbrakk>folding_g.chamber B;\n   B \\<notin> f \\<turnstile> folding_g.\\<C>\\<rbrakk>\n  \\<Longrightarrow> B \\<in> g \\<turnstile> folding_g.\\<C>\n  (f, g) \\<in> foldpairs\n\ngoal (1 subgoal):\n 1. H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> folding_g.\\<C>,\n                  g \\<turnstile> folding_g.\\<C>}}) &&&\n    separated_by H C B", "by    (auto intro: separated_byI)"], ["proof (state)\nthis:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}})\n  separated_by H C B\n\ngoal (1 subgoal):\n 1. B \\<notin> f \\<turnstile> folding_g.\\<C> \\<Longrightarrow>\n    H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}})\n  separated_by H C B\n\ngoal (1 subgoal):\n 1. H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))", "using galleryD_adj[OF Cons(3)]\n            THE_default1_equality[OF adj_wall_imp_ex1_wall]"], ["proof (prove)\nusing this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}})\n  separated_by H C B\n  adjacentchain (C # (B # Bs) @ [D])\n  \\<lbrakk>?C1 \\<sim> ?D1;\n   ?H0.1\n   \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n             {{f \\<turnstile> folding_g.\\<C>,\n               g \\<turnstile> folding_g.\\<C>}});\n   separated_by ?H0.1 ?C1 ?D1;\n   ?a \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> folding_g.\\<C>,\n                  g \\<turnstile> folding_g.\\<C>}}) \\<and>\n   separated_by ?a ?C1 ?D1\\<rbrakk>\n  \\<Longrightarrow> THE_default ?d\n                     (\\<lambda>H.\n                         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                     {{f \\<turnstile> folding_g.\\<C>,\n g \\<turnstile> folding_g.\\<C>}}) \\<and>\n                         separated_by H ?C1 ?D1) =\n                    ?a\n\ngoal (1 subgoal):\n 1. H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))", "by    auto"], ["proof (state)\nthis:\n  H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H \\<in> set (wall_crossings (C # (B # Bs) @ [D]))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context OpposedThinChamberComplexFoldings *)"], ["", "lemma (in ThinChamberComplex) walls_betw_subset_wall_crossings:\n  assumes \"gallery (C#Cs@[D])\"\n  shows   \"walls_betw C D \\<subseteq> set (wall_crossings (C#Cs@[D]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (set (wall_crossings (C # Cs @ [D]))) (walls_betw C D)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> walls_betw C D \\<Longrightarrow>\n       x \\<in> set (wall_crossings (C # Cs @ [D]))", "fix H"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> walls_betw C D \\<Longrightarrow>\n       x \\<in> set (wall_crossings (C # Cs @ [D]))", "assume \"H \\<in> walls_betw C D\""], ["proof (state)\nthis:\n  H \\<in> walls_betw C D\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> walls_betw C D \\<Longrightarrow>\n       x \\<in> set (wall_crossings (C # Cs @ [D]))", "hence H: \"H\\<in>walls\" \"separated_by H C D\""], ["proof (prove)\nusing this:\n  H \\<in> walls_betw C D\n\ngoal (1 subgoal):\n 1. H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) &&&\n    separated_by H C D", "using walls_betw_def"], ["proof (prove)\nusing this:\n  H \\<in> walls_betw C D\n  walls_betw ?C ?D \\<equiv>\n  {H \\<in> \\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}.\n   separated_by H ?C ?D}\n\ngoal (1 subgoal):\n 1. H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) &&&\n    separated_by H C D", "by auto"], ["proof (state)\nthis:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  separated_by H C D\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> walls_betw C D \\<Longrightarrow>\n       x \\<in> set (wall_crossings (C # Cs @ [D]))", "from this"], ["proof (chain)\npicking this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  separated_by H C D", "obtain f g\n    where fg: \"(f,g)\\<in>foldpairs\" \"H = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\" \"C\\<in>f\\<turnstile>\\<C>\" \"D\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  separated_by H C D\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>};\n         C \\<in> f \\<turnstile> \\<C>; D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using separated_by_wall_ex_foldpair[of H C D]"], ["proof (prove)\nusing this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  separated_by H C D\n  \\<lbrakk>H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                       {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}});\n   separated_by H C D\\<rbrakk>\n  \\<Longrightarrow> \\<exists>(f, g)\\<in>foldpairs.\n                       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n                       C \\<in> f \\<turnstile> \\<C> \\<and>\n                       D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>};\n         C \\<in> f \\<turnstile> \\<C>; D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> walls_betw C D \\<Longrightarrow>\n       x \\<in> set (wall_crossings (C # Cs @ [D]))", "from fg(1)"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs", "obtain Z where Z: \"OpposedThinChamberComplexFoldings X f g Z\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        OpposedThinChamberComplexFoldings X f g Z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using foldpairs_def"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        OpposedThinChamberComplexFoldings X f g Z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g Z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> walls_betw C D \\<Longrightarrow>\n       x \\<in> set (wall_crossings (C # Cs @ [D]))", "from assms H(2) fg(2-4)"], ["proof (chain)\npicking this:\n  gallery (C # Cs @ [D])\n  separated_by H C D\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>", "show \"H \\<in> set (wall_crossings (C#Cs@[D]))\""], ["proof (prove)\nusing this:\n  gallery (C # Cs @ [D])\n  separated_by H C D\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. H \\<in> set (wall_crossings (C # Cs @ [D]))", "using OpposedThinChamberComplexFoldings.this_wall_in_crossingsI_fg[OF Z]"], ["proof (prove)\nusing this:\n  gallery (C # Cs @ [D])\n  separated_by H C D\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n  \\<lbrakk>?D \\<in> g \\<turnstile> \\<C>; ?C \\<in> f \\<turnstile> \\<C>;\n   gallery (?C # ?Cs @ [?D])\\<rbrakk>\n  \\<Longrightarrow> {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n                    \\<in> set (wall_crossings (?C # ?Cs @ [?D]))\n\ngoal (1 subgoal):\n 1. H \\<in> set (wall_crossings (C # Cs @ [D]))", "by    auto"], ["proof (state)\nthis:\n  H \\<in> set (wall_crossings (C # Cs @ [D]))\n\ngoal:\nNo subgoals!", "qed"], ["", "context OpposedThinChamberComplexFoldings\nbegin"], ["", "lemma same_side_this_wall_wall_crossings_not_distinct_f:\n  \"gallery (C#Cs@[D]) \\<Longrightarrow> C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow> D\\<in>f\\<turnstile>\\<C> \\<Longrightarrow>\n    {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\\<in>set (wall_crossings (C#Cs@[D])) \\<Longrightarrow>\n    \\<not> distinct (wall_crossings (C#Cs@[D]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>folding_g.gallery (C # Cs @ [D]);\n     C \\<in> f \\<turnstile> folding_g.\\<C>;\n     D \\<in> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<in> set (wall_crossings (C # Cs @ [D]))\\<rbrakk>\n    \\<Longrightarrow> \\<not> distinct (wall_crossings (C # Cs @ [D]))", "proof (induct Cs arbitrary: C)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>folding_g.gallery (C # [] @ [D]);\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        D \\<in> f \\<turnstile> folding_g.\\<C>;\n        {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n        \\<in> set (wall_crossings (C # [] @ [D]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> distinct (wall_crossings (C # [] @ [D]))\n 2. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>folding_g.gallery (C # Cs @ [D]);\n                    C \\<in> f \\<turnstile> folding_g.\\<C>;\n                    D \\<in> f \\<turnstile> folding_g.\\<C>;\n                    {f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}\n                    \\<in> set (wall_crossings (C # Cs @ [D]))\\<rbrakk>\n                   \\<Longrightarrow> \\<not> distinct\n       (wall_crossings (C # Cs @ [D]));\n        folding_g.gallery (C # (a # Cs) @ [D]);\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        D \\<in> f \\<turnstile> folding_g.\\<C>;\n        {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n        \\<in> set (wall_crossings (C # (a # Cs) @ [D]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> distinct\n                                 (wall_crossings (C # (a # Cs) @ [D]))", "case Nil"], ["proof (state)\nthis:\n  folding_g.gallery (C # [] @ [D])\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  D \\<in> f \\<turnstile> folding_g.\\<C>\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> set (wall_crossings (C # [] @ [D]))\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>folding_g.gallery (C # [] @ [D]);\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        D \\<in> f \\<turnstile> folding_g.\\<C>;\n        {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n        \\<in> set (wall_crossings (C # [] @ [D]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> distinct (wall_crossings (C # [] @ [D]))\n 2. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>folding_g.gallery (C # Cs @ [D]);\n                    C \\<in> f \\<turnstile> folding_g.\\<C>;\n                    D \\<in> f \\<turnstile> folding_g.\\<C>;\n                    {f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}\n                    \\<in> set (wall_crossings (C # Cs @ [D]))\\<rbrakk>\n                   \\<Longrightarrow> \\<not> distinct\n       (wall_crossings (C # Cs @ [D]));\n        folding_g.gallery (C # (a # Cs) @ [D]);\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        D \\<in> f \\<turnstile> folding_g.\\<C>;\n        {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n        \\<in> set (wall_crossings (C # (a # Cs) @ [D]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> distinct\n                                 (wall_crossings (C # (a # Cs) @ [D]))", "hence \"{f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} = the_wall_betw C D\""], ["proof (prove)\nusing this:\n  folding_g.gallery (C # [] @ [D])\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  D \\<in> f \\<turnstile> folding_g.\\<C>\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> set (wall_crossings (C # [] @ [D]))\n\ngoal (1 subgoal):\n 1. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n    THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> folding_g.\\<C>,\n                       g \\<turnstile> folding_g.\\<C>}}) \\<and>\n         separated_by H C D)", "by simp"], ["proof (state)\nthis:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C D)\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>folding_g.gallery (C # [] @ [D]);\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        D \\<in> f \\<turnstile> folding_g.\\<C>;\n        {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n        \\<in> set (wall_crossings (C # [] @ [D]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> distinct (wall_crossings (C # [] @ [D]))\n 2. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>folding_g.gallery (C # Cs @ [D]);\n                    C \\<in> f \\<turnstile> folding_g.\\<C>;\n                    D \\<in> f \\<turnstile> folding_g.\\<C>;\n                    {f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}\n                    \\<in> set (wall_crossings (C # Cs @ [D]))\\<rbrakk>\n                   \\<Longrightarrow> \\<not> distinct\n       (wall_crossings (C # Cs @ [D]));\n        folding_g.gallery (C # (a # Cs) @ [D]);\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        D \\<in> f \\<turnstile> folding_g.\\<C>;\n        {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n        \\<in> set (wall_crossings (C # (a # Cs) @ [D]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> distinct\n                                 (wall_crossings (C # (a # Cs) @ [D]))", "moreover"], ["proof (state)\nthis:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C D)\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>folding_g.gallery (C # [] @ [D]);\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        D \\<in> f \\<turnstile> folding_g.\\<C>;\n        {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n        \\<in> set (wall_crossings (C # [] @ [D]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> distinct (wall_crossings (C # [] @ [D]))\n 2. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>folding_g.gallery (C # Cs @ [D]);\n                    C \\<in> f \\<turnstile> folding_g.\\<C>;\n                    D \\<in> f \\<turnstile> folding_g.\\<C>;\n                    {f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}\n                    \\<in> set (wall_crossings (C # Cs @ [D]))\\<rbrakk>\n                   \\<Longrightarrow> \\<not> distinct\n       (wall_crossings (C # Cs @ [D]));\n        folding_g.gallery (C # (a # Cs) @ [D]);\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        D \\<in> f \\<turnstile> folding_g.\\<C>;\n        {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n        \\<in> set (wall_crossings (C # (a # Cs) @ [D]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> distinct\n                                 (wall_crossings (C # (a # Cs) @ [D]))", "hence \"the_wall_betw C D \\<noteq> {}\""], ["proof (prove)\nusing this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C D)\n\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> folding_g.\\<C>,\n                       g \\<turnstile> folding_g.\\<C>}}) \\<and>\n         separated_by H C D) \\<noteq>\n    {}", "by fast"], ["proof (state)\nthis:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C D) \\<noteq>\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>folding_g.gallery (C # [] @ [D]);\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        D \\<in> f \\<turnstile> folding_g.\\<C>;\n        {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n        \\<in> set (wall_crossings (C # [] @ [D]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> distinct (wall_crossings (C # [] @ [D]))\n 2. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>folding_g.gallery (C # Cs @ [D]);\n                    C \\<in> f \\<turnstile> folding_g.\\<C>;\n                    D \\<in> f \\<turnstile> folding_g.\\<C>;\n                    {f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}\n                    \\<in> set (wall_crossings (C # Cs @ [D]))\\<rbrakk>\n                   \\<Longrightarrow> \\<not> distinct\n       (wall_crossings (C # Cs @ [D]));\n        folding_g.gallery (C # (a # Cs) @ [D]);\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        D \\<in> f \\<turnstile> folding_g.\\<C>;\n        {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n        \\<in> set (wall_crossings (C # (a # Cs) @ [D]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> distinct\n                                 (wall_crossings (C # (a # Cs) @ [D]))", "ultimately"], ["proof (chain)\npicking this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C D)\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C D) \\<noteq>\n  {}", "show ?case"], ["proof (prove)\nusing this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C D)\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C D) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings (C # [] @ [D]))", "using Nil(2,3) the_wall_betw_nempty(2) separated_by_this_wall_fg[of C D]\n          half_chamber_system_disjoint_union(2)"], ["proof (prove)\nusing this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C D)\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C D) \\<noteq>\n  {}\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  D \\<in> f \\<turnstile> folding_g.\\<C>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H ?C ?D) \\<noteq>\n  {} \\<Longrightarrow>\n  separated_by\n   (THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> folding_g.\\<C>,\n                       g \\<turnstile> folding_g.\\<C>}}) \\<and>\n         separated_by H ?C ?D))\n   ?C ?D\n  \\<lbrakk>separated_by\n            {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C\n            D;\n   C \\<in> f \\<turnstile> folding_g.\\<C>\\<rbrakk>\n  \\<Longrightarrow> D \\<in> g \\<turnstile> folding_g.\\<C>\n  f \\<turnstile> folding_g.\\<C> \\<inter> (g \\<turnstile> folding_g.\\<C>) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings (C # [] @ [D]))", "by    auto"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings (C # [] @ [D]))\n\ngoal (1 subgoal):\n 1. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>folding_g.gallery (C # Cs @ [D]);\n                    C \\<in> f \\<turnstile> folding_g.\\<C>;\n                    D \\<in> f \\<turnstile> folding_g.\\<C>;\n                    {f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}\n                    \\<in> set (wall_crossings (C # Cs @ [D]))\\<rbrakk>\n                   \\<Longrightarrow> \\<not> distinct\n       (wall_crossings (C # Cs @ [D]));\n        folding_g.gallery (C # (a # Cs) @ [D]);\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        D \\<in> f \\<turnstile> folding_g.\\<C>;\n        {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n        \\<in> set (wall_crossings (C # (a # Cs) @ [D]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> distinct\n                                 (wall_crossings (C # (a # Cs) @ [D]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>folding_g.gallery (C # Cs @ [D]);\n                    C \\<in> f \\<turnstile> folding_g.\\<C>;\n                    D \\<in> f \\<turnstile> folding_g.\\<C>;\n                    {f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}\n                    \\<in> set (wall_crossings (C # Cs @ [D]))\\<rbrakk>\n                   \\<Longrightarrow> \\<not> distinct\n       (wall_crossings (C # Cs @ [D]));\n        folding_g.gallery (C # (a # Cs) @ [D]);\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        D \\<in> f \\<turnstile> folding_g.\\<C>;\n        {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n        \\<in> set (wall_crossings (C # (a # Cs) @ [D]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> distinct\n                                 (wall_crossings (C # (a # Cs) @ [D]))", "case (Cons E Es)"], ["proof (state)\nthis:\n  \\<lbrakk>folding_g.gallery (?C2 # Es @ [D]);\n   ?C2 \\<in> f \\<turnstile> folding_g.\\<C>;\n   D \\<in> f \\<turnstile> folding_g.\\<C>;\n   {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n   \\<in> set (wall_crossings (?C2 # Es @ [D]))\\<rbrakk>\n  \\<Longrightarrow> \\<not> distinct (wall_crossings (?C2 # Es @ [D]))\n  folding_g.gallery (C # (E # Es) @ [D])\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  D \\<in> f \\<turnstile> folding_g.\\<C>\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> set (wall_crossings (C # (E # Es) @ [D]))\n\ngoal (1 subgoal):\n 1. \\<And>a Cs C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>folding_g.gallery (C # Cs @ [D]);\n                    C \\<in> f \\<turnstile> folding_g.\\<C>;\n                    D \\<in> f \\<turnstile> folding_g.\\<C>;\n                    {f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}\n                    \\<in> set (wall_crossings (C # Cs @ [D]))\\<rbrakk>\n                   \\<Longrightarrow> \\<not> distinct\n       (wall_crossings (C # Cs @ [D]));\n        folding_g.gallery (C # (a # Cs) @ [D]);\n        C \\<in> f \\<turnstile> folding_g.\\<C>;\n        D \\<in> f \\<turnstile> folding_g.\\<C>;\n        {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n        \\<in> set (wall_crossings (C # (a # Cs) @ [D]))\\<rbrakk>\n       \\<Longrightarrow> \\<not> distinct\n                                 (wall_crossings (C # (a # Cs) @ [D]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings (C # (E # Es) @ [D]))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (wall_crossings (C # (E # Es) @ [D])) \\<Longrightarrow> False", "assume 1: \"distinct (wall_crossings (C # (E # Es) @ [D]))\""], ["proof (state)\nthis:\n  distinct (wall_crossings (C # (E # Es) @ [D]))\n\ngoal (1 subgoal):\n 1. distinct (wall_crossings (C # (E # Es) @ [D])) \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (\n      cases \"E\\<in>f\\<turnstile>\\<C>\" \"{f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} \\<in> set (wall_crossings (E#Es@[D]))\"\n      rule: two_cases\n    )"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>E \\<in> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<in> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>E \\<in> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<in> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "case both"], ["proof (state)\nthis:\n  E \\<in> f \\<turnstile> folding_g.\\<C>\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> set (wall_crossings (E # Es @ [D]))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>E \\<in> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<in> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>E \\<in> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<in> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "with Cons(1,2,4) 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>folding_g.gallery (?C2 # Es @ [D]);\n   ?C2 \\<in> f \\<turnstile> folding_g.\\<C>;\n   D \\<in> f \\<turnstile> folding_g.\\<C>;\n   {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n   \\<in> set (wall_crossings (?C2 # Es @ [D]))\\<rbrakk>\n  \\<Longrightarrow> \\<not> distinct (wall_crossings (?C2 # Es @ [D]))\n  folding_g.gallery (C # (E # Es) @ [D])\n  D \\<in> f \\<turnstile> folding_g.\\<C>\n  distinct (wall_crossings (C # (E # Es) @ [D]))\n  E \\<in> f \\<turnstile> folding_g.\\<C>\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> set (wall_crossings (E # Es @ [D]))", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>folding_g.gallery (?C2 # Es @ [D]);\n   ?C2 \\<in> f \\<turnstile> folding_g.\\<C>;\n   D \\<in> f \\<turnstile> folding_g.\\<C>;\n   {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n   \\<in> set (wall_crossings (?C2 # Es @ [D]))\\<rbrakk>\n  \\<Longrightarrow> \\<not> distinct (wall_crossings (?C2 # Es @ [D]))\n  folding_g.gallery (C # (E # Es) @ [D])\n  D \\<in> f \\<turnstile> folding_g.\\<C>\n  distinct (wall_crossings (C # (E # Es) @ [D]))\n  E \\<in> f \\<turnstile> folding_g.\\<C>\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> set (wall_crossings (E # Es @ [D]))\n\ngoal (1 subgoal):\n 1. False", "using gallery_Cons_reduce"], ["proof (prove)\nusing this:\n  \\<lbrakk>folding_g.gallery (?C2 # Es @ [D]);\n   ?C2 \\<in> f \\<turnstile> folding_g.\\<C>;\n   D \\<in> f \\<turnstile> folding_g.\\<C>;\n   {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n   \\<in> set (wall_crossings (?C2 # Es @ [D]))\\<rbrakk>\n  \\<Longrightarrow> \\<not> distinct (wall_crossings (?C2 # Es @ [D]))\n  folding_g.gallery (C # (E # Es) @ [D])\n  D \\<in> f \\<turnstile> folding_g.\\<C>\n  distinct (wall_crossings (C # (E # Es) @ [D]))\n  E \\<in> f \\<turnstile> folding_g.\\<C>\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> set (wall_crossings (E # Es @ [D]))\n  folding_g.gallery (?x # ?xs) \\<Longrightarrow> folding_g.gallery ?xs\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>E \\<in> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<in> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>E \\<in> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<in> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "case one"], ["proof (state)\nthis:\n  E \\<in> f \\<turnstile> folding_g.\\<C>\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<notin> set (wall_crossings (E # Es @ [D]))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>E \\<in> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<in> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "from one(2) Cons(5)"], ["proof (chain)\npicking this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<notin> set (wall_crossings (E # Es @ [D]))\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> set (wall_crossings (C # (E # Es) @ [D]))", "have \"{f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} = the_wall_betw C E\""], ["proof (prove)\nusing this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<notin> set (wall_crossings (E # Es @ [D]))\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> set (wall_crossings (C # (E # Es) @ [D]))\n\ngoal (1 subgoal):\n 1. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n    THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> folding_g.\\<C>,\n                       g \\<turnstile> folding_g.\\<C>}}) \\<and>\n         separated_by H C E)", "by simp"], ["proof (state)\nthis:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C E)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>E \\<in> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<in> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C E)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>E \\<in> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<in> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"the_wall_betw C E \\<noteq> {}\""], ["proof (prove)\nusing this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C E)\n\ngoal (1 subgoal):\n 1. THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> folding_g.\\<C>,\n                       g \\<turnstile> folding_g.\\<C>}}) \\<and>\n         separated_by H C E) \\<noteq>\n    {}", "by fast"], ["proof (state)\nthis:\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C E) \\<noteq>\n  {}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>E \\<in> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<in> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C E)\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C E) \\<noteq>\n  {}", "show False"], ["proof (prove)\nusing this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C E)\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C E) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. False", "using Cons(3) one(1) the_wall_betw_nempty(2)\n              separated_by_this_wall_fg[of C E]\n              half_chamber_system_disjoint_union(2)"], ["proof (prove)\nusing this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C E)\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H C E) \\<noteq>\n  {}\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  E \\<in> f \\<turnstile> folding_g.\\<C>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}}) \\<and>\n       separated_by H ?C ?D) \\<noteq>\n  {} \\<Longrightarrow>\n  separated_by\n   (THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> folding_g.\\<C>,\n                       g \\<turnstile> folding_g.\\<C>}}) \\<and>\n         separated_by H ?C ?D))\n   ?C ?D\n  \\<lbrakk>separated_by\n            {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C\n            E;\n   C \\<in> f \\<turnstile> folding_g.\\<C>\\<rbrakk>\n  \\<Longrightarrow> E \\<in> g \\<turnstile> folding_g.\\<C>\n  f \\<turnstile> folding_g.\\<C> \\<inter> (g \\<turnstile> folding_g.\\<C>) =\n  {}\n\ngoal (1 subgoal):\n 1. False", "by    auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<in> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<in> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "case other"], ["proof (state)\nthis:\n  E \\<notin> f \\<turnstile> folding_g.\\<C>\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> set (wall_crossings (E # Es @ [D]))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<in> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "with Cons(3)"], ["proof (chain)\npicking this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  E \\<notin> f \\<turnstile> folding_g.\\<C>\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> set (wall_crossings (E # Es @ [D]))", "show False"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  E \\<notin> f \\<turnstile> folding_g.\\<C>\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> set (wall_crossings (E # Es @ [D]))\n\ngoal (1 subgoal):\n 1. False", "using 1 galleryD_chamber[OF Cons(2)] galleryD_adj[OF Cons(2)] \n              chamber_in_other_half_fg this_wall_betwI"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> folding_g.\\<C>\n  E \\<notin> f \\<turnstile> folding_g.\\<C>\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> set (wall_crossings (E # Es @ [D]))\n  distinct (wall_crossings (C # (E # Es) @ [D]))\n  ?x \\<in> set (C # (E # Es) @ [D]) \\<Longrightarrow> folding_g.chamber ?x\n  adjacentchain (C # (E # Es) @ [D])\n  \\<lbrakk>folding_g.chamber ?C;\n   ?C \\<notin> f \\<turnstile> folding_g.\\<C>\\<rbrakk>\n  \\<Longrightarrow> ?C \\<in> g \\<turnstile> folding_g.\\<C>\n  \\<lbrakk>?C \\<in> f \\<turnstile> folding_g.\\<C>;\n   ?D \\<in> g \\<turnstile> folding_g.\\<C>; ?C \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> THE_default {}\n                     (\\<lambda>H.\n                         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                     {{f \\<turnstile> folding_g.\\<C>,\n g \\<turnstile> folding_g.\\<C>}}) \\<and>\n                         separated_by H ?C ?D) =\n                    {f \\<turnstile> folding_g.\\<C>,\n                     g \\<turnstile> folding_g.\\<C>}\n\ngoal (1 subgoal):\n 1. False", "by    force"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "case neither"], ["proof (state)\nthis:\n  E \\<notin> f \\<turnstile> folding_g.\\<C>\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<notin> set (wall_crossings (E # Es @ [D]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "from Cons(2) neither(1)"], ["proof (chain)\npicking this:\n  folding_g.gallery (C # (E # Es) @ [D])\n  E \\<notin> f \\<turnstile> folding_g.\\<C>", "have \"E\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  folding_g.gallery (C # (E # Es) @ [D])\n  E \\<notin> f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. E \\<in> g \\<turnstile> folding_g.\\<C>", "using galleryD_chamber chamber_in_other_half_fg"], ["proof (prove)\nusing this:\n  folding_g.gallery (C # (E # Es) @ [D])\n  E \\<notin> f \\<turnstile> folding_g.\\<C>\n  \\<lbrakk>folding_g.gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> folding_g.chamber ?x\n  \\<lbrakk>folding_g.chamber ?C;\n   ?C \\<notin> f \\<turnstile> folding_g.\\<C>\\<rbrakk>\n  \\<Longrightarrow> ?C \\<in> g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. E \\<in> g \\<turnstile> folding_g.\\<C>", "by auto"], ["proof (state)\nthis:\n  E \\<in> g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "with Cons(4)"], ["proof (chain)\npicking this:\n  D \\<in> f \\<turnstile> folding_g.\\<C>\n  E \\<in> g \\<turnstile> folding_g.\\<C>", "have \"separated_by {g\\<turnstile>\\<C>,f\\<turnstile>\\<C>} E D\""], ["proof (prove)\nusing this:\n  D \\<in> f \\<turnstile> folding_g.\\<C>\n  E \\<in> g \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. separated_by\n     {g \\<turnstile> folding_g.\\<C>, f \\<turnstile> folding_g.\\<C>} E D", "by (blast intro: separated_byI)"], ["proof (state)\nthis:\n  separated_by\n   {g \\<turnstile> folding_g.\\<C>, f \\<turnstile> folding_g.\\<C>} E D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"{f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} \\<in> walls_betw E D\""], ["proof (prove)\nusing this:\n  separated_by\n   {g \\<turnstile> folding_g.\\<C>, f \\<turnstile> folding_g.\\<C>} E D\n\ngoal (1 subgoal):\n 1. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n    \\<in> walls_betw E D", "using foldpair walls_betw_def"], ["proof (prove)\nusing this:\n  separated_by\n   {g \\<turnstile> folding_g.\\<C>, f \\<turnstile> folding_g.\\<C>} E D\n  (f, g) \\<in> foldpairs\n  walls_betw ?C ?D \\<equiv>\n  {H \\<in> \\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> folding_g.\\<C>,\n                g \\<turnstile> folding_g.\\<C>}}.\n   separated_by H ?C ?D}\n\ngoal (1 subgoal):\n 1. {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n    \\<in> walls_betw E D", "by (auto simp add: insert_commute)"], ["proof (state)\nthis:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> walls_betw E D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>E \\<notin> f \\<turnstile> folding_g.\\<C>;\n     {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n     \\<notin> set (wall_crossings (E # Es @ [D]))\\<rbrakk>\n    \\<Longrightarrow> False", "with neither(2)"], ["proof (chain)\npicking this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<notin> set (wall_crossings (E # Es @ [D]))\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> walls_betw E D", "show False"], ["proof (prove)\nusing this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<notin> set (wall_crossings (E # Es @ [D]))\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> walls_betw E D\n\ngoal (1 subgoal):\n 1. False", "using gallery_Cons_reduce[OF Cons(2)] walls_betw_subset_wall_crossings"], ["proof (prove)\nusing this:\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<notin> set (wall_crossings (E # Es @ [D]))\n  {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n  \\<in> walls_betw E D\n  folding_g.gallery ((E # Es) @ [D])\n  folding_g.gallery (?C # ?Cs @ [?D]) \\<Longrightarrow>\n  order.greater_eq (set (wall_crossings (?C # ?Cs @ [?D])))\n   (walls_betw ?C ?D)\n\ngoal (1 subgoal):\n 1. False", "by    auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings (C # (E # Es) @ [D]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas sside_wcrossings_ndistinct_f =\n  same_side_this_wall_wall_crossings_not_distinct_f"], ["", "lemma separated_by_this_wall_chain3_fg:\n  assumes \"B\\<in>f\\<turnstile>\\<C>\" \"chamber C\" \"chamber D\"\n          \"separated_by {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} B C\" \"separated_by {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>} C D\"\n  shows   \"C\\<in>g\\<turnstile>\\<C>\" \"D\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> g \\<turnstile> folding_g.\\<C> &&&\n    D \\<in> f \\<turnstile> folding_g.\\<C>", "using   assms separated_by_this_wall_fg separated_by_this_wall_gf"], ["proof (prove)\nusing this:\n  B \\<in> f \\<turnstile> folding_g.\\<C>\n  folding_g.chamber C\n  folding_g.chamber D\n  separated_by\n   {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} B C\n  separated_by\n   {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>} C D\n  \\<lbrakk>separated_by\n            {f \\<turnstile> folding_g.\\<C>, g \\<turnstile> folding_g.\\<C>}\n            ?C ?D;\n   ?C \\<in> f \\<turnstile> folding_g.\\<C>\\<rbrakk>\n  \\<Longrightarrow> ?D \\<in> g \\<turnstile> folding_g.\\<C>\n  \\<lbrakk>separated_by\n            {g \\<turnstile> folding_g.\\<C>, f \\<turnstile> folding_g.\\<C>}\n            ?C ?D;\n   ?C \\<in> g \\<turnstile> folding_g.\\<C>\\<rbrakk>\n  \\<Longrightarrow> ?D \\<in> f \\<turnstile> folding_g.\\<C>\n\ngoal (1 subgoal):\n 1. C \\<in> g \\<turnstile> folding_g.\\<C> &&&\n    D \\<in> f \\<turnstile> folding_g.\\<C>", "by      (auto simp add: insert_commute)"], ["", "lemmas sepwall_chain3_fg =\n  separated_by_this_wall_chain3_fg"], ["", "end"], ["", "(* context OpposedThinChamberComplexFoldings *)"], ["", "context ThinChamberComplex\nbegin"], ["", "lemma wall_crossings_min_gallery_betwI:\n  assumes \"gallery (C#Cs@[D])\"\n          \"distinct (wall_crossings (C#Cs@[D]))\"\n          \"\\<forall>H\\<in>set (wall_crossings (C#Cs@[D])). separated_by H C D\"\n  shows   \"min_gallery (C#Cs@[D])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_gallery (C # Cs @ [D])", "proof (rule min_galleryI_betw)"], ["proof (state)\ngoal (3 subgoals):\n 1. C \\<noteq> D\n 2. gallery (C # Cs @ [D])\n 3. \\<And>ys.\n       gallery (C # ys @ [D]) \\<Longrightarrow>\n       order.greater_eq (length ys) (length Cs)", "obtain B Bs where BBs: \"Cs@[D] = B#Bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B Bs.\n        Cs @ [D] = B # Bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using snoc_conv_cons"], ["proof (prove)\nusing this:\n  \\<exists>x xs. ?ys @ [?y] = x # xs\n\ngoal (1 subgoal):\n 1. (\\<And>B Bs.\n        Cs @ [D] = B # Bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  Cs @ [D] = B # Bs\n\ngoal (3 subgoals):\n 1. C \\<noteq> D\n 2. gallery (C # Cs @ [D])\n 3. \\<And>ys.\n       gallery (C # ys @ [D]) \\<Longrightarrow>\n       order.greater_eq (length ys) (length Cs)", "define H where \"H = the_wall_betw C B\""], ["proof (state)\nthis:\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C B)\n\ngoal (3 subgoals):\n 1. C \\<noteq> D\n 2. gallery (C # Cs @ [D])\n 3. \\<And>ys.\n       gallery (C # ys @ [D]) \\<Longrightarrow>\n       order.greater_eq (length ys) (length Cs)", "with BBs assms(3)"], ["proof (chain)\npicking this:\n  Cs @ [D] = B # Bs\n  \\<forall>H\\<in>set (wall_crossings (C # Cs @ [D])). separated_by H C D\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C B)", "have 1: \"separated_by H C D\""], ["proof (prove)\nusing this:\n  Cs @ [D] = B # Bs\n  \\<forall>H\\<in>set (wall_crossings (C # Cs @ [D])). separated_by H C D\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C B)\n\ngoal (1 subgoal):\n 1. separated_by H C D", "by simp"], ["proof (state)\nthis:\n  separated_by H C D\n\ngoal (3 subgoals):\n 1. C \\<noteq> D\n 2. gallery (C # Cs @ [D])\n 3. \\<And>ys.\n       gallery (C # ys @ [D]) \\<Longrightarrow>\n       order.greater_eq (length ys) (length Cs)", "show \"C\\<noteq>D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<noteq> D", "proof (cases \"H={}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. H = {} \\<Longrightarrow> C \\<noteq> D\n 2. H \\<noteq> {} \\<Longrightarrow> C \\<noteq> D", "case True"], ["proof (state)\nthis:\n  H = {}\n\ngoal (2 subgoals):\n 1. H = {} \\<Longrightarrow> C \\<noteq> D\n 2. H \\<noteq> {} \\<Longrightarrow> C \\<noteq> D", "thus ?thesis"], ["proof (prove)\nusing this:\n  H = {}\n\ngoal (1 subgoal):\n 1. C \\<noteq> D", "using 1"], ["proof (prove)\nusing this:\n  H = {}\n  separated_by H C D\n\ngoal (1 subgoal):\n 1. C \\<noteq> D", "unfolding separated_by_def"], ["proof (prove)\nusing this:\n  H = {}\n  \\<exists>A B. H = {A, B} \\<and> C \\<in> A \\<and> D \\<in> B\n\ngoal (1 subgoal):\n 1. C \\<noteq> D", "by simp"], ["proof (state)\nthis:\n  C \\<noteq> D\n\ngoal (1 subgoal):\n 1. H \\<noteq> {} \\<Longrightarrow> C \\<noteq> D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<noteq> {} \\<Longrightarrow> C \\<noteq> D", "case False"], ["proof (state)\nthis:\n  H \\<noteq> {}\n\ngoal (1 subgoal):\n 1. H \\<noteq> {} \\<Longrightarrow> C \\<noteq> D", "with H_def"], ["proof (chain)\npicking this:\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C B)\n  H \\<noteq> {}", "have \"H \\<in> walls\""], ["proof (prove)\nusing this:\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C B)\n  H \\<noteq> {}\n\ngoal (1 subgoal):\n 1. H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})", "using the_wall_betw_nempty(1)"], ["proof (prove)\nusing this:\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C B)\n  H \\<noteq> {}\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H ?C ?D) \\<noteq>\n  {} \\<Longrightarrow>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H ?C ?D)\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n\ngoal (1 subgoal):\n 1. H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})", "by simp"], ["proof (state)\nthis:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n\ngoal (1 subgoal):\n 1. H \\<noteq> {} \\<Longrightarrow> C \\<noteq> D", "from this"], ["proof (chain)\npicking this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})", "obtain f g\n      where fg: \"(f,g)\\<in>foldpairs\" \"H = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\" \"C\\<in>f\\<turnstile>\\<C>\" \"D\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>};\n         C \\<in> f \\<turnstile> \\<C>; D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1 separated_by_wall_ex_foldpair[of H C D]"], ["proof (prove)\nusing this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  separated_by H C D\n  \\<lbrakk>H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                       {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}});\n   separated_by H C D\\<rbrakk>\n  \\<Longrightarrow> \\<exists>(f, g)\\<in>foldpairs.\n                       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n                       C \\<in> f \\<turnstile> \\<C> \\<and>\n                       D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>};\n         C \\<in> f \\<turnstile> \\<C>; D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. H \\<noteq> {} \\<Longrightarrow> C \\<noteq> D", "thus ?thesis"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<noteq> D", "using foldpairs_def \n            OpposedThinChamberComplexFoldings.halfchsys_decomp(2)[\n              of X f g\n            ]"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n  OpposedThinChamberComplexFoldings X f g ?C0.0 \\<Longrightarrow>\n  f \\<turnstile> \\<C> \\<inter> (g \\<turnstile> \\<C>) = {}\n\ngoal (1 subgoal):\n 1. C \\<noteq> D", "by    auto"], ["proof (state)\nthis:\n  C \\<noteq> D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C \\<noteq> D\n\ngoal (2 subgoals):\n 1. gallery (C # Cs @ [D])\n 2. \\<And>ys.\n       gallery (C # ys @ [D]) \\<Longrightarrow>\n       order.greater_eq (length ys) (length Cs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. gallery (C # Cs @ [D])\n 2. \\<And>ys.\n       gallery (C # ys @ [D]) \\<Longrightarrow>\n       order.greater_eq (length ys) (length Cs)", "fix Ds"], ["proof (state)\ngoal (2 subgoals):\n 1. gallery (C # Cs @ [D])\n 2. \\<And>ys.\n       gallery (C # ys @ [D]) \\<Longrightarrow>\n       order.greater_eq (length ys) (length Cs)", "assume Ds: \"gallery (C # Ds @ [D])\""], ["proof (state)\nthis:\n  gallery (C # Ds @ [D])\n\ngoal (2 subgoals):\n 1. gallery (C # Cs @ [D])\n 2. \\<And>ys.\n       gallery (C # ys @ [D]) \\<Longrightarrow>\n       order.greater_eq (length ys) (length Cs)", "have \"Suc (length Cs) = card (walls_betw C D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (length Cs) = card (walls_betw C D)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (length Cs) = card (walls_betw C D)", "from assms(1,3)"], ["proof (chain)\npicking this:\n  gallery (C # Cs @ [D])\n  \\<forall>H\\<in>set (wall_crossings (C # Cs @ [D])). separated_by H C D", "have \"set (wall_crossings (C#Cs@[D])) = walls_betw C D\""], ["proof (prove)\nusing this:\n  gallery (C # Cs @ [D])\n  \\<forall>H\\<in>set (wall_crossings (C # Cs @ [D])). separated_by H C D\n\ngoal (1 subgoal):\n 1. set (wall_crossings (C # Cs @ [D])) = walls_betw C D", "using     separated_by_not_empty wall_crossings_are_walls[of _ \"C#Cs@[D]\"]\n                walls_betw_def\n                walls_betw_subset_wall_crossings[OF assms(1)]"], ["proof (prove)\nusing this:\n  gallery (C # Cs @ [D])\n  \\<forall>H\\<in>set (wall_crossings (C # Cs @ [D])). separated_by H C D\n  separated_by ?w ?x ?y \\<Longrightarrow> ?w \\<noteq> {}\n  \\<lbrakk>?H \\<in> set (wall_crossings (C # Cs @ [D]));\n   ?H \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                 {{f \\<turnstile> \\<C>,\n                                   g \\<turnstile> \\<C>}})\n  walls_betw ?C ?D \\<equiv>\n  {H \\<in> \\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}.\n   separated_by H ?C ?D}\n  order.greater_eq (set (wall_crossings (C # Cs @ [D]))) (walls_betw C D)\n\ngoal (1 subgoal):\n 1. set (wall_crossings (C # Cs @ [D])) = walls_betw C D", "unfolding separated_by_def"], ["proof (prove)\nusing this:\n  gallery (C # Cs @ [D])\n  \\<forall>H\\<in>set (wall_crossings (C # Cs @ [D])).\n     \\<exists>A B. H = {A, B} \\<and> C \\<in> A \\<and> D \\<in> B\n  \\<exists>A B.\n     ?w = {A, B} \\<and> ?x \\<in> A \\<and> ?y \\<in> B \\<Longrightarrow>\n  ?w \\<noteq> {}\n  \\<lbrakk>?H \\<in> set (wall_crossings (C # Cs @ [D]));\n   ?H \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                 {{f \\<turnstile> \\<C>,\n                                   g \\<turnstile> \\<C>}})\n  walls_betw ?C ?D \\<equiv>\n  {H \\<in> \\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}.\n   \\<exists>A B. H = {A, B} \\<and> ?C \\<in> A \\<and> ?D \\<in> B}\n  order.greater_eq (set (wall_crossings (C # Cs @ [D]))) (walls_betw C D)\n\ngoal (1 subgoal):\n 1. set (wall_crossings (C # Cs @ [D])) = walls_betw C D", "by        auto"], ["proof (state)\nthis:\n  set (wall_crossings (C # Cs @ [D])) = walls_betw C D\n\ngoal (1 subgoal):\n 1. Suc (length Cs) = card (walls_betw C D)", "with assms(2)"], ["proof (chain)\npicking this:\n  distinct (wall_crossings (C # Cs @ [D]))\n  set (wall_crossings (C # Cs @ [D])) = walls_betw C D", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (wall_crossings (C # Cs @ [D]))\n  set (wall_crossings (C # Cs @ [D])) = walls_betw C D\n\ngoal (1 subgoal):\n 1. Suc (length Cs) = card (walls_betw C D)", "using distinct_card[THEN sym] length_wall_crossings"], ["proof (prove)\nusing this:\n  distinct (wall_crossings (C # Cs @ [D]))\n  set (wall_crossings (C # Cs @ [D])) = walls_betw C D\n  distinct ?xs1 \\<Longrightarrow> length ?xs1 = card (set ?xs1)\n  length (wall_crossings ?Cs) = length ?Cs - 1\n\ngoal (1 subgoal):\n 1. Suc (length Cs) = card (walls_betw C D)", "by fastforce"], ["proof (state)\nthis:\n  Suc (length Cs) = card (walls_betw C D)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc (length Cs) = card (walls_betw C D)\n\ngoal (2 subgoals):\n 1. gallery (C # Cs @ [D])\n 2. \\<And>ys.\n       gallery (C # ys @ [D]) \\<Longrightarrow>\n       order.greater_eq (length ys) (length Cs)", "moreover"], ["proof (state)\nthis:\n  Suc (length Cs) = card (walls_betw C D)\n\ngoal (2 subgoals):\n 1. gallery (C # Cs @ [D])\n 2. \\<And>ys.\n       gallery (C # ys @ [D]) \\<Longrightarrow>\n       order.greater_eq (length ys) (length Cs)", "have \"card (walls_betw C D) \\<le> Suc (length Ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (Suc (length Ds)) (card (walls_betw C D))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. order.greater_eq (Suc (length Ds)) (card (walls_betw C D))", "from Ds"], ["proof (chain)\npicking this:\n  gallery (C # Ds @ [D])", "have \"card (walls_betw C D) \\<le> card (set (wall_crossings (C#Ds@[D])))\""], ["proof (prove)\nusing this:\n  gallery (C # Ds @ [D])\n\ngoal (1 subgoal):\n 1. order.greater_eq (card (set (wall_crossings (C # Ds @ [D]))))\n     (card (walls_betw C D))", "using walls_betw_subset_wall_crossings finite_set card_mono"], ["proof (prove)\nusing this:\n  gallery (C # Ds @ [D])\n  gallery (?C # ?Cs @ [?D]) \\<Longrightarrow>\n  order.greater_eq (set (wall_crossings (?C # ?Cs @ [?D])))\n   (walls_betw ?C ?D)\n  finite (set ?xs)\n  \\<lbrakk>finite ?B; order.greater_eq ?B ?A\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (card ?B) (card ?A)\n\ngoal (1 subgoal):\n 1. order.greater_eq (card (set (wall_crossings (C # Ds @ [D]))))\n     (card (walls_betw C D))", "by force"], ["proof (state)\nthis:\n  order.greater_eq (card (set (wall_crossings (C # Ds @ [D]))))\n   (card (walls_betw C D))\n\ngoal (1 subgoal):\n 1. order.greater_eq (Suc (length Ds)) (card (walls_betw C D))", "also"], ["proof (state)\nthis:\n  order.greater_eq (card (set (wall_crossings (C # Ds @ [D]))))\n   (card (walls_betw C D))\n\ngoal (1 subgoal):\n 1. order.greater_eq (Suc (length Ds)) (card (walls_betw C D))", "have \"\\<dots> \\<le> length (wall_crossings (C#Ds@[D]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (length (wall_crossings (C # Ds @ [D])))\n     (card (set (wall_crossings (C # Ds @ [D]))))", "using card_length"], ["proof (prove)\nusing this:\n  order.greater_eq (length ?xs) (card (set ?xs))\n\ngoal (1 subgoal):\n 1. order.greater_eq (length (wall_crossings (C # Ds @ [D])))\n     (card (set (wall_crossings (C # Ds @ [D]))))", "by auto"], ["proof (state)\nthis:\n  order.greater_eq (length (wall_crossings (C # Ds @ [D])))\n   (card (set (wall_crossings (C # Ds @ [D]))))\n\ngoal (1 subgoal):\n 1. order.greater_eq (Suc (length Ds)) (card (walls_betw C D))", "finally"], ["proof (chain)\npicking this:\n  order.greater_eq (length (wall_crossings (C # Ds @ [D])))\n   (card (walls_betw C D))", "show ?thesis"], ["proof (prove)\nusing this:\n  order.greater_eq (length (wall_crossings (C # Ds @ [D])))\n   (card (walls_betw C D))\n\ngoal (1 subgoal):\n 1. order.greater_eq (Suc (length Ds)) (card (walls_betw C D))", "using length_wall_crossings"], ["proof (prove)\nusing this:\n  order.greater_eq (length (wall_crossings (C # Ds @ [D])))\n   (card (walls_betw C D))\n  length (wall_crossings ?Cs) = length ?Cs - 1\n\ngoal (1 subgoal):\n 1. order.greater_eq (Suc (length Ds)) (card (walls_betw C D))", "by simp"], ["proof (state)\nthis:\n  order.greater_eq (Suc (length Ds)) (card (walls_betw C D))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq (Suc (length Ds)) (card (walls_betw C D))\n\ngoal (2 subgoals):\n 1. gallery (C # Cs @ [D])\n 2. \\<And>ys.\n       gallery (C # ys @ [D]) \\<Longrightarrow>\n       order.greater_eq (length ys) (length Cs)", "ultimately"], ["proof (chain)\npicking this:\n  Suc (length Cs) = card (walls_betw C D)\n  order.greater_eq (Suc (length Ds)) (card (walls_betw C D))", "show \"length Cs \\<le> length Ds\""], ["proof (prove)\nusing this:\n  Suc (length Cs) = card (walls_betw C D)\n  order.greater_eq (Suc (length Ds)) (card (walls_betw C D))\n\ngoal (1 subgoal):\n 1. order.greater_eq (length Ds) (length Cs)", "by simp"], ["proof (state)\nthis:\n  order.greater_eq (length Ds) (length Cs)\n\ngoal (1 subgoal):\n 1. gallery (C # Cs @ [D])", "qed (rule assms(1))"], ["", "lemma ex_nonseparating_wall_imp_wall_crossings_not_distinct:\n  assumes gal : \"gallery (C#Cs@[D])\"\n  and     wall: \"H\\<in>set (wall_crossings (C#Cs@[D]))\" \"H\\<noteq>{}\"\n                \"\\<not> separated_by H C D\"\n  shows   \"\\<not> distinct (wall_crossings (C#Cs@[D]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings (C # Cs @ [D]))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings (C # Cs @ [D]))", "from assms"], ["proof (chain)\npicking this:\n  gallery (C # Cs @ [D])\n  H \\<in> set (wall_crossings (C # Cs @ [D]))\n  H \\<noteq> {}\n  \\<not> separated_by H C D", "obtain f g\n    where fg: \"(f,g)\\<in>foldpairs\" \"H = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\" \"C\\<in>f\\<turnstile>\\<C>\" \"D\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  gallery (C # Cs @ [D])\n  H \\<in> set (wall_crossings (C # Cs @ [D]))\n  H \\<noteq> {}\n  \\<not> separated_by H C D\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>};\n         C \\<in> f \\<turnstile> \\<C>; D \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using wall_crossings_are_walls[of H]\n          not_separated_by_wall_ex_foldpair[of C D H]\n          galleryD_chamber"], ["proof (prove)\nusing this:\n  gallery (C # Cs @ [D])\n  H \\<in> set (wall_crossings (C # Cs @ [D]))\n  H \\<noteq> {}\n  \\<not> separated_by H C D\n  \\<lbrakk>H \\<in> set (wall_crossings ?Cs); H \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                {{f \\<turnstile> \\<C>,\n                                  g \\<turnstile> \\<C>}})\n  \\<lbrakk>chamber C; chamber D;\n   H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n               {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}});\n   \\<not> separated_by H C D\\<rbrakk>\n  \\<Longrightarrow> \\<exists>(f, g)\\<in>foldpairs.\n                       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n                       C \\<in> f \\<turnstile> \\<C> \\<and>\n                       D \\<in> f \\<turnstile> \\<C>\n  \\<lbrakk>gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> chamber ?x\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>};\n         C \\<in> f \\<turnstile> \\<C>; D \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings (C # Cs @ [D]))", "from fg(1)"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs", "obtain Z where Z: \"OpposedThinChamberComplexFoldings X f g Z\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        OpposedThinChamberComplexFoldings X f g Z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using foldpairs_def"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        OpposedThinChamberComplexFoldings X f g Z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g Z\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings (C # Cs @ [D]))", "from wall fg(2-4)"], ["proof (chain)\npicking this:\n  H \\<in> set (wall_crossings (C # Cs @ [D]))\n  H \\<noteq> {}\n  \\<not> separated_by H C D\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> f \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  H \\<in> set (wall_crossings (C # Cs @ [D]))\n  H \\<noteq> {}\n  \\<not> separated_by H C D\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings (C # Cs @ [D]))", "using OpposedThinChamberComplexFoldings.sside_wcrossings_ndistinct_f [\n            OF Z gal\n          ]"], ["proof (prove)\nusing this:\n  H \\<in> set (wall_crossings (C # Cs @ [D]))\n  H \\<noteq> {}\n  \\<not> separated_by H C D\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> f \\<turnstile> \\<C>\n  \\<lbrakk>C \\<in> f \\<turnstile> \\<C>; D \\<in> f \\<turnstile> \\<C>;\n   {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n   \\<in> set (wall_crossings (C # Cs @ [D]))\\<rbrakk>\n  \\<Longrightarrow> \\<not> distinct (wall_crossings (C # Cs @ [D]))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings (C # Cs @ [D]))", "by    blast"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings (C # Cs @ [D]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_min_gallery_double_crosses_wall:\n  assumes \"gallery Cs\" \"\\<not> min_gallery Cs\" \"{} \\<notin> set (wall_crossings Cs)\"\n  shows   \"\\<not> distinct (wall_crossings Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs)", "proof (cases Cs rule: list_cases_Cons_snoc)"], ["proof (state)\ngoal (3 subgoals):\n 1. Cs = [] \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)\n 2. \\<And>x. Cs = [x] \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)\n 3. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> distinct (wall_crossings Cs)", "case Nil"], ["proof (state)\nthis:\n  Cs = []\n\ngoal (3 subgoals):\n 1. Cs = [] \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)\n 2. \\<And>x. Cs = [x] \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)\n 3. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> distinct (wall_crossings Cs)", "with assms(2)"], ["proof (chain)\npicking this:\n  \\<not> min_gallery Cs\n  Cs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> min_gallery Cs\n  Cs = []\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs)", "by simp"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings Cs)\n\ngoal (2 subgoals):\n 1. \\<And>x. Cs = [x] \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)\n 2. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> distinct (wall_crossings Cs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. Cs = [x] \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)\n 2. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> distinct (wall_crossings Cs)", "case Single"], ["proof (state)\nthis:\n  Cs = [x_]\n\ngoal (2 subgoals):\n 1. \\<And>x. Cs = [x] \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)\n 2. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> distinct (wall_crossings Cs)", "with assms(1,2)"], ["proof (chain)\npicking this:\n  gallery Cs\n  \\<not> min_gallery Cs\n  Cs = [x_]", "show ?thesis"], ["proof (prove)\nusing this:\n  gallery Cs\n  \\<not> min_gallery Cs\n  Cs = [x_]\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs)", "using galleryD_chamber"], ["proof (prove)\nusing this:\n  gallery Cs\n  \\<not> min_gallery Cs\n  Cs = [x_]\n  \\<lbrakk>gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> chamber ?x\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs)", "by simp"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings Cs)\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> distinct (wall_crossings Cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> distinct (wall_crossings Cs)", "case (Cons_snoc B Bs C)"], ["proof (state)\nthis:\n  Cs = B # Bs @ [C]\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       Cs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> distinct (wall_crossings Cs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs)", "proof (cases \"B=C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. B = C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)\n 2. B \\<noteq> C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "case True"], ["proof (state)\nthis:\n  B = C\n\ngoal (2 subgoals):\n 1. B = C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)\n 2. B \\<noteq> C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs)", "proof (cases Bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. Bs = [] \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)\n 2. \\<And>a list.\n       Bs = a # list \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "case Nil"], ["proof (state)\nthis:\n  Bs = []\n\ngoal (2 subgoals):\n 1. Bs = [] \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)\n 2. \\<And>a list.\n       Bs = a # list \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "with True Cons_snoc assms(3)"], ["proof (chain)\npicking this:\n  B = C\n  Cs = B # Bs @ [C]\n  {} \\<notin> set (wall_crossings Cs)\n  Bs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  B = C\n  Cs = B # Bs @ [C]\n  {} \\<notin> set (wall_crossings Cs)\n  Bs = []\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs)", "using the_wall_betw_self_empty"], ["proof (prove)\nusing this:\n  B = C\n  Cs = B # Bs @ [C]\n  {} \\<notin> set (wall_crossings Cs)\n  Bs = []\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H ?C ?C) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs)", "by simp"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings Cs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Bs = a # list \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Bs = a # list \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "case (Cons E Es)"], ["proof (state)\nthis:\n  Bs = E # Es\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Bs = a # list \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "define H where \"H = the_wall_betw B E\""], ["proof (state)\nthis:\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H B E)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Bs = a # list \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "with Cons"], ["proof (chain)\npicking this:\n  Bs = E # Es\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H B E)", "have *: \"H \\<in> set (wall_crossings (B#Bs@[C]))\""], ["proof (prove)\nusing this:\n  Bs = E # Es\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H B E)\n\ngoal (1 subgoal):\n 1. H \\<in> set (wall_crossings (B # Bs @ [C]))", "by simp"], ["proof (state)\nthis:\n  H \\<in> set (wall_crossings (B # Bs @ [C]))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Bs = a # list \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "moreover"], ["proof (state)\nthis:\n  H \\<in> set (wall_crossings (B # Bs @ [C]))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Bs = a # list \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "from assms(3) Cons_snoc *"], ["proof (chain)\npicking this:\n  {} \\<notin> set (wall_crossings Cs)\n  Cs = B # Bs @ [C]\n  H \\<in> set (wall_crossings (B # Bs @ [C]))", "have \"H \\<noteq> {}\""], ["proof (prove)\nusing this:\n  {} \\<notin> set (wall_crossings Cs)\n  Cs = B # Bs @ [C]\n  H \\<in> set (wall_crossings (B # Bs @ [C]))\n\ngoal (1 subgoal):\n 1. H \\<noteq> {}", "by fast"], ["proof (state)\nthis:\n  H \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Bs = a # list \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "ultimately"], ["proof (chain)\npicking this:\n  H \\<in> set (wall_crossings (B # Bs @ [C]))\n  H \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  H \\<in> set (wall_crossings (B # Bs @ [C]))\n  H \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs)", "using assms(1) Cons_snoc Cons True H_def\n              the_wall_betw_nempty(1)[of B E] not_self_separated_by_wall[of H B]\n              ex_nonseparating_wall_imp_wall_crossings_not_distinct[of B Bs C H]"], ["proof (prove)\nusing this:\n  H \\<in> set (wall_crossings (B # Bs @ [C]))\n  H \\<noteq> {}\n  gallery Cs\n  Cs = B # Bs @ [C]\n  Bs = E # Es\n  B = C\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H B E)\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H B E) \\<noteq>\n  {} \\<Longrightarrow>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H B E)\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>,\n                g \\<turnstile> \\<C>}}) \\<Longrightarrow>\n  \\<not> separated_by H B B\n  \\<lbrakk>gallery (B # Bs @ [C]);\n   H \\<in> set (wall_crossings (B # Bs @ [C])); H \\<noteq> {};\n   \\<not> separated_by H B C\\<rbrakk>\n  \\<Longrightarrow> \\<not> distinct (wall_crossings (B # Bs @ [C]))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs)", "by    fast"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings Cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings Cs)\n\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "case False"], ["proof (state)\nthis:\n  B \\<noteq> C\n\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "with assms Cons_snoc"], ["proof (chain)\npicking this:\n  gallery Cs\n  \\<not> min_gallery Cs\n  {} \\<notin> set (wall_crossings Cs)\n  Cs = B # Bs @ [C]\n  B \\<noteq> C", "have  1: \"\\<not> distinct (wall_crossings Cs) \\<or>\n              \\<not> (\\<forall>H\\<in>set (wall_crossings Cs). separated_by H B C)\""], ["proof (prove)\nusing this:\n  gallery Cs\n  \\<not> min_gallery Cs\n  {} \\<notin> set (wall_crossings Cs)\n  Cs = B # Bs @ [C]\n  B \\<noteq> C\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs) \\<or>\n    \\<not> (\\<forall>H\\<in>set (wall_crossings Cs). separated_by H B C)", "using wall_crossings_min_gallery_betwI"], ["proof (prove)\nusing this:\n  gallery Cs\n  \\<not> min_gallery Cs\n  {} \\<notin> set (wall_crossings Cs)\n  Cs = B # Bs @ [C]\n  B \\<noteq> C\n  \\<lbrakk>gallery (?C # ?Cs @ [?D]);\n   distinct (wall_crossings (?C # ?Cs @ [?D]));\n   \\<forall>H\\<in>set (wall_crossings (?C # ?Cs @ [?D])).\n      separated_by H ?C ?D\\<rbrakk>\n  \\<Longrightarrow> min_gallery (?C # ?Cs @ [?D])\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs) \\<or>\n    \\<not> (\\<forall>H\\<in>set (wall_crossings Cs). separated_by H B C)", "by    force"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings Cs) \\<or>\n  \\<not> (\\<forall>H\\<in>set (wall_crossings Cs). separated_by H B C)\n\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "moreover"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings Cs) \\<or>\n  \\<not> (\\<forall>H\\<in>set (wall_crossings Cs). separated_by H B C)\n\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "{"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings Cs) \\<or>\n  \\<not> (\\<forall>H\\<in>set (wall_crossings Cs). separated_by H B C)\n\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "assume \"\\<not> (\\<forall>H\\<in>set (wall_crossings Cs). separated_by H B C)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>H\\<in>set (wall_crossings Cs). separated_by H B C)\n\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "from this"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>H\\<in>set (wall_crossings Cs). separated_by H B C)", "obtain H\n        where H: \"H\\<in>set (wall_crossings Cs)\" \"\\<not> separated_by H B C\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>H\\<in>set (wall_crossings Cs). separated_by H B C)\n\ngoal (1 subgoal):\n 1. (\\<And>H.\n        \\<lbrakk>H \\<in> set (wall_crossings Cs);\n         \\<not> separated_by H B C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  H \\<in> set (wall_crossings Cs)\n  \\<not> separated_by H B C\n\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "moreover"], ["proof (state)\nthis:\n  H \\<in> set (wall_crossings Cs)\n  \\<not> separated_by H B C\n\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "from H(1) assms(3)"], ["proof (chain)\npicking this:\n  H \\<in> set (wall_crossings Cs)\n  {} \\<notin> set (wall_crossings Cs)", "have \"H\\<noteq>{}\""], ["proof (prove)\nusing this:\n  H \\<in> set (wall_crossings Cs)\n  {} \\<notin> set (wall_crossings Cs)\n\ngoal (1 subgoal):\n 1. H \\<noteq> {}", "by fast"], ["proof (state)\nthis:\n  H \\<noteq> {}\n\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "ultimately"], ["proof (chain)\npicking this:\n  H \\<in> set (wall_crossings Cs)\n  \\<not> separated_by H B C\n  H \\<noteq> {}", "have ?thesis"], ["proof (prove)\nusing this:\n  H \\<in> set (wall_crossings Cs)\n  \\<not> separated_by H B C\n  H \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs)", "using assms(1) Cons_snoc\n              ex_nonseparating_wall_imp_wall_crossings_not_distinct"], ["proof (prove)\nusing this:\n  H \\<in> set (wall_crossings Cs)\n  \\<not> separated_by H B C\n  H \\<noteq> {}\n  gallery Cs\n  Cs = B # Bs @ [C]\n  \\<lbrakk>gallery (?C # ?Cs @ [?D]);\n   ?H \\<in> set (wall_crossings (?C # ?Cs @ [?D])); ?H \\<noteq> {};\n   \\<not> separated_by ?H ?C ?D\\<rbrakk>\n  \\<Longrightarrow> \\<not> distinct (wall_crossings (?C # ?Cs @ [?D]))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs)", "by    simp"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings Cs)\n\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "}"], ["proof (state)\nthis:\n  \\<not> (\\<forall>H\\<in>set (wall_crossings Cs).\n             separated_by H B C) \\<Longrightarrow>\n  \\<not> distinct (wall_crossings Cs)\n\ngoal (1 subgoal):\n 1. B \\<noteq> C \\<Longrightarrow> \\<not> distinct (wall_crossings Cs)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> distinct (wall_crossings Cs) \\<or>\n  \\<not> (\\<forall>H\\<in>set (wall_crossings Cs). separated_by H B C)\n  \\<not> (\\<forall>H\\<in>set (wall_crossings Cs).\n             separated_by H B C) \\<Longrightarrow>\n  \\<not> distinct (wall_crossings Cs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> distinct (wall_crossings Cs) \\<or>\n  \\<not> (\\<forall>H\\<in>set (wall_crossings Cs). separated_by H B C)\n  \\<not> (\\<forall>H\\<in>set (wall_crossings Cs).\n             separated_by H B C) \\<Longrightarrow>\n  \\<not> distinct (wall_crossings Cs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (wall_crossings Cs)", "by fast"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings Cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings Cs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_distinct_crossings_split_gallery:\n  \"\\<lbrakk> gallery Cs; {} \\<notin> set (wall_crossings Cs); \\<not> distinct (wall_crossings Cs) \\<rbrakk> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n      (f,g)\\<in>foldpairs \\<and> A\\<in>f\\<turnstile>\\<C> \\<and> B\\<in>g\\<turnstile>\\<C> \\<and> E\\<in>g\\<turnstile>\\<C> \\<and> F\\<in>f\\<turnstile>\\<C> \\<and>\n      ( Cs = As@[A,B,F]@Fs \\<or> Cs = As@[A,B]@Bs@[E,F]@Fs )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gallery Cs; {} \\<notin> set (wall_crossings Cs);\n     \\<not> distinct (wall_crossings Cs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                         (f, g) \\<in> foldpairs \\<and>\n                         A \\<in> f \\<turnstile> \\<C> \\<and>\n                         B \\<in> g \\<turnstile> \\<C> \\<and>\n                         E \\<in> g \\<turnstile> \\<C> \\<and>\n                         F \\<in> f \\<turnstile> \\<C> \\<and>\n                         (Cs = As @ [A, B, F] @ Fs \\<or>\n                          Cs = As @ [A, B] @ Bs @ [E, F] @ Fs)", "proof (induct Cs rule: list_induct_CCons)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>gallery []; {} \\<notin> set (wall_crossings []);\n     \\<not> distinct (wall_crossings [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                         (f, g) \\<in> foldpairs \\<and>\n                         A \\<in> f \\<turnstile> \\<C> \\<and>\n                         B \\<in> g \\<turnstile> \\<C> \\<and>\n                         E \\<in> g \\<turnstile> \\<C> \\<and>\n                         F \\<in> f \\<turnstile> \\<C> \\<and>\n                         ([] = As @ [A, B, F] @ Fs \\<or>\n                          [] = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<And>x.\n       \\<lbrakk>gallery [x]; {} \\<notin> set (wall_crossings [x]);\n        \\<not> distinct (wall_crossings [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                            (f, g) \\<in> foldpairs \\<and>\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> g \\<turnstile> \\<C> \\<and>\n                            E \\<in> g \\<turnstile> \\<C> \\<and>\n                            F \\<in> f \\<turnstile> \\<C> \\<and>\n                            ([x] = As @ [A, B, F] @ Fs \\<or>\n                             [x] = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 3. \\<And>x y xs.\n       \\<lbrakk>\\<lbrakk>gallery (y # xs);\n                 {} \\<notin> set (wall_crossings (y # xs));\n                 \\<not> distinct (wall_crossings (y # xs))\\<rbrakk>\n                \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                                     (f, g) \\<in> foldpairs \\<and>\n                                     A \\<in> f \\<turnstile> \\<C> \\<and>\n                                     B \\<in> g \\<turnstile> \\<C> \\<and>\n                                     E \\<in> g \\<turnstile> \\<C> \\<and>\n                                     F \\<in> f \\<turnstile> \\<C> \\<and>\n                                     (y # xs = As @ [A, B, F] @ Fs \\<or>\ny # xs = As @ [A, B] @ Bs @ [E, F] @ Fs);\n        gallery (x # y # xs); {} \\<notin> set (wall_crossings (x # y # xs));\n        \\<not> distinct (wall_crossings (x # y # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                            (f, g) \\<in> foldpairs \\<and>\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> g \\<turnstile> \\<C> \\<and>\n                            E \\<in> g \\<turnstile> \\<C> \\<and>\n                            F \\<in> f \\<turnstile> \\<C> \\<and>\n                            (x # y # xs = As @ [A, B, F] @ Fs \\<or>\n                             x # y # xs = As @ [A, B] @ Bs @ [E, F] @ Fs)", "case (CCons C J Js)"], ["proof (state)\nthis:\n  \\<lbrakk>gallery (J # Js); {} \\<notin> set (wall_crossings (J # Js));\n   \\<not> distinct (wall_crossings (J # Js))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                       (f, g) \\<in> foldpairs \\<and>\n                       A \\<in> f \\<turnstile> \\<C> \\<and>\n                       B \\<in> g \\<turnstile> \\<C> \\<and>\n                       E \\<in> g \\<turnstile> \\<C> \\<and>\n                       F \\<in> f \\<turnstile> \\<C> \\<and>\n                       (J # Js = As @ [A, B, F] @ Fs \\<or>\n                        J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n  gallery (C # J # Js)\n  {} \\<notin> set (wall_crossings (C # J # Js))\n  \\<not> distinct (wall_crossings (C # J # Js))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>gallery []; {} \\<notin> set (wall_crossings []);\n     \\<not> distinct (wall_crossings [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                         (f, g) \\<in> foldpairs \\<and>\n                         A \\<in> f \\<turnstile> \\<C> \\<and>\n                         B \\<in> g \\<turnstile> \\<C> \\<and>\n                         E \\<in> g \\<turnstile> \\<C> \\<and>\n                         F \\<in> f \\<turnstile> \\<C> \\<and>\n                         ([] = As @ [A, B, F] @ Fs \\<or>\n                          [] = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<And>x.\n       \\<lbrakk>gallery [x]; {} \\<notin> set (wall_crossings [x]);\n        \\<not> distinct (wall_crossings [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                            (f, g) \\<in> foldpairs \\<and>\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> g \\<turnstile> \\<C> \\<and>\n                            E \\<in> g \\<turnstile> \\<C> \\<and>\n                            F \\<in> f \\<turnstile> \\<C> \\<and>\n                            ([x] = As @ [A, B, F] @ Fs \\<or>\n                             [x] = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 3. \\<And>x y xs.\n       \\<lbrakk>\\<lbrakk>gallery (y # xs);\n                 {} \\<notin> set (wall_crossings (y # xs));\n                 \\<not> distinct (wall_crossings (y # xs))\\<rbrakk>\n                \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                                     (f, g) \\<in> foldpairs \\<and>\n                                     A \\<in> f \\<turnstile> \\<C> \\<and>\n                                     B \\<in> g \\<turnstile> \\<C> \\<and>\n                                     E \\<in> g \\<turnstile> \\<C> \\<and>\n                                     F \\<in> f \\<turnstile> \\<C> \\<and>\n                                     (y # xs = As @ [A, B, F] @ Fs \\<or>\ny # xs = As @ [A, B] @ Bs @ [E, F] @ Fs);\n        gallery (x # y # xs); {} \\<notin> set (wall_crossings (x # y # xs));\n        \\<not> distinct (wall_crossings (x # y # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                            (f, g) \\<in> foldpairs \\<and>\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> g \\<turnstile> \\<C> \\<and>\n                            E \\<in> g \\<turnstile> \\<C> \\<and>\n                            F \\<in> f \\<turnstile> \\<C> \\<and>\n                            (x # y # xs = As @ [A, B, F] @ Fs \\<or>\n                             x # y # xs = As @ [A, B] @ Bs @ [E, F] @ Fs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "proof (cases \"distinct (wall_crossings (J#Js))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<not> distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "case False"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings (J # Js))\n\ngoal (2 subgoals):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<not> distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "moreover"], ["proof (state)\nthis:\n  \\<not> distinct (wall_crossings (J # Js))\n\ngoal (2 subgoals):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<not> distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "from CCons(2)"], ["proof (chain)\npicking this:\n  gallery (C # J # Js)", "have \"gallery (J#Js)\""], ["proof (prove)\nusing this:\n  gallery (C # J # Js)\n\ngoal (1 subgoal):\n 1. gallery (J # Js)", "using gallery_Cons_reduce"], ["proof (prove)\nusing this:\n  gallery (C # J # Js)\n  gallery (?x # ?xs) \\<Longrightarrow> gallery ?xs\n\ngoal (1 subgoal):\n 1. gallery (J # Js)", "by simp"], ["proof (state)\nthis:\n  gallery (J # Js)\n\ngoal (2 subgoals):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<not> distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "moreover"], ["proof (state)\nthis:\n  gallery (J # Js)\n\ngoal (2 subgoals):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<not> distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "from CCons(3)"], ["proof (chain)\npicking this:\n  {} \\<notin> set (wall_crossings (C # J # Js))", "have \"{} \\<notin> set (wall_crossings (J#Js))\""], ["proof (prove)\nusing this:\n  {} \\<notin> set (wall_crossings (C # J # Js))\n\ngoal (1 subgoal):\n 1. {} \\<notin> set (wall_crossings (J # Js))", "by simp"], ["proof (state)\nthis:\n  {} \\<notin> set (wall_crossings (J # Js))\n\ngoal (2 subgoals):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<not> distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> distinct (wall_crossings (J # Js))\n  gallery (J # Js)\n  {} \\<notin> set (wall_crossings (J # Js))", "obtain f g As A B Bs E F Fs where split:\n      \"(f,g)\\<in>foldpairs\" \"A\\<in>f\\<turnstile>\\<C>\" \"B\\<in>g\\<turnstile>\\<C>\" \"E\\<in>g\\<turnstile>\\<C>\" \"F\\<in>f\\<turnstile>\\<C>\"\n      \"J#Js = As@[A,B,F]@Fs \\<or> J#Js = As@[A,B]@Bs@[E,F]@Fs\""], ["proof (prove)\nusing this:\n  \\<not> distinct (wall_crossings (J # Js))\n  gallery (J # Js)\n  {} \\<notin> set (wall_crossings (J # Js))\n\ngoal (1 subgoal):\n 1. (\\<And>f g A B E F As Fs Bs.\n        \\<lbrakk>(f, g) \\<in> foldpairs; A \\<in> f \\<turnstile> \\<C>;\n         B \\<in> g \\<turnstile> \\<C>; E \\<in> g \\<turnstile> \\<C>;\n         F \\<in> f \\<turnstile> \\<C>;\n         J # Js = As @ [A, B, F] @ Fs \\<or>\n         J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using CCons(1)"], ["proof (prove)\nusing this:\n  \\<not> distinct (wall_crossings (J # Js))\n  gallery (J # Js)\n  {} \\<notin> set (wall_crossings (J # Js))\n  \\<lbrakk>gallery (J # Js); {} \\<notin> set (wall_crossings (J # Js));\n   \\<not> distinct (wall_crossings (J # Js))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                       (f, g) \\<in> foldpairs \\<and>\n                       A \\<in> f \\<turnstile> \\<C> \\<and>\n                       B \\<in> g \\<turnstile> \\<C> \\<and>\n                       E \\<in> g \\<turnstile> \\<C> \\<and>\n                       F \\<in> f \\<turnstile> \\<C> \\<and>\n                       (J # Js = As @ [A, B, F] @ Fs \\<or>\n                        J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n\ngoal (1 subgoal):\n 1. (\\<And>f g A B E F As Fs Bs.\n        \\<lbrakk>(f, g) \\<in> foldpairs; A \\<in> f \\<turnstile> \\<C>;\n         B \\<in> g \\<turnstile> \\<C>; E \\<in> g \\<turnstile> \\<C>;\n         F \\<in> f \\<turnstile> \\<C>;\n         J # Js = As @ [A, B, F] @ Fs \\<or>\n         J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    blast"], ["proof (state)\nthis:\n  (f, g) \\<in> foldpairs\n  A \\<in> f \\<turnstile> \\<C>\n  B \\<in> g \\<turnstile> \\<C>\n  E \\<in> g \\<turnstile> \\<C>\n  F \\<in> f \\<turnstile> \\<C>\n  J # Js = As @ [A, B, F] @ Fs \\<or> J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs\n\ngoal (2 subgoals):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<not> distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "from split(6)"], ["proof (chain)\npicking this:\n  J # Js = As @ [A, B, F] @ Fs \\<or> J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs", "have \"C#J#Js = (C#As)@[A,B,F]@Fs \\<or>\n              C#J#Js = (C#As)@[A,B]@Bs@[E,F]@Fs\""], ["proof (prove)\nusing this:\n  J # Js = As @ [A, B, F] @ Fs \\<or> J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs\n\ngoal (1 subgoal):\n 1. C # J # Js = (C # As) @ [A, B, F] @ Fs \\<or>\n    C # J # Js = (C # As) @ [A, B] @ Bs @ [E, F] @ Fs", "by   simp"], ["proof (state)\nthis:\n  C # J # Js = (C # As) @ [A, B, F] @ Fs \\<or>\n  C # J # Js = (C # As) @ [A, B] @ Bs @ [E, F] @ Fs\n\ngoal (2 subgoals):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<not> distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "with split(1-5)"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs\n  A \\<in> f \\<turnstile> \\<C>\n  B \\<in> g \\<turnstile> \\<C>\n  E \\<in> g \\<turnstile> \\<C>\n  F \\<in> f \\<turnstile> \\<C>\n  C # J # Js = (C # As) @ [A, B, F] @ Fs \\<or>\n  C # J # Js = (C # As) @ [A, B] @ Bs @ [E, F] @ Fs", "show ?thesis"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  A \\<in> f \\<turnstile> \\<C>\n  B \\<in> g \\<turnstile> \\<C>\n  E \\<in> g \\<turnstile> \\<C>\n  F \\<in> f \\<turnstile> \\<C>\n  C # J # Js = (C # As) @ [A, B, F] @ Fs \\<or>\n  C # J # Js = (C # As) @ [A, B] @ Bs @ [E, F] @ Fs\n\ngoal (1 subgoal):\n 1. \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "by blast"], ["proof (state)\nthis:\n  \\<exists>f g As A B Bs E F Fs.\n     (f, g) \\<in> foldpairs \\<and>\n     A \\<in> f \\<turnstile> \\<C> \\<and>\n     B \\<in> g \\<turnstile> \\<C> \\<and>\n     E \\<in> g \\<turnstile> \\<C> \\<and>\n     F \\<in> f \\<turnstile> \\<C> \\<and>\n     (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n      C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n\ngoal (1 subgoal):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "case True"], ["proof (state)\nthis:\n  distinct (wall_crossings (J # Js))\n\ngoal (1 subgoal):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "define H where \"H = the_wall_betw C J\""], ["proof (state)\nthis:\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C J)\n\ngoal (1 subgoal):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "with True CCons(4)"], ["proof (chain)\npicking this:\n  distinct (wall_crossings (J # Js))\n  \\<not> distinct (wall_crossings (C # J # Js))\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C J)", "have \"H\\<in>set (wall_crossings (J#Js))\""], ["proof (prove)\nusing this:\n  distinct (wall_crossings (J # Js))\n  \\<not> distinct (wall_crossings (C # J # Js))\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C J)\n\ngoal (1 subgoal):\n 1. H \\<in> set (wall_crossings (J # Js))", "by simp"], ["proof (state)\nthis:\n  H \\<in> set (wall_crossings (J # Js))\n\ngoal (1 subgoal):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "from this"], ["proof (chain)\npicking this:\n  H \\<in> set (wall_crossings (J # Js))", "obtain Bs E F Fs\n      where split1: \"J#Js = Bs@[E,F]@Fs\" \"H = the_wall_betw E F\""], ["proof (prove)\nusing this:\n  H \\<in> set (wall_crossings (J # Js))\n\ngoal (1 subgoal):\n 1. (\\<And>Bs E F Fs.\n        \\<lbrakk>J # Js = Bs @ [E, F] @ Fs;\n         H =\n         THE_default {}\n          (\\<lambda>H.\n              H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n              separated_by H E F)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using in_set_wall_crossings_decomp"], ["proof (prove)\nusing this:\n  H \\<in> set (wall_crossings (J # Js))\n  ?H \\<in> set (wall_crossings ?Cs) \\<Longrightarrow>\n  \\<exists>As A B Bs.\n     ?Cs = As @ [A, B] @ Bs \\<and>\n     ?H =\n     THE_default {}\n      (\\<lambda>H.\n          H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                      {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n          separated_by H A B)\n\ngoal (1 subgoal):\n 1. (\\<And>Bs E F Fs.\n        \\<lbrakk>J # Js = Bs @ [E, F] @ Fs;\n         H =\n         THE_default {}\n          (\\<lambda>H.\n              H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n              separated_by H E F)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  J # Js = Bs @ [E, F] @ Fs\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H E F)\n\ngoal (1 subgoal):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "from H_def split1(2) CCons(3)"], ["proof (chain)\npicking this:\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C J)\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H E F)\n  {} \\<notin> set (wall_crossings (C # J # Js))", "have  Hwall: \"H \\<in> walls\" \"separated_by H C J\" \"separated_by H E F\""], ["proof (prove)\nusing this:\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C J)\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H E F)\n  {} \\<notin> set (wall_crossings (C # J # Js))\n\ngoal (1 subgoal):\n 1. H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) &&&\n    separated_by H C J &&& separated_by H E F", "using the_wall_betw_nempty[of C J] the_wall_betw_nempty[of E F]"], ["proof (prove)\nusing this:\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C J)\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H E F)\n  {} \\<notin> set (wall_crossings (C # J # Js))\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C J) \\<noteq>\n  {} \\<Longrightarrow>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C J)\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C J) \\<noteq>\n  {} \\<Longrightarrow>\n  separated_by\n   (THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C J))\n   C J\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H E F) \\<noteq>\n  {} \\<Longrightarrow>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H E F)\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H E F) \\<noteq>\n  {} \\<Longrightarrow>\n  separated_by\n   (THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H E F))\n   E F\n\ngoal (1 subgoal):\n 1. H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) &&&\n    separated_by H C J &&& separated_by H E F", "by    auto"], ["proof (state)\nthis:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  separated_by H C J\n  separated_by H E F\n\ngoal (1 subgoal):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "from Hwall(1,2)"], ["proof (chain)\npicking this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  separated_by H C J", "obtain f g\n      where fg: \"(f,g)\\<in>foldpairs\" \"H={f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\" \"C\\<in>f\\<turnstile>\\<C>\" \"J\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  separated_by H C J\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>};\n         C \\<in> f \\<turnstile> \\<C>; J \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using separated_by_wall_ex_foldpair[of H C J]"], ["proof (prove)\nusing this:\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  separated_by H C J\n  \\<lbrakk>H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                       {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}});\n   separated_by H C J\\<rbrakk>\n  \\<Longrightarrow> \\<exists>(f, g)\\<in>foldpairs.\n                       H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} \\<and>\n                       C \\<in> f \\<turnstile> \\<C> \\<and>\n                       J \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>};\n         C \\<in> f \\<turnstile> \\<C>; J \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  (f, g) \\<in> foldpairs\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  J \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "from fg(1)"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs", "obtain Z\n      where Z: \"OpposedThinChamberComplexFoldings X f g Z\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        OpposedThinChamberComplexFoldings X f g Z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using foldpairs_def"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        OpposedThinChamberComplexFoldings X f g Z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g Z\n\ngoal (1 subgoal):\n 1. distinct (wall_crossings (J # Js)) \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "proof (cases Bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. Bs = [] \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<And>a list.\n       Bs = a # list \\<Longrightarrow>\n       \\<exists>f g As A B Bs E F Fs.\n          (f, g) \\<in> foldpairs \\<and>\n          A \\<in> f \\<turnstile> \\<C> \\<and>\n          B \\<in> g \\<turnstile> \\<C> \\<and>\n          E \\<in> g \\<turnstile> \\<C> \\<and>\n          F \\<in> f \\<turnstile> \\<C> \\<and>\n          (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n           C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "case Nil"], ["proof (state)\nthis:\n  Bs = []\n\ngoal (2 subgoals):\n 1. Bs = [] \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<And>a list.\n       Bs = a # list \\<Longrightarrow>\n       \\<exists>f g As A B Bs E F Fs.\n          (f, g) \\<in> foldpairs \\<and>\n          A \\<in> f \\<turnstile> \\<C> \\<and>\n          B \\<in> g \\<turnstile> \\<C> \\<and>\n          E \\<in> g \\<turnstile> \\<C> \\<and>\n          F \\<in> f \\<turnstile> \\<C> \\<and>\n          (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n           C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "with CCons(2) Hwall(2,3) fg(2-4) split1(1)"], ["proof (chain)\npicking this:\n  gallery (C # J # Js)\n  separated_by H C J\n  separated_by H E F\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  J \\<in> g \\<turnstile> \\<C>\n  J # Js = Bs @ [E, F] @ Fs\n  Bs = []", "have \"F\\<in>f\\<turnstile>\\<C>\" \"C#J#Js = []@[C,J,F]@Fs\""], ["proof (prove)\nusing this:\n  gallery (C # J # Js)\n  separated_by H C J\n  separated_by H E F\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  J \\<in> g \\<turnstile> \\<C>\n  J # Js = Bs @ [E, F] @ Fs\n  Bs = []\n\ngoal (1 subgoal):\n 1. F \\<in> f \\<turnstile> \\<C> &&& C # J # Js = [] @ [C, J, F] @ Fs", "using galleryD_chamber \n              OpposedThinChamberComplexFoldings.sepwall_chain3_fg(2)[\n                OF Z, of C J F\n              ]"], ["proof (prove)\nusing this:\n  gallery (C # J # Js)\n  separated_by H C J\n  separated_by H E F\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  C \\<in> f \\<turnstile> \\<C>\n  J \\<in> g \\<turnstile> \\<C>\n  J # Js = Bs @ [E, F] @ Fs\n  Bs = []\n  \\<lbrakk>gallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> chamber ?x\n  \\<lbrakk>C \\<in> f \\<turnstile> \\<C>; chamber J; chamber F;\n   separated_by {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} C J;\n   separated_by {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} J F\\<rbrakk>\n  \\<Longrightarrow> F \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. F \\<in> f \\<turnstile> \\<C> &&& C # J # Js = [] @ [C, J, F] @ Fs", "by    auto"], ["proof (state)\nthis:\n  F \\<in> f \\<turnstile> \\<C>\n  C # J # Js = [] @ [C, J, F] @ Fs\n\ngoal (2 subgoals):\n 1. Bs = [] \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<And>a list.\n       Bs = a # list \\<Longrightarrow>\n       \\<exists>f g As A B Bs E F Fs.\n          (f, g) \\<in> foldpairs \\<and>\n          A \\<in> f \\<turnstile> \\<C> \\<and>\n          B \\<in> g \\<turnstile> \\<C> \\<and>\n          E \\<in> g \\<turnstile> \\<C> \\<and>\n          F \\<in> f \\<turnstile> \\<C> \\<and>\n          (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n           C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "with fg(1,3,4)"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs\n  C \\<in> f \\<turnstile> \\<C>\n  J \\<in> g \\<turnstile> \\<C>\n  F \\<in> f \\<turnstile> \\<C>\n  C # J # Js = [] @ [C, J, F] @ Fs", "show ?thesis"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  C \\<in> f \\<turnstile> \\<C>\n  J \\<in> g \\<turnstile> \\<C>\n  F \\<in> f \\<turnstile> \\<C>\n  C # J # Js = [] @ [C, J, F] @ Fs\n\ngoal (1 subgoal):\n 1. \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "by blast"], ["proof (state)\nthis:\n  \\<exists>f g As A B Bs E F Fs.\n     (f, g) \\<in> foldpairs \\<and>\n     A \\<in> f \\<turnstile> \\<C> \\<and>\n     B \\<in> g \\<turnstile> \\<C> \\<and>\n     E \\<in> g \\<turnstile> \\<C> \\<and>\n     F \\<in> f \\<turnstile> \\<C> \\<and>\n     (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n      C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Bs = a # list \\<Longrightarrow>\n       \\<exists>f g As A B Bs E F Fs.\n          (f, g) \\<in> foldpairs \\<and>\n          A \\<in> f \\<turnstile> \\<C> \\<and>\n          B \\<in> g \\<turnstile> \\<C> \\<and>\n          E \\<in> g \\<turnstile> \\<C> \\<and>\n          F \\<in> f \\<turnstile> \\<C> \\<and>\n          (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n           C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Bs = a # list \\<Longrightarrow>\n       \\<exists>f g As A B Bs E F Fs.\n          (f, g) \\<in> foldpairs \\<and>\n          A \\<in> f \\<turnstile> \\<C> \\<and>\n          B \\<in> g \\<turnstile> \\<C> \\<and>\n          E \\<in> g \\<turnstile> \\<C> \\<and>\n          F \\<in> f \\<turnstile> \\<C> \\<and>\n          (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n           C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "case (Cons K Ks)"], ["proof (state)\nthis:\n  Bs = K # Ks\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Bs = a # list \\<Longrightarrow>\n       \\<exists>f g As A B Bs E F Fs.\n          (f, g) \\<in> foldpairs \\<and>\n          A \\<in> f \\<turnstile> \\<C> \\<and>\n          B \\<in> g \\<turnstile> \\<C> \\<and>\n          E \\<in> g \\<turnstile> \\<C> \\<and>\n          F \\<in> f \\<turnstile> \\<C> \\<and>\n          (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n           C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "have Bs: \"Bs = K#Ks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bs = K # Ks", "by fact"], ["proof (state)\nthis:\n  Bs = K # Ks\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Bs = a # list \\<Longrightarrow>\n       \\<exists>f g As A B Bs E F Fs.\n          (f, g) \\<in> foldpairs \\<and>\n          A \\<in> f \\<turnstile> \\<C> \\<and>\n          B \\<in> g \\<turnstile> \\<C> \\<and>\n          E \\<in> g \\<turnstile> \\<C> \\<and>\n          F \\<in> f \\<turnstile> \\<C> \\<and>\n          (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n           C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "proof (cases \"E\\<in>f\\<turnstile>\\<C>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. E \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "case True"], ["proof (state)\nthis:\n  E \\<in> f \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. E \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "from CCons(2) split1(1) Bs"], ["proof (chain)\npicking this:\n  gallery (C # J # Js)\n  J # Js = Bs @ [E, F] @ Fs\n  Bs = K # Ks", "have \"gallery (J#Ks@[E])\""], ["proof (prove)\nusing this:\n  gallery (C # J # Js)\n  J # Js = Bs @ [E, F] @ Fs\n  Bs = K # Ks\n\ngoal (1 subgoal):\n 1. gallery (J # Ks @ [E])", "using gallery_Cons_reduce[of C \"J#Ks@E#F#Fs\"]\n                gallery_append_reduce1[of \"J#Ks@[E]\" \"F#Fs\"]"], ["proof (prove)\nusing this:\n  gallery (C # J # Js)\n  J # Js = Bs @ [E, F] @ Fs\n  Bs = K # Ks\n  gallery (C # J # Ks @ E # F # Fs) \\<Longrightarrow>\n  gallery (J # Ks @ E # F # Fs)\n  gallery ((J # Ks @ [E]) @ F # Fs) \\<Longrightarrow> gallery (J # Ks @ [E])\n\ngoal (1 subgoal):\n 1. gallery (J # Ks @ [E])", "by    simp"], ["proof (state)\nthis:\n  gallery (J # Ks @ [E])\n\ngoal (2 subgoals):\n 1. E \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "with fg(4) True"], ["proof (chain)\npicking this:\n  J \\<in> g \\<turnstile> \\<C>\n  E \\<in> f \\<turnstile> \\<C>\n  gallery (J # Ks @ [E])", "obtain Ls L M Ms\n          where LsLMMs: \"L\\<in>g\\<turnstile>\\<C>\" \"M\\<in>f\\<turnstile>\\<C>\" \"J#Ks@[E] = Ls@L#M#Ms\""], ["proof (prove)\nusing this:\n  J \\<in> g \\<turnstile> \\<C>\n  E \\<in> f \\<turnstile> \\<C>\n  gallery (J # Ks @ [E])\n\ngoal (1 subgoal):\n 1. (\\<And>L M Ls Ms.\n        \\<lbrakk>L \\<in> g \\<turnstile> \\<C>; M \\<in> f \\<turnstile> \\<C>;\n         J # Ks @ [E] = Ls @ L # M # Ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using OpposedThinChamberComplexFoldings.split_gallery_gf[\n                  OF Z, of J E Ks\n                ]"], ["proof (prove)\nusing this:\n  J \\<in> g \\<turnstile> \\<C>\n  E \\<in> f \\<turnstile> \\<C>\n  gallery (J # Ks @ [E])\n  \\<lbrakk>J \\<in> g \\<turnstile> \\<C>; E \\<in> f \\<turnstile> \\<C>;\n   gallery (J # Ks @ [E])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>As A B Bs.\n                       A \\<in> g \\<turnstile> \\<C> \\<and>\n                       B \\<in> f \\<turnstile> \\<C> \\<and>\n                       J # Ks @ [E] = As @ A # B # Bs\n\ngoal (1 subgoal):\n 1. (\\<And>L M Ls Ms.\n        \\<lbrakk>L \\<in> g \\<turnstile> \\<C>; M \\<in> f \\<turnstile> \\<C>;\n         J # Ks @ [E] = Ls @ L # M # Ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    blast"], ["proof (state)\nthis:\n  L \\<in> g \\<turnstile> \\<C>\n  M \\<in> f \\<turnstile> \\<C>\n  J # Ks @ [E] = Ls @ L # M # Ms\n\ngoal (2 subgoals):\n 1. E \\<in> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "proof (cases Ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. Ls = [] \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<And>a list.\n       Ls = a # list \\<Longrightarrow>\n       \\<exists>f g As A B Bs E F Fs.\n          (f, g) \\<in> foldpairs \\<and>\n          A \\<in> f \\<turnstile> \\<C> \\<and>\n          B \\<in> g \\<turnstile> \\<C> \\<and>\n          E \\<in> g \\<turnstile> \\<C> \\<and>\n          F \\<in> f \\<turnstile> \\<C> \\<and>\n          (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n           C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "case Nil"], ["proof (state)\nthis:\n  Ls = []\n\ngoal (2 subgoals):\n 1. Ls = [] \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<And>a list.\n       Ls = a # list \\<Longrightarrow>\n       \\<exists>f g As A B Bs E F Fs.\n          (f, g) \\<in> foldpairs \\<and>\n          A \\<in> f \\<turnstile> \\<C> \\<and>\n          B \\<in> g \\<turnstile> \\<C> \\<and>\n          E \\<in> g \\<turnstile> \\<C> \\<and>\n          F \\<in> f \\<turnstile> \\<C> \\<and>\n          (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n           C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "with split1(1) Bs LsLMMs(3)"], ["proof (chain)\npicking this:\n  J # Js = Bs @ [E, F] @ Fs\n  Bs = K # Ks\n  J # Ks @ [E] = Ls @ L # M # Ms\n  Ls = []", "have \"C#J#Js = []@[C,J,M]@(Ms@F#Fs)\""], ["proof (prove)\nusing this:\n  J # Js = Bs @ [E, F] @ Fs\n  Bs = K # Ks\n  J # Ks @ [E] = Ls @ L # M # Ms\n  Ls = []\n\ngoal (1 subgoal):\n 1. C # J # Js = [] @ [C, J, M] @ Ms @ F # Fs", "by   simp"], ["proof (state)\nthis:\n  C # J # Js = [] @ [C, J, M] @ Ms @ F # Fs\n\ngoal (2 subgoals):\n 1. Ls = [] \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<And>a list.\n       Ls = a # list \\<Longrightarrow>\n       \\<exists>f g As A B Bs E F Fs.\n          (f, g) \\<in> foldpairs \\<and>\n          A \\<in> f \\<turnstile> \\<C> \\<and>\n          B \\<in> g \\<turnstile> \\<C> \\<and>\n          E \\<in> g \\<turnstile> \\<C> \\<and>\n          F \\<in> f \\<turnstile> \\<C> \\<and>\n          (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n           C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "with fg(1,3,4) LsLMMs(2)"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs\n  C \\<in> f \\<turnstile> \\<C>\n  J \\<in> g \\<turnstile> \\<C>\n  M \\<in> f \\<turnstile> \\<C>\n  C # J # Js = [] @ [C, J, M] @ Ms @ F # Fs", "show ?thesis"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  C \\<in> f \\<turnstile> \\<C>\n  J \\<in> g \\<turnstile> \\<C>\n  M \\<in> f \\<turnstile> \\<C>\n  C # J # Js = [] @ [C, J, M] @ Ms @ F # Fs\n\ngoal (1 subgoal):\n 1. \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "by blast"], ["proof (state)\nthis:\n  \\<exists>f g As A B Bs E F Fs.\n     (f, g) \\<in> foldpairs \\<and>\n     A \\<in> f \\<turnstile> \\<C> \\<and>\n     B \\<in> g \\<turnstile> \\<C> \\<and>\n     E \\<in> g \\<turnstile> \\<C> \\<and>\n     F \\<in> f \\<turnstile> \\<C> \\<and>\n     (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n      C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Ls = a # list \\<Longrightarrow>\n       \\<exists>f g As A B Bs E F Fs.\n          (f, g) \\<in> foldpairs \\<and>\n          A \\<in> f \\<turnstile> \\<C> \\<and>\n          B \\<in> g \\<turnstile> \\<C> \\<and>\n          E \\<in> g \\<turnstile> \\<C> \\<and>\n          F \\<in> f \\<turnstile> \\<C> \\<and>\n          (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n           C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Ls = a # list \\<Longrightarrow>\n       \\<exists>f g As A B Bs E F Fs.\n          (f, g) \\<in> foldpairs \\<and>\n          A \\<in> f \\<turnstile> \\<C> \\<and>\n          B \\<in> g \\<turnstile> \\<C> \\<and>\n          E \\<in> g \\<turnstile> \\<C> \\<and>\n          F \\<in> f \\<turnstile> \\<C> \\<and>\n          (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n           C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "case (Cons N Ns)"], ["proof (state)\nthis:\n  Ls = N # Ns\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Ls = a # list \\<Longrightarrow>\n       \\<exists>f g As A B Bs E F Fs.\n          (f, g) \\<in> foldpairs \\<and>\n          A \\<in> f \\<turnstile> \\<C> \\<and>\n          B \\<in> g \\<turnstile> \\<C> \\<and>\n          E \\<in> g \\<turnstile> \\<C> \\<and>\n          F \\<in> f \\<turnstile> \\<C> \\<and>\n          (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n           C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "with split1(1) Bs LsLMMs(3)"], ["proof (chain)\npicking this:\n  J # Js = Bs @ [E, F] @ Fs\n  Bs = K # Ks\n  J # Ks @ [E] = Ls @ L # M # Ms\n  Ls = N # Ns", "have \"C#J#Js = []@[C,J]@Ns@[L,M]@(Ms@F#Fs)\""], ["proof (prove)\nusing this:\n  J # Js = Bs @ [E, F] @ Fs\n  Bs = K # Ks\n  J # Ks @ [E] = Ls @ L # M # Ms\n  Ls = N # Ns\n\ngoal (1 subgoal):\n 1. C # J # Js = [] @ [C, J] @ Ns @ [L, M] @ Ms @ F # Fs", "by   simp"], ["proof (state)\nthis:\n  C # J # Js = [] @ [C, J] @ Ns @ [L, M] @ Ms @ F # Fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       Ls = a # list \\<Longrightarrow>\n       \\<exists>f g As A B Bs E F Fs.\n          (f, g) \\<in> foldpairs \\<and>\n          A \\<in> f \\<turnstile> \\<C> \\<and>\n          B \\<in> g \\<turnstile> \\<C> \\<and>\n          E \\<in> g \\<turnstile> \\<C> \\<and>\n          F \\<in> f \\<turnstile> \\<C> \\<and>\n          (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n           C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "with fg(1,3,4) LsLMMs(1,2)"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs\n  C \\<in> f \\<turnstile> \\<C>\n  J \\<in> g \\<turnstile> \\<C>\n  L \\<in> g \\<turnstile> \\<C>\n  M \\<in> f \\<turnstile> \\<C>\n  C # J # Js = [] @ [C, J] @ Ns @ [L, M] @ Ms @ F # Fs", "show ?thesis"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  C \\<in> f \\<turnstile> \\<C>\n  J \\<in> g \\<turnstile> \\<C>\n  L \\<in> g \\<turnstile> \\<C>\n  M \\<in> f \\<turnstile> \\<C>\n  C # J # Js = [] @ [C, J] @ Ns @ [L, M] @ Ms @ F # Fs\n\ngoal (1 subgoal):\n 1. \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "by blast"], ["proof (state)\nthis:\n  \\<exists>f g As A B Bs E F Fs.\n     (f, g) \\<in> foldpairs \\<and>\n     A \\<in> f \\<turnstile> \\<C> \\<and>\n     B \\<in> g \\<turnstile> \\<C> \\<and>\n     E \\<in> g \\<turnstile> \\<C> \\<and>\n     F \\<in> f \\<turnstile> \\<C> \\<and>\n     (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n      C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f g As A B Bs E F Fs.\n     (f, g) \\<in> foldpairs \\<and>\n     A \\<in> f \\<turnstile> \\<C> \\<and>\n     B \\<in> g \\<turnstile> \\<C> \\<and>\n     E \\<in> g \\<turnstile> \\<C> \\<and>\n     F \\<in> f \\<turnstile> \\<C> \\<and>\n     (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n      C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n\ngoal (1 subgoal):\n 1. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "case False"], ["proof (state)\nthis:\n  E \\<notin> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "with Hwall(2,3) fg(2) split1(1) Cons"], ["proof (chain)\npicking this:\n  separated_by H C J\n  separated_by H E F\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  J # Js = Bs @ [E, F] @ Fs\n  Bs = K # Ks\n  E \\<notin> f \\<turnstile> \\<C>", "have  \"E\\<in>g\\<turnstile>\\<C>\" \"F\\<in>f\\<turnstile>\\<C>\" \"C#J#Js = []@[C,J]@Ks@[E,F]@Fs\""], ["proof (prove)\nusing this:\n  separated_by H C J\n  separated_by H E F\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  J # Js = Bs @ [E, F] @ Fs\n  Bs = K # Ks\n  E \\<notin> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. E \\<in> g \\<turnstile> \\<C> &&&\n    F \\<in> f \\<turnstile> \\<C> &&&\n    C # J # Js = [] @ [C, J] @ Ks @ [E, F] @ Fs", "using OpposedThinChamberComplexFoldings.separated_by_this_wall_fg[\n                  OF Z\n                ]\n                separated_by_in_other[of \"f\\<turnstile>\\<C>\" \"g\\<turnstile>\\<C>\"]"], ["proof (prove)\nusing this:\n  separated_by H C J\n  separated_by H E F\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  J # Js = Bs @ [E, F] @ Fs\n  Bs = K # Ks\n  E \\<notin> f \\<turnstile> \\<C>\n  \\<lbrakk>separated_by {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} ?C ?D;\n   ?C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> ?D \\<in> g \\<turnstile> \\<C>\n  \\<lbrakk>separated_by {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} ?x ?y;\n   ?x \\<notin> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> g \\<turnstile> \\<C> \\<and>\n                    ?y \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. E \\<in> g \\<turnstile> \\<C> &&&\n    F \\<in> f \\<turnstile> \\<C> &&&\n    C # J # Js = [] @ [C, J] @ Ks @ [E, F] @ Fs", "by    auto"], ["proof (state)\nthis:\n  E \\<in> g \\<turnstile> \\<C>\n  F \\<in> f \\<turnstile> \\<C>\n  C # J # Js = [] @ [C, J] @ Ks @ [E, F] @ Fs\n\ngoal (1 subgoal):\n 1. E \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "with fg(1,3,4)"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs\n  C \\<in> f \\<turnstile> \\<C>\n  J \\<in> g \\<turnstile> \\<C>\n  E \\<in> g \\<turnstile> \\<C>\n  F \\<in> f \\<turnstile> \\<C>\n  C # J # Js = [] @ [C, J] @ Ks @ [E, F] @ Fs", "show ?thesis"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  C \\<in> f \\<turnstile> \\<C>\n  J \\<in> g \\<turnstile> \\<C>\n  E \\<in> g \\<turnstile> \\<C>\n  F \\<in> f \\<turnstile> \\<C>\n  C # J # Js = [] @ [C, J] @ Ks @ [E, F] @ Fs\n\ngoal (1 subgoal):\n 1. \\<exists>f g As A B Bs E F Fs.\n       (f, g) \\<in> foldpairs \\<and>\n       A \\<in> f \\<turnstile> \\<C> \\<and>\n       B \\<in> g \\<turnstile> \\<C> \\<and>\n       E \\<in> g \\<turnstile> \\<C> \\<and>\n       F \\<in> f \\<turnstile> \\<C> \\<and>\n       (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n        C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)", "by blast"], ["proof (state)\nthis:\n  \\<exists>f g As A B Bs E F Fs.\n     (f, g) \\<in> foldpairs \\<and>\n     A \\<in> f \\<turnstile> \\<C> \\<and>\n     B \\<in> g \\<turnstile> \\<C> \\<and>\n     E \\<in> g \\<turnstile> \\<C> \\<and>\n     F \\<in> f \\<turnstile> \\<C> \\<and>\n     (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n      C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f g As A B Bs E F Fs.\n     (f, g) \\<in> foldpairs \\<and>\n     A \\<in> f \\<turnstile> \\<C> \\<and>\n     B \\<in> g \\<turnstile> \\<C> \\<and>\n     E \\<in> g \\<turnstile> \\<C> \\<and>\n     F \\<in> f \\<turnstile> \\<C> \\<and>\n     (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n      C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f g As A B Bs E F Fs.\n     (f, g) \\<in> foldpairs \\<and>\n     A \\<in> f \\<turnstile> \\<C> \\<and>\n     B \\<in> g \\<turnstile> \\<C> \\<and>\n     E \\<in> g \\<turnstile> \\<C> \\<and>\n     F \\<in> f \\<turnstile> \\<C> \\<and>\n     (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n      C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f g As A B Bs E F Fs.\n     (f, g) \\<in> foldpairs \\<and>\n     A \\<in> f \\<turnstile> \\<C> \\<and>\n     B \\<in> g \\<turnstile> \\<C> \\<and>\n     E \\<in> g \\<turnstile> \\<C> \\<and>\n     F \\<in> f \\<turnstile> \\<C> \\<and>\n     (C # J # Js = As @ [A, B, F] @ Fs \\<or>\n      C # J # Js = As @ [A, B] @ Bs @ [E, F] @ Fs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>gallery []; {} \\<notin> set (wall_crossings []);\n     \\<not> distinct (wall_crossings [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                         (f, g) \\<in> foldpairs \\<and>\n                         A \\<in> f \\<turnstile> \\<C> \\<and>\n                         B \\<in> g \\<turnstile> \\<C> \\<and>\n                         E \\<in> g \\<turnstile> \\<C> \\<and>\n                         F \\<in> f \\<turnstile> \\<C> \\<and>\n                         ([] = As @ [A, B, F] @ Fs \\<or>\n                          [] = As @ [A, B] @ Bs @ [E, F] @ Fs)\n 2. \\<And>x.\n       \\<lbrakk>gallery [x]; {} \\<notin> set (wall_crossings [x]);\n        \\<not> distinct (wall_crossings [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                            (f, g) \\<in> foldpairs \\<and>\n                            A \\<in> f \\<turnstile> \\<C> \\<and>\n                            B \\<in> g \\<turnstile> \\<C> \\<and>\n                            E \\<in> g \\<turnstile> \\<C> \\<and>\n                            F \\<in> f \\<turnstile> \\<C> \\<and>\n                            ([x] = As @ [A, B, F] @ Fs \\<or>\n                             [x] = As @ [A, B] @ Bs @ [E, F] @ Fs)", "qed auto"], ["", "lemma not_min_gallery_double_split:\n  \"\\<lbrakk> gallery Cs; \\<not> min_gallery Cs; {} \\<notin> set (wall_crossings Cs) \\<rbrakk> \\<Longrightarrow>\n    \\<exists>f g As A B Bs E F Fs.\n      (f,g)\\<in>foldpairs \\<and> A\\<in>f\\<turnstile>\\<C> \\<and> B\\<in>g\\<turnstile>\\<C> \\<and> E\\<in>g\\<turnstile>\\<C> \\<and> F\\<in>f\\<turnstile>\\<C> \\<and>\n      ( Cs = As@[A,B,F]@Fs \\<or> Cs = As@[A,B]@Bs@[E,F]@Fs )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gallery Cs; \\<not> min_gallery Cs;\n     {} \\<notin> set (wall_crossings Cs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                         (f, g) \\<in> foldpairs \\<and>\n                         A \\<in> f \\<turnstile> \\<C> \\<and>\n                         B \\<in> g \\<turnstile> \\<C> \\<and>\n                         E \\<in> g \\<turnstile> \\<C> \\<and>\n                         F \\<in> f \\<turnstile> \\<C> \\<and>\n                         (Cs = As @ [A, B, F] @ Fs \\<or>\n                          Cs = As @ [A, B] @ Bs @ [E, F] @ Fs)", "using not_min_gallery_double_crosses_wall not_distinct_crossings_split_gallery"], ["proof (prove)\nusing this:\n  \\<lbrakk>gallery ?Cs; \\<not> min_gallery ?Cs;\n   {} \\<notin> set (wall_crossings ?Cs)\\<rbrakk>\n  \\<Longrightarrow> \\<not> distinct (wall_crossings ?Cs)\n  \\<lbrakk>gallery ?Cs; {} \\<notin> set (wall_crossings ?Cs);\n   \\<not> distinct (wall_crossings ?Cs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                       (f, g) \\<in> foldpairs \\<and>\n                       A \\<in> f \\<turnstile> \\<C> \\<and>\n                       B \\<in> g \\<turnstile> \\<C> \\<and>\n                       E \\<in> g \\<turnstile> \\<C> \\<and>\n                       F \\<in> f \\<turnstile> \\<C> \\<and>\n                       (?Cs = As @ [A, B, F] @ Fs \\<or>\n                        ?Cs = As @ [A, B] @ Bs @ [E, F] @ Fs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>gallery Cs; \\<not> min_gallery Cs;\n     {} \\<notin> set (wall_crossings Cs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                         (f, g) \\<in> foldpairs \\<and>\n                         A \\<in> f \\<turnstile> \\<C> \\<and>\n                         B \\<in> g \\<turnstile> \\<C> \\<and>\n                         E \\<in> g \\<turnstile> \\<C> \\<and>\n                         F \\<in> f \\<turnstile> \\<C> \\<and>\n                         (Cs = As @ [A, B, F] @ Fs \\<or>\n                          Cs = As @ [A, B] @ Bs @ [E, F] @ Fs)", "by    simp"], ["", "end"], ["", "(* context ThinChamberComplex *)"], ["", "subsection \\<open>Thin chamber complexes with many foldings\\<close>"], ["", "text \\<open>\n  Here we begin to examine thin chamber complexes in which every pair of adjacent chambers affords a\n  pair of opposed foldings of the complex. This condition will ultimately be shown to be sufficient\n  to ensure that a thin chamber complex is isomorphic to some Coxeter complex.\n\\<close>"], ["", "subsubsection \\<open>Locale definition and basic facts\\<close>"], ["", "locale ThinChamberComplexManyFoldings = ThinChamberComplex X\n  for   X  :: \"'a set set\"\n+ fixes C0 :: \"'a set\"\n  assumes fundchamber: \"chamber C0\"\n  and     ex_walls   :\n    \"\\<lbrakk> chamber C; chamber D; C\\<sim>D; C\\<noteq>D \\<rbrakk> \\<Longrightarrow>\n      \\<exists>f g. OpposedThinChamberComplexFoldings X f g C \\<and> D=g`C\""], ["", "lemma (in ThinChamberComplex) ThinChamberComplexManyFoldingsI:\n  assumes \"chamber C0\"\n  and     \"\\<And>C D. \\<lbrakk> chamber C; chamber D; C\\<sim>D; C\\<noteq>D \\<rbrakk> \\<Longrightarrow>\n            \\<exists>f g. OpposedThinChamberComplexFoldings X f g C \\<and> D=g`C\"\n  shows   \"ThinChamberComplexManyFoldings X C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ThinChamberComplexManyFoldings X C0", "using   assms"], ["proof (prove)\nusing this:\n  chamber C0\n  \\<lbrakk>chamber ?C1; chamber ?D1; ?C1 \\<sim> ?D1;\n   ?C1 \\<noteq> ?D1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f g.\n                       OpposedThinChamberComplexFoldings X f g ?C1 \\<and>\n                       ?D1 = g ` ?C1\n\ngoal (1 subgoal):\n 1. ThinChamberComplexManyFoldings X C0", "by      (intro_locales, unfold_locales, fast)"], ["", "lemma (in ThinChamberComplexManyFoldings) wall_crossings_subset_walls_betw:\n  assumes \"min_gallery (C#Cs@[D])\"\n  shows   \"set (wall_crossings (C#Cs@[D])) \\<subseteq> walls_betw C D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (walls_betw C D) (set (wall_crossings (C # Cs @ [D])))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (wall_crossings (C # Cs @ [D])) \\<Longrightarrow>\n       x \\<in> walls_betw C D", "fix H"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (wall_crossings (C # Cs @ [D])) \\<Longrightarrow>\n       x \\<in> walls_betw C D", "assume \"H \\<in> set (wall_crossings (C#Cs@[D]))\""], ["proof (state)\nthis:\n  H \\<in> set (wall_crossings (C # Cs @ [D]))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (wall_crossings (C # Cs @ [D])) \\<Longrightarrow>\n       x \\<in> walls_betw C D", "from this"], ["proof (chain)\npicking this:\n  H \\<in> set (wall_crossings (C # Cs @ [D]))", "obtain As A B Bs\n    where H: \"C#Cs@[D] = As@[A,B]@Bs\" \"H=the_wall_betw A B\""], ["proof (prove)\nusing this:\n  H \\<in> set (wall_crossings (C # Cs @ [D]))\n\ngoal (1 subgoal):\n 1. (\\<And>As A B Bs.\n        \\<lbrakk>C # Cs @ [D] = As @ [A, B] @ Bs;\n         H =\n         THE_default {}\n          (\\<lambda>H.\n              H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n              separated_by H A B)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using in_set_wall_crossings_decomp"], ["proof (prove)\nusing this:\n  H \\<in> set (wall_crossings (C # Cs @ [D]))\n  ?H \\<in> set (wall_crossings ?Cs) \\<Longrightarrow>\n  \\<exists>As A B Bs.\n     ?Cs = As @ [A, B] @ Bs \\<and>\n     ?H =\n     THE_default {}\n      (\\<lambda>H.\n          H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                      {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n          separated_by H A B)\n\ngoal (1 subgoal):\n 1. (\\<And>As A B Bs.\n        \\<lbrakk>C # Cs @ [D] = As @ [A, B] @ Bs;\n         H =\n         THE_default {}\n          (\\<lambda>H.\n              H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                          {{f \\<turnstile> \\<C>,\n                            g \\<turnstile> \\<C>}}) \\<and>\n              separated_by H A B)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    blast"], ["proof (state)\nthis:\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (wall_crossings (C # Cs @ [D])) \\<Longrightarrow>\n       x \\<in> walls_betw C D", "from assms"], ["proof (chain)\npicking this:\n  min_gallery (C # Cs @ [D])", "have pgal: \"pgallery (C#Cs@[D])\""], ["proof (prove)\nusing this:\n  min_gallery (C # Cs @ [D])\n\ngoal (1 subgoal):\n 1. pgallery (C # Cs @ [D])", "using min_gallery_pgallery"], ["proof (prove)\nusing this:\n  min_gallery (C # Cs @ [D])\n  min_gallery ?xs \\<Longrightarrow> pgallery ?xs\n\ngoal (1 subgoal):\n 1. pgallery (C # Cs @ [D])", "by fast"], ["proof (state)\nthis:\n  pgallery (C # Cs @ [D])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (wall_crossings (C # Cs @ [D])) \\<Longrightarrow>\n       x \\<in> walls_betw C D", "with H(1)"], ["proof (chain)\npicking this:\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  pgallery (C # Cs @ [D])", "obtain f g\n    where fg: \"OpposedThinChamberComplexFoldings X f g A\" \"B=g`A\""], ["proof (prove)\nusing this:\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  pgallery (C # Cs @ [D])\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>OpposedThinChamberComplexFoldings X f g A;\n         B = g ` A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using pgalleryD_chamber pgalleryD_adj\n          binrelchain_append_reduce2[of adjacent As \"[A,B]@Bs\"]\n          pgalleryD_distinct[of \"As@[A,B]@Bs\"] ex_walls[of A B]"], ["proof (prove)\nusing this:\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  pgallery (C # Cs @ [D])\n  \\<lbrakk>pgallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> chamber ?x\n  pgallery ?xs \\<Longrightarrow> adjacentchain ?xs\n  adjacentchain (As @ [A, B] @ Bs) \\<Longrightarrow>\n  adjacentchain ([A, B] @ Bs)\n  pgallery (As @ [A, B] @ Bs) \\<Longrightarrow> distinct (As @ [A, B] @ Bs)\n  \\<lbrakk>chamber A; chamber B; A \\<sim> B; A \\<noteq> B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f g.\n                       OpposedThinChamberComplexFoldings X f g A \\<and>\n                       B = g ` A\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>OpposedThinChamberComplexFoldings X f g A;\n         B = g ` A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g A\n  B = g ` A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (wall_crossings (C # Cs @ [D])) \\<Longrightarrow>\n       x \\<in> walls_betw C D", "from H(2) fg"], ["proof (chain)\npicking this:\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B)\n  OpposedThinChamberComplexFoldings X f g A\n  B = g ` A", "have H': \"A\\<in>f\\<turnstile>\\<C>\" \"B\\<in>g\\<turnstile>\\<C>\" \"H = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\" \"H\\<in>walls\""], ["proof (prove)\nusing this:\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B)\n  OpposedThinChamberComplexFoldings X f g A\n  B = g ` A\n\ngoal (1 subgoal):\n 1. (A \\<in> f \\<turnstile> \\<C> &&& B \\<in> g \\<turnstile> \\<C>) &&&\n    H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} &&&\n    H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})", "using OpposedThinChamberComplexFoldings.basech_halfchsys[\n            OF fg(1)\n          ]\n          OpposedThinChamberComplexFoldings.chambers(2)[OF fg(1)]\n          OpposedThinChamberComplexFoldings.this_wall_betwI[OF fg(1)]\n          foldpairs_def"], ["proof (prove)\nusing this:\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B)\n  OpposedThinChamberComplexFoldings X f g A\n  B = g ` A\n  A \\<in> f \\<turnstile> \\<C>\n  g ` A \\<in> g \\<turnstile> \\<C>\n  A \\<sim> g ` A\n  \\<lbrakk>?C \\<in> f \\<turnstile> \\<C>; ?D \\<in> g \\<turnstile> \\<C>;\n   ?C \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> THE_default {}\n                     (\\<lambda>H.\n                         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                                     {{f \\<turnstile> \\<C>,\n g \\<turnstile> \\<C>}}) \\<and>\n                         separated_by H ?C ?D) =\n                    {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n\ngoal (1 subgoal):\n 1. (A \\<in> f \\<turnstile> \\<C> &&& B \\<in> g \\<turnstile> \\<C>) &&&\n    H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} &&&\n    H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})", "by    auto"], ["proof (state)\nthis:\n  A \\<in> f \\<turnstile> \\<C>\n  B \\<in> g \\<turnstile> \\<C>\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (wall_crossings (C # Cs @ [D])) \\<Longrightarrow>\n       x \\<in> walls_betw C D", "have CD: \"C \\<in> f\\<turnstile>\\<C> \\<union> g\\<turnstile>\\<C>\" \"D \\<in> f\\<turnstile>\\<C> \\<union> g\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> \\<C> \\<union> g \\<turnstile> \\<C> &&&\n    D \\<in> f \\<turnstile> \\<C> \\<union> g \\<turnstile> \\<C>", "using pgal pgalleryD_chamber chamber_system_def\n          OpposedThinChamberComplexFoldings.halfchsys_decomp(1)[\n            OF fg(1)\n          ]"], ["proof (prove)\nusing this:\n  pgallery (C # Cs @ [D])\n  \\<lbrakk>pgallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> chamber ?x\n  \\<C> \\<equiv> Collect chamber\n  \\<C> = f \\<turnstile> \\<C> \\<union> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> \\<C> \\<union> g \\<turnstile> \\<C> &&&\n    D \\<in> f \\<turnstile> \\<C> \\<union> g \\<turnstile> \\<C>", "by    auto"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> \\<C> \\<union> g \\<turnstile> \\<C>\n  D \\<in> f \\<turnstile> \\<C> \\<union> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (wall_crossings (C # Cs @ [D])) \\<Longrightarrow>\n       x \\<in> walls_betw C D", "show \"H \\<in> walls_betw C D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "proof (cases Bs As rule: two_lists_cases_snoc_Cons')"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>Bs = []; As = []\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<And>y ys.\n       \\<lbrakk>Bs = []; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D\n 3. \\<And>xs x.\n       \\<lbrakk>Bs = xs @ [x]; As = []\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D\n 4. \\<And>xs x y ys.\n       \\<lbrakk>Bs = xs @ [x]; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D", "case both_Nil"], ["proof (state)\nthis:\n  Bs = []\n  As = []\n\ngoal (4 subgoals):\n 1. \\<lbrakk>Bs = []; As = []\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<And>y ys.\n       \\<lbrakk>Bs = []; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D\n 3. \\<And>xs x.\n       \\<lbrakk>Bs = xs @ [x]; As = []\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D\n 4. \\<And>xs x y ys.\n       \\<lbrakk>Bs = xs @ [x]; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D", "with H"], ["proof (chain)\npicking this:\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B)\n  Bs = []\n  As = []", "show ?thesis"], ["proof (prove)\nusing this:\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B)\n  Bs = []\n  As = []\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "using H'(3) the_wall_betw_nempty[of A B]"], ["proof (prove)\nusing this:\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B)\n  Bs = []\n  As = []\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B) \\<noteq>\n  {} \\<Longrightarrow>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B)\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B) \\<noteq>\n  {} \\<Longrightarrow>\n  separated_by\n   (THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H A B))\n   A B\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "unfolding walls_betw_def"], ["proof (prove)\nusing this:\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  H =\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B)\n  Bs = []\n  As = []\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B) \\<noteq>\n  {} \\<Longrightarrow>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B)\n  \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n            {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H A B) \\<noteq>\n  {} \\<Longrightarrow>\n  separated_by\n   (THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H A B))\n   A B\n\ngoal (1 subgoal):\n 1. H \\<in> {H \\<in> \\<Union>(f, g)\\<in>foldpairs.\n                        {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}.\n             separated_by H C D}", "by force"], ["proof (state)\nthis:\n  H \\<in> walls_betw C D\n\ngoal (3 subgoals):\n 1. \\<And>y ys.\n       \\<lbrakk>Bs = []; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<And>xs x.\n       \\<lbrakk>Bs = xs @ [x]; As = []\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D\n 3. \\<And>xs x y ys.\n       \\<lbrakk>Bs = xs @ [x]; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>y ys.\n       \\<lbrakk>Bs = []; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<And>xs x.\n       \\<lbrakk>Bs = xs @ [x]; As = []\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D\n 3. \\<And>xs x y ys.\n       \\<lbrakk>Bs = xs @ [x]; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D", "case (Nil1 E Es)"], ["proof (state)\nthis:\n  Bs = []\n  As = E # Es\n\ngoal (3 subgoals):\n 1. \\<And>y ys.\n       \\<lbrakk>Bs = []; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<And>xs x.\n       \\<lbrakk>Bs = xs @ [x]; As = []\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D\n 3. \\<And>xs x y ys.\n       \\<lbrakk>Bs = xs @ [x]; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "proof (cases \"C\\<in>f\\<turnstile>\\<C>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D\n 2. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D", "case True"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D\n 2. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D", "with Nil1 H(1)"], ["proof (chain)\npicking this:\n  Bs = []\n  As = E # Es\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  C \\<in> f \\<turnstile> \\<C>", "have \"separated_by H C D\""], ["proof (prove)\nusing this:\n  Bs = []\n  As = E # Es\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  C \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. separated_by H C D", "using H'(2,3)"], ["proof (prove)\nusing this:\n  Bs = []\n  As = E # Es\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  C \\<in> f \\<turnstile> \\<C>\n  B \\<in> g \\<turnstile> \\<C>\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n\ngoal (1 subgoal):\n 1. separated_by H C D", "by (auto intro: separated_byI)"], ["proof (state)\nthis:\n  separated_by H C D\n\ngoal (2 subgoals):\n 1. C \\<in> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D\n 2. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D", "thus ?thesis"], ["proof (prove)\nusing this:\n  separated_by H C D\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "using H'(4)"], ["proof (prove)\nusing this:\n  separated_by H C D\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "unfolding walls_betw_def"], ["proof (prove)\nusing this:\n  separated_by H C D\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n\ngoal (1 subgoal):\n 1. H \\<in> {H \\<in> \\<Union>(f, g)\\<in>foldpairs.\n                        {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}.\n             separated_by H C D}", "by simp"], ["proof (state)\nthis:\n  H \\<in> walls_betw C D\n\ngoal (1 subgoal):\n 1. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D", "case False"], ["proof (state)\nthis:\n  C \\<notin> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D", "with assms Nil1 H(1)"], ["proof (chain)\npicking this:\n  min_gallery (C # Cs @ [D])\n  Bs = []\n  As = E # Es\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  C \\<notin> f \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  min_gallery (C # Cs @ [D])\n  Bs = []\n  As = E # Es\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  C \\<notin> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "using OpposedThinChamberComplexFoldings.foldg[\n                OF fg(1)\n              ]\n              CD(1) H'(1,2) pgal pgallery\n              OpposedThinChamberComplexFoldings.flopped_half_chamber_systems_gf[\n                OF fg(1)\n              ]\n              ThinChamberComplexFolding.gallery_double_cross_not_minimal1[\n                of X g E A B Es \"[]\"\n              ]"], ["proof (prove)\nusing this:\n  min_gallery (C # Cs @ [D])\n  Bs = []\n  As = E # Es\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  C \\<notin> f \\<turnstile> \\<C>\n  ThinChamberComplexFolding X g\n  C \\<in> f \\<turnstile> \\<C> \\<union> g \\<turnstile> \\<C>\n  A \\<in> f \\<turnstile> \\<C>\n  B \\<in> g \\<turnstile> \\<C>\n  pgallery (C # Cs @ [D])\n  pgallery ?xs \\<Longrightarrow> gallery ?xs\n  \\<C> - g \\<turnstile> \\<C> = f \\<turnstile> \\<C>\n  \\<lbrakk>ThinChamberComplexFolding X g; E \\<in> g \\<turnstile> \\<C>;\n   A \\<in> \\<C> - g \\<turnstile> \\<C>; B \\<in> g \\<turnstile> \\<C>;\n   gallery (E # Es @ A # [] @ [B])\\<rbrakk>\n  \\<Longrightarrow> \\<not> min_gallery (E # Es @ A # [] @ [B])\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "by    force"], ["proof (state)\nthis:\n  H \\<in> walls_betw C D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H \\<in> walls_betw C D\n\ngoal (2 subgoals):\n 1. \\<And>xs x.\n       \\<lbrakk>Bs = xs @ [x]; As = []\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<And>xs x y ys.\n       \\<lbrakk>Bs = xs @ [x]; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs x.\n       \\<lbrakk>Bs = xs @ [x]; As = []\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<And>xs x y ys.\n       \\<lbrakk>Bs = xs @ [x]; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D", "case (Nil2 Fs F)"], ["proof (state)\nthis:\n  Bs = Fs @ [F]\n  As = []\n\ngoal (2 subgoals):\n 1. \\<And>xs x.\n       \\<lbrakk>Bs = xs @ [x]; As = []\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<And>xs x y ys.\n       \\<lbrakk>Bs = xs @ [x]; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "proof (cases \"D\\<in>f\\<turnstile>\\<C>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. D \\<in> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D\n 2. D \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D", "case True"], ["proof (state)\nthis:\n  D \\<in> f \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. D \\<in> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D\n 2. D \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D", "with assms Nil2 H(1)"], ["proof (chain)\npicking this:\n  min_gallery (C # Cs @ [D])\n  Bs = Fs @ [F]\n  As = []\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  D \\<in> f \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  min_gallery (C # Cs @ [D])\n  Bs = Fs @ [F]\n  As = []\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  D \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "using OpposedThinChamberComplexFoldings.foldf[\n                OF fg(1)\n              ]\n              H'(1,2) pgal pgallery\n              OpposedThinChamberComplexFoldings.flopped_half_chamber_systems_fg[\n                OF fg(1)\n              ]\n              ThinChamberComplexFolding.gallery_double_cross_not_minimal_Cons1[\n                of X f\n              ]"], ["proof (prove)\nusing this:\n  min_gallery (C # Cs @ [D])\n  Bs = Fs @ [F]\n  As = []\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  D \\<in> f \\<turnstile> \\<C>\n  ThinChamberComplexFolding X f\n  A \\<in> f \\<turnstile> \\<C>\n  B \\<in> g \\<turnstile> \\<C>\n  pgallery (C # Cs @ [D])\n  pgallery ?xs \\<Longrightarrow> gallery ?xs\n  \\<C> - f \\<turnstile> \\<C> = g \\<turnstile> \\<C>\n  \\<lbrakk>ThinChamberComplexFolding X f; ?B \\<in> f \\<turnstile> \\<C>;\n   ?C \\<in> \\<C> - f \\<turnstile> \\<C>; ?D \\<in> f \\<turnstile> \\<C>;\n   gallery (?B # ?C # ?Cs @ [?D])\\<rbrakk>\n  \\<Longrightarrow> \\<not> min_gallery (?B # ?C # ?Cs @ [?D])\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "by    force"], ["proof (state)\nthis:\n  H \\<in> walls_betw C D\n\ngoal (1 subgoal):\n 1. D \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D", "case False"], ["proof (state)\nthis:\n  D \\<notin> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. D \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D", "with Nil2 H(1)"], ["proof (chain)\npicking this:\n  Bs = Fs @ [F]\n  As = []\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  D \\<notin> f \\<turnstile> \\<C>", "have \"separated_by H C D\""], ["proof (prove)\nusing this:\n  Bs = Fs @ [F]\n  As = []\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  D \\<notin> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. separated_by H C D", "using CD(2) H'(1,3)"], ["proof (prove)\nusing this:\n  Bs = Fs @ [F]\n  As = []\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  D \\<notin> f \\<turnstile> \\<C>\n  D \\<in> f \\<turnstile> \\<C> \\<union> g \\<turnstile> \\<C>\n  A \\<in> f \\<turnstile> \\<C>\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n\ngoal (1 subgoal):\n 1. separated_by H C D", "by (auto intro: separated_byI)"], ["proof (state)\nthis:\n  separated_by H C D\n\ngoal (1 subgoal):\n 1. D \\<notin> f \\<turnstile> \\<C> \\<Longrightarrow> H \\<in> walls_betw C D", "thus ?thesis"], ["proof (prove)\nusing this:\n  separated_by H C D\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "using H'(4)"], ["proof (prove)\nusing this:\n  separated_by H C D\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "unfolding walls_betw_def"], ["proof (prove)\nusing this:\n  separated_by H C D\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n\ngoal (1 subgoal):\n 1. H \\<in> {H \\<in> \\<Union>(f, g)\\<in>foldpairs.\n                        {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}.\n             separated_by H C D}", "by simp"], ["proof (state)\nthis:\n  H \\<in> walls_betw C D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H \\<in> walls_betw C D\n\ngoal (1 subgoal):\n 1. \\<And>xs x y ys.\n       \\<lbrakk>Bs = xs @ [x]; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x y ys.\n       \\<lbrakk>Bs = xs @ [x]; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D", "case (snoc_Cons Fs F E Es)"], ["proof (state)\nthis:\n  Bs = Fs @ [F]\n  As = E # Es\n\ngoal (1 subgoal):\n 1. \\<And>xs x y ys.\n       \\<lbrakk>Bs = xs @ [x]; As = y # ys\\<rbrakk>\n       \\<Longrightarrow> H \\<in> walls_betw C D", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "proof (cases \"C\\<in>f\\<turnstile>\\<C>\" \"D\\<in>g\\<turnstile>\\<C>\" rule: two_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n     D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 3. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 4. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D", "case both"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n     D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 3. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 4. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D", "thus ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "using H'(3,4) walls_betw_def"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  walls_betw ?C ?D \\<equiv>\n  {H \\<in> \\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}.\n   separated_by H ?C ?D}\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "unfolding separated_by_def"], ["proof (prove)\nusing this:\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  walls_betw ?C ?D \\<equiv>\n  {H \\<in> \\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}.\n   \\<exists>A B. H = {A, B} \\<and> ?C \\<in> A \\<and> ?D \\<in> B}\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "by auto"], ["proof (state)\nthis:\n  H \\<in> walls_betw C D\n\ngoal (3 subgoals):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 3. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 3. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D", "case one"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<notin> g \\<turnstile> \\<C>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>C \\<in> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 3. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D", "with snoc_Cons assms H(1)"], ["proof (chain)\npicking this:\n  Bs = Fs @ [F]\n  As = E # Es\n  min_gallery (C # Cs @ [D])\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<notin> g \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  Bs = Fs @ [F]\n  As = E # Es\n  min_gallery (C # Cs @ [D])\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<notin> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "using OpposedThinChamberComplexFoldings.foldf[\n                OF fg(1)\n              ]\n              CD(2) H'(2) pgal pgallery\n              OpposedThinChamberComplexFoldings.flopped_half_chamber_systems_fg[\n                OF fg(1)\n              ]\n              ThinChamberComplexFolding.gallery_double_cross_not_minimal1[\n                of X f C B D \"Es@[A]\"\n              ]"], ["proof (prove)\nusing this:\n  Bs = Fs @ [F]\n  As = E # Es\n  min_gallery (C # Cs @ [D])\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  C \\<in> f \\<turnstile> \\<C>\n  D \\<notin> g \\<turnstile> \\<C>\n  ThinChamberComplexFolding X f\n  D \\<in> f \\<turnstile> \\<C> \\<union> g \\<turnstile> \\<C>\n  B \\<in> g \\<turnstile> \\<C>\n  pgallery (C # Cs @ [D])\n  pgallery ?xs \\<Longrightarrow> gallery ?xs\n  \\<C> - f \\<turnstile> \\<C> = g \\<turnstile> \\<C>\n  \\<lbrakk>ThinChamberComplexFolding X f; C \\<in> f \\<turnstile> \\<C>;\n   B \\<in> \\<C> - f \\<turnstile> \\<C>; D \\<in> f \\<turnstile> \\<C>;\n   gallery (C # (Es @ [A]) @ B # ?Cs @ [D])\\<rbrakk>\n  \\<Longrightarrow> \\<not> min_gallery (C # (Es @ [A]) @ B # ?Cs @ [D])\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "by    fastforce"], ["proof (state)\nthis:\n  H \\<in> walls_betw C D\n\ngoal (2 subgoals):\n 1. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D", "case other"], ["proof (state)\nthis:\n  C \\<notin> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<in> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D\n 2. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D", "with snoc_Cons assms H(1)"], ["proof (chain)\npicking this:\n  Bs = Fs @ [F]\n  As = E # Es\n  min_gallery (C # Cs @ [D])\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  C \\<notin> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  Bs = Fs @ [F]\n  As = E # Es\n  min_gallery (C # Cs @ [D])\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  C \\<notin> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "using OpposedThinChamberComplexFoldings.ThinChamberComplexFolding_g[\n                OF fg(1)\n              ]\n              CD(1) H'(1) pgal pgallery\n              OpposedThinChamberComplexFoldings.flopped_half_chamber_systems_gf[\n                OF fg(1)\n              ]\n              ThinChamberComplexFolding.gallery_double_cross_not_minimal1[\n                of X g E A F Es \"B#Fs\"\n              ]"], ["proof (prove)\nusing this:\n  Bs = Fs @ [F]\n  As = E # Es\n  min_gallery (C # Cs @ [D])\n  C # Cs @ [D] = As @ [A, B] @ Bs\n  C \\<notin> f \\<turnstile> \\<C>\n  D \\<in> g \\<turnstile> \\<C>\n  ThinChamberComplexFolding X g\n  C \\<in> f \\<turnstile> \\<C> \\<union> g \\<turnstile> \\<C>\n  A \\<in> f \\<turnstile> \\<C>\n  pgallery (C # Cs @ [D])\n  pgallery ?xs \\<Longrightarrow> gallery ?xs\n  \\<C> - g \\<turnstile> \\<C> = f \\<turnstile> \\<C>\n  \\<lbrakk>ThinChamberComplexFolding X g; E \\<in> g \\<turnstile> \\<C>;\n   A \\<in> \\<C> - g \\<turnstile> \\<C>; F \\<in> g \\<turnstile> \\<C>;\n   gallery (E # Es @ A # (B # Fs) @ [F])\\<rbrakk>\n  \\<Longrightarrow> \\<not> min_gallery (E # Es @ A # (B # Fs) @ [F])\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "by    force"], ["proof (state)\nthis:\n  H \\<in> walls_betw C D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D", "case neither"], ["proof (state)\nthis:\n  C \\<notin> f \\<turnstile> \\<C>\n  D \\<notin> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D", "hence \"separated_by {g\\<turnstile>\\<C>,f\\<turnstile>\\<C>} C D\""], ["proof (prove)\nusing this:\n  C \\<notin> f \\<turnstile> \\<C>\n  D \\<notin> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. separated_by {g \\<turnstile> \\<C>, f \\<turnstile> \\<C>} C D", "using CD"], ["proof (prove)\nusing this:\n  C \\<notin> f \\<turnstile> \\<C>\n  D \\<notin> g \\<turnstile> \\<C>\n  C \\<in> f \\<turnstile> \\<C> \\<union> g \\<turnstile> \\<C>\n  D \\<in> f \\<turnstile> \\<C> \\<union> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. separated_by {g \\<turnstile> \\<C>, f \\<turnstile> \\<C>} C D", "by (auto intro: separated_byI)"], ["proof (state)\nthis:\n  separated_by {g \\<turnstile> \\<C>, f \\<turnstile> \\<C>} C D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<notin> f \\<turnstile> \\<C>;\n     D \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> H \\<in> walls_betw C D", "thus ?thesis"], ["proof (prove)\nusing this:\n  separated_by {g \\<turnstile> \\<C>, f \\<turnstile> \\<C>} C D\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "using H'(3,4) walls_betw_def"], ["proof (prove)\nusing this:\n  separated_by {g \\<turnstile> \\<C>, f \\<turnstile> \\<C>} C D\n  H = {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}\n  H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}})\n  walls_betw ?C ?D \\<equiv>\n  {H \\<in> \\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}.\n   separated_by H ?C ?D}\n\ngoal (1 subgoal):\n 1. H \\<in> walls_betw C D", "by (auto simp add: insert_commute)"], ["proof (state)\nthis:\n  H \\<in> walls_betw C D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H \\<in> walls_betw C D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  H \\<in> walls_betw C D\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>The group of automorphisms\\<close>"], ["", "text \\<open>\n  Recall that a pair of opposed foldings of a thin chamber complex can be stitched together to form\n  an automorphism of the complex. Choosing an arbitrary chamber in the complex to act as a sort of\n  centre of the complex (referred to as the fundamental chamber), we consider the group (under\n  composition) generated by the automorphisms afforded by the chambers adjacent to the fundamental\n  chamber via the pairs of opposed foldings that we have assumed to exist.\n\\<close>"], ["", "context ThinChamberComplexManyFoldings\nbegin"], ["", "definition fundfoldpairs :: \"(('a\\<Rightarrow>'a)\\<times>('a\\<Rightarrow>'a)) set\"\n  where \"fundfoldpairs \\<equiv> {(f,g). OpposedThinChamberComplexFoldings X f g C0}\""], ["", "abbreviation \"fundadjset \\<equiv> adjacentset C0 - {C0}\""], ["", "abbreviation induced_automorph :: \"('a\\<Rightarrow>'a) \\<Rightarrow> ('a\\<Rightarrow>'a) \\<Rightarrow> ('a\\<Rightarrow>'a)\"\n  where \"induced_automorph f g \\<equiv>\n          OpposedThinChamberComplexFoldings.induced_automorphism X f g\""], ["", "abbreviation Abs_induced_automorph :: \"('a\\<Rightarrow>'a) \\<Rightarrow> ('a\\<Rightarrow>'a) \\<Rightarrow> 'a permutation\"\n  where \"Abs_induced_automorph f g \\<equiv> Abs_permutation (induced_automorph f g)\""], ["", "abbreviation \"S \\<equiv> \\<Union>(f,g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\""], ["", "abbreviation \"W \\<equiv> \\<langle>S\\<rangle>\""], ["", "lemma fundfoldpairs_induced_autormorph_bij:\n  \"(f,g) \\<in> fundfoldpairs \\<Longrightarrow> bij (induced_automorph f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> fundfoldpairs \\<Longrightarrow> bij (induced_automorph f g)", "using     OpposedThinChamberComplexFoldings.induced_automorphism_bij"], ["proof (prove)\nusing this:\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  bij (OpposedThinChamberComplexFoldings.induced_automorphism ?X ?f ?g)\n\ngoal (1 subgoal):\n 1. (f, g) \\<in> fundfoldpairs \\<Longrightarrow> bij (induced_automorph f g)", "unfolding fundfoldpairs_def"], ["proof (prove)\nusing this:\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  bij (OpposedThinChamberComplexFoldings.induced_automorphism ?X ?f ?g)\n\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> {(f, g).\n           OpposedThinChamberComplexFoldings X f g C0} \\<Longrightarrow>\n    bij (induced_automorph f g)", "by        fast"], ["", "lemmas permutation_conv_induced_automorph =\n  Abs_permutation_inverse[OF CollectI, OF fundfoldpairs_induced_autormorph_bij]"], ["", "lemma fundfoldpairs_induced_autormorph_order2:\n  \"(f,g) \\<in> fundfoldpairs \\<Longrightarrow> induced_automorph f g \\<circ> induced_automorph f g = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> fundfoldpairs \\<Longrightarrow>\n    induced_automorph f g \\<circ> induced_automorph f g = id", "using     OpposedThinChamberComplexFoldings.indaut_order2"], ["proof (prove)\nusing this:\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  OpposedThinChamberComplexFoldings.induced_automorphism ?X ?f ?g \\<circ>\n  OpposedThinChamberComplexFoldings.induced_automorphism ?X ?f ?g =\n  id\n\ngoal (1 subgoal):\n 1. (f, g) \\<in> fundfoldpairs \\<Longrightarrow>\n    induced_automorph f g \\<circ> induced_automorph f g = id", "unfolding fundfoldpairs_def"], ["proof (prove)\nusing this:\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  OpposedThinChamberComplexFoldings.induced_automorphism ?X ?f ?g \\<circ>\n  OpposedThinChamberComplexFoldings.induced_automorphism ?X ?f ?g =\n  id\n\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> {(f, g).\n           OpposedThinChamberComplexFoldings X f g C0} \\<Longrightarrow>\n    induced_automorph f g \\<circ> induced_automorph f g = id", "by        fast"], ["", "lemma fundfoldpairs_induced_autormorph_ntrivial:\n  \"(f,g) \\<in> fundfoldpairs \\<Longrightarrow> induced_automorph f g \\<noteq> id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> fundfoldpairs \\<Longrightarrow>\n    induced_automorph f g \\<noteq> id", "using     OpposedThinChamberComplexFoldings.induced_automorphism_ntrivial"], ["proof (prove)\nusing this:\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  OpposedThinChamberComplexFoldings.induced_automorphism ?X ?f ?g \\<noteq>\n  id\n\ngoal (1 subgoal):\n 1. (f, g) \\<in> fundfoldpairs \\<Longrightarrow>\n    induced_automorph f g \\<noteq> id", "unfolding fundfoldpairs_def"], ["proof (prove)\nusing this:\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  OpposedThinChamberComplexFoldings.induced_automorphism ?X ?f ?g \\<noteq>\n  id\n\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> {(f, g).\n           OpposedThinChamberComplexFoldings X f g C0} \\<Longrightarrow>\n    induced_automorph f g \\<noteq> id", "by        fast"], ["", "lemma fundfoldpairs_fundchamber_image:\n  \"(f,g)\\<in>fundfoldpairs \\<Longrightarrow> Abs_induced_automorph f g `\\<rightarrow> C0 = g`C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> fundfoldpairs \\<Longrightarrow>\n    Abs_induced_automorph f g `\\<rightarrow> C0 = g ` C0", "using fundfoldpairs_def"], ["proof (prove)\nusing this:\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n\ngoal (1 subgoal):\n 1. (f, g) \\<in> fundfoldpairs \\<Longrightarrow>\n    Abs_induced_automorph f g `\\<rightarrow> C0 = g ` C0", "by    (simp add:\n          permutation_conv_induced_automorph\n          OpposedThinChamberComplexFoldings.induced_automorphism_C0\n        )"], ["", "lemma fundfoldpair_fundchamber_in_half_chamber_system_f:\n  \"(f,g)\\<in>fundfoldpairs \\<Longrightarrow> C0\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> fundfoldpairs \\<Longrightarrow>\n    C0 \\<in> f \\<turnstile> \\<C>", "using fundfoldpairs_def\n        OpposedThinChamberComplexFoldings.basech_halfchsys(1)"], ["proof (prove)\nusing this:\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  ?C0.0 \\<in> ?f \\<turnstile> ChamberComplex.chamber_system ?X\n\ngoal (1 subgoal):\n 1. (f, g) \\<in> fundfoldpairs \\<Longrightarrow>\n    C0 \\<in> f \\<turnstile> \\<C>", "by    fast"], ["", "lemma fundfoldpair_unique_half_chamber_system_f:\n  assumes \"(f,g)\\<in>fundfoldpairs\" \"(f',g')\\<in>fundfoldpairs\"\n          \"Abs_induced_automorph f' g' = Abs_induced_automorph f g\"\n  shows   \"f'\\<turnstile>\\<C> = f\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' \\<turnstile> \\<C> = f \\<turnstile> \\<C>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. f' \\<turnstile> \\<C> = f \\<turnstile> \\<C>", "from assms"], ["proof (chain)\npicking this:\n  (f, g) \\<in> fundfoldpairs\n  (f', g') \\<in> fundfoldpairs\n  Abs_induced_automorph f' g' = Abs_induced_automorph f g", "have \"g'`C0 = g`C0\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> fundfoldpairs\n  (f', g') \\<in> fundfoldpairs\n  Abs_induced_automorph f' g' = Abs_induced_automorph f g\n\ngoal (1 subgoal):\n 1. g' ` C0 = g ` C0", "using fundfoldpairs_fundchamber_image[OF assms(1)]\n          fundfoldpairs_fundchamber_image[OF assms(2)]"], ["proof (prove)\nusing this:\n  (f, g) \\<in> fundfoldpairs\n  (f', g') \\<in> fundfoldpairs\n  Abs_induced_automorph f' g' = Abs_induced_automorph f g\n  Abs_induced_automorph f g `\\<rightarrow> C0 = g ` C0\n  Abs_induced_automorph f' g' `\\<rightarrow> C0 = g' ` C0\n\ngoal (1 subgoal):\n 1. g' ` C0 = g ` C0", "by    simp"], ["proof (state)\nthis:\n  g' ` C0 = g ` C0\n\ngoal (1 subgoal):\n 1. f' \\<turnstile> \\<C> = f \\<turnstile> \\<C>", "with assms"], ["proof (chain)\npicking this:\n  (f, g) \\<in> fundfoldpairs\n  (f', g') \\<in> fundfoldpairs\n  Abs_induced_automorph f' g' = Abs_induced_automorph f g\n  g' ` C0 = g ` C0", "show \"f'\\<turnstile>\\<C> = f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> fundfoldpairs\n  (f', g') \\<in> fundfoldpairs\n  Abs_induced_automorph f' g' = Abs_induced_automorph f g\n  g' ` C0 = g ` C0\n\ngoal (1 subgoal):\n 1. f' \\<turnstile> \\<C> = f \\<turnstile> \\<C>", "using fundfoldpairs_def\n          OpposedThinChamberComplexFoldings.unique_half_chamber_system_f[\n            of X f g C0 f' g'\n          ]"], ["proof (prove)\nusing this:\n  (f, g) \\<in> fundfoldpairs\n  (f', g') \\<in> fundfoldpairs\n  Abs_induced_automorph f' g' = Abs_induced_automorph f g\n  g' ` C0 = g ` C0\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  \\<lbrakk>OpposedThinChamberComplexFoldings X f g C0;\n   OpposedThinChamberComplexFoldings X f' g' C0; g' ` C0 = g ` C0\\<rbrakk>\n  \\<Longrightarrow> f' \\<turnstile> \\<C> = f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. f' \\<turnstile> \\<C> = f \\<turnstile> \\<C>", "by    auto"], ["proof (state)\nthis:\n  f' \\<turnstile> \\<C> = f \\<turnstile> \\<C>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fundfoldpair_unique_half_chamber_systems_chamber_ng_f:\n  assumes \"(f,g)\\<in>fundfoldpairs\" \"(f',g')\\<in>fundfoldpairs\"\n          \"Abs_induced_automorph f' g' = Abs_induced_automorph f g\"\n          \"chamber C\" \"C\\<notin>g\\<turnstile>\\<C>\"\n  shows   \"C\\<in>f'\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> f' \\<turnstile> \\<C>", "using assms(1,3-5) fundfoldpairs_def chamber_system_def\n        OpposedThinChamberComplexFoldings.flopped_half_chamber_systems_gf[\n          THEN sym\n        ]\n        fundfoldpair_unique_half_chamber_system_f[OF assms(1,2)]"], ["proof (prove)\nusing this:\n  (f, g) \\<in> fundfoldpairs\n  Abs_induced_automorph f' g' = Abs_induced_automorph f g\n  chamber C\n  C \\<notin> g \\<turnstile> \\<C>\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  \\<C> \\<equiv> Collect chamber\n  OpposedThinChamberComplexFoldings ?X1 ?f1 ?g1 ?C0.1 \\<Longrightarrow>\n  ?f1 \\<turnstile> ChamberComplex.chamber_system ?X1 =\n  ChamberComplex.chamber_system ?X1 -\n  ?g1 \\<turnstile> ChamberComplex.chamber_system ?X1\n  Abs_induced_automorph f' g' = Abs_induced_automorph f g \\<Longrightarrow>\n  f' \\<turnstile> \\<C> = f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<in> f' \\<turnstile> \\<C>", "by    fastforce"], ["", "lemma the_wall_betw_adj_fundchamber:\n  \"(f,g)\\<in>fundfoldpairs \\<Longrightarrow>\n    the_wall_betw C0 (Abs_induced_automorph f g `\\<rightarrow> C0) = {f\\<turnstile>\\<C>,g\\<turnstile>\\<C>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> fundfoldpairs \\<Longrightarrow>\n    THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C0 (Abs_induced_automorph f g `\\<rightarrow> C0)) =\n    {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}", "using fundfoldpairs_def\n        OpposedThinChamberComplexFoldings.this_wall_betw_basechambers\n        OpposedThinChamberComplexFoldings.induced_automorphism_C0"], ["proof (prove)\nusing this:\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>ThinChamberComplex.foldpairs ?X.\n                   {{f \\<turnstile> ChamberComplex.chamber_system ?X,\n                     g \\<turnstile>\n                     ChamberComplex.chamber_system ?X}}) \\<and>\n       separated_by H ?C0.0 (?g ` ?C0.0)) =\n  {?f \\<turnstile> ChamberComplex.chamber_system ?X,\n   ?g \\<turnstile> ChamberComplex.chamber_system ?X}\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  OpposedThinChamberComplexFoldings.induced_automorphism ?X ?f ?g ` ?C0.0 =\n  ?g ` ?C0.0\n\ngoal (1 subgoal):\n 1. (f, g) \\<in> fundfoldpairs \\<Longrightarrow>\n    THE_default {}\n     (\\<lambda>H.\n         H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                     {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n         separated_by H C0 (Abs_induced_automorph f g `\\<rightarrow> C0)) =\n    {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}", "by    (fastforce simp add: permutation_conv_induced_automorph)"], ["", "lemma zero_notin_S: \"0\\<notin>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    False", "assume \"0\\<in>S\""], ["proof (state)\nthis:\n  0 \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. 0 \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  0 \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "obtain f g\n    where \"(f,g)\\<in>fundfoldpairs\" \"0 = Abs_induced_automorph f g\""], ["proof (prove)\nusing this:\n  0 \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> fundfoldpairs;\n         0 = Abs_induced_automorph f g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  (f, g) \\<in> fundfoldpairs\n  0 = Abs_induced_automorph f g\n\ngoal (1 subgoal):\n 1. 0 \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  (f, g) \\<in> fundfoldpairs\n  0 = Abs_induced_automorph f g\n\ngoal (1 subgoal):\n 1. False", "using Abs_permutation_inject[of id \"induced_automorph f g\"]\n          bij_id fundfoldpairs_induced_autormorph_bij\n          fundfoldpairs_induced_autormorph_ntrivial"], ["proof (prove)\nusing this:\n  (f, g) \\<in> fundfoldpairs\n  0 = Abs_induced_automorph f g\n  \\<lbrakk>id \\<in> {f. bij f};\n   induced_automorph f g \\<in> {f. bij f}\\<rbrakk>\n  \\<Longrightarrow> (Abs_permutation id = Abs_induced_automorph f g) =\n                    (id = induced_automorph f g)\n  bij id\n  (?f, ?g) \\<in> fundfoldpairs \\<Longrightarrow>\n  bij (induced_automorph ?f ?g)\n  (?f, ?g) \\<in> fundfoldpairs \\<Longrightarrow>\n  induced_automorph ?f ?g \\<noteq> id\n\ngoal (1 subgoal):\n 1. False", "by    (force simp add: zero_permutation.abs_eq)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma S_order2_add: \"s\\<in>S \\<Longrightarrow> s + s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    s + s = 0", "using fundfoldpairs_induced_autormorph_bij zero_permutation.abs_eq"], ["proof (prove)\nusing this:\n  (?f, ?g) \\<in> fundfoldpairs \\<Longrightarrow>\n  bij (induced_automorph ?f ?g)\n  0 = Abs_permutation id\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    s + s = 0", "by    (fastforce simp add:\n          plus_permutation_abs_eq fundfoldpairs_induced_autormorph_order2\n        )"], ["", "lemma S_add_order2:\n  assumes \"s\\<in>S\"\n  shows   \"add_order s = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_order s = 2", "proof (rule add_order_equality)"], ["proof (state)\ngoal (3 subgoals):\n 1. order.greater 2 0\n 2. nataction.power2 s = 0\n 3. \\<And>m.\n       \\<lbrakk>order.greater m 0; s +^ m = 0\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq m 2", "from assms"], ["proof (chain)\npicking this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "show \"s+^2 = 0\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. nataction.power2 s = 0", "using S_order2_add"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  ?s + ?s = 0\n\ngoal (1 subgoal):\n 1. nataction.power2 s = 0", "by (simp add: nataction_2)"], ["proof (state)\nthis:\n  nataction.power2 s = 0\n\ngoal (2 subgoals):\n 1. order.greater 2 0\n 2. \\<And>m.\n       \\<lbrakk>order.greater m 0; s +^ m = 0\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq m 2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater 2 0\n 2. \\<And>m.\n       \\<lbrakk>order.greater m 0; s +^ m = 0\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq m 2", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater 2 0\n 2. \\<And>m.\n       \\<lbrakk>order.greater m 0; s +^ m = 0\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq m 2", "assume \"0 < m\" \"s+^m = 0\""], ["proof (state)\nthis:\n  order.greater m 0\n  s +^ m = 0\n\ngoal (2 subgoals):\n 1. order.greater 2 0\n 2. \\<And>m.\n       \\<lbrakk>order.greater m 0; s +^ m = 0\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq m 2", "with assms"], ["proof (chain)\npicking this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  order.greater m 0\n  s +^ m = 0", "show \"2 \\<le> m\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  order.greater m 0\n  s +^ m = 0\n\ngoal (1 subgoal):\n 1. order.greater_eq m 2", "using zero_notin_S"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  order.greater m 0\n  s +^ m = 0\n  0 \\<notin> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. order.greater_eq m 2", "by (cases \"m=1\") auto"], ["proof (state)\nthis:\n  order.greater_eq m 2\n\ngoal (1 subgoal):\n 1. order.greater 2 0", "qed simp"], ["", "lemmas S_uminus = minus_unique[OF S_order2_add]"], ["", "lemma S_sym: \"uminus ` S \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (uminus `\n      (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))", "using S_uminus"], ["proof (prove)\nusing this:\n  ?a \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  - ?a = ?a\n\ngoal (1 subgoal):\n 1. order.greater_eq\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (uminus `\n      (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))", "by auto"], ["", "lemmas sum_list_S_in_W  = sum_list_lists_in_genby_sym[OF S_sym]"], ["", "lemmas W_conv_sum_lists = genby_sym_eq_sum_lists[OF S_sym]"], ["", "lemma S_endomorphism:\n  \"s\\<in>S \\<Longrightarrow> ChamberComplexEndomorphism X (permutation s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    ChamberComplexEndomorphism X ((\\<rightarrow>) s)", "using fundfoldpairs_def\n        OpposedThinChamberComplexFoldings.induced_automorphism_morphism"], ["proof (prove)\nusing this:\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  ChamberComplexEndomorphism ?X\n   (OpposedThinChamberComplexFoldings.induced_automorphism ?X ?f ?g)\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    ChamberComplexEndomorphism X ((\\<rightarrow>) s)", "by    (fastforce simp add: permutation_conv_induced_automorph)"], ["", "lemma S_list_endomorphism:\n  \"ss\\<in>lists S \\<Longrightarrow> ChamberComplexEndomorphism X (permutation (sum_list ss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    ChamberComplexEndomorphism X ((\\<rightarrow>) (sum_list ss))", "by  (induct ss)\n      (auto simp add:\n        zero_permutation.rep_eq trivial_endomorphism plus_permutation.rep_eq\n        S_endomorphism ChamberComplexEndomorphism.endo_comp\n      )"], ["", "lemma W_endomorphism:\n  \"w\\<in>W \\<Longrightarrow> ChamberComplexEndomorphism X (permutation w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f\n                          g}\\<rangle> \\<Longrightarrow>\n    ChamberComplexEndomorphism X ((\\<rightarrow>) w)", "using W_conv_sum_lists S_list_endomorphism"], ["proof (prove)\nusing this:\n  \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}\\<rangle> =\n  (\\<Union>ss\\<in>lists\n                   (\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}).\n      {sum_list ss})\n  ?ss\n  \\<in> lists\n         (\\<Union>(f, g)\\<in>fundfoldpairs.\n             {Abs_induced_automorph f g}) \\<Longrightarrow>\n  ChamberComplexEndomorphism X ((\\<rightarrow>) (sum_list ?ss))\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f\n                          g}\\<rangle> \\<Longrightarrow>\n    ChamberComplexEndomorphism X ((\\<rightarrow>) w)", "by auto"], ["", "lemma S_automorphism:\n  \"s\\<in>S \\<Longrightarrow> ChamberComplexAutomorphism X (permutation s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    ChamberComplexAutomorphism X ((\\<rightarrow>) s)", "using fundfoldpairs_def\n        OpposedThinChamberComplexFoldings.induced_automorphism_automorphism"], ["proof (prove)\nusing this:\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  ChamberComplexAutomorphism ?X\n   (OpposedThinChamberComplexFoldings.induced_automorphism ?X ?f ?g)\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    ChamberComplexAutomorphism X ((\\<rightarrow>) s)", "by    (fastforce simp add: permutation_conv_induced_automorph)"], ["", "lemma S_list_automorphism:\n  \"ss\\<in>lists S \\<Longrightarrow> ChamberComplexAutomorphism X (permutation (sum_list ss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    ChamberComplexAutomorphism X ((\\<rightarrow>) (sum_list ss))", "by  (induct ss)\n      (auto simp add:\n        zero_permutation.rep_eq trivial_automorphism plus_permutation.rep_eq\n        S_automorphism ChamberComplexAutomorphism.comp\n      )"], ["", "lemma W_automorphism:\n  \"w\\<in>W \\<Longrightarrow> ChamberComplexAutomorphism X (permutation w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f\n                          g}\\<rangle> \\<Longrightarrow>\n    ChamberComplexAutomorphism X ((\\<rightarrow>) w)", "using W_conv_sum_lists S_list_automorphism"], ["proof (prove)\nusing this:\n  \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}\\<rangle> =\n  (\\<Union>ss\\<in>lists\n                   (\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}).\n      {sum_list ss})\n  ?ss\n  \\<in> lists\n         (\\<Union>(f, g)\\<in>fundfoldpairs.\n             {Abs_induced_automorph f g}) \\<Longrightarrow>\n  ChamberComplexAutomorphism X ((\\<rightarrow>) (sum_list ?ss))\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f\n                          g}\\<rangle> \\<Longrightarrow>\n    ChamberComplexAutomorphism X ((\\<rightarrow>) w)", "by auto"], ["", "lemma S_respects_labels: \"\\<lbrakk> label_wrt B \\<phi>; s\\<in>S; v\\<in>(\\<Union>X) \\<rbrakk> \\<Longrightarrow> \\<phi> (s \\<rightarrow> v) = \\<phi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>label_wrt B \\<phi>;\n     s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g});\n     v \\<in> \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> \\<phi> (s \\<rightarrow> v) = \\<phi> v", "using fundfoldpairs_def\n        OpposedThinChamberComplexFoldings.indaut_resplabels[\n          of X _ _ C0 B \\<phi> v\n        ]"], ["proof (prove)\nusing this:\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  \\<lbrakk>OpposedThinChamberComplexFoldings X ?f ?g C0; label_wrt B \\<phi>;\n   v \\<in> \\<Union> X\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (induced_automorph ?f ?g v) = \\<phi> v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>label_wrt B \\<phi>;\n     s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g});\n     v \\<in> \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> \\<phi> (s \\<rightarrow> v) = \\<phi> v", "by    (auto simp add: permutation_conv_induced_automorph)"], ["", "lemma S_list_respects_labels:\n  \"\\<lbrakk> label_wrt B \\<phi>; ss\\<in>lists S; v\\<in>(\\<Union>X) \\<rbrakk> \\<Longrightarrow> \\<phi> (sum_list ss \\<rightarrow> v) = \\<phi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>label_wrt B \\<phi>;\n     ss \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g});\n     v \\<in> \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> \\<phi> (sum_list ss \\<rightarrow> v) = \\<phi> v", "using S_endomorphism ChamberComplexEndomorphism.vertex_map[of X]"], ["proof (prove)\nusing this:\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  ChamberComplexEndomorphism X ((\\<rightarrow>) ?s)\n  \\<lbrakk>ChamberComplexEndomorphism X ?f; ?x \\<in> \\<Union> X\\<rbrakk>\n  \\<Longrightarrow> ?f ?x \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>label_wrt B \\<phi>;\n     ss \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g});\n     v \\<in> \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> \\<phi> (sum_list ss \\<rightarrow> v) = \\<phi> v", "by    (induct ss arbitrary: v rule: rev_induct)\n        (auto simp add:\n          plus_permutation.rep_eq S_respects_labels zero_permutation.rep_eq\n        )"], ["", "lemma W_respects_labels:\n  \"\\<lbrakk> label_wrt B \\<phi>; w\\<in>W; v\\<in>(\\<Union>X) \\<rbrakk> \\<Longrightarrow> \\<phi> (w\\<rightarrow>v) = \\<phi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>label_wrt B \\<phi>;\n     w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}\\<rangle>;\n     v \\<in> \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> \\<phi> (w \\<rightarrow> v) = \\<phi> v", "using W_conv_sum_lists S_list_respects_labels[of B \\<phi> _ v]"], ["proof (prove)\nusing this:\n  \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}\\<rangle> =\n  (\\<Union>ss\\<in>lists\n                   (\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}).\n      {sum_list ss})\n  \\<lbrakk>label_wrt B \\<phi>;\n   ?ss\n   \\<in> lists\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   v \\<in> \\<Union> X\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (sum_list ?ss \\<rightarrow> v) = \\<phi> v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>label_wrt B \\<phi>;\n     w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}\\<rangle>;\n     v \\<in> \\<Union> X\\<rbrakk>\n    \\<Longrightarrow> \\<phi> (w \\<rightarrow> v) = \\<phi> v", "by auto"], ["", "end"], ["", "(* context ThinChamberComplexManyFoldings *)"], ["", "subsubsection \\<open>Action of the group of automorphisms on the chamber system\\<close>"], ["", "text \\<open>\n  Now we examine the action of the group @{term W} on the chamber system. In particular, we show\n  that the action is transitive.\n\\<close>"], ["", "context ThinChamberComplexManyFoldings\nbegin"], ["", "lemma fundchamber_S_chamber: \"s\\<in>S \\<Longrightarrow> chamber (s`\\<rightarrow>C0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    chamber (s `\\<rightarrow> C0)", "using fundfoldpairs_def"], ["proof (prove)\nusing this:\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    chamber (s `\\<rightarrow> C0)", "by    (fastforce simp add: \n          fundfoldpairs_fundchamber_image\n          OpposedThinChamberComplexFoldings.chamber_D0\n        )"], ["", "lemma fundchamber_W_image_chamber:\n  \"w\\<in>W \\<Longrightarrow> chamber (w`\\<rightarrow>C0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f\n                          g}\\<rangle> \\<Longrightarrow>\n    chamber (w `\\<rightarrow> C0)", "using fundchamber W_endomorphism\n        ChamberComplexEndomorphism.chamber_map"], ["proof (prove)\nusing this:\n  chamber C0\n  ?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f\n                         g}\\<rangle> \\<Longrightarrow>\n  ChamberComplexEndomorphism X ((\\<rightarrow>) ?w)\n  \\<lbrakk>ChamberComplexEndomorphism ?X ?f;\n   SimplicialComplex.maxsimp ?X ?C\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp ?X (?f ` ?C)\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f\n                          g}\\<rangle> \\<Longrightarrow>\n    chamber (w `\\<rightarrow> C0)", "by    auto"], ["", "lemma fundchamber_S_adjacent: \"s\\<in>S \\<Longrightarrow> C0 \\<sim> (s`\\<rightarrow>C0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    C0 \\<sim> s `\\<rightarrow> C0", "using fundfoldpairs_def"], ["proof (prove)\nusing this:\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    C0 \\<sim> s `\\<rightarrow> C0", "by    (auto simp add:\n          fundfoldpairs_fundchamber_image\n          OpposedThinChamberComplexFoldings.chambers(2)\n        )"], ["", "lemma fundchamber_WS_image_adjacent:\n  \"w\\<in>W \\<Longrightarrow> s\\<in>S \\<Longrightarrow> (w`\\<rightarrow>C0) \\<sim> ((w+s)`\\<rightarrow>C0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}\\<rangle>;\n     s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g})\\<rbrakk>\n    \\<Longrightarrow> w `\\<rightarrow> C0 \\<sim> (w + s) `\\<rightarrow> C0", "using fundchamber fundchamber_S_adjacent fundchamber_S_chamber\n        W_endomorphism\n        ChamberComplexEndomorphism.adj_map[of X \"permutation w\" C0 \"s`\\<rightarrow>C0\"]"], ["proof (prove)\nusing this:\n  chamber C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<sim> ?s `\\<rightarrow> C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  chamber (?s `\\<rightarrow> C0)\n  ?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f\n                         g}\\<rangle> \\<Longrightarrow>\n  ChamberComplexEndomorphism X ((\\<rightarrow>) ?w)\n  \\<lbrakk>ChamberComplexEndomorphism X ((\\<rightarrow>) w); chamber C0;\n   chamber (s `\\<rightarrow> C0); C0 \\<sim> s `\\<rightarrow> C0\\<rbrakk>\n  \\<Longrightarrow> w `\\<rightarrow> C0 \\<sim>\n                    w `\\<rightarrow> s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}\\<rangle>;\n     s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g})\\<rbrakk>\n    \\<Longrightarrow> w `\\<rightarrow> C0 \\<sim> (w + s) `\\<rightarrow> C0", "by    (auto simp add: image_comp plus_permutation.rep_eq)"], ["", "lemma fundchamber_S_image_neq_fundchamber: \"s\\<in>S \\<Longrightarrow> s`\\<rightarrow>C0 \\<noteq> C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    s `\\<rightarrow> C0 \\<noteq> C0", "using fundfoldpairs_def OpposedThinChamberComplexFoldings.chambers(3)"], ["proof (prove)\nusing this:\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  ?C0.0 \\<noteq> ?g ` ?C0.0\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    s `\\<rightarrow> C0 \\<noteq> C0", "by    (fastforce simp add: fundfoldpairs_fundchamber_image)"], ["", "lemma fundchamber_next_WS_image_neq:\n  assumes \"s\\<in>S\"\n  shows   \"(w+s) `\\<rightarrow> C0 \\<noteq> w `\\<rightarrow> C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w + s) `\\<rightarrow> C0 \\<noteq> w `\\<rightarrow> C0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (w + s) `\\<rightarrow> C0 = w `\\<rightarrow> C0 \\<Longrightarrow> False", "assume \"(w+s) `\\<rightarrow> C0 = w `\\<rightarrow> C0\""], ["proof (state)\nthis:\n  (w + s) `\\<rightarrow> C0 = w `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (w + s) `\\<rightarrow> C0 = w `\\<rightarrow> C0 \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  (w + s) `\\<rightarrow> C0 = w `\\<rightarrow> C0", "show False"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  (w + s) `\\<rightarrow> C0 = w `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. False", "using fundchamber_S_image_neq_fundchamber[of s]"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  (w + s) `\\<rightarrow> C0 = w `\\<rightarrow> C0\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  s `\\<rightarrow> C0 \\<noteq> C0\n\ngoal (1 subgoal):\n 1. False", "by    (auto simp add: plus_permutation.rep_eq image_comp permutation_eq_image)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fundchamber_S_fundadjset: \"s\\<in>S \\<Longrightarrow> s`\\<rightarrow>C0 \\<in> fundadjset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    s `\\<rightarrow> C0 \\<in> adjacentset C0 - {C0}", "using fundchamber_S_adjacent fundchamber_S_image_neq_fundchamber\n        fundchamber_S_chamber chamberD_simplex adjacentset_def"], ["proof (prove)\nusing this:\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<sim> ?s `\\<rightarrow> C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  ?s `\\<rightarrow> C0 \\<noteq> C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  chamber (?s `\\<rightarrow> C0)\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n  adjacentset ?x = {y \\<in> X. ?x \\<sim> y}\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    s `\\<rightarrow> C0 \\<in> adjacentset C0 - {C0}", "by    simp"], ["", "lemma fundadjset_eq_S_image: \"D\\<in>fundadjset \\<Longrightarrow> \\<exists>s\\<in>S. D = s`\\<rightarrow>C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<in> adjacentset C0 - {C0} \\<Longrightarrow>\n    \\<exists>s\\<in>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}.\n       D = s `\\<rightarrow> C0", "using fundchamber adjacentsetD_adj adjacentset_chamber ex_walls[of C0 D]\n        fundfoldpairs_def fundfoldpairs_fundchamber_image"], ["proof (prove)\nusing this:\n  chamber C0\n  ?y \\<in> adjacentset ?x \\<Longrightarrow> ?x \\<sim> ?y\n  \\<lbrakk>chamber ?C; ?D \\<in> adjacentset ?C\\<rbrakk>\n  \\<Longrightarrow> chamber ?D\n  \\<lbrakk>chamber C0; chamber D; C0 \\<sim> D; C0 \\<noteq> D\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f g.\n                       OpposedThinChamberComplexFoldings X f g C0 \\<and>\n                       D = g ` C0\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  (?f, ?g) \\<in> fundfoldpairs \\<Longrightarrow>\n  Abs_induced_automorph ?f ?g `\\<rightarrow> C0 = ?g ` C0\n\ngoal (1 subgoal):\n 1. D \\<in> adjacentset C0 - {C0} \\<Longrightarrow>\n    \\<exists>s\\<in>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}.\n       D = s `\\<rightarrow> C0", "by    blast"], ["", "lemma S_fixespointwise_fundchamber_image_int:\n  assumes \"s\\<in>S\"\n  shows   \"fixespointwise ((\\<rightarrow>) s) (C0\\<inter>s`\\<rightarrow>C0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise ((\\<rightarrow>) s) (C0 \\<inter> s `\\<rightarrow> C0)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. fixespointwise ((\\<rightarrow>) s) (C0 \\<inter> s `\\<rightarrow> C0)", "from assms(1)"], ["proof (chain)\npicking this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "obtain f g\n    where fg: \"(f,g)\\<in>fundfoldpairs\" \"s = Abs_induced_automorph f g\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> fundfoldpairs;\n         s = Abs_induced_automorph f g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g\n\ngoal (1 subgoal):\n 1. fixespointwise ((\\<rightarrow>) s) (C0 \\<inter> s `\\<rightarrow> C0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise ((\\<rightarrow>) s) (C0 \\<inter> s `\\<rightarrow> C0)", "proof (rule fixespointwise_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. fun_eq_on ((\\<rightarrow>) s) ?g (C0 \\<inter> s `\\<rightarrow> C0)\n 2. fixespointwise ?g (C0 \\<inter> s `\\<rightarrow> C0)", "from fg"], ["proof (chain)\npicking this:\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g", "show \"fun_eq_on ((\\<rightarrow>) s) (induced_automorph f g) (C0\\<inter>s`\\<rightarrow>C0)\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g\n\ngoal (1 subgoal):\n 1. fun_eq_on ((\\<rightarrow>) s) (induced_automorph f g)\n     (C0 \\<inter> s `\\<rightarrow> C0)", "using permutation_conv_induced_automorph fun_eq_onI"], ["proof (prove)\nusing this:\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g\n  (?f, ?g) \\<in> fundfoldpairs \\<Longrightarrow>\n  (\\<rightarrow>) (Abs_induced_automorph ?f ?g) = induced_automorph ?f ?g\n  (\\<And>a. a \\<in> ?A \\<Longrightarrow> ?f a = ?g a) \\<Longrightarrow>\n  fun_eq_on ?f ?g ?A\n\ngoal (1 subgoal):\n 1. fun_eq_on ((\\<rightarrow>) s) (induced_automorph f g)\n     (C0 \\<inter> s `\\<rightarrow> C0)", "by fastforce"], ["proof (state)\nthis:\n  fun_eq_on ((\\<rightarrow>) s) (induced_automorph f g)\n   (C0 \\<inter> s `\\<rightarrow> C0)\n\ngoal (1 subgoal):\n 1. fixespointwise (induced_automorph f g) (C0 \\<inter> s `\\<rightarrow> C0)", "from fg"], ["proof (chain)\npicking this:\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g", "show \"fixespointwise (induced_automorph f g) (C0\\<inter>s`\\<rightarrow>C0)\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g\n\ngoal (1 subgoal):\n 1. fixespointwise (induced_automorph f g) (C0 \\<inter> s `\\<rightarrow> C0)", "using fundfoldpairs_fundchamber_image fundfoldpairs_def\n            OpposedThinChamberComplexFoldings.indaut_fixes_fundfacet"], ["proof (prove)\nusing this:\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g\n  (?f, ?g) \\<in> fundfoldpairs \\<Longrightarrow>\n  Abs_induced_automorph ?f ?g `\\<rightarrow> C0 = ?g ` C0\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  fixespointwise\n   (OpposedThinChamberComplexFoldings.induced_automorphism ?X ?f ?g)\n   (?C0.0 \\<inter> ?g ` ?C0.0)\n\ngoal (1 subgoal):\n 1. fixespointwise (induced_automorph f g) (C0 \\<inter> s `\\<rightarrow> C0)", "by    auto"], ["proof (state)\nthis:\n  fixespointwise (induced_automorph f g) (C0 \\<inter> s `\\<rightarrow> C0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fixespointwise ((\\<rightarrow>) s) (C0 \\<inter> s `\\<rightarrow> C0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma S_fixes_fundchamber_image_int:\n  \"s\\<in>S \\<Longrightarrow> s`\\<rightarrow>(C0\\<inter>s`\\<rightarrow>C0) = C0\\<inter>s`\\<rightarrow>C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    s `\\<rightarrow> (C0 \\<inter> s `\\<rightarrow> C0) =\n    C0 \\<inter> s `\\<rightarrow> C0", "using fixespointwise_im[OF S_fixespointwise_fundchamber_image_int]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1\n           \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g});\n   order.greater_eq (C0 \\<inter> ?s1 `\\<rightarrow> C0) ?B\\<rbrakk>\n  \\<Longrightarrow> ?s1 `\\<rightarrow> ?B = ?B\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    s `\\<rightarrow> (C0 \\<inter> s `\\<rightarrow> C0) =\n    C0 \\<inter> s `\\<rightarrow> C0", "by simp"], ["", "lemma fundfacets:\n  assumes \"s\\<in>S\"\n  shows   \"C0\\<inter>s`\\<rightarrow>C0 \\<lhd> C0\" \"C0\\<inter>s`\\<rightarrow>C0 \\<lhd> s`\\<rightarrow>C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C0 \\<inter> s `\\<rightarrow> C0 \\<lhd> C0 &&&\n    C0 \\<inter> s `\\<rightarrow> C0 \\<lhd> s `\\<rightarrow> C0", "using   assms fundchamber_S_adjacent[of s]\n          fundchamber_S_image_neq_fundchamber[of s]\n          adjacent_int_facet1[of C0] adjacent_int_facet2[of C0]"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<sim> s `\\<rightarrow> C0\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  s `\\<rightarrow> C0 \\<noteq> C0\n  \\<lbrakk>C0 \\<sim> ?y; C0 \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> C0 \\<inter> ?y \\<lhd> C0\n  \\<lbrakk>C0 \\<sim> ?y; C0 \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> C0 \\<inter> ?y \\<lhd> ?y\n\ngoal (1 subgoal):\n 1. C0 \\<inter> s `\\<rightarrow> C0 \\<lhd> C0 &&&\n    C0 \\<inter> s `\\<rightarrow> C0 \\<lhd> s `\\<rightarrow> C0", "by      auto"], ["", "lemma fundadjset_ex1_eq_S_image:\n  assumes \"D\\<in>fundadjset\"\n  shows   \"\\<exists>!s\\<in>S. D = s`\\<rightarrow>C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!s.\n       s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g}) \\<and>\n       D = s `\\<rightarrow> C0", "proof (rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>s.\n       s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g}) \\<and>\n       D = s `\\<rightarrow> C0\n 2. \\<And>s y.\n       \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) \\<and>\n                D = s `\\<rightarrow> C0;\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<and>\n        D = y `\\<rightarrow> C0\\<rbrakk>\n       \\<Longrightarrow> s = y", "from assms"], ["proof (chain)\npicking this:\n  D \\<in> adjacentset C0 - {C0}", "show \"\\<exists>s. s\\<in>S \\<and> D = s `\\<rightarrow> C0\""], ["proof (prove)\nusing this:\n  D \\<in> adjacentset C0 - {C0}\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g}) \\<and>\n       D = s `\\<rightarrow> C0", "using fundadjset_eq_S_image"], ["proof (prove)\nusing this:\n  D \\<in> adjacentset C0 - {C0}\n  ?D \\<in> adjacentset C0 - {C0} \\<Longrightarrow>\n  \\<exists>s\\<in>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}.\n     ?D = s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g}) \\<and>\n       D = s `\\<rightarrow> C0", "by fast"], ["proof (state)\nthis:\n  \\<exists>s.\n     s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) \\<and>\n     D = s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>s y.\n       \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) \\<and>\n                D = s `\\<rightarrow> C0;\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<and>\n        D = y `\\<rightarrow> C0\\<rbrakk>\n       \\<Longrightarrow> s = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s y.\n       \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) \\<and>\n                D = s `\\<rightarrow> C0;\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<and>\n        D = y `\\<rightarrow> C0\\<rbrakk>\n       \\<Longrightarrow> s = y", "fix s t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s y.\n       \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) \\<and>\n                D = s `\\<rightarrow> C0;\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<and>\n        D = y `\\<rightarrow> C0\\<rbrakk>\n       \\<Longrightarrow> s = y", "assume \"s\\<in>S \\<and> D = s`\\<rightarrow>C0\" \"t\\<in>S \\<and> D = t`\\<rightarrow>C0\""], ["proof (state)\nthis:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<and>\n  D = s `\\<rightarrow> C0\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<and>\n  D = t `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>s y.\n       \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) \\<and>\n                D = s `\\<rightarrow> C0;\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<and>\n        D = y `\\<rightarrow> C0\\<rbrakk>\n       \\<Longrightarrow> s = y", "hence s: \"s\\<in>S\" \"D = s`\\<rightarrow>C0\"\n    and t: \"t\\<in>S\" \"D = t`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<and>\n  D = s `\\<rightarrow> C0\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<and>\n  D = t `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) &&&\n     D = s `\\<rightarrow> C0) &&&\n    t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) &&&\n    D = t `\\<rightarrow> C0", "by  auto"], ["proof (state)\nthis:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  D = s `\\<rightarrow> C0\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  D = t `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>s y.\n       \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) \\<and>\n                D = s `\\<rightarrow> C0;\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<and>\n        D = y `\\<rightarrow> C0\\<rbrakk>\n       \\<Longrightarrow> s = y", "from s(1) t(1)"], ["proof (chain)\npicking this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "obtain f g f' g'\n    where \"(f,g)\\<in>fundfoldpairs\" \"s = Abs_induced_automorph f  g\"\n    and   \"(f',g')\\<in>fundfoldpairs\" \"t = Abs_induced_automorph f' g'\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. (\\<And>f g f' g'.\n        \\<lbrakk>(f, g) \\<in> fundfoldpairs; s = Abs_induced_automorph f g;\n         (f', g') \\<in> fundfoldpairs;\n         t = Abs_induced_automorph f' g'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g\n  (f', g') \\<in> fundfoldpairs\n  t = Abs_induced_automorph f' g'\n\ngoal (1 subgoal):\n 1. \\<And>s y.\n       \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) \\<and>\n                D = s `\\<rightarrow> C0;\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<and>\n        D = y `\\<rightarrow> C0\\<rbrakk>\n       \\<Longrightarrow> s = y", "with s(2) t(2)"], ["proof (chain)\npicking this:\n  D = s `\\<rightarrow> C0\n  D = t `\\<rightarrow> C0\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g\n  (f', g') \\<in> fundfoldpairs\n  t = Abs_induced_automorph f' g'", "show \"s=t\""], ["proof (prove)\nusing this:\n  D = s `\\<rightarrow> C0\n  D = t `\\<rightarrow> C0\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g\n  (f', g') \\<in> fundfoldpairs\n  t = Abs_induced_automorph f' g'\n\ngoal (1 subgoal):\n 1. s = t", "using fundfoldpairs_def fundfoldpairs_fundchamber_image\n            OpposedThinChamberComplexFoldings.induced_automorphism_unique[\n              of X f' g' C0 f g\n            ]"], ["proof (prove)\nusing this:\n  D = s `\\<rightarrow> C0\n  D = t `\\<rightarrow> C0\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g\n  (f', g') \\<in> fundfoldpairs\n  t = Abs_induced_automorph f' g'\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  (?f, ?g) \\<in> fundfoldpairs \\<Longrightarrow>\n  Abs_induced_automorph ?f ?g `\\<rightarrow> C0 = ?g ` C0\n  \\<lbrakk>OpposedThinChamberComplexFoldings X f' g' C0;\n   OpposedThinChamberComplexFoldings X f g C0; g ` C0 = g' ` C0\\<rbrakk>\n  \\<Longrightarrow> induced_automorph f g = induced_automorph f' g'\n\ngoal (1 subgoal):\n 1. s = t", "by    auto"], ["proof (state)\nthis:\n  s = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fundchamber_S_image_inj_on: \"inj_on (\\<lambda>s. s`\\<rightarrow>C0) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>s. s `\\<rightarrow> C0)\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g});\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g});\n        x `\\<rightarrow> C0 = y `\\<rightarrow> C0\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix s t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g});\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g});\n        x `\\<rightarrow> C0 = y `\\<rightarrow> C0\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"s\\<in>S\" \"t\\<in>S\" \"s`\\<rightarrow>C0 = t`\\<rightarrow>C0\""], ["proof (state)\nthis:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s `\\<rightarrow> C0 = t `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g});\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g});\n        x `\\<rightarrow> C0 = y `\\<rightarrow> C0\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"s=t\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s `\\<rightarrow> C0 = t `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. s = t", "using fundchamber_S_fundadjset\n          bex1_equality[OF fundadjset_ex1_eq_S_image, of \"s`\\<rightarrow>C0\" s t]"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s `\\<rightarrow> C0 = t `\\<rightarrow> C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  ?s `\\<rightarrow> C0 \\<in> adjacentset C0 - {C0}\n  \\<lbrakk>s `\\<rightarrow> C0 \\<in> adjacentset C0 - {C0};\n   s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   s `\\<rightarrow> C0 = s `\\<rightarrow> C0;\n   t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   s `\\<rightarrow> C0 = t `\\<rightarrow> C0\\<rbrakk>\n  \\<Longrightarrow> s = t\n\ngoal (1 subgoal):\n 1. s = t", "by    simp"], ["proof (state)\nthis:\n  s = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma S_list_image_gallery:\n  \"ss\\<in>lists S \\<Longrightarrow> gallery (map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "proof (induct ss rule: list_induct_ssnoc)"], ["proof (state)\ngoal (3 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums []))\n 2. \\<And>x.\n       [x]\n       \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n       gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [x]))\n 3. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                gallery\n                 (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x])));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> gallery\n                          (map (\\<lambda>w. w `\\<rightarrow> C0)\n                            (sums (xs @ [x, y])))", "case (Single s)"], ["proof (state)\nthis:\n  [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n\ngoal (3 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums []))\n 2. \\<And>x.\n       [x]\n       \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n       gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [x]))\n 3. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                gallery\n                 (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x])));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> gallery\n                          (map (\\<lambda>w. w `\\<rightarrow> C0)\n                            (sums (xs @ [x, y])))", "thus ?case"], ["proof (prove)\nusing this:\n  [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [s]))", "using fundchamber fundchamber_S_chamber fundchamber_S_adjacent\n          gallery_def"], ["proof (prove)\nusing this:\n  [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  chamber C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  chamber (?s `\\<rightarrow> C0)\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<sim> ?s `\\<rightarrow> C0\n  gallery ?xs \\<equiv> Ball (set ?xs) chamber \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [s]))", "by    (fastforce simp add: zero_permutation.rep_eq)"], ["proof (state)\nthis:\n  gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [s]))\n\ngoal (2 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums []))\n 2. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                gallery\n                 (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x])));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> gallery\n                          (map (\\<lambda>w. w `\\<rightarrow> C0)\n                            (sums (xs @ [x, y])))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums []))\n 2. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                gallery\n                 (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x])));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> gallery\n                          (map (\\<lambda>w. w `\\<rightarrow> C0)\n                            (sums (xs @ [x, y])))", "case (ssnoc ss s t)"], ["proof (state)\nthis:\n  ss @ [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of\n             (f, g) \\<Rightarrow>\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (ss @ [s])))\n  ss @ [s, t]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n\ngoal (2 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums []))\n 2. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                gallery\n                 (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x])));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> gallery\n                          (map (\\<lambda>w. w `\\<rightarrow> C0)\n                            (sums (xs @ [x, y])))", "define Cs D E where \"Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\"\n    and \"D = sum_list (ss@[s]) `\\<rightarrow> C0\"\n    and \"E = sum_list (ss@[s,t]) `\\<rightarrow> C0\""], ["proof (state)\nthis:\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  D = sum_list (ss @ [s]) `\\<rightarrow> C0\n  E = sum_list (ss @ [s, t]) `\\<rightarrow> C0\n\ngoal (2 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums []))\n 2. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                gallery\n                 (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x])));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> gallery\n                          (map (\\<lambda>w. w `\\<rightarrow> C0)\n                            (sums (xs @ [x, y])))", "with ssnoc"], ["proof (chain)\npicking this:\n  ss @ [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of\n             (f, g) \\<Rightarrow>\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (ss @ [s])))\n  ss @ [s, t]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  D = sum_list (ss @ [s]) `\\<rightarrow> C0\n  E = sum_list (ss @ [s, t]) `\\<rightarrow> C0", "have \"gallery (Cs@[D,E])\""], ["proof (prove)\nusing this:\n  ss @ [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of\n             (f, g) \\<Rightarrow>\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (ss @ [s])))\n  ss @ [s, t]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  D = sum_list (ss @ [s]) `\\<rightarrow> C0\n  E = sum_list (ss @ [s, t]) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. gallery (Cs @ [D, E])", "using sum_list_S_in_W[of \"ss@[s,t]\"] sum_list_S_in_W[of \"ss@[s]\"]\n          fundchamber_W_image_chamber\n          fundchamber_WS_image_adjacent[of \"sum_list (ss@[s])\" t]\n          sum_list_append[of \"ss@[s]\" \"[t]\"]"], ["proof (prove)\nusing this:\n  ss @ [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of\n             (f, g) \\<Rightarrow>\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (ss @ [s])))\n  ss @ [s, t]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  D = sum_list (ss @ [s]) `\\<rightarrow> C0\n  E = sum_list (ss @ [s, t]) `\\<rightarrow> C0\n  ss @ [s, t]\n  \\<in> lists\n         (\\<Union>(f, g)\\<in>fundfoldpairs.\n             {Abs_induced_automorph f g}) \\<Longrightarrow>\n  sum_list (ss @ [s, t])\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  ss @ [s]\n  \\<in> lists\n         (\\<Union>(f, g)\\<in>fundfoldpairs.\n             {Abs_induced_automorph f g}) \\<Longrightarrow>\n  sum_list (ss @ [s])\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  ?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f\n                         g}\\<rangle> \\<Longrightarrow>\n  chamber (?w `\\<rightarrow> C0)\n  \\<lbrakk>sum_list (ss @ [s])\n           \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g}\\<rangle>;\n   t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g})\\<rbrakk>\n  \\<Longrightarrow> sum_list (ss @ [s]) `\\<rightarrow> C0 \\<sim>\n                    (sum_list (ss @ [s]) + t) `\\<rightarrow> C0\n  sum_list ((ss @ [s]) @ [t]) = sum_list (ss @ [s]) + sum_list [t]\n\ngoal (1 subgoal):\n 1. gallery (Cs @ [D, E])", "by    (auto intro: gallery_snocI simp add: sums_snoc)"], ["proof (state)\nthis:\n  gallery (Cs @ [D, E])\n\ngoal (2 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums []))\n 2. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                gallery\n                 (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x])));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> gallery\n                          (map (\\<lambda>w. w `\\<rightarrow> C0)\n                            (sums (xs @ [x, y])))", "with Cs_def D_def E_def"], ["proof (chain)\npicking this:\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  D = sum_list (ss @ [s]) `\\<rightarrow> C0\n  E = sum_list (ss @ [s, t]) `\\<rightarrow> C0\n  gallery (Cs @ [D, E])", "show ?case"], ["proof (prove)\nusing this:\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  D = sum_list (ss @ [s]) `\\<rightarrow> C0\n  E = sum_list (ss @ [s, t]) `\\<rightarrow> C0\n  gallery (Cs @ [D, E])\n\ngoal (1 subgoal):\n 1. gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (ss @ [s, t])))", "using sums_snoc[of \"ss@[s]\" t]"], ["proof (prove)\nusing this:\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  D = sum_list (ss @ [s]) `\\<rightarrow> C0\n  E = sum_list (ss @ [s, t]) `\\<rightarrow> C0\n  gallery (Cs @ [D, E])\n  sums ((ss @ [s]) @ [t]) = sums (ss @ [s]) @ [sum_list ((ss @ [s]) @ [t])]\n\ngoal (1 subgoal):\n 1. gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (ss @ [s, t])))", "by (simp add: sums_snoc)"], ["proof (state)\nthis:\n  gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (ss @ [s, t])))\n\ngoal (1 subgoal):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums []))", "qed (auto simp add: gallery_def fundchamber zero_permutation.rep_eq)"], ["", "lemma pgallery_last_eq_W_image:\n  \"pgallery (C0#Cs@[C]) \\<Longrightarrow> \\<exists>w\\<in>W. C = w`\\<rightarrow>C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pgallery (C0 # Cs @ [C]) \\<Longrightarrow>\n    \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "proof (induct Cs arbitrary: C rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       pgallery (C0 # [] @ [C]) \\<Longrightarrow>\n       \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                  {Abs_induced_automorph f g}\\<rangle>.\n          C = w `\\<rightarrow> C0\n 2. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "case Nil"], ["proof (state)\nthis:\n  pgallery (C0 # [] @ [C])\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       pgallery (C0 # [] @ [C]) \\<Longrightarrow>\n       \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                  {Abs_induced_automorph f g}\\<rangle>.\n          C = w `\\<rightarrow> C0\n 2. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "hence \"C\\<in>fundadjset\""], ["proof (prove)\nusing this:\n  pgallery (C0 # [] @ [C])\n\ngoal (1 subgoal):\n 1. C \\<in> adjacentset C0 - {C0}", "using pgallery_def chamberD_simplex adjacentset_def"], ["proof (prove)\nusing this:\n  pgallery (C0 # [] @ [C])\n  pgallery ?xs \\<equiv> Ball (set ?xs) chamber \\<and> padjacentchain ?xs\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n  adjacentset ?x = {y \\<in> X. ?x \\<sim> y}\n\ngoal (1 subgoal):\n 1. C \\<in> adjacentset C0 - {C0}", "by fastforce"], ["proof (state)\nthis:\n  C \\<in> adjacentset C0 - {C0}\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       pgallery (C0 # [] @ [C]) \\<Longrightarrow>\n       \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                  {Abs_induced_automorph f g}\\<rangle>.\n          C = w `\\<rightarrow> C0\n 2. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "from this"], ["proof (chain)\npicking this:\n  C \\<in> adjacentset C0 - {C0}", "obtain s where \"s\\<in>S\" \"C = s`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  C \\<in> adjacentset C0 - {C0}\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g});\n         C = s `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using fundadjset_eq_S_image[of C]"], ["proof (prove)\nusing this:\n  C \\<in> adjacentset C0 - {C0}\n  C \\<in> adjacentset C0 - {C0} \\<Longrightarrow>\n  \\<exists>s\\<in>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}.\n     C = s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g});\n         C = s `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  C = s `\\<rightarrow> C0\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       pgallery (C0 # [] @ [C]) \\<Longrightarrow>\n       \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                  {Abs_induced_automorph f g}\\<rangle>.\n          C = w `\\<rightarrow> C0\n 2. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "thus ?case"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  C = s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>\\<langle>\\<Union>a\\<in>fundfoldpairs.\n                               case a of\n                               (f, g) \\<Rightarrow>\n                                 {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "using genby_genset_closed[of s S]"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  C = s `\\<rightarrow> C0\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  s \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>\\<langle>\\<Union>a\\<in>fundfoldpairs.\n                               case a of\n                               (f, g) \\<Rightarrow>\n                                 {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "by fast"], ["proof (state)\nthis:\n  \\<exists>w\\<in>\\<langle>\\<Union>a\\<in>fundfoldpairs.\n                             case a of\n                             (f, g) \\<Rightarrow>\n                               {Abs_induced_automorph f g}\\<rangle>.\n     C = w `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "case (snoc D Ds)"], ["proof (state)\nthis:\n  pgallery (C0 # Ds @ [?C1]) \\<Longrightarrow>\n  \\<exists>w\\<in>\\<langle>\\<Union>a\\<in>fundfoldpairs.\n                             case a of\n                             (f, g) \\<Rightarrow>\n                               {Abs_induced_automorph f g}\\<rangle>.\n     ?C1 = w `\\<rightarrow> C0\n  pgallery (C0 # (Ds @ [D]) @ [C])\n\ngoal (1 subgoal):\n 1. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "have DC: \"chamber D\" \"chamber C\" \"D\\<sim>C\" \"D\\<noteq>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (chamber D &&& chamber C) &&& D \\<sim> C &&& D \\<noteq> C", "using pgallery_def snoc(2)\n          binrelchain_append_reduce2[of adjacent \"C0#Ds\" \"[D,C]\"]"], ["proof (prove)\nusing this:\n  pgallery ?xs \\<equiv> Ball (set ?xs) chamber \\<and> padjacentchain ?xs\n  pgallery (C0 # (Ds @ [D]) @ [C])\n  adjacentchain ((C0 # Ds) @ [D, C]) \\<Longrightarrow> adjacentchain [D, C]\n\ngoal (1 subgoal):\n 1. (chamber D &&& chamber C) &&& D \\<sim> C &&& D \\<noteq> C", "by    auto"], ["proof (state)\nthis:\n  chamber D\n  chamber C\n  D \\<sim> C\n  D \\<noteq> C\n\ngoal (1 subgoal):\n 1. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "from snoc"], ["proof (chain)\npicking this:\n  pgallery (C0 # Ds @ [?C1]) \\<Longrightarrow>\n  \\<exists>w\\<in>\\<langle>\\<Union>a\\<in>fundfoldpairs.\n                             case a of\n                             (f, g) \\<Rightarrow>\n                               {Abs_induced_automorph f g}\\<rangle>.\n     ?C1 = w `\\<rightarrow> C0\n  pgallery (C0 # (Ds @ [D]) @ [C])", "obtain w where w: \"w\\<in>W\" \"D = w`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  pgallery (C0 # Ds @ [?C1]) \\<Longrightarrow>\n  \\<exists>w\\<in>\\<langle>\\<Union>a\\<in>fundfoldpairs.\n                             case a of\n                             (f, g) \\<Rightarrow>\n                               {Abs_induced_automorph f g}\\<rangle>.\n     ?C1 = w `\\<rightarrow> C0\n  pgallery (C0 # (Ds @ [D]) @ [C])\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}\\<rangle>;\n         D = w `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using pgallery_append_reduce1[of \"C0#Ds@[D]\" \"[C]\"]"], ["proof (prove)\nusing this:\n  pgallery (C0 # Ds @ [?C1]) \\<Longrightarrow>\n  \\<exists>w\\<in>\\<langle>\\<Union>a\\<in>fundfoldpairs.\n                             case a of\n                             (f, g) \\<Rightarrow>\n                               {Abs_induced_automorph f g}\\<rangle>.\n     ?C1 = w `\\<rightarrow> C0\n  pgallery (C0 # (Ds @ [D]) @ [C])\n  pgallery ((C0 # Ds @ [D]) @ [C]) \\<Longrightarrow>\n  pgallery (C0 # Ds @ [D])\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}\\<rangle>;\n         D = w `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  D = w `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "from w(2)"], ["proof (chain)\npicking this:\n  D = w `\\<rightarrow> C0", "have \"(-w)`\\<rightarrow>D = C0\""], ["proof (prove)\nusing this:\n  D = w `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (- w) `\\<rightarrow> D = C0", "by  (simp add:\n          image_comp plus_permutation.rep_eq[THEN sym]\n          zero_permutation.rep_eq\n        )"], ["proof (state)\nthis:\n  (- w) `\\<rightarrow> D = C0\n\ngoal (1 subgoal):\n 1. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "with DC w(1)"], ["proof (chain)\npicking this:\n  chamber D\n  chamber C\n  D \\<sim> C\n  D \\<noteq> C\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  (- w) `\\<rightarrow> D = C0", "have \"C0 \\<sim> (-w)`\\<rightarrow>C\" \"C0 \\<noteq> (-w)`\\<rightarrow>C\" \"(-w)`\\<rightarrow>C \\<in> X\""], ["proof (prove)\nusing this:\n  chamber D\n  chamber C\n  D \\<sim> C\n  D \\<noteq> C\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  (- w) `\\<rightarrow> D = C0\n\ngoal (1 subgoal):\n 1. C0 \\<sim> (- w) `\\<rightarrow> C &&&\n    C0 \\<noteq> (- w) `\\<rightarrow> C &&& (- w) `\\<rightarrow> C \\<in> X", "using genby_uminus_closed W_endomorphism[of \"-w\"]\n          ChamberComplexEndomorphism.adj_map[of X _ D C]\n          permutation_eq_image[of \"-w\" D] chamberD_simplex[of C]\n          ChamberComplexEndomorphism.simplex_map[of X \"permutation (-w)\" C]"], ["proof (prove)\nusing this:\n  chamber D\n  chamber C\n  D \\<sim> C\n  D \\<noteq> C\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  (- w) `\\<rightarrow> D = C0\n  ?g \\<in> \\<langle>?S\\<rangle> \\<Longrightarrow>\n  - ?g \\<in> \\<langle>?S\\<rangle>\n  - w\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle> \\<Longrightarrow>\n  ChamberComplexEndomorphism X ((\\<rightarrow>) (- w))\n  \\<lbrakk>ChamberComplexEndomorphism X ?f; chamber D; chamber C;\n   D \\<sim> C\\<rbrakk>\n  \\<Longrightarrow> ?f ` D \\<sim> ?f ` C\n  (- w) `\\<rightarrow> D = (- w) `\\<rightarrow> ?B \\<Longrightarrow> D = ?B\n  chamber C \\<Longrightarrow> C \\<in> X\n  \\<lbrakk>ChamberComplexEndomorphism X ((\\<rightarrow>) (- w));\n   C \\<in> X\\<rbrakk>\n  \\<Longrightarrow> (- w) `\\<rightarrow> C \\<in> X\n\ngoal (1 subgoal):\n 1. C0 \\<sim> (- w) `\\<rightarrow> C &&&\n    C0 \\<noteq> (- w) `\\<rightarrow> C &&& (- w) `\\<rightarrow> C \\<in> X", "by    auto"], ["proof (state)\nthis:\n  C0 \\<sim> (- w) `\\<rightarrow> C\n  C0 \\<noteq> (- w) `\\<rightarrow> C\n  (- w) `\\<rightarrow> C \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "hence \"(-w)`\\<rightarrow>C \\<in> fundadjset\""], ["proof (prove)\nusing this:\n  C0 \\<sim> (- w) `\\<rightarrow> C\n  C0 \\<noteq> (- w) `\\<rightarrow> C\n  (- w) `\\<rightarrow> C \\<in> X\n\ngoal (1 subgoal):\n 1. (- w) `\\<rightarrow> C \\<in> adjacentset C0 - {C0}", "using adjacentset_def"], ["proof (prove)\nusing this:\n  C0 \\<sim> (- w) `\\<rightarrow> C\n  C0 \\<noteq> (- w) `\\<rightarrow> C\n  (- w) `\\<rightarrow> C \\<in> X\n  adjacentset ?x = {y \\<in> X. ?x \\<sim> y}\n\ngoal (1 subgoal):\n 1. (- w) `\\<rightarrow> C \\<in> adjacentset C0 - {C0}", "by fast"], ["proof (state)\nthis:\n  (- w) `\\<rightarrow> C \\<in> adjacentset C0 - {C0}\n\ngoal (1 subgoal):\n 1. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "from this"], ["proof (chain)\npicking this:\n  (- w) `\\<rightarrow> C \\<in> adjacentset C0 - {C0}", "obtain s where s: \"s\\<in>S\" \"(-w)`\\<rightarrow>C = s`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  (- w) `\\<rightarrow> C \\<in> adjacentset C0 - {C0}\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g});\n         (- w) `\\<rightarrow> C = s `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using fundadjset_eq_S_image"], ["proof (prove)\nusing this:\n  (- w) `\\<rightarrow> C \\<in> adjacentset C0 - {C0}\n  ?D \\<in> adjacentset C0 - {C0} \\<Longrightarrow>\n  \\<exists>s\\<in>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}.\n     ?D = s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g});\n         (- w) `\\<rightarrow> C = s `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  (- w) `\\<rightarrow> C = s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "from s(2)"], ["proof (chain)\npicking this:\n  (- w) `\\<rightarrow> C = s `\\<rightarrow> C0", "have\n    \"(permutation w \\<circ> permutation (-w))`C = (permutation w \\<circ> permutation s)`C0\""], ["proof (prove)\nusing this:\n  (- w) `\\<rightarrow> C = s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. ((\\<rightarrow>) w \\<circ> (\\<rightarrow>) (- w)) ` C =\n    ((\\<rightarrow>) w \\<circ> (\\<rightarrow>) s) ` C0", "by (simp add: image_comp[THEN sym])"], ["proof (state)\nthis:\n  ((\\<rightarrow>) w \\<circ> (\\<rightarrow>) (- w)) ` C =\n  ((\\<rightarrow>) w \\<circ> (\\<rightarrow>) s) ` C0\n\ngoal (1 subgoal):\n 1. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "hence \"C = (w+s)`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  ((\\<rightarrow>) w \\<circ> (\\<rightarrow>) (- w)) ` C =\n  ((\\<rightarrow>) w \\<circ> (\\<rightarrow>) s) ` C0\n\ngoal (1 subgoal):\n 1. C = (w + s) `\\<rightarrow> C0", "by (simp add: plus_permutation.rep_eq[THEN sym] zero_permutation.rep_eq)"], ["proof (state)\nthis:\n  C = (w + s) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x xs C.\n       \\<lbrakk>\\<And>C.\n                   pgallery (C0 # xs @ [C]) \\<Longrightarrow>\n                   \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                      C = w `\\<rightarrow> C0;\n        pgallery (C0 # (xs @ [x]) @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>\\<langle>\\<Union>(f,\n              g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                            C = w `\\<rightarrow> C0", "with w(1) s(1)"], ["proof (chain)\npicking this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  C = (w + s) `\\<rightarrow> C0", "show ?case"], ["proof (prove)\nusing this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  C = (w + s) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>\\<langle>\\<Union>a\\<in>fundfoldpairs.\n                               case a of\n                               (f, g) \\<Rightarrow>\n                                 {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "using genby_genset_closed[of s S] genby_add_closed"], ["proof (prove)\nusing this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  C = (w + s) `\\<rightarrow> C0\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  s \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  \\<lbrakk>?g \\<in> \\<langle>?S\\<rangle>;\n   ?h \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?g + ?h \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>\\<langle>\\<Union>a\\<in>fundfoldpairs.\n                               case a of\n                               (f, g) \\<Rightarrow>\n                                 {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "by blast"], ["proof (state)\nthis:\n  \\<exists>w\\<in>\\<langle>\\<Union>a\\<in>fundfoldpairs.\n                             case a of\n                             (f, g) \\<Rightarrow>\n                               {Abs_induced_automorph f g}\\<rangle>.\n     C = w `\\<rightarrow> C0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chamber_eq_W_image:\n  assumes \"chamber C\"\n  shows   \"\\<exists>w\\<in>W. C = w`\\<rightarrow>C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "proof (cases \"C=C0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C = C0 \\<Longrightarrow>\n    \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0\n 2. C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "case True"], ["proof (state)\nthis:\n  C = C0\n\ngoal (2 subgoals):\n 1. C = C0 \\<Longrightarrow>\n    \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0\n 2. C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "hence \"0\\<in>W\" \"C = 0`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  C = C0\n\ngoal (1 subgoal):\n 1. 0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}\\<rangle> &&&\n    C = 0 `\\<rightarrow> C0", "using genby_0_closed"], ["proof (prove)\nusing this:\n  C = C0\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. 0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}\\<rangle> &&&\n    C = 0 `\\<rightarrow> C0", "by (auto simp add: zero_permutation.rep_eq)"], ["proof (state)\nthis:\n  0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  C = 0 `\\<rightarrow> C0\n\ngoal (2 subgoals):\n 1. C = C0 \\<Longrightarrow>\n    \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0\n 2. C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  C = 0 `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "by fast"], ["proof (state)\nthis:\n  \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g}\\<rangle>.\n     C = w `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "case False"], ["proof (state)\nthis:\n  C \\<noteq> C0\n\ngoal (1 subgoal):\n 1. C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "with assms"], ["proof (chain)\npicking this:\n  chamber C\n  C \\<noteq> C0", "show ?thesis"], ["proof (prove)\nusing this:\n  chamber C\n  C \\<noteq> C0\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "using fundchamber chamber_pconnect pgallery_last_eq_W_image"], ["proof (prove)\nusing this:\n  chamber C\n  C \\<noteq> C0\n  chamber C0\n  \\<lbrakk>?x \\<noteq> ?y; chamber ?x; chamber ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs. pgallery (?x # xs @ [?y])\n  pgallery (C0 # ?Cs @ [?C]) \\<Longrightarrow>\n  \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g}\\<rangle>.\n     ?C = w `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n       C = w `\\<rightarrow> C0", "by blast"], ["proof (state)\nthis:\n  \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g}\\<rangle>.\n     C = w `\\<rightarrow> C0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma S_list_image_crosses_walls:\n  \"ss \\<in> lists S \\<Longrightarrow> {} \\<notin> set (wall_crossings (map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)))", "proof (induct ss rule: list_induct_ssnoc)"], ["proof (state)\ngoal (3 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [])))\n 2. \\<And>x.\n       [x]\n       \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n       {} \\<notin> set (wall_crossings\n                         (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [x])))\n 3. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                {} \\<notin> set (wall_crossings\n                                  (map (\\<lambda>w. w `\\<rightarrow> C0)\n                                    (sums (xs @ [x]))));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> {} \\<notin> set\n(wall_crossings\n  (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x, y]))))", "case (Single s)"], ["proof (state)\nthis:\n  [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n\ngoal (3 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [])))\n 2. \\<And>x.\n       [x]\n       \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n       {} \\<notin> set (wall_crossings\n                         (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [x])))\n 3. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                {} \\<notin> set (wall_crossings\n                                  (map (\\<lambda>w. w `\\<rightarrow> C0)\n                                    (sums (xs @ [x]))));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> {} \\<notin> set\n(wall_crossings\n  (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x, y]))))", "thus ?case"], ["proof (prove)\nusing this:\n  [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [s])))", "using fundchamber fundchamber_S_chamber fundchamber_S_adjacent\n          fundchamber_S_image_neq_fundchamber[of s] ex_walls[of C0 \"s`\\<rightarrow>C0\"]\n          OpposedThinChamberComplexFoldings.this_wall_betw_basechambers"], ["proof (prove)\nusing this:\n  [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  chamber C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  chamber (?s `\\<rightarrow> C0)\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<sim> ?s `\\<rightarrow> C0\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  s `\\<rightarrow> C0 \\<noteq> C0\n  \\<lbrakk>chamber C0; chamber (s `\\<rightarrow> C0);\n   C0 \\<sim> s `\\<rightarrow> C0; C0 \\<noteq> s `\\<rightarrow> C0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f g.\n                       OpposedThinChamberComplexFoldings X f g C0 \\<and>\n                       s `\\<rightarrow> C0 = g ` C0\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>ThinChamberComplex.foldpairs ?X.\n                   {{f \\<turnstile> ChamberComplex.chamber_system ?X,\n                     g \\<turnstile>\n                     ChamberComplex.chamber_system ?X}}) \\<and>\n       separated_by H ?C0.0 (?g ` ?C0.0)) =\n  {?f \\<turnstile> ChamberComplex.chamber_system ?X,\n   ?g \\<turnstile> ChamberComplex.chamber_system ?X}\n\ngoal (1 subgoal):\n 1. {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [s])))", "by    (force simp add: zero_permutation.rep_eq)"], ["proof (state)\nthis:\n  {} \\<notin> set (wall_crossings\n                    (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [s])))\n\ngoal (2 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [])))\n 2. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                {} \\<notin> set (wall_crossings\n                                  (map (\\<lambda>w. w `\\<rightarrow> C0)\n                                    (sums (xs @ [x]))));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> {} \\<notin> set\n(wall_crossings\n  (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x, y]))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [])))\n 2. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                {} \\<notin> set (wall_crossings\n                                  (map (\\<lambda>w. w `\\<rightarrow> C0)\n                                    (sums (xs @ [x]))));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> {} \\<notin> set\n(wall_crossings\n  (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x, y]))))", "case (ssnoc ss s t)"], ["proof (state)\nthis:\n  ss @ [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of\n             (f, g) \\<Rightarrow>\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  {} \\<notin> set (wall_crossings\n                    (map (\\<lambda>w. w `\\<rightarrow> C0)\n                      (sums (ss @ [s]))))\n  ss @ [s, t]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n\ngoal (2 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [])))\n 2. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                {} \\<notin> set (wall_crossings\n                                  (map (\\<lambda>w. w `\\<rightarrow> C0)\n                                    (sums (xs @ [x]))));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> {} \\<notin> set\n(wall_crossings\n  (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x, y]))))", "moreover"], ["proof (state)\nthis:\n  ss @ [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of\n             (f, g) \\<Rightarrow>\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  {} \\<notin> set (wall_crossings\n                    (map (\\<lambda>w. w `\\<rightarrow> C0)\n                      (sums (ss @ [s]))))\n  ss @ [s, t]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n\ngoal (2 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [])))\n 2. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                {} \\<notin> set (wall_crossings\n                                  (map (\\<lambda>w. w `\\<rightarrow> C0)\n                                    (sums (xs @ [x]))));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> {} \\<notin> set\n(wall_crossings\n  (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x, y]))))", "define A B where \"A = sum_list (ss@[s]) `\\<rightarrow> C0\" and \"B = sum_list (ss@[s,t]) `\\<rightarrow> C0\""], ["proof (state)\nthis:\n  A = sum_list (ss @ [s]) `\\<rightarrow> C0\n  B = sum_list (ss @ [s, t]) `\\<rightarrow> C0\n\ngoal (2 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [])))\n 2. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                {} \\<notin> set (wall_crossings\n                                  (map (\\<lambda>w. w `\\<rightarrow> C0)\n                                    (sums (xs @ [x]))));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> {} \\<notin> set\n(wall_crossings\n  (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x, y]))))", "moreover"], ["proof (state)\nthis:\n  A = sum_list (ss @ [s]) `\\<rightarrow> C0\n  B = sum_list (ss @ [s, t]) `\\<rightarrow> C0\n\ngoal (2 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [])))\n 2. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                {} \\<notin> set (wall_crossings\n                                  (map (\\<lambda>w. w `\\<rightarrow> C0)\n                                    (sums (xs @ [x]))));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> {} \\<notin> set\n(wall_crossings\n  (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x, y]))))", "from ssnoc(2) A_def B_def"], ["proof (chain)\npicking this:\n  ss @ [s, t]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  A = sum_list (ss @ [s]) `\\<rightarrow> C0\n  B = sum_list (ss @ [s, t]) `\\<rightarrow> C0", "obtain f g\n    where \"OpposedThinChamberComplexFoldings X f g A\" \"B=g`A\""], ["proof (prove)\nusing this:\n  ss @ [s, t]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  A = sum_list (ss @ [s]) `\\<rightarrow> C0\n  B = sum_list (ss @ [s, t]) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>OpposedThinChamberComplexFoldings X f g A;\n         B = g ` A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sum_list_S_in_W[of \"ss@[s]\"] sum_list_S_in_W[of \"ss@[s,t]\"]\n          fundchamber_W_image_chamber sum_list_append[of \"ss@[s]\" \"[t]\"]\n          fundchamber_next_WS_image_neq[of t \"sum_list (ss@[s])\"]\n          fundchamber_WS_image_adjacent[of \"sum_list (ss@[s])\" t]\n          ex_walls[of A B]"], ["proof (prove)\nusing this:\n  ss @ [s, t]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  A = sum_list (ss @ [s]) `\\<rightarrow> C0\n  B = sum_list (ss @ [s, t]) `\\<rightarrow> C0\n  ss @ [s]\n  \\<in> lists\n         (\\<Union>(f, g)\\<in>fundfoldpairs.\n             {Abs_induced_automorph f g}) \\<Longrightarrow>\n  sum_list (ss @ [s])\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  ss @ [s, t]\n  \\<in> lists\n         (\\<Union>(f, g)\\<in>fundfoldpairs.\n             {Abs_induced_automorph f g}) \\<Longrightarrow>\n  sum_list (ss @ [s, t])\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  ?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f\n                         g}\\<rangle> \\<Longrightarrow>\n  chamber (?w `\\<rightarrow> C0)\n  sum_list ((ss @ [s]) @ [t]) = sum_list (ss @ [s]) + sum_list [t]\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  (sum_list (ss @ [s]) + t) `\\<rightarrow> C0 \\<noteq>\n  sum_list (ss @ [s]) `\\<rightarrow> C0\n  \\<lbrakk>sum_list (ss @ [s])\n           \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g}\\<rangle>;\n   t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g})\\<rbrakk>\n  \\<Longrightarrow> sum_list (ss @ [s]) `\\<rightarrow> C0 \\<sim>\n                    (sum_list (ss @ [s]) + t) `\\<rightarrow> C0\n  \\<lbrakk>chamber A; chamber B; A \\<sim> B; A \\<noteq> B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f g.\n                       OpposedThinChamberComplexFoldings X f g A \\<and>\n                       B = g ` A\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>OpposedThinChamberComplexFoldings X f g A;\n         B = g ` A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g A\n  B = g ` A\n\ngoal (2 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [])))\n 2. \\<And>xs x y.\n       \\<lbrakk>xs @ [x]\n                \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}) \\<Longrightarrow>\n                {} \\<notin> set (wall_crossings\n                                  (map (\\<lambda>w. w `\\<rightarrow> C0)\n                                    (sums (xs @ [x]))));\n        xs @ [x, y]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> {} \\<notin> set\n(wall_crossings\n  (map (\\<lambda>w. w `\\<rightarrow> C0) (sums (xs @ [x, y]))))", "ultimately"], ["proof (chain)\npicking this:\n  ss @ [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of\n             (f, g) \\<Rightarrow>\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  {} \\<notin> set (wall_crossings\n                    (map (\\<lambda>w. w `\\<rightarrow> C0)\n                      (sums (ss @ [s]))))\n  ss @ [s, t]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  A = sum_list (ss @ [s]) `\\<rightarrow> C0\n  B = sum_list (ss @ [s, t]) `\\<rightarrow> C0\n  OpposedThinChamberComplexFoldings X f g A\n  B = g ` A", "show ?case"], ["proof (prove)\nusing this:\n  ss @ [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of\n             (f, g) \\<Rightarrow>\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  {} \\<notin> set (wall_crossings\n                    (map (\\<lambda>w. w `\\<rightarrow> C0)\n                      (sums (ss @ [s]))))\n  ss @ [s, t]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  A = sum_list (ss @ [s]) `\\<rightarrow> C0\n  B = sum_list (ss @ [s, t]) `\\<rightarrow> C0\n  OpposedThinChamberComplexFoldings X f g A\n  B = g ` A\n\ngoal (1 subgoal):\n 1. {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0)\n                        (sums (ss @ [s, t]))))", "using OpposedThinChamberComplexFoldings.this_wall_betw_basechambers\n          sums_snoc[of \"ss@[s]\" t]"], ["proof (prove)\nusing this:\n  ss @ [s]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of\n             (f, g) \\<Rightarrow>\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  {} \\<notin> set (wall_crossings\n                    (map (\\<lambda>w. w `\\<rightarrow> C0)\n                      (sums (ss @ [s]))))\n  ss @ [s, t]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  A = sum_list (ss @ [s]) `\\<rightarrow> C0\n  B = sum_list (ss @ [s, t]) `\\<rightarrow> C0\n  OpposedThinChamberComplexFoldings X f g A\n  B = g ` A\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>ThinChamberComplex.foldpairs ?X.\n                   {{f \\<turnstile> ChamberComplex.chamber_system ?X,\n                     g \\<turnstile>\n                     ChamberComplex.chamber_system ?X}}) \\<and>\n       separated_by H ?C0.0 (?g ` ?C0.0)) =\n  {?f \\<turnstile> ChamberComplex.chamber_system ?X,\n   ?g \\<turnstile> ChamberComplex.chamber_system ?X}\n  sums ((ss @ [s]) @ [t]) = sums (ss @ [s]) @ [sum_list ((ss @ [s]) @ [t])]\n\ngoal (1 subgoal):\n 1. {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0)\n                        (sums (ss @ [s, t]))))", "by    (force simp add: sums_snoc wall_crossings_snoc)"], ["proof (state)\nthis:\n  {} \\<notin> set (wall_crossings\n                    (map (\\<lambda>w. w `\\<rightarrow> C0)\n                      (sums (ss @ [s, t]))))\n\ngoal (1 subgoal):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    {} \\<notin> set (wall_crossings\n                      (map (\\<lambda>w. w `\\<rightarrow> C0) (sums [])))", "qed (simp add: zero_permutation.rep_eq)"], ["", "end"], ["", "(* context ThinChamberComplexManyFoldings *)"], ["", "subsubsection \\<open>A labelling by the vertices of the fundamental chamber\\<close>"], ["", "text \\<open>\n  Here we show that by repeatedly applying the composition of all the elements in the collection\n  @{term S} of fundamental automorphisms, we can retract the entire chamber complex onto the\n  fundamental chamber. This retraction provides a means of labelling the chamber complex, using the\n  vertices of the fundamental chamber as labels.\n\\<close>"], ["", "context ThinChamberComplexManyFoldings\nbegin"], ["", "definition Spair :: \"'a permutation \\<Rightarrow> ('a\\<Rightarrow>'a)\\<times>('a\\<Rightarrow>'a)\"\n  where \"Spair s \\<equiv>\n          SOME fg. fg \\<in> fundfoldpairs \\<and> s = case_prod Abs_induced_automorph fg\""], ["", "lemma Spair_fundfoldpair: \"s\\<in>S \\<Longrightarrow> Spair s \\<in> fundfoldpairs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    Spair s \\<in> fundfoldpairs", "using Spair_def\n        someI_ex[of\n          \"\\<lambda>fg. fg \\<in> fundfoldpairs \\<and>\n            s = case_prod Abs_induced_automorph fg\"\n        ]"], ["proof (prove)\nusing this:\n  Spair ?s \\<equiv>\n  SOME fg.\n     fg \\<in> fundfoldpairs \\<and>\n     ?s = (case fg of (f, g) \\<Rightarrow> Abs_induced_automorph f g)\n  \\<exists>x.\n     x \\<in> fundfoldpairs \\<and>\n     s =\n     (case x of\n      (f, g) \\<Rightarrow> Abs_induced_automorph f g) \\<Longrightarrow>\n  (SOME x.\n      x \\<in> fundfoldpairs \\<and>\n      s = (case x of (f, g) \\<Rightarrow> Abs_induced_automorph f g))\n  \\<in> fundfoldpairs \\<and>\n  s =\n  (case SOME x.\n           x \\<in> fundfoldpairs \\<and>\n           s = (case x of (f, g) \\<Rightarrow> Abs_induced_automorph f g) of\n   (f, g) \\<Rightarrow> Abs_induced_automorph f g)\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    Spair s \\<in> fundfoldpairs", "by    auto"], ["", "lemma Spair_induced_automorph:\n  \"s\\<in>S \\<Longrightarrow> s = case_prod Abs_induced_automorph (Spair s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    s = (case Spair s of (f, g) \\<Rightarrow> Abs_induced_automorph f g)", "using Spair_def\n        someI_ex[of\n          \"\\<lambda>fg. fg \\<in> fundfoldpairs \\<and>\n            s = case_prod Abs_induced_automorph fg\"\n        ]"], ["proof (prove)\nusing this:\n  Spair ?s \\<equiv>\n  SOME fg.\n     fg \\<in> fundfoldpairs \\<and>\n     ?s = (case fg of (f, g) \\<Rightarrow> Abs_induced_automorph f g)\n  \\<exists>x.\n     x \\<in> fundfoldpairs \\<and>\n     s =\n     (case x of\n      (f, g) \\<Rightarrow> Abs_induced_automorph f g) \\<Longrightarrow>\n  (SOME x.\n      x \\<in> fundfoldpairs \\<and>\n      s = (case x of (f, g) \\<Rightarrow> Abs_induced_automorph f g))\n  \\<in> fundfoldpairs \\<and>\n  s =\n  (case SOME x.\n           x \\<in> fundfoldpairs \\<and>\n           s = (case x of (f, g) \\<Rightarrow> Abs_induced_automorph f g) of\n   (f, g) \\<Rightarrow> Abs_induced_automorph f g)\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    s = (case Spair s of (f, g) \\<Rightarrow> Abs_induced_automorph f g)", "by    auto"], ["", "lemma S_list_pgallery_decomp1:\n  assumes ss: \"set ss = S\" and gal: \"Cs\\<noteq>[]\" \"pgallery (C0#Cs)\"\n  shows   \"\\<exists>s\\<in>set ss. \\<exists>C\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n            s = Abs_induced_automorph f g \\<longrightarrow> C \\<in> g\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>set ss.\n       \\<exists>C\\<in>set Cs.\n          \\<forall>(f, g)\\<in>fundfoldpairs.\n             s = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> g \\<turnstile> \\<C>", "proof (cases Cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. Cs = [] \\<Longrightarrow>\n    \\<exists>s\\<in>set ss.\n       \\<exists>C\\<in>set Cs.\n          \\<forall>(f, g)\\<in>fundfoldpairs.\n             s = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> g \\<turnstile> \\<C>\n 2. \\<And>a list.\n       Cs = a # list \\<Longrightarrow>\n       \\<exists>s\\<in>set ss.\n          \\<exists>C\\<in>set Cs.\n             \\<forall>(f, g)\\<in>fundfoldpairs.\n                s = Abs_induced_automorph f g \\<longrightarrow>\n                C \\<in> g \\<turnstile> \\<C>", "case (Cons D Ds)"], ["proof (state)\nthis:\n  Cs = D # Ds\n\ngoal (2 subgoals):\n 1. Cs = [] \\<Longrightarrow>\n    \\<exists>s\\<in>set ss.\n       \\<exists>C\\<in>set Cs.\n          \\<forall>(f, g)\\<in>fundfoldpairs.\n             s = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> g \\<turnstile> \\<C>\n 2. \\<And>a list.\n       Cs = a # list \\<Longrightarrow>\n       \\<exists>s\\<in>set ss.\n          \\<exists>C\\<in>set Cs.\n             \\<forall>(f, g)\\<in>fundfoldpairs.\n                s = Abs_induced_automorph f g \\<longrightarrow>\n                C \\<in> g \\<turnstile> \\<C>", "with gal(2)"], ["proof (chain)\npicking this:\n  pgallery (C0 # Cs)\n  Cs = D # Ds", "have \"D\\<in>fundadjset\""], ["proof (prove)\nusing this:\n  pgallery (C0 # Cs)\n  Cs = D # Ds\n\ngoal (1 subgoal):\n 1. D \\<in> adjacentset C0 - {C0}", "using pgallery_def chamberD_simplex adjacentset_def"], ["proof (prove)\nusing this:\n  pgallery (C0 # Cs)\n  Cs = D # Ds\n  pgallery ?xs \\<equiv> Ball (set ?xs) chamber \\<and> padjacentchain ?xs\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n  adjacentset ?x = {y \\<in> X. ?x \\<sim> y}\n\ngoal (1 subgoal):\n 1. D \\<in> adjacentset C0 - {C0}", "by fastforce"], ["proof (state)\nthis:\n  D \\<in> adjacentset C0 - {C0}\n\ngoal (2 subgoals):\n 1. Cs = [] \\<Longrightarrow>\n    \\<exists>s\\<in>set ss.\n       \\<exists>C\\<in>set Cs.\n          \\<forall>(f, g)\\<in>fundfoldpairs.\n             s = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> g \\<turnstile> \\<C>\n 2. \\<And>a list.\n       Cs = a # list \\<Longrightarrow>\n       \\<exists>s\\<in>set ss.\n          \\<exists>C\\<in>set Cs.\n             \\<forall>(f, g)\\<in>fundfoldpairs.\n                s = Abs_induced_automorph f g \\<longrightarrow>\n                C \\<in> g \\<turnstile> \\<C>", "from this"], ["proof (chain)\npicking this:\n  D \\<in> adjacentset C0 - {C0}", "obtain s where s: \"s\\<in>S\" \"D = s`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  D \\<in> adjacentset C0 - {C0}\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g});\n         D = s `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using fundadjset_eq_S_image"], ["proof (prove)\nusing this:\n  D \\<in> adjacentset C0 - {C0}\n  ?D \\<in> adjacentset C0 - {C0} \\<Longrightarrow>\n  \\<exists>s\\<in>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}.\n     ?D = s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g});\n         D = s `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  D = s `\\<rightarrow> C0\n\ngoal (2 subgoals):\n 1. Cs = [] \\<Longrightarrow>\n    \\<exists>s\\<in>set ss.\n       \\<exists>C\\<in>set Cs.\n          \\<forall>(f, g)\\<in>fundfoldpairs.\n             s = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> g \\<turnstile> \\<C>\n 2. \\<And>a list.\n       Cs = a # list \\<Longrightarrow>\n       \\<exists>s\\<in>set ss.\n          \\<exists>C\\<in>set Cs.\n             \\<forall>(f, g)\\<in>fundfoldpairs.\n                s = Abs_induced_automorph f g \\<longrightarrow>\n                C \\<in> g \\<turnstile> \\<C>", "from s(2)"], ["proof (chain)\npicking this:\n  D = s `\\<rightarrow> C0", "have\n    \"\\<forall>(f,g)\\<in>fundfoldpairs. s = Abs_induced_automorph f g \\<longrightarrow> D\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  D = s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<forall>(f, g)\\<in>fundfoldpairs.\n       s = Abs_induced_automorph f g \\<longrightarrow>\n       D \\<in> g \\<turnstile> \\<C>", "using fundfoldpairs_def fundfoldpairs_fundchamber_image \n          OpposedThinChamberComplexFoldings.basechambers_half_chamber_systems(2)"], ["proof (prove)\nusing this:\n  D = s `\\<rightarrow> C0\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  (?f, ?g) \\<in> fundfoldpairs \\<Longrightarrow>\n  Abs_induced_automorph ?f ?g `\\<rightarrow> C0 = ?g ` C0\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  ?g ` ?C0.0 \\<in> ?g \\<turnstile> ChamberComplex.chamber_system ?X\n\ngoal (1 subgoal):\n 1. \\<forall>(f, g)\\<in>fundfoldpairs.\n       s = Abs_induced_automorph f g \\<longrightarrow>\n       D \\<in> g \\<turnstile> \\<C>", "by    auto"], ["proof (state)\nthis:\n  \\<forall>(f, g)\\<in>fundfoldpairs.\n     s = Abs_induced_automorph f g \\<longrightarrow>\n     D \\<in> g \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. Cs = [] \\<Longrightarrow>\n    \\<exists>s\\<in>set ss.\n       \\<exists>C\\<in>set Cs.\n          \\<forall>(f, g)\\<in>fundfoldpairs.\n             s = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> g \\<turnstile> \\<C>\n 2. \\<And>a list.\n       Cs = a # list \\<Longrightarrow>\n       \\<exists>s\\<in>set ss.\n          \\<exists>C\\<in>set Cs.\n             \\<forall>(f, g)\\<in>fundfoldpairs.\n                s = Abs_induced_automorph f g \\<longrightarrow>\n                C \\<in> g \\<turnstile> \\<C>", "with s(1) ss Cons"], ["proof (chain)\npicking this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  Cs = D # Ds\n  \\<forall>(f, g)\\<in>fundfoldpairs.\n     s = Abs_induced_automorph f g \\<longrightarrow>\n     D \\<in> g \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  Cs = D # Ds\n  \\<forall>(f, g)\\<in>fundfoldpairs.\n     s = Abs_induced_automorph f g \\<longrightarrow>\n     D \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>set ss.\n       \\<exists>C\\<in>set Cs.\n          \\<forall>(f, g)\\<in>fundfoldpairs.\n             s = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> g \\<turnstile> \\<C>", "by auto"], ["proof (state)\nthis:\n  \\<exists>s\\<in>set ss.\n     \\<exists>C\\<in>set Cs.\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           s = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. Cs = [] \\<Longrightarrow>\n    \\<exists>s\\<in>set ss.\n       \\<exists>C\\<in>set Cs.\n          \\<forall>(f, g)\\<in>fundfoldpairs.\n             s = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> g \\<turnstile> \\<C>", "qed (simp add: gal(1))"], ["", "lemma S_list_pgallery_decomp2:\n  assumes \"set ss = S\" \"Cs\\<noteq>[]\" \"pgallery (C0#Cs)\"\n  shows\n    \"\\<exists>rs s ts. ss = rs@s#ts \\<and>\n      (\\<exists>C\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow> C \\<in> g\\<turnstile>\\<C>) \\<and>\n        (\\<forall>r\\<in>set rs. \\<forall>C\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n          r = Abs_induced_automorph f g \\<longrightarrow> C\\<in>f\\<turnstile>\\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rs s ts.\n       ss = rs @ s # ts \\<and>\n       (\\<exists>C\\<in>set Cs.\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              s = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> g \\<turnstile> \\<C>) \\<and>\n       (\\<forall>r\\<in>set rs.\n           \\<forall>C\\<in>set Cs.\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>rs s ts.\n       ss = rs @ s # ts \\<and>\n       (\\<exists>C\\<in>set Cs.\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              s = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> g \\<turnstile> \\<C>) \\<and>\n       (\\<forall>r\\<in>set rs.\n           \\<forall>C\\<in>set Cs.\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>)", "from assms"], ["proof (chain)\npicking this:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  Cs \\<noteq> []\n  pgallery (C0 # Cs)", "obtain rs s ts  where rs_s_ts:\n    \"ss = rs@s#ts\"\n    \"\\<exists>C\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n      s = Abs_induced_automorph f g \\<longrightarrow> C \\<in> g\\<turnstile>\\<C>\"\n    \"\\<forall>r\\<in>set rs. \\<forall>C\\<in>set Cs.\n      \\<not> (\\<forall>(f,g)\\<in>fundfoldpairs. r = Abs_induced_automorph f g \\<longrightarrow> C \\<in> g\\<turnstile>\\<C>)\""], ["proof (prove)\nusing this:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  Cs \\<noteq> []\n  pgallery (C0 # Cs)\n\ngoal (1 subgoal):\n 1. (\\<And>rs s ts.\n        \\<lbrakk>ss = rs @ s # ts;\n         \\<exists>C\\<in>set Cs.\n            \\<forall>(f, g)\\<in>fundfoldpairs.\n               s = Abs_induced_automorph f g \\<longrightarrow>\n               C \\<in> g \\<turnstile> \\<C>;\n         \\<forall>r\\<in>set rs.\n            \\<forall>C\\<in>set Cs.\n               \\<not> (\\<forall>(f, g)\\<in>fundfoldpairs.\n                          r = Abs_induced_automorph f g \\<longrightarrow>\n                          C \\<in> g \\<turnstile> \\<C>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using split_list_first_prop[OF S_list_pgallery_decomp1, of ss Cs]"], ["proof (prove)\nusing this:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  Cs \\<noteq> []\n  pgallery (C0 # Cs)\n  \\<lbrakk>set ss =\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   Cs \\<noteq> []; pgallery (C0 # Cs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ys x zs.\n                       ss = ys @ x # zs \\<and>\n                       (\\<exists>C\\<in>set Cs.\n                           \\<forall>(f, g)\\<in>fundfoldpairs.\n                              x =\n                              Abs_induced_automorph f g \\<longrightarrow>\n                              C \\<in> g \\<turnstile> \\<C>) \\<and>\n                       (\\<forall>y\\<in>set ys.\n                           \\<not> (\\<exists>C\\<in>set Cs.\n\\<forall>(f, g)\\<in>fundfoldpairs.\n   y = Abs_induced_automorph f g \\<longrightarrow>\n   C \\<in> g \\<turnstile> \\<C>))\n\ngoal (1 subgoal):\n 1. (\\<And>rs s ts.\n        \\<lbrakk>ss = rs @ s # ts;\n         \\<exists>C\\<in>set Cs.\n            \\<forall>(f, g)\\<in>fundfoldpairs.\n               s = Abs_induced_automorph f g \\<longrightarrow>\n               C \\<in> g \\<turnstile> \\<C>;\n         \\<forall>r\\<in>set rs.\n            \\<forall>C\\<in>set Cs.\n               \\<not> (\\<forall>(f, g)\\<in>fundfoldpairs.\n                          r = Abs_induced_automorph f g \\<longrightarrow>\n                          C \\<in> g \\<turnstile> \\<C>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  ss = rs @ s # ts\n  \\<exists>C\\<in>set Cs.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        C \\<in> g \\<turnstile> \\<C>\n  \\<forall>r\\<in>set rs.\n     \\<forall>C\\<in>set Cs.\n        \\<not> (\\<forall>(f, g)\\<in>fundfoldpairs.\n                   r = Abs_induced_automorph f g \\<longrightarrow>\n                   C \\<in> g \\<turnstile> \\<C>)\n\ngoal (1 subgoal):\n 1. \\<exists>rs s ts.\n       ss = rs @ s # ts \\<and>\n       (\\<exists>C\\<in>set Cs.\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              s = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> g \\<turnstile> \\<C>) \\<and>\n       (\\<forall>r\\<in>set rs.\n           \\<forall>C\\<in>set Cs.\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>)", "have \"\\<forall>r\\<in>set rs. \\<forall>C\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n          r = Abs_induced_automorph f g \\<longrightarrow> C\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set rs.\n       \\<forall>C\\<in>set Cs.\n          \\<forall>(f, g)\\<in>fundfoldpairs.\n             r = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> f \\<turnstile> \\<C>", "proof (rule ballI, rule ballI, rule prod_ballI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r C f g.\n       \\<lbrakk>r \\<in> set rs; C \\<in> set Cs; (f, g) \\<in> fundfoldpairs;\n        r = Abs_induced_automorph f g\\<rbrakk>\n       \\<Longrightarrow> C \\<in> f \\<turnstile> \\<C>", "fix r C f g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r C f g.\n       \\<lbrakk>r \\<in> set rs; C \\<in> set Cs; (f, g) \\<in> fundfoldpairs;\n        r = Abs_induced_automorph f g\\<rbrakk>\n       \\<Longrightarrow> C \\<in> f \\<turnstile> \\<C>", "assume  \"r \\<in> set rs\" \"C \\<in> set Cs\" \"(f,g)\\<in>fundfoldpairs\"\n            \"r = Abs_induced_automorph f g\""], ["proof (state)\nthis:\n  r \\<in> set rs\n  C \\<in> set Cs\n  (f, g) \\<in> fundfoldpairs\n  r = Abs_induced_automorph f g\n\ngoal (1 subgoal):\n 1. \\<And>r C f g.\n       \\<lbrakk>r \\<in> set rs; C \\<in> set Cs; (f, g) \\<in> fundfoldpairs;\n        r = Abs_induced_automorph f g\\<rbrakk>\n       \\<Longrightarrow> C \\<in> f \\<turnstile> \\<C>", "with rs_s_ts(3) assms(3)"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>set rs.\n     \\<forall>C\\<in>set Cs.\n        \\<not> (\\<forall>(f, g)\\<in>fundfoldpairs.\n                   r = Abs_induced_automorph f g \\<longrightarrow>\n                   C \\<in> g \\<turnstile> \\<C>)\n  pgallery (C0 # Cs)\n  r \\<in> set rs\n  C \\<in> set Cs\n  (f, g) \\<in> fundfoldpairs\n  r = Abs_induced_automorph f g", "show \"C\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set rs.\n     \\<forall>C\\<in>set Cs.\n        \\<not> (\\<forall>(f, g)\\<in>fundfoldpairs.\n                   r = Abs_induced_automorph f g \\<longrightarrow>\n                   C \\<in> g \\<turnstile> \\<C>)\n  pgallery (C0 # Cs)\n  r \\<in> set rs\n  C \\<in> set Cs\n  (f, g) \\<in> fundfoldpairs\n  r = Abs_induced_automorph f g\n\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> \\<C>", "using pgalleryD_chamber\n            fundfoldpair_unique_half_chamber_systems_chamber_ng_f[\n              of _ _ f g C\n            ]"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set rs.\n     \\<forall>C\\<in>set Cs.\n        \\<not> (\\<forall>(f, g)\\<in>fundfoldpairs.\n                   r = Abs_induced_automorph f g \\<longrightarrow>\n                   C \\<in> g \\<turnstile> \\<C>)\n  pgallery (C0 # Cs)\n  r \\<in> set rs\n  C \\<in> set Cs\n  (f, g) \\<in> fundfoldpairs\n  r = Abs_induced_automorph f g\n  \\<lbrakk>pgallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> chamber ?x\n  \\<lbrakk>(?f, ?g) \\<in> fundfoldpairs; (f, g) \\<in> fundfoldpairs;\n   Abs_induced_automorph f g = Abs_induced_automorph ?f ?g; chamber C;\n   C \\<notin> ?g \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> C \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C \\<in> f \\<turnstile> \\<C>", "by    fastforce"], ["proof (state)\nthis:\n  C \\<in> f \\<turnstile> \\<C>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set rs.\n     \\<forall>C\\<in>set Cs.\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>rs s ts.\n       ss = rs @ s # ts \\<and>\n       (\\<exists>C\\<in>set Cs.\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              s = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> g \\<turnstile> \\<C>) \\<and>\n       (\\<forall>r\\<in>set rs.\n           \\<forall>C\\<in>set Cs.\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>)", "with rs_s_ts(1,2)"], ["proof (chain)\npicking this:\n  ss = rs @ s # ts\n  \\<exists>C\\<in>set Cs.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        C \\<in> g \\<turnstile> \\<C>\n  \\<forall>r\\<in>set rs.\n     \\<forall>C\\<in>set Cs.\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  ss = rs @ s # ts\n  \\<exists>C\\<in>set Cs.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        C \\<in> g \\<turnstile> \\<C>\n  \\<forall>r\\<in>set rs.\n     \\<forall>C\\<in>set Cs.\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>rs s ts.\n       ss = rs @ s # ts \\<and>\n       (\\<exists>C\\<in>set Cs.\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              s = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> g \\<turnstile> \\<C>) \\<and>\n       (\\<forall>r\\<in>set rs.\n           \\<forall>C\\<in>set Cs.\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>rs s ts.\n     ss = rs @ s # ts \\<and>\n     (\\<exists>C\\<in>set Cs.\n         \\<forall>(f, g)\\<in>fundfoldpairs.\n            s = Abs_induced_automorph f g \\<longrightarrow>\n            C \\<in> g \\<turnstile> \\<C>) \\<and>\n     (\\<forall>r\\<in>set rs.\n         \\<forall>C\\<in>set Cs.\n            \\<forall>(f, g)\\<in>fundfoldpairs.\n               r = Abs_induced_automorph f g \\<longrightarrow>\n               C \\<in> f \\<turnstile> \\<C>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma S_list_pgallery_decomp3:\n  assumes \"set ss = S\" \"Cs\\<noteq>[]\" \"pgallery (C0#Cs)\"\n  shows\n    \"\\<exists>rs s ts As B Bs. ss = rs@s#ts \\<and> Cs = As@B#Bs \\<and>\n      (\\<forall>(f,g)\\<in>fundfoldpairs. s = Abs_induced_automorph f g \\<longrightarrow> B\\<in>g\\<turnstile>\\<C>) \\<and>\n      (\\<forall>A\\<in>set As. \\<forall>(f,g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow> A\\<in>f\\<turnstile>\\<C>) \\<and>\n      (\\<forall>r\\<in>set rs. \\<forall>C\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow> C\\<in>f\\<turnstile>\\<C>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rs s ts As B Bs.\n       ss = rs @ s # ts \\<and>\n       Cs = As @ B # Bs \\<and>\n       (\\<forall>(f, g)\\<in>fundfoldpairs.\n           s = Abs_induced_automorph f g \\<longrightarrow>\n           B \\<in> g \\<turnstile> \\<C>) \\<and>\n       (\\<forall>A\\<in>set As.\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              s = Abs_induced_automorph f g \\<longrightarrow>\n              A \\<in> f \\<turnstile> \\<C>) \\<and>\n       (\\<forall>r\\<in>set rs.\n           \\<forall>C\\<in>set Cs.\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>rs s ts As B Bs.\n       ss = rs @ s # ts \\<and>\n       Cs = As @ B # Bs \\<and>\n       (\\<forall>(f, g)\\<in>fundfoldpairs.\n           s = Abs_induced_automorph f g \\<longrightarrow>\n           B \\<in> g \\<turnstile> \\<C>) \\<and>\n       (\\<forall>A\\<in>set As.\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              s = Abs_induced_automorph f g \\<longrightarrow>\n              A \\<in> f \\<turnstile> \\<C>) \\<and>\n       (\\<forall>r\\<in>set rs.\n           \\<forall>C\\<in>set Cs.\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>)", "from assms"], ["proof (chain)\npicking this:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  Cs \\<noteq> []\n  pgallery (C0 # Cs)", "obtain rs s ts where rs_s_ts:\n    \"ss = rs@s#ts\"\n    \"\\<exists>B\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs. s = Abs_induced_automorph f g \\<longrightarrow> B \\<in> g\\<turnstile>\\<C>\"\n    \"\\<forall>r\\<in>set rs. \\<forall>B\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n      r = Abs_induced_automorph f g \\<longrightarrow> B\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  Cs \\<noteq> []\n  pgallery (C0 # Cs)\n\ngoal (1 subgoal):\n 1. (\\<And>rs s ts.\n        \\<lbrakk>ss = rs @ s # ts;\n         \\<exists>B\\<in>set Cs.\n            \\<forall>(f, g)\\<in>fundfoldpairs.\n               s = Abs_induced_automorph f g \\<longrightarrow>\n               B \\<in> g \\<turnstile> \\<C>;\n         \\<forall>r\\<in>set rs.\n            \\<forall>B\\<in>set Cs.\n               \\<forall>(f, g)\\<in>fundfoldpairs.\n                  r = Abs_induced_automorph f g \\<longrightarrow>\n                  B \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using S_list_pgallery_decomp2[of ss Cs]"], ["proof (prove)\nusing this:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  Cs \\<noteq> []\n  pgallery (C0 # Cs)\n  \\<lbrakk>set ss =\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   Cs \\<noteq> []; pgallery (C0 # Cs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rs s ts.\n                       ss = rs @ s # ts \\<and>\n                       (\\<exists>C\\<in>set Cs.\n                           \\<forall>(f, g)\\<in>fundfoldpairs.\n                              s =\n                              Abs_induced_automorph f g \\<longrightarrow>\n                              C \\<in> g \\<turnstile> \\<C>) \\<and>\n                       (\\<forall>r\\<in>set rs.\n                           \\<forall>C\\<in>set Cs.\n                              \\<forall>(f, g)\\<in>fundfoldpairs.\n                                 r =\n                                 Abs_induced_automorph f g \\<longrightarrow>\n                                 C \\<in> f \\<turnstile> \\<C>)\n\ngoal (1 subgoal):\n 1. (\\<And>rs s ts.\n        \\<lbrakk>ss = rs @ s # ts;\n         \\<exists>B\\<in>set Cs.\n            \\<forall>(f, g)\\<in>fundfoldpairs.\n               s = Abs_induced_automorph f g \\<longrightarrow>\n               B \\<in> g \\<turnstile> \\<C>;\n         \\<forall>r\\<in>set rs.\n            \\<forall>B\\<in>set Cs.\n               \\<forall>(f, g)\\<in>fundfoldpairs.\n                  r = Abs_induced_automorph f g \\<longrightarrow>\n                  B \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  ss = rs @ s # ts\n  \\<exists>B\\<in>set Cs.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        B \\<in> g \\<turnstile> \\<C>\n  \\<forall>r\\<in>set rs.\n     \\<forall>B\\<in>set Cs.\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           B \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>rs s ts As B Bs.\n       ss = rs @ s # ts \\<and>\n       Cs = As @ B # Bs \\<and>\n       (\\<forall>(f, g)\\<in>fundfoldpairs.\n           s = Abs_induced_automorph f g \\<longrightarrow>\n           B \\<in> g \\<turnstile> \\<C>) \\<and>\n       (\\<forall>A\\<in>set As.\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              s = Abs_induced_automorph f g \\<longrightarrow>\n              A \\<in> f \\<turnstile> \\<C>) \\<and>\n       (\\<forall>r\\<in>set rs.\n           \\<forall>C\\<in>set Cs.\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>)", "obtain As B Bs where As_B_Bs:\n    \"Cs = As@B#Bs\"\n    \"\\<forall>(f,g)\\<in>fundfoldpairs. s = Abs_induced_automorph f g \\<longrightarrow> B \\<in> g\\<turnstile>\\<C>\"\n    \"\\<forall>A\\<in>set As. \\<exists>(f,g)\\<in>fundfoldpairs. s = Abs_induced_automorph f g \\<and> A\\<notin>g\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>As B Bs.\n        \\<lbrakk>Cs = As @ B # Bs;\n         \\<forall>(f, g)\\<in>fundfoldpairs.\n            s = Abs_induced_automorph f g \\<longrightarrow>\n            B \\<in> g \\<turnstile> \\<C>;\n         \\<forall>A\\<in>set As.\n            \\<exists>(f, g)\\<in>fundfoldpairs.\n               s = Abs_induced_automorph f g \\<and>\n               A \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using split_list_first_prop[OF rs_s_ts(2)]"], ["proof (prove)\nusing this:\n  \\<exists>ys x zs.\n     Cs = ys @ x # zs \\<and>\n     (\\<forall>(f, g)\\<in>fundfoldpairs.\n         s = Abs_induced_automorph f g \\<longrightarrow>\n         x \\<in> g \\<turnstile> \\<C>) \\<and>\n     (\\<forall>y\\<in>set ys.\n         \\<not> (\\<forall>(f, g)\\<in>fundfoldpairs.\n                    s = Abs_induced_automorph f g \\<longrightarrow>\n                    y \\<in> g \\<turnstile> \\<C>))\n\ngoal (1 subgoal):\n 1. (\\<And>As B Bs.\n        \\<lbrakk>Cs = As @ B # Bs;\n         \\<forall>(f, g)\\<in>fundfoldpairs.\n            s = Abs_induced_automorph f g \\<longrightarrow>\n            B \\<in> g \\<turnstile> \\<C>;\n         \\<forall>A\\<in>set As.\n            \\<exists>(f, g)\\<in>fundfoldpairs.\n               s = Abs_induced_automorph f g \\<and>\n               A \\<notin> g \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fastforce"], ["proof (state)\nthis:\n  Cs = As @ B # Bs\n  \\<forall>(f, g)\\<in>fundfoldpairs.\n     s = Abs_induced_automorph f g \\<longrightarrow>\n     B \\<in> g \\<turnstile> \\<C>\n  \\<forall>A\\<in>set As.\n     \\<exists>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<and> A \\<notin> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>rs s ts As B Bs.\n       ss = rs @ s # ts \\<and>\n       Cs = As @ B # Bs \\<and>\n       (\\<forall>(f, g)\\<in>fundfoldpairs.\n           s = Abs_induced_automorph f g \\<longrightarrow>\n           B \\<in> g \\<turnstile> \\<C>) \\<and>\n       (\\<forall>A\\<in>set As.\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              s = Abs_induced_automorph f g \\<longrightarrow>\n              A \\<in> f \\<turnstile> \\<C>) \\<and>\n       (\\<forall>r\\<in>set rs.\n           \\<forall>C\\<in>set Cs.\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>)", "from As_B_Bs(1,3) assms(3)"], ["proof (chain)\npicking this:\n  Cs = As @ B # Bs\n  \\<forall>A\\<in>set As.\n     \\<exists>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<and> A \\<notin> g \\<turnstile> \\<C>\n  pgallery (C0 # Cs)", "have \"\\<forall>A\\<in>set As. \\<forall>(f,g)\\<in>fundfoldpairs.\n          s = Abs_induced_automorph f g \\<longrightarrow> A\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  Cs = As @ B # Bs\n  \\<forall>A\\<in>set As.\n     \\<exists>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<and> A \\<notin> g \\<turnstile> \\<C>\n  pgallery (C0 # Cs)\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>set As.\n       \\<forall>(f, g)\\<in>fundfoldpairs.\n          s = Abs_induced_automorph f g \\<longrightarrow>\n          A \\<in> f \\<turnstile> \\<C>", "using pgalleryD_chamber\n            fundfoldpair_unique_half_chamber_systems_chamber_ng_f"], ["proof (prove)\nusing this:\n  Cs = As @ B # Bs\n  \\<forall>A\\<in>set As.\n     \\<exists>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<and> A \\<notin> g \\<turnstile> \\<C>\n  pgallery (C0 # Cs)\n  \\<lbrakk>pgallery ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> chamber ?x\n  \\<lbrakk>(?f, ?g) \\<in> fundfoldpairs; (?f', ?g') \\<in> fundfoldpairs;\n   Abs_induced_automorph ?f' ?g' = Abs_induced_automorph ?f ?g; chamber ?C;\n   ?C \\<notin> ?g \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> ?C \\<in> ?f' \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>set As.\n       \\<forall>(f, g)\\<in>fundfoldpairs.\n          s = Abs_induced_automorph f g \\<longrightarrow>\n          A \\<in> f \\<turnstile> \\<C>", "by    auto"], ["proof (state)\nthis:\n  \\<forall>A\\<in>set As.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        A \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>rs s ts As B Bs.\n       ss = rs @ s # ts \\<and>\n       Cs = As @ B # Bs \\<and>\n       (\\<forall>(f, g)\\<in>fundfoldpairs.\n           s = Abs_induced_automorph f g \\<longrightarrow>\n           B \\<in> g \\<turnstile> \\<C>) \\<and>\n       (\\<forall>A\\<in>set As.\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              s = Abs_induced_automorph f g \\<longrightarrow>\n              A \\<in> f \\<turnstile> \\<C>) \\<and>\n       (\\<forall>r\\<in>set rs.\n           \\<forall>C\\<in>set Cs.\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>)", "with rs_s_ts(1,3) As_B_Bs(1,2)"], ["proof (chain)\npicking this:\n  ss = rs @ s # ts\n  \\<forall>r\\<in>set rs.\n     \\<forall>B\\<in>set Cs.\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           B \\<in> f \\<turnstile> \\<C>\n  Cs = As @ B # Bs\n  \\<forall>(f, g)\\<in>fundfoldpairs.\n     s = Abs_induced_automorph f g \\<longrightarrow>\n     B \\<in> g \\<turnstile> \\<C>\n  \\<forall>A\\<in>set As.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        A \\<in> f \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  ss = rs @ s # ts\n  \\<forall>r\\<in>set rs.\n     \\<forall>B\\<in>set Cs.\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           B \\<in> f \\<turnstile> \\<C>\n  Cs = As @ B # Bs\n  \\<forall>(f, g)\\<in>fundfoldpairs.\n     s = Abs_induced_automorph f g \\<longrightarrow>\n     B \\<in> g \\<turnstile> \\<C>\n  \\<forall>A\\<in>set As.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        A \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<exists>rs s ts As B Bs.\n       ss = rs @ s # ts \\<and>\n       Cs = As @ B # Bs \\<and>\n       (\\<forall>(f, g)\\<in>fundfoldpairs.\n           s = Abs_induced_automorph f g \\<longrightarrow>\n           B \\<in> g \\<turnstile> \\<C>) \\<and>\n       (\\<forall>A\\<in>set As.\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              s = Abs_induced_automorph f g \\<longrightarrow>\n              A \\<in> f \\<turnstile> \\<C>) \\<and>\n       (\\<forall>r\\<in>set rs.\n           \\<forall>C\\<in>set Cs.\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>)", "by fast"], ["proof (state)\nthis:\n  \\<exists>rs s ts As B Bs.\n     ss = rs @ s # ts \\<and>\n     Cs = As @ B # Bs \\<and>\n     (\\<forall>(f, g)\\<in>fundfoldpairs.\n         s = Abs_induced_automorph f g \\<longrightarrow>\n         B \\<in> g \\<turnstile> \\<C>) \\<and>\n     (\\<forall>A\\<in>set As.\n         \\<forall>(f, g)\\<in>fundfoldpairs.\n            s = Abs_induced_automorph f g \\<longrightarrow>\n            A \\<in> f \\<turnstile> \\<C>) \\<and>\n     (\\<forall>r\\<in>set rs.\n         \\<forall>C\\<in>set Cs.\n            \\<forall>(f, g)\\<in>fundfoldpairs.\n               r = Abs_induced_automorph f g \\<longrightarrow>\n               C \\<in> f \\<turnstile> \\<C>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fundfold_trivial_f\\<C>:\n  \"r\\<in>S \\<Longrightarrow> \\<forall>(f,g)\\<in>fundfoldpairs. r = Abs_induced_automorph f g \\<longrightarrow> C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow>\n    fst (Spair r) ` C = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g});\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fst (Spair r) ` C = C", "using Spair_fundfoldpair[of r] Spair_induced_automorph[of r] fundfoldpairs_def\n        OpposedThinChamberComplexFoldings.axioms(2)[\n          of X \"fst (Spair r)\" \"snd (Spair r)\" C0\n        ]\n        ChamberComplexFolding.chamber_retraction2[of X \"fst (Spair r)\" C]"], ["proof (prove)\nusing this:\n  r \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  Spair r \\<in> fundfoldpairs\n  r \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  r = (case Spair r of (f, g) \\<Rightarrow> Abs_induced_automorph f g)\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  OpposedThinChamberComplexFoldings X (fst (Spair r)) (snd (Spair r))\n   C0 \\<Longrightarrow>\n  ChamberComplexFolding X (fst (Spair r))\n  \\<lbrakk>ChamberComplexFolding X (fst (Spair r));\n   C \\<in> fst (Spair r) \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fst (Spair r) ` C = C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g});\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fst (Spair r) ` C = C", "by    fastforce"], ["", "lemma fundfold_comp_trivial_f\\<C>:\n  \"set rs \\<subseteq> S \\<Longrightarrow>\n    \\<forall>r\\<in>set rs. \\<forall>(f,g)\\<in>fundfoldpairs.\n      r = Abs_induced_automorph f g \\<longrightarrow> C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow>\n    fold fst (map Spair rs) ` C = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set rs);\n     \\<forall>r\\<in>set rs.\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair rs) ` C = C", "proof (induct rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set []);\n     \\<forall>r\\<in>set [].\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair []) ` C = C\n 2. \\<And>a rs.\n       \\<lbrakk>\\<lbrakk>order.greater_eq\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          (set rs);\n                 \\<forall>r\\<in>set rs.\n                    \\<forall>(f, g)\\<in>fundfoldpairs.\n                       r = Abs_induced_automorph f g \\<longrightarrow>\n                       C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n                \\<Longrightarrow> fold fst (map Spair rs) ` C = C;\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (a # rs));\n        \\<forall>r\\<in>set (a # rs).\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (a # rs)) ` C = C", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<lbrakk>order.greater_eq\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n            (set rs);\n   \\<forall>r\\<in>set rs.\n      \\<forall>a\\<in>fundfoldpairs.\n         case a of\n         (f, g) \\<Rightarrow>\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fold fst (map Spair rs) ` C = C\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set (r # rs))\n  \\<forall>r\\<in>set (r # rs).\n     \\<forall>a\\<in>fundfoldpairs.\n        case a of\n        (f, g) \\<Rightarrow>\n          r = Abs_induced_automorph f g \\<longrightarrow>\n          C \\<in> f \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set []);\n     \\<forall>r\\<in>set [].\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair []) ` C = C\n 2. \\<And>a rs.\n       \\<lbrakk>\\<lbrakk>order.greater_eq\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          (set rs);\n                 \\<forall>r\\<in>set rs.\n                    \\<forall>(f, g)\\<in>fundfoldpairs.\n                       r = Abs_induced_automorph f g \\<longrightarrow>\n                       C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n                \\<Longrightarrow> fold fst (map Spair rs) ` C = C;\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (a # rs));\n        \\<forall>r\\<in>set (a # rs).\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (a # rs)) ` C = C", "have \"fold fst (map Spair (r#rs)) ` C =\n          fold fst (map Spair rs) ` fst (Spair r) ` C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold fst (map Spair (r # rs)) ` C =\n    fold fst (map Spair rs) ` fst (Spair r) ` C", "by (simp add: image_comp)"], ["proof (state)\nthis:\n  fold fst (map Spair (r # rs)) ` C =\n  fold fst (map Spair rs) ` fst (Spair r) ` C\n\ngoal (2 subgoals):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set []);\n     \\<forall>r\\<in>set [].\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair []) ` C = C\n 2. \\<And>a rs.\n       \\<lbrakk>\\<lbrakk>order.greater_eq\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          (set rs);\n                 \\<forall>r\\<in>set rs.\n                    \\<forall>(f, g)\\<in>fundfoldpairs.\n                       r = Abs_induced_automorph f g \\<longrightarrow>\n                       C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n                \\<Longrightarrow> fold fst (map Spair rs) ` C = C;\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (a # rs));\n        \\<forall>r\\<in>set (a # rs).\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (a # rs)) ` C = C", "also"], ["proof (state)\nthis:\n  fold fst (map Spair (r # rs)) ` C =\n  fold fst (map Spair rs) ` fst (Spair r) ` C\n\ngoal (2 subgoals):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set []);\n     \\<forall>r\\<in>set [].\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair []) ` C = C\n 2. \\<And>a rs.\n       \\<lbrakk>\\<lbrakk>order.greater_eq\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          (set rs);\n                 \\<forall>r\\<in>set rs.\n                    \\<forall>(f, g)\\<in>fundfoldpairs.\n                       r = Abs_induced_automorph f g \\<longrightarrow>\n                       C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n                \\<Longrightarrow> fold fst (map Spair rs) ` C = C;\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (a # rs));\n        \\<forall>r\\<in>set (a # rs).\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (a # rs)) ` C = C", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>order.greater_eq\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n            (set rs);\n   \\<forall>r\\<in>set rs.\n      \\<forall>a\\<in>fundfoldpairs.\n         case a of\n         (f, g) \\<Rightarrow>\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fold fst (map Spair rs) ` C = C\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set (r # rs))\n  \\<forall>r\\<in>set (r # rs).\n     \\<forall>a\\<in>fundfoldpairs.\n        case a of\n        (f, g) \\<Rightarrow>\n          r = Abs_induced_automorph f g \\<longrightarrow>\n          C \\<in> f \\<turnstile> \\<C>", "have \"\\<dots> = C\""], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater_eq\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n            (set rs);\n   \\<forall>r\\<in>set rs.\n      \\<forall>a\\<in>fundfoldpairs.\n         case a of\n         (f, g) \\<Rightarrow>\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fold fst (map Spair rs) ` C = C\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set (r # rs))\n  \\<forall>r\\<in>set (r # rs).\n     \\<forall>a\\<in>fundfoldpairs.\n        case a of\n        (f, g) \\<Rightarrow>\n          r = Abs_induced_automorph f g \\<longrightarrow>\n          C \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. fold fst (map Spair rs) ` fst (Spair r) ` C = C", "by (simp add: fundfold_trivial_f\\<C>)"], ["proof (state)\nthis:\n  fold fst (map Spair rs) ` fst (Spair r) ` C = C\n\ngoal (2 subgoals):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set []);\n     \\<forall>r\\<in>set [].\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair []) ` C = C\n 2. \\<And>a rs.\n       \\<lbrakk>\\<lbrakk>order.greater_eq\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          (set rs);\n                 \\<forall>r\\<in>set rs.\n                    \\<forall>(f, g)\\<in>fundfoldpairs.\n                       r = Abs_induced_automorph f g \\<longrightarrow>\n                       C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n                \\<Longrightarrow> fold fst (map Spair rs) ` C = C;\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (a # rs));\n        \\<forall>r\\<in>set (a # rs).\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (a # rs)) ` C = C", "finally"], ["proof (chain)\npicking this:\n  fold fst (map Spair (r # rs)) ` C = C", "show ?case"], ["proof (prove)\nusing this:\n  fold fst (map Spair (r # rs)) ` C = C\n\ngoal (1 subgoal):\n 1. fold fst (map Spair (r # rs)) ` C = C", "by fast"], ["proof (state)\nthis:\n  fold fst (map Spair (r # rs)) ` C = C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set []);\n     \\<forall>r\\<in>set [].\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair []) ` C = C", "qed simp"], ["", "lemma fundfold_trivial_f\\<C>_list:\n  \"r\\<in>S \\<Longrightarrow>\n    \\<forall>C\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n      r = Abs_induced_automorph f g \\<longrightarrow> C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow>\n    fst (Spair r) \\<Turnstile> Cs = Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g});\n     \\<forall>C\\<in>set Cs.\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fst (Spair r) \\<Turnstile> Cs = Cs", "using fundfold_trivial_f\\<C>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g});\n   \\<forall>(f, g)\\<in>fundfoldpairs.\n      ?r = Abs_induced_automorph f g \\<longrightarrow>\n      ?C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fst (Spair ?r) ` ?C = ?C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g});\n     \\<forall>C\\<in>set Cs.\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fst (Spair r) \\<Turnstile> Cs = Cs", "by (induct Cs) auto"], ["", "lemma fundfold_comp_trivial_f\\<C>_list:\n  \"set rs \\<subseteq> S \\<Longrightarrow>\n    \\<forall>r\\<in>set rs. \\<forall>C\\<in>set Cs. \\<forall>(f,g)\\<in>fundfoldpairs.\n      r = Abs_induced_automorph f g \\<longrightarrow> C\\<in>f\\<turnstile>\\<C> \\<Longrightarrow>\n    fold fst (map Spair rs) \\<Turnstile> Cs = Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set rs);\n     \\<forall>r\\<in>set rs.\n        \\<forall>C\\<in>set Cs.\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair rs) \\<Turnstile> Cs = Cs", "proof (induct rs Cs rule: list_induct2')"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set []);\n     \\<forall>r\\<in>set [].\n        \\<forall>C\\<in>set [].\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair []) \\<Turnstile> [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set (x # xs));\n        \\<forall>r\\<in>set (x # xs).\n           \\<forall>C\\<in>set [].\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (x # xs)) \\<Turnstile> [] = []\n 3. \\<And>y ys.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set []);\n        \\<forall>r\\<in>set [].\n           \\<forall>C\\<in>set (y # ys).\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair []) \\<Turnstile> (y # ys) =\n                         y # ys\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>order.greater_eq\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          (set xs);\n                 \\<forall>r\\<in>set xs.\n                    \\<forall>C\\<in>set ys.\n                       \\<forall>(f, g)\\<in>fundfoldpairs.\n                          r = Abs_induced_automorph f g \\<longrightarrow>\n                          C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n                \\<Longrightarrow> fold fst (map Spair xs) \\<Turnstile> ys =\n                                  ys;\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (x # xs));\n        \\<forall>r\\<in>set (x # xs).\n           \\<forall>C\\<in>set (y # ys).\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (x # xs)) \\<Turnstile>\n                         (y # ys) =\n                         y # ys", "case (4 r rs C Cs)"], ["proof (state)\nthis:\n  \\<lbrakk>order.greater_eq\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n            (set rs);\n   \\<forall>r\\<in>set rs.\n      \\<forall>C\\<in>set Cs.\n         \\<forall>a\\<in>fundfoldpairs.\n            case a of\n            (f, g) \\<Rightarrow>\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fold fst (map Spair rs) \\<Turnstile> Cs = Cs\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set (r # rs))\n  \\<forall>r\\<in>set (r # rs).\n     \\<forall>C\\<in>set (C # Cs).\n        \\<forall>a\\<in>fundfoldpairs.\n           case a of\n           (f, g) \\<Rightarrow>\n             r = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> f \\<turnstile> \\<C>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set []);\n     \\<forall>r\\<in>set [].\n        \\<forall>C\\<in>set [].\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair []) \\<Turnstile> [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set (x # xs));\n        \\<forall>r\\<in>set (x # xs).\n           \\<forall>C\\<in>set [].\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (x # xs)) \\<Turnstile> [] = []\n 3. \\<And>y ys.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set []);\n        \\<forall>r\\<in>set [].\n           \\<forall>C\\<in>set (y # ys).\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair []) \\<Turnstile> (y # ys) =\n                         y # ys\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>order.greater_eq\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          (set xs);\n                 \\<forall>r\\<in>set xs.\n                    \\<forall>C\\<in>set ys.\n                       \\<forall>(f, g)\\<in>fundfoldpairs.\n                          r = Abs_induced_automorph f g \\<longrightarrow>\n                          C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n                \\<Longrightarrow> fold fst (map Spair xs) \\<Turnstile> ys =\n                                  ys;\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (x # xs));\n        \\<forall>r\\<in>set (x # xs).\n           \\<forall>C\\<in>set (y # ys).\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (x # xs)) \\<Turnstile>\n                         (y # ys) =\n                         y # ys", "from 4(3)"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>set (r # rs).\n     \\<forall>C\\<in>set (C # Cs).\n        \\<forall>a\\<in>fundfoldpairs.\n           case a of\n           (f, g) \\<Rightarrow>\n             r = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> f \\<turnstile> \\<C>", "have  r: \"\\<forall>D\\<in>set (C#Cs). \\<forall>(f,g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow> D\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set (r # rs).\n     \\<forall>C\\<in>set (C # Cs).\n        \\<forall>a\\<in>fundfoldpairs.\n           case a of\n           (f, g) \\<Rightarrow>\n             r = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<forall>D\\<in>set (C # Cs).\n       \\<forall>(f, g)\\<in>fundfoldpairs.\n          r = Abs_induced_automorph f g \\<longrightarrow>\n          D \\<in> f \\<turnstile> \\<C>", "by    simp"], ["proof (state)\nthis:\n  \\<forall>D\\<in>set (C # Cs).\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        D \\<in> f \\<turnstile> \\<C>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set []);\n     \\<forall>r\\<in>set [].\n        \\<forall>C\\<in>set [].\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair []) \\<Turnstile> [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set (x # xs));\n        \\<forall>r\\<in>set (x # xs).\n           \\<forall>C\\<in>set [].\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (x # xs)) \\<Turnstile> [] = []\n 3. \\<And>y ys.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set []);\n        \\<forall>r\\<in>set [].\n           \\<forall>C\\<in>set (y # ys).\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair []) \\<Turnstile> (y # ys) =\n                         y # ys\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>order.greater_eq\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          (set xs);\n                 \\<forall>r\\<in>set xs.\n                    \\<forall>C\\<in>set ys.\n                       \\<forall>(f, g)\\<in>fundfoldpairs.\n                          r = Abs_induced_automorph f g \\<longrightarrow>\n                          C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n                \\<Longrightarrow> fold fst (map Spair xs) \\<Turnstile> ys =\n                                  ys;\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (x # xs));\n        \\<forall>r\\<in>set (x # xs).\n           \\<forall>C\\<in>set (y # ys).\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (x # xs)) \\<Turnstile>\n                         (y # ys) =\n                         y # ys", "from 4(2)"], ["proof (chain)\npicking this:\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set (r # rs))", "have  \"fold fst (map Spair (r#rs)) \\<Turnstile> (C#Cs) =\n            map ((`) (fold fst (map Spair rs))) (fst (Spair r) \\<Turnstile> (C#Cs))\""], ["proof (prove)\nusing this:\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set (r # rs))\n\ngoal (1 subgoal):\n 1. fold fst (map Spair (r # rs)) \\<Turnstile> (C # Cs) =\n    fold fst (map Spair rs) \\<Turnstile>\n    (fst (Spair r) \\<Turnstile> (C # Cs))", "by    (auto simp add: image_comp)"], ["proof (state)\nthis:\n  fold fst (map Spair (r # rs)) \\<Turnstile> (C # Cs) =\n  fold fst (map Spair rs) \\<Turnstile> (fst (Spair r) \\<Turnstile> (C # Cs))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set []);\n     \\<forall>r\\<in>set [].\n        \\<forall>C\\<in>set [].\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair []) \\<Turnstile> [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set (x # xs));\n        \\<forall>r\\<in>set (x # xs).\n           \\<forall>C\\<in>set [].\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (x # xs)) \\<Turnstile> [] = []\n 3. \\<And>y ys.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set []);\n        \\<forall>r\\<in>set [].\n           \\<forall>C\\<in>set (y # ys).\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair []) \\<Turnstile> (y # ys) =\n                         y # ys\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>order.greater_eq\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          (set xs);\n                 \\<forall>r\\<in>set xs.\n                    \\<forall>C\\<in>set ys.\n                       \\<forall>(f, g)\\<in>fundfoldpairs.\n                          r = Abs_induced_automorph f g \\<longrightarrow>\n                          C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n                \\<Longrightarrow> fold fst (map Spair xs) \\<Turnstile> ys =\n                                  ys;\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (x # xs));\n        \\<forall>r\\<in>set (x # xs).\n           \\<forall>C\\<in>set (y # ys).\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (x # xs)) \\<Turnstile>\n                         (y # ys) =\n                         y # ys", "also"], ["proof (state)\nthis:\n  fold fst (map Spair (r # rs)) \\<Turnstile> (C # Cs) =\n  fold fst (map Spair rs) \\<Turnstile> (fst (Spair r) \\<Turnstile> (C # Cs))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set []);\n     \\<forall>r\\<in>set [].\n        \\<forall>C\\<in>set [].\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair []) \\<Turnstile> [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set (x # xs));\n        \\<forall>r\\<in>set (x # xs).\n           \\<forall>C\\<in>set [].\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (x # xs)) \\<Turnstile> [] = []\n 3. \\<And>y ys.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set []);\n        \\<forall>r\\<in>set [].\n           \\<forall>C\\<in>set (y # ys).\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair []) \\<Turnstile> (y # ys) =\n                         y # ys\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>order.greater_eq\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          (set xs);\n                 \\<forall>r\\<in>set xs.\n                    \\<forall>C\\<in>set ys.\n                       \\<forall>(f, g)\\<in>fundfoldpairs.\n                          r = Abs_induced_automorph f g \\<longrightarrow>\n                          C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n                \\<Longrightarrow> fold fst (map Spair xs) \\<Turnstile> ys =\n                                  ys;\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (x # xs));\n        \\<forall>r\\<in>set (x # xs).\n           \\<forall>C\\<in>set (y # ys).\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (x # xs)) \\<Turnstile>\n                         (y # ys) =\n                         y # ys", "from 4"], ["proof (chain)\npicking this:\n  \\<lbrakk>order.greater_eq\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n            (set rs);\n   \\<forall>r\\<in>set rs.\n      \\<forall>C\\<in>set Cs.\n         \\<forall>a\\<in>fundfoldpairs.\n            case a of\n            (f, g) \\<Rightarrow>\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fold fst (map Spair rs) \\<Turnstile> Cs = Cs\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set (r # rs))\n  \\<forall>r\\<in>set (r # rs).\n     \\<forall>C\\<in>set (C # Cs).\n        \\<forall>a\\<in>fundfoldpairs.\n           case a of\n           (f, g) \\<Rightarrow>\n             r = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> f \\<turnstile> \\<C>", "have \"\\<dots> = C#Cs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater_eq\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n            (set rs);\n   \\<forall>r\\<in>set rs.\n      \\<forall>C\\<in>set Cs.\n         \\<forall>a\\<in>fundfoldpairs.\n            case a of\n            (f, g) \\<Rightarrow>\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fold fst (map Spair rs) \\<Turnstile> Cs = Cs\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set (r # rs))\n  \\<forall>r\\<in>set (r # rs).\n     \\<forall>C\\<in>set (C # Cs).\n        \\<forall>a\\<in>fundfoldpairs.\n           case a of\n           (f, g) \\<Rightarrow>\n             r = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. fold fst (map Spair rs) \\<Turnstile>\n    (fst (Spair r) \\<Turnstile> (C # Cs)) =\n    C # Cs", "using fundfold_trivial_f\\<C>_list[of r \"C#Cs\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater_eq\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n            (set rs);\n   \\<forall>r\\<in>set rs.\n      \\<forall>C\\<in>set Cs.\n         \\<forall>a\\<in>fundfoldpairs.\n            case a of\n            (f, g) \\<Rightarrow>\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fold fst (map Spair rs) \\<Turnstile> Cs = Cs\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set (r # rs))\n  \\<forall>r\\<in>set (r # rs).\n     \\<forall>C\\<in>set (C # Cs).\n        \\<forall>a\\<in>fundfoldpairs.\n           case a of\n           (f, g) \\<Rightarrow>\n             r = Abs_induced_automorph f g \\<longrightarrow>\n             C \\<in> f \\<turnstile> \\<C>\n  \\<lbrakk>r \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g});\n   \\<forall>C\\<in>set (C # Cs).\n      \\<forall>(f, g)\\<in>fundfoldpairs.\n         r = Abs_induced_automorph f g \\<longrightarrow>\n         C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fst (Spair r) \\<Turnstile> (C # Cs) = C # Cs\n\ngoal (1 subgoal):\n 1. fold fst (map Spair rs) \\<Turnstile>\n    (fst (Spair r) \\<Turnstile> (C # Cs)) =\n    C # Cs", "by    (simp add: fundfold_comp_trivial_f\\<C>)"], ["proof (state)\nthis:\n  fold fst (map Spair rs) \\<Turnstile>\n  (fst (Spair r) \\<Turnstile> (C # Cs)) =\n  C # Cs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set []);\n     \\<forall>r\\<in>set [].\n        \\<forall>C\\<in>set [].\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair []) \\<Turnstile> [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set (x # xs));\n        \\<forall>r\\<in>set (x # xs).\n           \\<forall>C\\<in>set [].\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (x # xs)) \\<Turnstile> [] = []\n 3. \\<And>y ys.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set []);\n        \\<forall>r\\<in>set [].\n           \\<forall>C\\<in>set (y # ys).\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair []) \\<Turnstile> (y # ys) =\n                         y # ys\n 4. \\<And>x xs y ys.\n       \\<lbrakk>\\<lbrakk>order.greater_eq\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          (set xs);\n                 \\<forall>r\\<in>set xs.\n                    \\<forall>C\\<in>set ys.\n                       \\<forall>(f, g)\\<in>fundfoldpairs.\n                          r = Abs_induced_automorph f g \\<longrightarrow>\n                          C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n                \\<Longrightarrow> fold fst (map Spair xs) \\<Turnstile> ys =\n                                  ys;\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (x # xs));\n        \\<forall>r\\<in>set (x # xs).\n           \\<forall>C\\<in>set (y # ys).\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (x # xs)) \\<Turnstile>\n                         (y # ys) =\n                         y # ys", "finally"], ["proof (chain)\npicking this:\n  fold fst (map Spair (r # rs)) \\<Turnstile> (C # Cs) = C # Cs", "show ?case"], ["proof (prove)\nusing this:\n  fold fst (map Spair (r # rs)) \\<Turnstile> (C # Cs) = C # Cs\n\ngoal (1 subgoal):\n 1. fold fst (map Spair (r # rs)) \\<Turnstile> (C # Cs) = C # Cs", "by fast"], ["proof (state)\nthis:\n  fold fst (map Spair (r # rs)) \\<Turnstile> (C # Cs) = C # Cs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>order.greater_eq\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              (set []);\n     \\<forall>r\\<in>set [].\n        \\<forall>C\\<in>set [].\n           \\<forall>(f, g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow>\n              C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n    \\<Longrightarrow> fold fst (map Spair []) \\<Turnstile> [] = []\n 2. \\<And>x xs.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set (x # xs));\n        \\<forall>r\\<in>set (x # xs).\n           \\<forall>C\\<in>set [].\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair (x # xs)) \\<Turnstile> [] = []\n 3. \\<And>y ys.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set []);\n        \\<forall>r\\<in>set [].\n           \\<forall>C\\<in>set (y # ys).\n              \\<forall>(f, g)\\<in>fundfoldpairs.\n                 r = Abs_induced_automorph f g \\<longrightarrow>\n                 C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n       \\<Longrightarrow> fold fst (map Spair []) \\<Turnstile> (y # ys) =\n                         y # ys", "qed auto"], ["", "lemma fundfold_gallery_map:\n  \"s\\<in>S \\<Longrightarrow> gallery Cs \\<Longrightarrow> gallery (fst (Spair s) \\<Turnstile> Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g});\n     gallery Cs\\<rbrakk>\n    \\<Longrightarrow> gallery (fst (Spair s) \\<Turnstile> Cs)", "using Spair_fundfoldpair fundfoldpairs_def\n        OpposedThinChamberComplexFoldings.axioms(2)\n        ChamberComplexFolding.gallery_map[of X \"fst (Spair s)\"]"], ["proof (prove)\nusing this:\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  Spair ?s \\<in> fundfoldpairs\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  OpposedThinChamberComplexFoldings ?X ?f ?g ?C0.0 \\<Longrightarrow>\n  ChamberComplexFolding ?X ?f\n  \\<lbrakk>ChamberComplexFolding X (fst (Spair s)); gallery ?Cs\\<rbrakk>\n  \\<Longrightarrow> gallery (fst (Spair s) \\<Turnstile> ?Cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g});\n     gallery Cs\\<rbrakk>\n    \\<Longrightarrow> gallery (fst (Spair s) \\<Turnstile> Cs)", "by    fastforce"], ["", "lemma fundfold_comp_gallery_map:\n  assumes pregal: \"gallery Cs\"\n  shows   \"set ss \\<subseteq> S \\<Longrightarrow> gallery (fold fst (map Spair ss) \\<Turnstile> Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (set ss) \\<Longrightarrow>\n    gallery (fold fst (map Spair ss) \\<Turnstile> Cs)", "proof (induct ss rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (set []) \\<Longrightarrow>\n    gallery (fold fst (map Spair []) \\<Turnstile> Cs)\n 2. \\<And>x xs.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set xs) \\<Longrightarrow>\n                gallery (fold fst (map Spair xs) \\<Turnstile> Cs);\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> gallery\n                          (fold fst (map Spair (xs @ [x])) \\<Turnstile> Cs)", "case (snoc s ss)"], ["proof (state)\nthis:\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set ss) \\<Longrightarrow>\n  gallery (fold fst (map Spair ss) \\<Turnstile> Cs)\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set (ss @ [s]))\n\ngoal (2 subgoals):\n 1. order.greater_eq\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (set []) \\<Longrightarrow>\n    gallery (fold fst (map Spair []) \\<Turnstile> Cs)\n 2. \\<And>x xs.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set xs) \\<Longrightarrow>\n                gallery (fold fst (map Spair xs) \\<Turnstile> Cs);\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> gallery\n                          (fold fst (map Spair (xs @ [x])) \\<Turnstile> Cs)", "hence 1: \"gallery (fst (Spair s) \\<Turnstile> (fold fst (map Spair ss) \\<Turnstile> Cs))\""], ["proof (prove)\nusing this:\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set ss) \\<Longrightarrow>\n  gallery (fold fst (map Spair ss) \\<Turnstile> Cs)\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set (ss @ [s]))\n\ngoal (1 subgoal):\n 1. gallery\n     (fst (Spair s) \\<Turnstile> (fold fst (map Spair ss) \\<Turnstile> Cs))", "using fundfold_gallery_map"], ["proof (prove)\nusing this:\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set ss) \\<Longrightarrow>\n  gallery (fold fst (map Spair ss) \\<Turnstile> Cs)\n  order.greater_eq\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (set (ss @ [s]))\n  \\<lbrakk>?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g});\n   gallery ?Cs\\<rbrakk>\n  \\<Longrightarrow> gallery (fst (Spair ?s) \\<Turnstile> ?Cs)\n\ngoal (1 subgoal):\n 1. gallery\n     (fst (Spair s) \\<Turnstile> (fold fst (map Spair ss) \\<Turnstile> Cs))", "by fastforce"], ["proof (state)\nthis:\n  gallery\n   (fst (Spair s) \\<Turnstile> (fold fst (map Spair ss) \\<Turnstile> Cs))\n\ngoal (2 subgoals):\n 1. order.greater_eq\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (set []) \\<Longrightarrow>\n    gallery (fold fst (map Spair []) \\<Turnstile> Cs)\n 2. \\<And>x xs.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set xs) \\<Longrightarrow>\n                gallery (fold fst (map Spair xs) \\<Turnstile> Cs);\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> gallery\n                          (fold fst (map Spair (xs @ [x])) \\<Turnstile> Cs)", "have 2: \"fst (Spair s) \\<Turnstile> (fold fst (map Spair ss) \\<Turnstile> Cs) =\n            fold fst (map Spair (ss@[s])) \\<Turnstile> Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Spair s) \\<Turnstile> (fold fst (map Spair ss) \\<Turnstile> Cs) =\n    fold fst (map Spair (ss @ [s])) \\<Turnstile> Cs", "by (simp add: image_comp)"], ["proof (state)\nthis:\n  fst (Spair s) \\<Turnstile> (fold fst (map Spair ss) \\<Turnstile> Cs) =\n  fold fst (map Spair (ss @ [s])) \\<Turnstile> Cs\n\ngoal (2 subgoals):\n 1. order.greater_eq\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (set []) \\<Longrightarrow>\n    gallery (fold fst (map Spair []) \\<Turnstile> Cs)\n 2. \\<And>x xs.\n       \\<lbrakk>order.greater_eq\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g})\n                 (set xs) \\<Longrightarrow>\n                gallery (fold fst (map Spair xs) \\<Turnstile> Cs);\n        order.greater_eq\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (set (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> gallery\n                          (fold fst (map Spair (xs @ [x])) \\<Turnstile> Cs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gallery (fold fst (map Spair (ss @ [s])) \\<Turnstile> Cs)", "using 1 subst[OF 2, of gallery, OF 1]"], ["proof (prove)\nusing this:\n  gallery\n   (fst (Spair s) \\<Turnstile> (fold fst (map Spair ss) \\<Turnstile> Cs))\n  gallery (fold fst (map Spair (ss @ [s])) \\<Turnstile> Cs)\n\ngoal (1 subgoal):\n 1. gallery (fold fst (map Spair (ss @ [s])) \\<Turnstile> Cs)", "by fast"], ["proof (state)\nthis:\n  gallery (fold fst (map Spair (ss @ [s])) \\<Turnstile> Cs)\n\ngoal (1 subgoal):\n 1. order.greater_eq\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (set []) \\<Longrightarrow>\n    gallery (fold fst (map Spair []) \\<Turnstile> Cs)", "qed (simp add: pregal galleryD_adj)"], ["", "lemma fundfold_comp_pgallery_ex_funpow:\n  assumes ss: \"set ss = S\"\n  shows   \"pgallery (C0#Cs@[C]) \\<Longrightarrow>\n            \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pgallery (C0 # Cs @ [C]) \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "proof (induct Cs arbitrary: C rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs C.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   (\\<forall>x.\n                       pgallery (C0 # ys @ [x]) \\<longrightarrow>\n                       (\\<exists>n.\n                           (fold fst (map Spair ss) ^^ n) ` x = C0));\n        pgallery (C0 # xs @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "fix Cs C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs C.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   (\\<forall>x.\n                       pgallery (C0 # ys @ [x]) \\<longrightarrow>\n                       (\\<exists>n.\n                           (fold fst (map Spair ss) ^^ n) ` x = C0));\n        pgallery (C0 # xs @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "assume step  :  \"\\<forall>ys. length ys < length Cs \\<longrightarrow>\n                    (\\<forall>x. pgallery (C0 # ys @ [x]) \\<longrightarrow>\n                    (\\<exists>n. (fold fst (map Spair ss) ^^ n) ` x = C0))\"\n    and  set_up:  \"pgallery (C0#Cs@[C])\""], ["proof (state)\nthis:\n  \\<forall>ys.\n     order.greater (length Cs) (length ys) \\<longrightarrow>\n     (\\<forall>x.\n         pgallery (C0 # ys @ [x]) \\<longrightarrow>\n         (\\<exists>n. (fold fst (map Spair ss) ^^ n) ` x = C0))\n  pgallery (C0 # Cs @ [C])\n\ngoal (1 subgoal):\n 1. \\<And>xs C.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   (\\<forall>x.\n                       pgallery (C0 # ys @ [x]) \\<longrightarrow>\n                       (\\<exists>n.\n                           (fold fst (map Spair ss) ^^ n) ` x = C0));\n        pgallery (C0 # xs @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "from ss set_up"], ["proof (chain)\npicking this:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  pgallery (C0 # Cs @ [C])", "obtain rs s ts As B Bs where decomps:\n    \"ss = rs@s#ts\" \"Cs@[C] = As@B#Bs\"\n    \"\\<forall>(f,g)\\<in>fundfoldpairs. s = Abs_induced_automorph f g \\<longrightarrow> B\\<in>g\\<turnstile>\\<C>\"\n    \"\\<forall>A\\<in>set As. \\<forall>(f,g)\\<in>fundfoldpairs. s = Abs_induced_automorph f g \\<longrightarrow> A\\<in>f\\<turnstile>\\<C>\"\n    \"\\<forall>r\\<in>set rs. \\<forall>D\\<in>set (Cs@[C]). \\<forall>(f,g)\\<in>fundfoldpairs.\n      r = Abs_induced_automorph f g \\<longrightarrow> D\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  pgallery (C0 # Cs @ [C])\n\ngoal (1 subgoal):\n 1. (\\<And>rs s ts As B Bs.\n        \\<lbrakk>ss = rs @ s # ts; Cs @ [C] = As @ B # Bs;\n         \\<forall>(f, g)\\<in>fundfoldpairs.\n            s = Abs_induced_automorph f g \\<longrightarrow>\n            B \\<in> g \\<turnstile> \\<C>;\n         \\<forall>A\\<in>set As.\n            \\<forall>(f, g)\\<in>fundfoldpairs.\n               s = Abs_induced_automorph f g \\<longrightarrow>\n               A \\<in> f \\<turnstile> \\<C>;\n         \\<forall>r\\<in>set rs.\n            \\<forall>D\\<in>set (Cs @ [C]).\n               \\<forall>(f, g)\\<in>fundfoldpairs.\n                  r = Abs_induced_automorph f g \\<longrightarrow>\n                  D \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using S_list_pgallery_decomp3[of ss \"Cs@[C]\"]"], ["proof (prove)\nusing this:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  pgallery (C0 # Cs @ [C])\n  \\<lbrakk>set ss =\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   Cs @ [C] \\<noteq> []; pgallery (C0 # Cs @ [C])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rs s ts As B Bs.\n                       ss = rs @ s # ts \\<and>\n                       Cs @ [C] = As @ B # Bs \\<and>\n                       (\\<forall>(f, g)\\<in>fundfoldpairs.\n                           s = Abs_induced_automorph f g \\<longrightarrow>\n                           B \\<in> g \\<turnstile> \\<C>) \\<and>\n                       (\\<forall>A\\<in>set As.\n                           \\<forall>(f, g)\\<in>fundfoldpairs.\n                              s =\n                              Abs_induced_automorph f g \\<longrightarrow>\n                              A \\<in> f \\<turnstile> \\<C>) \\<and>\n                       (\\<forall>r\\<in>set rs.\n                           \\<forall>C\\<in>set (Cs @ [C]).\n                              \\<forall>(f, g)\\<in>fundfoldpairs.\n                                 r =\n                                 Abs_induced_automorph f g \\<longrightarrow>\n                                 C \\<in> f \\<turnstile> \\<C>)\n\ngoal (1 subgoal):\n 1. (\\<And>rs s ts As B Bs.\n        \\<lbrakk>ss = rs @ s # ts; Cs @ [C] = As @ B # Bs;\n         \\<forall>(f, g)\\<in>fundfoldpairs.\n            s = Abs_induced_automorph f g \\<longrightarrow>\n            B \\<in> g \\<turnstile> \\<C>;\n         \\<forall>A\\<in>set As.\n            \\<forall>(f, g)\\<in>fundfoldpairs.\n               s = Abs_induced_automorph f g \\<longrightarrow>\n               A \\<in> f \\<turnstile> \\<C>;\n         \\<forall>r\\<in>set rs.\n            \\<forall>D\\<in>set (Cs @ [C]).\n               \\<forall>(f, g)\\<in>fundfoldpairs.\n                  r = Abs_induced_automorph f g \\<longrightarrow>\n                  D \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fastforce"], ["proof (state)\nthis:\n  ss = rs @ s # ts\n  Cs @ [C] = As @ B # Bs\n  \\<forall>(f, g)\\<in>fundfoldpairs.\n     s = Abs_induced_automorph f g \\<longrightarrow>\n     B \\<in> g \\<turnstile> \\<C>\n  \\<forall>A\\<in>set As.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        A \\<in> f \\<turnstile> \\<C>\n  \\<forall>r\\<in>set rs.\n     \\<forall>D\\<in>set (Cs @ [C]).\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           D \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<And>xs C.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   (\\<forall>x.\n                       pgallery (C0 # ys @ [x]) \\<longrightarrow>\n                       (\\<exists>n.\n                           (fold fst (map Spair ss) ^^ n) ` x = C0));\n        pgallery (C0 # xs @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "obtain Es E where EsE: \"C0#As = Es@[E]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Es E.\n        C0 # As = Es @ [E] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cons_conv_snoc"], ["proof (prove)\nusing this:\n  \\<exists>ys y. ?x # ?xs = ys @ [y]\n\ngoal (1 subgoal):\n 1. (\\<And>Es E.\n        C0 # As = Es @ [E] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  C0 # As = Es @ [E]\n\ngoal (1 subgoal):\n 1. \\<And>xs C.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   (\\<forall>x.\n                       pgallery (C0 # ys @ [x]) \\<longrightarrow>\n                       (\\<exists>n.\n                           (fold fst (map Spair ss) ^^ n) ` x = C0));\n        pgallery (C0 # xs @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "have EsE_s_f\\<C>:\n    \"\\<forall>A\\<in>set (Es@[E]). \\<forall>(f,g)\\<in>fundfoldpairs.\n      s = Abs_induced_automorph f g \\<longrightarrow> A\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>set (Es @ [E]).\n       \\<forall>(f, g)\\<in>fundfoldpairs.\n          s = Abs_induced_automorph f g \\<longrightarrow>\n          A \\<in> f \\<turnstile> \\<C>", "proof (rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> set (Es @ [E]) \\<Longrightarrow>\n       \\<forall>(f, g)\\<in>fundfoldpairs.\n          s = Abs_induced_automorph f g \\<longrightarrow>\n          A \\<in> f \\<turnstile> \\<C>", "fix A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> set (Es @ [E]) \\<Longrightarrow>\n       \\<forall>(f, g)\\<in>fundfoldpairs.\n          s = Abs_induced_automorph f g \\<longrightarrow>\n          A \\<in> f \\<turnstile> \\<C>", "assume \"A\\<in>set (Es@[E])\""], ["proof (state)\nthis:\n  A \\<in> set (Es @ [E])\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> set (Es @ [E]) \\<Longrightarrow>\n       \\<forall>(f, g)\\<in>fundfoldpairs.\n          s = Abs_induced_automorph f g \\<longrightarrow>\n          A \\<in> f \\<turnstile> \\<C>", "with EsE decomps(4)"], ["proof (chain)\npicking this:\n  C0 # As = Es @ [E]\n  \\<forall>A\\<in>set As.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        A \\<in> f \\<turnstile> \\<C>\n  A \\<in> set (Es @ [E])", "show  \"\\<forall>(f, g)\\<in>fundfoldpairs. s = Abs_induced_automorph f g \\<longrightarrow> A \\<in> f \\<turnstile> \\<C>\""], ["proof (prove)\nusing this:\n  C0 # As = Es @ [E]\n  \\<forall>A\\<in>set As.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        A \\<in> f \\<turnstile> \\<C>\n  A \\<in> set (Es @ [E])\n\ngoal (1 subgoal):\n 1. \\<forall>(f, g)\\<in>fundfoldpairs.\n       s = Abs_induced_automorph f g \\<longrightarrow>\n       A \\<in> f \\<turnstile> \\<C>", "using fundfoldpair_fundchamber_in_half_chamber_system_f\n            set_ConsD[of A C0 As]"], ["proof (prove)\nusing this:\n  C0 # As = Es @ [E]\n  \\<forall>A\\<in>set As.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        A \\<in> f \\<turnstile> \\<C>\n  A \\<in> set (Es @ [E])\n  (?f, ?g) \\<in> fundfoldpairs \\<Longrightarrow>\n  C0 \\<in> ?f \\<turnstile> \\<C>\n  A \\<in> set (C0 # As) \\<Longrightarrow> A = C0 \\<or> A \\<in> set As\n\ngoal (1 subgoal):\n 1. \\<forall>(f, g)\\<in>fundfoldpairs.\n       s = Abs_induced_automorph f g \\<longrightarrow>\n       A \\<in> f \\<turnstile> \\<C>", "by    auto"], ["proof (state)\nthis:\n  \\<forall>(f, g)\\<in>fundfoldpairs.\n     s = Abs_induced_automorph f g \\<longrightarrow>\n     A \\<in> f \\<turnstile> \\<C>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>A\\<in>set (Es @ [E]).\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        A \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<And>xs C.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   (\\<forall>x.\n                       pgallery (C0 # ys @ [x]) \\<longrightarrow>\n                       (\\<exists>n.\n                           (fold fst (map Spair ss) ^^ n) ` x = C0));\n        pgallery (C0 # xs @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "moreover"], ["proof (state)\nthis:\n  \\<forall>A\\<in>set (Es @ [E]).\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        A \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<And>xs C.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   (\\<forall>x.\n                       pgallery (C0 # ys @ [x]) \\<longrightarrow>\n                       (\\<exists>n.\n                           (fold fst (map Spair ss) ^^ n) ` x = C0));\n        pgallery (C0 # xs @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "from decomps(2) EsE"], ["proof (chain)\npicking this:\n  Cs @ [C] = As @ B # Bs\n  C0 # As = Es @ [E]", "have  decomp2: \"C0#Cs@[C] = Es@E#B#Bs\""], ["proof (prove)\nusing this:\n  Cs @ [C] = As @ B # Bs\n  C0 # As = Es @ [E]\n\ngoal (1 subgoal):\n 1. C0 # Cs @ [C] = Es @ E # B # Bs", "by    simp"], ["proof (state)\nthis:\n  C0 # Cs @ [C] = Es @ E # B # Bs\n\ngoal (1 subgoal):\n 1. \\<And>xs C.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   (\\<forall>x.\n                       pgallery (C0 # ys @ [x]) \\<longrightarrow>\n                       (\\<exists>n.\n                           (fold fst (map Spair ss) ^^ n) ` x = C0));\n        pgallery (C0 # xs @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "moreover"], ["proof (state)\nthis:\n  C0 # Cs @ [C] = Es @ E # B # Bs\n\ngoal (1 subgoal):\n 1. \\<And>xs C.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   (\\<forall>x.\n                       pgallery (C0 # ys @ [x]) \\<longrightarrow>\n                       (\\<exists>n.\n                           (fold fst (map Spair ss) ^^ n) ` x = C0));\n        pgallery (C0 # xs @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "from ss decomps(1)"], ["proof (chain)\npicking this:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss = rs @ s # ts", "have \"s\\<in>S\""], ["proof (prove)\nusing this:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss = rs @ s # ts\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "by auto"], ["proof (state)\nthis:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. \\<And>xs C.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   (\\<forall>x.\n                       pgallery (C0 # ys @ [x]) \\<longrightarrow>\n                       (\\<exists>n.\n                           (fold fst (map Spair ss) ^^ n) ` x = C0));\n        pgallery (C0 # xs @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>A\\<in>set (Es @ [E]).\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        A \\<in> f \\<turnstile> \\<C>\n  C0 # Cs @ [C] = Es @ E # B # Bs\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "have sB: \"fst (Spair s) ` B = E\""], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>set (Es @ [E]).\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        A \\<in> f \\<turnstile> \\<C>\n  C0 # Cs @ [C] = Es @ E # B # Bs\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. fst (Spair s) ` B = E", "using set_up decomps(3) Spair_fundfoldpair[of s]\n          Spair_induced_automorph[of s] fundfoldpairs_def\n          pgalleryD_adj\n          binrelchain_append_reduce2[of adjacent Es \"E#B#Bs\"]\n          OpposedThinChamberComplexFoldings.adjacent_half_chamber_system_image_fg[\n            of X \"fst (Spair s)\" \"snd (Spair s)\" C0 E B\n          ]"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>set (Es @ [E]).\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        A \\<in> f \\<turnstile> \\<C>\n  C0 # Cs @ [C] = Es @ E # B # Bs\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  pgallery (C0 # Cs @ [C])\n  \\<forall>(f, g)\\<in>fundfoldpairs.\n     s = Abs_induced_automorph f g \\<longrightarrow>\n     B \\<in> g \\<turnstile> \\<C>\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  Spair s \\<in> fundfoldpairs\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  s = (case Spair s of (f, g) \\<Rightarrow> Abs_induced_automorph f g)\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  pgallery ?xs \\<Longrightarrow> adjacentchain ?xs\n  adjacentchain (Es @ E # B # Bs) \\<Longrightarrow>\n  adjacentchain (E # B # Bs)\n  \\<lbrakk>OpposedThinChamberComplexFoldings X (fst (Spair s))\n            (snd (Spair s)) C0;\n   E \\<in> fst (Spair s) \\<turnstile> \\<C>;\n   B \\<in> snd (Spair s) \\<turnstile> \\<C>; E \\<sim> B\\<rbrakk>\n  \\<Longrightarrow> fst (Spair s) ` B = E\n\ngoal (1 subgoal):\n 1. fst (Spair s) ` B = E", "by    auto"], ["proof (state)\nthis:\n  fst (Spair s) ` B = E\n\ngoal (1 subgoal):\n 1. \\<And>xs C.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   (\\<forall>x.\n                       pgallery (C0 # ys @ [x]) \\<longrightarrow>\n                       (\\<exists>n.\n                           (fold fst (map Spair ss) ^^ n) ` x = C0));\n        pgallery (C0 # xs @ [C])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "show \"\\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "proof (cases \"Es=[] \\<and> Bs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Es = [] \\<and> Bs = [] \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n 2. \\<not> (Es = [] \\<and> Bs = []) \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "case True"], ["proof (state)\nthis:\n  Es = [] \\<and> Bs = []\n\ngoal (2 subgoals):\n 1. Es = [] \\<and> Bs = [] \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n 2. \\<not> (Es = [] \\<and> Bs = []) \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "from decomps(5)"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>set rs.\n     \\<forall>D\\<in>set (Cs @ [C]).\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           D \\<in> f \\<turnstile> \\<C>", "have\n      \"\\<forall>r\\<in>set rs. \\<forall>(f,g)\\<in>fundfoldpairs. r = Abs_induced_automorph f g \\<longrightarrow> C\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set rs.\n     \\<forall>D\\<in>set (Cs @ [C]).\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           D \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set rs.\n       \\<forall>(f, g)\\<in>fundfoldpairs.\n          r = Abs_induced_automorph f g \\<longrightarrow>\n          C \\<in> f \\<turnstile> \\<C>", "by auto"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set rs.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        C \\<in> f \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. Es = [] \\<and> Bs = [] \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n 2. \\<not> (Es = [] \\<and> Bs = []) \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "with decomps(1) ss"], ["proof (chain)\npicking this:\n  ss = rs @ s # ts\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<forall>r\\<in>set rs.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        C \\<in> f \\<turnstile> \\<C>", "have  \"fold fst (map Spair ss) ` C = fold fst (map Spair ts) ` fst (Spair s) ` C\""], ["proof (prove)\nusing this:\n  ss = rs @ s # ts\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<forall>r\\<in>set rs.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        C \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C =\n    fold fst (map Spair ts) ` fst (Spair s) ` C", "using fundfold_comp_trivial_f\\<C>[of rs C]"], ["proof (prove)\nusing this:\n  ss = rs @ s # ts\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<forall>r\\<in>set rs.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        C \\<in> f \\<turnstile> \\<C>\n  \\<lbrakk>order.greater_eq\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            (set rs);\n   \\<forall>r\\<in>set rs.\n      \\<forall>(f, g)\\<in>fundfoldpairs.\n         r = Abs_induced_automorph f g \\<longrightarrow>\n         C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fold fst (map Spair rs) ` C = C\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C =\n    fold fst (map Spair ts) ` fst (Spair s) ` C", "by    (fastforce simp add: image_comp[THEN sym])"], ["proof (state)\nthis:\n  fold fst (map Spair ss) ` C = fold fst (map Spair ts) ` fst (Spair s) ` C\n\ngoal (2 subgoals):\n 1. Es = [] \\<and> Bs = [] \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n 2. \\<not> (Es = [] \\<and> Bs = []) \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "moreover"], ["proof (state)\nthis:\n  fold fst (map Spair ss) ` C = fold fst (map Spair ts) ` fst (Spair s) ` C\n\ngoal (2 subgoals):\n 1. Es = [] \\<and> Bs = [] \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n 2. \\<not> (Es = [] \\<and> Bs = []) \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "have  \"\\<forall>r\\<in>set ts. \\<forall>(f,g)\\<in>fundfoldpairs.\n              r = Abs_induced_automorph f g \\<longrightarrow> C0\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set ts.\n       \\<forall>(f, g)\\<in>fundfoldpairs.\n          r = Abs_induced_automorph f g \\<longrightarrow>\n          C0 \\<in> f \\<turnstile> \\<C>", "using fundfoldpair_fundchamber_in_half_chamber_system_f"], ["proof (prove)\nusing this:\n  (?f, ?g) \\<in> fundfoldpairs \\<Longrightarrow>\n  C0 \\<in> ?f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set ts.\n       \\<forall>(f, g)\\<in>fundfoldpairs.\n          r = Abs_induced_automorph f g \\<longrightarrow>\n          C0 \\<in> f \\<turnstile> \\<C>", "by    fast"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set ts.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        C0 \\<in> f \\<turnstile> \\<C>\n\ngoal (2 subgoals):\n 1. Es = [] \\<and> Bs = [] \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n 2. \\<not> (Es = [] \\<and> Bs = []) \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "ultimately"], ["proof (chain)\npicking this:\n  fold fst (map Spair ss) ` C = fold fst (map Spair ts) ` fst (Spair s) ` C\n  \\<forall>r\\<in>set ts.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        C0 \\<in> f \\<turnstile> \\<C>", "have \"(fold fst (map Spair ss) ^^ 1) ` C = C0\""], ["proof (prove)\nusing this:\n  fold fst (map Spair ss) ` C = fold fst (map Spair ts) ` fst (Spair s) ` C\n  \\<forall>r\\<in>set ts.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        C0 \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. (fold fst (map Spair ss) ^^ 1) ` C = C0", "using True decomps(1,2) ss EsE sB fundfold_comp_trivial_f\\<C>[of ts C0]\n            fundfold_comp_trivial_f\\<C>[of ts C0]"], ["proof (prove)\nusing this:\n  fold fst (map Spair ss) ` C = fold fst (map Spair ts) ` fst (Spair s) ` C\n  \\<forall>r\\<in>set ts.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        C0 \\<in> f \\<turnstile> \\<C>\n  Es = [] \\<and> Bs = []\n  ss = rs @ s # ts\n  Cs @ [C] = As @ B # Bs\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  C0 # As = Es @ [E]\n  fst (Spair s) ` B = E\n  \\<lbrakk>order.greater_eq\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            (set ts);\n   \\<forall>r\\<in>set ts.\n      \\<forall>(f, g)\\<in>fundfoldpairs.\n         r = Abs_induced_automorph f g \\<longrightarrow>\n         C0 \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fold fst (map Spair ts) ` C0 = C0\n  \\<lbrakk>order.greater_eq\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            (set ts);\n   \\<forall>r\\<in>set ts.\n      \\<forall>(f, g)\\<in>fundfoldpairs.\n         r = Abs_induced_automorph f g \\<longrightarrow>\n         C0 \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fold fst (map Spair ts) ` C0 = C0\n\ngoal (1 subgoal):\n 1. (fold fst (map Spair ss) ^^ 1) ` C = C0", "by    fastforce"], ["proof (state)\nthis:\n  (fold fst (map Spair ss) ^^ 1) ` C = C0\n\ngoal (2 subgoals):\n 1. Es = [] \\<and> Bs = [] \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n 2. \\<not> (Es = [] \\<and> Bs = []) \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "thus ?thesis"], ["proof (prove)\nusing this:\n  (fold fst (map Spair ss) ^^ 1) ` C = C0\n\ngoal (1 subgoal):\n 1. \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "by fast"], ["proof (state)\nthis:\n  \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n\ngoal (1 subgoal):\n 1. \\<not> (Es = [] \\<and> Bs = []) \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (Es = [] \\<and> Bs = []) \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "case False"], ["proof (state)\nthis:\n  \\<not> (Es = [] \\<and> Bs = [])\n\ngoal (1 subgoal):\n 1. \\<not> (Es = [] \\<and> Bs = []) \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "have EsBs: \"\\<not> (Es = [] \\<and> Bs = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (Es = [] \\<and> Bs = [])", "by fact"], ["proof (state)\nthis:\n  \\<not> (Es = [] \\<and> Bs = [])\n\ngoal (1 subgoal):\n 1. \\<not> (Es = [] \\<and> Bs = []) \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "proof (cases \"fold fst (map Spair ss) ` C = C0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fold fst (map Spair ss) ` C = C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n 2. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "case True"], ["proof (state)\nthis:\n  fold fst (map Spair ss) ` C = C0\n\ngoal (2 subgoals):\n 1. fold fst (map Spair ss) ` C = C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n 2. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "hence \"(fold fst (map Spair ss) ^^ 1) ` C = C0\""], ["proof (prove)\nusing this:\n  fold fst (map Spair ss) ` C = C0\n\ngoal (1 subgoal):\n 1. (fold fst (map Spair ss) ^^ 1) ` C = C0", "by simp"], ["proof (state)\nthis:\n  (fold fst (map Spair ss) ^^ 1) ` C = C0\n\ngoal (2 subgoals):\n 1. fold fst (map Spair ss) ` C = C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n 2. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "thus ?thesis"], ["proof (prove)\nusing this:\n  (fold fst (map Spair ss) ^^ 1) ` C = C0\n\ngoal (1 subgoal):\n 1. \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "by fast"], ["proof (state)\nthis:\n  \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "case False"], ["proof (state)\nthis:\n  fold fst (map Spair ss) ` C \\<noteq> C0\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "from decomps(5)"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>set rs.\n     \\<forall>D\\<in>set (Cs @ [C]).\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           D \\<in> f \\<turnstile> \\<C>", "have C0CsC_rs_f\\<C>:\n        \"\\<forall>r\\<in>set rs. \\<forall>D\\<in>set (C0#Cs@[C]). \\<forall>(f,g)\\<in>fundfoldpairs. \n          r = Abs_induced_automorph f g \\<longrightarrow> D\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set rs.\n     \\<forall>D\\<in>set (Cs @ [C]).\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           D \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set rs.\n       \\<forall>D\\<in>set (C0 # Cs @ [C]).\n          \\<forall>(f, g)\\<in>fundfoldpairs.\n             r = Abs_induced_automorph f g \\<longrightarrow>\n             D \\<in> f \\<turnstile> \\<C>", "using fundfoldpair_fundchamber_in_half_chamber_system_f"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set rs.\n     \\<forall>D\\<in>set (Cs @ [C]).\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           D \\<in> f \\<turnstile> \\<C>\n  (?f, ?g) \\<in> fundfoldpairs \\<Longrightarrow>\n  C0 \\<in> ?f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set rs.\n       \\<forall>D\\<in>set (C0 # Cs @ [C]).\n          \\<forall>(f, g)\\<in>fundfoldpairs.\n             r = Abs_induced_automorph f g \\<longrightarrow>\n             D \\<in> f \\<turnstile> \\<C>", "by    auto"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set rs.\n     \\<forall>D\\<in>set (C0 # Cs @ [C]).\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           D \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "from decomps(1)"], ["proof (chain)\npicking this:\n  ss = rs @ s # ts", "have  \"fold fst (map Spair (rs@[s])) \\<Turnstile> (C0#Cs@[C]) =\n                fst (Spair s) \\<Turnstile> (fold fst (map Spair rs) \\<Turnstile> (C0#Cs@[C]))\""], ["proof (prove)\nusing this:\n  ss = rs @ s # ts\n\ngoal (1 subgoal):\n 1. fold fst (map Spair (rs @ [s])) \\<Turnstile> (C0 # Cs @ [C]) =\n    fst (Spair s) \\<Turnstile>\n    (fold fst (map Spair rs) \\<Turnstile> (C0 # Cs @ [C]))", "by    (simp add: image_comp)"], ["proof (state)\nthis:\n  fold fst (map Spair (rs @ [s])) \\<Turnstile> (C0 # Cs @ [C]) =\n  fst (Spair s) \\<Turnstile>\n  (fold fst (map Spair rs) \\<Turnstile> (C0 # Cs @ [C]))\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "also"], ["proof (state)\nthis:\n  fold fst (map Spair (rs @ [s])) \\<Turnstile> (C0 # Cs @ [C]) =\n  fst (Spair s) \\<Turnstile>\n  (fold fst (map Spair rs) \\<Turnstile> (C0 # Cs @ [C]))\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "from ss decomps(1)"], ["proof (chain)\npicking this:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss = rs @ s # ts", "have  \"\\<dots> =  fst (Spair s) \\<Turnstile> (C0#Cs@[C])\""], ["proof (prove)\nusing this:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss = rs @ s # ts\n\ngoal (1 subgoal):\n 1. fst (Spair s) \\<Turnstile>\n    (fold fst (map Spair rs) \\<Turnstile> (C0 # Cs @ [C])) =\n    fst (Spair s) \\<Turnstile> (C0 # Cs @ [C])", "using C0CsC_rs_f\\<C> fundfold_comp_trivial_f\\<C>_list[of rs \"C0#Cs@[C]\"]"], ["proof (prove)\nusing this:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss = rs @ s # ts\n  \\<forall>r\\<in>set rs.\n     \\<forall>D\\<in>set (C0 # Cs @ [C]).\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           D \\<in> f \\<turnstile> \\<C>\n  \\<lbrakk>order.greater_eq\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            (set rs);\n   \\<forall>r\\<in>set rs.\n      \\<forall>C\\<in>set (C0 # Cs @ [C]).\n         \\<forall>(f, g)\\<in>fundfoldpairs.\n            r = Abs_induced_automorph f g \\<longrightarrow>\n            C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fold fst (map Spair rs) \\<Turnstile> (C0 # Cs @ [C]) =\n                    C0 # Cs @ [C]\n\ngoal (1 subgoal):\n 1. fst (Spair s) \\<Turnstile>\n    (fold fst (map Spair rs) \\<Turnstile> (C0 # Cs @ [C])) =\n    fst (Spair s) \\<Turnstile> (C0 # Cs @ [C])", "by    fastforce"], ["proof (state)\nthis:\n  fst (Spair s) \\<Turnstile>\n  (fold fst (map Spair rs) \\<Turnstile> (C0 # Cs @ [C])) =\n  fst (Spair s) \\<Turnstile> (C0 # Cs @ [C])\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "also"], ["proof (state)\nthis:\n  fst (Spair s) \\<Turnstile>\n  (fold fst (map Spair rs) \\<Turnstile> (C0 # Cs @ [C])) =\n  fst (Spair s) \\<Turnstile> (C0 # Cs @ [C])\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "from decomp2"], ["proof (chain)\npicking this:\n  C0 # Cs @ [C] = Es @ E # B # Bs", "have \"\\<dots> =  fst (Spair s) \\<Turnstile> (Es@E#B#Bs)\""], ["proof (prove)\nusing this:\n  C0 # Cs @ [C] = Es @ E # B # Bs\n\ngoal (1 subgoal):\n 1. fst (Spair s) \\<Turnstile> (C0 # Cs @ [C]) =\n    fst (Spair s) \\<Turnstile> (Es @ E # B # Bs)", "by (simp add: image_comp)"], ["proof (state)\nthis:\n  fst (Spair s) \\<Turnstile> (C0 # Cs @ [C]) =\n  fst (Spair s) \\<Turnstile> (Es @ E # B # Bs)\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "finally"], ["proof (chain)\npicking this:\n  fold fst (map Spair (rs @ [s])) \\<Turnstile> (C0 # Cs @ [C]) =\n  fst (Spair s) \\<Turnstile> (Es @ E # B # Bs)", "have  \"fold fst (map Spair (rs@[s])) \\<Turnstile> (C0#Cs@[C]) =\n                Es @ E # E # fst (Spair s) \\<Turnstile> Bs\""], ["proof (prove)\nusing this:\n  fold fst (map Spair (rs @ [s])) \\<Turnstile> (C0 # Cs @ [C]) =\n  fst (Spair s) \\<Turnstile> (Es @ E # B # Bs)\n\ngoal (1 subgoal):\n 1. fold fst (map Spair (rs @ [s])) \\<Turnstile> (C0 # Cs @ [C]) =\n    Es @ E # E # fst (Spair s) \\<Turnstile> Bs", "using decomps(1) ss sB EsE_s_f\\<C> fundfold_trivial_f\\<C>_list[of s \"Es@[E]\"]"], ["proof (prove)\nusing this:\n  fold fst (map Spair (rs @ [s])) \\<Turnstile> (C0 # Cs @ [C]) =\n  fst (Spair s) \\<Turnstile> (Es @ E # B # Bs)\n  ss = rs @ s # ts\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  fst (Spair s) ` B = E\n  \\<forall>A\\<in>set (Es @ [E]).\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        s = Abs_induced_automorph f g \\<longrightarrow>\n        A \\<in> f \\<turnstile> \\<C>\n  \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g});\n   \\<forall>C\\<in>set (Es @ [E]).\n      \\<forall>(f, g)\\<in>fundfoldpairs.\n         s = Abs_induced_automorph f g \\<longrightarrow>\n         C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fst (Spair s) \\<Turnstile> (Es @ [E]) = Es @ [E]\n\ngoal (1 subgoal):\n 1. fold fst (map Spair (rs @ [s])) \\<Turnstile> (C0 # Cs @ [C]) =\n    Es @ E # E # fst (Spair s) \\<Turnstile> Bs", "by    fastforce"], ["proof (state)\nthis:\n  fold fst (map Spair (rs @ [s])) \\<Turnstile> (C0 # Cs @ [C]) =\n  Es @ E # E # fst (Spair s) \\<Turnstile> Bs\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "with set_up ss decomps(1)"], ["proof (chain)\npicking this:\n  pgallery (C0 # Cs @ [C])\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss = rs @ s # ts\n  fold fst (map Spair (rs @ [s])) \\<Turnstile> (C0 # Cs @ [C]) =\n  Es @ E # E # fst (Spair s) \\<Turnstile> Bs", "have  gal: \"gallery (Es @ E # fst (Spair s) \\<Turnstile> Bs)\""], ["proof (prove)\nusing this:\n  pgallery (C0 # Cs @ [C])\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss = rs @ s # ts\n  fold fst (map Spair (rs @ [s])) \\<Turnstile> (C0 # Cs @ [C]) =\n  Es @ E # E # fst (Spair s) \\<Turnstile> Bs\n\ngoal (1 subgoal):\n 1. gallery (Es @ E # fst (Spair s) \\<Turnstile> Bs)", "using pgallery fundfold_comp_gallery_map[of _ \"rs@[s]\"]\n              gallery_remdup_adj[of Es E \"fst (Spair s) \\<Turnstile> Bs\"]"], ["proof (prove)\nusing this:\n  pgallery (C0 # Cs @ [C])\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss = rs @ s # ts\n  fold fst (map Spair (rs @ [s])) \\<Turnstile> (C0 # Cs @ [C]) =\n  Es @ E # E # fst (Spair s) \\<Turnstile> Bs\n  pgallery ?xs \\<Longrightarrow> gallery ?xs\n  \\<lbrakk>gallery ?Cs;\n   order.greater_eq\n    (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n    (set (rs @ [s]))\\<rbrakk>\n  \\<Longrightarrow> gallery\n                     (fold fst (map Spair (rs @ [s])) \\<Turnstile> ?Cs)\n  gallery (Es @ [E, E] @ fst (Spair s) \\<Turnstile> Bs) \\<Longrightarrow>\n  gallery (Es @ [E] @ fst (Spair s) \\<Turnstile> Bs)\n\ngoal (1 subgoal):\n 1. gallery (Es @ E # fst (Spair s) \\<Turnstile> Bs)", "by    fastforce"], ["proof (state)\nthis:\n  gallery (Es @ E # fst (Spair s) \\<Turnstile> Bs)\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "from EsBs decomp2 EsE"], ["proof (chain)\npicking this:\n  \\<not> (Es = [] \\<and> Bs = [])\n  C0 # Cs @ [C] = Es @ E # B # Bs\n  C0 # As = Es @ [E]", "have  \"\\<exists>Zs. length Zs < length Cs \\<and>\n                Es @ E # fst (Spair s) \\<Turnstile> Bs = C0 # Zs @ [fst (Spair s) ` C]\""], ["proof (prove)\nusing this:\n  \\<not> (Es = [] \\<and> Bs = [])\n  C0 # Cs @ [C] = Es @ E # B # Bs\n  C0 # As = Es @ [E]\n\ngoal (1 subgoal):\n 1. \\<exists>Zs.\n       order.greater (length Cs) (length Zs) \\<and>\n       Es @ E # fst (Spair s) \\<Turnstile> Bs =\n       C0 # Zs @ [fst (Spair s) ` C]", "using sB"], ["proof (prove)\nusing this:\n  \\<not> (Es = [] \\<and> Bs = [])\n  C0 # Cs @ [C] = Es @ E # B # Bs\n  C0 # As = Es @ [E]\n  fst (Spair s) ` B = E\n\ngoal (1 subgoal):\n 1. \\<exists>Zs.\n       order.greater (length Cs) (length Zs) \\<and>\n       Es @ E # fst (Spair s) \\<Turnstile> Bs =\n       C0 # Zs @ [fst (Spair s) ` C]", "by    (cases Bs Es rule: two_lists_cases_snoc_Cons') auto"], ["proof (state)\nthis:\n  \\<exists>Zs.\n     order.greater (length Cs) (length Zs) \\<and>\n     Es @ E # fst (Spair s) \\<Turnstile> Bs = C0 # Zs @ [fst (Spair s) ` C]\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "from this"], ["proof (chain)\npicking this:\n  \\<exists>Zs.\n     order.greater (length Cs) (length Zs) \\<and>\n     Es @ E # fst (Spair s) \\<Turnstile> Bs = C0 # Zs @ [fst (Spair s) ` C]", "obtain Zs where Zs:\n        \"length Zs < length Cs\"\n        \"Es @ E # fst (Spair s) \\<Turnstile> Bs = C0 # Zs @ [fst (Spair s) ` C]\""], ["proof (prove)\nusing this:\n  \\<exists>Zs.\n     order.greater (length Cs) (length Zs) \\<and>\n     Es @ E # fst (Spair s) \\<Turnstile> Bs = C0 # Zs @ [fst (Spair s) ` C]\n\ngoal (1 subgoal):\n 1. (\\<And>Zs.\n        \\<lbrakk>order.greater (length Cs) (length Zs);\n         Es @ E # fst (Spair s) \\<Turnstile> Bs =\n         C0 # Zs @ [fst (Spair s) ` C]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  order.greater (length Cs) (length Zs)\n  Es @ E # fst (Spair s) \\<Turnstile> Bs = C0 # Zs @ [fst (Spair s) ` C]\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "define Ys where \"Ys = fold fst (map Spair ts) \\<Turnstile> Zs\""], ["proof (state)\nthis:\n  Ys = fold fst (map Spair ts) \\<Turnstile> Zs\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "with Zs(2)"], ["proof (chain)\npicking this:\n  Es @ E # fst (Spair s) \\<Turnstile> Bs = C0 # Zs @ [fst (Spair s) ` C]\n  Ys = fold fst (map Spair ts) \\<Turnstile> Zs", "have\n        \"fold fst (map Spair ts) \\<Turnstile> (Es @ E # fst (Spair s) \\<Turnstile> Bs) =\n          fold fst (map Spair ts) ` C0 # Ys @ [fold fst (map Spair (s#ts)) ` C]\""], ["proof (prove)\nusing this:\n  Es @ E # fst (Spair s) \\<Turnstile> Bs = C0 # Zs @ [fst (Spair s) ` C]\n  Ys = fold fst (map Spair ts) \\<Turnstile> Zs\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ts) \\<Turnstile>\n    (Es @ E # fst (Spair s) \\<Turnstile> Bs) =\n    fold fst (map Spair ts) ` C0 # Ys @ [fold fst (map Spair (s # ts)) ` C]", "by (simp add: image_comp)"], ["proof (state)\nthis:\n  fold fst (map Spair ts) \\<Turnstile>\n  (Es @ E # fst (Spair s) \\<Turnstile> Bs) =\n  fold fst (map Spair ts) ` C0 # Ys @ [fold fst (map Spair (s # ts)) ` C]\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "moreover"], ["proof (state)\nthis:\n  fold fst (map Spair ts) \\<Turnstile>\n  (Es @ E # fst (Spair s) \\<Turnstile> Bs) =\n  fold fst (map Spair ts) ` C0 # Ys @ [fold fst (map Spair (s # ts)) ` C]\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "have  \"\\<forall>r\\<in>set ts. \\<forall>(f,g)\\<in>fundfoldpairs.\n                r = Abs_induced_automorph f g \\<longrightarrow> C0\\<in>f\\<turnstile>\\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set ts.\n       \\<forall>(f, g)\\<in>fundfoldpairs.\n          r = Abs_induced_automorph f g \\<longrightarrow>\n          C0 \\<in> f \\<turnstile> \\<C>", "using fundfoldpair_fundchamber_in_half_chamber_system_f"], ["proof (prove)\nusing this:\n  (?f, ?g) \\<in> fundfoldpairs \\<Longrightarrow>\n  C0 \\<in> ?f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set ts.\n       \\<forall>(f, g)\\<in>fundfoldpairs.\n          r = Abs_induced_automorph f g \\<longrightarrow>\n          C0 \\<in> f \\<turnstile> \\<C>", "by    fast"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set ts.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        C0 \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "ultimately"], ["proof (chain)\npicking this:\n  fold fst (map Spair ts) \\<Turnstile>\n  (Es @ E # fst (Spair s) \\<Turnstile> Bs) =\n  fold fst (map Spair ts) ` C0 # Ys @ [fold fst (map Spair (s # ts)) ` C]\n  \\<forall>r\\<in>set ts.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        C0 \\<in> f \\<turnstile> \\<C>", "have\n        \"fold fst (map Spair ts) \\<Turnstile> (Es @ E # fst (Spair s) \\<Turnstile> Bs) =\n          C0 # Ys @ [fold fst (map Spair (s#ts)) ` fold fst (map Spair rs) ` C]\""], ["proof (prove)\nusing this:\n  fold fst (map Spair ts) \\<Turnstile>\n  (Es @ E # fst (Spair s) \\<Turnstile> Bs) =\n  fold fst (map Spair ts) ` C0 # Ys @ [fold fst (map Spair (s # ts)) ` C]\n  \\<forall>r\\<in>set ts.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        C0 \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ts) \\<Turnstile>\n    (Es @ E # fst (Spair s) \\<Turnstile> Bs) =\n    C0 # Ys @ [fold fst (map Spair (s # ts)) ` fold fst (map Spair rs) ` C]", "using decomps(1) ss C0CsC_rs_f\\<C> fundfold_comp_trivial_f\\<C>[of ts C0]\n              fundfold_comp_trivial_f\\<C>[of rs C]"], ["proof (prove)\nusing this:\n  fold fst (map Spair ts) \\<Turnstile>\n  (Es @ E # fst (Spair s) \\<Turnstile> Bs) =\n  fold fst (map Spair ts) ` C0 # Ys @ [fold fst (map Spair (s # ts)) ` C]\n  \\<forall>r\\<in>set ts.\n     \\<forall>(f, g)\\<in>fundfoldpairs.\n        r = Abs_induced_automorph f g \\<longrightarrow>\n        C0 \\<in> f \\<turnstile> \\<C>\n  ss = rs @ s # ts\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<forall>r\\<in>set rs.\n     \\<forall>D\\<in>set (C0 # Cs @ [C]).\n        \\<forall>(f, g)\\<in>fundfoldpairs.\n           r = Abs_induced_automorph f g \\<longrightarrow>\n           D \\<in> f \\<turnstile> \\<C>\n  \\<lbrakk>order.greater_eq\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            (set ts);\n   \\<forall>r\\<in>set ts.\n      \\<forall>(f, g)\\<in>fundfoldpairs.\n         r = Abs_induced_automorph f g \\<longrightarrow>\n         C0 \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fold fst (map Spair ts) ` C0 = C0\n  \\<lbrakk>order.greater_eq\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            (set rs);\n   \\<forall>r\\<in>set rs.\n      \\<forall>(f, g)\\<in>fundfoldpairs.\n         r = Abs_induced_automorph f g \\<longrightarrow>\n         C \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fold fst (map Spair rs) ` C = C\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ts) \\<Turnstile>\n    (Es @ E # fst (Spair s) \\<Turnstile> Bs) =\n    C0 # Ys @ [fold fst (map Spair (s # ts)) ` fold fst (map Spair rs) ` C]", "by    fastforce"], ["proof (state)\nthis:\n  fold fst (map Spair ts) \\<Turnstile>\n  (Es @ E # fst (Spair s) \\<Turnstile> Bs) =\n  C0 # Ys @ [fold fst (map Spair (s # ts)) ` fold fst (map Spair rs) ` C]\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "with decomps(1) ss"], ["proof (chain)\npicking this:\n  ss = rs @ s # ts\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  fold fst (map Spair ts) \\<Turnstile>\n  (Es @ E # fst (Spair s) \\<Turnstile> Bs) =\n  C0 # Ys @ [fold fst (map Spair (s # ts)) ` fold fst (map Spair rs) ` C]", "obtain Xs where Xs:\n        \"length Xs \\<le> length Ys\"\n        \"pgallery (C0 # Xs @ [fold fst (map Spair ss) ` C])\""], ["proof (prove)\nusing this:\n  ss = rs @ s # ts\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  fold fst (map Spair ts) \\<Turnstile>\n  (Es @ E # fst (Spair s) \\<Turnstile> Bs) =\n  C0 # Ys @ [fold fst (map Spair (s # ts)) ` fold fst (map Spair rs) ` C]\n\ngoal (1 subgoal):\n 1. (\\<And>Xs.\n        \\<lbrakk>order.greater_eq (length Ys) (length Xs);\n         pgallery (C0 # Xs @ [fold fst (map Spair ss) ` C])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using gal fundfold_comp_gallery_map[of \"Es @ E # fst (Spair s) \\<Turnstile> Bs\" ts]\n              gallery_obtain_pgallery[OF False[THEN not_sym]]"], ["proof (prove)\nusing this:\n  ss = rs @ s # ts\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  fold fst (map Spair ts) \\<Turnstile>\n  (Es @ E # fst (Spair s) \\<Turnstile> Bs) =\n  C0 # Ys @ [fold fst (map Spair (s # ts)) ` fold fst (map Spair rs) ` C]\n  gallery (Es @ E # fst (Spair s) \\<Turnstile> Bs)\n  \\<lbrakk>gallery (Es @ E # fst (Spair s) \\<Turnstile> Bs);\n   order.greater_eq\n    (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n    (set ts)\\<rbrakk>\n  \\<Longrightarrow> gallery\n                     (fold fst (map Spair ts) \\<Turnstile>\n                      (Es @ E # fst (Spair s) \\<Turnstile> Bs))\n  gallery (C0 # ?xs @ [fold fst (map Spair ss) ` C]) \\<Longrightarrow>\n  \\<exists>ys.\n     order.greater_eq (set ?xs) (set ys) \\<and>\n     order.greater_eq (length ?xs) (length ys) \\<and>\n     pgallery (C0 # ys @ [fold fst (map Spair ss) ` C])\n\ngoal (1 subgoal):\n 1. (\\<And>Xs.\n        \\<lbrakk>order.greater_eq (length Ys) (length Xs);\n         pgallery (C0 # Xs @ [fold fst (map Spair ss) ` C])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    (fastforce simp add: image_comp)"], ["proof (state)\nthis:\n  order.greater_eq (length Ys) (length Xs)\n  pgallery (C0 # Xs @ [fold fst (map Spair ss) ` C])\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "from Ys_def Xs(1) Zs(1)"], ["proof (chain)\npicking this:\n  Ys = fold fst (map Spair ts) \\<Turnstile> Zs\n  order.greater_eq (length Ys) (length Xs)\n  order.greater (length Cs) (length Zs)", "have \"length Xs < length Cs\""], ["proof (prove)\nusing this:\n  Ys = fold fst (map Spair ts) \\<Turnstile> Zs\n  order.greater_eq (length Ys) (length Xs)\n  order.greater (length Cs) (length Zs)\n\ngoal (1 subgoal):\n 1. order.greater (length Cs) (length Xs)", "by simp"], ["proof (state)\nthis:\n  order.greater (length Cs) (length Xs)\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "with Xs(2)"], ["proof (chain)\npicking this:\n  pgallery (C0 # Xs @ [fold fst (map Spair ss) ` C])\n  order.greater (length Cs) (length Xs)", "obtain n where \"(fold fst (map Spair ss) ^^ (Suc n)) ` C = C0\""], ["proof (prove)\nusing this:\n  pgallery (C0 # Xs @ [fold fst (map Spair ss) ` C])\n  order.greater (length Cs) (length Xs)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (fold fst (map Spair ss) ^^ Suc n) ` C = C0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using step"], ["proof (prove)\nusing this:\n  pgallery (C0 # Xs @ [fold fst (map Spair ss) ` C])\n  order.greater (length Cs) (length Xs)\n  \\<forall>ys.\n     order.greater (length Cs) (length ys) \\<longrightarrow>\n     (\\<forall>x.\n         pgallery (C0 # ys @ [x]) \\<longrightarrow>\n         (\\<exists>n. (fold fst (map Spair ss) ^^ n) ` x = C0))\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (fold fst (map Spair ss) ^^ Suc n) ` C = C0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (force simp add: image_comp funpow_Suc_right[THEN sym])"], ["proof (state)\nthis:\n  (fold fst (map Spair ss) ^^ Suc n) ` C = C0\n\ngoal (1 subgoal):\n 1. fold fst (map Spair ss) ` C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "thus ?thesis"], ["proof (prove)\nusing this:\n  (fold fst (map Spair ss) ^^ Suc n) ` C = C0\n\ngoal (1 subgoal):\n 1. \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "by fast"], ["proof (state)\nthis:\n  \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fundfold_comp_chamber_ex_funpow:\n  assumes ss: \"set ss = S\" and C: \"chamber C\"\n  shows   \"\\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "proof (cases \"C=C0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C = C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n 2. C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "case True"], ["proof (state)\nthis:\n  C = C0\n\ngoal (2 subgoals):\n 1. C = C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n 2. C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "hence \"(fold fst (map Spair ss) ^^ 0) ` C = C0\""], ["proof (prove)\nusing this:\n  C = C0\n\ngoal (1 subgoal):\n 1. (fold fst (map Spair ss) ^^ 0) ` C = C0", "by simp"], ["proof (state)\nthis:\n  (fold fst (map Spair ss) ^^ 0) ` C = C0\n\ngoal (2 subgoals):\n 1. C = C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n 2. C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "thus ?thesis"], ["proof (prove)\nusing this:\n  (fold fst (map Spair ss) ^^ 0) ` C = C0\n\ngoal (1 subgoal):\n 1. \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "by fast"], ["proof (state)\nthis:\n  \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n\ngoal (1 subgoal):\n 1. C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "case False"], ["proof (state)\nthis:\n  C \\<noteq> C0\n\ngoal (1 subgoal):\n 1. C \\<noteq> C0 \\<Longrightarrow>\n    \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "with fundchamber assms"], ["proof (chain)\npicking this:\n  chamber C0\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  chamber C\n  C \\<noteq> C0", "show ?thesis"], ["proof (prove)\nusing this:\n  chamber C0\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  chamber C\n  C \\<noteq> C0\n\ngoal (1 subgoal):\n 1. \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "using chamber_pconnect[of C0 C] fundfold_comp_pgallery_ex_funpow"], ["proof (prove)\nusing this:\n  chamber C0\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  chamber C\n  C \\<noteq> C0\n  \\<lbrakk>C0 \\<noteq> C; chamber C0; chamber C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs. pgallery (C0 # xs @ [C])\n  \\<lbrakk>set ?ss =\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   pgallery (C0 # ?Cs @ [?C])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. (fold fst (map Spair ?ss) ^^ n) ` ?C = C0\n\ngoal (1 subgoal):\n 1. \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0", "by    fastforce"], ["proof (state)\nthis:\n  \\<exists>n. (fold fst (map Spair ss) ^^ n) ` C = C0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fundfold_comp_fixespointwise_C0:\n  assumes \"set ss \\<subseteq> S\"\n  shows   \"fixespointwise (fold fst (map Spair ss)) C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise (fold fst (map Spair ss)) C0", "proof (rule fold_fixespointwise, rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map Spair ss) \\<Longrightarrow>\n       fixespointwise (fst x) C0", "fix fg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map Spair ss) \\<Longrightarrow>\n       fixespointwise (fst x) C0", "assume \"fg \\<in> set (map Spair ss)\""], ["proof (state)\nthis:\n  fg \\<in> set (map Spair ss)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map Spair ss) \\<Longrightarrow>\n       fixespointwise (fst x) C0", "from this"], ["proof (chain)\npicking this:\n  fg \\<in> set (map Spair ss)", "obtain s where \"s\\<in>set ss\" \"fg = Spair s\""], ["proof (prove)\nusing this:\n  fg \\<in> set (map Spair ss)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> set ss; fg = Spair s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s \\<in> set ss\n  fg = Spair s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map Spair ss) \\<Longrightarrow>\n       fixespointwise (fst x) C0", "with assms"], ["proof (chain)\npicking this:\n  order.greater_eq\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) (set ss)\n  s \\<in> set ss\n  fg = Spair s", "have  fg': \"OpposedThinChamberComplexFoldings X (fst fg) (snd fg) C0\""], ["proof (prove)\nusing this:\n  order.greater_eq\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) (set ss)\n  s \\<in> set ss\n  fg = Spair s\n\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings X (fst fg) (snd fg) C0", "using Spair_fundfoldpair fundfoldpairs_def"], ["proof (prove)\nusing this:\n  order.greater_eq\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) (set ss)\n  s \\<in> set ss\n  fg = Spair s\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  Spair ?s \\<in> fundfoldpairs\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings X (fst fg) (snd fg) C0", "by    fastforce"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X (fst fg) (snd fg) C0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map Spair ss) \\<Longrightarrow>\n       fixespointwise (fst x) C0", "show \"fixespointwise (fst fg) C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise (fst fg) C0", "using OpposedThinChamberComplexFoldings.axioms(2)[OF fg']\n          OpposedThinChamberComplexFoldings.chamber_D0[OF fg']\n          OpposedThinChamberComplexFoldings.chambers(4)[OF fg']\n          chamber_system_def\n          ChamberComplexFolding.chamber_retraction1[of X \"fst fg\" C0]"], ["proof (prove)\nusing this:\n  ChamberComplexFolding X (fst fg)\n  chamber (snd fg ` C0)\n  fst fg ` snd fg ` C0 = C0\n  \\<C> \\<equiv> Collect chamber\n  \\<lbrakk>ChamberComplexFolding X (fst fg);\n   C0 \\<in> fst fg \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> fixespointwise (fst fg) C0\n\ngoal (1 subgoal):\n 1. fixespointwise (fst fg) C0", "by    auto"], ["proof (state)\nthis:\n  fixespointwise (fst fg) C0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fundfold_comp_endomorphism:\n  assumes \"set ss \\<subseteq> S\"\n  shows   \"ChamberComplexEndomorphism X (fold fst (map Spair ss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (fold fst (map Spair ss))", "proof (rule fold_chamber_complex_endomorph_list, rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map Spair ss) \\<Longrightarrow>\n       ChamberComplexEndomorphism X (fst x)", "fix fg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map Spair ss) \\<Longrightarrow>\n       ChamberComplexEndomorphism X (fst x)", "assume fg: \"fg \\<in>set (map Spair ss)\""], ["proof (state)\nthis:\n  fg \\<in> set (map Spair ss)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map Spair ss) \\<Longrightarrow>\n       ChamberComplexEndomorphism X (fst x)", "from this"], ["proof (chain)\npicking this:\n  fg \\<in> set (map Spair ss)", "obtain s where \"s\\<in>set ss\" \"fg = Spair s\""], ["proof (prove)\nusing this:\n  fg \\<in> set (map Spair ss)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> set ss; fg = Spair s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s \\<in> set ss\n  fg = Spair s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map Spair ss) \\<Longrightarrow>\n       ChamberComplexEndomorphism X (fst x)", "with assms"], ["proof (chain)\npicking this:\n  order.greater_eq\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) (set ss)\n  s \\<in> set ss\n  fg = Spair s", "show \"ChamberComplexEndomorphism X (fst fg)\""], ["proof (prove)\nusing this:\n  order.greater_eq\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) (set ss)\n  s \\<in> set ss\n  fg = Spair s\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (fst fg)", "using     Spair_fundfoldpair\n              OpposedThinChamberComplexFoldings.axioms(2)[of X]\n              ChamberComplexFolding.axioms(1)[of X]\n              ChamberComplexRetraction.axioms(1)[of X]"], ["proof (prove)\nusing this:\n  order.greater_eq\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) (set ss)\n  s \\<in> set ss\n  fg = Spair s\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  Spair ?s \\<in> fundfoldpairs\n  OpposedThinChamberComplexFoldings X ?f ?g ?C0.0 \\<Longrightarrow>\n  ChamberComplexFolding X ?f\n  ChamberComplexFolding X ?f \\<Longrightarrow> ChamberComplexRetraction X ?f\n  ChamberComplexRetraction X ?f \\<Longrightarrow>\n  ChamberComplexEndomorphism X ?f\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (fst fg)", "unfolding fundfoldpairs_def"], ["proof (prove)\nusing this:\n  order.greater_eq\n   (\\<Union>(f, g)\\<in>{(f, g). OpposedThinChamberComplexFoldings X f g C0}.\n       {Abs_induced_automorph f g})\n   (set ss)\n  s \\<in> set ss\n  fg = Spair s\n  ?s \\<in> (\\<Union>(f,\n               g)\\<in>{(f, g). OpposedThinChamberComplexFoldings X f g C0}.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  Spair ?s \\<in> {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  OpposedThinChamberComplexFoldings X ?f ?g ?C0.0 \\<Longrightarrow>\n  ChamberComplexFolding X ?f\n  ChamberComplexFolding X ?f \\<Longrightarrow> ChamberComplexRetraction X ?f\n  ChamberComplexRetraction X ?f \\<Longrightarrow>\n  ChamberComplexEndomorphism X ?f\n\ngoal (1 subgoal):\n 1. ChamberComplexEndomorphism X (fst fg)", "by        fastforce"], ["proof (state)\nthis:\n  ChamberComplexEndomorphism X (fst fg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_S: \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "using fundchamber_S_fundadjset fundchamber finite_adjacentset"], ["proof (prove)\nusing this:\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  ?s `\\<rightarrow> C0 \\<in> adjacentset C0 - {C0}\n  chamber C0\n  chamber ?C \\<Longrightarrow> finite (adjacentset ?C)\n\ngoal (1 subgoal):\n 1. finite (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "by    (blast intro: inj_on_finite fundchamber_S_image_inj_on)"], ["", "lemma ex_label_retraction: \"\\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0", "obtain ss where ss: \"set ss = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        set ss =\n        (\\<Union>(f, g)\\<in>fundfoldpairs.\n            {Abs_induced_automorph f g}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using finite_S finite_list"], ["proof (prove)\nusing this:\n  finite (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A\n\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        set ss =\n        (\\<Union>(f, g)\\<in>fundfoldpairs.\n            {Abs_induced_automorph f g}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0", "define fgs where \"fgs = map Spair ss\"\n  \\<comment> \\<open>for @{term \"fg \\<in> set fgs\"}, have @{term \"(fst fg) ` D = C0\"} for some @{term \"D \\<in> fundajdset\"}\\<close>"], ["proof (state)\nthis:\n  fgs = map Spair ss\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0", "define \\<psi> where \"\\<psi> = fold fst fgs\""], ["proof (state)\nthis:\n  \\<psi> = fold fst fgs\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0", "(* \\<psi> = fn \\<circ> \\<dots> \\<circ> f1 *)"], ["proof (state)\nthis:\n  \\<psi> = fold fst fgs\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0", "define vdist where \"vdist v = (LEAST n. (\\<psi>^^n) v \\<in> C0)\" for v"], ["proof (state)\nthis:\n  vdist ?v = (LEAST n. (\\<psi> ^^ n) ?v \\<in> C0)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0", "define \\<phi> where \"\\<phi> v = (\\<psi>^^(vdist v)) v\" for v"], ["proof (state)\nthis:\n  \\<phi> ?v = (\\<psi> ^^ vdist ?v) ?v\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0", "have \"label_wrt C0 \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. label_wrt C0 \\<phi>", "unfolding label_wrt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>\\<C>. bij_betw \\<phi> C C0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C. C \\<in> \\<C> \\<Longrightarrow> bij_betw \\<phi> C C0", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C. C \\<in> \\<C> \\<Longrightarrow> bij_betw \\<phi> C C0", "assume C: \"C\\<in>\\<C>\""], ["proof (state)\nthis:\n  C \\<in> \\<C>\n\ngoal (1 subgoal):\n 1. \\<And>C. C \\<in> \\<C> \\<Longrightarrow> bij_betw \\<phi> C C0", "show \"bij_betw \\<phi> C C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw \\<phi> C C0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw \\<phi> C C0", "from \\<psi>_def fgs_def ss C"], ["proof (chain)\npicking this:\n  \\<psi> = fold fst fgs\n  fgs = map Spair ss\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  C \\<in> \\<C>", "obtain m where m: \"(\\<psi>^^m)`C = C0\""], ["proof (prove)\nusing this:\n  \\<psi> = fold fst fgs\n  fgs = map Spair ss\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  C \\<in> \\<C>\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        (\\<psi> ^^ m) ` C = C0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using chamber_system_def fundfold_comp_chamber_ex_funpow"], ["proof (prove)\nusing this:\n  \\<psi> = fold fst fgs\n  fgs = map Spair ss\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  C \\<in> \\<C>\n  \\<C> \\<equiv> Collect chamber\n  \\<lbrakk>set ?ss =\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   chamber ?C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. (fold fst (map Spair ?ss) ^^ n) ` ?C = C0\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        (\\<psi> ^^ m) ` C = C0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  (\\<psi> ^^ m) ` C = C0\n\ngoal (1 subgoal):\n 1. bij_betw \\<phi> C C0", "have \"\\<And>v. v\\<in>C \\<Longrightarrow> (\\<psi>^^m) v = \\<phi> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> C \\<Longrightarrow> (\\<psi> ^^ m) v = \\<phi> v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> C \\<Longrightarrow> (\\<psi> ^^ m) v = \\<phi> v", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> C \\<Longrightarrow> (\\<psi> ^^ m) v = \\<phi> v", "assume v: \"v\\<in>C\""], ["proof (state)\nthis:\n  v \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> C \\<Longrightarrow> (\\<psi> ^^ m) v = \\<phi> v", "define n where \"n = (LEAST n. (\\<psi>^^n) v \\<in> C0)\""], ["proof (state)\nthis:\n  n = (LEAST n. (\\<psi> ^^ n) v \\<in> C0)\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> C \\<Longrightarrow> (\\<psi> ^^ m) v = \\<phi> v", "from v m \\<phi>_def vdist_def n_def"], ["proof (chain)\npicking this:\n  v \\<in> C\n  (\\<psi> ^^ m) ` C = C0\n  \\<phi> ?v = (\\<psi> ^^ vdist ?v) ?v\n  vdist ?v = (LEAST n. (\\<psi> ^^ n) ?v \\<in> C0)\n  n = (LEAST n. (\\<psi> ^^ n) v \\<in> C0)", "have \"m \\<ge> n\" \"\\<phi> v \\<in> C0\""], ["proof (prove)\nusing this:\n  v \\<in> C\n  (\\<psi> ^^ m) ` C = C0\n  \\<phi> ?v = (\\<psi> ^^ vdist ?v) ?v\n  vdist ?v = (LEAST n. (\\<psi> ^^ n) ?v \\<in> C0)\n  n = (LEAST n. (\\<psi> ^^ n) v \\<in> C0)\n\ngoal (1 subgoal):\n 1. order.greater_eq m n &&& \\<phi> v \\<in> C0", "using Least_le[of \"\\<lambda>n. (\\<psi>^^n) v \\<in> C0\" m]\n                LeastI_ex[of \"\\<lambda>n. (\\<psi>^^n) v \\<in> C0\"]"], ["proof (prove)\nusing this:\n  v \\<in> C\n  (\\<psi> ^^ m) ` C = C0\n  \\<phi> ?v = (\\<psi> ^^ vdist ?v) ?v\n  vdist ?v = (LEAST n. (\\<psi> ^^ n) ?v \\<in> C0)\n  n = (LEAST n. (\\<psi> ^^ n) v \\<in> C0)\n  (\\<psi> ^^ m) v \\<in> C0 \\<Longrightarrow>\n  order.greater_eq m (LEAST x. (\\<psi> ^^ x) v \\<in> C0)\n  \\<exists>x. (\\<psi> ^^ x) v \\<in> C0 \\<Longrightarrow>\n  (\\<psi> ^^ (LEAST n. (\\<psi> ^^ n) v \\<in> C0)) v \\<in> C0\n\ngoal (1 subgoal):\n 1. order.greater_eq m n &&& \\<phi> v \\<in> C0", "by    auto"], ["proof (state)\nthis:\n  order.greater_eq m n\n  \\<phi> v \\<in> C0\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> C \\<Longrightarrow> (\\<psi> ^^ m) v = \\<phi> v", "then"], ["proof (chain)\npicking this:\n  order.greater_eq m n\n  \\<phi> v \\<in> C0", "show \"(\\<psi>^^m) v = \\<phi> v\""], ["proof (prove)\nusing this:\n  order.greater_eq m n\n  \\<phi> v \\<in> C0\n\ngoal (1 subgoal):\n 1. (\\<psi> ^^ m) v = \\<phi> v", "using ss \\<psi>_def fgs_def \\<phi>_def vdist_def n_def funpow_add[of \"m-n\" n \\<psi>]\n                fundfold_comp_fixespointwise_C0\n                funpower_fixespointwise fixespointwiseD"], ["proof (prove)\nusing this:\n  order.greater_eq m n\n  \\<phi> v \\<in> C0\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<psi> = fold fst fgs\n  fgs = map Spair ss\n  \\<phi> ?v = (\\<psi> ^^ vdist ?v) ?v\n  vdist ?v = (LEAST n. (\\<psi> ^^ n) ?v \\<in> C0)\n  n = (LEAST n. (\\<psi> ^^ n) v \\<in> C0)\n  \\<psi> ^^ (m - n + n) = \\<psi> ^^ (m - n) \\<circ> \\<psi> ^^ n\n  order.greater_eq\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   (set ?ss) \\<Longrightarrow>\n  fixespointwise (fold fst (map Spair ?ss)) C0\n  fixespointwise ?f ?A \\<Longrightarrow> fixespointwise (?f ^^ ?n) ?A\n  \\<lbrakk>fixespointwise ?f ?A; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f ?a = id ?a\n\ngoal (1 subgoal):\n 1. (\\<psi> ^^ m) v = \\<phi> v", "by    fastforce"], ["proof (state)\nthis:\n  (\\<psi> ^^ m) v = \\<phi> v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?v1 \\<in> C \\<Longrightarrow> (\\<psi> ^^ m) ?v1 = \\<phi> ?v1\n\ngoal (1 subgoal):\n 1. bij_betw \\<phi> C C0", "with C m ss \\<psi>_def fgs_def"], ["proof (chain)\npicking this:\n  C \\<in> \\<C>\n  (\\<psi> ^^ m) ` C = C0\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<psi> = fold fst fgs\n  fgs = map Spair ss\n  ?v1 \\<in> C \\<Longrightarrow> (\\<psi> ^^ m) ?v1 = \\<phi> ?v1", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> \\<C>\n  (\\<psi> ^^ m) ` C = C0\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<psi> = fold fst fgs\n  fgs = map Spair ss\n  ?v1 \\<in> C \\<Longrightarrow> (\\<psi> ^^ m) ?v1 = \\<phi> ?v1\n\ngoal (1 subgoal):\n 1. bij_betw \\<phi> C C0", "using chamber_system_def fundchamber fundfold_comp_endomorphism\n              ChamberComplexEndomorphism.funpower_endomorphism[of X]\n              ChamberComplexEndomorphism.bij_betw_chambers[of X]\n              bij_betw_cong[of C \"\\<psi>^^m\" \\<phi> C0]"], ["proof (prove)\nusing this:\n  C \\<in> \\<C>\n  (\\<psi> ^^ m) ` C = C0\n  set ss = (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<psi> = fold fst fgs\n  fgs = map Spair ss\n  ?v1 \\<in> C \\<Longrightarrow> (\\<psi> ^^ m) ?v1 = \\<phi> ?v1\n  \\<C> \\<equiv> Collect chamber\n  chamber C0\n  order.greater_eq\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   (set ?ss) \\<Longrightarrow>\n  ChamberComplexEndomorphism X (fold fst (map Spair ?ss))\n  ChamberComplexEndomorphism X ?f \\<Longrightarrow>\n  ChamberComplexEndomorphism X (?f ^^ ?n)\n  \\<lbrakk>ChamberComplexEndomorphism X ?f; chamber ?C\\<rbrakk>\n  \\<Longrightarrow> bij_betw ?f ?C (?f ` ?C)\n  (\\<And>a.\n      a \\<in> C \\<Longrightarrow>\n      (\\<psi> ^^ m) a = \\<phi> a) \\<Longrightarrow>\n  bij_betw (\\<psi> ^^ m) C C0 = bij_betw \\<phi> C C0\n\ngoal (1 subgoal):\n 1. bij_betw \\<phi> C C0", "by    fastforce"], ["proof (state)\nthis:\n  bij_betw \\<phi> C C0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bij_betw \\<phi> C C0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  label_wrt C0 \\<phi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0", "moreover"], ["proof (state)\nthis:\n  label_wrt C0 \\<phi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0", "from vdist_def \\<phi>_def"], ["proof (chain)\npicking this:\n  vdist ?v = (LEAST n. (\\<psi> ^^ n) ?v \\<in> C0)\n  \\<phi> ?v = (\\<psi> ^^ vdist ?v) ?v", "have \"fixespointwise \\<phi> C0\""], ["proof (prove)\nusing this:\n  vdist ?v = (LEAST n. (\\<psi> ^^ n) ?v \\<in> C0)\n  \\<phi> ?v = (\\<psi> ^^ vdist ?v) ?v\n\ngoal (1 subgoal):\n 1. fixespointwise \\<phi> C0", "using Least_eq_0"], ["proof (prove)\nusing this:\n  vdist ?v = (LEAST n. (\\<psi> ^^ n) ?v \\<in> C0)\n  \\<phi> ?v = (\\<psi> ^^ vdist ?v) ?v\n  ?P 0 \\<Longrightarrow> Least ?P = 0\n\ngoal (1 subgoal):\n 1. fixespointwise \\<phi> C0", "by (fastforce intro: fixespointwiseI)"], ["proof (state)\nthis:\n  fixespointwise \\<phi> C0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0", "ultimately"], ["proof (chain)\npicking this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0", "show ?thesis"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0", "by fast"], ["proof (state)\nthis:\n  \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_label_map: \"\\<exists>\\<phi>. label_wrt C0 \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. label_wrt C0 \\<phi>", "using ex_label_retraction"], ["proof (prove)\nusing this:\n  \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. label_wrt C0 \\<phi>", "by fast"], ["", "end"], ["", "(* context ThinChamberComplexManyFoldings *)"], ["", "subsubsection \\<open>More on the action of the group of automorphisms on chambers\\<close>"], ["", "text \\<open>\n  Recall that we have already verified that @{term W} acts transitively on the chamber system. We\n  now use the labelling of the chamber complex examined in the previous section to show that this\n  action is simply transitive.\n\\<close>"], ["", "context ThinChamberComplexManyFoldings\nbegin"], ["", "lemma fundchamber_W_image_ker:\n  assumes \"w\\<in>W\" \"w`\\<rightarrow>C0 = C0\"\n  shows   \"w = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. w = 0", "obtain \\<phi> where \\<phi>: \"label_wrt C0 \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        label_wrt C0 \\<phi> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_label_map"], ["proof (prove)\nusing this:\n  \\<exists>\\<phi>. label_wrt C0 \\<phi>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        label_wrt C0 \\<phi> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  label_wrt C0 \\<phi>\n\ngoal (1 subgoal):\n 1. w = 0", "have \"fixespointwise (permutation w) C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise ((\\<rightarrow>) w) C0", "using W_respects_labels[OF \\<phi> assms(1)] chamberD_simplex[OF fundchamber]\n          ChamberComplexEndomorphism.respects_label_fixes_chamber_imp_fixespointwise[\n            OF W_endomorphism, OF assms(1) \\<phi> fundchamber assms(2)\n          ]"], ["proof (prove)\nusing this:\n  ?v \\<in> \\<Union> X \\<Longrightarrow>\n  \\<phi> (w \\<rightarrow> ?v) = \\<phi> ?v\n  C0 \\<in> X\n  \\<forall>v\\<in>C0. \\<phi> (w \\<rightarrow> v) = \\<phi> v \\<Longrightarrow>\n  fixespointwise ((\\<rightarrow>) w) C0\n\ngoal (1 subgoal):\n 1. fixespointwise ((\\<rightarrow>) w) C0", "by    fast"], ["proof (state)\nthis:\n  fixespointwise ((\\<rightarrow>) w) C0\n\ngoal (1 subgoal):\n 1. w = 0", "with assms(1)"], ["proof (chain)\npicking this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  fixespointwise ((\\<rightarrow>) w) C0", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  fixespointwise ((\\<rightarrow>) w) C0\n\ngoal (1 subgoal):\n 1. w = 0", "using fundchamber W_automorphism trivial_automorphism\n          standard_uniqueness_automorphs\n          permutation_inject[of w 0]"], ["proof (prove)\nusing this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  fixespointwise ((\\<rightarrow>) w) C0\n  chamber C0\n  ?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f\n                         g}\\<rangle> \\<Longrightarrow>\n  ChamberComplexAutomorphism X ((\\<rightarrow>) ?w)\n  ChamberComplexAutomorphism X id\n  \\<lbrakk>ChamberComplexAutomorphism X ?f; ChamberComplexAutomorphism X ?g;\n   chamber ?C; fun_eq_on ?f ?g ?C\\<rbrakk>\n  \\<Longrightarrow> ?f = ?g\n  ((\\<rightarrow>) w = (\\<rightarrow>) 0) = (w = 0)\n\ngoal (1 subgoal):\n 1. w = 0", "by    (auto simp add: zero_permutation.rep_eq)"], ["proof (state)\nthis:\n  w = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fundchamber_W_image_inj_on:\n  \"inj_on (\\<lambda>w. w`\\<rightarrow>C0) W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>w. w `\\<rightarrow> C0)\n     \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}\\<rangle>", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>;\n        y \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}\\<rangle>;\n        x `\\<rightarrow> C0 = y `\\<rightarrow> C0\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix w w'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>;\n        y \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}\\<rangle>;\n        x `\\<rightarrow> C0 = y `\\<rightarrow> C0\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume ww': \"w\\<in>W\" \"w'\\<in>W\" \"w`\\<rightarrow>C0 = w'`\\<rightarrow>C0\""], ["proof (state)\nthis:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  w' \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  w `\\<rightarrow> C0 = w' `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>;\n        y \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}\\<rangle>;\n        x `\\<rightarrow> C0 = y `\\<rightarrow> C0\\<rbrakk>\n       \\<Longrightarrow> x = y", "from ww'(3)"], ["proof (chain)\npicking this:\n  w `\\<rightarrow> C0 = w' `\\<rightarrow> C0", "have \"(-w')`\\<rightarrow>w`\\<rightarrow>C0 = (-w')`\\<rightarrow>w'`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  w `\\<rightarrow> C0 = w' `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (- w') `\\<rightarrow> w `\\<rightarrow> C0 =\n    (- w') `\\<rightarrow> w' `\\<rightarrow> C0", "by simp"], ["proof (state)\nthis:\n  (- w') `\\<rightarrow> w `\\<rightarrow> C0 =\n  (- w') `\\<rightarrow> w' `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>;\n        y \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}\\<rangle>;\n        x `\\<rightarrow> C0 = y `\\<rightarrow> C0\\<rbrakk>\n       \\<Longrightarrow> x = y", "with ww'(1,2)"], ["proof (chain)\npicking this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  w' \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  (- w') `\\<rightarrow> w `\\<rightarrow> C0 =\n  (- w') `\\<rightarrow> w' `\\<rightarrow> C0", "show \"w = w'\""], ["proof (prove)\nusing this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  w' \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  (- w') `\\<rightarrow> w `\\<rightarrow> C0 =\n  (- w') `\\<rightarrow> w' `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. w = w'", "using fundchamber_W_image_ker[of \"-w'+w\"] add.assoc[of w' \"-w'\" w]"], ["proof (prove)\nusing this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  w' \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  (- w') `\\<rightarrow> w `\\<rightarrow> C0 =\n  (- w') `\\<rightarrow> w' `\\<rightarrow> C0\n  \\<lbrakk>- w' + w\n           \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g}\\<rangle>;\n   (- w' + w) `\\<rightarrow> C0 = C0\\<rbrakk>\n  \\<Longrightarrow> - w' + w = 0\n  w' + - w' + w = w' + (- w' + w)\n\ngoal (1 subgoal):\n 1. w = w'", "by    (simp add:\n            image_comp plus_permutation.rep_eq[THEN sym]\n            zero_permutation.rep_eq genby_uminus_add_closed\n          )"], ["proof (state)\nthis:\n  w = w'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ThinChamberComplexManyFoldings *)"], ["", "subsubsection \\<open>A bijection between the fundamental chamber and the set of generating automorphisms\\<close>"], ["", "text \\<open>\n  Removing a single vertex from the fundamental chamber determines a facet, a facet in the\n  fundamental chamber determines an adjacent chamber (since our complex is thin), and a chamber\n  adjacent to the fundamental chamber determines an automorphism (via some pair of opposed foldings)\n  in our generating set @{term S}. Here we show that this correspondence is bijective.\n\\<close>"], ["", "context ThinChamberComplexManyFoldings\nbegin"], ["", "definition fundantivertex :: \"'a permutation \\<Rightarrow> 'a\"\n  where \"fundantivertex s \\<equiv> (THE v. v \\<in> C0-s`\\<rightarrow>C0)\""], ["", "abbreviation \"fundantipermutation \\<equiv> the_inv_into S fundantivertex\""], ["", "lemma fundantivertex: \"s\\<in>S \\<Longrightarrow> fundantivertex s \\<in> C0-s`\\<rightarrow>C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    fundantivertex s \\<in> C0 - s `\\<rightarrow> C0", "using fundchamber_S_adjacent[of s]\n        fundchamber_S_image_neq_fundchamber[of s]\n        fundantivertex_def[of s] theI'[OF adj_antivertex]"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<sim> s `\\<rightarrow> C0\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  s `\\<rightarrow> C0 \\<noteq> C0\n  fundantivertex s \\<equiv> THE v. v \\<in> C0 - s `\\<rightarrow> C0\n  \\<lbrakk>?x1 \\<sim> ?y1; ?x1 \\<noteq> ?y1\\<rbrakk>\n  \\<Longrightarrow> (THE x. x \\<in> ?x1 - ?y1) \\<in> ?x1 - ?y1\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    fundantivertex s \\<in> C0 - s `\\<rightarrow> C0", "by    auto"], ["", "lemma fundantivertex_fundchamber_decomp:\n  \"s\\<in>S \\<Longrightarrow> C0 = insert (fundantivertex s) (C0\\<inter>s`\\<rightarrow>C0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    C0 = insert (fundantivertex s) (C0 \\<inter> s `\\<rightarrow> C0)", "using fundchamber_S_adjacent[of s]\n        fundchamber_S_image_neq_fundchamber[of s]\n        fundantivertex[of s] adjacent_conv_insert[of C0]"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<sim> s `\\<rightarrow> C0\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  s `\\<rightarrow> C0 \\<noteq> C0\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  fundantivertex s \\<in> C0 - s `\\<rightarrow> C0\n  \\<lbrakk>C0 \\<sim> ?y; ?v \\<in> C0 - ?y\\<rbrakk>\n  \\<Longrightarrow> C0 = insert ?v (C0 \\<inter> ?y)\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    C0 = insert (fundantivertex s) (C0 \\<inter> s `\\<rightarrow> C0)", "by    auto"], ["", "lemma fundantivertex_unstable:\n  \"s\\<in>S \\<Longrightarrow> s \\<rightarrow> fundantivertex s \\<noteq> fundantivertex s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    s \\<rightarrow> fundantivertex s \\<noteq> fundantivertex s", "using fundantivertex_fundchamber_decomp[of s]\n          image_insert[of \"(\\<rightarrow>) s\" \"fundantivertex s\" \"C0\\<inter>s`\\<rightarrow>C0\"]\n          S_fixes_fundchamber_image_int fundchamber_S_image_neq_fundchamber"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 = insert (fundantivertex s) (C0 \\<inter> s `\\<rightarrow> C0)\n  s `\\<rightarrow>\n  insert (fundantivertex s) (C0 \\<inter> s `\\<rightarrow> C0) =\n  insert (s \\<rightarrow> fundantivertex s)\n   (s `\\<rightarrow> (C0 \\<inter> s `\\<rightarrow> C0))\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  ?s `\\<rightarrow> (C0 \\<inter> ?s `\\<rightarrow> C0) =\n  C0 \\<inter> ?s `\\<rightarrow> C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  ?s `\\<rightarrow> C0 \\<noteq> C0\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n    s \\<rightarrow> fundantivertex s \\<noteq> fundantivertex s", "by    fastforce"], ["", "lemma fundantivertex_inj_on: \"inj_on fundantivertex S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on fundantivertex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g});\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g});\n        fundantivertex x = fundantivertex y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix s t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g});\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g});\n        fundantivertex x = fundantivertex y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume st: \"s\\<in>S\" \"t\\<in>S\" \"fundantivertex s = fundantivertex t\""], ["proof (state)\nthis:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  fundantivertex s = fundantivertex t\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g});\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g});\n        fundantivertex x = fundantivertex y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"insert (fundantivertex s) (C0\\<inter>s`\\<rightarrow>C0) =\n          insert (fundantivertex s) (C0\\<inter>t`\\<rightarrow>C0)\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  fundantivertex s = fundantivertex t\n\ngoal (1 subgoal):\n 1. insert (fundantivertex s) (C0 \\<inter> s `\\<rightarrow> C0) =\n    insert (fundantivertex s) (C0 \\<inter> t `\\<rightarrow> C0)", "using fundantivertex_fundchamber_decomp[of s]\n          fundantivertex_fundchamber_decomp[of t]"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  fundantivertex s = fundantivertex t\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 = insert (fundantivertex s) (C0 \\<inter> s `\\<rightarrow> C0)\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 = insert (fundantivertex t) (C0 \\<inter> t `\\<rightarrow> C0)\n\ngoal (1 subgoal):\n 1. insert (fundantivertex s) (C0 \\<inter> s `\\<rightarrow> C0) =\n    insert (fundantivertex s) (C0 \\<inter> t `\\<rightarrow> C0)", "by    auto"], ["proof (state)\nthis:\n  insert (fundantivertex s) (C0 \\<inter> s `\\<rightarrow> C0) =\n  insert (fundantivertex s) (C0 \\<inter> t `\\<rightarrow> C0)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g});\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g});\n        fundantivertex x = fundantivertex y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  insert (fundantivertex s) (C0 \\<inter> s `\\<rightarrow> C0) =\n  insert (fundantivertex s) (C0 \\<inter> t `\\<rightarrow> C0)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g});\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g});\n        fundantivertex x = fundantivertex y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from st"], ["proof (chain)\npicking this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  fundantivertex s = fundantivertex t", "have  \"fundantivertex s \\<notin> C0\\<inter>s`\\<rightarrow>C0\" \"fundantivertex s \\<notin> C0\\<inter>t`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  fundantivertex s = fundantivertex t\n\ngoal (1 subgoal):\n 1. fundantivertex s \\<notin> C0 \\<inter> s `\\<rightarrow> C0 &&&\n    fundantivertex s \\<notin> C0 \\<inter> t `\\<rightarrow> C0", "using fundantivertex[of s] fundantivertex[of t]"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  fundantivertex s = fundantivertex t\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  fundantivertex s \\<in> C0 - s `\\<rightarrow> C0\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  fundantivertex t \\<in> C0 - t `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. fundantivertex s \\<notin> C0 \\<inter> s `\\<rightarrow> C0 &&&\n    fundantivertex s \\<notin> C0 \\<inter> t `\\<rightarrow> C0", "by    auto"], ["proof (state)\nthis:\n  fundantivertex s \\<notin> C0 \\<inter> s `\\<rightarrow> C0\n  fundantivertex s \\<notin> C0 \\<inter> t `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g});\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g});\n        fundantivertex x = fundantivertex y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  insert (fundantivertex s) (C0 \\<inter> s `\\<rightarrow> C0) =\n  insert (fundantivertex s) (C0 \\<inter> t `\\<rightarrow> C0)\n  fundantivertex s \\<notin> C0 \\<inter> s `\\<rightarrow> C0\n  fundantivertex s \\<notin> C0 \\<inter> t `\\<rightarrow> C0", "have \"C0\\<inter>s`\\<rightarrow>C0 = C0\\<inter>t`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  insert (fundantivertex s) (C0 \\<inter> s `\\<rightarrow> C0) =\n  insert (fundantivertex s) (C0 \\<inter> t `\\<rightarrow> C0)\n  fundantivertex s \\<notin> C0 \\<inter> s `\\<rightarrow> C0\n  fundantivertex s \\<notin> C0 \\<inter> t `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. C0 \\<inter> s `\\<rightarrow> C0 = C0 \\<inter> t `\\<rightarrow> C0", "using insert_subset_equality[of \"fundantivertex s\"]"], ["proof (prove)\nusing this:\n  insert (fundantivertex s) (C0 \\<inter> s `\\<rightarrow> C0) =\n  insert (fundantivertex s) (C0 \\<inter> t `\\<rightarrow> C0)\n  fundantivertex s \\<notin> C0 \\<inter> s `\\<rightarrow> C0\n  fundantivertex s \\<notin> C0 \\<inter> t `\\<rightarrow> C0\n  \\<lbrakk>fundantivertex s \\<notin> ?A; fundantivertex s \\<notin> ?B;\n   insert (fundantivertex s) ?A = insert (fundantivertex s) ?B\\<rbrakk>\n  \\<Longrightarrow> ?A = ?B\n\ngoal (1 subgoal):\n 1. C0 \\<inter> s `\\<rightarrow> C0 = C0 \\<inter> t `\\<rightarrow> C0", "by simp"], ["proof (state)\nthis:\n  C0 \\<inter> s `\\<rightarrow> C0 = C0 \\<inter> t `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g});\n        y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g});\n        fundantivertex x = fundantivertex y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with st(1,2)"], ["proof (chain)\npicking this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  C0 \\<inter> s `\\<rightarrow> C0 = C0 \\<inter> t `\\<rightarrow> C0", "show \"s=t\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  C0 \\<inter> s `\\<rightarrow> C0 = C0 \\<inter> t `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. s = t", "using fundchamber fundchamber_S_chamber[of s] fundchamber_S_chamber[of t]\n          fundfacets[of s] fundfacets(2)[of t]\n          fundchamber_S_image_neq_fundchamber[of s]\n          fundchamber_S_image_neq_fundchamber[of t]\n          facet_unique_other_chamber[of C0 \"C0\\<inter>s`\\<rightarrow>C0\" \"s`\\<rightarrow>C0\" \"t`\\<rightarrow>C0\"]\n          genby_genset_closed[of _ S]\n          inj_onD[OF fundchamber_W_image_inj_on, of s t]"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  C0 \\<inter> s `\\<rightarrow> C0 = C0 \\<inter> t `\\<rightarrow> C0\n  chamber C0\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  chamber (s `\\<rightarrow> C0)\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  chamber (t `\\<rightarrow> C0)\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<inter> s `\\<rightarrow> C0 \\<lhd> C0\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<inter> s `\\<rightarrow> C0 \\<lhd> s `\\<rightarrow> C0\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<inter> t `\\<rightarrow> C0 \\<lhd> t `\\<rightarrow> C0\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  s `\\<rightarrow> C0 \\<noteq> C0\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  t `\\<rightarrow> C0 \\<noteq> C0\n  \\<lbrakk>chamber C0; C0 \\<inter> s `\\<rightarrow> C0 \\<lhd> C0;\n   chamber (s `\\<rightarrow> C0);\n   C0 \\<inter> s `\\<rightarrow> C0 \\<lhd> s `\\<rightarrow> C0;\n   chamber (t `\\<rightarrow> C0);\n   C0 \\<inter> s `\\<rightarrow> C0 \\<lhd> t `\\<rightarrow> C0;\n   s `\\<rightarrow> C0 \\<noteq> C0; t `\\<rightarrow> C0 \\<noteq> C0\\<rbrakk>\n  \\<Longrightarrow> s `\\<rightarrow> C0 = t `\\<rightarrow> C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  ?s \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<lbrakk>s `\\<rightarrow> C0 = t `\\<rightarrow> C0;\n   s \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>;\n   t \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> s = t\n\ngoal (1 subgoal):\n 1. s = t", "by    auto"], ["proof (state)\nthis:\n  s = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fundantivertex_surj_on: \"fundantivertex ` S = C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fundantivertex `\n    (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) =\n    C0", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> fundantivertex `\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> C0\n 2. \\<And>x.\n       x \\<in> C0 \\<Longrightarrow>\n       x \\<in> fundantivertex `\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})", "show \"\\<And>v. v \\<in> fundantivertex ` S \\<Longrightarrow> v\\<in>C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> fundantivertex `\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g}) \\<Longrightarrow>\n       v \\<in> C0", "using fundantivertex"], ["proof (prove)\nusing this:\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  fundantivertex ?s \\<in> C0 - ?s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> fundantivertex `\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g}) \\<Longrightarrow>\n       v \\<in> C0", "by fast"], ["proof (state)\nthis:\n  ?v1\n  \\<in> fundantivertex `\n        (\\<Union>(f, g)\\<in>fundfoldpairs.\n            {Abs_induced_automorph f g}) \\<Longrightarrow>\n  ?v1 \\<in> C0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C0 \\<Longrightarrow>\n       x \\<in> fundantivertex `\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C0 \\<Longrightarrow>\n       x \\<in> fundantivertex `\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C0 \\<Longrightarrow>\n       x \\<in> fundantivertex `\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})", "assume v: \"v\\<in>C0\""], ["proof (state)\nthis:\n  v \\<in> C0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C0 \\<Longrightarrow>\n       x \\<in> fundantivertex `\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})", "define D where \"D = the_adj_chamber C0 (C0-{v})\""], ["proof (state)\nthis:\n  D = the_adj_chamber C0 (C0 - {v})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C0 \\<Longrightarrow>\n       x \\<in> fundantivertex `\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})", "with v"], ["proof (chain)\npicking this:\n  v \\<in> C0\n  D = the_adj_chamber C0 (C0 - {v})", "have \"D\\<in>fundadjset\""], ["proof (prove)\nusing this:\n  v \\<in> C0\n  D = the_adj_chamber C0 (C0 - {v})\n\ngoal (1 subgoal):\n 1. D \\<in> adjacentset C0 - {C0}", "using fundchamber facetrel_diff_vertex the_adj_chamber_adjacentset\n          the_adj_chamber_neq"], ["proof (prove)\nusing this:\n  v \\<in> C0\n  D = the_adj_chamber C0 (C0 - {v})\n  chamber C0\n  ?v \\<in> ?x \\<Longrightarrow> ?x - {?v} \\<lhd> ?x\n  \\<lbrakk>chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> the_adj_chamber ?C ?z \\<in> adjacentset ?C\n  \\<lbrakk>chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> the_adj_chamber ?C ?z \\<noteq> ?C\n\ngoal (1 subgoal):\n 1. D \\<in> adjacentset C0 - {C0}", "by    fastforce"], ["proof (state)\nthis:\n  D \\<in> adjacentset C0 - {C0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C0 \\<Longrightarrow>\n       x \\<in> fundantivertex `\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})", "from this"], ["proof (chain)\npicking this:\n  D \\<in> adjacentset C0 - {C0}", "obtain s where s: \"s\\<in>S\" \"D = s`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  D \\<in> adjacentset C0 - {C0}\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g});\n         D = s `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using fundadjset_eq_S_image"], ["proof (prove)\nusing this:\n  D \\<in> adjacentset C0 - {C0}\n  ?D \\<in> adjacentset C0 - {C0} \\<Longrightarrow>\n  \\<exists>s\\<in>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}.\n     ?D = s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g});\n         D = s `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  D = s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C0 \\<Longrightarrow>\n       x \\<in> fundantivertex `\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})", "with v D_def [abs_def]"], ["proof (chain)\npicking this:\n  v \\<in> C0\n  D \\<equiv> the_adj_chamber C0 (C0 - {v})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  D = s `\\<rightarrow> C0", "have \"fundantivertex s = v\""], ["proof (prove)\nusing this:\n  v \\<in> C0\n  D \\<equiv> the_adj_chamber C0 (C0 - {v})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  D = s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. fundantivertex s = v", "using     fundchamber fundchamber_S_adjacent\n              fundchamber_S_image_neq_fundchamber[of s]\n              facetrel_diff_vertex[of v C0]\n              the_adj_chamber_facet facetrel_def[of \"C0-{v}\" D]"], ["proof (prove)\nusing this:\n  v \\<in> C0\n  D \\<equiv> the_adj_chamber C0 (C0 - {v})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  D = s `\\<rightarrow> C0\n  chamber C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<sim> ?s `\\<rightarrow> C0\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  s `\\<rightarrow> C0 \\<noteq> C0\n  v \\<in> C0 \\<Longrightarrow> C0 - {v} \\<lhd> C0\n  \\<lbrakk>chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> ?z \\<lhd> the_adj_chamber ?C ?z\n  C0 - {v} \\<lhd> D \\<equiv>\n  \\<exists>va. va \\<notin> C0 - {v} \\<and> D = insert va (C0 - {v})\n\ngoal (1 subgoal):\n 1. fundantivertex s = v", "unfolding fundantivertex_def"], ["proof (prove)\nusing this:\n  v \\<in> C0\n  D \\<equiv> the_adj_chamber C0 (C0 - {v})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  D = s `\\<rightarrow> C0\n  chamber C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<sim> ?s `\\<rightarrow> C0\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  s `\\<rightarrow> C0 \\<noteq> C0\n  v \\<in> C0 \\<Longrightarrow> C0 - {v} \\<lhd> C0\n  \\<lbrakk>chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> ?z \\<lhd> the_adj_chamber ?C ?z\n  C0 - {v} \\<lhd> D \\<equiv>\n  \\<exists>va. va \\<notin> C0 - {v} \\<and> D = insert va (C0 - {v})\n\ngoal (1 subgoal):\n 1. (THE v. v \\<in> C0 - s `\\<rightarrow> C0) = v", "by        (force intro: the1_equality[OF adj_antivertex])"], ["proof (state)\nthis:\n  fundantivertex s = v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C0 \\<Longrightarrow>\n       x \\<in> fundantivertex `\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})", "with s(1)"], ["proof (chain)\npicking this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  fundantivertex s = v", "show \"v \\<in> fundantivertex ` S\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  fundantivertex s = v\n\ngoal (1 subgoal):\n 1. v \\<in> fundantivertex `\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "by fast"], ["proof (state)\nthis:\n  v \\<in> fundantivertex `\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fundantivertex_bij_betw: \"bij_betw fundantivertex S C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw fundantivertex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) C0", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on fundantivertex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) \\<and>\n    fundantivertex `\n    (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) =\n    C0", "using     fundantivertex_inj_on fundantivertex_surj_on"], ["proof (prove)\nusing this:\n  inj_on fundantivertex\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  fundantivertex `\n  (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) =\n  C0\n\ngoal (1 subgoal):\n 1. inj_on fundantivertex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) \\<and>\n    fundantivertex `\n    (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) =\n    C0", "by        fast"], ["", "lemma card_S_fundchamber: \"card S = card C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) =\n    card C0", "using bij_betw_same_card[OF fundantivertex_bij_betw]"], ["proof (prove)\nusing this:\n  card (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) =\n  card C0\n\ngoal (1 subgoal):\n 1. card (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) =\n    card C0", "by fast"], ["", "lemma card_S_chamber:\n  \"chamber C \\<Longrightarrow> card C = card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chamber C \\<Longrightarrow>\n    card C =\n    card (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "using fundchamber chamber_card[of C0 C] card_S_fundchamber"], ["proof (prove)\nusing this:\n  chamber C0\n  \\<lbrakk>chamber C0; chamber C\\<rbrakk> \\<Longrightarrow> card C0 = card C\n  card (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) =\n  card C0\n\ngoal (1 subgoal):\n 1. chamber C \\<Longrightarrow>\n    card C =\n    card (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "by auto"], ["", "lemma fundantipermutation1:\n  \"v\\<in>C0 \\<Longrightarrow> fundantipermutation v \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> C0 \\<Longrightarrow>\n    the_inv_into\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     fundantivertex v\n    \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "using fundantivertex_surj_on the_inv_into_into[OF fundantivertex_inj_on]"], ["proof (prove)\nusing this:\n  fundantivertex `\n  (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) =\n  C0\n  \\<lbrakk>?x \\<in> fundantivertex `\n                    (\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g});\n   order.greater_eq ?B\n    (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\\<rbrakk>\n  \\<Longrightarrow> the_inv_into\n                     (\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g})\n                     fundantivertex ?x\n                    \\<in> ?B\n\ngoal (1 subgoal):\n 1. v \\<in> C0 \\<Longrightarrow>\n    the_inv_into\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     fundantivertex v\n    \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "by blast"], ["", "end"], ["", "(* context ThinChamberComplexManyFoldings *)"], ["", "subsection \\<open>Thick chamber complexes\\<close>"], ["", "text \\<open>\n  A thick chamber complex is one in which every facet is a facet of at least three chambers.\n\\<close>"], ["", "locale ThickChamberComplex = ChamberComplex X\n  for X :: \"'a set set\"\n+ assumes thick:\n    \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow>\n      \\<exists>D E. D\\<in>X-{C} \\<and> z\\<lhd>D \\<and> E\\<in>X-{C,D} \\<and> z\\<lhd>E\"\nbegin"], ["", "definition some_third_chamber :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set\"\n  where \"some_third_chamber C D z \\<equiv> SOME E. E\\<in>X-{C,D} \\<and> z\\<lhd>E\""], ["", "lemma facet_ex_third_chamber: \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> \\<exists>E\\<in>X-{C,D}. z\\<lhd>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>E\\<in>X - {C, D}. z \\<lhd> E", "using thick[of C z]"], ["proof (prove)\nusing this:\n  \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>D E.\n                       D \\<in> X - {C} \\<and>\n                       z \\<lhd> D \\<and>\n                       E \\<in> X - {C, D} \\<and> z \\<lhd> E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>E\\<in>X - {C, D}. z \\<lhd> E", "by auto"], ["", "lemma some_third_chamberD_facet:\n  \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> z \\<lhd> some_third_chamber C D z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> z \\<lhd> some_third_chamber C D z", "using facet_ex_third_chamber[of C z D] someI_ex[of \"\\<lambda>E. E\\<in>X-{C,D} \\<and> z\\<lhd>E\"]\n        some_third_chamber_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E\\<in>X - {C, D}. z \\<lhd> E\n  \\<exists>x. x \\<in> X - {C, D} \\<and> z \\<lhd> x \\<Longrightarrow>\n  (SOME x. x \\<in> X - {C, D} \\<and> z \\<lhd> x) \\<in> X - {C, D} \\<and>\n  z \\<lhd> (SOME x. x \\<in> X - {C, D} \\<and> z \\<lhd> x)\n  some_third_chamber ?C ?D ?z \\<equiv>\n  SOME E. E \\<in> X - {?C, ?D} \\<and> ?z \\<lhd> E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> z \\<lhd> some_third_chamber C D z", "by    auto"], ["", "lemma some_third_chamberD_simplex:\n  \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> some_third_chamber C D z \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> some_third_chamber C D z \\<in> X", "using facet_ex_third_chamber[of C z D] someI_ex[of \"\\<lambda>E. E\\<in>X-{C,D} \\<and> z\\<lhd>E\"]\n        some_third_chamber_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E\\<in>X - {C, D}. z \\<lhd> E\n  \\<exists>x. x \\<in> X - {C, D} \\<and> z \\<lhd> x \\<Longrightarrow>\n  (SOME x. x \\<in> X - {C, D} \\<and> z \\<lhd> x) \\<in> X - {C, D} \\<and>\n  z \\<lhd> (SOME x. x \\<in> X - {C, D} \\<and> z \\<lhd> x)\n  some_third_chamber ?C ?D ?z \\<equiv>\n  SOME E. E \\<in> X - {?C, ?D} \\<and> ?z \\<lhd> E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> some_third_chamber C D z \\<in> X", "by    auto"], ["", "lemma some_third_chamberD_adj:\n  \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> C \\<sim> some_third_chamber C D z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> C \\<sim> some_third_chamber C D z", "using some_third_chamberD_facet"], ["proof (prove)\nusing this:\n  \\<lbrakk>chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> ?z \\<lhd> some_third_chamber ?C ?D ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> C \\<sim> some_third_chamber C D z", "by (fast intro: adjacentI)"], ["", "lemma chamber_some_third_chamber:\n  \"chamber C \\<Longrightarrow> z\\<lhd>C \\<Longrightarrow> chamber (some_third_chamber C D z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> chamber (some_third_chamber C D z)", "using chamber_adj some_third_chamberD_simplex some_third_chamberD_adj"], ["proof (prove)\nusing this:\n  \\<lbrakk>chamber ?C; ?D \\<in> X; ?C \\<sim> ?D\\<rbrakk>\n  \\<Longrightarrow> chamber ?D\n  \\<lbrakk>chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> some_third_chamber ?C ?D ?z \\<in> X\n  \\<lbrakk>chamber ?C; ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> ?C \\<sim> some_third_chamber ?C ?D ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n    \\<Longrightarrow> chamber (some_third_chamber C D z)", "by    fast"], ["", "lemma some_third_chamberD_ne:\n  assumes \"chamber C\" \"z\\<lhd>C\"\n  shows   \"some_third_chamber C D z \\<noteq> C\" \"some_third_chamber C D z \\<noteq> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. some_third_chamber C D z \\<noteq> C &&&\n    some_third_chamber C D z \\<noteq> D", "using   assms facet_ex_third_chamber[of C z D]\n          someI_ex[of \"\\<lambda>E. E\\<in>X-{C,D} \\<and> z\\<lhd>E\"] some_third_chamber_def"], ["proof (prove)\nusing this:\n  chamber C\n  z \\<lhd> C\n  \\<lbrakk>chamber C; z \\<lhd> C\\<rbrakk>\n  \\<Longrightarrow> \\<exists>E\\<in>X - {C, D}. z \\<lhd> E\n  \\<exists>x. x \\<in> X - {C, D} \\<and> z \\<lhd> x \\<Longrightarrow>\n  (SOME x. x \\<in> X - {C, D} \\<and> z \\<lhd> x) \\<in> X - {C, D} \\<and>\n  z \\<lhd> (SOME x. x \\<in> X - {C, D} \\<and> z \\<lhd> x)\n  some_third_chamber ?C ?D ?z \\<equiv>\n  SOME E. E \\<in> X - {?C, ?D} \\<and> ?z \\<lhd> E\n\ngoal (1 subgoal):\n 1. some_third_chamber C D z \\<noteq> C &&&\n    some_third_chamber C D z \\<noteq> D", "by      auto"], ["", "end"], ["", "(* context ThickChamberComplex *)"], ["", "end"], ["", "(* theory *)"]]}