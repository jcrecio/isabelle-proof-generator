{"file_name": "/home/qj213/afp-2021-10-22/thys/Buildings/Algebra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Buildings", "problem_names": ["lemma times2_conv_add: \"(j::nat) + j = 2*j\"", "lemma (in comm_semiring_1) odd_n0: \"odd m \\<Longrightarrow> m\\<noteq>0\"", "lemma (in semigroup_add) add_assoc4: \"a + b + c + d = a + (b + c + d)\"", "lemmas (in monoid_add) sum_list_map_cong =\n  arg_cong[OF map_cong, OF refl, of _ _ _ sum_list]", "lemma map_uminus_order2:\n  \"\\<forall>s\\<in>set ss. s+s=0 \\<Longrightarrow> map (uminus) ss = ss\"", "lemma uminus_sum_list: \"- sum_list as = sum_list (map uminus (rev as))\"", "lemma uminus_sum_list_order2:\n  \"\\<forall>s\\<in>set ss. s+s=0 \\<Longrightarrow> - sum_list ss = sum_list (rev ss)\"", "lemma permutation_eq_image: \"a `\\<rightarrow> A = a `\\<rightarrow> B \\<Longrightarrow> A=B\"", "lemma plus_permutation_abs_eq:\n  \"bij f \\<Longrightarrow> bij g \\<Longrightarrow>\n    Abs_permutation f + Abs_permutation g = Abs_permutation (f\\<circ>g)\"", "lemma minus_permutation_abs_eq:\n  \"bij f \\<Longrightarrow> bij g \\<Longrightarrow>\n    Abs_permutation f - Abs_permutation g = Abs_permutation (f \\<circ> the_inv g)\"", "lemmas nataction_2    = add_mult_translate.power2_eq_square", "lemmas nataction_Suc2 = add_mult_translate.power_Suc2", "lemma alternating_sum_list_conv_nataction:\n  \"sum_list (alternating_list (2*n) s t) = (s+t)+^n\"", "lemma nataction_add_flip: \"(a+b)+^(Suc n) = a + (b+a)+^n + b\"", "lemma (in group_add) nataction_add_eq0_flip:\n  assumes \"(a+b)+^n = 0\"\n  shows   \"(b+a)+^n = 0\"", "lemma add_order: \"a+^(add_order a) = 0\"", "lemma add_order_least: \"n>0 \\<Longrightarrow> a+^n = 0 \\<Longrightarrow> add_order a \\<le> n\"", "lemma add_order_equality:\n  \"\\<lbrakk> n>0; a+^n = 0; (\\<And>m. m>0 \\<Longrightarrow> a+^m = 0 \\<Longrightarrow> n\\<le>m) \\<rbrakk> \\<Longrightarrow>\n    add_order a = n\"", "lemma add_order0: \"add_order 0 = 1\"", "lemma add_order_gt0: \"(add_order a > 0) = (\\<exists>n>0. a+^n = 0)\"", "lemma add_order_eq0: \"add_order a = 0 \\<Longrightarrow> n>0 \\<Longrightarrow> a+^n \\<noteq> 0\"", "lemma less_add_order_eq_0:\n  assumes \"a+^k = 0\" \"k < add_order a\"\n  shows   \"k = 0\"", "lemma less_add_order_eq_0_contra: \"k>0 \\<Longrightarrow> k < add_order a \\<Longrightarrow> a+^k \\<noteq> 0\"", "lemma add_order_relator: \"add_order (a+^(add_order a)) = 1\"", "lemma sum_list_pair_relator_list: \"sum_list (pair_relator_list s t) = 0\"", "lemma add_order_add_eq1: \"add_order (s+t) = 1 \\<Longrightarrow> t = -s\"", "lemma add_order_add_sym: \"add_order (t+s) = add_order (s+t)\"", "lemma pair_relator_halflist_append:\n  \"pair_relator_halflist s t @ pair_relator_halflist2 s t = pair_relator_list s t\"", "lemma rev_pair_relator_list: \"rev (pair_relator_list s t) = pair_relator_list t s\"", "lemma pair_relator_halflist2_conv_rev_pair_relator_halflist:\n  \"pair_relator_halflist2 s t = rev (pair_relator_halflist t s)\"", "lemma length_sums: \"length (sums xs) = Suc (length xs)\"", "lemma sums_snoc: \"sums (xs@[x]) = sums xs @ [sum_list (xs@[x])]\"", "lemma sums_append2:\n  \"sums (xs@ys) = butlast (sums xs) @ map ((+) (sum_list xs)) (sums ys)\"", "lemma sums_Cons_conv_append_tl:\n  \"sums (x#xs) = 0 # x # map ((+) x) (tl (sums xs))\"", "lemma pullback_sums_map_middle2:\n  \"map F (sums xs) = ds@[d,e]@es \\<Longrightarrow>\n    \\<exists>as a bs. xs = as@[a]@bs \\<and> map F (sums as) = ds@[d] \\<and>\n      d = F (sum_list as) \\<and> e = F (sum_list (as@[a]))\"", "lemma pullback_sums_map_middle3:\n  \"map F (sums xs) = ds@[d,e,f]@fs \\<Longrightarrow>\n    \\<exists>as a b bs. xs = as@[a,b]@bs \\<and> d = F (sum_list as) \\<and>\n      e = F (sum_list (as@[a])) \\<and> f = F (sum_list (as@[a,b]))\"", "lemma pullback_sums_map_double_middle2:\n  assumes \"map F (sums xs) = ds@[d,e]@es@[f,g]@gs\"\n  shows   \"\\<exists>as a bs b cs. xs = as@[a]@bs@[b]@cs \\<and> d = F (sum_list as) \\<and>\n            e = F (sum_list (as@[a])) \\<and> f = F (sum_list (as@[a]@bs)) \\<and>\n            g = F (sum_list (as@[a]@bs@[b]))\"", "lemma (in group_add) uminus_sum_list_alternating_order2:\n  \"s+s=0 \\<Longrightarrow> t+t=0 \\<Longrightarrow> - sum_list (alternating_list n s t) =\n    sum_list (if even n then alternating_list n t s else alternating_list n s t)\"", "lemma alternating_order2_cancel_1left:\n  \"s+s=0 \\<Longrightarrow>\n    sum_list (s # (alternating_list (Suc n) s t)) = sum_list (alternating_list n t s)\"", "lemma alternating_order2_cancel_2left:\n  \"s+s=0 \\<Longrightarrow> t+t=0 \\<Longrightarrow>\n    sum_list (t # s # (alternating_list (Suc (Suc n)) s t)) =\n      sum_list (alternating_list n s t)\"", "lemma alternating_order2_even_cancel_right:\n  assumes st    : \"s+s=0\" \"t+t=0\"\n  and     even_n: \"even n\"\n  shows   \"m \\<le> n \\<Longrightarrow> sum_list (alternating_list n s t @ alternating_list m t s) =\n            sum_list (alternating_list (n-m) s t)\"", "lemma lconjby_add: \"lconjby (x+y) z = lconjby x (lconjby y z)\"", "lemma rconjby_add: \"rconjby (x+y) z = rconjby y (rconjby x z)\"", "lemma add_rconjby: \"rconjby x y + rconjby x z = rconjby x (y+z)\"", "lemma lconjby_uminus: \"lconjby x (-y) = - lconjby x y\"", "lemma rconjby_uminus: \"rconjby x (-y) = - rconjby x y\"", "lemma lconjby_rconjby: \"lconjby x (rconjby x y) = y\"", "lemma rconjby_lconjby: \"rconjby x (lconjby x y) = y\"", "lemma lconjby_inj: \"inj (lconjby x)\"", "lemma rconjby_inj: \"inj (rconjby x)\"", "lemma lconjby_surj: \"surj (lconjby x)\"", "lemma lconjby_bij: \"bij (lconjby x)\"", "lemma the_inv_lconjby: \"the_inv (lconjby x) = (rconjby x)\"", "lemma lconjby_eq_conv_rconjby_eq: \"w = lconjby x y \\<Longrightarrow> y = rconjby x w\"", "lemma rconjby_order2: \"s+s = 0 \\<Longrightarrow> rconjby x s + rconjby x s = 0\"", "lemma rconjby_order2_eq_lconjby:\n  assumes \"s+s=0\"\n  shows   \"rconjby s = lconjby s\"", "lemma lconjby_alternating_list_order2:\n  assumes \"s+s=0\" \"t+t=0\"\n  shows   \"lconjby (sum_list (alternating_list k s t)) (if even k then s else t) =\n            sum_list (alternating_list (Suc (2*k)) s t)\"", "lemma length_lconjseq: \"length (lconjseq xs) = length xs\"", "lemma lconjseq_snoc: \"lconjseq (xs@[x]) = lconjseq xs @ [lconjby (sum_list xs) x]\"", "lemma lconjseq_append:\n  \"lconjseq (xs@ys) = lconjseq xs @ (map (lconjby (sum_list xs)) (lconjseq ys))\"", "lemma lconjseq_alternating_order2_repeats':\n  fixes   s t :: 'a\n  defines altst: \"altst \\<equiv> \\<lambda>n. alternating_list n s t\"\n  and     altts: \"altts \\<equiv> \\<lambda>n. alternating_list n t s\"\n  assumes st   : \"s+s=0\" \"t+t=0\" \"(s+t)+^k = 0\"\n  shows   \"map (lconjby (sum_list (altst k)))\n            (lconjseq (if even k then altst m else altts m)) = lconjseq (altst m)\"", "lemma lconjseq_alternating_order2_repeats:\n  fixes   s t :: 'a and k :: nat\n  defines altst: \"altst \\<equiv> \\<lambda>n. alternating_list n s t\"\n  and     altts: \"altts \\<equiv> \\<lambda>n. alternating_list n t s\"\n  assumes st: \"s+s=0\" \"t+t=0\" \"(s+t)+^k = 0\"\n  shows   \"lconjseq (altst (2*k)) = lconjseq (altst k) @ lconjseq (altst k)\"", "lemma even_count_lconjseq_alternating_order2:\n  fixes   s t :: 'a\n  assumes \"s+s=0\" \"t+t=0\" \"(s+t)+^k = 0\"\n  shows   \"even (count_list (lconjseq (alternating_list (2*k) s t)) x)\"", "lemma order2_hd_in_lconjseq_deletion:\n  shows \"s+s=0 \\<Longrightarrow> s \\<in> set (lconjseq ss)\n            \\<Longrightarrow> \\<exists>as b bs. ss = as@[b]@bs \\<and> sum_list (s#ss) = sum_list (as@bs)\"", "lemmas signed_lconjactionD = signed_funaction_def[of lconjby]", "lemmas signed_rconjactionD = signed_funaction_def[of rconjby]", "lemma signed_lconjaction_fst: \"fst (signed_lconjaction s x) = lconjby s (fst x)\"", "lemma signed_lconjaction_rconjaction:\n  \"signed_lconjaction s (signed_rconjaction s x) = x\"", "lemma signed_rconjaction_by_order2_eq_lconjaction:\n  \"s+s=0 \\<Longrightarrow> signed_rconjaction s = signed_lconjaction s\"", "lemma inj_signed_lconjaction: \"inj (signed_lconjaction s)\"", "lemma surj_signed_lconjaction: \"surj (signed_lconjaction s)\"", "lemma bij_signed_lconjaction: \"bij (signed_lconjaction s)\"", "lemma the_inv_signed_lconjaction:\n  \"the_inv (signed_lconjaction s) = signed_rconjaction s\"", "lemma the_inv_signed_lconjaction_by_order2:\n  \"s+s=0 \\<Longrightarrow> the_inv (signed_lconjaction s) = signed_lconjaction s\"", "lemma signed_list_lconjaction_fst:\n  \"fst (signed_list_lconjaction ss x) = lconjby (sum_list ss) (fst x)\"", "lemma signed_list_lconjaction_snd:\n  shows \"\\<forall>s\\<in>set ss. s+s=0 \\<Longrightarrow> snd (signed_list_lconjaction ss x)\n          = (if even (count_list (lconjseq (rev ss)) (fst x)) then snd x else \\<not>snd x)\"", "lemma set_zero_plus' [simp]: \"(0::'a::monoid_add) +o C = C\"\n\\<comment> \\<open>lemma @{text \"Set_Algebras.set_zero_plus\"} is restricted to types of class\n@{class comm_monoid_add}; here is a version in @{class monoid_add}.\\<close>", "lemma lcoset_0: \"(w::'a::monoid_add) +o 0 = {w}\"", "lemma lcoset_refl: \"(0::'a::monoid_add) \\<in> A \\<Longrightarrow> a \\<in> a +o A\"", "lemma lcoset_eq_reps_subset: \n  \"(a::'a::group_add) +o A \\<subseteq> a +o B \\<Longrightarrow> A \\<subseteq> B\"", "lemma lcoset_eq_reps: \"(a::'a::group_add) +o A = a +o B \\<Longrightarrow> A = B\"", "lemma lcoset_inj_on: \"inj ((+o) (a::'a::group_add))\"", "lemma lcoset_conv_set: \"(a::'g::group_add) \\<in> b +o A \\<Longrightarrow> -b + a \\<in> A\"", "lemma supset_lbound_lcoset_shift:\n  \"supset_lbound_of X Y B \\<Longrightarrow>\n    ordering.lbound_of (\\<supseteq>) (a +o X) (a +o Y) (a +o B)\"", "lemma supset_glbound_in_of_lcoset_shift:\n  fixes   P :: \"'a::group_add set set\"\n  assumes \"supset_glbound_in_of P X Y B\"\n  shows   \"supset_glbound_in_of ((+o) a ` P) (a +o X) (a +o Y) (a +o B)\"", "lemma lcoset_relI: \"-x+y \\<in> A \\<Longrightarrow> (x,y) \\<in> lcoset_rel A\"", "lemma SubgroupD1: \"Subgroup H \\<Longrightarrow> Group H\"", "lemma zero_closed : \"0 \\<in> G\"", "lemma uminus_closed: \"g\\<in>G \\<Longrightarrow> -g\\<in>G\"", "lemma add_closed: \"g\\<in>G \\<Longrightarrow> h\\<in>G \\<Longrightarrow> g+h \\<in> G\"", "lemma uminus_add_closed: \"g \\<in> G \\<Longrightarrow> h \\<in> G \\<Longrightarrow> -g + h \\<in> G\"", "lemma lconjby_closed: \"g\\<in>G \\<Longrightarrow> x\\<in>G \\<Longrightarrow> lconjby g x \\<in> G\"", "lemma lconjby_set_closed: \"g\\<in>G \\<Longrightarrow> A\\<subseteq>G \\<Longrightarrow> lconjby g ` A \\<subseteq> G\"", "lemma set_lconjby_subset_closed:\n  \"H\\<subseteq>G \\<Longrightarrow> A\\<subseteq>G \\<Longrightarrow> (\\<Union>h\\<in>H. lconjby h ` A) \\<subseteq> G\"", "lemma sum_list_map_closed: \"set (map f as) \\<subseteq> G \\<Longrightarrow> (\\<Sum>a\\<leftarrow>as. f a) \\<in> G\"", "lemma sum_list_closed: \"set as \\<subseteq> G \\<Longrightarrow> sum_list as \\<in> G\"", "lemma unique_identity1: \"g\\<in>G \\<Longrightarrow> \\<forall>x\\<in>G. binop g x = x \\<Longrightarrow> g = e\"", "lemma unique_inverse:\n  assumes \"g\\<in>G\"\n  shows   \"\\<exists>!h. h\\<in>G \\<and> binop g h = e \\<and> binop h g = e\"", "lemma G_perm_comp:\n  \"g\\<in>G \\<Longrightarrow> h\\<in>G \\<Longrightarrow> G_perm g \\<circ> G_perm h = G_perm (binop g h)\"", "lemma the_inverseD:\n  assumes   \"g\\<in>G\"\n  shows     \"\\<ii> g \\<in> G\" \"binop g (\\<ii> g) = e\" \"binop (\\<ii> g) g = e\"", "lemma binop_G_comp_binop_\\<ii>G: \"g\\<in>G \\<Longrightarrow> x\\<in>G \\<Longrightarrow> binop g (binop (\\<ii> g) x) = x\"", "lemma bij_betw_binop_G:\n  assumes   \"g\\<in>G\"\n  shows     \"bij_betw (binop g) G G\"", "lemma the_inv_into_G_binop_G:\n  assumes \"g\\<in>G\" \"x\\<in>G\"\n  shows   \"the_inv_into G (binop g) x = binop (\\<ii> g) x\"", "lemma restrict1_the_inv_into_G_binop_G:\n  \"g\\<in>G \\<Longrightarrow> restrict1 (the_inv_into G (binop g)) G = G_perm (\\<ii> g)\"", "lemma bij_G_perm: \"g\\<in>G \\<Longrightarrow> bij (G_perm g)\"", "lemma G_perm_apply: \"g\\<in>G \\<Longrightarrow> x\\<in>G \\<Longrightarrow> \\<pp> g \\<rightarrow> x = binop g x\"", "lemma G_perm_apply_identity: \"g\\<in>G \\<Longrightarrow> \\<pp> g \\<rightarrow> e = g\"", "lemma the_inv_G_perm:\n  \"g\\<in>G \\<Longrightarrow> the_inv (G_perm g) = G_perm (\\<ii> g)\"", "lemma Abs_G_perm_diff:\n  \"g\\<in>G \\<Longrightarrow> h\\<in>G \\<Longrightarrow> \\<pp> g - \\<pp> h = \\<pp> (binop g (\\<ii> h))\"", "lemma Group: \"Group pG\"", "lemma inj_on_\\<pp>_G: \"inj_on \\<pp> G\"", "lemma homs:\n  \"\\<And>g h. g\\<in>G \\<Longrightarrow> h\\<in>G \\<Longrightarrow> \\<pp> (binop g h) = \\<pp> g + \\<pp> h\"\n  \"\\<And>x y. x\\<in>pG \\<Longrightarrow> y\\<in>pG \\<Longrightarrow> binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) = \\<ii>\\<pp> (x+y)\"", "lemmas inv_correspondence_into =\n  the_inv_into_into[OF inj_on_\\<pp>_G, of _ G, simplified]", "lemma inv_correspondence_conv_apply: \"x \\<in> pG \\<Longrightarrow> \\<ii>\\<pp> x = x\\<rightarrow>e\"", "lemma lcoset_refl: \"a \\<in> a +o G\"", "lemma lcoset_el_reduce:\n  assumes \"a \\<in> G\"\n  shows \"a +o G = G\"", "lemma lcoset_el_reduce0: \"0 \\<in> a +o G \\<Longrightarrow> a +o G = G\"", "lemma lcoset_subgroup_imp_eq_reps:\n  \"Group H \\<Longrightarrow> w +o H \\<subseteq> w' +o G \\<Longrightarrow> w' +o G = w +o G\"", "lemma lcoset_closed: \"a\\<in>G \\<Longrightarrow> A\\<subseteq>G \\<Longrightarrow> a +o A \\<subseteq> G\"", "lemma lcoset_rel_sym: \"sym (lcoset_rel G)\"", "lemma lcoset_rel_trans: \"trans (lcoset_rel G)\"", "lemma refl_on_LCoset_rel: \"0\\<in>H \\<Longrightarrow> refl_on G (LCoset_rel H)\"", "lemmas subgroup_refl_on_LCoset_rel =\n  refl_on_LCoset_rel[OF Group.zero_closed, OF SubgroupD1]", "lemmas LCoset_rel_quotientI        = quotientI[of _ G \"LCoset_rel _\"]", "lemmas LCoset_rel_quotientE        = quotientE[of _ G \"LCoset_rel _\"]", "lemma lcoset_subgroup_rel_equiv:\n  \"Subgroup H \\<Longrightarrow> equiv G (LCoset_rel H)\"", "lemma trivial_LCoset: \"H\\<subseteq>G \\<Longrightarrow> H = LCoset_rel H `` {0}\"", "lemma genby_Group: \"Group \\<langle>S\\<rangle>\"", "lemmas genby_uminus_closed             = Group.uminus_closed     [OF genby_Group]", "lemmas genby_add_closed                = Group.add_closed        [OF genby_Group]", "lemmas genby_uminus_add_closed         = Group.uminus_add_closed [OF genby_Group]", "lemmas genby_lcoset_refl               = Group.lcoset_refl       [OF genby_Group]", "lemmas genby_lcoset_el_reduce          = Group.lcoset_el_reduce  [OF genby_Group]", "lemmas genby_lcoset_el_reduce0         = Group.lcoset_el_reduce0 [OF genby_Group]", "lemmas genby_lcoset_closed             = Group.lcoset_closed     [OF genby_Group]", "lemmas genby_lcoset_subgroup_imp_eq_reps =\n  Group.lcoset_subgroup_imp_eq_reps[OF genby_Group, OF genby_Group]", "lemma genby_genset_subset: \"S \\<subseteq> \\<langle>S\\<rangle>\"", "lemma genby_uminus_genset_subset: \"uminus ` S \\<subseteq> \\<langle>S\\<rangle>\"", "lemma genby_in_sum_list_lists:\n  fixes   S\n  defines S_sum_lists: \"S_sum_lists \\<equiv> (\\<Union>ss\\<in>lists (S \\<union> uminus ` S). {sum_list ss})\"\n  shows   \"w \\<in> \\<langle>S\\<rangle> \\<Longrightarrow> w \\<in> S_sum_lists\"", "lemma sum_list_lists_in_genby: \"ss \\<in> lists (S \\<union> uminus ` S) \\<Longrightarrow> sum_list ss \\<in> \\<langle>S\\<rangle>\"", "lemma sum_list_lists_in_genby_sym:\n  \"uminus ` S \\<subseteq> S \\<Longrightarrow> ss \\<in> lists S \\<Longrightarrow> sum_list ss \\<in> \\<langle>S\\<rangle>\"", "lemma genby_eq_sum_lists: \"\\<langle>S\\<rangle> = (\\<Union>ss\\<in>lists (S \\<union> uminus ` S). {sum_list ss})\"", "lemma genby_mono: \"T \\<subseteq> S \\<Longrightarrow> \\<langle>T\\<rangle> \\<subseteq> \\<langle>S\\<rangle>\"", "lemma (in Group) genby_closed:\n  assumes \"S \\<subseteq> G\"\n  shows \"\\<langle>S\\<rangle> \\<subseteq> G\"", "lemma (in Group) genby_subgroup: \"S \\<subseteq> G \\<Longrightarrow> Subgroup \\<langle>S\\<rangle>\"", "lemma genby_sym_eq_sum_lists:\n  \"uminus ` S \\<subseteq> S \\<Longrightarrow> \\<langle>S\\<rangle> = (\\<Union>ss\\<in>lists S. {sum_list ss})\"", "lemma genby_empty': \"w \\<in> \\<langle>{}\\<rangle> \\<Longrightarrow> w = 0\"", "lemma genby_order2':\n  assumes \"s+s=0\"\n  shows   \"w \\<in> \\<langle>{s}\\<rangle> \\<Longrightarrow> w = 0 \\<or> w = s\"", "lemma genby_order2: \"s+s=0 \\<Longrightarrow> \\<langle>{s}\\<rangle> = {0,s}\"", "lemma genby_empty: \"\\<langle>{}\\<rangle> = 0\"", "lemma genby_lcoset_order2: \"s+s=0 \\<Longrightarrow> w +o \\<langle>{s}\\<rangle> = {w,w+s}\"", "lemma genby_lcoset_empty: \"(w::'a::group_add) +o \\<langle>{}\\<rangle> = {w}\"", "lemma (in Group) genby_set_lconjby_set_lconjby_closed:\n  fixes   A :: \"'g set\"\n  defines \"S \\<equiv> (\\<Union>g\\<in>G. lconjby g ` A)\"\n  assumes \"g\\<in>G\"\n  shows   \"x \\<in> \\<langle>S\\<rangle> \\<Longrightarrow> lconjby g x \\<in> \\<langle>S\\<rangle>\"", "lemma (in Group) genby_set_lconjby_set_rconjby_closed:\n  fixes   A :: \"'g set\"\n  defines \"S \\<equiv> (\\<Union>g\\<in>G. lconjby g ` A)\"\n  assumes \"g\\<in>G\" \"x \\<in> \\<langle>S\\<rangle>\"\n  shows   \"rconjby g x \\<in> \\<langle>S\\<rangle>\"", "lemma im_zero: \"T 0 = 0\"", "lemma im_uminus: \"T (- g) = - T g\"", "lemma im_uminus_add: \"g \\<in> G \\<Longrightarrow> g' \\<in> G \\<Longrightarrow> T (-g + g') = - T g + T g'\"", "lemma im_diff: \"g \\<in> G \\<Longrightarrow> g' \\<in> G \\<Longrightarrow> T (g - g') = T g - T g'\"", "lemma im_lconjby: \"x \\<in> G \\<Longrightarrow> g \\<in> G \\<Longrightarrow> T (lconjby x g) = lconjby (T x) (T g)\"", "lemma im_sum_list_map:\n  \"set (map f as) \\<subseteq> G \\<Longrightarrow> T (\\<Sum>a\\<leftarrow>as. f a) = (\\<Sum>a\\<leftarrow>as. T (f a))\"", "lemma comp:\n  assumes \"GroupHom H S\" \"T`G \\<subseteq> H\" \n  shows   \"GroupHom G (S \\<circ> T)\"", "lemma ker_subset_ker_restrict0: \"ker f \\<subseteq> ker (restrict0 f A)\"", "lemma uminus_add_in_Ker_eq_eq_im:\n  \"g\\<in>G \\<Longrightarrow> h\\<in>G \\<Longrightarrow> (-g + h \\<in> Ker) = (T g = T h)\"", "lemmas im_zero       = im_zero", "lemmas im_uminus     = im_uminus", "lemma hom: \"T (g+g') = T g + T g'\"", "lemma im_diff: \"T (g - g') = T g - T g'\"", "lemma im_lconjby: \"T (lconjby x g) = lconjby (T x) (T g)\"", "lemma restrict0:\n  assumes \"Group G\"\n  shows   \"GroupHom G (restrict0 T G)\"", "lemma UGroupHomI:\n  assumes \"\\<And>g g'. T (g + g') = T g + T g'\"\n  shows   \"UGroupHom T\"", "lemma (in GroupHom) isoI:\n  assumes \"\\<And>k. k\\<in>G \\<Longrightarrow> T k = 0 \\<Longrightarrow> k=0\"\n  shows   \"GroupIso G T\"", "lemma (in BinOpSetGroup) lift_hom:\n  fixes T :: \"'a \\<Rightarrow> 'b::group_add\"\n  assumes \"\\<forall>g\\<in>G. \\<forall>h\\<in>G. T (binop g h) = T g + T h\"\n  shows   \"GroupHom pG (lift_hom T)\"", "lemma rcoset_rel_conv_lcoset_rel:\n  \"rcoset_rel G = map_prod uminus uminus ` (lcoset_rel G)\"", "lemma rcoset_rel_sym: \"sym (rcoset_rel G)\"", "lemma normalI:\n  assumes   \"Group H\" \"\\<forall>g\\<in>G. \\<forall>h\\<in>H. \\<exists>h'\\<in>H. g+h = h'+g\"\n            \"\\<forall>g\\<in>G. \\<forall>h\\<in>H. \\<exists>h'\\<in>H. h+g = g+h'\"\n  shows     \"normal H\"", "lemma normal_lconjby_closed:\n  \"\\<lbrakk> Subgroup H; normal H; g\\<in>G; h\\<in>H \\<rbrakk> \\<Longrightarrow> lconjby g h \\<in> H\"", "lemma normal_rconjby_closed:\n  \"\\<lbrakk> Subgroup H; normal H; g\\<in>G; h\\<in>H \\<rbrakk> \\<Longrightarrow> rconjby g h \\<in> H\"", "lemma (in Group) normal_closure:\n  assumes \"A\\<subseteq>G\"\n  shows   \"normal (normal_closure A)\"", "lemma normal_quotient_add_well_defined:\n  assumes \"Subgroup H\" \"normal H\" \"g\\<in>G\" \"g'\\<in>G\"\n  shows   \"LCoset_rel H `` {g} + LCoset_rel H `` {g'} = LCoset_rel H `` {g+g'}\"", "lemma BinOpSetGroup_normal_quotient:\n  assumes \"Subgroup H\" \"normal H\"\n  shows   \"BinOpSetGroup (quotient_set H) (+) H\"", "lemmas lcoset_perm_def =\n  BinOpSetGroup.Abs_G_perm_def[OF BinOpSetGroup_normal_quotient]", "lemmas lcoset_perm_comp =\n  BinOpSetGroup.G_perm_comp[OF BinOpSetGroup_normal_quotient]", "lemmas bij_lcoset_perm =\n  BinOpSetGroup.bij_G_perm[OF BinOpSetGroup_normal_quotient]", "lemma trivial_lcoset_perm:\n  assumes \"Subgroup H\" \"normal H\" \"h\\<in>H\"\n  shows   \"restrict1 ((+) (LCoset_rel H `` {h})) (quotient_set H) = id\"", "theorem quotient_group:\n  \"Subgroup H \\<Longrightarrow> normal H \\<Longrightarrow> Group (quotient_group H)\"", "lemma natural_quotient_hom:\n  \"Subgroup H \\<Longrightarrow> normal H \\<Longrightarrow> GroupHom G (natural_quotient_hom H)\"", "lemma natural_quotient_hom_image:\n  \"natural_quotient_hom H ` G = quotient_group H\"", "lemma quotient_group_UN: \"quotient_group H = (\\<lambda>g. \\<lceil>g|H\\<rceil>) ` G\"", "lemma quotient_identity_rule: \"\\<lbrakk> Subgroup H; normal H; h\\<in>H \\<rbrakk> \\<Longrightarrow> \\<lceil>h|H\\<rceil> = 0\"", "lemma quotient_group_lift_to_quotient_set:\n  \"\\<lbrakk> Subgroup H; normal H; g\\<in>G \\<rbrakk> \\<Longrightarrow> (\\<lceil>g|H\\<rceil>) \\<rightarrow> H = LCoset_rel H `` {g}\"", "lemma respects_Ker_lcosets: \"H \\<subseteq> Ker \\<Longrightarrow> T respects (LCoset_rel H)\"", "lemmas normal_subgroup_quotientfun_classrep_equality =\n  quotientfun_classrep_equality[\n    OF subgroup_refl_on_LCoset_rel, OF _ respects_Ker_lcosets\n  ]", "lemma quotient_hom_im:\n  \"\\<lbrakk> Subgroup H; normal H; H \\<subseteq> Ker; g\\<in>G \\<rbrakk> \\<Longrightarrow> quotient_hom H (\\<lceil>g|H\\<rceil>) = T g\"", "lemma quotient_hom:\n  assumes \"Subgroup H\" \"normal H\" \"H \\<subseteq> Ker\"\n  shows   \"GroupHom (quotient_group H) (quotient_hom H)\"", "lemma flip_signed_order2: \"flip_signed (flip_signed x) = x\"", "lemma map_charpair_uniform:\n  \"ss\\<in>lists S \\<Longrightarrow> map (charpair S) ss = map pairtrue ss\"", "lemma fst_set_map_charpair_un_uminus:\n  fixes ss :: \"'a::group_add list\"\n  shows \"ss\\<in>lists (S \\<union> uminus ` S) \\<Longrightarrow> fst ` set (map (charpair S) ss) \\<subseteq> S\"", "lemma proper_map_flip_signed:\n  \"proper_signed_list xs \\<Longrightarrow> proper_signed_list (map flip_signed xs)\"", "lemma proper_rev_map_flip_signed:\n  \"proper_signed_list xs \\<Longrightarrow> proper_signed_list (rev (map flip_signed xs))\"", "lemma uniform_snd_imp_proper_signed_list:\n  \"snd ` set xs \\<subseteq> {b} \\<Longrightarrow> proper_signed_list xs\"", "lemma proper_signed_list_map_uniform_snd:\n  \"proper_signed_list (map (\\<lambda>s. (s,b)) as)\"", "lemma proper_prappend_signed_list:\n  \"proper_signed_list xs \\<Longrightarrow> proper_signed_list ys\n    \\<Longrightarrow> proper_signed_list (prappend_signed_list xs ys)\"", "lemma fully_prappend_signed_list:\n  \"prappend_signed_list (rev (map flip_signed xs)) xs = []\"", "lemma prappend_signed_list_single_Cons:\n  \"prappend_signed_list [x] (y#ys) = (if y = flip_signed x then ys else x#y#ys)\"", "lemma prappend_signed_list_map_uniform_snd:\n  \"prappend_signed_list (map (\\<lambda>s. (s,b)) xs) (map (\\<lambda>s. (s,b)) ys) =\n    map (\\<lambda>s. (s,b)) xs @ map (\\<lambda>s. (s,b)) ys\"", "lemma prappend_signed_list_assoc_conv_snoc2Cons:\n  assumes \"proper_signed_list (xs@[y])\" \"proper_signed_list (y#ys)\"\n  shows   \"prappend_signed_list (xs@[y]) ys = prappend_signed_list xs (y#ys)\"", "lemma prappend_signed_list_assoc:\n  \"\\<lbrakk> proper_signed_list xs; proper_signed_list ys; proper_signed_list zs \\<rbrakk> \\<Longrightarrow>\n    prappend_signed_list (prappend_signed_list xs ys) zs =\n      prappend_signed_list xs (prappend_signed_list ys zs)\"", "lemma fst_set_prappend_signed_list:\n  \"fst ` set (prappend_signed_list xs ys) \\<subseteq> fst ` (set xs \\<union> set ys)\"", "lemma collapse_flipped_signed:\n  \"prappend_signed_list [(s,b)] [(s,\\<not>b)] = []\"", "lemma Abs_freeword_Cons:\n  assumes \"proper_signed_list (x#xs)\"\n  shows \"Abs_freeword (x#xs) = Abs_freeword [x] + Abs_freeword xs\"", "lemma Abs_freelist_Cons: \"Abs_freelist (x#xs) = Abs_freeletter x + Abs_freelist xs\"", "lemma plus_freeword_abs_eq:\n  \"proper_signed_list xs \\<Longrightarrow> proper_signed_list ys \\<Longrightarrow>\n    Abs_freeword xs + Abs_freeword ys = Abs_freeword (prappend_signed_list xs ys)\"", "lemma Abs_freeletter_add: \"s [+] t = Abs_freelist [s,t]\"", "lemma uminus_freeword_Abs_eq:\n  \"proper_signed_list xs \\<Longrightarrow>\n    - Abs_freeword xs = Abs_freeword (rev (map flip_signed xs))\"", "lemma uminus_Abs_freeword_singleton:\n  \"- Abs_freeword [(s,b)] = Abs_freeword [(s,\\<not> b)]\"", "lemma Abs_freeword_append_uniform_snd:\n  \"Abs_freeword (map (\\<lambda>s. (s,b)) (xs@ys)) =\n    Abs_freeword (map (\\<lambda>s. (s,b)) xs) + Abs_freeword (map (\\<lambda>s. (s,b)) ys)\"", "lemmas Abs_freelist_append = Abs_freeword_append_uniform_snd[of True]", "lemma Abs_freelist_append_append:\n  \"Abs_freelist (xs@ys@zs) = Abs_freelist xs + Abs_freelist ys + Abs_freelist zs\"", "lemma Abs_freelist_inverse: \"freeword (Abs_freelist as) = map pairtrue as\"", "lemma Abs_freeword_singleton_conv_apply_sign_freeletter:\n  \"Abs_freeword [x] = apply_sign Abs_freeletter x\"", "lemma Abs_freeword_conv_freeletter_sum_list:\n  \"proper_signed_list xs \\<Longrightarrow>\n    Abs_freeword xs = (\\<Sum>x\\<leftarrow>xs. apply_sign Abs_freeletter x)\"", "lemma freeword_conv_freeletter_sum_list:\n  \"x = (\\<Sum>s\\<leftarrow>freeword x. apply_sign Abs_freeletter s)\"", "lemma Abs_freeletter_prod_conv_Abs_freeword:\n  \"snd x \\<Longrightarrow> Abs_freeletter (fst x) = Abs_freeword [x]\"", "lemma extend_map_to_freeword_hom':\n  fixes   f :: \"'a \\<Rightarrow> 'b::group_add\"\n  defines h: \"h::'a signed \\<Rightarrow> 'b \\<equiv> \\<lambda>(s,b). if b then f s else - (f s)\"\n  defines g: \"g::'a signed list \\<Rightarrow> 'b \\<equiv> \\<lambda>xs. sum_list (map h xs)\"\n  shows   \"g (prappend_signed_list xs ys) = g xs + g ys\"", "lemma extend_map_to_freeword_hom1:\n  fixes   f :: \"'a \\<Rightarrow> 'b::group_add\"\n  defines \"h::'a signed \\<Rightarrow> 'b \\<equiv> \\<lambda>(s,b). if b then f s else - (f s)\"\n  defines \"g::'a freeword \\<Rightarrow> 'b \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\"\n  shows   \"g (Abs_freeletter s) = f s\"", "lemma extend_map_to_freeword_hom2:\n  fixes   f :: \"'a \\<Rightarrow> 'b::group_add\"\n  defines \"h::'a signed \\<Rightarrow> 'b \\<equiv> \\<lambda>(s,b). if b then f s else - (f s)\"\n  defines \"g::'a freeword \\<Rightarrow> 'b \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\"\n  shows   \"UGroupHom g\"", "lemma uniqueness_of_extended_map_to_freeword_hom':\n  fixes   f :: \"'a \\<Rightarrow> 'b::group_add\"\n  defines h: \"h::'a signed \\<Rightarrow> 'b \\<equiv> \\<lambda>(s,b). if b then f s else - (f s)\"\n  defines g: \"g::'a signed list \\<Rightarrow> 'b \\<equiv> \\<lambda>xs. sum_list (map h xs)\"\n  assumes singles: \"\\<And>s. k [(s,True)] = f s\"\n  and     adds   : \"\\<And>xs ys. proper_signed_list xs \\<Longrightarrow> proper_signed_list ys\n            \\<Longrightarrow> k (prappend_signed_list xs ys) = k xs + k ys\"\n  shows   \"proper_signed_list xs \\<Longrightarrow> k xs = g xs\"", "lemma uniqueness_of_extended_map_to_freeword_hom:\n  fixes   f :: \"'a \\<Rightarrow> 'b::group_add\"\n  defines \"h::'a signed \\<Rightarrow> 'b \\<equiv> \\<lambda>(s,b). if b then f s else - (f s)\"\n  defines \"g::'a freeword \\<Rightarrow> 'b \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\"\n  assumes k: \"k \\<circ> Abs_freeletter = f\" \"UGroupHom k\"\n  shows   \"k = g\"", "theorem universal_property:\n  fixes f :: \"'a \\<Rightarrow> 'b::group_add\"\n  shows \"\\<exists>!g::'a freeword\\<Rightarrow>'b. g \\<circ> Abs_freeletter = f \\<and> UGroupHom g\"", "lemma additive_freeword_funlift: \"UGroupHom (freeword_funlift f)\"", "lemma freeword_funlift_Abs_freeletter: \"freeword_funlift f (Abs_freeletter s) = f s\"", "lemmas freeword_funlift_add         = UGroupHom.hom        [OF additive_freeword_funlift]", "lemmas freeword_funlift_0           = UGroupHom.im_zero    [OF additive_freeword_funlift]", "lemmas freeword_funlift_uminus      = UGroupHom.im_uminus  [OF additive_freeword_funlift]", "lemmas freeword_funlift_diff        = UGroupHom.im_diff    [OF additive_freeword_funlift]", "lemmas freeword_funlift_lconjby     = UGroupHom.im_lconjby [OF additive_freeword_funlift]", "lemma freeword_funlift_uminus_Abs_freeletter:\n  \"freeword_funlift f (Abs_freeword [(s,False)]) = - f s\"", "lemma freeword_funlift_Abs_freeword_singleton:\n  \"freeword_funlift f (Abs_freeword [x]) = apply_sign f x\"", "lemma freeword_funlift_Abs_freeword_Cons:\n  assumes \"proper_signed_list (x#xs)\"\n  shows   \"freeword_funlift f (Abs_freeword (x#xs)) =\n            apply_sign f x + freeword_funlift f (Abs_freeword xs)\"", "lemma freeword_funlift_Abs_freeword:\n  \"proper_signed_list xs \\<Longrightarrow> freeword_funlift f (Abs_freeword xs) =\n    (\\<Sum>x\\<leftarrow>xs. apply_sign f x)\"", "lemma freeword_funlift_Abs_freelist:\n  \"freeword_funlift f (Abs_freelist xs) = (\\<Sum>x\\<leftarrow>xs. f x)\"", "lemma freeword_funlift_im':\n  \"proper_signed_list xs \\<Longrightarrow> fst ` set xs \\<subseteq> S \\<Longrightarrow>\n    freeword_funlift f (Abs_freeword xs) \\<in> \\<langle>f`S\\<rangle>\"", "lemma FreeGroupI_transfer:\n  \"proper_signed_list xs \\<Longrightarrow> fst ` set xs \\<subseteq> S \\<Longrightarrow> Abs_freeword xs \\<in> FreeGroup S\"", "lemma FreeGroupD: \"x \\<in> FreeGroup S \\<Longrightarrow> fst ` set (freeword x) \\<subseteq> S\"", "lemma FreeGroupD_transfer:\n  \"proper_signed_list xs \\<Longrightarrow> Abs_freeword xs \\<in> FreeGroup S \\<Longrightarrow> fst ` set xs \\<subseteq> S\"", "lemma FreeGroupD_transfer':\n  \"Abs_freelist xs \\<in> FreeGroup S \\<Longrightarrow> xs \\<in> lists S\"", "lemma FreeGroup_0_closed: \"0 \\<in> FreeGroup S\"", "lemma FreeGroup_diff_closed:\n  assumes \"x \\<in> FreeGroup S\" \"y \\<in> FreeGroup S\"\n  shows   \"x-y \\<in> FreeGroup S\"", "lemma FreeGroup_Group: \"Group (FreeGroup S)\"", "lemmas FreeGroup_add_closed    = Group.add_closed    [OF FreeGroup_Group]", "lemmas FreeGroup_uminus_closed = Group.uminus_closed [OF FreeGroup_Group]", "lemmas FreeGroup_genby_set_lconjby_set_rconjby_closed =\n  Group.genby_set_lconjby_set_rconjby_closed[OF FreeGroup_Group]", "lemma Abs_freelist_in_FreeGroup: \"ss \\<in> lists S \\<Longrightarrow> Abs_freelist ss \\<in> FreeGroup S\"", "lemma Abs_freeletter_in_FreeGroup_iff: \"(Abs_freeletter s \\<in> FreeGroup S) = (s\\<in>S)\"", "lemma freeword_funlift_im: \"x \\<in> FreeGroup S \\<Longrightarrow> freeword_funlift f x \\<in> \\<langle>f ` S\\<rangle>\"", "lemma freeword_funlift_surj':\n  \"ys \\<in> lists (f`S \\<union> uminus`f`S) \\<Longrightarrow> sum_list ys \\<in> freeword_funlift f ` FreeGroup S\"", "lemma freeword_funlift_surj:\n  fixes f :: \"'a \\<Rightarrow> 'b::group_add\"\n  shows \"freeword_funlift f ` FreeGroup S = \\<langle>f`S\\<rangle>\"", "lemma hom_restrict0_freeword_funlift:\n  \"GroupHom (FreeGroup S) (res_freeword_funlift f S)\"", "lemma uniqueness_of_restricted_lift:\n  assumes \"GroupHom (FreeGroup S) T\" \"\\<forall>s\\<in>S. T (Abs_freeletter s) = f s\"\n  shows   \"T = res_freeword_funlift f S\"", "theorem FreeGroup_universal_property:\n  fixes f :: \"'a \\<Rightarrow> 'b::group_add\"\n  shows \"\\<exists>!T::'a freeword\\<Rightarrow>'b. (\\<forall>s\\<in>S. T (Abs_freeletter s) = f s) \\<and>\n          GroupHom (FreeGroup S) T\"", "lemmas G_UN = Group.quotient_group_UN[OF FreeGroup_Group, of S Q]", "lemma P'_FreeS: \"P' \\<subseteq> FreeGroup S\"", "lemma relators: \"P' \\<subseteq> Q\"", "lemmas lconjby_P'_FreeS =\n  Group.set_lconjby_subset_closed[\n    OF FreeGroup_Group _ P'_FreeS, OF basic_monos(1)\n  ]", "lemmas Q_FreeS =\n  Group.genby_closed[OF FreeGroup_Group lconjby_P'_FreeS]", "lemmas Q_subgroup_FreeS =\n  Group.genby_subgroup[OF FreeGroup_Group lconjby_P'_FreeS]", "lemmas normal_Q = Group.normal_closure[OF FreeGroup_Group, OF P'_FreeS]", "lemmas natural_hom =\n  Group.natural_quotient_hom[\n    OF FreeGroup_Group Q_subgroup_FreeS normal_Q\n  ]", "lemmas natural_hom_image =\n  Group.natural_quotient_hom_image[OF FreeGroup_Group, of S Q]", "lemma lift_f_trivial_P': \"p\\<in>P' \\<Longrightarrow> lift_f p = 0\"", "lemma lift_f_trivial_lconjby_P': \"p\\<in>P' \\<Longrightarrow> lift_f (lconjby w p) = 0\"", "lemma lift_f_trivial_Q: \"q\\<in>Q \\<Longrightarrow> lift_f q = 0\"", "lemma lift_f_ker_Q: \"Q \\<subseteq> ker lift_f\"", "lemma lift_f_Ker_Q: \"Q \\<subseteq> GroupHom.Ker (FreeGroup S) lift_f\"", "lemma restrict0_lift_f_Ker_Q:\n  \"Q \\<subseteq> GroupHom.Ker (FreeGroup S) (restrict0 lift_f (FreeGroup S))\"", "lemma induced_hom_equality:\n  \"w \\<in> FreeGroup S \\<Longrightarrow> F (\\<lceil>FreeGroup S|w|Q\\<rceil>) = lift_f w\"\n\\<comment> \\<open>algebraic properties of the induced homomorphism could be proved using its properties as a group\n  homomorphism, but it's generally easier to prove them using the algebraic properties of the lift\n  via this lemma\\<close>", "lemma hom_induced_hom: \"GroupHom G F\"", "lemma induced_hom_Abs_freeletter_equality:\n  \"s\\<in>S \\<Longrightarrow> F (\\<lceil>FreeGroup S|Abs_freeletter s|Q\\<rceil>) = f s\"", "lemma uniqueness_of_induced_hom':\n  defines \"q \\<equiv> Group.natural_quotient_hom (FreeGroup S) Q\"\n  assumes \"GroupHom G T\" \"\\<forall>s\\<in>S. T (\\<lceil>FreeGroup S|Abs_freeletter s|Q\\<rceil>) = f s\"\n  shows   \"T \\<circ> q = F \\<circ> q\"", "lemma uniqueness_of_induced_hom:\n  assumes \"GroupHom G T\" \"\\<forall>s\\<in>S. T (\\<lceil>FreeGroup S|Abs_freeletter s|Q\\<rceil>) = f s\"\n  shows   \"T = F\"", "theorem induced_hom_universal_property:\n  \"\\<exists>!F. GroupHom G F \\<and> (\\<forall>s\\<in>S. F (\\<lceil>FreeGroup S|Abs_freeletter s|Q\\<rceil>) = f s)\"", "lemma induced_hom_Abs_freelist_conv_sum_list:\n  \"ss\\<in>lists S \\<Longrightarrow> F (\\<lceil>FreeGroup S|Abs_freelist ss|Q\\<rceil>) = (\\<Sum>s\\<leftarrow>ss. f s)\"", "lemma induced_hom_surj: \"F`G = \\<langle>f`S\\<rangle>\"", "lemma GroupByPresentation_S_P: \"GroupByPresentation S P\"", "lemmas G_UN     = GroupByPresentation.G_UN[OF GroupByPresentation_S_P]", "lemmas P'_FreeS = GroupByPresentation.P'_FreeS[OF GroupByPresentation_S_P]", "lemma freeliftid_trivial_relator_freeword_R:\n  \"rs\\<in>R \\<Longrightarrow> freeliftid (relator_freeword rs) = 0\"", "lemma freeliftid_trivial_P: \"ps\\<in>P \\<Longrightarrow> freeliftid (Abs_freeword ps) = 0\"", "lemma GroupByPresentationInducedFun_S_P_id:\n  \"GroupByPresentationInducedFun S P id\"", "lemma induced_id_Abs_freelist_conv_sum_list:\n  \"ss\\<in>lists S \\<Longrightarrow> induced_id (\\<lceil>FreeGroup S|Abs_freelist ss|Q\\<rceil>) = sum_list ss\"", "lemma lconj_relator_freeword_R:\n  \"\\<lbrakk> rs\\<in>R; proper_signed_list xs; fst ` set xs \\<subseteq> S \\<rbrakk> \\<Longrightarrow>\n    lconjby (Abs_freeword xs) (relator_freeword rs) \\<in> Q\"", "lemma rconj_relator_freeword:\n  assumes \"rs\\<in>R\" \"proper_signed_list xs\" \"fst ` set xs \\<subseteq> S\"\n  shows   \"rconjby (Abs_freeword xs) (relator_freeword rs) \\<in> Q\"", "lemma lconjby_Abs_freelist_relator_freeword:\n  \"\\<lbrakk> rs\\<in>R; xs\\<in>lists S \\<rbrakk> \\<Longrightarrow> lconjby (Abs_freelist xs) (relator_freeword rs) \\<in> Q\"", "theorem induced_id_hom_surj: \"GroupHom G induced_id\" \"induced_id ` G = \\<langle>S\\<rangle>\"", "lemma inv_induced_id_sum_list_S:\n  \"ss \\<in> lists S \\<Longrightarrow> inv_induced_id (sum_list ss) = (\\<lceil>FreeGroup S|Abs_freelist ss|Q\\<rceil>)\"", "lemma reduced_word_forI:\n  assumes   \"as \\<in> lists A\" \"sum_list as = a\"\n            \"\\<And>bs. bs \\<in> lists A \\<Longrightarrow> sum_list bs = a \\<Longrightarrow> length as \\<le> length bs\"\n  shows     \"reduced_word_for A a as\"", "lemma reduced_word_forI_compare:\n  \"\\<lbrakk> reduced_word_for A a as; bs \\<in> lists A; sum_list bs = a; length bs = length as \\<rbrakk>\n    \\<Longrightarrow> reduced_word_for A a bs\"", "lemma reduced_word_for_lists: \"reduced_word_for A a as \\<Longrightarrow> as \\<in> lists A\"", "lemma reduced_word_for_sum_list: \"reduced_word_for A a as \\<Longrightarrow> sum_list as = a\"", "lemma reduced_word_for_minimal:\n  \"\\<lbrakk> reduced_word_for A a as; bs \\<in> lists A; sum_list bs = a \\<rbrakk> \\<Longrightarrow>\n    length as \\<le> length bs\"", "lemma reduced_word_for_length:\n  \"reduced_word_for A a as \\<Longrightarrow> length as = word_length A a\"", "lemma reduced_word_for_eq_length:\n  \"reduced_word_for A a as \\<Longrightarrow> reduced_word_for A a bs \\<Longrightarrow> length as = length bs\"", "lemma reduced_word_for_arg_min:\n  \"as \\<in> lists A \\<Longrightarrow> sum_list as = a \\<Longrightarrow>\n    reduced_word_for A a (arg_min length (word_for A a))\"", "lemma nil_reduced_word_for_0: \"reduced_word_for A 0 []\"", "lemma reduced_word_for_0_imp_nil: \"reduced_word_for A 0 as \\<Longrightarrow> as = []\"", "lemma not_reduced_word_for:\n  \"\\<lbrakk> bs \\<in> lists A; sum_list bs = a; length bs < length as \\<rbrakk> \\<Longrightarrow>\n    \\<not> reduced_word_for A a as\"", "lemma reduced_word_for_imp_reduced_word:\n  \"reduced_word_for A a as \\<Longrightarrow> reduced_word A as\"", "lemma sum_list_zero_nreduced:\n  \"as \\<noteq> [] \\<Longrightarrow> sum_list as = 0 \\<Longrightarrow> \\<not> reduced_word A as\"", "lemma order2_nreduced: \"a+a=0 \\<Longrightarrow> \\<not> reduced_word A [a,a]\"", "lemma reduced_word_append_reduce_contra1:\n  assumes \"\\<not> reduced_word A as\"\n  shows   \"\\<not> reduced_word A (as@bs)\"", "lemma reduced_word_append_reduce_contra2:\n  assumes \"\\<not> reduced_word A bs\"\n  shows   \"\\<not> reduced_word A (as@bs)\"", "lemma contains_nreduced_imp_nreduced:\n  \"\\<not> reduced_word A bs \\<Longrightarrow> \\<not> reduced_word A (as@bs@cs)\"", "lemma contains_order2_nreduced: \"a+a=0 \\<Longrightarrow> \\<not> reduced_word A (as@[a,a]@bs)\"", "lemma reduced_word_Cons_reduce_contra:\n  \"\\<not> reduced_word A as \\<Longrightarrow> \\<not> reduced_word A (a#as)\"", "lemma reduced_word_Cons_reduce: \"reduced_word A (a#as) \\<Longrightarrow> reduced_word A as\"", "lemma reduced_word_singleton:\n  assumes \"a\\<in>A\" \"a\\<noteq>0\"\n  shows   \"reduced_word A [a]\"", "lemma el_reduced:\n  assumes \"0 \\<notin> A\" \"as \\<in> lists A\" \"sum_list as \\<in> A\" \"reduced_word A as\"\n  shows \"length as = 1\"", "lemma reduced_letter_set_0: \"reduced_letter_set A 0 = {}\"", "lemma reduced_letter_set_subset: \"reduced_letter_set A a \\<subseteq> A\"", "lemma reduced_word_forI_length:\n  \"\\<lbrakk> as \\<in> lists A; sum_list as = a; length as = word_length A a \\<rbrakk> \\<Longrightarrow>\n    reduced_word_for A a as\"", "lemma word_length_le:\n  \"as \\<in> lists A \\<Longrightarrow> sum_list as = a \\<Longrightarrow> word_length A a \\<le> length as\"", "lemma reduced_word_forI_length':\n  \"\\<lbrakk> as \\<in> lists A; sum_list as = a; length as \\<le> word_length A a \\<rbrakk> \\<Longrightarrow>\n    reduced_word_for A a as\"", "lemma word_length_lt:\n  \"as \\<in> lists A \\<Longrightarrow> sum_list as = a \\<Longrightarrow> \\<not> reduced_word_for A a as \\<Longrightarrow>\n    word_length A a < length as\"", "lemma in_genby_reduced_letter_set:\n  assumes \"as \\<in> lists A\" \"sum_list as = a\"\n  shows   \"a \\<in> \\<langle>reduced_letter_set A a\\<rangle>\"", "lemma reduced_word_for_genby_arg_min:\n  fixes   A :: \"'a::group_add set\"\n  defines \"B \\<equiv> A \\<union> uminus ` A\"\n  assumes \"a\\<in>\\<langle>A\\<rangle>\"\n  shows   \"reduced_word_for B a (arg_min length (word_for B a))\"", "lemma reduced_word_for_genby_sym_arg_min:\n  assumes \"uminus ` A \\<subseteq> A\" \"a\\<in>\\<langle>A\\<rangle>\"\n  shows   \"reduced_word_for A a (arg_min length (word_for A a))\"", "lemma in_genby_imp_in_reduced_letter_set:\n  fixes   A :: \"'a::group_add set\"\n  defines \"B \\<equiv> A \\<union> uminus ` A\"\n  assumes \"a \\<in> \\<langle>A\\<rangle>\"\n  shows   \"a \\<in> \\<langle>reduced_letter_set B a\\<rangle>\"", "lemma in_genby_sym_imp_in_reduced_letter_set:\n  \"uminus ` A \\<subseteq> A \\<Longrightarrow> a \\<in> \\<langle>A\\<rangle> \\<Longrightarrow> a \\<in> \\<langle>reduced_letter_set A a\\<rangle>\""], "translations": [["", "lemma times2_conv_add: \"(j::nat) + j = 2*j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j + j = 2 * j", "by (induct j) auto"], ["", "lemma (in comm_semiring_1) odd_n0: \"odd m \\<Longrightarrow> m\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd m \\<Longrightarrow> m \\<noteq> (0::'b)", "using dvd_0_right"], ["proof (prove)\nusing this:\n  ?a dvd (0::'a)\n\ngoal (1 subgoal):\n 1. odd m \\<Longrightarrow> m \\<noteq> (0::'b)", "by fast"], ["", "lemma (in semigroup_add) add_assoc4: \"a + b + c + d = a + (b + c + d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b + c + d = a + (b + c + d)", "using add.assoc"], ["proof (prove)\nusing this:\n  ?a + ?b + ?c = ?a + (?b + ?c)\n\ngoal (1 subgoal):\n 1. a + b + c + d = a + (b + c + d)", "by simp"], ["", "lemmas (in monoid_add) sum_list_map_cong =\n  arg_cong[OF map_cong, OF refl, of _ _ _ sum_list]"], ["", "context group_add\nbegin"], ["", "lemma map_uminus_order2:\n  \"\\<forall>s\\<in>set ss. s+s=0 \\<Longrightarrow> map (uminus) ss = ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>set ss. s + s = (0::'a) \\<Longrightarrow>\n    map uminus ss = ss", "by (induct ss) (auto simp add: minus_unique)"], ["", "lemma uminus_sum_list: \"- sum_list as = sum_list (map uminus (rev as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - sum_list as = sum_list (map uminus (rev as))", "by (induct as) (auto simp add: minus_add)"], ["", "lemma uminus_sum_list_order2:\n  \"\\<forall>s\\<in>set ss. s+s=0 \\<Longrightarrow> - sum_list ss = sum_list (rev ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>set ss. s + s = (0::'a) \\<Longrightarrow>\n    - sum_list ss = sum_list (rev ss)", "using uminus_sum_list map_uminus_order2"], ["proof (prove)\nusing this:\n  - sum_list ?as = sum_list (map uminus (rev ?as))\n  \\<forall>s\\<in>set ?ss. s + s = (0::'a) \\<Longrightarrow>\n  map uminus ?ss = ?ss\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>set ss. s + s = (0::'a) \\<Longrightarrow>\n    - sum_list ss = sum_list (rev ss)", "by simp"], ["", "end"], ["", "(* context group_add *)"], ["", "subsection \\<open>The type of permutations of a type\\<close>"], ["", "text \\<open>\n  Here we construct a type consisting of all bijective functions on a type. This is the\n  prototypical example of a group, where the group operation is composition, and every group can\n  be embedded into such a type. It is for this purpose that we construct this type, so that we may\n  confer upon suitable subsets of types that are not of class @{class group_add} the properties of\n  that class, via a suitable injective correspondence to this permutation type.\n\\<close>"], ["", "typedef 'a permutation = \"{f::'a\\<Rightarrow>'a. bij f}\"\n  morphisms permutation Abs_permutation"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. bij f}", "by fast"], ["", "setup_lifting type_definition_permutation"], ["", "abbreviation permutation_apply :: \"'a permutation \\<Rightarrow> 'a \\<Rightarrow> 'a \" (infixr \"\\<rightarrow>\" 90)\n  where \"p \\<rightarrow> a \\<equiv> permutation p a\""], ["", "abbreviation permutation_image :: \"'a permutation \\<Rightarrow> 'a set \\<Rightarrow> 'a set\"\n  (infixr \"`\\<rightarrow>\" 90)\n  where \"p `\\<rightarrow> A \\<equiv> permutation p ` A\""], ["", "lemma permutation_eq_image: \"a `\\<rightarrow> A = a `\\<rightarrow> B \\<Longrightarrow> A=B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a `\\<rightarrow> A = a `\\<rightarrow> B \\<Longrightarrow> A = B", "using permutation[of a] inj_eq_image[OF bij_is_inj]"], ["proof (prove)\nusing this:\n  (\\<rightarrow>) a \\<in> {f. bij f}\n  \\<lbrakk>bij ?f; ?f ` ?X = ?f ` ?Y\\<rbrakk> \\<Longrightarrow> ?X = ?Y\n\ngoal (1 subgoal):\n 1. a `\\<rightarrow> A = a `\\<rightarrow> B \\<Longrightarrow> A = B", "by auto"], ["", "instantiation permutation :: (type) zero\nbegin"], ["", "lift_definition zero_permutation :: \"'a permutation\" is \"id::'a\\<Rightarrow>'a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij id", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a permutation, zero_class)", ".."], ["", "end"], ["", "instantiation permutation :: (type) plus\nbegin"], ["", "lift_definition plus_permutation :: \"'a permutation \\<Rightarrow> 'a permutation \\<Rightarrow> 'a permutation\"\n  is    \"comp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>bij fun1; bij fun2\\<rbrakk>\n       \\<Longrightarrow> bij (fun1 \\<circ> fun2)", "using bij_comp"], ["proof (prove)\nusing this:\n  \\<lbrakk>bij ?f; bij ?g\\<rbrakk> \\<Longrightarrow> bij (?g \\<circ> ?f)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>bij fun1; bij fun2\\<rbrakk>\n       \\<Longrightarrow> bij (fun1 \\<circ> fun2)", "by    fast"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a permutation, plus_class)", ".."], ["", "end"], ["", "lemma plus_permutation_abs_eq:\n  \"bij f \\<Longrightarrow> bij g \\<Longrightarrow>\n    Abs_permutation f + Abs_permutation g = Abs_permutation (f\\<circ>g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij f; bij g\\<rbrakk>\n    \\<Longrightarrow> Abs_permutation f + Abs_permutation g =\n                      Abs_permutation (f \\<circ> g)", "by (simp add: plus_permutation.abs_eq eq_onp_same_args)"], ["", "instance permutation :: (type) semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a permutation, semigroup_add_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c. a + b + c = a + (b + c)", "fix a b c :: \"'a permutation\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c. a + b + c = a + (b + c)", "show \"a + b + c = a + (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "using comp_assoc[of \"permutation a\" \"permutation b\" \"permutation c\"]"], ["proof (prove)\nusing this:\n  (\\<rightarrow>) a \\<circ> (\\<rightarrow>) b \\<circ> (\\<rightarrow>) c =\n  (\\<rightarrow>) a \\<circ> ((\\<rightarrow>) b \\<circ> (\\<rightarrow>) c)\n\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "by    transfer simp"], ["proof (state)\nthis:\n  a + b + c = a + (b + c)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance permutation :: (type) monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a permutation, monoid_add_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. 0 + a = a\n 2. \\<And>a. a + 0 = a", "fix a :: \"'a permutation\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. 0 + a = a\n 2. \\<And>a. a + 0 = a", "show \"0 + a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + a = a", "by transfer simp"], ["proof (state)\nthis:\n  0 + a = a\n\ngoal (1 subgoal):\n 1. \\<And>a. a + 0 = a", "show \"a + 0 = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + 0 = a", "by transfer simp"], ["proof (state)\nthis:\n  a + 0 = a\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation permutation :: (type) uminus\nbegin"], ["", "lift_definition uminus_permutation :: \"'a permutation \\<Rightarrow> 'a permutation\"\n  is    \"\\<lambda>f. the_inv f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. bij fun \\<Longrightarrow> bij (the_inv fun)", "using bij_betw_the_inv_into"], ["proof (prove)\nusing this:\n  bij_betw ?f ?A ?B \\<Longrightarrow> bij_betw (the_inv_into ?A ?f) ?B ?A\n\ngoal (1 subgoal):\n 1. \\<And>fun. bij fun \\<Longrightarrow> bij (the_inv fun)", "by    fast"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a permutation, uminus_class)", ".."], ["", "end"], ["", "instantiation permutation :: (type) minus\nbegin"], ["", "lift_definition minus_permutation :: \"'a permutation \\<Rightarrow> 'a permutation \\<Rightarrow> 'a permutation\"\n  is    \"\\<lambda>f g. f \\<circ> (the_inv g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>bij fun1; bij fun2\\<rbrakk>\n       \\<Longrightarrow> bij (fun1 \\<circ> the_inv fun2)", "using bij_betw_the_inv_into bij_comp"], ["proof (prove)\nusing this:\n  bij_betw ?f ?A ?B \\<Longrightarrow> bij_betw (the_inv_into ?A ?f) ?B ?A\n  \\<lbrakk>bij ?f; bij ?g\\<rbrakk> \\<Longrightarrow> bij (?g \\<circ> ?f)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>bij fun1; bij fun2\\<rbrakk>\n       \\<Longrightarrow> bij (fun1 \\<circ> the_inv fun2)", "by    fast"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a permutation, minus_class)", ".."], ["", "end"], ["", "lemma minus_permutation_abs_eq:\n  \"bij f \\<Longrightarrow> bij g \\<Longrightarrow>\n    Abs_permutation f - Abs_permutation g = Abs_permutation (f \\<circ> the_inv g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij f; bij g\\<rbrakk>\n    \\<Longrightarrow> Abs_permutation f - Abs_permutation g =\n                      Abs_permutation (f \\<circ> the_inv g)", "by (simp add: minus_permutation.abs_eq eq_onp_same_args)"], ["", "instance permutation :: (type) group_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a permutation, group_add_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. - a + a = 0\n 2. \\<And>a b. a + - b = a - b", "fix a b :: \"'a permutation\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. - a + a = 0\n 2. \\<And>a b. a + - b = a - b", "show \"- a + a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a + a = 0", "using the_inv_leftinv[of \"permutation a\"]"], ["proof (prove)\nusing this:\n  bij ((\\<rightarrow>) a) \\<Longrightarrow>\n  the_inv ((\\<rightarrow>) a) \\<circ> (\\<rightarrow>) a = id\n\ngoal (1 subgoal):\n 1. - a + a = 0", "by transfer simp"], ["proof (state)\nthis:\n  - a + a = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b. a + - b = a - b", "show \"a + - b = a - b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + - b = a - b", "by transfer simp"], ["proof (state)\nthis:\n  a + - b = a - b\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Natural action of @{typ nat} on types of class @{class monoid_add}\\<close>"], ["", "subsubsection \\<open>Translation from class @{class power}.\\<close>"], ["", "text \\<open>\n  Here we translate the @{class power} class to apply to types of class @{class monoid_add}.\n\\<close>"], ["", "context monoid_add\nbegin"], ["", "sublocale nataction: power 0 plus"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale add_mult_translate: monoid_mult 0 plus"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.monoid_mult (0::'a) (+)", "by unfold_locales (auto simp add: add.assoc)"], ["", "abbreviation nataction :: \"'a \\<Rightarrow> nat \\<Rightarrow> 'a\" (infix \"+^\" 80)\n  where \"a+^n  \\<equiv> nataction.power a n\""], ["", "lemmas nataction_2    = add_mult_translate.power2_eq_square"], ["", "lemmas nataction_Suc2 = add_mult_translate.power_Suc2"], ["", "lemma alternating_sum_list_conv_nataction:\n  \"sum_list (alternating_list (2*n) s t) = (s+t)+^n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (alternating_list (2 * n) s t) = (s + t) +^ n", "by (induct n) (auto simp add: nataction_Suc2[THEN sym])"], ["", "lemma nataction_add_flip: \"(a+b)+^(Suc n) = a + (b+a)+^n + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b) +^ Suc n = a + (b + a) +^ n + b", "using nataction_Suc2 add.assoc"], ["proof (prove)\nusing this:\n  ?a +^ Suc ?n = ?a +^ ?n + ?a\n  ?a + ?b + ?c = ?a + (?b + ?c)\n\ngoal (1 subgoal):\n 1. (a + b) +^ Suc n = a + (b + a) +^ n + b", "by (induct n arbitrary: a b) auto"], ["", "end"], ["", "(* context monoid_add *)"], ["", "lemma (in group_add) nataction_add_eq0_flip:\n  assumes \"(a+b)+^n = 0\"\n  shows   \"(b+a)+^n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b + a) +^ n = (0::'a)", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> (b + a) +^ n = (0::'a)\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> (b + a) +^ n = (0::'a)", "case (Suc k)"], ["proof (state)\nthis:\n  n = Suc k\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> (b + a) +^ n = (0::'a)\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> (b + a) +^ n = (0::'a)", "with assms"], ["proof (chain)\npicking this:\n  (a + b) +^ n = (0::'a)\n  n = Suc k", "show ?thesis"], ["proof (prove)\nusing this:\n  (a + b) +^ n = (0::'a)\n  n = Suc k\n\ngoal (1 subgoal):\n 1. (b + a) +^ n = (0::'a)", "using nataction_add_flip add.assoc[of \"-a\" \"a+b\" \"(a+b)+^k\"]"], ["proof (prove)\nusing this:\n  (a + b) +^ n = (0::'a)\n  n = Suc k\n  (?a + ?b) +^ Suc ?n = ?a + (?b + ?a) +^ ?n + ?b\n  - a + (a + b) + (a + b) +^ k = - a + (a + b + (a + b) +^ k)\n\ngoal (1 subgoal):\n 1. (b + a) +^ n = (0::'a)", "by simp"], ["proof (state)\nthis:\n  (b + a) +^ n = (0::'a)\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> (b + a) +^ n = (0::'a)", "qed simp"], ["", "subsubsection \\<open>Additive order of an element\\<close>"], ["", "context monoid_add\nbegin"], ["", "definition add_order :: \"'a \\<Rightarrow> nat\"\n  where \"add_order a \\<equiv> if (\\<exists>n>0. a+^n = 0) then\n          (LEAST n. n>0 \\<and> a+^n = 0) else 0\""], ["", "lemma add_order: \"a+^(add_order a) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a +^ add_order a = (0::'a)", "using LeastI_ex[of \"\\<lambda>n. n>0 \\<and> a+^n = 0\"] add_order_def"], ["proof (prove)\nusing this:\n  \\<exists>x. order.greater x 0 \\<and> a +^ x = (0::'a) \\<Longrightarrow>\n  order.greater (LEAST n. order.greater n 0 \\<and> a +^ n = (0::'a))\n   0 \\<and>\n  a +^ (LEAST n. order.greater n 0 \\<and> a +^ n = (0::'a)) = (0::'a)\n  add_order ?a \\<equiv>\n  if \\<exists>n. order.greater n 0 \\<and> ?a +^ n = (0::'a)\n  then LEAST n. order.greater n 0 \\<and> ?a +^ n = (0::'a) else 0\n\ngoal (1 subgoal):\n 1. a +^ add_order a = (0::'a)", "by simp"], ["", "lemma add_order_least: \"n>0 \\<Longrightarrow> a+^n = 0 \\<Longrightarrow> add_order a \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater n 0; a +^ n = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq n (add_order a)", "using Least_le[of \"\\<lambda>n. n>0 \\<and> a+^n = 0\"] add_order_def"], ["proof (prove)\nusing this:\n  order.greater ?k 0 \\<and> a +^ ?k = (0::'a) \\<Longrightarrow>\n  order.greater_eq ?k (LEAST x. order.greater x 0 \\<and> a +^ x = (0::'a))\n  add_order ?a \\<equiv>\n  if \\<exists>n. order.greater n 0 \\<and> ?a +^ n = (0::'a)\n  then LEAST n. order.greater n 0 \\<and> ?a +^ n = (0::'a) else 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater n 0; a +^ n = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq n (add_order a)", "by simp"], ["", "lemma add_order_equality:\n  \"\\<lbrakk> n>0; a+^n = 0; (\\<And>m. m>0 \\<Longrightarrow> a+^m = 0 \\<Longrightarrow> n\\<le>m) \\<rbrakk> \\<Longrightarrow>\n    add_order a = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater n 0; a +^ n = (0::'a);\n     \\<And>m.\n        \\<lbrakk>order.greater m 0; a +^ m = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> order.greater_eq m n\\<rbrakk>\n    \\<Longrightarrow> add_order a = n", "using Least_equality[of \"\\<lambda>n. n>0 \\<and> a+^n = 0\"] add_order_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater ?x 0 \\<and> a +^ ?x = (0::'a);\n   \\<And>y.\n      order.greater y 0 \\<and> a +^ y = (0::'a) \\<Longrightarrow>\n      order.greater_eq y ?x\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. order.greater n 0 \\<and> a +^ n = (0::'a)) =\n                    ?x\n  add_order ?a \\<equiv>\n  if \\<exists>n. order.greater n 0 \\<and> ?a +^ n = (0::'a)\n  then LEAST n. order.greater n 0 \\<and> ?a +^ n = (0::'a) else 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater n 0; a +^ n = (0::'a);\n     \\<And>m.\n        \\<lbrakk>order.greater m 0; a +^ m = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> order.greater_eq m n\\<rbrakk>\n    \\<Longrightarrow> add_order a = n", "by auto"], ["", "lemma add_order0: \"add_order 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_order (0::'a) = 1", "using add_order_equality"], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater ?n 0; ?a +^ ?n = (0::'a);\n   \\<And>m.\n      \\<lbrakk>order.greater m 0; ?a +^ m = (0::'a)\\<rbrakk>\n      \\<Longrightarrow> order.greater_eq m ?n\\<rbrakk>\n  \\<Longrightarrow> add_order ?a = ?n\n\ngoal (1 subgoal):\n 1. add_order (0::'a) = 1", "by simp"], ["", "lemma add_order_gt0: \"(add_order a > 0) = (\\<exists>n>0. a+^n = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater (add_order a) 0 =\n    (\\<exists>n. order.greater n 0 \\<and> a +^ n = (0::'a))", "using LeastI_ex[of \"\\<lambda>n. n>0 \\<and> a+^n = 0\"] add_order_def"], ["proof (prove)\nusing this:\n  \\<exists>x. order.greater x 0 \\<and> a +^ x = (0::'a) \\<Longrightarrow>\n  order.greater (LEAST n. order.greater n 0 \\<and> a +^ n = (0::'a))\n   0 \\<and>\n  a +^ (LEAST n. order.greater n 0 \\<and> a +^ n = (0::'a)) = (0::'a)\n  add_order ?a \\<equiv>\n  if \\<exists>n. order.greater n 0 \\<and> ?a +^ n = (0::'a)\n  then LEAST n. order.greater n 0 \\<and> ?a +^ n = (0::'a) else 0\n\ngoal (1 subgoal):\n 1. order.greater (add_order a) 0 =\n    (\\<exists>n. order.greater n 0 \\<and> a +^ n = (0::'a))", "by simp"], ["", "lemma add_order_eq0: \"add_order a = 0 \\<Longrightarrow> n>0 \\<Longrightarrow> a+^n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>add_order a = 0; order.greater n 0\\<rbrakk>\n    \\<Longrightarrow> a +^ n \\<noteq> (0::'a)", "using add_order_gt0"], ["proof (prove)\nusing this:\n  order.greater (add_order ?a) 0 =\n  (\\<exists>n. order.greater n 0 \\<and> ?a +^ n = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>add_order a = 0; order.greater n 0\\<rbrakk>\n    \\<Longrightarrow> a +^ n \\<noteq> (0::'a)", "by force"], ["", "lemma less_add_order_eq_0:\n  assumes \"a+^k = 0\" \"k < add_order a\"\n  shows   \"k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = 0", "proof (cases \"k=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> k = 0\n 2. k \\<noteq> 0 \\<Longrightarrow> k = 0", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> k = 0\n 2. k \\<noteq> 0 \\<Longrightarrow> k = 0", "moreover"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> k = 0\n 2. k \\<noteq> 0 \\<Longrightarrow> k = 0", "with assms(1)"], ["proof (chain)\npicking this:\n  a +^ k = (0::'a)\n  k \\<noteq> 0", "have \"\\<exists>n>0. a+^n = 0\""], ["proof (prove)\nusing this:\n  a +^ k = (0::'a)\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>n. order.greater n 0 \\<and> a +^ n = (0::'a)", "by fast"], ["proof (state)\nthis:\n  \\<exists>n. order.greater n 0 \\<and> a +^ n = (0::'a)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> k = 0\n 2. k \\<noteq> 0 \\<Longrightarrow> k = 0", "ultimately"], ["proof (chain)\npicking this:\n  k \\<noteq> 0\n  \\<exists>n. order.greater n 0 \\<and> a +^ n = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  \\<exists>n. order.greater n 0 \\<and> a +^ n = (0::'a)\n\ngoal (1 subgoal):\n 1. k = 0", "using assms add_order_def not_less_Least[of k \"\\<lambda>n. n>0 \\<and> a+^n = 0\"]"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  \\<exists>n. order.greater n 0 \\<and> a +^ n = (0::'a)\n  a +^ k = (0::'a)\n  order.greater (add_order a) k\n  add_order ?a \\<equiv>\n  if \\<exists>n. order.greater n 0 \\<and> ?a +^ n = (0::'a)\n  then LEAST n. order.greater n 0 \\<and> ?a +^ n = (0::'a) else 0\n  order.greater (LEAST x. order.greater x 0 \\<and> a +^ x = (0::'a))\n   k \\<Longrightarrow>\n  \\<not> (order.greater k 0 \\<and> a +^ k = (0::'a))\n\ngoal (1 subgoal):\n 1. k = 0", "by    auto"], ["proof (state)\nthis:\n  k = 0\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> k = 0", "qed simp"], ["", "lemma less_add_order_eq_0_contra: \"k>0 \\<Longrightarrow> k < add_order a \\<Longrightarrow> a+^k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater k 0; order.greater (add_order a) k\\<rbrakk>\n    \\<Longrightarrow> a +^ k \\<noteq> (0::'a)", "using less_add_order_eq_0"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a +^ ?k = (0::'a); order.greater (add_order ?a) ?k\\<rbrakk>\n  \\<Longrightarrow> ?k = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater k 0; order.greater (add_order a) k\\<rbrakk>\n    \\<Longrightarrow> a +^ k \\<noteq> (0::'a)", "by fast"], ["", "lemma add_order_relator: \"add_order (a+^(add_order a)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_order (a +^ add_order a) = 1", "using add_order"], ["proof (prove)\nusing this:\n  ?a +^ add_order ?a = (0::'a)\n\ngoal (1 subgoal):\n 1. add_order (a +^ add_order a) = 1", "by (auto intro: add_order_equality)"], ["", "abbreviation pair_relator_list :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a list\"\n  where \"pair_relator_list s t \\<equiv> alternating_list (2*add_order (s+t)) s t\""], ["", "abbreviation pair_relator_halflist :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a list\"\n  where \"pair_relator_halflist s t \\<equiv> alternating_list (add_order (s+t)) s t\""], ["", "abbreviation pair_relator_halflist2 :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a list\"\n  where \"pair_relator_halflist2 s t \\<equiv>\n    (if even (add_order (s+t)) then pair_relator_halflist s t else\n      pair_relator_halflist t s)\""], ["", "lemma sum_list_pair_relator_list: \"sum_list (pair_relator_list s t) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (pair_relator_list s t) = (0::'a)", "by (auto simp add: add_order alternating_sum_list_conv_nataction)"], ["", "end"], ["", "(* context monoid_add *)"], ["", "context group_add\nbegin"], ["", "lemma add_order_add_eq1: \"add_order (s+t) = 1 \\<Longrightarrow> t = -s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_order (s + t) = 1 \\<Longrightarrow> t = - s", "using add_order[of \"s+t\"]"], ["proof (prove)\nusing this:\n  (s + t) +^ add_order (s + t) = (0::'a)\n\ngoal (1 subgoal):\n 1. add_order (s + t) = 1 \\<Longrightarrow> t = - s", "by (simp add: minus_unique)"], ["", "lemma add_order_add_sym: \"add_order (t+s) = add_order (s+t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_order (t + s) = add_order (s + t)", "proof (cases \"add_order (t+s) = 0\" \"add_order (s+t) = 0\" rule: two_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>add_order (t + s) = 0; add_order (s + t) = 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 2. \\<lbrakk>add_order (t + s) = 0; add_order (s + t) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 3. \\<lbrakk>add_order (t + s) \\<noteq> 0; add_order (s + t) = 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 4. \\<lbrakk>add_order (t + s) \\<noteq> 0;\n     add_order (s + t) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)", "case one"], ["proof (state)\nthis:\n  add_order (t + s) = 0\n  add_order (s + t) \\<noteq> 0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>add_order (t + s) = 0; add_order (s + t) = 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 2. \\<lbrakk>add_order (t + s) = 0; add_order (s + t) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 3. \\<lbrakk>add_order (t + s) \\<noteq> 0; add_order (s + t) = 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 4. \\<lbrakk>add_order (t + s) \\<noteq> 0;\n     add_order (s + t) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  add_order (t + s) = 0\n  add_order (s + t) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. add_order (t + s) = add_order (s + t)", "using add_order nataction_add_eq0_flip[of s t] add_order_eq0"], ["proof (prove)\nusing this:\n  add_order (t + s) = 0\n  add_order (s + t) \\<noteq> 0\n  ?a +^ add_order ?a = (0::'a)\n  (s + t) +^ ?n = (0::'a) \\<Longrightarrow> (t + s) +^ ?n = (0::'a)\n  \\<lbrakk>add_order ?a = 0; order.greater ?n 0\\<rbrakk>\n  \\<Longrightarrow> ?a +^ ?n \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. add_order (t + s) = add_order (s + t)", "by auto"], ["proof (state)\nthis:\n  add_order (t + s) = add_order (s + t)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>add_order (t + s) = 0; add_order (s + t) = 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 2. \\<lbrakk>add_order (t + s) \\<noteq> 0; add_order (s + t) = 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 3. \\<lbrakk>add_order (t + s) \\<noteq> 0;\n     add_order (s + t) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>add_order (t + s) = 0; add_order (s + t) = 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 2. \\<lbrakk>add_order (t + s) \\<noteq> 0; add_order (s + t) = 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 3. \\<lbrakk>add_order (t + s) \\<noteq> 0;\n     add_order (s + t) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)", "case other"], ["proof (state)\nthis:\n  add_order (t + s) \\<noteq> 0\n  add_order (s + t) = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>add_order (t + s) = 0; add_order (s + t) = 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 2. \\<lbrakk>add_order (t + s) \\<noteq> 0; add_order (s + t) = 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 3. \\<lbrakk>add_order (t + s) \\<noteq> 0;\n     add_order (s + t) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  add_order (t + s) \\<noteq> 0\n  add_order (s + t) = 0\n\ngoal (1 subgoal):\n 1. add_order (t + s) = add_order (s + t)", "using add_order nataction_add_eq0_flip[of t s] add_order_eq0"], ["proof (prove)\nusing this:\n  add_order (t + s) \\<noteq> 0\n  add_order (s + t) = 0\n  ?a +^ add_order ?a = (0::'a)\n  (t + s) +^ ?n = (0::'a) \\<Longrightarrow> (s + t) +^ ?n = (0::'a)\n  \\<lbrakk>add_order ?a = 0; order.greater ?n 0\\<rbrakk>\n  \\<Longrightarrow> ?a +^ ?n \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. add_order (t + s) = add_order (s + t)", "by auto"], ["proof (state)\nthis:\n  add_order (t + s) = add_order (s + t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>add_order (t + s) = 0; add_order (s + t) = 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 2. \\<lbrakk>add_order (t + s) \\<noteq> 0;\n     add_order (s + t) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>add_order (t + s) = 0; add_order (s + t) = 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 2. \\<lbrakk>add_order (t + s) \\<noteq> 0;\n     add_order (s + t) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)", "case neither"], ["proof (state)\nthis:\n  add_order (t + s) \\<noteq> 0\n  add_order (s + t) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>add_order (t + s) = 0; add_order (s + t) = 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)\n 2. \\<lbrakk>add_order (t + s) \\<noteq> 0;\n     add_order (s + t) \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  add_order (t + s) \\<noteq> 0\n  add_order (s + t) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. add_order (t + s) = add_order (s + t)", "using add_order[of \"s+t\"] add_order[of \"t+s\"]\n          nataction_add_eq0_flip[of s t] nataction_add_eq0_flip[of t s]\n          add_order_least[of \"add_order (s+t)\"] add_order_least[of \"add_order (t+s)\"]"], ["proof (prove)\nusing this:\n  add_order (t + s) \\<noteq> 0\n  add_order (s + t) \\<noteq> 0\n  (s + t) +^ add_order (s + t) = (0::'a)\n  (t + s) +^ add_order (t + s) = (0::'a)\n  (s + t) +^ ?n = (0::'a) \\<Longrightarrow> (t + s) +^ ?n = (0::'a)\n  (t + s) +^ ?n = (0::'a) \\<Longrightarrow> (s + t) +^ ?n = (0::'a)\n  \\<lbrakk>order.greater (add_order (s + t)) 0;\n   ?a +^ add_order (s + t) = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (add_order (s + t)) (add_order ?a)\n  \\<lbrakk>order.greater (add_order (t + s)) 0;\n   ?a +^ add_order (t + s) = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (add_order (t + s)) (add_order ?a)\n\ngoal (1 subgoal):\n 1. add_order (t + s) = add_order (s + t)", "by fastforce"], ["proof (state)\nthis:\n  add_order (t + s) = add_order (s + t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>add_order (t + s) = 0; add_order (s + t) = 0\\<rbrakk>\n    \\<Longrightarrow> add_order (t + s) = add_order (s + t)", "qed simp"], ["", "lemma pair_relator_halflist_append:\n  \"pair_relator_halflist s t @ pair_relator_halflist2 s t = pair_relator_list s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_relator_halflist s t @\n    (if gcd_nat.greater_eq (add_order (s + t)) 2\n     then pair_relator_halflist s t else pair_relator_halflist t s) =\n    pair_relator_list s t", "using alternating_list_split[of \"add_order (s+t)\" \"add_order (s+t)\" s t]"], ["proof (prove)\nusing this:\n  alternating_list (add_order (s + t) + add_order (s + t)) s t =\n  pair_relator_halflist s t @\n  (if gcd_nat.greater_eq (add_order (s + t)) 2\n   then pair_relator_halflist s t\n   else alternating_list (add_order (s + t)) t s)\n\ngoal (1 subgoal):\n 1. pair_relator_halflist s t @\n    (if gcd_nat.greater_eq (add_order (s + t)) 2\n     then pair_relator_halflist s t else pair_relator_halflist t s) =\n    pair_relator_list s t", "by    (auto simp add: times2_conv_add add_order_add_sym)"], ["", "lemma rev_pair_relator_list: \"rev (pair_relator_list s t) = pair_relator_list t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (pair_relator_list s t) = pair_relator_list t s", "by (simp add:rev_alternating_list add_order_add_sym)"], ["", "lemma pair_relator_halflist2_conv_rev_pair_relator_halflist:\n  \"pair_relator_halflist2 s t = rev (pair_relator_halflist t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if gcd_nat.greater_eq (add_order (s + t)) 2\n     then pair_relator_halflist s t else pair_relator_halflist t s) =\n    rev (pair_relator_halflist t s)", "by (auto simp add: add_order_add_sym rev_alternating_list)"], ["", "end"], ["", "(* context group_add *)"], ["", "subsection \\<open>Partial sums of a list\\<close>"], ["", "text \\<open>\n  Here we construct a list that collects the results of adding the elements of a given list\n  together one-by-one.\n\\<close>"], ["", "context monoid_add\nbegin"], ["", "primrec sums :: \"'a list \\<Rightarrow> 'a list\"\n  where\n    \"sums [] = [0]\"\n  | \"sums (x#xs) = 0 # map ((+) x) (sums xs)\""], ["", "lemma length_sums: \"length (sums xs) = Suc (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (sums xs) = Suc (length xs)", "by (induct xs) auto"], ["", "lemma sums_snoc: \"sums (xs@[x]) = sums xs @ [sum_list (xs@[x])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sums (xs @ [x]) = sums xs @ [sum_list (xs @ [x])]", "by (induct xs) (auto simp add: add.assoc)"], ["", "lemma sums_append2:\n  \"sums (xs@ys) = butlast (sums xs) @ map ((+) (sum_list xs)) (sums ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sums (xs @ ys) = butlast (sums xs) @ map ((+) (sum_list xs)) (sums ys)", "proof (induct ys rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. sums (xs @ []) = butlast (sums xs) @ map ((+) (sum_list xs)) (sums [])\n 2. \\<And>x xsa.\n       sums (xs @ xsa) =\n       butlast (sums xs) @\n       map ((+) (sum_list xs)) (sums xsa) \\<Longrightarrow>\n       sums (xs @ xsa @ [x]) =\n       butlast (sums xs) @ map ((+) (sum_list xs)) (sums (xsa @ [x]))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sums (xs @ []) = butlast (sums xs) @ map ((+) (sum_list xs)) (sums [])\n 2. \\<And>x xsa.\n       sums (xs @ xsa) =\n       butlast (sums xs) @\n       map ((+) (sum_list xs)) (sums xsa) \\<Longrightarrow>\n       sums (xs @ xsa @ [x]) =\n       butlast (sums xs) @ map ((+) (sum_list xs)) (sums (xsa @ [x]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sums (xs @ []) = butlast (sums xs) @ map ((+) (sum_list xs)) (sums [])", "by (cases xs rule: rev_cases) (auto simp add: sums_snoc)"], ["proof (state)\nthis:\n  sums (xs @ []) = butlast (sums xs) @ map ((+) (sum_list xs)) (sums [])\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       sums (xs @ xsa) =\n       butlast (sums xs) @\n       map ((+) (sum_list xs)) (sums xsa) \\<Longrightarrow>\n       sums (xs @ xsa @ [x]) =\n       butlast (sums xs) @ map ((+) (sum_list xs)) (sums (xsa @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       sums (xs @ xsa) =\n       butlast (sums xs) @\n       map ((+) (sum_list xs)) (sums xsa) \\<Longrightarrow>\n       sums (xs @ xsa @ [x]) =\n       butlast (sums xs) @ map ((+) (sum_list xs)) (sums (xsa @ [x]))", "case (snoc y ys)"], ["proof (state)\nthis:\n  sums (xs @ ys) = butlast (sums xs) @ map ((+) (sum_list xs)) (sums ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       sums (xs @ xsa) =\n       butlast (sums xs) @\n       map ((+) (sum_list xs)) (sums xsa) \\<Longrightarrow>\n       sums (xs @ xsa @ [x]) =\n       butlast (sums xs) @ map ((+) (sum_list xs)) (sums (xsa @ [x]))", "thus ?case"], ["proof (prove)\nusing this:\n  sums (xs @ ys) = butlast (sums xs) @ map ((+) (sum_list xs)) (sums ys)\n\ngoal (1 subgoal):\n 1. sums (xs @ ys @ [y]) =\n    butlast (sums xs) @ map ((+) (sum_list xs)) (sums (ys @ [y]))", "using sums_snoc[of \"xs@ys\"]"], ["proof (prove)\nusing this:\n  sums (xs @ ys) = butlast (sums xs) @ map ((+) (sum_list xs)) (sums ys)\n  sums ((xs @ ys) @ [?x]) = sums (xs @ ys) @ [sum_list ((xs @ ys) @ [?x])]\n\ngoal (1 subgoal):\n 1. sums (xs @ ys @ [y]) =\n    butlast (sums xs) @ map ((+) (sum_list xs)) (sums (ys @ [y]))", "by (simp add: sums_snoc)"], ["proof (state)\nthis:\n  sums (xs @ ys @ [y]) =\n  butlast (sums xs) @ map ((+) (sum_list xs)) (sums (ys @ [y]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sums_Cons_conv_append_tl:\n  \"sums (x#xs) = 0 # x # map ((+) x) (tl (sums xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sums (x # xs) = (0::'a) # x # map ((+) x) (tl (sums xs))", "by (cases xs) auto"], ["", "lemma pullback_sums_map_middle2:\n  \"map F (sums xs) = ds@[d,e]@es \\<Longrightarrow>\n    \\<exists>as a bs. xs = as@[a]@bs \\<and> map F (sums as) = ds@[d] \\<and>\n      d = F (sum_list as) \\<and> e = F (sum_list (as@[a]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map F (sums xs) = ds @ [d, e] @ es \\<Longrightarrow>\n    \\<exists>as a bs.\n       xs = as @ [a] @ bs \\<and>\n       map F (sums as) = ds @ [d] \\<and>\n       d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "proof (induct xs es rule: list_induct2_snoc)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       map F (sums []) = ds @ [d, e] @ ys \\<Longrightarrow>\n       \\<exists>as a bs.\n          [] = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n 2. \\<And>xs.\n       map F (sums xs) = ds @ [d, e] @ [] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n 3. \\<And>xs x ys y.\n       \\<lbrakk>map F (sums xs) = ds @ [d, e] @ ys \\<Longrightarrow>\n                \\<exists>as a bs.\n                   xs = as @ [a] @ bs \\<and>\n                   map F (sums as) = ds @ [d] \\<and>\n                   d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]));\n        map F (sums (xs @ [x])) = ds @ [d, e] @ ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as a bs.\n                            xs @ [x] = as @ [a] @ bs \\<and>\n                            map F (sums as) = ds @ [d] \\<and>\n                            d = F (sum_list as) \\<and>\n                            e = F (sum_list (as @ [a]))", "case (Nil2 xs)"], ["proof (state)\nthis:\n  map F (sums xs) = ds @ [d, e] @ []\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       map F (sums []) = ds @ [d, e] @ ys \\<Longrightarrow>\n       \\<exists>as a bs.\n          [] = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n 2. \\<And>xs.\n       map F (sums xs) = ds @ [d, e] @ [] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n 3. \\<And>xs x ys y.\n       \\<lbrakk>map F (sums xs) = ds @ [d, e] @ ys \\<Longrightarrow>\n                \\<exists>as a bs.\n                   xs = as @ [a] @ bs \\<and>\n                   map F (sums as) = ds @ [d] \\<and>\n                   d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]));\n        map F (sums (xs @ [x])) = ds @ [d, e] @ ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as a bs.\n                            xs @ [x] = as @ [a] @ bs \\<and>\n                            map F (sums as) = ds @ [d] \\<and>\n                            d = F (sum_list as) \\<and>\n                            e = F (sum_list (as @ [a]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as a bs.\n       xs = as @ [a] @ bs \\<and>\n       map F (sums as) = ds @ [d] \\<and>\n       d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "proof (cases xs rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    \\<exists>as a bs.\n       xs = as @ [a] @ bs \\<and>\n       map F (sums as) = ds @ [d] \\<and>\n       d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n 2. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    \\<exists>as a bs.\n       xs = as @ [a] @ bs \\<and>\n       map F (sums as) = ds @ [d] \\<and>\n       d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n 2. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "with Nil2"], ["proof (chain)\npicking this:\n  map F (sums xs) = ds @ [d, e] @ []\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  map F (sums xs) = ds @ [d, e] @ []\n  xs = []\n\ngoal (1 subgoal):\n 1. \\<exists>as a bs.\n       xs = as @ [a] @ bs \\<and>\n       map F (sums as) = ds @ [d] \\<and>\n       d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "by simp"], ["proof (state)\nthis:\n  \\<exists>as a bs.\n     xs = as @ [a] @ bs \\<and>\n     map F (sums as) = ds @ [d] \\<and>\n     d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "case (snoc ys y)"], ["proof (state)\nthis:\n  xs = ys @ [y]\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "have ys: \"xs = ys@[y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys @ [y]", "by fact"], ["proof (state)\nthis:\n  xs = ys @ [y]\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "with Nil2(1)"], ["proof (chain)\npicking this:\n  map F (sums xs) = ds @ [d, e] @ []\n  xs = ys @ [y]", "have y: \"map F (sums ys) = ds@[d]\" \"e = F (sum_list (ys@[y]))\""], ["proof (prove)\nusing this:\n  map F (sums xs) = ds @ [d, e] @ []\n  xs = ys @ [y]\n\ngoal (1 subgoal):\n 1. map F (sums ys) = ds @ [d] &&& e = F (sum_list (ys @ [y]))", "by (auto simp add: sums_snoc)"], ["proof (state)\nthis:\n  map F (sums ys) = ds @ [d]\n  e = F (sum_list (ys @ [y]))\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as a bs.\n       xs = as @ [a] @ bs \\<and>\n       map F (sums as) = ds @ [d] \\<and>\n       d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "proof (cases ys rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    \\<exists>as a bs.\n       xs = as @ [a] @ bs \\<and>\n       map F (sums as) = ds @ [d] \\<and>\n       d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n 2. \\<And>ysa y.\n       ys = ysa @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "case Nil"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    \\<exists>as a bs.\n       xs = as @ [a] @ bs \\<and>\n       map F (sums as) = ds @ [d] \\<and>\n       d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n 2. \\<And>ysa y.\n       ys = ysa @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "with ys y"], ["proof (chain)\npicking this:\n  xs = ys @ [y]\n  map F (sums ys) = ds @ [d]\n  e = F (sum_list (ys @ [y]))\n  ys = []", "have\n        \"xs = []@[y]@[]\" \"map F (sums []) = ds@[d]\"\n        \"d = F (sum_list [])\" \"e = F (sum_list ([]@[y]))\""], ["proof (prove)\nusing this:\n  xs = ys @ [y]\n  map F (sums ys) = ds @ [d]\n  e = F (sum_list (ys @ [y]))\n  ys = []\n\ngoal (1 subgoal):\n 1. (xs = [] @ [y] @ [] &&& map F (sums []) = ds @ [d]) &&&\n    d = F (sum_list []) &&& e = F (sum_list ([] @ [y]))", "by auto"], ["proof (state)\nthis:\n  xs = [] @ [y] @ []\n  map F (sums []) = ds @ [d]\n  d = F (sum_list [])\n  e = F (sum_list ([] @ [y]))\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    \\<exists>as a bs.\n       xs = as @ [a] @ bs \\<and>\n       map F (sums as) = ds @ [d] \\<and>\n       d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n 2. \\<And>ysa y.\n       ys = ysa @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = [] @ [y] @ []\n  map F (sums []) = ds @ [d]\n  d = F (sum_list [])\n  e = F (sum_list ([] @ [y]))\n\ngoal (1 subgoal):\n 1. \\<exists>as a bs.\n       xs = as @ [a] @ bs \\<and>\n       map F (sums as) = ds @ [d] \\<and>\n       d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "by fast"], ["proof (state)\nthis:\n  \\<exists>as a bs.\n     xs = as @ [a] @ bs \\<and>\n     map F (sums as) = ds @ [d] \\<and>\n     d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n\ngoal (1 subgoal):\n 1. \\<And>ysa y.\n       ys = ysa @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ysa y.\n       ys = ysa @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "case (snoc zs z)"], ["proof (state)\nthis:\n  ys = zs @ [z]\n\ngoal (1 subgoal):\n 1. \\<And>ysa y.\n       ys = ysa @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "with y(1)"], ["proof (chain)\npicking this:\n  map F (sums ys) = ds @ [d]\n  ys = zs @ [z]", "have z: \"map F (sums zs) = ds\" \"d = F (sum_list (zs@[z]))\""], ["proof (prove)\nusing this:\n  map F (sums ys) = ds @ [d]\n  ys = zs @ [z]\n\ngoal (1 subgoal):\n 1. map F (sums zs) = ds &&& d = F (sum_list (zs @ [z]))", "by (auto simp add: sums_snoc)"], ["proof (state)\nthis:\n  map F (sums zs) = ds\n  d = F (sum_list (zs @ [z]))\n\ngoal (1 subgoal):\n 1. \\<And>ysa y.\n       ys = ysa @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "from z(1) ys y snoc"], ["proof (chain)\npicking this:\n  map F (sums zs) = ds\n  xs = ys @ [y]\n  map F (sums ys) = ds @ [d]\n  e = F (sum_list (ys @ [y]))\n  ys = zs @ [z]", "have\n        \"xs = (zs@[z])@[y]@[]\" \"map F (sums (zs@[z])) = ds@[d]\"\n        \"e = F (sum_list ((zs@[z])@[y]))\""], ["proof (prove)\nusing this:\n  map F (sums zs) = ds\n  xs = ys @ [y]\n  map F (sums ys) = ds @ [d]\n  e = F (sum_list (ys @ [y]))\n  ys = zs @ [z]\n\ngoal (1 subgoal):\n 1. xs = (zs @ [z]) @ [y] @ [] &&&\n    map F (sums (zs @ [z])) = ds @ [d] &&&\n    e = F (sum_list ((zs @ [z]) @ [y]))", "by auto"], ["proof (state)\nthis:\n  xs = (zs @ [z]) @ [y] @ []\n  map F (sums (zs @ [z])) = ds @ [d]\n  e = F (sum_list ((zs @ [z]) @ [y]))\n\ngoal (1 subgoal):\n 1. \\<And>ysa y.\n       ys = ysa @ [y] \\<Longrightarrow>\n       \\<exists>as a bs.\n          xs = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "with z(2)"], ["proof (chain)\npicking this:\n  d = F (sum_list (zs @ [z]))\n  xs = (zs @ [z]) @ [y] @ []\n  map F (sums (zs @ [z])) = ds @ [d]\n  e = F (sum_list ((zs @ [z]) @ [y]))", "show ?thesis"], ["proof (prove)\nusing this:\n  d = F (sum_list (zs @ [z]))\n  xs = (zs @ [z]) @ [y] @ []\n  map F (sums (zs @ [z])) = ds @ [d]\n  e = F (sum_list ((zs @ [z]) @ [y]))\n\ngoal (1 subgoal):\n 1. \\<exists>as a bs.\n       xs = as @ [a] @ bs \\<and>\n       map F (sums as) = ds @ [d] \\<and>\n       d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "by fast"], ["proof (state)\nthis:\n  \\<exists>as a bs.\n     xs = as @ [a] @ bs \\<and>\n     map F (sums as) = ds @ [d] \\<and>\n     d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as a bs.\n     xs = as @ [a] @ bs \\<and>\n     map F (sums as) = ds @ [d] \\<and>\n     d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as a bs.\n     xs = as @ [a] @ bs \\<and>\n     map F (sums as) = ds @ [d] \\<and>\n     d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       map F (sums []) = ds @ [d, e] @ ys \\<Longrightarrow>\n       \\<exists>as a bs.\n          [] = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n 2. \\<And>xs x ys y.\n       \\<lbrakk>map F (sums xs) = ds @ [d, e] @ ys \\<Longrightarrow>\n                \\<exists>as a bs.\n                   xs = as @ [a] @ bs \\<and>\n                   map F (sums as) = ds @ [d] \\<and>\n                   d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]));\n        map F (sums (xs @ [x])) = ds @ [d, e] @ ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as a bs.\n                            xs @ [x] = as @ [a] @ bs \\<and>\n                            map F (sums as) = ds @ [d] \\<and>\n                            d = F (sum_list as) \\<and>\n                            e = F (sum_list (as @ [a]))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       map F (sums []) = ds @ [d, e] @ ys \\<Longrightarrow>\n       \\<exists>as a bs.\n          [] = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n 2. \\<And>xs x ys y.\n       \\<lbrakk>map F (sums xs) = ds @ [d, e] @ ys \\<Longrightarrow>\n                \\<exists>as a bs.\n                   xs = as @ [a] @ bs \\<and>\n                   map F (sums as) = ds @ [d] \\<and>\n                   d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]));\n        map F (sums (xs @ [x])) = ds @ [d, e] @ ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as a bs.\n                            xs @ [x] = as @ [a] @ bs \\<and>\n                            map F (sums as) = ds @ [d] \\<and>\n                            d = F (sum_list as) \\<and>\n                            e = F (sum_list (as @ [a]))", "case snoc"], ["proof (state)\nthis:\n  map F (sums xs_) = ds @ [d, e] @ ys_ \\<Longrightarrow>\n  \\<exists>as a bs.\n     xs_ = as @ [a] @ bs \\<and>\n     map F (sums as) = ds @ [d] \\<and>\n     d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n  map F (sums (xs_ @ [x_])) = ds @ [d, e] @ ys_ @ [y_]\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       map F (sums []) = ds @ [d, e] @ ys \\<Longrightarrow>\n       \\<exists>as a bs.\n          [] = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n 2. \\<And>xs x ys y.\n       \\<lbrakk>map F (sums xs) = ds @ [d, e] @ ys \\<Longrightarrow>\n                \\<exists>as a bs.\n                   xs = as @ [a] @ bs \\<and>\n                   map F (sums as) = ds @ [d] \\<and>\n                   d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]));\n        map F (sums (xs @ [x])) = ds @ [d, e] @ ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as a bs.\n                            xs @ [x] = as @ [a] @ bs \\<and>\n                            map F (sums as) = ds @ [d] \\<and>\n                            d = F (sum_list as) \\<and>\n                            e = F (sum_list (as @ [a]))", "thus ?case"], ["proof (prove)\nusing this:\n  map F (sums xs_) = ds @ [d, e] @ ys_ \\<Longrightarrow>\n  \\<exists>as a bs.\n     xs_ = as @ [a] @ bs \\<and>\n     map F (sums as) = ds @ [d] \\<and>\n     d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n  map F (sums (xs_ @ [x_])) = ds @ [d, e] @ ys_ @ [y_]\n\ngoal (1 subgoal):\n 1. \\<exists>as a bs.\n       xs_ @ [x_] = as @ [a] @ bs \\<and>\n       map F (sums as) = ds @ [d] \\<and>\n       d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "by (fastforce simp add: sums_snoc)"], ["proof (state)\nthis:\n  \\<exists>as a bs.\n     xs_ @ [x_] = as @ [a] @ bs \\<and>\n     map F (sums as) = ds @ [d] \\<and>\n     d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       map F (sums []) = ds @ [d, e] @ ys \\<Longrightarrow>\n       \\<exists>as a bs.\n          [] = as @ [a] @ bs \\<and>\n          map F (sums as) = ds @ [d] \\<and>\n          d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))", "qed simp"], ["", "lemma pullback_sums_map_middle3:\n  \"map F (sums xs) = ds@[d,e,f]@fs \\<Longrightarrow>\n    \\<exists>as a b bs. xs = as@[a,b]@bs \\<and> d = F (sum_list as) \\<and>\n      e = F (sum_list (as@[a])) \\<and> f = F (sum_list (as@[a,b]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map F (sums xs) = ds @ [d, e, f] @ fs \\<Longrightarrow>\n    \\<exists>as a b bs.\n       xs = as @ [a, b] @ bs \\<and>\n       d = F (sum_list as) \\<and>\n       e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "proof (induct xs fs rule: list_induct2_snoc)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       map F (sums []) = ds @ [d, e, f] @ ys \\<Longrightarrow>\n       \\<exists>as a b bs.\n          [] = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n 2. \\<And>xs.\n       map F (sums xs) = ds @ [d, e, f] @ [] \\<Longrightarrow>\n       \\<exists>as a b bs.\n          xs = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n 3. \\<And>xs x ys y.\n       \\<lbrakk>map F (sums xs) = ds @ [d, e, f] @ ys \\<Longrightarrow>\n                \\<exists>as a b bs.\n                   xs = as @ [a, b] @ bs \\<and>\n                   d = F (sum_list as) \\<and>\n                   e = F (sum_list (as @ [a])) \\<and>\n                   f = F (sum_list (as @ [a, b]));\n        map F (sums (xs @ [x])) = ds @ [d, e, f] @ ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as a b bs.\n                            xs @ [x] = as @ [a, b] @ bs \\<and>\n                            d = F (sum_list as) \\<and>\n                            e = F (sum_list (as @ [a])) \\<and>\n                            f = F (sum_list (as @ [a, b]))", "case (Nil2 xs)"], ["proof (state)\nthis:\n  map F (sums xs) = ds @ [d, e, f] @ []\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       map F (sums []) = ds @ [d, e, f] @ ys \\<Longrightarrow>\n       \\<exists>as a b bs.\n          [] = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n 2. \\<And>xs.\n       map F (sums xs) = ds @ [d, e, f] @ [] \\<Longrightarrow>\n       \\<exists>as a b bs.\n          xs = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n 3. \\<And>xs x ys y.\n       \\<lbrakk>map F (sums xs) = ds @ [d, e, f] @ ys \\<Longrightarrow>\n                \\<exists>as a b bs.\n                   xs = as @ [a, b] @ bs \\<and>\n                   d = F (sum_list as) \\<and>\n                   e = F (sum_list (as @ [a])) \\<and>\n                   f = F (sum_list (as @ [a, b]));\n        map F (sums (xs @ [x])) = ds @ [d, e, f] @ ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as a b bs.\n                            xs @ [x] = as @ [a, b] @ bs \\<and>\n                            d = F (sum_list as) \\<and>\n                            e = F (sum_list (as @ [a])) \\<and>\n                            f = F (sum_list (as @ [a, b]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as a b bs.\n       xs = as @ [a, b] @ bs \\<and>\n       d = F (sum_list as) \\<and>\n       e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "proof (cases xs rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    \\<exists>as a b bs.\n       xs = as @ [a, b] @ bs \\<and>\n       d = F (sum_list as) \\<and>\n       e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n 2. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a b bs.\n          xs = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    \\<exists>as a b bs.\n       xs = as @ [a, b] @ bs \\<and>\n       d = F (sum_list as) \\<and>\n       e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n 2. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a b bs.\n          xs = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "with Nil2"], ["proof (chain)\npicking this:\n  map F (sums xs) = ds @ [d, e, f] @ []\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  map F (sums xs) = ds @ [d, e, f] @ []\n  xs = []\n\ngoal (1 subgoal):\n 1. \\<exists>as a b bs.\n       xs = as @ [a, b] @ bs \\<and>\n       d = F (sum_list as) \\<and>\n       e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "by simp"], ["proof (state)\nthis:\n  \\<exists>as a b bs.\n     xs = as @ [a, b] @ bs \\<and>\n     d = F (sum_list as) \\<and>\n     e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a b bs.\n          xs = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a b bs.\n          xs = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "case (snoc ys y)"], ["proof (state)\nthis:\n  xs = ys @ [y]\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a b bs.\n          xs = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "with Nil2"], ["proof (chain)\npicking this:\n  map F (sums xs) = ds @ [d, e, f] @ []\n  xs = ys @ [y]", "have y: \"map F (sums ys) = ds@[d,e]\" \"f = F (sum_list (ys@[y]))\""], ["proof (prove)\nusing this:\n  map F (sums xs) = ds @ [d, e, f] @ []\n  xs = ys @ [y]\n\ngoal (1 subgoal):\n 1. map F (sums ys) = ds @ [d, e] &&& f = F (sum_list (ys @ [y]))", "by (auto simp add: sums_snoc)"], ["proof (state)\nthis:\n  map F (sums ys) = ds @ [d, e]\n  f = F (sum_list (ys @ [y]))\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a b bs.\n          xs = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "from y(1)"], ["proof (chain)\npicking this:\n  map F (sums ys) = ds @ [d, e]", "obtain as a bs where asabs:\n      \"ys = as@[a]@bs\" \"map F (sums as) = ds@[d]\"\n      \"d = F (sum_list as)\" \"e = F (sum_list (as@[a]))\""], ["proof (prove)\nusing this:\n  map F (sums ys) = ds @ [d, e]\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs.\n        \\<lbrakk>ys = as @ [a] @ bs; map F (sums as) = ds @ [d];\n         d = F (sum_list as); e = F (sum_list (as @ [a]))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using pullback_sums_map_middle2[of F ys ds]"], ["proof (prove)\nusing this:\n  map F (sums ys) = ds @ [d, e]\n  map F (sums ys) = ds @ [?d, ?e] @ ?es \\<Longrightarrow>\n  \\<exists>as a bs.\n     ys = as @ [a] @ bs \\<and>\n     map F (sums as) = ds @ [?d] \\<and>\n     ?d = F (sum_list as) \\<and> ?e = F (sum_list (as @ [a]))\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs.\n        \\<lbrakk>ys = as @ [a] @ bs; map F (sums as) = ds @ [d];\n         d = F (sum_list as); e = F (sum_list (as @ [a]))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fastforce"], ["proof (state)\nthis:\n  ys = as @ [a] @ bs\n  map F (sums as) = ds @ [d]\n  d = F (sum_list as)\n  e = F (sum_list (as @ [a]))\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a b bs.\n          xs = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "have \"bs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs = []", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. bs = []", "from y(1) asabs(1,2)"], ["proof (chain)\npicking this:\n  map F (sums ys) = ds @ [d, e]\n  ys = as @ [a] @ bs\n  map F (sums as) = ds @ [d]", "have \"Suc (length bs) = Suc 0\""], ["proof (prove)\nusing this:\n  map F (sums ys) = ds @ [d, e]\n  ys = as @ [a] @ bs\n  map F (sums as) = ds @ [d]\n\ngoal (1 subgoal):\n 1. Suc (length bs) = Suc 0", "by (auto simp add: sums_append2 map_butlast length_sums[THEN sym])"], ["proof (state)\nthis:\n  Suc (length bs) = Suc 0\n\ngoal (1 subgoal):\n 1. bs = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  Suc (length bs) = Suc 0\n\ngoal (1 subgoal):\n 1. bs = []", "by fast"], ["proof (state)\nthis:\n  bs = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bs = []\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a b bs.\n          xs = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "with snoc asabs(1) y(2)"], ["proof (chain)\npicking this:\n  xs = ys @ [y]\n  ys = as @ [a] @ bs\n  f = F (sum_list (ys @ [y]))\n  bs = []", "have \"xs = as@[a,y]@[]\" \"f = F (sum_list (as@[a,y]))\""], ["proof (prove)\nusing this:\n  xs = ys @ [y]\n  ys = as @ [a] @ bs\n  f = F (sum_list (ys @ [y]))\n  bs = []\n\ngoal (1 subgoal):\n 1. xs = as @ [a, y] @ [] &&& f = F (sum_list (as @ [a, y]))", "by auto"], ["proof (state)\nthis:\n  xs = as @ [a, y] @ []\n  f = F (sum_list (as @ [a, y]))\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       xs = ys @ [y] \\<Longrightarrow>\n       \\<exists>as a b bs.\n          xs = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "with asabs(3,4)"], ["proof (chain)\npicking this:\n  d = F (sum_list as)\n  e = F (sum_list (as @ [a]))\n  xs = as @ [a, y] @ []\n  f = F (sum_list (as @ [a, y]))", "show ?thesis"], ["proof (prove)\nusing this:\n  d = F (sum_list as)\n  e = F (sum_list (as @ [a]))\n  xs = as @ [a, y] @ []\n  f = F (sum_list (as @ [a, y]))\n\ngoal (1 subgoal):\n 1. \\<exists>as a b bs.\n       xs = as @ [a, b] @ bs \\<and>\n       d = F (sum_list as) \\<and>\n       e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "by fast"], ["proof (state)\nthis:\n  \\<exists>as a b bs.\n     xs = as @ [a, b] @ bs \\<and>\n     d = F (sum_list as) \\<and>\n     e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as a b bs.\n     xs = as @ [a, b] @ bs \\<and>\n     d = F (sum_list as) \\<and>\n     e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       map F (sums []) = ds @ [d, e, f] @ ys \\<Longrightarrow>\n       \\<exists>as a b bs.\n          [] = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n 2. \\<And>xs x ys y.\n       \\<lbrakk>map F (sums xs) = ds @ [d, e, f] @ ys \\<Longrightarrow>\n                \\<exists>as a b bs.\n                   xs = as @ [a, b] @ bs \\<and>\n                   d = F (sum_list as) \\<and>\n                   e = F (sum_list (as @ [a])) \\<and>\n                   f = F (sum_list (as @ [a, b]));\n        map F (sums (xs @ [x])) = ds @ [d, e, f] @ ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as a b bs.\n                            xs @ [x] = as @ [a, b] @ bs \\<and>\n                            d = F (sum_list as) \\<and>\n                            e = F (sum_list (as @ [a])) \\<and>\n                            f = F (sum_list (as @ [a, b]))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       map F (sums []) = ds @ [d, e, f] @ ys \\<Longrightarrow>\n       \\<exists>as a b bs.\n          [] = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n 2. \\<And>xs x ys y.\n       \\<lbrakk>map F (sums xs) = ds @ [d, e, f] @ ys \\<Longrightarrow>\n                \\<exists>as a b bs.\n                   xs = as @ [a, b] @ bs \\<and>\n                   d = F (sum_list as) \\<and>\n                   e = F (sum_list (as @ [a])) \\<and>\n                   f = F (sum_list (as @ [a, b]));\n        map F (sums (xs @ [x])) = ds @ [d, e, f] @ ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as a b bs.\n                            xs @ [x] = as @ [a, b] @ bs \\<and>\n                            d = F (sum_list as) \\<and>\n                            e = F (sum_list (as @ [a])) \\<and>\n                            f = F (sum_list (as @ [a, b]))", "case snoc"], ["proof (state)\nthis:\n  map F (sums xs_) = ds @ [d, e, f] @ ys_ \\<Longrightarrow>\n  \\<exists>as a b bs.\n     xs_ = as @ [a, b] @ bs \\<and>\n     d = F (sum_list as) \\<and>\n     e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n  map F (sums (xs_ @ [x_])) = ds @ [d, e, f] @ ys_ @ [y_]\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       map F (sums []) = ds @ [d, e, f] @ ys \\<Longrightarrow>\n       \\<exists>as a b bs.\n          [] = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n 2. \\<And>xs x ys y.\n       \\<lbrakk>map F (sums xs) = ds @ [d, e, f] @ ys \\<Longrightarrow>\n                \\<exists>as a b bs.\n                   xs = as @ [a, b] @ bs \\<and>\n                   d = F (sum_list as) \\<and>\n                   e = F (sum_list (as @ [a])) \\<and>\n                   f = F (sum_list (as @ [a, b]));\n        map F (sums (xs @ [x])) = ds @ [d, e, f] @ ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as a b bs.\n                            xs @ [x] = as @ [a, b] @ bs \\<and>\n                            d = F (sum_list as) \\<and>\n                            e = F (sum_list (as @ [a])) \\<and>\n                            f = F (sum_list (as @ [a, b]))", "thus ?case"], ["proof (prove)\nusing this:\n  map F (sums xs_) = ds @ [d, e, f] @ ys_ \\<Longrightarrow>\n  \\<exists>as a b bs.\n     xs_ = as @ [a, b] @ bs \\<and>\n     d = F (sum_list as) \\<and>\n     e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n  map F (sums (xs_ @ [x_])) = ds @ [d, e, f] @ ys_ @ [y_]\n\ngoal (1 subgoal):\n 1. \\<exists>as a b bs.\n       xs_ @ [x_] = as @ [a, b] @ bs \\<and>\n       d = F (sum_list as) \\<and>\n       e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "by (fastforce simp add: sums_snoc)"], ["proof (state)\nthis:\n  \\<exists>as a b bs.\n     xs_ @ [x_] = as @ [a, b] @ bs \\<and>\n     d = F (sum_list as) \\<and>\n     e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       map F (sums []) = ds @ [d, e, f] @ ys \\<Longrightarrow>\n       \\<exists>as a b bs.\n          [] = as @ [a, b] @ bs \\<and>\n          d = F (sum_list as) \\<and>\n          e = F (sum_list (as @ [a])) \\<and> f = F (sum_list (as @ [a, b]))", "qed simp"], ["", "lemma pullback_sums_map_double_middle2:\n  assumes \"map F (sums xs) = ds@[d,e]@es@[f,g]@gs\"\n  shows   \"\\<exists>as a bs b cs. xs = as@[a]@bs@[b]@cs \\<and> d = F (sum_list as) \\<and>\n            e = F (sum_list (as@[a])) \\<and> f = F (sum_list (as@[a]@bs)) \\<and>\n            g = F (sum_list (as@[a]@bs@[b]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as a bs b cs.\n       xs = as @ [a] @ bs @ [b] @ cs \\<and>\n       d = F (sum_list as) \\<and>\n       e = F (sum_list (as @ [a])) \\<and>\n       f = F (sum_list (as @ [a] @ bs)) \\<and>\n       g = F (sum_list (as @ [a] @ bs @ [b]))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as a bs b cs.\n       xs = as @ [a] @ bs @ [b] @ cs \\<and>\n       d = F (sum_list as) \\<and>\n       e = F (sum_list (as @ [a])) \\<and>\n       f = F (sum_list (as @ [a] @ bs)) \\<and>\n       g = F (sum_list (as @ [a] @ bs @ [b]))", "from assms"], ["proof (chain)\npicking this:\n  map F (sums xs) = ds @ [d, e] @ es @ [f, g] @ gs", "obtain As b cs where Asbcs:\n    \"xs = As@[b]@cs\" \"map F (sums As) = ds@[d,e]@es@[f]\"\n    \"f = F (sum_list As)\" \"g = F (sum_list (As@[b]))\""], ["proof (prove)\nusing this:\n  map F (sums xs) = ds @ [d, e] @ es @ [f, g] @ gs\n\ngoal (1 subgoal):\n 1. (\\<And>As b cs.\n        \\<lbrakk>xs = As @ [b] @ cs;\n         map F (sums As) = ds @ [d, e] @ es @ [f]; f = F (sum_list As);\n         g = F (sum_list (As @ [b]))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using pullback_sums_map_middle2[of F xs \"ds@[d,e]@es\"]"], ["proof (prove)\nusing this:\n  map F (sums xs) = ds @ [d, e] @ es @ [f, g] @ gs\n  map F (sums xs) = (ds @ [d, e] @ es) @ [?d, ?e] @ ?es \\<Longrightarrow>\n  \\<exists>as a bs.\n     xs = as @ [a] @ bs \\<and>\n     map F (sums as) = (ds @ [d, e] @ es) @ [?d] \\<and>\n     ?d = F (sum_list as) \\<and> ?e = F (sum_list (as @ [a]))\n\ngoal (1 subgoal):\n 1. (\\<And>As b cs.\n        \\<lbrakk>xs = As @ [b] @ cs;\n         map F (sums As) = ds @ [d, e] @ es @ [f]; f = F (sum_list As);\n         g = F (sum_list (As @ [b]))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fastforce"], ["proof (state)\nthis:\n  xs = As @ [b] @ cs\n  map F (sums As) = ds @ [d, e] @ es @ [f]\n  f = F (sum_list As)\n  g = F (sum_list (As @ [b]))\n\ngoal (1 subgoal):\n 1. \\<exists>as a bs b cs.\n       xs = as @ [a] @ bs @ [b] @ cs \\<and>\n       d = F (sum_list as) \\<and>\n       e = F (sum_list (as @ [a])) \\<and>\n       f = F (sum_list (as @ [a] @ bs)) \\<and>\n       g = F (sum_list (as @ [a] @ bs @ [b]))", "from Asbcs"], ["proof (chain)\npicking this:\n  xs = As @ [b] @ cs\n  map F (sums As) = ds @ [d, e] @ es @ [f]\n  f = F (sum_list As)\n  g = F (sum_list (As @ [b]))", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = As @ [b] @ cs\n  map F (sums As) = ds @ [d, e] @ es @ [f]\n  f = F (sum_list As)\n  g = F (sum_list (As @ [b]))\n\ngoal (1 subgoal):\n 1. \\<exists>as a bs b cs.\n       xs = as @ [a] @ bs @ [b] @ cs \\<and>\n       d = F (sum_list as) \\<and>\n       e = F (sum_list (as @ [a])) \\<and>\n       f = F (sum_list (as @ [a] @ bs)) \\<and>\n       g = F (sum_list (as @ [a] @ bs @ [b]))", "using pullback_sums_map_middle2[of F As ds d e \"es@[f]\"]"], ["proof (prove)\nusing this:\n  xs = As @ [b] @ cs\n  map F (sums As) = ds @ [d, e] @ es @ [f]\n  f = F (sum_list As)\n  g = F (sum_list (As @ [b]))\n  map F (sums As) = ds @ [d, e] @ es @ [f] \\<Longrightarrow>\n  \\<exists>as a bs.\n     As = as @ [a] @ bs \\<and>\n     map F (sums as) = ds @ [d] \\<and>\n     d = F (sum_list as) \\<and> e = F (sum_list (as @ [a]))\n\ngoal (1 subgoal):\n 1. \\<exists>as a bs b cs.\n       xs = as @ [a] @ bs @ [b] @ cs \\<and>\n       d = F (sum_list as) \\<and>\n       e = F (sum_list (as @ [a])) \\<and>\n       f = F (sum_list (as @ [a] @ bs)) \\<and>\n       g = F (sum_list (as @ [a] @ bs @ [b]))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as a bs b cs.\n     xs = as @ [a] @ bs @ [b] @ cs \\<and>\n     d = F (sum_list as) \\<and>\n     e = F (sum_list (as @ [a])) \\<and>\n     f = F (sum_list (as @ [a] @ bs)) \\<and>\n     g = F (sum_list (as @ [a] @ bs @ [b]))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context monoid_add *)"], ["", "subsection \\<open>Sums of alternating lists\\<close>"], ["", "lemma (in group_add) uminus_sum_list_alternating_order2:\n  \"s+s=0 \\<Longrightarrow> t+t=0 \\<Longrightarrow> - sum_list (alternating_list n s t) =\n    sum_list (if even n then alternating_list n t s else alternating_list n s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s + s = (0::'a); t + t = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> - sum_list (alternating_list n s t) =\n                      sum_list\n                       (if gcd_nat.greater_eq n 2\n                        then alternating_list n t s\n                        else alternating_list n s t)", "using uminus_sum_list_order2 set_alternating_list[of n] rev_alternating_list[of n s]"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>set ?ss. s + s = (0::'a) \\<Longrightarrow>\n  - sum_list ?ss = sum_list (rev ?ss)\n  order.greater_eq {?s, ?t} (set (alternating_list n ?s ?t))\n  rev (alternating_list n s ?t) =\n  (if gcd_nat.greater_eq n 2 then alternating_list n ?t s\n   else alternating_list n s ?t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s + s = (0::'a); t + t = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> - sum_list (alternating_list n s t) =\n                      sum_list\n                       (if gcd_nat.greater_eq n 2\n                        then alternating_list n t s\n                        else alternating_list n s t)", "by    fastforce"], ["", "context monoid_add\nbegin"], ["", "lemma alternating_order2_cancel_1left:\n  \"s+s=0 \\<Longrightarrow>\n    sum_list (s # (alternating_list (Suc n) s t)) = sum_list (alternating_list n t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + s = (0::'a) \\<Longrightarrow>\n    sum_list (s # alternating_list (Suc n) s t) =\n    sum_list (alternating_list n t s)", "using add.assoc[of s s] alternating_list_Suc_Cons[of n s]"], ["proof (prove)\nusing this:\n  s + s + ?c = s + (s + ?c)\n  alternating_list (Suc n) s ?t = s # alternating_list n ?t s\n\ngoal (1 subgoal):\n 1. s + s = (0::'a) \\<Longrightarrow>\n    sum_list (s # alternating_list (Suc n) s t) =\n    sum_list (alternating_list n t s)", "by simp"], ["", "lemma alternating_order2_cancel_2left:\n  \"s+s=0 \\<Longrightarrow> t+t=0 \\<Longrightarrow>\n    sum_list (t # s # (alternating_list (Suc (Suc n)) s t)) =\n      sum_list (alternating_list n s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s + s = (0::'a); t + t = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> sum_list\n                       (t # s # alternating_list (Suc (Suc n)) s t) =\n                      sum_list (alternating_list n s t)", "using alternating_order2_cancel_1left[of s \"Suc n\"]\n          alternating_order2_cancel_1left[of t n]"], ["proof (prove)\nusing this:\n  s + s = (0::'a) \\<Longrightarrow>\n  sum_list (s # alternating_list (Suc (Suc n)) s ?t) =\n  sum_list (alternating_list (Suc n) ?t s)\n  t + t = (0::'a) \\<Longrightarrow>\n  sum_list (t # alternating_list (Suc n) t ?t) =\n  sum_list (alternating_list n ?t t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s + s = (0::'a); t + t = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> sum_list\n                       (t # s # alternating_list (Suc (Suc n)) s t) =\n                      sum_list (alternating_list n s t)", "by    simp"], ["", "lemma alternating_order2_even_cancel_right:\n  assumes st    : \"s+s=0\" \"t+t=0\"\n  and     even_n: \"even n\"\n  shows   \"m \\<le> n \\<Longrightarrow> sum_list (alternating_list n s t @ alternating_list m t s) =\n            sum_list (alternating_list (n-m) s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq n m \\<Longrightarrow>\n    sum_list (alternating_list n s t @ alternating_list m t s) =\n    sum_list (alternating_list (n - m) s t)", "proof (induct n arbitrary: m rule: nat_even_induct, rule even_n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       order.greater_eq 0 m \\<Longrightarrow>\n       sum_list (alternating_list 0 s t @ alternating_list m t s) =\n       sum_list (alternating_list (0 - m) s t)\n 2. \\<And>m ma.\n       \\<lbrakk>gcd_nat.greater_eq m 2;\n        \\<And>ma.\n           order.greater_eq m ma \\<Longrightarrow>\n           sum_list (alternating_list m s t @ alternating_list ma t s) =\n           sum_list (alternating_list (m - ma) s t);\n        order.greater_eq (Suc (Suc m)) ma\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (alternating_list (Suc (Suc m)) s t @\n                           alternating_list ma t s) =\n                         sum_list (alternating_list (Suc (Suc m) - ma) s t)", "case (SucSuc k)"], ["proof (state)\nthis:\n  gcd_nat.greater_eq k 2\n  order.greater_eq k ?m \\<Longrightarrow>\n  sum_list (alternating_list k s t @ alternating_list ?m t s) =\n  sum_list (alternating_list (k - ?m) s t)\n  order.greater_eq (Suc (Suc k)) m\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       order.greater_eq 0 m \\<Longrightarrow>\n       sum_list (alternating_list 0 s t @ alternating_list m t s) =\n       sum_list (alternating_list (0 - m) s t)\n 2. \\<And>m ma.\n       \\<lbrakk>gcd_nat.greater_eq m 2;\n        \\<And>ma.\n           order.greater_eq m ma \\<Longrightarrow>\n           sum_list (alternating_list m s t @ alternating_list ma t s) =\n           sum_list (alternating_list (m - ma) s t);\n        order.greater_eq (Suc (Suc m)) ma\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (alternating_list (Suc (Suc m)) s t @\n                           alternating_list ma t s) =\n                         sum_list (alternating_list (Suc (Suc m) - ma) s t)", "with st"], ["proof (chain)\npicking this:\n  s + s = (0::'a)\n  t + t = (0::'a)\n  gcd_nat.greater_eq k 2\n  order.greater_eq k ?m \\<Longrightarrow>\n  sum_list (alternating_list k s t @ alternating_list ?m t s) =\n  sum_list (alternating_list (k - ?m) s t)\n  order.greater_eq (Suc (Suc k)) m", "show ?case"], ["proof (prove)\nusing this:\n  s + s = (0::'a)\n  t + t = (0::'a)\n  gcd_nat.greater_eq k 2\n  order.greater_eq k ?m \\<Longrightarrow>\n  sum_list (alternating_list k s t @ alternating_list ?m t s) =\n  sum_list (alternating_list (k - ?m) s t)\n  order.greater_eq (Suc (Suc k)) m\n\ngoal (1 subgoal):\n 1. sum_list (alternating_list (Suc (Suc k)) s t @ alternating_list m t s) =\n    sum_list (alternating_list (Suc (Suc k) - m) s t)", "using alternating_order2_cancel_2left[of t s]"], ["proof (prove)\nusing this:\n  s + s = (0::'a)\n  t + t = (0::'a)\n  gcd_nat.greater_eq k 2\n  order.greater_eq k ?m \\<Longrightarrow>\n  sum_list (alternating_list k s t @ alternating_list ?m t s) =\n  sum_list (alternating_list (k - ?m) s t)\n  order.greater_eq (Suc (Suc k)) m\n  \\<lbrakk>t + t = (0::'a); s + s = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> sum_list (s # t # alternating_list (Suc (Suc ?n)) t s) =\n                    sum_list (alternating_list ?n t s)\n\ngoal (1 subgoal):\n 1. sum_list (alternating_list (Suc (Suc k)) s t @ alternating_list m t s) =\n    sum_list (alternating_list (Suc (Suc k) - m) s t)", "by    (cases m rule: nat_cases_2Suc) auto"], ["proof (state)\nthis:\n  sum_list (alternating_list (Suc (Suc k)) s t @ alternating_list m t s) =\n  sum_list (alternating_list (Suc (Suc k) - m) s t)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       order.greater_eq 0 m \\<Longrightarrow>\n       sum_list (alternating_list 0 s t @ alternating_list m t s) =\n       sum_list (alternating_list (0 - m) s t)", "qed simp"], ["", "end"], ["", "(* context monoid_add *)"], ["", "subsection \\<open>Conjugation in @{class group_add}\\<close>"], ["", "subsubsection \\<open>Abbreviations and basic facts\\<close>"], ["", "context group_add\nbegin"], ["", "abbreviation lconjby :: \"'a\\<Rightarrow>'a\\<Rightarrow>'a\"\n  where \"lconjby x y \\<equiv> x+y-x\""], ["", "abbreviation rconjby :: \"'a\\<Rightarrow>'a\\<Rightarrow>'a\"\n  where \"rconjby x y \\<equiv> -x+y+x\""], ["", "lemma lconjby_add: \"lconjby (x+y) z = lconjby x (lconjby y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconjby (x + y) z = lconjby x (lconjby y z)", "by (auto simp add: algebra_simps)"], ["", "lemma rconjby_add: \"rconjby (x+y) z = rconjby y (rconjby x z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rconjby (x + y) z = rconjby y (rconjby x z)", "by (simp add: minus_add add.assoc[THEN sym])"], ["", "lemma add_rconjby: \"rconjby x y + rconjby x z = rconjby x (y+z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rconjby x y + rconjby x z = rconjby x (y + z)", "by (simp add: add.assoc)"], ["", "lemma lconjby_uminus: \"lconjby x (-y) = - lconjby x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconjby x (- y) = - lconjby x y", "using minus_unique[of \"lconjby x y\", THEN sym]"], ["proof (prove)\nusing this:\n  lconjby x y + ?t = (0::'a) \\<Longrightarrow> ?t = - lconjby x y\n\ngoal (1 subgoal):\n 1. lconjby x (- y) = - lconjby x y", "by (simp add: algebra_simps)"], ["", "lemma rconjby_uminus: \"rconjby x (-y) = - rconjby x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rconjby x (- y) = - rconjby x y", "using minus_unique[of \"rconjby x y\"] add_assoc4[of \"rconjby x y\" \"-x\" \"-y\" x]"], ["proof (prove)\nusing this:\n  rconjby x y + ?b = (0::'a) \\<Longrightarrow> - rconjby x y = ?b\n  rconjby x y + - x + - y + x = rconjby x y + rconjby x (- y)\n\ngoal (1 subgoal):\n 1. rconjby x (- y) = - rconjby x y", "by simp"], ["", "lemma lconjby_rconjby: \"lconjby x (rconjby x y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconjby x (rconjby x y) = y", "by (simp add: algebra_simps)"], ["", "lemma rconjby_lconjby: \"rconjby x (lconjby x y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rconjby x (lconjby x y) = y", "by (simp add: algebra_simps)"], ["", "lemma lconjby_inj: \"inj (lconjby x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (lconjby x)", "using rconjby_lconjby"], ["proof (prove)\nusing this:\n  rconjby ?x (lconjby ?x ?y) = ?y\n\ngoal (1 subgoal):\n 1. inj (lconjby x)", "by (fast intro: inj_on_inverseI)"], ["", "lemma rconjby_inj: \"inj (rconjby x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (rconjby x)", "using lconjby_rconjby"], ["proof (prove)\nusing this:\n  lconjby ?x (rconjby ?x ?y) = ?y\n\ngoal (1 subgoal):\n 1. inj (rconjby x)", "by (fast intro: inj_on_inverseI)"], ["", "lemma lconjby_surj: \"surj (lconjby x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj (lconjby x)", "using lconjby_rconjby surjI[of \"lconjby x\"]"], ["proof (prove)\nusing this:\n  lconjby ?x (rconjby ?x ?y) = ?y\n  (\\<And>xa. lconjby x (?f xa) = xa) \\<Longrightarrow> surj (lconjby x)\n\ngoal (1 subgoal):\n 1. surj (lconjby x)", "by fast"], ["", "lemma lconjby_bij: \"bij (lconjby x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (lconjby x)", "unfolding bij_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (lconjby x) \\<and> surj (lconjby x)", "using lconjby_inj lconjby_surj"], ["proof (prove)\nusing this:\n  inj (lconjby ?x)\n  surj (lconjby ?x)\n\ngoal (1 subgoal):\n 1. inj (lconjby x) \\<and> surj (lconjby x)", "by fast"], ["", "lemma the_inv_lconjby: \"the_inv (lconjby x) = (rconjby x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv (lconjby x) = rconjby x", "using bij_betw_f_the_inv_into_f[OF lconjby_bij, of _ x] lconjby_rconjby"], ["proof (prove)\nusing this:\n  ?y \\<in> UNIV \\<Longrightarrow> lconjby x (the_inv (lconjby x) ?y) = ?y\n  lconjby ?x (rconjby ?x ?y) = ?y\n\ngoal (1 subgoal):\n 1. the_inv (lconjby x) = rconjby x", "by    (force intro: inj_onD[OF lconjby_inj, of x])"], ["", "lemma lconjby_eq_conv_rconjby_eq: \"w = lconjby x y \\<Longrightarrow> y = rconjby x w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = lconjby x y \\<Longrightarrow> y = rconjby x w", "using the_inv_lconjby the_inv_into_f_f[OF lconjby_inj]"], ["proof (prove)\nusing this:\n  the_inv (lconjby ?x) = rconjby ?x\n  ?x \\<in> UNIV \\<Longrightarrow>\n  the_inv (lconjby ?x1) (lconjby ?x1 ?x) = ?x\n\ngoal (1 subgoal):\n 1. w = lconjby x y \\<Longrightarrow> y = rconjby x w", "by force"], ["", "lemma rconjby_order2: \"s+s = 0 \\<Longrightarrow> rconjby x s + rconjby x s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + s = (0::'a) \\<Longrightarrow> rconjby x s + rconjby x s = (0::'a)", "by (simp add: add_rconjby)"], ["", "lemma rconjby_order2_eq_lconjby:\n  assumes \"s+s=0\"\n  shows   \"rconjby s = lconjby s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rconjby s = lconjby s", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. rconjby s = lconjby s", "have \"rconjby s = lconjby (-s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rconjby s = lconjby (- s)", "by simp"], ["proof (state)\nthis:\n  rconjby s = lconjby (- s)\n\ngoal (1 subgoal):\n 1. rconjby s = lconjby s", "with assms"], ["proof (chain)\npicking this:\n  s + s = (0::'a)\n  rconjby s = lconjby (- s)", "show ?thesis"], ["proof (prove)\nusing this:\n  s + s = (0::'a)\n  rconjby s = lconjby (- s)\n\ngoal (1 subgoal):\n 1. rconjby s = lconjby s", "using minus_unique"], ["proof (prove)\nusing this:\n  s + s = (0::'a)\n  rconjby s = lconjby (- s)\n  ?a + ?b = (0::'a) \\<Longrightarrow> - ?a = ?b\n\ngoal (1 subgoal):\n 1. rconjby s = lconjby s", "by simp"], ["proof (state)\nthis:\n  rconjby s = lconjby s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lconjby_alternating_list_order2:\n  assumes \"s+s=0\" \"t+t=0\"\n  shows   \"lconjby (sum_list (alternating_list k s t)) (if even k then s else t) =\n            sum_list (alternating_list (Suc (2*k)) s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconjby (sum_list (alternating_list k s t))\n     (if gcd_nat.greater_eq k 2 then s else t) =\n    sum_list (alternating_list (Suc (2 * k)) s t)", "proof (induct k rule: nat_induct_step2)"], ["proof (state)\ngoal (3 subgoals):\n 1. lconjby (sum_list (alternating_list 0 s t))\n     (if gcd_nat.greater_eq 0 2 then s else t) =\n    sum_list (alternating_list (Suc (2 * 0)) s t)\n 2. lconjby (sum_list (alternating_list 1 s t))\n     (if gcd_nat.greater_eq 1 2 then s else t) =\n    sum_list (alternating_list (Suc (2 * 1)) s t)\n 3. \\<And>m.\n       lconjby (sum_list (alternating_list m s t))\n        (if gcd_nat.greater_eq m 2 then s else t) =\n       sum_list (alternating_list (Suc (2 * m)) s t) \\<Longrightarrow>\n       lconjby (sum_list (alternating_list (Suc (Suc m)) s t))\n        (if gcd_nat.greater_eq (Suc (Suc m)) 2 then s else t) =\n       sum_list (alternating_list (Suc (2 * Suc (Suc m))) s t)", "case (SucSuc m)"], ["proof (state)\nthis:\n  lconjby (sum_list (alternating_list m s t))\n   (if gcd_nat.greater_eq m 2 then s else t) =\n  sum_list (alternating_list (Suc (2 * m)) s t)\n\ngoal (3 subgoals):\n 1. lconjby (sum_list (alternating_list 0 s t))\n     (if gcd_nat.greater_eq 0 2 then s else t) =\n    sum_list (alternating_list (Suc (2 * 0)) s t)\n 2. lconjby (sum_list (alternating_list 1 s t))\n     (if gcd_nat.greater_eq 1 2 then s else t) =\n    sum_list (alternating_list (Suc (2 * 1)) s t)\n 3. \\<And>m.\n       lconjby (sum_list (alternating_list m s t))\n        (if gcd_nat.greater_eq m 2 then s else t) =\n       sum_list (alternating_list (Suc (2 * m)) s t) \\<Longrightarrow>\n       lconjby (sum_list (alternating_list (Suc (Suc m)) s t))\n        (if gcd_nat.greater_eq (Suc (Suc m)) 2 then s else t) =\n       sum_list (alternating_list (Suc (2 * Suc (Suc m))) s t)", "have \"lconjby (sum_list (alternating_list (Suc (Suc m)) s t))\n          (if even (Suc (Suc m)) then s else t) = s + t +\n          lconjby (sum_list (alternating_list m s t)) (if even m then s else t) - t - s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconjby (sum_list (alternating_list (Suc (Suc m)) s t))\n     (if gcd_nat.greater_eq (Suc (Suc m)) 2 then s else t) =\n    s + t +\n    lconjby (sum_list (alternating_list m s t))\n     (if gcd_nat.greater_eq m 2 then s else t) -\n    t -\n    s", "using alternating_list_SucSuc_ConsCons[of m s t]"], ["proof (prove)\nusing this:\n  alternating_list (Suc (Suc m)) s t = s # t # alternating_list m s t\n\ngoal (1 subgoal):\n 1. lconjby (sum_list (alternating_list (Suc (Suc m)) s t))\n     (if gcd_nat.greater_eq (Suc (Suc m)) 2 then s else t) =\n    s + t +\n    lconjby (sum_list (alternating_list m s t))\n     (if gcd_nat.greater_eq m 2 then s else t) -\n    t -\n    s", "by    (simp add: algebra_simps)"], ["proof (state)\nthis:\n  lconjby (sum_list (alternating_list (Suc (Suc m)) s t))\n   (if gcd_nat.greater_eq (Suc (Suc m)) 2 then s else t) =\n  s + t +\n  lconjby (sum_list (alternating_list m s t))\n   (if gcd_nat.greater_eq m 2 then s else t) -\n  t -\n  s\n\ngoal (3 subgoals):\n 1. lconjby (sum_list (alternating_list 0 s t))\n     (if gcd_nat.greater_eq 0 2 then s else t) =\n    sum_list (alternating_list (Suc (2 * 0)) s t)\n 2. lconjby (sum_list (alternating_list 1 s t))\n     (if gcd_nat.greater_eq 1 2 then s else t) =\n    sum_list (alternating_list (Suc (2 * 1)) s t)\n 3. \\<And>m.\n       lconjby (sum_list (alternating_list m s t))\n        (if gcd_nat.greater_eq m 2 then s else t) =\n       sum_list (alternating_list (Suc (2 * m)) s t) \\<Longrightarrow>\n       lconjby (sum_list (alternating_list (Suc (Suc m)) s t))\n        (if gcd_nat.greater_eq (Suc (Suc m)) 2 then s else t) =\n       sum_list (alternating_list (Suc (2 * Suc (Suc m))) s t)", "also"], ["proof (state)\nthis:\n  lconjby (sum_list (alternating_list (Suc (Suc m)) s t))\n   (if gcd_nat.greater_eq (Suc (Suc m)) 2 then s else t) =\n  s + t +\n  lconjby (sum_list (alternating_list m s t))\n   (if gcd_nat.greater_eq m 2 then s else t) -\n  t -\n  s\n\ngoal (3 subgoals):\n 1. lconjby (sum_list (alternating_list 0 s t))\n     (if gcd_nat.greater_eq 0 2 then s else t) =\n    sum_list (alternating_list (Suc (2 * 0)) s t)\n 2. lconjby (sum_list (alternating_list 1 s t))\n     (if gcd_nat.greater_eq 1 2 then s else t) =\n    sum_list (alternating_list (Suc (2 * 1)) s t)\n 3. \\<And>m.\n       lconjby (sum_list (alternating_list m s t))\n        (if gcd_nat.greater_eq m 2 then s else t) =\n       sum_list (alternating_list (Suc (2 * m)) s t) \\<Longrightarrow>\n       lconjby (sum_list (alternating_list (Suc (Suc m)) s t))\n        (if gcd_nat.greater_eq (Suc (Suc m)) 2 then s else t) =\n       sum_list (alternating_list (Suc (2 * Suc (Suc m))) s t)", "from assms SucSuc"], ["proof (chain)\npicking this:\n  s + s = (0::'a)\n  t + t = (0::'a)\n  lconjby (sum_list (alternating_list m s t))\n   (if gcd_nat.greater_eq m 2 then s else t) =\n  sum_list (alternating_list (Suc (2 * m)) s t)", "have  \"\\<dots> = sum_list (alternating_list (Suc (2*Suc (Suc m))) s t)\""], ["proof (prove)\nusing this:\n  s + s = (0::'a)\n  t + t = (0::'a)\n  lconjby (sum_list (alternating_list m s t))\n   (if gcd_nat.greater_eq m 2 then s else t) =\n  sum_list (alternating_list (Suc (2 * m)) s t)\n\ngoal (1 subgoal):\n 1. s + t +\n    lconjby (sum_list (alternating_list m s t))\n     (if gcd_nat.greater_eq m 2 then s else t) -\n    t -\n    s =\n    sum_list (alternating_list (Suc (2 * Suc (Suc m))) s t)", "using alternating_list_SucSuc_ConsCons[of \"Suc (2*m)\" s t]\n          sum_list.append[of \"alternating_list (Suc (2*Suc m)) s t\" \"[t]\"]"], ["proof (prove)\nusing this:\n  s + s = (0::'a)\n  t + t = (0::'a)\n  lconjby (sum_list (alternating_list m s t))\n   (if gcd_nat.greater_eq m 2 then s else t) =\n  sum_list (alternating_list (Suc (2 * m)) s t)\n  alternating_list (Suc (Suc (Suc (2 * m)))) s t =\n  s # t # alternating_list (Suc (2 * m)) s t\n  sum_list (alternating_list (Suc (2 * Suc m)) s t @ [t]) =\n  sum_list (alternating_list (Suc (2 * Suc m)) s t) + sum_list [t]\n\ngoal (1 subgoal):\n 1. s + t +\n    lconjby (sum_list (alternating_list m s t))\n     (if gcd_nat.greater_eq m 2 then s else t) -\n    t -\n    s =\n    sum_list (alternating_list (Suc (2 * Suc (Suc m))) s t)", "by    (simp add: algebra_simps)"], ["proof (state)\nthis:\n  s + t +\n  lconjby (sum_list (alternating_list m s t))\n   (if gcd_nat.greater_eq m 2 then s else t) -\n  t -\n  s =\n  sum_list (alternating_list (Suc (2 * Suc (Suc m))) s t)\n\ngoal (3 subgoals):\n 1. lconjby (sum_list (alternating_list 0 s t))\n     (if gcd_nat.greater_eq 0 2 then s else t) =\n    sum_list (alternating_list (Suc (2 * 0)) s t)\n 2. lconjby (sum_list (alternating_list 1 s t))\n     (if gcd_nat.greater_eq 1 2 then s else t) =\n    sum_list (alternating_list (Suc (2 * 1)) s t)\n 3. \\<And>m.\n       lconjby (sum_list (alternating_list m s t))\n        (if gcd_nat.greater_eq m 2 then s else t) =\n       sum_list (alternating_list (Suc (2 * m)) s t) \\<Longrightarrow>\n       lconjby (sum_list (alternating_list (Suc (Suc m)) s t))\n        (if gcd_nat.greater_eq (Suc (Suc m)) 2 then s else t) =\n       sum_list (alternating_list (Suc (2 * Suc (Suc m))) s t)", "finally"], ["proof (chain)\npicking this:\n  lconjby (sum_list (alternating_list (Suc (Suc m)) s t))\n   (if gcd_nat.greater_eq (Suc (Suc m)) 2 then s else t) =\n  sum_list (alternating_list (Suc (2 * Suc (Suc m))) s t)", "show ?case"], ["proof (prove)\nusing this:\n  lconjby (sum_list (alternating_list (Suc (Suc m)) s t))\n   (if gcd_nat.greater_eq (Suc (Suc m)) 2 then s else t) =\n  sum_list (alternating_list (Suc (2 * Suc (Suc m))) s t)\n\ngoal (1 subgoal):\n 1. lconjby (sum_list (alternating_list (Suc (Suc m)) s t))\n     (if gcd_nat.greater_eq (Suc (Suc m)) 2 then s else t) =\n    sum_list (alternating_list (Suc (2 * Suc (Suc m))) s t)", "by fast"], ["proof (state)\nthis:\n  lconjby (sum_list (alternating_list (Suc (Suc m)) s t))\n   (if gcd_nat.greater_eq (Suc (Suc m)) 2 then s else t) =\n  sum_list (alternating_list (Suc (2 * Suc (Suc m))) s t)\n\ngoal (2 subgoals):\n 1. lconjby (sum_list (alternating_list 0 s t))\n     (if gcd_nat.greater_eq 0 2 then s else t) =\n    sum_list (alternating_list (Suc (2 * 0)) s t)\n 2. lconjby (sum_list (alternating_list 1 s t))\n     (if gcd_nat.greater_eq 1 2 then s else t) =\n    sum_list (alternating_list (Suc (2 * 1)) s t)", "qed (auto simp add: assms(1) algebra_simps)"], ["", "end"], ["", "(* context group_add *)"], ["", "subsubsection \\<open>The conjugation sequence\\<close>"], ["", "text \\<open>\n  Given a list in @{class group_add}, we create a new list by conjugating each term by all the\n  previous terms. This sequence arises in Coxeter systems.\n\\<close>"], ["", "context group_add\nbegin"], ["", "primrec lconjseq :: \"'a list \\<Rightarrow> 'a list\"\n  where\n    \"lconjseq []     = []\"\n  | \"lconjseq (x#xs) = x # (map (lconjby x) (lconjseq xs))\""], ["", "lemma length_lconjseq: \"length (lconjseq xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (lconjseq xs) = length xs", "by (induct xs) auto"], ["", "lemma lconjseq_snoc: \"lconjseq (xs@[x]) = lconjseq xs @ [lconjby (sum_list xs) x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconjseq (xs @ [x]) = lconjseq xs @ [lconjby (sum_list xs) x]", "by (induct xs) (auto simp add: lconjby_add)"], ["", "lemma lconjseq_append:\n  \"lconjseq (xs@ys) = lconjseq xs @ (map (lconjby (sum_list xs)) (lconjseq ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconjseq (xs @ ys) =\n    lconjseq xs @ map (lconjby (sum_list xs)) (lconjseq ys)", "proof (induct ys rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. lconjseq (xs @ []) =\n    lconjseq xs @ map (lconjby (sum_list xs)) (lconjseq [])\n 2. \\<And>x xsa.\n       lconjseq (xs @ xsa) =\n       lconjseq xs @\n       map (lconjby (sum_list xs)) (lconjseq xsa) \\<Longrightarrow>\n       lconjseq (xs @ xsa @ [x]) =\n       lconjseq xs @ map (lconjby (sum_list xs)) (lconjseq (xsa @ [x]))", "case (snoc y ys)"], ["proof (state)\nthis:\n  lconjseq (xs @ ys) =\n  lconjseq xs @ map (lconjby (sum_list xs)) (lconjseq ys)\n\ngoal (2 subgoals):\n 1. lconjseq (xs @ []) =\n    lconjseq xs @ map (lconjby (sum_list xs)) (lconjseq [])\n 2. \\<And>x xsa.\n       lconjseq (xs @ xsa) =\n       lconjseq xs @\n       map (lconjby (sum_list xs)) (lconjseq xsa) \\<Longrightarrow>\n       lconjseq (xs @ xsa @ [x]) =\n       lconjseq xs @ map (lconjby (sum_list xs)) (lconjseq (xsa @ [x]))", "thus ?case"], ["proof (prove)\nusing this:\n  lconjseq (xs @ ys) =\n  lconjseq xs @ map (lconjby (sum_list xs)) (lconjseq ys)\n\ngoal (1 subgoal):\n 1. lconjseq (xs @ ys @ [y]) =\n    lconjseq xs @ map (lconjby (sum_list xs)) (lconjseq (ys @ [y]))", "using lconjseq_snoc[of \"xs@ys\"] lconjseq_snoc[of ys]"], ["proof (prove)\nusing this:\n  lconjseq (xs @ ys) =\n  lconjseq xs @ map (lconjby (sum_list xs)) (lconjseq ys)\n  lconjseq ((xs @ ys) @ [?x]) =\n  lconjseq (xs @ ys) @ [lconjby (sum_list (xs @ ys)) ?x]\n  lconjseq (ys @ [?x]) = lconjseq ys @ [lconjby (sum_list ys) ?x]\n\ngoal (1 subgoal):\n 1. lconjseq (xs @ ys @ [y]) =\n    lconjseq xs @ map (lconjby (sum_list xs)) (lconjseq (ys @ [y]))", "by (simp add: lconjby_add)"], ["proof (state)\nthis:\n  lconjseq (xs @ ys @ [y]) =\n  lconjseq xs @ map (lconjby (sum_list xs)) (lconjseq (ys @ [y]))\n\ngoal (1 subgoal):\n 1. lconjseq (xs @ []) =\n    lconjseq xs @ map (lconjby (sum_list xs)) (lconjseq [])", "qed simp"], ["", "lemma lconjseq_alternating_order2_repeats':\n  fixes   s t :: 'a\n  defines altst: \"altst \\<equiv> \\<lambda>n. alternating_list n s t\"\n  and     altts: \"altts \\<equiv> \\<lambda>n. alternating_list n t s\"\n  assumes st   : \"s+s=0\" \"t+t=0\" \"(s+t)+^k = 0\"\n  shows   \"map (lconjby (sum_list (altst k)))\n            (lconjseq (if even k then altst m else altts m)) = lconjseq (altst m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (lconjby (sum_list (altst k)))\n     (lconjseq (if gcd_nat.greater_eq k 2 then altst m else altts m)) =\n    lconjseq (altst m)", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. map (lconjby (sum_list (altst k)))\n     (lconjseq (if gcd_nat.greater_eq k 2 then altst 0 else altts 0)) =\n    lconjseq (altst 0)\n 2. \\<And>m.\n       map (lconjby (sum_list (altst k)))\n        (lconjseq (if gcd_nat.greater_eq k 2 then altst m else altts m)) =\n       lconjseq (altst m) \\<Longrightarrow>\n       map (lconjby (sum_list (altst k)))\n        (lconjseq\n          (if gcd_nat.greater_eq k 2 then altst (Suc m)\n           else altts (Suc m))) =\n       lconjseq (altst (Suc m))", "case (Suc j)"], ["proof (state)\nthis:\n  map (lconjby (sum_list (altst k)))\n   (lconjseq (if gcd_nat.greater_eq k 2 then altst j else altts j)) =\n  lconjseq (altst j)\n\ngoal (2 subgoals):\n 1. map (lconjby (sum_list (altst k)))\n     (lconjseq (if gcd_nat.greater_eq k 2 then altst 0 else altts 0)) =\n    lconjseq (altst 0)\n 2. \\<And>m.\n       map (lconjby (sum_list (altst k)))\n        (lconjseq (if gcd_nat.greater_eq k 2 then altst m else altts m)) =\n       lconjseq (altst m) \\<Longrightarrow>\n       map (lconjby (sum_list (altst k)))\n        (lconjseq\n          (if gcd_nat.greater_eq k 2 then altst (Suc m)\n           else altts (Suc m))) =\n       lconjseq (altst (Suc m))", "with altst altts"], ["proof (chain)\npicking this:\n  altst \\<equiv> \\<lambda>n. alternating_list n s t\n  altts \\<equiv> \\<lambda>n. alternating_list n t s\n  map (lconjby (sum_list (altst k)))\n   (lconjseq (if gcd_nat.greater_eq k 2 then altst j else altts j)) =\n  lconjseq (altst j)", "have  \"map (lconjby (sum_list (altst k)))\n            (lconjseq (if even k then altst (Suc j) else altts (Suc j))) =\n            lconjseq (altst j) @\n            [lconjby (sum_list (altst k @ (if even k then altst j else altts j)))\n            (if even k then (if even j then s else t) else (if even j then t else s))]\""], ["proof (prove)\nusing this:\n  altst \\<equiv> \\<lambda>n. alternating_list n s t\n  altts \\<equiv> \\<lambda>n. alternating_list n t s\n  map (lconjby (sum_list (altst k)))\n   (lconjseq (if gcd_nat.greater_eq k 2 then altst j else altts j)) =\n  lconjseq (altst j)\n\ngoal (1 subgoal):\n 1. map (lconjby (sum_list (altst k)))\n     (lconjseq\n       (if gcd_nat.greater_eq k 2 then altst (Suc j) else altts (Suc j))) =\n    lconjseq (altst j) @\n    [lconjby\n      (sum_list\n        (altst k @ (if gcd_nat.greater_eq k 2 then altst j else altts j)))\n      (if gcd_nat.greater_eq k 2\n       then if gcd_nat.greater_eq j 2 then s else t\n       else if gcd_nat.greater_eq j 2 then t else s)]", "by    (auto simp add: lconjseq_snoc lconjby_add)"], ["proof (state)\nthis:\n  map (lconjby (sum_list (altst k)))\n   (lconjseq\n     (if gcd_nat.greater_eq k 2 then altst (Suc j) else altts (Suc j))) =\n  lconjseq (altst j) @\n  [lconjby\n    (sum_list\n      (altst k @ (if gcd_nat.greater_eq k 2 then altst j else altts j)))\n    (if gcd_nat.greater_eq k 2 then if gcd_nat.greater_eq j 2 then s else t\n     else if gcd_nat.greater_eq j 2 then t else s)]\n\ngoal (2 subgoals):\n 1. map (lconjby (sum_list (altst k)))\n     (lconjseq (if gcd_nat.greater_eq k 2 then altst 0 else altts 0)) =\n    lconjseq (altst 0)\n 2. \\<And>m.\n       map (lconjby (sum_list (altst k)))\n        (lconjseq (if gcd_nat.greater_eq k 2 then altst m else altts m)) =\n       lconjseq (altst m) \\<Longrightarrow>\n       map (lconjby (sum_list (altst k)))\n        (lconjseq\n          (if gcd_nat.greater_eq k 2 then altst (Suc m)\n           else altts (Suc m))) =\n       lconjseq (altst (Suc m))", "also"], ["proof (state)\nthis:\n  map (lconjby (sum_list (altst k)))\n   (lconjseq\n     (if gcd_nat.greater_eq k 2 then altst (Suc j) else altts (Suc j))) =\n  lconjseq (altst j) @\n  [lconjby\n    (sum_list\n      (altst k @ (if gcd_nat.greater_eq k 2 then altst j else altts j)))\n    (if gcd_nat.greater_eq k 2 then if gcd_nat.greater_eq j 2 then s else t\n     else if gcd_nat.greater_eq j 2 then t else s)]\n\ngoal (2 subgoals):\n 1. map (lconjby (sum_list (altst k)))\n     (lconjseq (if gcd_nat.greater_eq k 2 then altst 0 else altts 0)) =\n    lconjseq (altst 0)\n 2. \\<And>m.\n       map (lconjby (sum_list (altst k)))\n        (lconjseq (if gcd_nat.greater_eq k 2 then altst m else altts m)) =\n       lconjseq (altst m) \\<Longrightarrow>\n       map (lconjby (sum_list (altst k)))\n        (lconjseq\n          (if gcd_nat.greater_eq k 2 then altst (Suc m)\n           else altts (Suc m))) =\n       lconjseq (altst (Suc m))", "from altst altts st(1,2)"], ["proof (chain)\npicking this:\n  altst \\<equiv> \\<lambda>n. alternating_list n s t\n  altts \\<equiv> \\<lambda>n. alternating_list n t s\n  s + s = (0::'a)\n  t + t = (0::'a)", "have  \"\\<dots> = lconjseq (altst j) @ [sum_list (altst (Suc (2*(k+j))))]\""], ["proof (prove)\nusing this:\n  altst \\<equiv> \\<lambda>n. alternating_list n s t\n  altts \\<equiv> \\<lambda>n. alternating_list n t s\n  s + s = (0::'a)\n  t + t = (0::'a)\n\ngoal (1 subgoal):\n 1. lconjseq (altst j) @\n    [lconjby\n      (sum_list\n        (altst k @ (if gcd_nat.greater_eq k 2 then altst j else altts j)))\n      (if gcd_nat.greater_eq k 2\n       then if gcd_nat.greater_eq j 2 then s else t\n       else if gcd_nat.greater_eq j 2 then t else s)] =\n    lconjseq (altst j) @ [sum_list (altst (Suc (2 * (k + j))))]", "using lconjby_alternating_list_order2[of s t \"k+j\"]"], ["proof (prove)\nusing this:\n  altst \\<equiv> \\<lambda>n. alternating_list n s t\n  altts \\<equiv> \\<lambda>n. alternating_list n t s\n  s + s = (0::'a)\n  t + t = (0::'a)\n  \\<lbrakk>s + s = (0::'a); t + t = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> lconjby (sum_list (alternating_list (k + j) s t))\n                     (if gcd_nat.greater_eq (k + j) 2 then s else t) =\n                    sum_list (alternating_list (Suc (2 * (k + j))) s t)\n\ngoal (1 subgoal):\n 1. lconjseq (altst j) @\n    [lconjby\n      (sum_list\n        (altst k @ (if gcd_nat.greater_eq k 2 then altst j else altts j)))\n      (if gcd_nat.greater_eq k 2\n       then if gcd_nat.greater_eq j 2 then s else t\n       else if gcd_nat.greater_eq j 2 then t else s)] =\n    lconjseq (altst j) @ [sum_list (altst (Suc (2 * (k + j))))]", "by    (cases \"even k\")\n          (auto simp add: alternating_list_append[of k])"], ["proof (state)\nthis:\n  lconjseq (altst j) @\n  [lconjby\n    (sum_list\n      (altst k @ (if gcd_nat.greater_eq k 2 then altst j else altts j)))\n    (if gcd_nat.greater_eq k 2 then if gcd_nat.greater_eq j 2 then s else t\n     else if gcd_nat.greater_eq j 2 then t else s)] =\n  lconjseq (altst j) @ [sum_list (altst (Suc (2 * (k + j))))]\n\ngoal (2 subgoals):\n 1. map (lconjby (sum_list (altst k)))\n     (lconjseq (if gcd_nat.greater_eq k 2 then altst 0 else altts 0)) =\n    lconjseq (altst 0)\n 2. \\<And>m.\n       map (lconjby (sum_list (altst k)))\n        (lconjseq (if gcd_nat.greater_eq k 2 then altst m else altts m)) =\n       lconjseq (altst m) \\<Longrightarrow>\n       map (lconjby (sum_list (altst k)))\n        (lconjseq\n          (if gcd_nat.greater_eq k 2 then altst (Suc m)\n           else altts (Suc m))) =\n       lconjseq (altst (Suc m))", "finally"], ["proof (chain)\npicking this:\n  map (lconjby (sum_list (altst k)))\n   (lconjseq\n     (if gcd_nat.greater_eq k 2 then altst (Suc j) else altts (Suc j))) =\n  lconjseq (altst j) @ [sum_list (altst (Suc (2 * (k + j))))]", "show ?case"], ["proof (prove)\nusing this:\n  map (lconjby (sum_list (altst k)))\n   (lconjseq\n     (if gcd_nat.greater_eq k 2 then altst (Suc j) else altts (Suc j))) =\n  lconjseq (altst j) @ [sum_list (altst (Suc (2 * (k + j))))]\n\ngoal (1 subgoal):\n 1. map (lconjby (sum_list (altst k)))\n     (lconjseq\n       (if gcd_nat.greater_eq k 2 then altst (Suc j) else altts (Suc j))) =\n    lconjseq (altst (Suc j))", "using altst st"], ["proof (prove)\nusing this:\n  map (lconjby (sum_list (altst k)))\n   (lconjseq\n     (if gcd_nat.greater_eq k 2 then altst (Suc j) else altts (Suc j))) =\n  lconjseq (altst j) @ [sum_list (altst (Suc (2 * (k + j))))]\n  altst \\<equiv> \\<lambda>n. alternating_list n s t\n  s + s = (0::'a)\n  t + t = (0::'a)\n  (s + t) +^ k = (0::'a)\n\ngoal (1 subgoal):\n 1. map (lconjby (sum_list (altst k)))\n     (lconjseq\n       (if gcd_nat.greater_eq k 2 then altst (Suc j) else altts (Suc j))) =\n    lconjseq (altst (Suc j))", "by    (auto simp add:\n            alternating_list_append(1)[THEN sym]\n            alternating_sum_list_conv_nataction\n            lconjby_alternating_list_order2 lconjseq_snoc\n          )"], ["proof (state)\nthis:\n  map (lconjby (sum_list (altst k)))\n   (lconjseq\n     (if gcd_nat.greater_eq k 2 then altst (Suc j) else altts (Suc j))) =\n  lconjseq (altst (Suc j))\n\ngoal (1 subgoal):\n 1. map (lconjby (sum_list (altst k)))\n     (lconjseq (if gcd_nat.greater_eq k 2 then altst 0 else altts 0)) =\n    lconjseq (altst 0)", "qed (simp add: altst altts)"], ["", "lemma lconjseq_alternating_order2_repeats:\n  fixes   s t :: 'a and k :: nat\n  defines altst: \"altst \\<equiv> \\<lambda>n. alternating_list n s t\"\n  and     altts: \"altts \\<equiv> \\<lambda>n. alternating_list n t s\"\n  assumes st: \"s+s=0\" \"t+t=0\" \"(s+t)+^k = 0\"\n  shows   \"lconjseq (altst (2*k)) = lconjseq (altst k) @ lconjseq (altst k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconjseq (altst (2 * k)) = lconjseq (altst k) @ lconjseq (altst k)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. lconjseq (altst (2 * k)) = lconjseq (altst k) @ lconjseq (altst k)", "from altst altts"], ["proof (chain)\npicking this:\n  altst \\<equiv> \\<lambda>n. alternating_list n s t\n  altts \\<equiv> \\<lambda>n. alternating_list n t s", "have \"lconjseq (altst (2*k)) = lconjseq (altst k) @\n            map (lconjby (sum_list (altst k)))\n              (lconjseq (if even k then altst k else altts k))\""], ["proof (prove)\nusing this:\n  altst \\<equiv> \\<lambda>n. alternating_list n s t\n  altts \\<equiv> \\<lambda>n. alternating_list n t s\n\ngoal (1 subgoal):\n 1. lconjseq (altst (2 * k)) =\n    lconjseq (altst k) @\n    map (lconjby (sum_list (altst k)))\n     (lconjseq (if gcd_nat.greater_eq k 2 then altst k else altts k))", "using alternating_list_append[THEN sym, of k k s t]"], ["proof (prove)\nusing this:\n  altst \\<equiv> \\<lambda>n. alternating_list n s t\n  altts \\<equiv> \\<lambda>n. alternating_list n t s\n  gcd_nat.greater_eq k 2 \\<Longrightarrow>\n  alternating_list (k + k) s t =\n  alternating_list k s t @ alternating_list k s t\n  \\<not> gcd_nat.greater_eq k 2 \\<Longrightarrow>\n  alternating_list (k + k) s t =\n  alternating_list k s t @ alternating_list k t s\n\ngoal (1 subgoal):\n 1. lconjseq (altst (2 * k)) =\n    lconjseq (altst k) @\n    map (lconjby (sum_list (altst k)))\n     (lconjseq (if gcd_nat.greater_eq k 2 then altst k else altts k))", "by    (auto simp add: times2_conv_add lconjseq_append)"], ["proof (state)\nthis:\n  lconjseq (altst (2 * k)) =\n  lconjseq (altst k) @\n  map (lconjby (sum_list (altst k)))\n   (lconjseq (if gcd_nat.greater_eq k 2 then altst k else altts k))\n\ngoal (1 subgoal):\n 1. lconjseq (altst (2 * k)) = lconjseq (altst k) @ lconjseq (altst k)", "with altst altts st"], ["proof (chain)\npicking this:\n  altst \\<equiv> \\<lambda>n. alternating_list n s t\n  altts \\<equiv> \\<lambda>n. alternating_list n t s\n  s + s = (0::'a)\n  t + t = (0::'a)\n  (s + t) +^ k = (0::'a)\n  lconjseq (altst (2 * k)) =\n  lconjseq (altst k) @\n  map (lconjby (sum_list (altst k)))\n   (lconjseq (if gcd_nat.greater_eq k 2 then altst k else altts k))", "show ?thesis"], ["proof (prove)\nusing this:\n  altst \\<equiv> \\<lambda>n. alternating_list n s t\n  altts \\<equiv> \\<lambda>n. alternating_list n t s\n  s + s = (0::'a)\n  t + t = (0::'a)\n  (s + t) +^ k = (0::'a)\n  lconjseq (altst (2 * k)) =\n  lconjseq (altst k) @\n  map (lconjby (sum_list (altst k)))\n   (lconjseq (if gcd_nat.greater_eq k 2 then altst k else altts k))\n\ngoal (1 subgoal):\n 1. lconjseq (altst (2 * k)) = lconjseq (altst k) @ lconjseq (altst k)", "using lconjseq_alternating_order2_repeats'[of s t k k]"], ["proof (prove)\nusing this:\n  altst \\<equiv> \\<lambda>n. alternating_list n s t\n  altts \\<equiv> \\<lambda>n. alternating_list n t s\n  s + s = (0::'a)\n  t + t = (0::'a)\n  (s + t) +^ k = (0::'a)\n  lconjseq (altst (2 * k)) =\n  lconjseq (altst k) @\n  map (lconjby (sum_list (altst k)))\n   (lconjseq (if gcd_nat.greater_eq k 2 then altst k else altts k))\n  \\<lbrakk>s + s = (0::'a); t + t = (0::'a); (s + t) +^ k = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> map (lconjby (sum_list (alternating_list k s t)))\n                     (lconjseq\n                       (if gcd_nat.greater_eq k 2\n                        then alternating_list k s t\n                        else alternating_list k t s)) =\n                    lconjseq (alternating_list k s t)\n\ngoal (1 subgoal):\n 1. lconjseq (altst (2 * k)) = lconjseq (altst k) @ lconjseq (altst k)", "by auto"], ["proof (state)\nthis:\n  lconjseq (altst (2 * k)) = lconjseq (altst k) @ lconjseq (altst k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma even_count_lconjseq_alternating_order2:\n  fixes   s t :: 'a\n  assumes \"s+s=0\" \"t+t=0\" \"(s+t)+^k = 0\"\n  shows   \"even (count_list (lconjseq (alternating_list (2*k) s t)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_nat.greater_eq\n     (count_list (lconjseq (alternating_list (2 * k) s t)) x) 2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd_nat.greater_eq\n     (count_list (lconjseq (alternating_list (2 * k) s t)) x) 2", "define xs where xs: \"xs \\<equiv> lconjseq (alternating_list (2*k) s t)\""], ["proof (state)\nthis:\n  xs \\<equiv> lconjseq (alternating_list (2 * k) s t)\n\ngoal (1 subgoal):\n 1. gcd_nat.greater_eq\n     (count_list (lconjseq (alternating_list (2 * k) s t)) x) 2", "with assms"], ["proof (chain)\npicking this:\n  s + s = (0::'a)\n  t + t = (0::'a)\n  (s + t) +^ k = (0::'a)\n  xs \\<equiv> lconjseq (alternating_list (2 * k) s t)", "obtain as where \"xs = as@as\""], ["proof (prove)\nusing this:\n  s + s = (0::'a)\n  t + t = (0::'a)\n  (s + t) +^ k = (0::'a)\n  xs \\<equiv> lconjseq (alternating_list (2 * k) s t)\n\ngoal (1 subgoal):\n 1. (\\<And>as. xs = as @ as \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lconjseq_alternating_order2_repeats"], ["proof (prove)\nusing this:\n  s + s = (0::'a)\n  t + t = (0::'a)\n  (s + t) +^ k = (0::'a)\n  xs \\<equiv> lconjseq (alternating_list (2 * k) s t)\n  \\<lbrakk>?s + ?s = (0::'a); ?t + ?t = (0::'a);\n   (?s + ?t) +^ ?k = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> lconjseq (alternating_list (2 * ?k) ?s ?t) =\n                    lconjseq (alternating_list ?k ?s ?t) @\n                    lconjseq (alternating_list ?k ?s ?t)\n\ngoal (1 subgoal):\n 1. (\\<And>as. xs = as @ as \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  xs = as @ as\n\ngoal (1 subgoal):\n 1. gcd_nat.greater_eq\n     (count_list (lconjseq (alternating_list (2 * k) s t)) x) 2", "hence \"count_list xs x = 2 * (count_list as x)\""], ["proof (prove)\nusing this:\n  xs = as @ as\n\ngoal (1 subgoal):\n 1. count_list xs x = 2 * count_list as x", "by (simp add: count_list_append times2_conv_add)"], ["proof (state)\nthis:\n  count_list xs x = 2 * count_list as x\n\ngoal (1 subgoal):\n 1. gcd_nat.greater_eq\n     (count_list (lconjseq (alternating_list (2 * k) s t)) x) 2", "with xs"], ["proof (chain)\npicking this:\n  xs \\<equiv> lconjseq (alternating_list (2 * k) s t)\n  count_list xs x = 2 * count_list as x", "show ?thesis"], ["proof (prove)\nusing this:\n  xs \\<equiv> lconjseq (alternating_list (2 * k) s t)\n  count_list xs x = 2 * count_list as x\n\ngoal (1 subgoal):\n 1. gcd_nat.greater_eq\n     (count_list (lconjseq (alternating_list (2 * k) s t)) x) 2", "by simp"], ["proof (state)\nthis:\n  gcd_nat.greater_eq\n   (count_list (lconjseq (alternating_list (2 * k) s t)) x) 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order2_hd_in_lconjseq_deletion:\n  shows \"s+s=0 \\<Longrightarrow> s \\<in> set (lconjseq ss)\n            \\<Longrightarrow> \\<exists>as b bs. ss = as@[b]@bs \\<and> sum_list (s#ss) = sum_list (as@bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s + s = (0::'a); s \\<in> set (lconjseq ss)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as b bs.\n                         ss = as @ [b] @ bs \\<and>\n                         sum_list (s # ss) = sum_list (as @ bs)", "proof (induct ss arbitrary: s rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s + s = (0::'a); s \\<in> set (lconjseq [])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as b bs.\n                            [] = as @ [b] @ bs \\<and>\n                            sum_list [s] = sum_list (as @ bs)\n 2. \\<And>x xs s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s + s = (0::'a);\n                    s \\<in> set (lconjseq xs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as b bs.\n  xs = as @ [b] @ bs \\<and> sum_list (s # xs) = sum_list (as @ bs);\n        s + s = (0::'a); s \\<in> set (lconjseq (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as b bs.\n                            xs @ [x] = as @ [b] @ bs \\<and>\n                            sum_list (s # xs @ [x]) = sum_list (as @ bs)", "case (snoc t ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?s + ?s = (0::'a); ?s \\<in> set (lconjseq ts)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as b bs.\n                       ts = as @ [b] @ bs \\<and>\n                       sum_list (?s # ts) = sum_list (as @ bs)\n  s + s = (0::'a)\n  s \\<in> set (lconjseq (ts @ [t]))\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s + s = (0::'a); s \\<in> set (lconjseq [])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as b bs.\n                            [] = as @ [b] @ bs \\<and>\n                            sum_list [s] = sum_list (as @ bs)\n 2. \\<And>x xs s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s + s = (0::'a);\n                    s \\<in> set (lconjseq xs)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as b bs.\n  xs = as @ [b] @ bs \\<and> sum_list (s # xs) = sum_list (as @ bs);\n        s + s = (0::'a); s \\<in> set (lconjseq (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as b bs.\n                            xs @ [x] = as @ [b] @ bs \\<and>\n                            sum_list (s # xs @ [x]) = sum_list (as @ bs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "proof (cases \"s \\<in> set (lconjseq ts)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s \\<in> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)\n 2. s \\<notin> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "case True"], ["proof (state)\nthis:\n  s \\<in> set (lconjseq ts)\n\ngoal (2 subgoals):\n 1. s \\<in> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)\n 2. s \\<notin> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "with snoc(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?s + ?s = (0::'a); ?s \\<in> set (lconjseq ts)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as b bs.\n                       ts = as @ [b] @ bs \\<and>\n                       sum_list (?s # ts) = sum_list (as @ bs)\n  s + s = (0::'a)\n  s \\<in> set (lconjseq ts)", "obtain as b bs\n      where   asbbs: \"ts = as @[b]@bs\" \"sum_list (s#ts) = sum_list (as@bs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?s + ?s = (0::'a); ?s \\<in> set (lconjseq ts)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as b bs.\n                       ts = as @ [b] @ bs \\<and>\n                       sum_list (?s # ts) = sum_list (as @ bs)\n  s + s = (0::'a)\n  s \\<in> set (lconjseq ts)\n\ngoal (1 subgoal):\n 1. (\\<And>as b bs.\n        \\<lbrakk>ts = as @ [b] @ bs;\n         sum_list (s # ts) = sum_list (as @ bs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by      fastforce"], ["proof (state)\nthis:\n  ts = as @ [b] @ bs\n  sum_list (s # ts) = sum_list (as @ bs)\n\ngoal (2 subgoals):\n 1. s \\<in> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)\n 2. s \\<notin> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "from asbbs(2)"], ["proof (chain)\npicking this:\n  sum_list (s # ts) = sum_list (as @ bs)", "have \"sum_list (s#ts@[t]) = sum_list (as@(bs@[t]))\""], ["proof (prove)\nusing this:\n  sum_list (s # ts) = sum_list (as @ bs)\n\ngoal (1 subgoal):\n 1. sum_list (s # ts @ [t]) = sum_list (as @ bs @ [t])", "using sum_list.append[of \"s#ts\" \"[t]\"] sum_list.append[of \"as@bs\" \"[t]\"]"], ["proof (prove)\nusing this:\n  sum_list (s # ts) = sum_list (as @ bs)\n  sum_list ((s # ts) @ [t]) = sum_list (s # ts) + sum_list [t]\n  sum_list ((as @ bs) @ [t]) = sum_list (as @ bs) + sum_list [t]\n\ngoal (1 subgoal):\n 1. sum_list (s # ts @ [t]) = sum_list (as @ bs @ [t])", "by simp"], ["proof (state)\nthis:\n  sum_list (s # ts @ [t]) = sum_list (as @ bs @ [t])\n\ngoal (2 subgoals):\n 1. s \\<in> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)\n 2. s \\<notin> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "with asbbs(1)"], ["proof (chain)\npicking this:\n  ts = as @ [b] @ bs\n  sum_list (s # ts @ [t]) = sum_list (as @ bs @ [t])", "show ?thesis"], ["proof (prove)\nusing this:\n  ts = as @ [b] @ bs\n  sum_list (s # ts @ [t]) = sum_list (as @ bs @ [t])\n\ngoal (1 subgoal):\n 1. \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as b bs.\n     ts @ [t] = as @ [b] @ bs \\<and>\n     sum_list (s # ts @ [t]) = sum_list (as @ bs)\n\ngoal (1 subgoal):\n 1. s \\<notin> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<notin> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "case False"], ["proof (state)\nthis:\n  s \\<notin> set (lconjseq ts)\n\ngoal (1 subgoal):\n 1. s \\<notin> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "with snoc(3)"], ["proof (chain)\npicking this:\n  s \\<in> set (lconjseq (ts @ [t]))\n  s \\<notin> set (lconjseq ts)", "have s: \"s = lconjby (sum_list ts) t\""], ["proof (prove)\nusing this:\n  s \\<in> set (lconjseq (ts @ [t]))\n  s \\<notin> set (lconjseq ts)\n\ngoal (1 subgoal):\n 1. s = lconjby (sum_list ts) t", "by (simp add: lconjseq_snoc)"], ["proof (state)\nthis:\n  s = lconjby (sum_list ts) t\n\ngoal (1 subgoal):\n 1. s \\<notin> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "with snoc(2)"], ["proof (chain)\npicking this:\n  s + s = (0::'a)\n  s = lconjby (sum_list ts) t", "have \"t+t=0\""], ["proof (prove)\nusing this:\n  s + s = (0::'a)\n  s = lconjby (sum_list ts) t\n\ngoal (1 subgoal):\n 1. t + t = (0::'a)", "using lconjby_eq_conv_rconjby_eq[of s \"sum_list ts\" t]\n            rconjby_order2[of s \"sum_list ts\"]"], ["proof (prove)\nusing this:\n  s + s = (0::'a)\n  s = lconjby (sum_list ts) t\n  s = lconjby (sum_list ts) t \\<Longrightarrow> t = rconjby (sum_list ts) s\n  s + s = (0::'a) \\<Longrightarrow>\n  rconjby (sum_list ts) s + rconjby (sum_list ts) s = (0::'a)\n\ngoal (1 subgoal):\n 1. t + t = (0::'a)", "by    simp"], ["proof (state)\nthis:\n  t + t = (0::'a)\n\ngoal (1 subgoal):\n 1. s \\<notin> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "moreover"], ["proof (state)\nthis:\n  t + t = (0::'a)\n\ngoal (1 subgoal):\n 1. s \\<notin> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "from s"], ["proof (chain)\npicking this:\n  s = lconjby (sum_list ts) t", "have \"sum_list (s#ts@[t]) = sum_list ts + t + t\""], ["proof (prove)\nusing this:\n  s = lconjby (sum_list ts) t\n\ngoal (1 subgoal):\n 1. sum_list (s # ts @ [t]) = sum_list ts + t + t", "using add.assoc[of \"sum_list ts + t - sum_list ts\" \"sum_list ts\"]"], ["proof (prove)\nusing this:\n  s = lconjby (sum_list ts) t\n  lconjby (sum_list ts) t + sum_list ts + ?c =\n  lconjby (sum_list ts) t + (sum_list ts + ?c)\n\ngoal (1 subgoal):\n 1. sum_list (s # ts @ [t]) = sum_list ts + t + t", "by    (simp add: algebra_simps)"], ["proof (state)\nthis:\n  sum_list (s # ts @ [t]) = sum_list ts + t + t\n\ngoal (1 subgoal):\n 1. s \\<notin> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "ultimately"], ["proof (chain)\npicking this:\n  t + t = (0::'a)\n  sum_list (s # ts @ [t]) = sum_list ts + t + t", "have \"sum_list (s#ts@[t]) = sum_list (ts@[])\""], ["proof (prove)\nusing this:\n  t + t = (0::'a)\n  sum_list (s # ts @ [t]) = sum_list ts + t + t\n\ngoal (1 subgoal):\n 1. sum_list (s # ts @ [t]) = sum_list (ts @ [])", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  sum_list (s # ts @ [t]) = sum_list (ts @ [])\n\ngoal (1 subgoal):\n 1. s \\<notin> set (lconjseq ts) \\<Longrightarrow>\n    \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum_list (s # ts @ [t]) = sum_list (ts @ [])\n\ngoal (1 subgoal):\n 1. \\<exists>as b bs.\n       ts @ [t] = as @ [b] @ bs \\<and>\n       sum_list (s # ts @ [t]) = sum_list (as @ bs)", "by fast"], ["proof (state)\nthis:\n  \\<exists>as b bs.\n     ts @ [t] = as @ [b] @ bs \\<and>\n     sum_list (s # ts @ [t]) = sum_list (as @ bs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as b bs.\n     ts @ [t] = as @ [b] @ bs \\<and>\n     sum_list (s # ts @ [t]) = sum_list (as @ bs)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s + s = (0::'a); s \\<in> set (lconjseq [])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as b bs.\n                            [] = as @ [b] @ bs \\<and>\n                            sum_list [s] = sum_list (as @ bs)", "qed simp"], ["", "end"], ["", "(* context group_add *)"], ["", "subsubsection \\<open>The action on signed @{class group_add} elements\\<close>"], ["", "text \\<open>\n  Here we construct an action of a group on itself by conjugation, where group elements are\n  endowed with an auxiliary sign by pairing with a boolean element. In multiple applications of\n  this action, the auxiliary sign helps keep track of how many times the elements conjugating and\n  being conjugated are the same. This action arises in exploring reduced expressions of group\n  elements as words in a set of generators of order two (in particular, in a Coxeter group).\n\\<close>"], ["", "type_synonym 'a signed = \"'a\\<times>bool\""], ["", "definition signed_funaction :: \"('a\\<Rightarrow>'a\\<Rightarrow>'a) \\<Rightarrow> 'a \\<Rightarrow> 'a signed \\<Rightarrow> 'a signed\"\n  where \"signed_funaction f s x \\<equiv> map_prod (f s) (\\<lambda>b. b \\<noteq> (fst x = s)) x\"\n  \\<comment> \\<open>so the sign of @{term x} is flipped precisely when its first component is equal to\n@{term s}\\<close>"], ["", "context group_add\nbegin"], ["", "abbreviation \"signed_lconjaction \\<equiv> signed_funaction lconjby\""], ["", "abbreviation \"signed_rconjaction \\<equiv> signed_funaction rconjby\""], ["", "lemmas signed_lconjactionD = signed_funaction_def[of lconjby]"], ["", "lemmas signed_rconjactionD = signed_funaction_def[of rconjby]"], ["", "abbreviation signed_lconjpermutation :: \"'a \\<Rightarrow> 'a signed permutation\"\n  where \"signed_lconjpermutation s \\<equiv> Abs_permutation (signed_lconjaction s)\""], ["", "abbreviation signed_list_lconjaction :: \"'a list \\<Rightarrow> 'a signed \\<Rightarrow> 'a signed\"\n  where \"signed_list_lconjaction ss \\<equiv> foldr signed_lconjaction ss\""], ["", "lemma signed_lconjaction_fst: \"fst (signed_lconjaction s x) = lconjby s (fst x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (signed_lconjaction s x) = lconjby s (fst x)", "using signed_lconjactionD"], ["proof (prove)\nusing this:\n  signed_lconjaction ?s ?x \\<equiv>\n  map_prod (lconjby ?s) (\\<lambda>b. b \\<noteq> (fst ?x = ?s)) ?x\n\ngoal (1 subgoal):\n 1. fst (signed_lconjaction s x) = lconjby s (fst x)", "by simp"], ["", "lemma signed_lconjaction_rconjaction:\n  \"signed_lconjaction s (signed_rconjaction s x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_lconjaction s (signed_rconjaction s x) = x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. signed_lconjaction s (signed_rconjaction s x) = x", "obtain a::'a and b::bool where \"x = (a,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. signed_lconjaction s (signed_rconjaction s x) = x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. signed_lconjaction s (signed_rconjaction s x) = x", "using signed_lconjactionD signed_rconjactionD injD[OF rconjby_inj, of s a]\n          lconjby_rconjby[of s a]"], ["proof (prove)\nusing this:\n  x = (a, b)\n  signed_lconjaction ?s ?x \\<equiv>\n  map_prod (lconjby ?s) (\\<lambda>b. b \\<noteq> (fst ?x = ?s)) ?x\n  signed_rconjaction ?s ?x \\<equiv>\n  map_prod (rconjby ?s) (\\<lambda>b. b \\<noteq> (fst ?x = ?s)) ?x\n  rconjby s a = rconjby s ?y \\<Longrightarrow> a = ?y\n  lconjby s (rconjby s a) = a\n\ngoal (1 subgoal):\n 1. signed_lconjaction s (signed_rconjaction s x) = x", "by    auto"], ["proof (state)\nthis:\n  signed_lconjaction s (signed_rconjaction s x) = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma signed_rconjaction_by_order2_eq_lconjaction:\n  \"s+s=0 \\<Longrightarrow> signed_rconjaction s = signed_lconjaction s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + s = (0::'a) \\<Longrightarrow>\n    signed_rconjaction s = signed_lconjaction s", "using signed_funaction_def[of lconjby s] signed_funaction_def[of rconjby s]\n        rconjby_order2_eq_lconjby[of s]"], ["proof (prove)\nusing this:\n  signed_lconjaction s ?x \\<equiv>\n  map_prod (lconjby s) (\\<lambda>b. b \\<noteq> (fst ?x = s)) ?x\n  signed_rconjaction s ?x \\<equiv>\n  map_prod (rconjby s) (\\<lambda>b. b \\<noteq> (fst ?x = s)) ?x\n  s + s = (0::'a) \\<Longrightarrow> rconjby s = lconjby s\n\ngoal (1 subgoal):\n 1. s + s = (0::'a) \\<Longrightarrow>\n    signed_rconjaction s = signed_lconjaction s", "by    auto"], ["", "lemma inj_signed_lconjaction: \"inj (signed_lconjaction s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (signed_lconjaction s)", "proof (rule injI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       signed_lconjaction s x = signed_lconjaction s y \\<Longrightarrow>\n       x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       signed_lconjaction s x = signed_lconjaction s y \\<Longrightarrow>\n       x = y", "assume 1: \"signed_lconjaction s x = signed_lconjaction s y\""], ["proof (state)\nthis:\n  signed_lconjaction s x = signed_lconjaction s y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       signed_lconjaction s x = signed_lconjaction s y \\<Longrightarrow>\n       x = y", "moreover"], ["proof (state)\nthis:\n  signed_lconjaction s x = signed_lconjaction s y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       signed_lconjaction s x = signed_lconjaction s y \\<Longrightarrow>\n       x = y", "obtain a1 a2 :: 'a and b1 b2 :: bool\n    where xy: \"x = (a1,b1)\" \"y = (a2,b2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a1 b1 a2 b2.\n        \\<lbrakk>x = (a1, b1); y = (a2, b2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fastforce"], ["proof (state)\nthis:\n  x = (a1, b1)\n  y = (a2, b2)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       signed_lconjaction s x = signed_lconjaction s y \\<Longrightarrow>\n       x = y", "ultimately"], ["proof (chain)\npicking this:\n  signed_lconjaction s x = signed_lconjaction s y\n  x = (a1, b1)\n  y = (a2, b2)", "show \"x=y\""], ["proof (prove)\nusing this:\n  signed_lconjaction s x = signed_lconjaction s y\n  x = (a1, b1)\n  y = (a2, b2)\n\ngoal (1 subgoal):\n 1. x = y", "using injD[OF lconjby_inj, of s a1 a2] signed_lconjactionD"], ["proof (prove)\nusing this:\n  signed_lconjaction s x = signed_lconjaction s y\n  x = (a1, b1)\n  y = (a2, b2)\n  lconjby s a1 = lconjby s a2 \\<Longrightarrow> a1 = a2\n  signed_lconjaction ?s ?x \\<equiv>\n  map_prod (lconjby ?s) (\\<lambda>b. b \\<noteq> (fst ?x = ?s)) ?x\n\ngoal (1 subgoal):\n 1. x = y", "by    (cases \"a1=s\" \"a2=s\" rule: two_cases) auto"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma surj_signed_lconjaction: \"surj (signed_lconjaction s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj (signed_lconjaction s)", "using signed_lconjaction_rconjaction[THEN sym]"], ["proof (prove)\nusing this:\n  ?t = signed_lconjaction ?s1 (signed_rconjaction ?s1 ?t)\n\ngoal (1 subgoal):\n 1. surj (signed_lconjaction s)", "by fast"], ["", "lemma bij_signed_lconjaction: \"bij (signed_lconjaction s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (signed_lconjaction s)", "using inj_signed_lconjaction surj_signed_lconjaction"], ["proof (prove)\nusing this:\n  inj (signed_lconjaction ?s)\n  surj (signed_lconjaction ?s)\n\ngoal (1 subgoal):\n 1. bij (signed_lconjaction s)", "by (fast intro: bijI)"], ["", "lemma the_inv_signed_lconjaction:\n  \"the_inv (signed_lconjaction s) = signed_rconjaction s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv (signed_lconjaction s) = signed_rconjaction s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. the_inv (signed_lconjaction s) x = signed_rconjaction s x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. the_inv (signed_lconjaction s) x = signed_rconjaction s x", "show \"the_inv (signed_lconjaction s) x = signed_rconjaction s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv (signed_lconjaction s) x = signed_rconjaction s x", "proof (rule the_inv_into_f_eq, rule inj_signed_lconjaction)"], ["proof (state)\ngoal (2 subgoals):\n 1. signed_lconjaction s (signed_rconjaction s x) = x\n 2. signed_rconjaction s x \\<in> UNIV", "show \"signed_lconjaction s (signed_rconjaction s x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signed_lconjaction s (signed_rconjaction s x) = x", "using signed_lconjaction_rconjaction"], ["proof (prove)\nusing this:\n  signed_lconjaction ?s (signed_rconjaction ?s ?x) = ?x\n\ngoal (1 subgoal):\n 1. signed_lconjaction s (signed_rconjaction s x) = x", "by fast"], ["proof (state)\nthis:\n  signed_lconjaction s (signed_rconjaction s x) = x\n\ngoal (1 subgoal):\n 1. signed_rconjaction s x \\<in> UNIV", "qed (simp add: surj_signed_lconjaction)"], ["proof (state)\nthis:\n  the_inv (signed_lconjaction s) x = signed_rconjaction s x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma the_inv_signed_lconjaction_by_order2:\n  \"s+s=0 \\<Longrightarrow> the_inv (signed_lconjaction s) = signed_lconjaction s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + s = (0::'a) \\<Longrightarrow>\n    the_inv (signed_lconjaction s) = signed_lconjaction s", "using the_inv_signed_lconjaction signed_rconjaction_by_order2_eq_lconjaction"], ["proof (prove)\nusing this:\n  the_inv (signed_lconjaction ?s) = signed_rconjaction ?s\n  ?s + ?s = (0::'a) \\<Longrightarrow>\n  signed_rconjaction ?s = signed_lconjaction ?s\n\ngoal (1 subgoal):\n 1. s + s = (0::'a) \\<Longrightarrow>\n    the_inv (signed_lconjaction s) = signed_lconjaction s", "by    simp"], ["", "lemma signed_list_lconjaction_fst:\n  \"fst (signed_list_lconjaction ss x) = lconjby (sum_list ss) (fst x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (signed_list_lconjaction ss x) = lconjby (sum_list ss) (fst x)", "using signed_lconjaction_fst lconjby_add"], ["proof (prove)\nusing this:\n  fst (signed_lconjaction ?s ?x) = lconjby ?s (fst ?x)\n  lconjby (?x + ?y) ?z = lconjby ?x (lconjby ?y ?z)\n\ngoal (1 subgoal):\n 1. fst (signed_list_lconjaction ss x) = lconjby (sum_list ss) (fst x)", "by (induct ss) auto"], ["", "lemma signed_list_lconjaction_snd:\n  shows \"\\<forall>s\\<in>set ss. s+s=0 \\<Longrightarrow> snd (signed_list_lconjaction ss x)\n          = (if even (count_list (lconjseq (rev ss)) (fst x)) then snd x else \\<not>snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>set ss. s + s = (0::'a) \\<Longrightarrow>\n    snd (signed_list_lconjaction ss x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n     then snd x else \\<not> snd x)", "proof (induct ss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>s\\<in>set []. s + s = (0::'a) \\<Longrightarrow>\n    snd (signed_list_lconjaction [] x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev [])) (fst x)) 2\n     then snd x else \\<not> snd x)\n 2. \\<And>a ss.\n       \\<lbrakk>\\<forall>s\\<in>set ss. s + s = (0::'a) \\<Longrightarrow>\n                snd (signed_list_lconjaction ss x) =\n                (if gcd_nat.greater_eq\n                     (count_list (lconjseq (rev ss)) (fst x)) 2\n                 then snd x else \\<not> snd x);\n        \\<forall>s\\<in>set (a # ss). s + s = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> snd (signed_list_lconjaction (a # ss) x) =\n                         (if gcd_nat.greater_eq\n                              (count_list (lconjseq (rev (a # ss))) (fst x))\n                              2\n                          then snd x else \\<not> snd x)", "case (Cons s ss)"], ["proof (state)\nthis:\n  \\<forall>s\\<in>set ss. s + s = (0::'a) \\<Longrightarrow>\n  snd (signed_list_lconjaction ss x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n   then snd x else \\<not> snd x)\n  \\<forall>s\\<in>set (s # ss). s + s = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<forall>s\\<in>set []. s + s = (0::'a) \\<Longrightarrow>\n    snd (signed_list_lconjaction [] x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev [])) (fst x)) 2\n     then snd x else \\<not> snd x)\n 2. \\<And>a ss.\n       \\<lbrakk>\\<forall>s\\<in>set ss. s + s = (0::'a) \\<Longrightarrow>\n                snd (signed_list_lconjaction ss x) =\n                (if gcd_nat.greater_eq\n                     (count_list (lconjseq (rev ss)) (fst x)) 2\n                 then snd x else \\<not> snd x);\n        \\<forall>s\\<in>set (a # ss). s + s = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> snd (signed_list_lconjaction (a # ss) x) =\n                         (if gcd_nat.greater_eq\n                              (count_list (lconjseq (rev (a # ss))) (fst x))\n                              2\n                          then snd x else \\<not> snd x)", "hence prevcase:\n    \"snd (signed_list_lconjaction ss x) =\n      (if even (count_list (lconjseq (rev ss)) (fst x)) then snd x else \\<not> snd x)\""], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>set ss. s + s = (0::'a) \\<Longrightarrow>\n  snd (signed_list_lconjaction ss x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n   then snd x else \\<not> snd x)\n  \\<forall>s\\<in>set (s # ss). s + s = (0::'a)\n\ngoal (1 subgoal):\n 1. snd (signed_list_lconjaction ss x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n     then snd x else \\<not> snd x)", "by simp"], ["proof (state)\nthis:\n  snd (signed_list_lconjaction ss x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n   then snd x else \\<not> snd x)\n\ngoal (2 subgoals):\n 1. \\<forall>s\\<in>set []. s + s = (0::'a) \\<Longrightarrow>\n    snd (signed_list_lconjaction [] x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev [])) (fst x)) 2\n     then snd x else \\<not> snd x)\n 2. \\<And>a ss.\n       \\<lbrakk>\\<forall>s\\<in>set ss. s + s = (0::'a) \\<Longrightarrow>\n                snd (signed_list_lconjaction ss x) =\n                (if gcd_nat.greater_eq\n                     (count_list (lconjseq (rev ss)) (fst x)) 2\n                 then snd x else \\<not> snd x);\n        \\<forall>s\\<in>set (a # ss). s + s = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> snd (signed_list_lconjaction (a # ss) x) =\n                         (if gcd_nat.greater_eq\n                              (count_list (lconjseq (rev (a # ss))) (fst x))\n                              2\n                          then snd x else \\<not> snd x)", "have 1: \"snd (signed_list_lconjaction (s # ss) x) =\n            snd (signed_lconjaction s (signed_list_lconjaction ss x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (signed_list_lconjaction (s # ss) x) =\n    snd (signed_lconjaction s (signed_list_lconjaction ss x))", "by simp"], ["proof (state)\nthis:\n  snd (signed_list_lconjaction (s # ss) x) =\n  snd (signed_lconjaction s (signed_list_lconjaction ss x))\n\ngoal (2 subgoals):\n 1. \\<forall>s\\<in>set []. s + s = (0::'a) \\<Longrightarrow>\n    snd (signed_list_lconjaction [] x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev [])) (fst x)) 2\n     then snd x else \\<not> snd x)\n 2. \\<And>a ss.\n       \\<lbrakk>\\<forall>s\\<in>set ss. s + s = (0::'a) \\<Longrightarrow>\n                snd (signed_list_lconjaction ss x) =\n                (if gcd_nat.greater_eq\n                     (count_list (lconjseq (rev ss)) (fst x)) 2\n                 then snd x else \\<not> snd x);\n        \\<forall>s\\<in>set (a # ss). s + s = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> snd (signed_list_lconjaction (a # ss) x) =\n                         (if gcd_nat.greater_eq\n                              (count_list (lconjseq (rev (a # ss))) (fst x))\n                              2\n                          then snd x else \\<not> snd x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)", "proof (cases \"fst (signed_list_lconjaction ss x) = s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (signed_list_lconjaction ss x) = s \\<Longrightarrow>\n    snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)\n 2. fst (signed_list_lconjaction ss x) \\<noteq> s \\<Longrightarrow>\n    snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)", "case True"], ["proof (state)\nthis:\n  fst (signed_list_lconjaction ss x) = s\n\ngoal (2 subgoals):\n 1. fst (signed_list_lconjaction ss x) = s \\<Longrightarrow>\n    snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)\n 2. fst (signed_list_lconjaction ss x) \\<noteq> s \\<Longrightarrow>\n    snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)", "with 1 prevcase"], ["proof (chain)\npicking this:\n  snd (signed_list_lconjaction (s # ss) x) =\n  snd (signed_lconjaction s (signed_list_lconjaction ss x))\n  snd (signed_list_lconjaction ss x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n   then snd x else \\<not> snd x)\n  fst (signed_list_lconjaction ss x) = s", "have  \"snd (signed_list_lconjaction (s # ss) x) =\n              (if even (count_list (lconjseq (rev ss)) (fst x)) then \\<not> snd x else snd x)\""], ["proof (prove)\nusing this:\n  snd (signed_list_lconjaction (s # ss) x) =\n  snd (signed_lconjaction s (signed_list_lconjaction ss x))\n  snd (signed_list_lconjaction ss x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n   then snd x else \\<not> snd x)\n  fst (signed_list_lconjaction ss x) = s\n\ngoal (1 subgoal):\n 1. snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n     then \\<not> snd x else snd x)", "by    (simp add: signed_lconjactionD)"], ["proof (state)\nthis:\n  snd (signed_list_lconjaction (s # ss) x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n   then \\<not> snd x else snd x)\n\ngoal (2 subgoals):\n 1. fst (signed_list_lconjaction ss x) = s \\<Longrightarrow>\n    snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)\n 2. fst (signed_list_lconjaction ss x) \\<noteq> s \\<Longrightarrow>\n    snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)", "with True Cons(2)"], ["proof (chain)\npicking this:\n  fst (signed_list_lconjaction ss x) = s\n  \\<forall>s\\<in>set (s # ss). s + s = (0::'a)\n  snd (signed_list_lconjaction (s # ss) x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n   then \\<not> snd x else snd x)", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (signed_list_lconjaction ss x) = s\n  \\<forall>s\\<in>set (s # ss). s + s = (0::'a)\n  snd (signed_list_lconjaction (s # ss) x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n   then \\<not> snd x else snd x)\n\ngoal (1 subgoal):\n 1. snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)", "by    (simp add:\n              signed_list_lconjaction_fst lconjby_eq_conv_rconjby_eq\n              uminus_sum_list_order2[THEN sym] lconjseq_snoc count_list_snoc\n            )"], ["proof (state)\nthis:\n  snd (signed_list_lconjaction (s # ss) x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n   then snd x else \\<not> snd x)\n\ngoal (1 subgoal):\n 1. fst (signed_list_lconjaction ss x) \\<noteq> s \\<Longrightarrow>\n    snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (signed_list_lconjaction ss x) \\<noteq> s \\<Longrightarrow>\n    snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)", "case False"], ["proof (state)\nthis:\n  fst (signed_list_lconjaction ss x) \\<noteq> s\n\ngoal (1 subgoal):\n 1. fst (signed_list_lconjaction ss x) \\<noteq> s \\<Longrightarrow>\n    snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)", "hence \"rconjby (sum_list ss) (lconjby (sum_list ss) (fst x)) \\<noteq>\n            rconjby (sum_list ss) s\""], ["proof (prove)\nusing this:\n  fst (signed_list_lconjaction ss x) \\<noteq> s\n\ngoal (1 subgoal):\n 1. rconjby (sum_list ss) (lconjby (sum_list ss) (fst x)) \\<noteq>\n    rconjby (sum_list ss) s", "by (simp add: signed_list_lconjaction_fst)"], ["proof (state)\nthis:\n  rconjby (sum_list ss) (lconjby (sum_list ss) (fst x)) \\<noteq>\n  rconjby (sum_list ss) s\n\ngoal (1 subgoal):\n 1. fst (signed_list_lconjaction ss x) \\<noteq> s \\<Longrightarrow>\n    snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)", "with Cons(2)"], ["proof (chain)\npicking this:\n  \\<forall>s\\<in>set (s # ss). s + s = (0::'a)\n  rconjby (sum_list ss) (lconjby (sum_list ss) (fst x)) \\<noteq>\n  rconjby (sum_list ss) s", "have  \"count_list (lconjseq (rev (s#ss))) (fst x) =\n              count_list (lconjseq (rev ss)) (fst x)\""], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>set (s # ss). s + s = (0::'a)\n  rconjby (sum_list ss) (lconjby (sum_list ss) (fst x)) \\<noteq>\n  rconjby (sum_list ss) s\n\ngoal (1 subgoal):\n 1. count_list (lconjseq (rev (s # ss))) (fst x) =\n    count_list (lconjseq (rev ss)) (fst x)", "by    (simp add:\n              rconjby_lconjby uminus_sum_list_order2[THEN sym]\n              lconjseq_snoc count_list_snoc\n            )"], ["proof (state)\nthis:\n  count_list (lconjseq (rev (s # ss))) (fst x) =\n  count_list (lconjseq (rev ss)) (fst x)\n\ngoal (1 subgoal):\n 1. fst (signed_list_lconjaction ss x) \\<noteq> s \\<Longrightarrow>\n    snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)", "moreover"], ["proof (state)\nthis:\n  count_list (lconjseq (rev (s # ss))) (fst x) =\n  count_list (lconjseq (rev ss)) (fst x)\n\ngoal (1 subgoal):\n 1. fst (signed_list_lconjaction ss x) \\<noteq> s \\<Longrightarrow>\n    snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)", "from False 1 prevcase"], ["proof (chain)\npicking this:\n  fst (signed_list_lconjaction ss x) \\<noteq> s\n  snd (signed_list_lconjaction (s # ss) x) =\n  snd (signed_lconjaction s (signed_list_lconjaction ss x))\n  snd (signed_list_lconjaction ss x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n   then snd x else \\<not> snd x)", "have \"snd (signed_list_lconjaction (s # ss) x) =\n              (if even (count_list (lconjseq (rev ss)) (fst x)) then snd x else \\<not> snd x)\""], ["proof (prove)\nusing this:\n  fst (signed_list_lconjaction ss x) \\<noteq> s\n  snd (signed_list_lconjaction (s # ss) x) =\n  snd (signed_lconjaction s (signed_list_lconjaction ss x))\n  snd (signed_list_lconjaction ss x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n   then snd x else \\<not> snd x)\n\ngoal (1 subgoal):\n 1. snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n     then snd x else \\<not> snd x)", "by (simp add: signed_lconjactionD)"], ["proof (state)\nthis:\n  snd (signed_list_lconjaction (s # ss) x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n   then snd x else \\<not> snd x)\n\ngoal (1 subgoal):\n 1. fst (signed_list_lconjaction ss x) \\<noteq> s \\<Longrightarrow>\n    snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)", "ultimately"], ["proof (chain)\npicking this:\n  count_list (lconjseq (rev (s # ss))) (fst x) =\n  count_list (lconjseq (rev ss)) (fst x)\n  snd (signed_list_lconjaction (s # ss) x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n   then snd x else \\<not> snd x)", "show ?thesis"], ["proof (prove)\nusing this:\n  count_list (lconjseq (rev (s # ss))) (fst x) =\n  count_list (lconjseq (rev ss)) (fst x)\n  snd (signed_list_lconjaction (s # ss) x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev ss)) (fst x)) 2\n   then snd x else \\<not> snd x)\n\ngoal (1 subgoal):\n 1. snd (signed_list_lconjaction (s # ss) x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n     then snd x else \\<not> snd x)", "by simp"], ["proof (state)\nthis:\n  snd (signed_list_lconjaction (s # ss) x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n   then snd x else \\<not> snd x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (signed_list_lconjaction (s # ss) x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev (s # ss))) (fst x)) 2\n   then snd x else \\<not> snd x)\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>set []. s + s = (0::'a) \\<Longrightarrow>\n    snd (signed_list_lconjaction [] x) =\n    (if gcd_nat.greater_eq (count_list (lconjseq (rev [])) (fst x)) 2\n     then snd x else \\<not> snd x)", "qed simp"], ["", "end"], ["", "(* context group_add *)"], ["", "subsection \\<open>Cosets\\<close>"], ["", "subsubsection \\<open>Basic facts\\<close>"], ["", "lemma set_zero_plus' [simp]: \"(0::'a::monoid_add) +o C = C\"\n\\<comment> \\<open>lemma @{text \"Set_Algebras.set_zero_plus\"} is restricted to types of class\n@{class comm_monoid_add}; here is a version in @{class monoid_add}.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) +o C = C", "by (auto simp add: elt_set_plus_def)"], ["", "lemma lcoset_0: \"(w::'a::monoid_add) +o 0 = {w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w +o 0 = {w}", "using elt_set_plus_def[of w]"], ["proof (prove)\nusing this:\n  w +o ?B = {c. \\<exists>b\\<in>?B. c = w + b}\n\ngoal (1 subgoal):\n 1. w +o 0 = {w}", "by simp"], ["", "lemma lcoset_refl: \"(0::'a::monoid_add) \\<in> A \\<Longrightarrow> a \\<in> a +o A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<in> A \\<Longrightarrow> a \\<in> a +o A", "using elt_set_plus_def"], ["proof (prove)\nusing this:\n  ?a +o ?B = {c. \\<exists>b\\<in>?B. c = ?a + b}\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> A \\<Longrightarrow> a \\<in> a +o A", "by force"], ["", "lemma lcoset_eq_reps_subset: \n  \"(a::'a::group_add) +o A \\<subseteq> a +o B \\<Longrightarrow> A \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (a +o B) (a +o A) \\<Longrightarrow>\n    order.greater_eq B A", "using elt_set_plus_def[of a]"], ["proof (prove)\nusing this:\n  a +o ?B = {c. \\<exists>b\\<in>?B. c = a + b}\n\ngoal (1 subgoal):\n 1. order.greater_eq (a +o B) (a +o A) \\<Longrightarrow>\n    order.greater_eq B A", "by auto"], ["", "lemma lcoset_eq_reps: \"(a::'a::group_add) +o A = a +o B \\<Longrightarrow> A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a +o A = a +o B \\<Longrightarrow> A = B", "using lcoset_eq_reps_subset[of a A B] lcoset_eq_reps_subset[of a B A]"], ["proof (prove)\nusing this:\n  order.greater_eq (a +o B) (a +o A) \\<Longrightarrow> order.greater_eq B A\n  order.greater_eq (a +o A) (a +o B) \\<Longrightarrow> order.greater_eq A B\n\ngoal (1 subgoal):\n 1. a +o A = a +o B \\<Longrightarrow> A = B", "by auto"], ["", "lemma lcoset_inj_on: \"inj ((+o) (a::'a::group_add))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ((+o) a)", "using lcoset_eq_reps inj_onI[of UNIV \"(+o) a\"]"], ["proof (prove)\nusing this:\n  ?a +o ?A = ?a +o ?B \\<Longrightarrow> ?A = ?B\n  (\\<And>x y.\n      \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; a +o x = a +o y\\<rbrakk>\n      \\<Longrightarrow> x = y) \\<Longrightarrow>\n  inj ((+o) a)\n\ngoal (1 subgoal):\n 1. inj ((+o) a)", "by auto"], ["", "lemma lcoset_conv_set: \"(a::'g::group_add) \\<in> b +o A \\<Longrightarrow> -b + a \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> b +o A \\<Longrightarrow> - b + a \\<in> A", "by (auto simp add: elt_set_plus_def)"], ["", "subsubsection \\<open>The supset order on cosets\\<close>"], ["", "lemma supset_lbound_lcoset_shift:\n  \"supset_lbound_of X Y B \\<Longrightarrow>\n    ordering.lbound_of (\\<supseteq>) (a +o X) (a +o Y) (a +o B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_order.lbound_of X Y B \\<Longrightarrow>\n    dual_order.lbound_of (a +o X) (a +o Y) (a +o B)", "using ordering.lbound_of_def[OF supset_poset, of X Y B]"], ["proof (prove)\nusing this:\n  dual_order.lbound_of X Y B \\<equiv>\n  order.greater_eq B X \\<and> order.greater_eq B Y\n\ngoal (1 subgoal):\n 1. dual_order.lbound_of X Y B \\<Longrightarrow>\n    dual_order.lbound_of (a +o X) (a +o Y) (a +o B)", "by    (fast intro: ordering.lbound_ofI supset_poset)"], ["", "lemma supset_glbound_in_of_lcoset_shift:\n  fixes   P :: \"'a::group_add set set\"\n  assumes \"supset_glbound_in_of P X Y B\"\n  shows   \"supset_glbound_in_of ((+o) a ` P) (a +o X) (a +o Y) (a +o B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_order.glbound_in_of ((+o) a ` P) (a +o X) (a +o Y) (a +o B)", "using   ordering.glbound_in_ofD_in[OF supset_poset, OF assms]\n          ordering.glbound_in_ofD_lbound[OF supset_poset, OF assms]\n          supset_lbound_lcoset_shift[of X Y B a]\n          supset_lbound_lcoset_shift[of \"a +o X\" \"a +o Y\" _ \"-a\"]\n          ordering.glbound_in_ofD_glbound[OF supset_poset, OF assms]\n          ordering.glbound_in_ofI[\n            OF supset_poset, of \"a +o B\" \"(+o) a ` P\" \"a +o X\" \"a +o Y\"\n          ]"], ["proof (prove)\nusing this:\n  B \\<in> P\n  dual_order.lbound_of X Y B\n  dual_order.lbound_of X Y B \\<Longrightarrow>\n  dual_order.lbound_of (a +o X) (a +o Y) (a +o B)\n  dual_order.lbound_of (a +o X) (a +o Y) ?B \\<Longrightarrow>\n  dual_order.lbound_of (- a +o (a +o X)) (- a +o (a +o Y)) (- a +o ?B)\n  \\<lbrakk>?a \\<in> P; dual_order.lbound_of X Y ?a\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq ?a B\n  \\<lbrakk>a +o B \\<in> (+o) a ` P;\n   dual_order.lbound_of (a +o X) (a +o Y) (a +o B);\n   \\<And>aa.\n      \\<lbrakk>aa \\<in> (+o) a ` P;\n       dual_order.lbound_of (a +o X) (a +o Y) aa\\<rbrakk>\n      \\<Longrightarrow> order.greater_eq aa (a +o B)\\<rbrakk>\n  \\<Longrightarrow> dual_order.glbound_in_of ((+o) a ` P) (a +o X) (a +o Y)\n                     (a +o B)\n\ngoal (1 subgoal):\n 1. dual_order.glbound_in_of ((+o) a ` P) (a +o X) (a +o Y) (a +o B)", "by      (fastforce simp add: set_plus_rearrange2)"], ["", "subsubsection \\<open>The afforded partition\\<close>"], ["", "definition lcoset_rel :: \"'a::{uminus,plus} set \\<Rightarrow> ('a\\<times>'a) set\"\n  where \"lcoset_rel A \\<equiv> {(x,y). -x + y \\<in> A}\""], ["", "lemma lcoset_relI: \"-x+y \\<in> A \\<Longrightarrow> (x,y) \\<in> lcoset_rel A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x + y \\<in> A \\<Longrightarrow> (x, y) \\<in> lcoset_rel A", "using lcoset_rel_def"], ["proof (prove)\nusing this:\n  lcoset_rel ?A \\<equiv> {(x, y). - x + y \\<in> ?A}\n\ngoal (1 subgoal):\n 1. - x + y \\<in> A \\<Longrightarrow> (x, y) \\<in> lcoset_rel A", "by fast"], ["", "subsection \\<open>Groups\\<close>"], ["", "text \\<open>We consider groups as closed sets in a type of class @{class group_add}.\\<close>"], ["", "subsubsection \\<open>Locale definition and basic facts\\<close>"], ["", "locale    Group =\n  fixes   G :: \"'g::group_add set\"\n  assumes nonempty   : \"G \\<noteq> {}\"\n  and     diff_closed: \"\\<And>g h. g \\<in> G \\<Longrightarrow> h \\<in> G \\<Longrightarrow> g - h \\<in> G\"\nbegin"], ["", "abbreviation Subgroup :: \"'g set \\<Rightarrow> bool\"\n  where \"Subgroup H \\<equiv> Group H \\<and> H \\<subseteq> G\""], ["", "lemma SubgroupD1: \"Subgroup H \\<Longrightarrow> Group H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group H \\<and> order.greater_eq G H \\<Longrightarrow> Group H", "by fast"], ["", "lemma zero_closed : \"0 \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'g) \\<in> G", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'g) \\<in> G", "from nonempty"], ["proof (chain)\npicking this:\n  G \\<noteq> {}", "obtain g where \"g \\<in> G\""], ["proof (prove)\nusing this:\n  G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>g. g \\<in> G \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fast"], ["proof (state)\nthis:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. (0::'g) \\<in> G", "hence \"g - g \\<in> G\""], ["proof (prove)\nusing this:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. g - g \\<in> G", "using diff_closed"], ["proof (prove)\nusing this:\n  g \\<in> G\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g - ?h \\<in> G\n\ngoal (1 subgoal):\n 1. g - g \\<in> G", "by fast"], ["proof (state)\nthis:\n  g - g \\<in> G\n\ngoal (1 subgoal):\n 1. (0::'g) \\<in> G", "thus ?thesis"], ["proof (prove)\nusing this:\n  g - g \\<in> G\n\ngoal (1 subgoal):\n 1. (0::'g) \\<in> G", "by simp"], ["proof (state)\nthis:\n  (0::'g) \\<in> G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uminus_closed: \"g\\<in>G \\<Longrightarrow> -g\\<in>G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> G \\<Longrightarrow> - g \\<in> G", "using zero_closed diff_closed[of 0 g]"], ["proof (prove)\nusing this:\n  (0::'g) \\<in> G\n  \\<lbrakk>(0::'g) \\<in> G; g \\<in> G\\<rbrakk>\n  \\<Longrightarrow> (0::'g) - g \\<in> G\n\ngoal (1 subgoal):\n 1. g \\<in> G \\<Longrightarrow> - g \\<in> G", "by simp"], ["", "lemma add_closed: \"g\\<in>G \\<Longrightarrow> h\\<in>G \\<Longrightarrow> g+h \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk> \\<Longrightarrow> g + h \\<in> G", "using uminus_closed[of h] diff_closed[of g \"-h\"]"], ["proof (prove)\nusing this:\n  h \\<in> G \\<Longrightarrow> - h \\<in> G\n  \\<lbrakk>g \\<in> G; - h \\<in> G\\<rbrakk> \\<Longrightarrow> g - - h \\<in> G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk> \\<Longrightarrow> g + h \\<in> G", "by simp"], ["", "lemma uminus_add_closed: \"g \\<in> G \\<Longrightarrow> h \\<in> G \\<Longrightarrow> -g + h \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk> \\<Longrightarrow> - g + h \\<in> G", "using uminus_closed add_closed"], ["proof (prove)\nusing this:\n  ?g \\<in> G \\<Longrightarrow> - ?g \\<in> G\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g + ?h \\<in> G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk> \\<Longrightarrow> - g + h \\<in> G", "by fast"], ["", "lemma lconjby_closed: \"g\\<in>G \\<Longrightarrow> x\\<in>G \\<Longrightarrow> lconjby g x \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; x \\<in> G\\<rbrakk>\n    \\<Longrightarrow> lconjby g x \\<in> G", "using add_closed diff_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g + ?h \\<in> G\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g - ?h \\<in> G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; x \\<in> G\\<rbrakk>\n    \\<Longrightarrow> lconjby g x \\<in> G", "by fast"], ["", "lemma lconjby_set_closed: \"g\\<in>G \\<Longrightarrow> A\\<subseteq>G \\<Longrightarrow> lconjby g ` A \\<subseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; order.greater_eq G A\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq G (lconjby g ` A)", "using lconjby_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; ?x \\<in> G\\<rbrakk>\n  \\<Longrightarrow> lconjby ?g ?x \\<in> G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; order.greater_eq G A\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq G (lconjby g ` A)", "by fast"], ["", "lemma set_lconjby_subset_closed:\n  \"H\\<subseteq>G \\<Longrightarrow> A\\<subseteq>G \\<Longrightarrow> (\\<Union>h\\<in>H. lconjby h ` A) \\<subseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq G H; order.greater_eq G A\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq G (\\<Union>h\\<in>H. lconjby h ` A)", "using lconjby_set_closed[of _ A]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; order.greater_eq G A\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq G (lconjby ?g ` A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq G H; order.greater_eq G A\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq G (\\<Union>h\\<in>H. lconjby h ` A)", "by fast"], ["", "lemma sum_list_map_closed: \"set (map f as) \\<subseteq> G \\<Longrightarrow> (\\<Sum>a\\<leftarrow>as. f a) \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq G (set (map f as)) \\<Longrightarrow>\n    sum_list (map f as) \\<in> G", "using zero_closed add_closed"], ["proof (prove)\nusing this:\n  (0::'g) \\<in> G\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g + ?h \\<in> G\n\ngoal (1 subgoal):\n 1. order.greater_eq G (set (map f as)) \\<Longrightarrow>\n    sum_list (map f as) \\<in> G", "by (induct as) auto"], ["", "lemma sum_list_closed: \"set as \\<subseteq> G \\<Longrightarrow> sum_list as \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq G (set as) \\<Longrightarrow> sum_list as \\<in> G", "using sum_list_map_closed"], ["proof (prove)\nusing this:\n  order.greater_eq G (set (map ?f ?as)) \\<Longrightarrow>\n  sum_list (map ?f ?as) \\<in> G\n\ngoal (1 subgoal):\n 1. order.greater_eq G (set as) \\<Longrightarrow> sum_list as \\<in> G", "by force"], ["", "end"], ["", "(* context Group *)"], ["", "subsubsection \\<open>Sets with a suitable binary operation\\<close>"], ["", "text \\<open>\n  We have chosen to only consider groups in types of class @{class group_add} so that we can take\n  advantage of all the algebra lemmas already proven in @{theory HOL.Groups}, as well as\n  constructs like @{const sum_list}. The following locale builds a bridge between this restricted\n  view of groups and the usual notion of a binary operation on a set satisfying the group axioms,\n  by constructing an injective map into type @{type permutation} (which is of class\n  @{class group_add} with respect to the composition operation) that respects the group operation.\n  This bridge will be necessary to define quotient groups, in particular.\n\\<close>"], ["", "locale BinOpSetGroup =\n  fixes G     :: \"'a set\"\n  and   binop :: \"'a\\<Rightarrow>'a\\<Rightarrow>'a\"\n  and   e     :: \"'a\"\n  assumes closed  : \"g\\<in>G \\<Longrightarrow> h\\<in>G \\<Longrightarrow> binop g h \\<in> G\"\n  and     assoc   :\n    \"\\<lbrakk> g\\<in>G; h\\<in>G; k\\<in>G \\<rbrakk> \\<Longrightarrow> binop (binop g h) k = binop g (binop h k)\"\n  and     identity: \"e\\<in>G\" \"g\\<in>G \\<Longrightarrow> binop g e = g\" \"g\\<in>G \\<Longrightarrow> binop e g = g\"\n  and     inverses: \"g\\<in>G \\<Longrightarrow> \\<exists>h\\<in>G. binop g h = e \\<and> binop h g = e\"\nbegin"], ["", "lemma unique_identity1: \"g\\<in>G \\<Longrightarrow> \\<forall>x\\<in>G. binop g x = x \\<Longrightarrow> g = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; \\<forall>x\\<in>G. binop g x = x\\<rbrakk>\n    \\<Longrightarrow> g = e", "using identity(1,2)"], ["proof (prove)\nusing this:\n  e \\<in> G\n  ?g \\<in> G \\<Longrightarrow> binop ?g e = ?g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; \\<forall>x\\<in>G. binop g x = x\\<rbrakk>\n    \\<Longrightarrow> g = e", "by auto"], ["", "lemma unique_inverse:\n  assumes \"g\\<in>G\"\n  shows   \"\\<exists>!h. h\\<in>G \\<and> binop g h = e \\<and> binop h g = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!h. h \\<in> G \\<and> binop g h = e \\<and> binop h g = e", "proof (rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>h. h \\<in> G \\<and> binop g h = e \\<and> binop h g = e\n 2. \\<And>h y.\n       \\<lbrakk>h \\<in> G \\<and> binop g h = e \\<and> binop h g = e;\n        y \\<in> G \\<and> binop g y = e \\<and> binop y g = e\\<rbrakk>\n       \\<Longrightarrow> h = y", "from assms"], ["proof (chain)\npicking this:\n  g \\<in> G", "show \"\\<exists>h. h \\<in> G \\<and> binop g h = e \\<and> binop h g = e\""], ["proof (prove)\nusing this:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> G \\<and> binop g h = e \\<and> binop h g = e", "using inverses"], ["proof (prove)\nusing this:\n  g \\<in> G\n  ?g \\<in> G \\<Longrightarrow>\n  \\<exists>h\\<in>G. binop ?g h = e \\<and> binop h ?g = e\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> G \\<and> binop g h = e \\<and> binop h g = e", "by fast"], ["proof (state)\nthis:\n  \\<exists>h. h \\<in> G \\<and> binop g h = e \\<and> binop h g = e\n\ngoal (1 subgoal):\n 1. \\<And>h y.\n       \\<lbrakk>h \\<in> G \\<and> binop g h = e \\<and> binop h g = e;\n        y \\<in> G \\<and> binop g y = e \\<and> binop y g = e\\<rbrakk>\n       \\<Longrightarrow> h = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h y.\n       \\<lbrakk>h \\<in> G \\<and> binop g h = e \\<and> binop h g = e;\n        y \\<in> G \\<and> binop g y = e \\<and> binop y g = e\\<rbrakk>\n       \\<Longrightarrow> h = y", "fix h k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h y.\n       \\<lbrakk>h \\<in> G \\<and> binop g h = e \\<and> binop h g = e;\n        y \\<in> G \\<and> binop g y = e \\<and> binop y g = e\\<rbrakk>\n       \\<Longrightarrow> h = y", "assume \"h\\<in>G \\<and> binop g h = e \\<and> binop h g = e\" \"k\\<in>G \\<and>\n            binop g k = e \\<and> binop k g = e\""], ["proof (state)\nthis:\n  h \\<in> G \\<and> binop g h = e \\<and> binop h g = e\n  k \\<in> G \\<and> binop g k = e \\<and> binop k g = e\n\ngoal (1 subgoal):\n 1. \\<And>h y.\n       \\<lbrakk>h \\<in> G \\<and> binop g h = e \\<and> binop h g = e;\n        y \\<in> G \\<and> binop g y = e \\<and> binop y g = e\\<rbrakk>\n       \\<Longrightarrow> h = y", "hence h: \"h\\<in>G\" \"binop g h = e\" \"binop h g = e\"\n    and k: \"k\\<in>G\" \"binop g k = e\" \"binop k g = e\""], ["proof (prove)\nusing this:\n  h \\<in> G \\<and> binop g h = e \\<and> binop h g = e\n  k \\<in> G \\<and> binop g k = e \\<and> binop k g = e\n\ngoal (1 subgoal):\n 1. (h \\<in> G &&& binop g h = e &&& binop h g = e) &&&\n    k \\<in> G &&& binop g k = e &&& binop k g = e", "by  auto"], ["proof (state)\nthis:\n  h \\<in> G\n  binop g h = e\n  binop h g = e\n  k \\<in> G\n  binop g k = e\n  binop k g = e\n\ngoal (1 subgoal):\n 1. \\<And>h y.\n       \\<lbrakk>h \\<in> G \\<and> binop g h = e \\<and> binop h g = e;\n        y \\<in> G \\<and> binop g y = e \\<and> binop y g = e\\<rbrakk>\n       \\<Longrightarrow> h = y", "from assms h(1,3) k(1,2)"], ["proof (chain)\npicking this:\n  g \\<in> G\n  h \\<in> G\n  binop h g = e\n  k \\<in> G\n  binop g k = e", "show \"h=k\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  h \\<in> G\n  binop h g = e\n  k \\<in> G\n  binop g k = e\n\ngoal (1 subgoal):\n 1. h = k", "using identity(2,3) assoc"], ["proof (prove)\nusing this:\n  g \\<in> G\n  h \\<in> G\n  binop h g = e\n  k \\<in> G\n  binop g k = e\n  ?g \\<in> G \\<Longrightarrow> binop ?g e = ?g\n  ?g \\<in> G \\<Longrightarrow> binop e ?g = ?g\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G; ?k \\<in> G\\<rbrakk>\n  \\<Longrightarrow> binop (binop ?g ?h) ?k = binop ?g (binop ?h ?k)\n\ngoal (1 subgoal):\n 1. h = k", "by force"], ["proof (state)\nthis:\n  h = k\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"G_perm g \\<equiv> restrict1 (binop g) G\""], ["", "definition Abs_G_perm :: \"'a \\<Rightarrow> 'a permutation\"\n  where \"Abs_G_perm g \\<equiv> Abs_permutation (G_perm g)\""], ["", "abbreviation \"\\<pp> \\<equiv> Abs_G_perm\" \\<comment> \\<open>the injection into type @{type permutation}\\<close>"], ["", "abbreviation \"\\<ii>\\<pp> \\<equiv> the_inv_into G \\<pp>\" \\<comment> \\<open>the reverse correspondence\\<close>"], ["", "abbreviation \"pG \\<equiv> \\<pp>`G\" \\<comment> \\<open>the resulting @{const Group} of type @{type permutation}\\<close>"], ["", "lemma G_perm_comp:\n  \"g\\<in>G \\<Longrightarrow> h\\<in>G \\<Longrightarrow> G_perm g \\<circ> G_perm h = G_perm (binop g h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk>\n    \\<Longrightarrow> G_perm g \\<circ> G_perm h = G_perm (binop g h)", "using closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> binop ?g ?h \\<in> G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk>\n    \\<Longrightarrow> G_perm g \\<circ> G_perm h = G_perm (binop g h)", "by (auto simp add: assoc)"], ["", "definition the_inverse :: \"'a \\<Rightarrow> 'a\"\n  where \"the_inverse g \\<equiv> (THE h. h\\<in>G \\<and> binop g h = e \\<and> binop h g = e)\""], ["", "abbreviation \"\\<ii> \\<equiv> the_inverse\""], ["", "lemma the_inverseD:\n  assumes   \"g\\<in>G\"\n  shows     \"\\<ii> g \\<in> G\" \"binop g (\\<ii> g) = e\" \"binop (\\<ii> g) g = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ii> g \\<in> G &&& binop g (\\<ii> g) = e &&& binop (\\<ii> g) g = e", "using     assms theI'[OF unique_inverse]"], ["proof (prove)\nusing this:\n  g \\<in> G\n  ?g1 \\<in> G \\<Longrightarrow>\n  (THE x. x \\<in> G \\<and> binop ?g1 x = e \\<and> binop x ?g1 = e)\n  \\<in> G \\<and>\n  binop ?g1\n   (THE x. x \\<in> G \\<and> binop ?g1 x = e \\<and> binop x ?g1 = e) =\n  e \\<and>\n  binop (THE x. x \\<in> G \\<and> binop ?g1 x = e \\<and> binop x ?g1 = e)\n   ?g1 =\n  e\n\ngoal (1 subgoal):\n 1. \\<ii> g \\<in> G &&& binop g (\\<ii> g) = e &&& binop (\\<ii> g) g = e", "unfolding the_inverse_def"], ["proof (prove)\nusing this:\n  g \\<in> G\n  ?g1 \\<in> G \\<Longrightarrow>\n  (THE x. x \\<in> G \\<and> binop ?g1 x = e \\<and> binop x ?g1 = e)\n  \\<in> G \\<and>\n  binop ?g1\n   (THE x. x \\<in> G \\<and> binop ?g1 x = e \\<and> binop x ?g1 = e) =\n  e \\<and>\n  binop (THE x. x \\<in> G \\<and> binop ?g1 x = e \\<and> binop x ?g1 = e)\n   ?g1 =\n  e\n\ngoal (1 subgoal):\n 1. (THE h. h \\<in> G \\<and> binop g h = e \\<and> binop h g = e) \\<in> G &&&\n    binop g (THE h. h \\<in> G \\<and> binop g h = e \\<and> binop h g = e) =\n    e &&&\n    binop (THE h. h \\<in> G \\<and> binop g h = e \\<and> binop h g = e) g = e", "by        auto"], ["", "lemma binop_G_comp_binop_\\<ii>G: \"g\\<in>G \\<Longrightarrow> x\\<in>G \\<Longrightarrow> binop g (binop (\\<ii> g) x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; x \\<in> G\\<rbrakk>\n    \\<Longrightarrow> binop g (binop (\\<ii> g) x) = x", "using the_inverseD(1) assoc[of g \"\\<ii> g\" x]"], ["proof (prove)\nusing this:\n  ?g \\<in> G \\<Longrightarrow> \\<ii> ?g \\<in> G\n  \\<lbrakk>g \\<in> G; \\<ii> g \\<in> G; x \\<in> G\\<rbrakk>\n  \\<Longrightarrow> binop (binop g (\\<ii> g)) x =\n                    binop g (binop (\\<ii> g) x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; x \\<in> G\\<rbrakk>\n    \\<Longrightarrow> binop g (binop (\\<ii> g) x) = x", "by (simp add: identity(3) the_inverseD(2))"], ["", "lemma bij_betw_binop_G:\n  assumes   \"g\\<in>G\"\n  shows     \"bij_betw (binop g) G G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (binop g) G G", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (binop g) G \\<and> binop g ` G = G", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (binop g) G\n 2. binop g ` G = G", "show \"inj_on (binop g) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (binop g) G", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; binop g x = binop g y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix h k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; binop g x = binop g y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume hk: \"h\\<in>G\" \"k\\<in>G\" \"binop g h = binop g k\""], ["proof (state)\nthis:\n  h \\<in> G\n  k \\<in> G\n  binop g h = binop g k\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; binop g x = binop g y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with assms"], ["proof (chain)\npicking this:\n  g \\<in> G\n  h \\<in> G\n  k \\<in> G\n  binop g h = binop g k", "have \"binop (binop (\\<ii> g) g) h = binop (binop (\\<ii> g) g) k\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  h \\<in> G\n  k \\<in> G\n  binop g h = binop g k\n\ngoal (1 subgoal):\n 1. binop (binop (\\<ii> g) g) h = binop (binop (\\<ii> g) g) k", "using the_inverseD(1)"], ["proof (prove)\nusing this:\n  g \\<in> G\n  h \\<in> G\n  k \\<in> G\n  binop g h = binop g k\n  ?g \\<in> G \\<Longrightarrow> \\<ii> ?g \\<in> G\n\ngoal (1 subgoal):\n 1. binop (binop (\\<ii> g) g) h = binop (binop (\\<ii> g) g) k", "by (simp add: assoc)"], ["proof (state)\nthis:\n  binop (binop (\\<ii> g) g) h = binop (binop (\\<ii> g) g) k\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; binop g x = binop g y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with assms hk(1,2)"], ["proof (chain)\npicking this:\n  g \\<in> G\n  h \\<in> G\n  k \\<in> G\n  binop (binop (\\<ii> g) g) h = binop (binop (\\<ii> g) g) k", "show \"h=k\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  h \\<in> G\n  k \\<in> G\n  binop (binop (\\<ii> g) g) h = binop (binop (\\<ii> g) g) k\n\ngoal (1 subgoal):\n 1. h = k", "using the_inverseD(3) identity"], ["proof (prove)\nusing this:\n  g \\<in> G\n  h \\<in> G\n  k \\<in> G\n  binop (binop (\\<ii> g) g) h = binop (binop (\\<ii> g) g) k\n  ?g \\<in> G \\<Longrightarrow> binop (\\<ii> ?g) ?g = e\n  e \\<in> G\n  ?g \\<in> G \\<Longrightarrow> binop ?g e = ?g\n  ?g \\<in> G \\<Longrightarrow> binop e ?g = ?g\n\ngoal (1 subgoal):\n 1. h = k", "by simp"], ["proof (state)\nthis:\n  h = k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (binop g) G\n\ngoal (1 subgoal):\n 1. binop g ` G = G", "show \"binop g ` G = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binop g ` G = G", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq G (binop g ` G)\n 2. order.greater_eq (binop g ` G) G", "from assms"], ["proof (chain)\npicking this:\n  g \\<in> G", "show \"binop g ` G \\<subseteq> G\""], ["proof (prove)\nusing this:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. order.greater_eq G (binop g ` G)", "using closed"], ["proof (prove)\nusing this:\n  g \\<in> G\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> binop ?g ?h \\<in> G\n\ngoal (1 subgoal):\n 1. order.greater_eq G (binop g ` G)", "by fast"], ["proof (state)\nthis:\n  order.greater_eq G (binop g ` G)\n\ngoal (1 subgoal):\n 1. order.greater_eq (binop g ` G) G", "from assms"], ["proof (chain)\npicking this:\n  g \\<in> G", "show \"binop g ` G \\<supseteq> G\""], ["proof (prove)\nusing this:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. order.greater_eq (binop g ` G) G", "using binop_G_comp_binop_\\<ii>G[THEN sym] the_inverseD(1) closed"], ["proof (prove)\nusing this:\n  g \\<in> G\n  \\<lbrakk>?g1 \\<in> G; ?t \\<in> G\\<rbrakk>\n  \\<Longrightarrow> ?t = binop ?g1 (binop (\\<ii> ?g1) ?t)\n  ?g \\<in> G \\<Longrightarrow> \\<ii> ?g \\<in> G\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> binop ?g ?h \\<in> G\n\ngoal (1 subgoal):\n 1. order.greater_eq (binop g ` G) G", "by fast"], ["proof (state)\nthis:\n  order.greater_eq (binop g ` G) G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  binop g ` G = G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma the_inv_into_G_binop_G:\n  assumes \"g\\<in>G\" \"x\\<in>G\"\n  shows   \"the_inv_into G (binop g) x = binop (\\<ii> g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv_into G (binop g) x = binop (\\<ii> g) x", "proof (rule the_inv_into_f_eq)"], ["proof (state)\ngoal (3 subgoals):\n 1. inj_on (binop g) G\n 2. binop g (binop (\\<ii> g) x) = x\n 3. binop (\\<ii> g) x \\<in> G", "from assms(1)"], ["proof (chain)\npicking this:\n  g \\<in> G", "show \"inj_on (binop g) G\""], ["proof (prove)\nusing this:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. inj_on (binop g) G", "using bij_betw_imp_inj_on[OF bij_betw_binop_G]"], ["proof (prove)\nusing this:\n  g \\<in> G\n  ?g1 \\<in> G \\<Longrightarrow> inj_on (binop ?g1) G\n\ngoal (1 subgoal):\n 1. inj_on (binop g) G", "by fast"], ["proof (state)\nthis:\n  inj_on (binop g) G\n\ngoal (2 subgoals):\n 1. binop g (binop (\\<ii> g) x) = x\n 2. binop (\\<ii> g) x \\<in> G", "from assms"], ["proof (chain)\npicking this:\n  g \\<in> G\n  x \\<in> G", "show \"binop g (binop (\\<ii> g) x) = x\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  x \\<in> G\n\ngoal (1 subgoal):\n 1. binop g (binop (\\<ii> g) x) = x", "using binop_G_comp_binop_\\<ii>G"], ["proof (prove)\nusing this:\n  g \\<in> G\n  x \\<in> G\n  \\<lbrakk>?g \\<in> G; ?x \\<in> G\\<rbrakk>\n  \\<Longrightarrow> binop ?g (binop (\\<ii> ?g) ?x) = ?x\n\ngoal (1 subgoal):\n 1. binop g (binop (\\<ii> g) x) = x", "by fast"], ["proof (state)\nthis:\n  binop g (binop (\\<ii> g) x) = x\n\ngoal (1 subgoal):\n 1. binop (\\<ii> g) x \\<in> G", "from assms"], ["proof (chain)\npicking this:\n  g \\<in> G\n  x \\<in> G", "show \"binop (\\<ii> g) x \\<in> G\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  x \\<in> G\n\ngoal (1 subgoal):\n 1. binop (\\<ii> g) x \\<in> G", "using closed the_inverseD(1)"], ["proof (prove)\nusing this:\n  g \\<in> G\n  x \\<in> G\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> binop ?g ?h \\<in> G\n  ?g \\<in> G \\<Longrightarrow> \\<ii> ?g \\<in> G\n\ngoal (1 subgoal):\n 1. binop (\\<ii> g) x \\<in> G", "by fast"], ["proof (state)\nthis:\n  binop (\\<ii> g) x \\<in> G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restrict1_the_inv_into_G_binop_G:\n  \"g\\<in>G \\<Longrightarrow> restrict1 (the_inv_into G (binop g)) G = G_perm (\\<ii> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> G \\<Longrightarrow>\n    restrict1 (the_inv_into G (binop g)) G = G_perm (\\<ii> g)", "using the_inv_into_G_binop_G"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; ?x \\<in> G\\<rbrakk>\n  \\<Longrightarrow> the_inv_into G (binop ?g) ?x = binop (\\<ii> ?g) ?x\n\ngoal (1 subgoal):\n 1. g \\<in> G \\<Longrightarrow>\n    restrict1 (the_inv_into G (binop g)) G = G_perm (\\<ii> g)", "by auto"], ["", "lemma bij_G_perm: \"g\\<in>G \\<Longrightarrow> bij (G_perm g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> G \\<Longrightarrow> bij (G_perm g)", "using set_permutation_bij_restrict1 bij_betw_binop_G"], ["proof (prove)\nusing this:\n  bij_betw ?f ?A ?A \\<Longrightarrow> bij (restrict1 ?f ?A)\n  ?g \\<in> G \\<Longrightarrow> bij_betw (binop ?g) G G\n\ngoal (1 subgoal):\n 1. g \\<in> G \\<Longrightarrow> bij (G_perm g)", "by fast"], ["", "lemma G_perm_apply: \"g\\<in>G \\<Longrightarrow> x\\<in>G \\<Longrightarrow> \\<pp> g \\<rightarrow> x = binop g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; x \\<in> G\\<rbrakk>\n    \\<Longrightarrow> \\<pp> g \\<rightarrow> x = binop g x", "using Abs_G_perm_def Abs_permutation_inverse bij_G_perm"], ["proof (prove)\nusing this:\n  \\<pp> ?g \\<equiv> Abs_permutation (G_perm ?g)\n  ?y \\<in> {f. bij f} \\<Longrightarrow>\n  (\\<rightarrow>) (Abs_permutation ?y) = ?y\n  ?g \\<in> G \\<Longrightarrow> bij (G_perm ?g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; x \\<in> G\\<rbrakk>\n    \\<Longrightarrow> \\<pp> g \\<rightarrow> x = binop g x", "by fastforce"], ["", "lemma G_perm_apply_identity: \"g\\<in>G \\<Longrightarrow> \\<pp> g \\<rightarrow> e = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> G \\<Longrightarrow> \\<pp> g \\<rightarrow> e = g", "using G_perm_apply identity(1,2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; ?x \\<in> G\\<rbrakk>\n  \\<Longrightarrow> \\<pp> ?g \\<rightarrow> ?x = binop ?g ?x\n  e \\<in> G\n  ?g \\<in> G \\<Longrightarrow> binop ?g e = ?g\n\ngoal (1 subgoal):\n 1. g \\<in> G \\<Longrightarrow> \\<pp> g \\<rightarrow> e = g", "by simp"], ["", "lemma the_inv_G_perm:\n  \"g\\<in>G \\<Longrightarrow> the_inv (G_perm g) = G_perm (\\<ii> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> G \\<Longrightarrow> the_inv (G_perm g) = G_perm (\\<ii> g)", "using set_permutation_the_inv_restrict1 bij_betw_binop_G\n        restrict1_the_inv_into_G_binop_G"], ["proof (prove)\nusing this:\n  bij_betw ?f ?A ?A \\<Longrightarrow>\n  the_inv (restrict1 ?f ?A) = restrict1 (the_inv_into ?A ?f) ?A\n  ?g \\<in> G \\<Longrightarrow> bij_betw (binop ?g) G G\n  ?g \\<in> G \\<Longrightarrow>\n  restrict1 (the_inv_into G (binop ?g)) G = G_perm (\\<ii> ?g)\n\ngoal (1 subgoal):\n 1. g \\<in> G \\<Longrightarrow> the_inv (G_perm g) = G_perm (\\<ii> g)", "by    fastforce"], ["", "lemma Abs_G_perm_diff:\n  \"g\\<in>G \\<Longrightarrow> h\\<in>G \\<Longrightarrow> \\<pp> g - \\<pp> h = \\<pp> (binop g (\\<ii> h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk>\n    \\<Longrightarrow> \\<pp> g - \\<pp> h = \\<pp> (binop g (\\<ii> h))", "using Abs_G_perm_def minus_permutation_abs_eq[OF bij_G_perm bij_G_perm]\n        the_inv_G_perm G_perm_comp the_inverseD(1)"], ["proof (prove)\nusing this:\n  \\<pp> ?g \\<equiv> Abs_permutation (G_perm ?g)\n  \\<lbrakk>?g2 \\<in> G; ?g1 \\<in> G\\<rbrakk>\n  \\<Longrightarrow> Abs_permutation (G_perm ?g2) -\n                    Abs_permutation (G_perm ?g1) =\n                    Abs_permutation\n                     (G_perm ?g2 \\<circ> the_inv (G_perm ?g1))\n  ?g \\<in> G \\<Longrightarrow> the_inv (G_perm ?g) = G_perm (\\<ii> ?g)\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> G_perm ?g \\<circ> G_perm ?h = G_perm (binop ?g ?h)\n  ?g \\<in> G \\<Longrightarrow> \\<ii> ?g \\<in> G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk>\n    \\<Longrightarrow> \\<pp> g - \\<pp> h = \\<pp> (binop g (\\<ii> h))", "by    simp"], ["", "lemma Group: \"Group pG\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group pG", "using identity(1) Abs_G_perm_diff the_inverseD(1) closed"], ["proof (prove)\nusing this:\n  e \\<in> G\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> \\<pp> ?g - \\<pp> ?h = \\<pp> (binop ?g (\\<ii> ?h))\n  ?g \\<in> G \\<Longrightarrow> \\<ii> ?g \\<in> G\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> binop ?g ?h \\<in> G\n\ngoal (1 subgoal):\n 1. Group pG", "by unfold_locales auto"], ["", "lemma inj_on_\\<pp>_G: \"inj_on \\<pp> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<pp> G", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; \\<pp> x = \\<pp> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; \\<pp> x = \\<pp> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume xy: \"x\\<in>G\" \"y\\<in>G\" \"\\<pp> x = \\<pp> y\""], ["proof (state)\nthis:\n  x \\<in> G\n  y \\<in> G\n  \\<pp> x = \\<pp> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; \\<pp> x = \\<pp> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"Abs_permutation (G_perm (binop x (\\<ii> y))) = Abs_permutation id\""], ["proof (prove)\nusing this:\n  x \\<in> G\n  y \\<in> G\n  \\<pp> x = \\<pp> y\n\ngoal (1 subgoal):\n 1. Abs_permutation (G_perm (binop x (\\<ii> y))) = Abs_permutation id", "using Abs_G_perm_diff Abs_G_perm_def"], ["proof (prove)\nusing this:\n  x \\<in> G\n  y \\<in> G\n  \\<pp> x = \\<pp> y\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> \\<pp> ?g - \\<pp> ?h = \\<pp> (binop ?g (\\<ii> ?h))\n  \\<pp> ?g \\<equiv> Abs_permutation (G_perm ?g)\n\ngoal (1 subgoal):\n 1. Abs_permutation (G_perm (binop x (\\<ii> y))) = Abs_permutation id", "by (fastforce simp add: zero_permutation.abs_eq)"], ["proof (state)\nthis:\n  Abs_permutation (G_perm (binop x (\\<ii> y))) = Abs_permutation id\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; \\<pp> x = \\<pp> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  Abs_permutation (G_perm (binop x (\\<ii> y))) = Abs_permutation id\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; \\<pp> x = \\<pp> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from xy(1,2)"], ["proof (chain)\npicking this:\n  x \\<in> G\n  y \\<in> G", "have 1: \"binop x (\\<ii> y) \\<in> G\""], ["proof (prove)\nusing this:\n  x \\<in> G\n  y \\<in> G\n\ngoal (1 subgoal):\n 1. binop x (\\<ii> y) \\<in> G", "using bij_id closed the_inverseD(1)"], ["proof (prove)\nusing this:\n  x \\<in> G\n  y \\<in> G\n  bij id\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> binop ?g ?h \\<in> G\n  ?g \\<in> G \\<Longrightarrow> \\<ii> ?g \\<in> G\n\ngoal (1 subgoal):\n 1. binop x (\\<ii> y) \\<in> G", "by fast"], ["proof (state)\nthis:\n  binop x (\\<ii> y) \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; \\<pp> x = \\<pp> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  Abs_permutation (G_perm (binop x (\\<ii> y))) = Abs_permutation id\n  binop x (\\<ii> y) \\<in> G", "have 2: \"G_perm (binop x (\\<ii> y)) = id\""], ["proof (prove)\nusing this:\n  Abs_permutation (G_perm (binop x (\\<ii> y))) = Abs_permutation id\n  binop x (\\<ii> y) \\<in> G\n\ngoal (1 subgoal):\n 1. G_perm (binop x (\\<ii> y)) = id", "using Abs_permutation_inject[of \"G_perm (binop x (\\<ii> y))\"] bij_G_perm bij_id"], ["proof (prove)\nusing this:\n  Abs_permutation (G_perm (binop x (\\<ii> y))) = Abs_permutation id\n  binop x (\\<ii> y) \\<in> G\n  \\<lbrakk>G_perm (binop x (\\<ii> y)) \\<in> {f. bij f};\n   ?y \\<in> {f. bij f}\\<rbrakk>\n  \\<Longrightarrow> (Abs_permutation (G_perm (binop x (\\<ii> y))) =\n                     Abs_permutation ?y) =\n                    (G_perm (binop x (\\<ii> y)) = ?y)\n  ?g \\<in> G \\<Longrightarrow> bij (G_perm ?g)\n  bij id\n\ngoal (1 subgoal):\n 1. G_perm (binop x (\\<ii> y)) = id", "by    simp"], ["proof (state)\nthis:\n  G_perm (binop x (\\<ii> y)) = id\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; \\<pp> x = \\<pp> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"\\<forall>z\\<in>G. binop (binop x (\\<ii> y)) z = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>G. binop (binop x (\\<ii> y)) z = z", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> G \\<Longrightarrow> binop (binop x (\\<ii> y)) z = z", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> G \\<Longrightarrow> binop (binop x (\\<ii> y)) z = z", "assume \"z\\<in>G\""], ["proof (state)\nthis:\n  z \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> G \\<Longrightarrow> binop (binop x (\\<ii> y)) z = z", "thus \"binop (binop x (\\<ii> y)) z = z\""], ["proof (prove)\nusing this:\n  z \\<in> G\n\ngoal (1 subgoal):\n 1. binop (binop x (\\<ii> y)) z = z", "using fun_cong[OF 2, of z]"], ["proof (prove)\nusing this:\n  z \\<in> G\n  G_perm (binop x (\\<ii> y)) z = id z\n\ngoal (1 subgoal):\n 1. binop (binop x (\\<ii> y)) z = z", "by simp"], ["proof (state)\nthis:\n  binop (binop x (\\<ii> y)) z = z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>z\\<in>G. binop (binop x (\\<ii> y)) z = z\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; \\<pp> x = \\<pp> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with xy(1,2)"], ["proof (chain)\npicking this:\n  x \\<in> G\n  y \\<in> G\n  \\<forall>z\\<in>G. binop (binop x (\\<ii> y)) z = z", "have \"binop x (binop (\\<ii> y) y) = y\""], ["proof (prove)\nusing this:\n  x \\<in> G\n  y \\<in> G\n  \\<forall>z\\<in>G. binop (binop x (\\<ii> y)) z = z\n\ngoal (1 subgoal):\n 1. binop x (binop (\\<ii> y) y) = y", "using unique_identity1[OF 1] the_inverseD(1)"], ["proof (prove)\nusing this:\n  x \\<in> G\n  y \\<in> G\n  \\<forall>z\\<in>G. binop (binop x (\\<ii> y)) z = z\n  \\<forall>xa\\<in>G. binop (binop x (\\<ii> y)) xa = xa \\<Longrightarrow>\n  binop x (\\<ii> y) = e\n  ?g \\<in> G \\<Longrightarrow> \\<ii> ?g \\<in> G\n\ngoal (1 subgoal):\n 1. binop x (binop (\\<ii> y) y) = y", "by (simp add: assoc)"], ["proof (state)\nthis:\n  binop x (binop (\\<ii> y) y) = y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; \\<pp> x = \\<pp> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with xy(1,2)"], ["proof (chain)\npicking this:\n  x \\<in> G\n  y \\<in> G\n  binop x (binop (\\<ii> y) y) = y", "show \"x = y\""], ["proof (prove)\nusing this:\n  x \\<in> G\n  y \\<in> G\n  binop x (binop (\\<ii> y) y) = y\n\ngoal (1 subgoal):\n 1. x = y", "using the_inverseD(3) identity(2)"], ["proof (prove)\nusing this:\n  x \\<in> G\n  y \\<in> G\n  binop x (binop (\\<ii> y) y) = y\n  ?g \\<in> G \\<Longrightarrow> binop (\\<ii> ?g) ?g = e\n  ?g \\<in> G \\<Longrightarrow> binop ?g e = ?g\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homs:\n  \"\\<And>g h. g\\<in>G \\<Longrightarrow> h\\<in>G \\<Longrightarrow> \\<pp> (binop g h) = \\<pp> g + \\<pp> h\"\n  \"\\<And>x y. x\\<in>pG \\<Longrightarrow> y\\<in>pG \\<Longrightarrow> binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) = \\<ii>\\<pp> (x+y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk>\n        \\<Longrightarrow> \\<pp> (binop g h) = \\<pp> g + \\<pp> h) &&&\n    (\\<And>x y.\n        \\<lbrakk>x \\<in> pG; y \\<in> pG\\<rbrakk>\n        \\<Longrightarrow> binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) =\n                          \\<ii>\\<pp> (x + y))", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk>\n       \\<Longrightarrow> \\<pp> (binop g h) = \\<pp> g + \\<pp> h\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> pG; y \\<in> pG\\<rbrakk>\n       \\<Longrightarrow> binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) =\n                         \\<ii>\\<pp> (x + y)", "show 1: \"\\<And>g h. g\\<in>G \\<Longrightarrow> h\\<in>G \\<Longrightarrow> \\<pp> (binop g h) = \\<pp> g + \\<pp> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk>\n       \\<Longrightarrow> \\<pp> (binop g h) = \\<pp> g + \\<pp> h", "using Abs_G_perm_def G_perm_comp\n          plus_permutation_abs_eq[OF bij_G_perm bij_G_perm]"], ["proof (prove)\nusing this:\n  \\<pp> ?g \\<equiv> Abs_permutation (G_perm ?g)\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> G_perm ?g \\<circ> G_perm ?h = G_perm (binop ?g ?h)\n  \\<lbrakk>?g2 \\<in> G; ?g1 \\<in> G\\<rbrakk>\n  \\<Longrightarrow> Abs_permutation (G_perm ?g2) +\n                    Abs_permutation (G_perm ?g1) =\n                    Abs_permutation (G_perm ?g2 \\<circ> G_perm ?g1)\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk>\n       \\<Longrightarrow> \\<pp> (binop g h) = \\<pp> g + \\<pp> h", "by    simp"], ["proof (state)\nthis:\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> \\<pp> (binop ?g ?h) = \\<pp> ?g + \\<pp> ?h\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> pG; y \\<in> pG\\<rbrakk>\n       \\<Longrightarrow> binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) =\n                         \\<ii>\\<pp> (x + y)", "show \"\\<And>x y. x\\<in>pG \\<Longrightarrow> y\\<in>pG \\<Longrightarrow> binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) = \\<ii>\\<pp> (x+y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> pG; y \\<in> pG\\<rbrakk>\n       \\<Longrightarrow> binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) =\n                         \\<ii>\\<pp> (x + y)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> pG; y \\<in> pG\\<rbrakk>\n       \\<Longrightarrow> binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) =\n                         \\<ii>\\<pp> (x + y)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> pG; y \\<in> pG\\<rbrakk>\n       \\<Longrightarrow> binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) =\n                         \\<ii>\\<pp> (x + y)", "assume \"x\\<in>pG\" \"y\\<in>pG\""], ["proof (state)\nthis:\n  x \\<in> pG\n  y \\<in> pG\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> pG; y \\<in> pG\\<rbrakk>\n       \\<Longrightarrow> binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) =\n                         \\<ii>\\<pp> (x + y)", "moreover"], ["proof (state)\nthis:\n  x \\<in> pG\n  y \\<in> pG\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> pG; y \\<in> pG\\<rbrakk>\n       \\<Longrightarrow> binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) =\n                         \\<ii>\\<pp> (x + y)", "hence \"\\<ii>\\<pp> (\\<pp> (binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y))) = \\<ii>\\<pp> (x + y)\""], ["proof (prove)\nusing this:\n  x \\<in> pG\n  y \\<in> pG\n\ngoal (1 subgoal):\n 1. \\<ii>\\<pp> (\\<pp> (binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y))) =\n    \\<ii>\\<pp> (x + y)", "using 1 the_inv_into_into[OF inj_on_\\<pp>_G] f_the_inv_into_f[OF inj_on_\\<pp>_G]"], ["proof (prove)\nusing this:\n  x \\<in> pG\n  y \\<in> pG\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> \\<pp> (binop ?g ?h) = \\<pp> ?g + \\<pp> ?h\n  \\<lbrakk>?x \\<in> pG; order.greater_eq ?B G\\<rbrakk>\n  \\<Longrightarrow> \\<ii>\\<pp> ?x \\<in> ?B\n  ?y \\<in> pG \\<Longrightarrow> \\<pp> (\\<ii>\\<pp> ?y) = ?y\n\ngoal (1 subgoal):\n 1. \\<ii>\\<pp> (\\<pp> (binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y))) =\n    \\<ii>\\<pp> (x + y)", "by    simp"], ["proof (state)\nthis:\n  \\<ii>\\<pp> (\\<pp> (binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y))) =\n  \\<ii>\\<pp> (x + y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> pG; y \\<in> pG\\<rbrakk>\n       \\<Longrightarrow> binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) =\n                         \\<ii>\\<pp> (x + y)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> pG\n  y \\<in> pG\n  \\<ii>\\<pp> (\\<pp> (binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y))) =\n  \\<ii>\\<pp> (x + y)", "show \"binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) = \\<ii>\\<pp> (x+y)\""], ["proof (prove)\nusing this:\n  x \\<in> pG\n  y \\<in> pG\n  \\<ii>\\<pp> (\\<pp> (binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y))) =\n  \\<ii>\\<pp> (x + y)\n\ngoal (1 subgoal):\n 1. binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) = \\<ii>\\<pp> (x + y)", "using the_inv_into_into[OF inj_on_\\<pp>_G] closed the_inv_into_f_f[OF inj_on_\\<pp>_G]"], ["proof (prove)\nusing this:\n  x \\<in> pG\n  y \\<in> pG\n  \\<ii>\\<pp> (\\<pp> (binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y))) =\n  \\<ii>\\<pp> (x + y)\n  \\<lbrakk>?x \\<in> pG; order.greater_eq ?B G\\<rbrakk>\n  \\<Longrightarrow> \\<ii>\\<pp> ?x \\<in> ?B\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> binop ?g ?h \\<in> G\n  ?x \\<in> G \\<Longrightarrow> \\<ii>\\<pp> (\\<pp> ?x) = ?x\n\ngoal (1 subgoal):\n 1. binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) = \\<ii>\\<pp> (x + y)", "by    simp"], ["proof (state)\nthis:\n  binop (\\<ii>\\<pp> x) (\\<ii>\\<pp> y) = \\<ii>\\<pp> (x + y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> pG; ?y \\<in> pG\\<rbrakk>\n  \\<Longrightarrow> binop (\\<ii>\\<pp> ?x) (\\<ii>\\<pp> ?y) =\n                    \\<ii>\\<pp> (?x + ?y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas inv_correspondence_into =\n  the_inv_into_into[OF inj_on_\\<pp>_G, of _ G, simplified]"], ["", "lemma inv_correspondence_conv_apply: \"x \\<in> pG \\<Longrightarrow> \\<ii>\\<pp> x = x\\<rightarrow>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> pG \\<Longrightarrow> \\<ii>\\<pp> x = x \\<rightarrow> e", "using G_perm_apply_identity inj_on_\\<pp>_G"], ["proof (prove)\nusing this:\n  ?g \\<in> G \\<Longrightarrow> \\<pp> ?g \\<rightarrow> e = ?g\n  inj_on \\<pp> G\n\ngoal (1 subgoal):\n 1. x \\<in> pG \\<Longrightarrow> \\<ii>\\<pp> x = x \\<rightarrow> e", "by (auto intro: the_inv_into_f_eq)"], ["", "end"], ["", "(* context BinOpSetGroup *)"], ["", "subsubsection \\<open>Cosets of a @{const Group}\\<close>"], ["", "context Group\nbegin"], ["", "lemma lcoset_refl: \"a \\<in> a +o G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> a +o G", "using lcoset_refl zero_closed"], ["proof (prove)\nusing this:\n  (0::?'a) \\<in> ?A \\<Longrightarrow> ?a \\<in> ?a +o ?A\n  (0::'g) \\<in> G\n\ngoal (1 subgoal):\n 1. a \\<in> a +o G", "by fast"], ["", "lemma lcoset_el_reduce:\n  assumes \"a \\<in> G\"\n  shows \"a +o G = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a +o G = G", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> a +o G \\<Longrightarrow> x \\<in> G\n 2. \\<And>x. x \\<in> G \\<Longrightarrow> x \\<in> a +o G", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> a +o G \\<Longrightarrow> x \\<in> G\n 2. \\<And>x. x \\<in> G \\<Longrightarrow> x \\<in> a +o G", "assume \"x \\<in> a +o G\""], ["proof (state)\nthis:\n  x \\<in> a +o G\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> a +o G \\<Longrightarrow> x \\<in> G\n 2. \\<And>x. x \\<in> G \\<Longrightarrow> x \\<in> a +o G", "from this"], ["proof (chain)\npicking this:\n  x \\<in> a +o G", "obtain g where \"g\\<in>G\" \"x = a+g\""], ["proof (prove)\nusing this:\n  x \\<in> a +o G\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> G; x = a + g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using elt_set_plus_def[of a]"], ["proof (prove)\nusing this:\n  x \\<in> a +o G\n  a +o ?B = {c. \\<exists>b\\<in>?B. c = a + b}\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> G; x = a + g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g \\<in> G\n  x = a + g\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> a +o G \\<Longrightarrow> x \\<in> G\n 2. \\<And>x. x \\<in> G \\<Longrightarrow> x \\<in> a +o G", "with assms"], ["proof (chain)\npicking this:\n  a \\<in> G\n  g \\<in> G\n  x = a + g", "show \"x\\<in>G\""], ["proof (prove)\nusing this:\n  a \\<in> G\n  g \\<in> G\n  x = a + g\n\ngoal (1 subgoal):\n 1. x \\<in> G", "by (simp add: add_closed)"], ["proof (state)\nthis:\n  x \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> x \\<in> a +o G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> x \\<in> a +o G", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> x \\<in> a +o G", "assume \"x\\<in>G\""], ["proof (state)\nthis:\n  x \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> x \\<in> a +o G", "with assms"], ["proof (chain)\npicking this:\n  a \\<in> G\n  x \\<in> G", "have \"-a + x \\<in> G\""], ["proof (prove)\nusing this:\n  a \\<in> G\n  x \\<in> G\n\ngoal (1 subgoal):\n 1. - a + x \\<in> G", "by (simp add: uminus_add_closed)"], ["proof (state)\nthis:\n  - a + x \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G \\<Longrightarrow> x \\<in> a +o G", "thus \"x \\<in> a +o G\""], ["proof (prove)\nusing this:\n  - a + x \\<in> G\n\ngoal (1 subgoal):\n 1. x \\<in> a +o G", "using elt_set_plus_def"], ["proof (prove)\nusing this:\n  - a + x \\<in> G\n  ?a +o ?B = {c. \\<exists>b\\<in>?B. c = ?a + b}\n\ngoal (1 subgoal):\n 1. x \\<in> a +o G", "by force"], ["proof (state)\nthis:\n  x \\<in> a +o G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lcoset_el_reduce0: \"0 \\<in> a +o G \\<Longrightarrow> a +o G = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'g) \\<in> a +o G \\<Longrightarrow> a +o G = G", "using elt_set_plus_def[of a G] minus_unique uminus_closed[of \"-a\"]\n        lcoset_el_reduce"], ["proof (prove)\nusing this:\n  a +o G = {c. \\<exists>b\\<in>G. c = a + b}\n  ?a + ?b = (0::?'a) \\<Longrightarrow> - ?a = ?b\n  - a \\<in> G \\<Longrightarrow> - (- a) \\<in> G\n  ?a \\<in> G \\<Longrightarrow> ?a +o G = G\n\ngoal (1 subgoal):\n 1. (0::'g) \\<in> a +o G \\<Longrightarrow> a +o G = G", "by    fastforce"], ["", "lemma lcoset_subgroup_imp_eq_reps:\n  \"Group H \\<Longrightarrow> w +o H \\<subseteq> w' +o G \\<Longrightarrow> w' +o G = w +o G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H; order.greater_eq (w' +o G) (w +o H)\\<rbrakk>\n    \\<Longrightarrow> w' +o G = w +o G", "using Group.lcoset_refl[of H w] lcoset_conv_set[of w] lcoset_el_reduce\n        set_plus_rearrange2[of w' \"-w'+w\" G]"], ["proof (prove)\nusing this:\n  Group H \\<Longrightarrow> w \\<in> w +o H\n  w \\<in> ?b +o ?A \\<Longrightarrow> - ?b + w \\<in> ?A\n  ?a \\<in> G \\<Longrightarrow> ?a +o G = G\n  w' +o ((- w' + w) +o G) = (w' + (- w' + w)) +o G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H; order.greater_eq (w' +o G) (w +o H)\\<rbrakk>\n    \\<Longrightarrow> w' +o G = w +o G", "by    force"], ["", "lemma lcoset_closed: \"a\\<in>G \\<Longrightarrow> A\\<subseteq>G \\<Longrightarrow> a +o A \\<subseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> G; order.greater_eq G A\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq G (a +o A)", "using elt_set_plus_def[of a] add_closed"], ["proof (prove)\nusing this:\n  a +o ?B = {c. \\<exists>b\\<in>?B. c = a + b}\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g + ?h \\<in> G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> G; order.greater_eq G A\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq G (a +o A)", "by auto"], ["", "lemma lcoset_rel_sym: \"sym (lcoset_rel G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym (lcoset_rel G)", "proof (rule symI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> lcoset_rel G \\<Longrightarrow> (b, a) \\<in> lcoset_rel G", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> lcoset_rel G \\<Longrightarrow> (b, a) \\<in> lcoset_rel G", "show \"(a,b) \\<in> lcoset_rel G \\<Longrightarrow> (b,a) \\<in> lcoset_rel G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> lcoset_rel G \\<Longrightarrow> (b, a) \\<in> lcoset_rel G", "using uminus_closed minus_add[of \"-a\" b] lcoset_rel_def[of G]"], ["proof (prove)\nusing this:\n  ?g \\<in> G \\<Longrightarrow> - ?g \\<in> G\n  - (- a + b) = - b + - (- a)\n  lcoset_rel G \\<equiv> {(x, y). - x + y \\<in> G}\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> lcoset_rel G \\<Longrightarrow> (b, a) \\<in> lcoset_rel G", "by fastforce"], ["proof (state)\nthis:\n  (a, b) \\<in> lcoset_rel G \\<Longrightarrow> (b, a) \\<in> lcoset_rel G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lcoset_rel_trans: \"trans (lcoset_rel G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (lcoset_rel G)", "proof (rule transI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> lcoset_rel G;\n        (y, z) \\<in> lcoset_rel G\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> lcoset_rel G", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> lcoset_rel G;\n        (y, z) \\<in> lcoset_rel G\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> lcoset_rel G", "assume xy: \"(x,y) \\<in> lcoset_rel G\" and yz: \"(y,z) \\<in> lcoset_rel G\""], ["proof (state)\nthis:\n  (x, y) \\<in> lcoset_rel G\n  (y, z) \\<in> lcoset_rel G\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> lcoset_rel G;\n        (y, z) \\<in> lcoset_rel G\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> lcoset_rel G", "from this"], ["proof (chain)\npicking this:\n  (x, y) \\<in> lcoset_rel G\n  (y, z) \\<in> lcoset_rel G", "obtain g g' where \"g\\<in>G\" \"-x+y = g\" \"g'\\<in>G\" \"-y+z = g'\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> lcoset_rel G\n  (y, z) \\<in> lcoset_rel G\n\ngoal (1 subgoal):\n 1. (\\<And>g g'.\n        \\<lbrakk>g \\<in> G; - x + y = g; g' \\<in> G; - y + z = g'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lcoset_rel_def[of G]"], ["proof (prove)\nusing this:\n  (x, y) \\<in> lcoset_rel G\n  (y, z) \\<in> lcoset_rel G\n  lcoset_rel G \\<equiv> {(x, y). - x + y \\<in> G}\n\ngoal (1 subgoal):\n 1. (\\<And>g g'.\n        \\<lbrakk>g \\<in> G; - x + y = g; g' \\<in> G; - y + z = g'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  g \\<in> G\n  - x + y = g\n  g' \\<in> G\n  - y + z = g'\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> lcoset_rel G;\n        (y, z) \\<in> lcoset_rel G\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> lcoset_rel G", "thus \"(x, z) \\<in> lcoset_rel G\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  - x + y = g\n  g' \\<in> G\n  - y + z = g'\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> lcoset_rel G", "using add.assoc[of g \"-y\" z] add_closed lcoset_rel_def[of G]"], ["proof (prove)\nusing this:\n  g \\<in> G\n  - x + y = g\n  g' \\<in> G\n  - y + z = g'\n  g + - y + z = g + (- y + z)\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g + ?h \\<in> G\n  lcoset_rel G \\<equiv> {(x, y). - x + y \\<in> G}\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> lcoset_rel G", "by auto"], ["proof (state)\nthis:\n  (x, z) \\<in> lcoset_rel G\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation LCoset_rel :: \"'g set \\<Rightarrow> ('g\\<times>'g) set\"\n  where \"LCoset_rel H \\<equiv> lcoset_rel H \\<inter> (G\\<times>G)\""], ["", "lemma refl_on_LCoset_rel: \"0\\<in>H \\<Longrightarrow> refl_on G (LCoset_rel H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'g) \\<in> H \\<Longrightarrow> refl_on G (LCoset_rel H)", "using lcoset_rel_def"], ["proof (prove)\nusing this:\n  lcoset_rel ?A \\<equiv> {(x, y). - x + y \\<in> ?A}\n\ngoal (1 subgoal):\n 1. (0::'g) \\<in> H \\<Longrightarrow> refl_on G (LCoset_rel H)", "by (fastforce intro: refl_onI)"], ["", "lemmas subgroup_refl_on_LCoset_rel =\n  refl_on_LCoset_rel[OF Group.zero_closed, OF SubgroupD1]"], ["", "lemmas LCoset_rel_quotientI        = quotientI[of _ G \"LCoset_rel _\"]"], ["", "lemmas LCoset_rel_quotientE        = quotientE[of _ G \"LCoset_rel _\"]"], ["", "lemma lcoset_subgroup_rel_equiv:\n  \"Subgroup H \\<Longrightarrow> equiv G (LCoset_rel H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group H \\<and> order.greater_eq G H \\<Longrightarrow>\n    equiv G (LCoset_rel H)", "using Group.lcoset_rel_sym sym_sym sym_Int Group.lcoset_rel_trans trans_sym\n        trans_Int subgroup_refl_on_LCoset_rel"], ["proof (prove)\nusing this:\n  Group ?G \\<Longrightarrow> sym (lcoset_rel ?G)\n  sym (?A \\<times> ?A)\n  \\<lbrakk>sym ?r; sym ?s\\<rbrakk> \\<Longrightarrow> sym (?r \\<inter> ?s)\n  Group ?G \\<Longrightarrow> trans (lcoset_rel ?G)\n  trans (?A \\<times> ?A)\n  \\<lbrakk>trans ?r; trans ?s\\<rbrakk>\n  \\<Longrightarrow> trans (?r \\<inter> ?s)\n  Group ?H \\<and> order.greater_eq G ?H \\<Longrightarrow>\n  refl_on G (LCoset_rel ?H)\n\ngoal (1 subgoal):\n 1. Group H \\<and> order.greater_eq G H \\<Longrightarrow>\n    equiv G (LCoset_rel H)", "by    (blast intro: equivI)"], ["", "lemma trivial_LCoset: \"H\\<subseteq>G \\<Longrightarrow> H = LCoset_rel H `` {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq G H \\<Longrightarrow> H = LCoset_rel H `` {0::'g}", "using zero_closed"], ["proof (prove)\nusing this:\n  (0::'g) \\<in> G\n\ngoal (1 subgoal):\n 1. order.greater_eq G H \\<Longrightarrow> H = LCoset_rel H `` {0::'g}", "unfolding lcoset_rel_def"], ["proof (prove)\nusing this:\n  (0::'g) \\<in> G\n\ngoal (1 subgoal):\n 1. order.greater_eq G H \\<Longrightarrow>\n    H = Restr {(x, y). - x + y \\<in> H} G `` {0::'g}", "by auto"], ["", "end"], ["", "(* context Group *)"], ["", "subsubsection \\<open>The @{const Group} generated by a set\\<close>"], ["", "inductive_set genby :: \"'a::group_add set \\<Rightarrow> 'a set\" (\"\\<langle>_\\<rangle>\")\n  for S :: \"'a set\"\n  where\n      genby_0_closed     : \"0\\<in>\\<langle>S\\<rangle>\"  \\<comment> \\<open>just in case @{term S} is empty\\<close>\n    | genby_genset_closed: \"s\\<in>S \\<Longrightarrow> s\\<in>\\<langle>S\\<rangle>\"\n    | genby_diff_closed  : \"w\\<in>\\<langle>S\\<rangle> \\<Longrightarrow> w'\\<in>\\<langle>S\\<rangle> \\<Longrightarrow> w - w' \\<in> \\<langle>S\\<rangle>\""], ["", "lemma genby_Group: \"Group \\<langle>S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group \\<langle>S\\<rangle>", "using genby_0_closed genby_diff_closed"], ["proof (prove)\nusing this:\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n  \\<lbrakk>?w \\<in> \\<langle>?S\\<rangle>;\n   ?w' \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?w - ?w' \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. Group \\<langle>S\\<rangle>", "by unfold_locales fast"], ["", "lemmas genby_uminus_closed             = Group.uminus_closed     [OF genby_Group]"], ["", "lemmas genby_add_closed                = Group.add_closed        [OF genby_Group]"], ["", "lemmas genby_uminus_add_closed         = Group.uminus_add_closed [OF genby_Group]"], ["", "lemmas genby_lcoset_refl               = Group.lcoset_refl       [OF genby_Group]"], ["", "lemmas genby_lcoset_el_reduce          = Group.lcoset_el_reduce  [OF genby_Group]"], ["", "lemmas genby_lcoset_el_reduce0         = Group.lcoset_el_reduce0 [OF genby_Group]"], ["", "lemmas genby_lcoset_closed             = Group.lcoset_closed     [OF genby_Group]"], ["", "lemmas genby_lcoset_subgroup_imp_eq_reps =\n  Group.lcoset_subgroup_imp_eq_reps[OF genby_Group, OF genby_Group]"], ["", "lemma genby_genset_subset: \"S \\<subseteq> \\<langle>S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq \\<langle>S\\<rangle> S", "using genby_genset_closed"], ["proof (prove)\nusing this:\n  ?s \\<in> ?S \\<Longrightarrow> ?s \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq \\<langle>S\\<rangle> S", "by fast"], ["", "lemma genby_uminus_genset_subset: \"uminus ` S \\<subseteq> \\<langle>S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq \\<langle>S\\<rangle> (uminus ` S)", "using genby_genset_subset genby_uminus_closed"], ["proof (prove)\nusing this:\n  order.greater_eq \\<langle>?S\\<rangle> ?S\n  ?g \\<in> \\<langle>?S\\<rangle> \\<Longrightarrow>\n  - ?g \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq \\<langle>S\\<rangle> (uminus ` S)", "by auto"], ["", "lemma genby_in_sum_list_lists:\n  fixes   S\n  defines S_sum_lists: \"S_sum_lists \\<equiv> (\\<Union>ss\\<in>lists (S \\<union> uminus ` S). {sum_list ss})\"\n  shows   \"w \\<in> \\<langle>S\\<rangle> \\<Longrightarrow> w \\<in> S_sum_lists\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>S\\<rangle> \\<Longrightarrow> w \\<in> S_sum_lists", "proof (erule genby.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. (0::'a) \\<in> S_sum_lists\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> s \\<in> S_sum_lists\n 3. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "have \"0 = sum_list []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) = sum_list []", "by simp"], ["proof (state)\nthis:\n  (0::?'b1) = sum_list []\n\ngoal (3 subgoals):\n 1. (0::'a) \\<in> S_sum_lists\n 2. \\<And>s. s \\<in> S \\<Longrightarrow> s \\<in> S_sum_lists\n 3. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "with S_sum_lists"], ["proof (chain)\npicking this:\n  S_sum_lists \\<equiv>\n  \\<Union>ss\\<in>lists (S \\<union> uminus ` S). {sum_list ss}\n  (0::?'b1) = sum_list []", "show \"0 \\<in> S_sum_lists\""], ["proof (prove)\nusing this:\n  S_sum_lists \\<equiv>\n  \\<Union>ss\\<in>lists (S \\<union> uminus ` S). {sum_list ss}\n  (0::?'b1) = sum_list []\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> S_sum_lists", "by blast"], ["proof (state)\nthis:\n  (0::'a) \\<in> S_sum_lists\n\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> s \\<in> S_sum_lists\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> s \\<in> S_sum_lists\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> s \\<in> S_sum_lists\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "assume \"s\\<in>S\""], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> s \\<in> S_sum_lists\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "hence \"[s] \\<in> lists (S \\<union> uminus ` S)\""], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. [s] \\<in> lists (S \\<union> uminus ` S)", "by simp"], ["proof (state)\nthis:\n  [s] \\<in> lists (S \\<union> uminus ` S)\n\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> s \\<in> S_sum_lists\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "moreover"], ["proof (state)\nthis:\n  [s] \\<in> lists (S \\<union> uminus ` S)\n\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> s \\<in> S_sum_lists\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "have \"s = sum_list [s]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = sum_list [s]", "by simp"], ["proof (state)\nthis:\n  s = sum_list [s]\n\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> s \\<in> S_sum_lists\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "ultimately"], ["proof (chain)\npicking this:\n  [s] \\<in> lists (S \\<union> uminus ` S)\n  s = sum_list [s]", "show \"s \\<in> S_sum_lists\""], ["proof (prove)\nusing this:\n  [s] \\<in> lists (S \\<union> uminus ` S)\n  s = sum_list [s]\n\ngoal (1 subgoal):\n 1. s \\<in> S_sum_lists", "using S_sum_lists"], ["proof (prove)\nusing this:\n  [s] \\<in> lists (S \\<union> uminus ` S)\n  s = sum_list [s]\n  S_sum_lists \\<equiv>\n  \\<Union>ss\\<in>lists (S \\<union> uminus ` S). {sum_list ss}\n\ngoal (1 subgoal):\n 1. s \\<in> S_sum_lists", "by blast"], ["proof (state)\nthis:\n  s \\<in> S_sum_lists\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "fix w w'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "assume ww': \"w \\<in> S_sum_lists\" \"w' \\<in> S_sum_lists\""], ["proof (state)\nthis:\n  w \\<in> S_sum_lists\n  w' \\<in> S_sum_lists\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "with S_sum_lists"], ["proof (chain)\npicking this:\n  S_sum_lists \\<equiv>\n  \\<Union>ss\\<in>lists (S \\<union> uminus ` S). {sum_list ss}\n  w \\<in> S_sum_lists\n  w' \\<in> S_sum_lists", "obtain ss ts\n    where ss: \"ss \\<in> lists (S \\<union> uminus ` S)\" \"w = sum_list ss\"\n    and   ts: \"ts \\<in> lists (S \\<union> uminus ` S)\" \"w' = sum_list ts\""], ["proof (prove)\nusing this:\n  S_sum_lists \\<equiv>\n  \\<Union>ss\\<in>lists (S \\<union> uminus ` S). {sum_list ss}\n  w \\<in> S_sum_lists\n  w' \\<in> S_sum_lists\n\ngoal (1 subgoal):\n 1. (\\<And>ss ts.\n        \\<lbrakk>ss \\<in> lists (S \\<union> uminus ` S); w = sum_list ss;\n         ts \\<in> lists (S \\<union> uminus ` S); w' = sum_list ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ss \\<in> lists (S \\<union> uminus ` S)\n  w = sum_list ss\n  ts \\<in> lists (S \\<union> uminus ` S)\n  w' = sum_list ts\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "from ss(2) ts(2)"], ["proof (chain)\npicking this:\n  w = sum_list ss\n  w' = sum_list ts", "have \"w-w' = sum_list (ss @ map uminus (rev ts))\""], ["proof (prove)\nusing this:\n  w = sum_list ss\n  w' = sum_list ts\n\ngoal (1 subgoal):\n 1. w - w' = sum_list (ss @ map uminus (rev ts))", "by (simp add: diff_conv_add_uminus uminus_sum_list)"], ["proof (state)\nthis:\n  w - w' = sum_list (ss @ map uminus (rev ts))\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "moreover"], ["proof (state)\nthis:\n  w - w' = sum_list (ss @ map uminus (rev ts))\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "from ss(1) ts(1)"], ["proof (chain)\npicking this:\n  ss \\<in> lists (S \\<union> uminus ` S)\n  ts \\<in> lists (S \\<union> uminus ` S)", "have  \"ss @ map uminus (rev ts) \\<in> lists (S \\<union> uminus ` S)\""], ["proof (prove)\nusing this:\n  ss \\<in> lists (S \\<union> uminus ` S)\n  ts \\<in> lists (S \\<union> uminus ` S)\n\ngoal (1 subgoal):\n 1. ss @ map uminus (rev ts) \\<in> lists (S \\<union> uminus ` S)", "by    fastforce"], ["proof (state)\nthis:\n  ss @ map uminus (rev ts) \\<in> lists (S \\<union> uminus ` S)\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> S_sum_lists;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> S_sum_lists\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> S_sum_lists", "ultimately"], ["proof (chain)\npicking this:\n  w - w' = sum_list (ss @ map uminus (rev ts))\n  ss @ map uminus (rev ts) \\<in> lists (S \\<union> uminus ` S)", "show \"w - w' \\<in> S_sum_lists\""], ["proof (prove)\nusing this:\n  w - w' = sum_list (ss @ map uminus (rev ts))\n  ss @ map uminus (rev ts) \\<in> lists (S \\<union> uminus ` S)\n\ngoal (1 subgoal):\n 1. w - w' \\<in> S_sum_lists", "using S_sum_lists"], ["proof (prove)\nusing this:\n  w - w' = sum_list (ss @ map uminus (rev ts))\n  ss @ map uminus (rev ts) \\<in> lists (S \\<union> uminus ` S)\n  S_sum_lists \\<equiv>\n  \\<Union>ss\\<in>lists (S \\<union> uminus ` S). {sum_list ss}\n\ngoal (1 subgoal):\n 1. w - w' \\<in> S_sum_lists", "by fast"], ["proof (state)\nthis:\n  w - w' \\<in> S_sum_lists\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_lists_in_genby: \"ss \\<in> lists (S \\<union> uminus ` S) \\<Longrightarrow> sum_list ss \\<in> \\<langle>S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists (S \\<union> uminus ` S) \\<Longrightarrow>\n    sum_list ss \\<in> \\<langle>S\\<rangle>", "proof (induct ss)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> lists (S \\<union> uminus ` S) \\<Longrightarrow>\n    sum_list [] \\<in> \\<langle>S\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>ss \\<in> lists (S \\<union> uminus ` S) \\<Longrightarrow>\n                sum_list ss \\<in> \\<langle>S\\<rangle>;\n        a # ss \\<in> lists (S \\<union> uminus ` S)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss) \\<in> \\<langle>S\\<rangle>", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> lists (S \\<union> uminus ` S)\n\ngoal (2 subgoals):\n 1. [] \\<in> lists (S \\<union> uminus ` S) \\<Longrightarrow>\n    sum_list [] \\<in> \\<langle>S\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>ss \\<in> lists (S \\<union> uminus ` S) \\<Longrightarrow>\n                sum_list ss \\<in> \\<langle>S\\<rangle>;\n        a # ss \\<in> lists (S \\<union> uminus ` S)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss) \\<in> \\<langle>S\\<rangle>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list [] \\<in> \\<langle>S\\<rangle>", "using genby_0_closed"], ["proof (prove)\nusing this:\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. sum_list [] \\<in> \\<langle>S\\<rangle>", "by simp"], ["proof (state)\nthis:\n  sum_list [] \\<in> \\<langle>S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>ss \\<in> lists (S \\<union> uminus ` S) \\<Longrightarrow>\n                sum_list ss \\<in> \\<langle>S\\<rangle>;\n        a # ss \\<in> lists (S \\<union> uminus ` S)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss) \\<in> \\<langle>S\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>ss \\<in> lists (S \\<union> uminus ` S) \\<Longrightarrow>\n                sum_list ss \\<in> \\<langle>S\\<rangle>;\n        a # ss \\<in> lists (S \\<union> uminus ` S)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss) \\<in> \\<langle>S\\<rangle>", "case (Cons s ss)"], ["proof (state)\nthis:\n  ss \\<in> lists (S \\<union> uminus ` S) \\<Longrightarrow>\n  sum_list ss \\<in> \\<langle>S\\<rangle>\n  s # ss \\<in> lists (S \\<union> uminus ` S)\n\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>ss \\<in> lists (S \\<union> uminus ` S) \\<Longrightarrow>\n                sum_list ss \\<in> \\<langle>S\\<rangle>;\n        a # ss \\<in> lists (S \\<union> uminus ` S)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss) \\<in> \\<langle>S\\<rangle>", "thus ?case"], ["proof (prove)\nusing this:\n  ss \\<in> lists (S \\<union> uminus ` S) \\<Longrightarrow>\n  sum_list ss \\<in> \\<langle>S\\<rangle>\n  s # ss \\<in> lists (S \\<union> uminus ` S)\n\ngoal (1 subgoal):\n 1. sum_list (s # ss) \\<in> \\<langle>S\\<rangle>", "using genby_genset_subset[of S] genby_uminus_genset_subset\n          genby_add_closed[of s S \"sum_list ss\"]"], ["proof (prove)\nusing this:\n  ss \\<in> lists (S \\<union> uminus ` S) \\<Longrightarrow>\n  sum_list ss \\<in> \\<langle>S\\<rangle>\n  s # ss \\<in> lists (S \\<union> uminus ` S)\n  order.greater_eq \\<langle>S\\<rangle> S\n  order.greater_eq \\<langle>?S\\<rangle> (uminus ` ?S)\n  \\<lbrakk>s \\<in> \\<langle>S\\<rangle>;\n   sum_list ss \\<in> \\<langle>S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> s + sum_list ss \\<in> \\<langle>S\\<rangle>\n\ngoal (1 subgoal):\n 1. sum_list (s # ss) \\<in> \\<langle>S\\<rangle>", "by    auto"], ["proof (state)\nthis:\n  sum_list (s # ss) \\<in> \\<langle>S\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_lists_in_genby_sym:\n  \"uminus ` S \\<subseteq> S \\<Longrightarrow> ss \\<in> lists S \\<Longrightarrow> sum_list ss \\<in> \\<langle>S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq S (uminus ` S); ss \\<in> lists S\\<rbrakk>\n    \\<Longrightarrow> sum_list ss \\<in> \\<langle>S\\<rangle>", "using sum_list_lists_in_genby"], ["proof (prove)\nusing this:\n  ?ss \\<in> lists (?S \\<union> uminus ` ?S) \\<Longrightarrow>\n  sum_list ?ss \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq S (uminus ` S); ss \\<in> lists S\\<rbrakk>\n    \\<Longrightarrow> sum_list ss \\<in> \\<langle>S\\<rangle>", "by fast"], ["", "lemma genby_eq_sum_lists: \"\\<langle>S\\<rangle> = (\\<Union>ss\\<in>lists (S \\<union> uminus ` S). {sum_list ss})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>S\\<rangle> =\n    (\\<Union>ss\\<in>lists (S \\<union> uminus ` S). {sum_list ss})", "using genby_in_sum_list_lists sum_list_lists_in_genby"], ["proof (prove)\nusing this:\n  ?w \\<in> \\<langle>?S\\<rangle> \\<Longrightarrow>\n  ?w \\<in> (\\<Union>ss\\<in>lists (?S \\<union> uminus ` ?S). {sum_list ss})\n  ?ss \\<in> lists (?S \\<union> uminus ` ?S) \\<Longrightarrow>\n  sum_list ?ss \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>S\\<rangle> =\n    (\\<Union>ss\\<in>lists (S \\<union> uminus ` S). {sum_list ss})", "by fast"], ["", "lemma genby_mono: \"T \\<subseteq> S \\<Longrightarrow> \\<langle>T\\<rangle> \\<subseteq> \\<langle>S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq S T \\<Longrightarrow>\n    order.greater_eq \\<langle>S\\<rangle> \\<langle>T\\<rangle>", "using genby_eq_sum_lists[of T] genby_eq_sum_lists[of S]"], ["proof (prove)\nusing this:\n  \\<langle>T\\<rangle> =\n  (\\<Union>ss\\<in>lists (T \\<union> uminus ` T). {sum_list ss})\n  \\<langle>S\\<rangle> =\n  (\\<Union>ss\\<in>lists (S \\<union> uminus ` S). {sum_list ss})\n\ngoal (1 subgoal):\n 1. order.greater_eq S T \\<Longrightarrow>\n    order.greater_eq \\<langle>S\\<rangle> \\<langle>T\\<rangle>", "by force"], ["", "lemma (in Group) genby_closed:\n  assumes \"S \\<subseteq> G\"\n  shows \"\\<langle>S\\<rangle> \\<subseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq G \\<langle>S\\<rangle>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<langle>S\\<rangle> \\<Longrightarrow> x \\<in> G", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<langle>S\\<rangle> \\<Longrightarrow> x \\<in> G", "show \"x \\<in> \\<langle>S\\<rangle> \\<Longrightarrow> x \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>S\\<rangle> \\<Longrightarrow> x \\<in> G", "proof (erule genby.induct, rule zero_closed)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> s \\<in> G\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> G;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> G\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> G", "from assms"], ["proof (chain)\npicking this:\n  order.greater_eq G S", "show \"\\<And>s. s\\<in>S \\<Longrightarrow> s\\<in>G\""], ["proof (prove)\nusing this:\n  order.greater_eq G S\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> s \\<in> G", "by fast"], ["proof (state)\nthis:\n  ?s \\<in> S \\<Longrightarrow> ?s \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>; w \\<in> G;\n        w' \\<in> \\<langle>S\\<rangle>; w' \\<in> G\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> G", "show \"\\<And>w w'. w\\<in>G \\<Longrightarrow> w'\\<in>G \\<Longrightarrow> w-w' \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> G; w' \\<in> G\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> G", "using diff_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g - ?h \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> G; w' \\<in> G\\<rbrakk>\n       \\<Longrightarrow> w - w' \\<in> G", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>?w \\<in> G; ?w' \\<in> G\\<rbrakk>\n  \\<Longrightarrow> ?w - ?w' \\<in> G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> \\<langle>S\\<rangle> \\<Longrightarrow> x \\<in> G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in Group) genby_subgroup: \"S \\<subseteq> G \\<Longrightarrow> Subgroup \\<langle>S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq G S \\<Longrightarrow>\n    Group \\<langle>S\\<rangle> \\<and> order.greater_eq G \\<langle>S\\<rangle>", "using genby_closed genby_Group"], ["proof (prove)\nusing this:\n  order.greater_eq G ?S \\<Longrightarrow>\n  order.greater_eq G \\<langle>?S\\<rangle>\n  Group \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq G S \\<Longrightarrow>\n    Group \\<langle>S\\<rangle> \\<and> order.greater_eq G \\<langle>S\\<rangle>", "by simp"], ["", "lemma genby_sym_eq_sum_lists:\n  \"uminus ` S \\<subseteq> S \\<Longrightarrow> \\<langle>S\\<rangle> = (\\<Union>ss\\<in>lists S. {sum_list ss})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq S (uminus ` S) \\<Longrightarrow>\n    \\<langle>S\\<rangle> = (\\<Union>ss\\<in>lists S. {sum_list ss})", "using lists_mono genby_eq_sum_lists[of S]"], ["proof (prove)\nusing this:\n  order.greater_eq ?B ?A \\<Longrightarrow>\n  order.greater_eq (lists ?B) (lists ?A)\n  \\<langle>S\\<rangle> =\n  (\\<Union>ss\\<in>lists (S \\<union> uminus ` S). {sum_list ss})\n\ngoal (1 subgoal):\n 1. order.greater_eq S (uminus ` S) \\<Longrightarrow>\n    \\<langle>S\\<rangle> = (\\<Union>ss\\<in>lists S. {sum_list ss})", "by force"], ["", "lemma genby_empty': \"w \\<in> \\<langle>{}\\<rangle> \\<Longrightarrow> w = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>{}\\<rangle> \\<Longrightarrow> w = (0::'a)", "proof (erule genby.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. (0::'a) = (0::'a)\n 2. \\<And>s. s \\<in> {} \\<Longrightarrow> s = (0::'a)\n 3. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>{}\\<rangle>; w = (0::'a);\n        w' \\<in> \\<langle>{}\\<rangle>; w' = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> w - w' = (0::'a)", "qed auto"], ["", "lemma genby_order2':\n  assumes \"s+s=0\"\n  shows   \"w \\<in> \\<langle>{s}\\<rangle> \\<Longrightarrow> w = 0 \\<or> w = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>{s}\\<rangle> \\<Longrightarrow> w = (0::'a) \\<or> w = s", "proof (erule genby.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. (0::'a) = (0::'a) \\<or> (0::'a) = s\n 2. \\<And>sa. sa \\<in> {s} \\<Longrightarrow> sa = (0::'a) \\<or> sa = s\n 3. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>{s}\\<rangle>; w = (0::'a) \\<or> w = s;\n        w' \\<in> \\<langle>{s}\\<rangle>; w' = (0::'a) \\<or> w' = s\\<rbrakk>\n       \\<Longrightarrow> w - w' = (0::'a) \\<or> w - w' = s", "fix w w'"], ["proof (state)\ngoal (3 subgoals):\n 1. (0::'a) = (0::'a) \\<or> (0::'a) = s\n 2. \\<And>sa. sa \\<in> {s} \\<Longrightarrow> sa = (0::'a) \\<or> sa = s\n 3. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>{s}\\<rangle>; w = (0::'a) \\<or> w = s;\n        w' \\<in> \\<langle>{s}\\<rangle>; w' = (0::'a) \\<or> w' = s\\<rbrakk>\n       \\<Longrightarrow> w - w' = (0::'a) \\<or> w - w' = s", "assume \"w = 0 \\<or> w = s\" \"w' = 0 \\<or> w' = s\""], ["proof (state)\nthis:\n  w = (0::'a) \\<or> w = s\n  w' = (0::'a) \\<or> w' = s\n\ngoal (3 subgoals):\n 1. (0::'a) = (0::'a) \\<or> (0::'a) = s\n 2. \\<And>sa. sa \\<in> {s} \\<Longrightarrow> sa = (0::'a) \\<or> sa = s\n 3. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>{s}\\<rangle>; w = (0::'a) \\<or> w = s;\n        w' \\<in> \\<langle>{s}\\<rangle>; w' = (0::'a) \\<or> w' = s\\<rbrakk>\n       \\<Longrightarrow> w - w' = (0::'a) \\<or> w - w' = s", "with assms"], ["proof (chain)\npicking this:\n  s + s = (0::'a)\n  w = (0::'a) \\<or> w = s\n  w' = (0::'a) \\<or> w' = s", "show \"w - w' = 0 \\<or> w - w' = s\""], ["proof (prove)\nusing this:\n  s + s = (0::'a)\n  w = (0::'a) \\<or> w = s\n  w' = (0::'a) \\<or> w' = s\n\ngoal (1 subgoal):\n 1. w - w' = (0::'a) \\<or> w - w' = s", "by (cases \"w'=0\") (auto simp add: minus_unique)"], ["proof (state)\nthis:\n  w - w' = (0::'a) \\<or> w - w' = s\n\ngoal (2 subgoals):\n 1. (0::'a) = (0::'a) \\<or> (0::'a) = s\n 2. \\<And>sa. sa \\<in> {s} \\<Longrightarrow> sa = (0::'a) \\<or> sa = s", "qed auto"], ["", "lemma genby_order2: \"s+s=0 \\<Longrightarrow> \\<langle>{s}\\<rangle> = {0,s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + s = (0::'a) \\<Longrightarrow> \\<langle>{s}\\<rangle> = {0::'a, s}", "using genby_order2'[of s] genby_0_closed genby_genset_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>s + s = (0::'a); ?w \\<in> \\<langle>{s}\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?w = (0::'a) \\<or> ?w = s\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n  ?s \\<in> ?S \\<Longrightarrow> ?s \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. s + s = (0::'a) \\<Longrightarrow> \\<langle>{s}\\<rangle> = {0::'a, s}", "by auto"], ["", "lemma genby_empty: \"\\<langle>{}\\<rangle> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>{}\\<rangle> = 0", "using genby_empty' genby_0_closed"], ["proof (prove)\nusing this:\n  ?w \\<in> \\<langle>{}\\<rangle> \\<Longrightarrow> ?w = (0::?'a)\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>{}\\<rangle> = 0", "by auto"], ["", "lemma genby_lcoset_order2: \"s+s=0 \\<Longrightarrow> w +o \\<langle>{s}\\<rangle> = {w,w+s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s + s = (0::'a) \\<Longrightarrow>\n    w +o \\<langle>{s}\\<rangle> = {w, w + s}", "using elt_set_plus_def[of w]"], ["proof (prove)\nusing this:\n  w +o ?B = {c. \\<exists>b\\<in>?B. c = w + b}\n\ngoal (1 subgoal):\n 1. s + s = (0::'a) \\<Longrightarrow>\n    w +o \\<langle>{s}\\<rangle> = {w, w + s}", "by (auto simp add: genby_order2)"], ["", "lemma genby_lcoset_empty: \"(w::'a::group_add) +o \\<langle>{}\\<rangle> = {w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w +o \\<langle>{}\\<rangle> = {w}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. w +o \\<langle>{}\\<rangle> = {w}", "have \"\\<langle>{}::'a set\\<rangle> = (0::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>{}\\<rangle> = 0", "using genby_empty"], ["proof (prove)\nusing this:\n  \\<langle>{}\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. \\<langle>{}\\<rangle> = 0", "by fast"], ["proof (state)\nthis:\n  \\<langle>{}\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. w +o \\<langle>{}\\<rangle> = {w}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>{}\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. w +o \\<langle>{}\\<rangle> = {w}", "using lcoset_0"], ["proof (prove)\nusing this:\n  \\<langle>{}\\<rangle> = 0\n  ?w +o 0 = {?w}\n\ngoal (1 subgoal):\n 1. w +o \\<langle>{}\\<rangle> = {w}", "by simp"], ["proof (state)\nthis:\n  w +o \\<langle>{}\\<rangle> = {w}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in Group) genby_set_lconjby_set_lconjby_closed:\n  fixes   A :: \"'g set\"\n  defines \"S \\<equiv> (\\<Union>g\\<in>G. lconjby g ` A)\"\n  assumes \"g\\<in>G\"\n  shows   \"x \\<in> \\<langle>S\\<rangle> \\<Longrightarrow> lconjby g x \\<in> \\<langle>S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>S\\<rangle> \\<Longrightarrow>\n    lconjby g x \\<in> \\<langle>S\\<rangle>", "proof (erule genby.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lconjby g (0::'g) \\<in> \\<langle>S\\<rangle>\n 2. \\<And>s.\n       s \\<in> S \\<Longrightarrow> lconjby g s \\<in> \\<langle>S\\<rangle>\n 3. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>;\n        lconjby g w \\<in> \\<langle>S\\<rangle>; w' \\<in> \\<langle>S\\<rangle>;\n        lconjby g w' \\<in> \\<langle>S\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lconjby g (w - w') \\<in> \\<langle>S\\<rangle>", "show \"lconjby g 0 \\<in> \\<langle>S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconjby g (0::'g) \\<in> \\<langle>S\\<rangle>", "using genby_0_closed"], ["proof (prove)\nusing this:\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. lconjby g (0::'g) \\<in> \\<langle>S\\<rangle>", "by simp"], ["proof (state)\nthis:\n  lconjby g (0::'g) \\<in> \\<langle>S\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow> lconjby g s \\<in> \\<langle>S\\<rangle>\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>;\n        lconjby g w \\<in> \\<langle>S\\<rangle>; w' \\<in> \\<langle>S\\<rangle>;\n        lconjby g w' \\<in> \\<langle>S\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lconjby g (w - w') \\<in> \\<langle>S\\<rangle>", "from assms"], ["proof (chain)\npicking this:\n  S \\<equiv> \\<Union>g\\<in>G. lconjby g ` A\n  g \\<in> G", "show \"\\<And>s. s \\<in> S \\<Longrightarrow> lconjby g s \\<in> \\<langle>S\\<rangle>\""], ["proof (prove)\nusing this:\n  S \\<equiv> \\<Union>g\\<in>G. lconjby g ` A\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow> lconjby g s \\<in> \\<langle>S\\<rangle>", "using add_closed genby_genset_closed[of _ S]"], ["proof (prove)\nusing this:\n  S \\<equiv> \\<Union>g\\<in>G. lconjby g ` A\n  g \\<in> G\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g + ?h \\<in> G\n  ?s \\<in> S \\<Longrightarrow> ?s \\<in> \\<langle>S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow> lconjby g s \\<in> \\<langle>S\\<rangle>", "by (force simp add: lconjby_add)"], ["proof (state)\nthis:\n  ?s \\<in> S \\<Longrightarrow> lconjby g ?s \\<in> \\<langle>S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>;\n        lconjby g w \\<in> \\<langle>S\\<rangle>; w' \\<in> \\<langle>S\\<rangle>;\n        lconjby g w' \\<in> \\<langle>S\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lconjby g (w - w') \\<in> \\<langle>S\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>;\n        lconjby g w \\<in> \\<langle>S\\<rangle>; w' \\<in> \\<langle>S\\<rangle>;\n        lconjby g w' \\<in> \\<langle>S\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lconjby g (w - w') \\<in> \\<langle>S\\<rangle>", "fix w w'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>;\n        lconjby g w \\<in> \\<langle>S\\<rangle>; w' \\<in> \\<langle>S\\<rangle>;\n        lconjby g w' \\<in> \\<langle>S\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lconjby g (w - w') \\<in> \\<langle>S\\<rangle>", "assume ww': \"lconjby g w \\<in> \\<langle>S\\<rangle>\" \"lconjby g w' \\<in> \\<langle>S\\<rangle>\""], ["proof (state)\nthis:\n  lconjby g w \\<in> \\<langle>S\\<rangle>\n  lconjby g w' \\<in> \\<langle>S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>;\n        lconjby g w \\<in> \\<langle>S\\<rangle>; w' \\<in> \\<langle>S\\<rangle>;\n        lconjby g w' \\<in> \\<langle>S\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lconjby g (w - w') \\<in> \\<langle>S\\<rangle>", "have \"lconjby g (w - w') = lconjby g w + lconjby g (-w')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconjby g (w - w') = lconjby g w + lconjby g (- w')", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  lconjby g (w - w') = lconjby g w + lconjby g (- w')\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>S\\<rangle>;\n        lconjby g w \\<in> \\<langle>S\\<rangle>; w' \\<in> \\<langle>S\\<rangle>;\n        lconjby g w' \\<in> \\<langle>S\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> lconjby g (w - w') \\<in> \\<langle>S\\<rangle>", "with ww'"], ["proof (chain)\npicking this:\n  lconjby g w \\<in> \\<langle>S\\<rangle>\n  lconjby g w' \\<in> \\<langle>S\\<rangle>\n  lconjby g (w - w') = lconjby g w + lconjby g (- w')", "show \"lconjby g (w - w') \\<in> \\<langle>S\\<rangle>\""], ["proof (prove)\nusing this:\n  lconjby g w \\<in> \\<langle>S\\<rangle>\n  lconjby g w' \\<in> \\<langle>S\\<rangle>\n  lconjby g (w - w') = lconjby g w + lconjby g (- w')\n\ngoal (1 subgoal):\n 1. lconjby g (w - w') \\<in> \\<langle>S\\<rangle>", "using lconjby_uminus[of g] diff_conv_add_uminus[of _ \"lconjby g w'\"]\n          genby_diff_closed"], ["proof (prove)\nusing this:\n  lconjby g w \\<in> \\<langle>S\\<rangle>\n  lconjby g w' \\<in> \\<langle>S\\<rangle>\n  lconjby g (w - w') = lconjby g w + lconjby g (- w')\n  lconjby g (- ?y) = - lconjby g ?y\n  ?a - lconjby g w' = ?a + - lconjby g w'\n  \\<lbrakk>?w \\<in> \\<langle>?S\\<rangle>;\n   ?w' \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?w - ?w' \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. lconjby g (w - w') \\<in> \\<langle>S\\<rangle>", "by    fastforce"], ["proof (state)\nthis:\n  lconjby g (w - w') \\<in> \\<langle>S\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in Group) genby_set_lconjby_set_rconjby_closed:\n  fixes   A :: \"'g set\"\n  defines \"S \\<equiv> (\\<Union>g\\<in>G. lconjby g ` A)\"\n  assumes \"g\\<in>G\" \"x \\<in> \\<langle>S\\<rangle>\"\n  shows   \"rconjby g x \\<in> \\<langle>S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rconjby g x \\<in> \\<langle>S\\<rangle>", "using   assms uminus_closed genby_set_lconjby_set_lconjby_closed"], ["proof (prove)\nusing this:\n  S \\<equiv> \\<Union>g\\<in>G. lconjby g ` A\n  g \\<in> G\n  x \\<in> \\<langle>S\\<rangle>\n  ?g \\<in> G \\<Longrightarrow> - ?g \\<in> G\n  \\<lbrakk>?g \\<in> G;\n   ?x \\<in> \\<langle>\\<Union>g\\<in>G. lconjby g ` ?A\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> lconjby ?g ?x\n                    \\<in> \\<langle>\\<Union>g\\<in>G. lconjby g ` ?A\\<rangle>\n\ngoal (1 subgoal):\n 1. rconjby g x \\<in> \\<langle>S\\<rangle>", "by      fastforce"], ["", "subsubsection \\<open>Homomorphisms and isomorphisms\\<close>"], ["", "locale GroupHom = Group G\n  for   G :: \"'g::group_add set\"\n+ fixes T :: \"'g \\<Rightarrow> 'h::group_add\"\n  assumes hom : \"g \\<in> G \\<Longrightarrow> g' \\<in> G \\<Longrightarrow> T (g + g') = T g + T g'\"\n  and     supp: \"supp T \\<subseteq> G\" \nbegin"], ["", "lemma im_zero: \"T 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T (0::'g) = (0::'h)", "using zero_closed hom[of 0 0] add_diff_cancel[of \"T 0\" \"T 0\"]"], ["proof (prove)\nusing this:\n  (0::'g) \\<in> G\n  \\<lbrakk>(0::'g) \\<in> G; (0::'g) \\<in> G\\<rbrakk>\n  \\<Longrightarrow> T ((0::'g) + (0::'g)) = T (0::'g) + T (0::'g)\n  lconjby (T (0::'g)) (T (0::'g)) = T (0::'g)\n\ngoal (1 subgoal):\n 1. T (0::'g) = (0::'h)", "by simp"], ["", "lemma im_uminus: \"T (- g) = - T g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T (- g) = - T g", "using im_zero hom[of g \"- g\"] uminus_closed[of g] minus_unique[of \"T g\"]\n        uminus_closed[of \"-g\"] supp suppI_contra[of g T]\n        suppI_contra[of \"-g\" T]"], ["proof (prove)\nusing this:\n  T (0::'g) = (0::'h)\n  \\<lbrakk>g \\<in> G; - g \\<in> G\\<rbrakk>\n  \\<Longrightarrow> T (g + - g) = T g + T (- g)\n  g \\<in> G \\<Longrightarrow> - g \\<in> G\n  T g + ?b = (0::'h) \\<Longrightarrow> - T g = ?b\n  - g \\<in> G \\<Longrightarrow> - (- g) \\<in> G\n  order.greater_eq G (supp T)\n  g \\<notin> supp T \\<Longrightarrow> T g = (0::'h)\n  - g \\<notin> supp T \\<Longrightarrow> T (- g) = (0::'h)\n\ngoal (1 subgoal):\n 1. T (- g) = - T g", "by    fastforce"], ["", "lemma im_uminus_add: \"g \\<in> G \\<Longrightarrow> g' \\<in> G \\<Longrightarrow> T (-g + g') = - T g + T g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; g' \\<in> G\\<rbrakk>\n    \\<Longrightarrow> T (- g + g') = - T g + T g'", "by (simp add: uminus_closed hom im_uminus)"], ["", "lemma im_diff: \"g \\<in> G \\<Longrightarrow> g' \\<in> G \\<Longrightarrow> T (g - g') = T g - T g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; g' \\<in> G\\<rbrakk>\n    \\<Longrightarrow> T (g - g') = T g - T g'", "using hom uminus_closed hom[of g \"-g'\"] im_uminus"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; ?g' \\<in> G\\<rbrakk>\n  \\<Longrightarrow> T (?g + ?g') = T ?g + T ?g'\n  ?g \\<in> G \\<Longrightarrow> - ?g \\<in> G\n  \\<lbrakk>g \\<in> G; - g' \\<in> G\\<rbrakk>\n  \\<Longrightarrow> T (g + - g') = T g + T (- g')\n  T (- ?g) = - T ?g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; g' \\<in> G\\<rbrakk>\n    \\<Longrightarrow> T (g - g') = T g - T g'", "by simp"], ["", "lemma im_lconjby: \"x \\<in> G \\<Longrightarrow> g \\<in> G \\<Longrightarrow> T (lconjby x g) = lconjby (T x) (T g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> G; g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> T (lconjby x g) = lconjby (T x) (T g)", "using add_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g + ?h \\<in> G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> G; g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> T (lconjby x g) = lconjby (T x) (T g)", "by (simp add: im_diff hom)"], ["", "lemma im_sum_list_map:\n  \"set (map f as) \\<subseteq> G \\<Longrightarrow> T (\\<Sum>a\\<leftarrow>as. f a) = (\\<Sum>a\\<leftarrow>as. T (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq G (set (map f as)) \\<Longrightarrow>\n    T (sum_list (map f as)) = (\\<Sum>a\\<leftarrow>as. T (f a))", "using hom im_zero sum_list_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; ?g' \\<in> G\\<rbrakk>\n  \\<Longrightarrow> T (?g + ?g') = T ?g + T ?g'\n  T (0::'g) = (0::'h)\n  order.greater_eq G (set ?as) \\<Longrightarrow> sum_list ?as \\<in> G\n\ngoal (1 subgoal):\n 1. order.greater_eq G (set (map f as)) \\<Longrightarrow>\n    T (sum_list (map f as)) = (\\<Sum>a\\<leftarrow>as. T (f a))", "by (induct as) auto"], ["", "lemma comp:\n  assumes \"GroupHom H S\" \"T`G \\<subseteq> H\" \n  shows   \"GroupHom G (S \\<circ> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupHom G (S \\<circ> T)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g g'.\n       \\<lbrakk>g \\<in> G; g' \\<in> G\\<rbrakk>\n       \\<Longrightarrow> (S \\<circ> T) (g + g') =\n                         (S \\<circ> T) g + (S \\<circ> T) g'\n 2. order.greater_eq G (supp (S \\<circ> T))", "fix g g'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g g'.\n       \\<lbrakk>g \\<in> G; g' \\<in> G\\<rbrakk>\n       \\<Longrightarrow> (S \\<circ> T) (g + g') =\n                         (S \\<circ> T) g + (S \\<circ> T) g'\n 2. order.greater_eq G (supp (S \\<circ> T))", "assume \"g \\<in> G\" \"g' \\<in> G\""], ["proof (state)\nthis:\n  g \\<in> G\n  g' \\<in> G\n\ngoal (2 subgoals):\n 1. \\<And>g g'.\n       \\<lbrakk>g \\<in> G; g' \\<in> G\\<rbrakk>\n       \\<Longrightarrow> (S \\<circ> T) (g + g') =\n                         (S \\<circ> T) g + (S \\<circ> T) g'\n 2. order.greater_eq G (supp (S \\<circ> T))", "with hom assms(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?g \\<in> G; ?g' \\<in> G\\<rbrakk>\n  \\<Longrightarrow> T (?g + ?g') = T ?g + T ?g'\n  order.greater_eq H (T ` G)\n  g \\<in> G\n  g' \\<in> G", "show \"(S \\<circ> T) (g + g') = (S \\<circ> T) g + (S \\<circ> T) g'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; ?g' \\<in> G\\<rbrakk>\n  \\<Longrightarrow> T (?g + ?g') = T ?g + T ?g'\n  order.greater_eq H (T ` G)\n  g \\<in> G\n  g' \\<in> G\n\ngoal (1 subgoal):\n 1. (S \\<circ> T) (g + g') = (S \\<circ> T) g + (S \\<circ> T) g'", "using GroupHom.hom[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; ?g' \\<in> G\\<rbrakk>\n  \\<Longrightarrow> T (?g + ?g') = T ?g + T ?g'\n  order.greater_eq H (T ` G)\n  g \\<in> G\n  g' \\<in> G\n  \\<lbrakk>?g \\<in> H; ?g' \\<in> H\\<rbrakk>\n  \\<Longrightarrow> S (?g + ?g') = S ?g + S ?g'\n\ngoal (1 subgoal):\n 1. (S \\<circ> T) (g + g') = (S \\<circ> T) g + (S \\<circ> T) g'", "by fastforce"], ["proof (state)\nthis:\n  (S \\<circ> T) (g + g') = (S \\<circ> T) g + (S \\<circ> T) g'\n\ngoal (1 subgoal):\n 1. order.greater_eq G (supp (S \\<circ> T))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. order.greater_eq G (supp (S \\<circ> T))", "from supp"], ["proof (chain)\npicking this:\n  order.greater_eq G (supp T)", "have \"\\<And>g. g \\<notin> G \\<Longrightarrow> (S \\<circ> T) g = 0\""], ["proof (prove)\nusing this:\n  order.greater_eq G (supp T)\n\ngoal (1 subgoal):\n 1. \\<And>g. g \\<notin> G \\<Longrightarrow> (S \\<circ> T) g = (0::'a)", "using suppI_contra GroupHom.im_zero[OF assms(1)]"], ["proof (prove)\nusing this:\n  order.greater_eq G (supp T)\n  ?x \\<notin> supp ?f \\<Longrightarrow> ?f ?x = (0::?'b)\n  S (0::'h) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>g. g \\<notin> G \\<Longrightarrow> (S \\<circ> T) g = (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  ?g \\<notin> G \\<Longrightarrow> (S \\<circ> T) ?g = (0::'a)\n\ngoal (1 subgoal):\n 1. order.greater_eq G (supp (S \\<circ> T))", "thus \"supp (S \\<circ> T) \\<subseteq> G\""], ["proof (prove)\nusing this:\n  ?g \\<notin> G \\<Longrightarrow> (S \\<circ> T) ?g = (0::'a)\n\ngoal (1 subgoal):\n 1. order.greater_eq G (supp (S \\<circ> T))", "using suppD_contra"], ["proof (prove)\nusing this:\n  ?g \\<notin> G \\<Longrightarrow> (S \\<circ> T) ?g = (0::'a)\n  ?f ?x = (0::?'a) \\<Longrightarrow> ?x \\<notin> supp ?f\n\ngoal (1 subgoal):\n 1. order.greater_eq G (supp (S \\<circ> T))", "by fast"], ["proof (state)\nthis:\n  order.greater_eq G (supp (S \\<circ> T))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context GroupHom *)"], ["", "definition ker :: \"('a\\<Rightarrow>'b::zero) \\<Rightarrow> 'a set\"\n  where \"ker f = {a. f a = 0}\""], ["", "lemma ker_subset_ker_restrict0: \"ker f \\<subseteq> ker (restrict0 f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (ker (restrict0 f A)) (ker f)", "unfolding ker_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq {a. restrict0 f A a = (0::'b)} {a. f a = (0::'b)}", "by auto"], ["", "context GroupHom\nbegin"], ["", "abbreviation \"Ker \\<equiv> ker T \\<inter> G\""], ["", "lemma uminus_add_in_Ker_eq_eq_im:\n  \"g\\<in>G \\<Longrightarrow> h\\<in>G \\<Longrightarrow> (-g + h \\<in> Ker) = (T g = T h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk>\n    \\<Longrightarrow> (- g + h \\<in> Ker) = (T g = T h)", "using neg_equal_iff_equal"], ["proof (prove)\nusing this:\n  (- ?a = - ?b) = (?a = ?b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk>\n    \\<Longrightarrow> (- g + h \\<in> Ker) = (T g = T h)", "by    (simp add: uminus_add_closed ker_def im_uminus_add eq_neg_iff_add_eq_0)"], ["", "end"], ["", "(* context GroupHom *)"], ["", "locale UGroupHom = GroupHom UNIV T\n  for T :: \"'g::group_add \\<Rightarrow> 'h::group_add\"\nbegin"], ["", "lemmas im_zero       = im_zero"], ["", "lemmas im_uminus     = im_uminus"], ["", "lemma hom: \"T (g+g') = T g + T g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T (g + g') = T g + T g'", "using hom"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> UNIV; ?g' \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> T (?g + ?g') = T ?g + T ?g'\n\ngoal (1 subgoal):\n 1. T (g + g') = T g + T g'", "by simp"], ["", "lemma im_diff: \"T (g - g') = T g - T g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T (g - g') = T g - T g'", "using im_diff"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> UNIV; ?g' \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> T (?g - ?g') = T ?g - T ?g'\n\ngoal (1 subgoal):\n 1. T (g - g') = T g - T g'", "by simp"], ["", "lemma im_lconjby: \"T (lconjby x g) = lconjby (T x) (T g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T (lconjby x g) = lconjby (T x) (T g)", "using im_lconjby"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> UNIV; ?g \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> T (lconjby ?x ?g) = lconjby (T ?x) (T ?g)\n\ngoal (1 subgoal):\n 1. T (lconjby x g) = lconjby (T x) (T g)", "by simp"], ["", "lemma restrict0:\n  assumes \"Group G\"\n  shows   \"GroupHom G (restrict0 T G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupHom G (restrict0 T G)", "proof (intro_locales, rule assms, unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g g'.\n       \\<lbrakk>g \\<in> G; g' \\<in> G\\<rbrakk>\n       \\<Longrightarrow> restrict0 T G (g + g') =\n                         restrict0 T G g + restrict0 T G g'\n 2. order.greater_eq G (supp (restrict0 T G))", "from hom"], ["proof (chain)\npicking this:\n  T (?g + ?g') = T ?g + T ?g'", "show  \"\\<And>g g'. g \\<in> G \\<Longrightarrow> g' \\<in> G \\<Longrightarrow>\n            restrict0 T G (g + g') = restrict0 T G g + restrict0 T G g'\""], ["proof (prove)\nusing this:\n  T (?g + ?g') = T ?g + T ?g'\n\ngoal (1 subgoal):\n 1. \\<And>g g'.\n       \\<lbrakk>g \\<in> G; g' \\<in> G\\<rbrakk>\n       \\<Longrightarrow> restrict0 T G (g + g') =\n                         restrict0 T G g + restrict0 T G g'", "using Group.add_closed[OF assms]"], ["proof (prove)\nusing this:\n  T (?g + ?g') = T ?g + T ?g'\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g + ?h \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>g g'.\n       \\<lbrakk>g \\<in> G; g' \\<in> G\\<rbrakk>\n       \\<Longrightarrow> restrict0 T G (g + g') =\n                         restrict0 T G g + restrict0 T G g'", "by    auto"], ["proof (state)\nthis:\n  \\<lbrakk>?g \\<in> G; ?g' \\<in> G\\<rbrakk>\n  \\<Longrightarrow> restrict0 T G (?g + ?g') =\n                    restrict0 T G ?g + restrict0 T G ?g'\n\ngoal (1 subgoal):\n 1. order.greater_eq G (supp (restrict0 T G))", "show \"supp (restrict0 T G) \\<subseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq G (supp (restrict0 T G))", "using supp_restrict0[of G T]"], ["proof (prove)\nusing this:\n  order.greater_eq G (supp (restrict0 T G))\n\ngoal (1 subgoal):\n 1. order.greater_eq G (supp (restrict0 T G))", "by fast"], ["proof (state)\nthis:\n  order.greater_eq G (supp (restrict0 T G))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context UGroupHom *)"], ["", "lemma UGroupHomI:\n  assumes \"\\<And>g g'. T (g + g') = T g + T g'\"\n  shows   \"UGroupHom T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UGroupHom T", "using   assms"], ["proof (prove)\nusing this:\n  T (?g + ?g') = T ?g + T ?g'\n\ngoal (1 subgoal):\n 1. UGroupHom T", "by      unfold_locales auto"], ["", "locale GroupIso = GroupHom G T\n  for   G :: \"'g::group_add set\"\n  and   T :: \"'g \\<Rightarrow> 'h::group_add\"\n+ assumes inj_on: \"inj_on T G\""], ["", "lemma (in GroupHom) isoI:\n  assumes \"\\<And>k. k\\<in>G \\<Longrightarrow> T k = 0 \\<Longrightarrow> k=0\"\n  shows   \"GroupIso G T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupIso G T", "proof (unfold_locales, rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; T x = T y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G; T x = T y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?k \\<in> G; T ?k = (0::'h)\\<rbrakk>\n  \\<Longrightarrow> ?k = (0::'g)", "show \"\\<lbrakk> x\\<in>G; y\\<in>G; T x = T y \\<rbrakk> \\<Longrightarrow> x = y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?k \\<in> G; T ?k = (0::'h)\\<rbrakk>\n  \\<Longrightarrow> ?k = (0::'g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> G; y \\<in> G; T x = T y\\<rbrakk>\n    \\<Longrightarrow> x = y", "using im_diff diff_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k \\<in> G; T ?k = (0::'h)\\<rbrakk>\n  \\<Longrightarrow> ?k = (0::'g)\n  \\<lbrakk>?g \\<in> G; ?g' \\<in> G\\<rbrakk>\n  \\<Longrightarrow> T (?g - ?g') = T ?g - T ?g'\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g - ?h \\<in> G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> G; y \\<in> G; T x = T y\\<rbrakk>\n    \\<Longrightarrow> x = y", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> G; y \\<in> G; T x = T y\\<rbrakk> \\<Longrightarrow> x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  In a @{const BinOpSetGroup}, any map from the set into a type of class @{class group_add} that respects the\n  binary operation induces a @{const GroupHom}.\n\\<close>"], ["", "abbreviation (in BinOpSetGroup) \"lift_hom T \\<equiv> restrict0 (T \\<circ> \\<ii>\\<pp>) pG\""], ["", "lemma (in BinOpSetGroup) lift_hom:\n  fixes T :: \"'a \\<Rightarrow> 'b::group_add\"\n  assumes \"\\<forall>g\\<in>G. \\<forall>h\\<in>G. T (binop g h) = T g + T h\"\n  shows   \"GroupHom pG (lift_hom T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupHom pG (lift_hom T)", "proof (intro_locales, rule Group, unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g g'.\n       \\<lbrakk>g \\<in> pG; g' \\<in> pG\\<rbrakk>\n       \\<Longrightarrow> lift_hom T (g + g') = lift_hom T g + lift_hom T g'\n 2. order.greater_eq pG (supp (lift_hom T))", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>g\\<in>G. \\<forall>h\\<in>G. T (binop g h) = T g + T h", "show  \"\\<And>x y. x\\<in>pG \\<Longrightarrow> y\\<in>pG \\<Longrightarrow>\n            lift_hom T (x+y) = lift_hom T x + lift_hom T y\""], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>G. \\<forall>h\\<in>G. T (binop g h) = T g + T h\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> pG; y \\<in> pG\\<rbrakk>\n       \\<Longrightarrow> lift_hom T (x + y) = lift_hom T x + lift_hom T y", "using Group.add_closed[OF Group] inv_correspondence_into"], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>G. \\<forall>h\\<in>G. T (binop g h) = T g + T h\n  \\<lbrakk>?g \\<in> pG; ?h \\<in> pG\\<rbrakk>\n  \\<Longrightarrow> ?g + ?h \\<in> pG\n  ?x \\<in> pG \\<Longrightarrow> \\<ii>\\<pp> ?x \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> pG; y \\<in> pG\\<rbrakk>\n       \\<Longrightarrow> lift_hom T (x + y) = lift_hom T x + lift_hom T y", "by    (simp add: homs(2)[THEN sym])"], ["proof (state)\nthis:\n  \\<lbrakk>?x1 \\<in> pG; ?y1 \\<in> pG\\<rbrakk>\n  \\<Longrightarrow> lift_hom T (?x1 + ?y1) = lift_hom T ?x1 + lift_hom T ?y1\n\ngoal (1 subgoal):\n 1. order.greater_eq pG (supp (lift_hom T))", "qed (rule supp_restrict0)"], ["", "subsubsection \\<open>Normal subgroups\\<close>"], ["", "definition rcoset_rel :: \"'a::{minus,plus} set \\<Rightarrow> ('a\\<times>'a) set\"\n  where \"rcoset_rel A \\<equiv> {(x,y). x-y \\<in> A}\""], ["", "context Group\nbegin"], ["", "lemma rcoset_rel_conv_lcoset_rel:\n  \"rcoset_rel G = map_prod uminus uminus ` (lcoset_rel G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rcoset_rel G = map_prod uminus uminus ` lcoset_rel G", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> rcoset_rel G) =\n       (x \\<in> map_prod uminus uminus ` lcoset_rel G)", "fix x :: \"'g\\<times>'g\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> rcoset_rel G) =\n       (x \\<in> map_prod uminus uminus ` lcoset_rel G)", "obtain a b where ab: \"x=(a,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> rcoset_rel G) =\n       (x \\<in> map_prod uminus uminus ` lcoset_rel G)", "hence \"(x \\<in> rcoset_rel G) = (a-b \\<in> G)\""], ["proof (prove)\nusing this:\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. (x \\<in> rcoset_rel G) = (a - b \\<in> G)", "using rcoset_rel_def"], ["proof (prove)\nusing this:\n  x = (a, b)\n  rcoset_rel ?A \\<equiv> {(x, y). x - y \\<in> ?A}\n\ngoal (1 subgoal):\n 1. (x \\<in> rcoset_rel G) = (a - b \\<in> G)", "by auto"], ["proof (state)\nthis:\n  (x \\<in> rcoset_rel G) = (a - b \\<in> G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> rcoset_rel G) =\n       (x \\<in> map_prod uminus uminus ` lcoset_rel G)", "also"], ["proof (state)\nthis:\n  (x \\<in> rcoset_rel G) = (a - b \\<in> G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> rcoset_rel G) =\n       (x \\<in> map_prod uminus uminus ` lcoset_rel G)", "have \"\\<dots> = ( (-b,-a) \\<in> lcoset_rel G )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a - b \\<in> G) = ((- b, - a) \\<in> lcoset_rel G)", "using uminus_closed lcoset_rel_def"], ["proof (prove)\nusing this:\n  ?g \\<in> G \\<Longrightarrow> - ?g \\<in> G\n  lcoset_rel ?A \\<equiv> {(x, y). - x + y \\<in> ?A}\n\ngoal (1 subgoal):\n 1. (a - b \\<in> G) = ((- b, - a) \\<in> lcoset_rel G)", "by fastforce"], ["proof (state)\nthis:\n  (a - b \\<in> G) = ((- b, - a) \\<in> lcoset_rel G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> rcoset_rel G) =\n       (x \\<in> map_prod uminus uminus ` lcoset_rel G)", "finally"], ["proof (chain)\npicking this:\n  (x \\<in> rcoset_rel G) = ((- b, - a) \\<in> lcoset_rel G)", "show  \"(x \\<in> rcoset_rel G) = (x \\<in> map_prod uminus uminus ` (lcoset_rel G))\""], ["proof (prove)\nusing this:\n  (x \\<in> rcoset_rel G) = ((- b, - a) \\<in> lcoset_rel G)\n\ngoal (1 subgoal):\n 1. (x \\<in> rcoset_rel G) = (x \\<in> map_prod uminus uminus ` lcoset_rel G)", "using ab symD[OF lcoset_rel_sym] map_prod_def"], ["proof (prove)\nusing this:\n  (x \\<in> rcoset_rel G) = ((- b, - a) \\<in> lcoset_rel G)\n  x = (a, b)\n  (?b, ?a) \\<in> lcoset_rel G \\<Longrightarrow> (?a, ?b) \\<in> lcoset_rel G\n  map_prod ?f ?g = (\\<lambda>(x, y). (?f x, ?g y))\n\ngoal (1 subgoal):\n 1. (x \\<in> rcoset_rel G) = (x \\<in> map_prod uminus uminus ` lcoset_rel G)", "by    force"], ["proof (state)\nthis:\n  (x \\<in> rcoset_rel G) = (x \\<in> map_prod uminus uminus ` lcoset_rel G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rcoset_rel_sym: \"sym (rcoset_rel G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym (rcoset_rel G)", "using rcoset_rel_conv_lcoset_rel map_prod_sym lcoset_rel_sym"], ["proof (prove)\nusing this:\n  rcoset_rel G = map_prod uminus uminus ` lcoset_rel G\n  sym ?A \\<Longrightarrow> sym (map_prod ?f ?f ` ?A)\n  sym (lcoset_rel G)\n\ngoal (1 subgoal):\n 1. sym (rcoset_rel G)", "by simp"], ["", "abbreviation RCoset_rel :: \"'g set \\<Rightarrow> ('g\\<times>'g) set\"\n  where \"RCoset_rel H \\<equiv> rcoset_rel H \\<inter> (G\\<times>G)\""], ["", "definition normal :: \"'g set \\<Rightarrow> bool\"\n  where \"normal H \\<equiv> (\\<forall>g\\<in>G. LCoset_rel H `` {g} = RCoset_rel H `` {g})\""], ["", "lemma normalI:\n  assumes   \"Group H\" \"\\<forall>g\\<in>G. \\<forall>h\\<in>H. \\<exists>h'\\<in>H. g+h = h'+g\"\n            \"\\<forall>g\\<in>G. \\<forall>h\\<in>H. \\<exists>h'\\<in>H. h+g = g+h'\"\n  shows     \"normal H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal H", "unfolding normal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>G. LCoset_rel H `` {g} = RCoset_rel H `` {g}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       g \\<in> G \\<Longrightarrow> LCoset_rel H `` {g} = RCoset_rel H `` {g}", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       g \\<in> G \\<Longrightarrow> LCoset_rel H `` {g} = RCoset_rel H `` {g}", "assume g: \"g\\<in>G\""], ["proof (state)\nthis:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       g \\<in> G \\<Longrightarrow> LCoset_rel H `` {g} = RCoset_rel H `` {g}", "show \"LCoset_rel H `` {g} = RCoset_rel H `` {g}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LCoset_rel H `` {g} = RCoset_rel H `` {g}", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> RCoset_rel H `` {g}\n 2. \\<And>x.\n       x \\<in> RCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g}", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> RCoset_rel H `` {g}\n 2. \\<And>x.\n       x \\<in> RCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g}", "assume \"x \\<in> LCoset_rel H `` {g}\""], ["proof (state)\nthis:\n  x \\<in> LCoset_rel H `` {g}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> RCoset_rel H `` {g}\n 2. \\<And>x.\n       x \\<in> RCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g}", "with g"], ["proof (chain)\npicking this:\n  g \\<in> G\n  x \\<in> LCoset_rel H `` {g}", "have x: \"x\\<in>G\" \"-g+x \\<in> H\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  x \\<in> LCoset_rel H `` {g}\n\ngoal (1 subgoal):\n 1. x \\<in> G &&& - g + x \\<in> H", "unfolding lcoset_rel_def"], ["proof (prove)\nusing this:\n  g \\<in> G\n  x \\<in> Restr {(x, y). - x + y \\<in> H} G `` {g}\n\ngoal (1 subgoal):\n 1. x \\<in> G &&& - g + x \\<in> H", "by auto"], ["proof (state)\nthis:\n  x \\<in> G\n  - g + x \\<in> H\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> RCoset_rel H `` {g}\n 2. \\<And>x.\n       x \\<in> RCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g}", "from g x(2) assms(2)"], ["proof (chain)\npicking this:\n  g \\<in> G\n  - g + x \\<in> H\n  \\<forall>g\\<in>G. \\<forall>h\\<in>H. \\<exists>h'\\<in>H. g + h = h' + g", "obtain h where h: \"h\\<in>H\" \"g-x = -h\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  - g + x \\<in> H\n  \\<forall>g\\<in>G. \\<forall>h\\<in>H. \\<exists>h'\\<in>H. g + h = h' + g\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<in> H; g - x = - h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by   (fastforce simp add: algebra_simps)"], ["proof (state)\nthis:\n  h \\<in> H\n  g - x = - h\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> RCoset_rel H `` {g}\n 2. \\<And>x.\n       x \\<in> RCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g}", "with assms(1) g x(1)"], ["proof (chain)\npicking this:\n  Group H\n  g \\<in> G\n  x \\<in> G\n  h \\<in> H\n  g - x = - h", "show \"x \\<in> RCoset_rel H `` {g}\""], ["proof (prove)\nusing this:\n  Group H\n  g \\<in> G\n  x \\<in> G\n  h \\<in> H\n  g - x = - h\n\ngoal (1 subgoal):\n 1. x \\<in> RCoset_rel H `` {g}", "using Group.uminus_closed"], ["proof (prove)\nusing this:\n  Group H\n  g \\<in> G\n  x \\<in> G\n  h \\<in> H\n  g - x = - h\n  \\<lbrakk>Group ?G; ?g \\<in> ?G\\<rbrakk> \\<Longrightarrow> - ?g \\<in> ?G\n\ngoal (1 subgoal):\n 1. x \\<in> RCoset_rel H `` {g}", "unfolding rcoset_rel_def"], ["proof (prove)\nusing this:\n  Group H\n  g \\<in> G\n  x \\<in> G\n  h \\<in> H\n  g - x = - h\n  \\<lbrakk>Group ?G; ?g \\<in> ?G\\<rbrakk> \\<Longrightarrow> - ?g \\<in> ?G\n\ngoal (1 subgoal):\n 1. x \\<in> Restr {(x, y). x - y \\<in> H} G `` {g}", "by simp"], ["proof (state)\nthis:\n  x \\<in> RCoset_rel H `` {g}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> RCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> RCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> RCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g}", "assume \"x \\<in> RCoset_rel H `` {g}\""], ["proof (state)\nthis:\n  x \\<in> RCoset_rel H `` {g}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> RCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g}", "with g"], ["proof (chain)\npicking this:\n  g \\<in> G\n  x \\<in> RCoset_rel H `` {g}", "have x: \"x\\<in>G\" \"g-x \\<in> H\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  x \\<in> RCoset_rel H `` {g}\n\ngoal (1 subgoal):\n 1. x \\<in> G &&& g - x \\<in> H", "unfolding rcoset_rel_def"], ["proof (prove)\nusing this:\n  g \\<in> G\n  x \\<in> Restr {(x, y). x - y \\<in> H} G `` {g}\n\ngoal (1 subgoal):\n 1. x \\<in> G &&& g - x \\<in> H", "by auto"], ["proof (state)\nthis:\n  x \\<in> G\n  g - x \\<in> H\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> RCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g}", "with assms(3)"], ["proof (chain)\npicking this:\n  \\<forall>g\\<in>G. \\<forall>h\\<in>H. \\<exists>h'\\<in>H. h + g = g + h'\n  x \\<in> G\n  g - x \\<in> H", "obtain h where h: \"h\\<in>H\" \"-g+x = -h\""], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>G. \\<forall>h\\<in>H. \\<exists>h'\\<in>H. h + g = g + h'\n  x \\<in> G\n  g - x \\<in> H\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<in> H; - g + x = - h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp add: algebra_simps minus_add)"], ["proof (state)\nthis:\n  h \\<in> H\n  - g + x = - h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> RCoset_rel H `` {g} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g}", "with assms(1) g x(1)"], ["proof (chain)\npicking this:\n  Group H\n  g \\<in> G\n  x \\<in> G\n  h \\<in> H\n  - g + x = - h", "show \"x \\<in> LCoset_rel H `` {g}\""], ["proof (prove)\nusing this:\n  Group H\n  g \\<in> G\n  x \\<in> G\n  h \\<in> H\n  - g + x = - h\n\ngoal (1 subgoal):\n 1. x \\<in> LCoset_rel H `` {g}", "using Group.uminus_closed"], ["proof (prove)\nusing this:\n  Group H\n  g \\<in> G\n  x \\<in> G\n  h \\<in> H\n  - g + x = - h\n  \\<lbrakk>Group ?G; ?g \\<in> ?G\\<rbrakk> \\<Longrightarrow> - ?g \\<in> ?G\n\ngoal (1 subgoal):\n 1. x \\<in> LCoset_rel H `` {g}", "unfolding lcoset_rel_def"], ["proof (prove)\nusing this:\n  Group H\n  g \\<in> G\n  x \\<in> G\n  h \\<in> H\n  - g + x = - h\n  \\<lbrakk>Group ?G; ?g \\<in> ?G\\<rbrakk> \\<Longrightarrow> - ?g \\<in> ?G\n\ngoal (1 subgoal):\n 1. x \\<in> Restr {(x, y). - x + y \\<in> H} G `` {g}", "by simp"], ["proof (state)\nthis:\n  x \\<in> LCoset_rel H `` {g}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LCoset_rel H `` {g} = RCoset_rel H `` {g}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normal_lconjby_closed:\n  \"\\<lbrakk> Subgroup H; normal H; g\\<in>G; h\\<in>H \\<rbrakk> \\<Longrightarrow> lconjby g h \\<in> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H; g \\<in> G;\n     h \\<in> H\\<rbrakk>\n    \\<Longrightarrow> lconjby g h \\<in> H", "using lcoset_relI[of g \"g+h\" H] add_closed[of g h] normal_def[of H]\n        symD[OF Group.rcoset_rel_sym, of H g \"g+h\"] rcoset_rel_def[of H]"], ["proof (prove)\nusing this:\n  - g + (g + h) \\<in> H \\<Longrightarrow> (g, g + h) \\<in> lcoset_rel H\n  \\<lbrakk>g \\<in> G; h \\<in> G\\<rbrakk> \\<Longrightarrow> g + h \\<in> G\n  normal H \\<equiv>\n  \\<forall>g\\<in>G. LCoset_rel H `` {g} = RCoset_rel H `` {g}\n  \\<lbrakk>Group H; (g, g + h) \\<in> rcoset_rel H\\<rbrakk>\n  \\<Longrightarrow> (g + h, g) \\<in> rcoset_rel H\n  rcoset_rel H \\<equiv> {(x, y). x - y \\<in> H}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H; g \\<in> G;\n     h \\<in> H\\<rbrakk>\n    \\<Longrightarrow> lconjby g h \\<in> H", "by    auto"], ["", "lemma normal_rconjby_closed:\n  \"\\<lbrakk> Subgroup H; normal H; g\\<in>G; h\\<in>H \\<rbrakk> \\<Longrightarrow> rconjby g h \\<in> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H; g \\<in> G;\n     h \\<in> H\\<rbrakk>\n    \\<Longrightarrow> rconjby g h \\<in> H", "using normal_lconjby_closed[of H \"-g\" h] uminus_closed[of g]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H; - g \\<in> G;\n   h \\<in> H\\<rbrakk>\n  \\<Longrightarrow> lconjby (- g) h \\<in> H\n  g \\<in> G \\<Longrightarrow> - g \\<in> G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H; g \\<in> G;\n     h \\<in> H\\<rbrakk>\n    \\<Longrightarrow> rconjby g h \\<in> H", "by auto"], ["", "abbreviation \"normal_closure A \\<equiv> \\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>\""], ["", "lemma (in Group) normal_closure:\n  assumes \"A\\<subseteq>G\"\n  shows   \"normal (normal_closure A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal (normal_closure A)", "proof (rule normalI, rule genby_Group)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>g\\<in>G.\n       \\<forall>h\\<in>normal_closure A.\n          \\<exists>h'\\<in>normal_closure A. g + h = h' + g\n 2. \\<forall>g\\<in>G.\n       \\<forall>h\\<in>normal_closure A.\n          \\<exists>h'\\<in>normal_closure A. h + g = g + h'", "show \"\\<forall>x\\<in>G. \\<forall>h\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>.\n        \\<exists>h'\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>. x + h = h' + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>G.\n       \\<forall>h\\<in>normal_closure A.\n          \\<exists>h'\\<in>normal_closure A. x + h = h' + x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<forall>h\\<in>normal_closure A.\n          \\<exists>h'\\<in>normal_closure A. x + h = h' + x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<forall>h\\<in>normal_closure A.\n          \\<exists>h'\\<in>normal_closure A. x + h = h' + x", "assume x: \"x\\<in>G\""], ["proof (state)\nthis:\n  x \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<forall>h\\<in>normal_closure A.\n          \\<exists>h'\\<in>normal_closure A. x + h = h' + x", "show \"\\<forall>h\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>.\n          \\<exists>h'\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>. x + h = h' + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h\\<in>normal_closure A.\n       \\<exists>h'\\<in>normal_closure A. x + h = h' + x", "proof (rule ballI, erule genby.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h. \\<exists>h'\\<in>normal_closure A. x + (0::'g) = h' + x\n 2. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. x + s = h' + x\n 3. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "show \"\\<exists>h\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>. x + 0 = h + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h\\<in>normal_closure A. x + (0::'g) = h + x", "using genby_0_closed"], ["proof (prove)\nusing this:\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>h\\<in>normal_closure A. x + (0::'g) = h + x", "by force"], ["proof (state)\nthis:\n  \\<exists>h\\<in>normal_closure A. x + (0::'g) = h + x\n\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. x + s = h' + x\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. x + s = h' + x\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. x + s = h' + x\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "assume \"s \\<in> (\\<Union>g\\<in>G. lconjby g ` A)\""], ["proof (state)\nthis:\n  s \\<in> (\\<Union>g\\<in>G. lconjby g ` A)\n\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. x + s = h' + x\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "from this"], ["proof (chain)\npicking this:\n  s \\<in> (\\<Union>g\\<in>G. lconjby g ` A)", "obtain g a where ga: \"g\\<in>G\" \"a\\<in>A\" \"s = lconjby g a\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>g\\<in>G. lconjby g ` A)\n\ngoal (1 subgoal):\n 1. (\\<And>g a.\n        \\<lbrakk>g \\<in> G; a \\<in> A; s = lconjby g a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  g \\<in> G\n  a \\<in> A\n  s = lconjby g a\n\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. x + s = h' + x\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "from ga(3)"], ["proof (chain)\npicking this:\n  s = lconjby g a", "have \"x + s = lconjby x (lconjby g a) + x\""], ["proof (prove)\nusing this:\n  s = lconjby g a\n\ngoal (1 subgoal):\n 1. x + s = lconjby x (lconjby g a) + x", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  x + s = lconjby x (lconjby g a) + x\n\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. x + s = h' + x\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "hence \"x + s = lconjby (x+g) a + x\""], ["proof (prove)\nusing this:\n  x + s = lconjby x (lconjby g a) + x\n\ngoal (1 subgoal):\n 1. x + s = lconjby (x + g) a + x", "by (simp add: lconjby_add)"], ["proof (state)\nthis:\n  x + s = lconjby (x + g) a + x\n\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. x + s = h' + x\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "with x ga(1,2)"], ["proof (chain)\npicking this:\n  x \\<in> G\n  g \\<in> G\n  a \\<in> A\n  x + s = lconjby (x + g) a + x", "show \"\\<exists>h\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>. x + s = h + x\""], ["proof (prove)\nusing this:\n  x \\<in> G\n  g \\<in> G\n  a \\<in> A\n  x + s = lconjby (x + g) a + x\n\ngoal (1 subgoal):\n 1. \\<exists>h\\<in>normal_closure A. x + s = h + x", "using add_closed"], ["proof (prove)\nusing this:\n  x \\<in> G\n  g \\<in> G\n  a \\<in> A\n  x + s = lconjby (x + g) a + x\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g + ?h \\<in> G\n\ngoal (1 subgoal):\n 1. \\<exists>h\\<in>normal_closure A. x + s = h + x", "by (blast intro: genby_genset_closed)"], ["proof (state)\nthis:\n  \\<exists>h\\<in>normal_closure A. x + s = h + x\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "fix w w'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "assume w :  \"w \\<in> \\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>\"\n                  \"\\<exists>h \\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>. x + w  = h + x\"\n        and  w':  \"w'\\<in> \\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>\"\n                  \"\\<exists>h'\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>. x + w' = h'+ x\""], ["proof (state)\nthis:\n  w \\<in> normal_closure A\n  \\<exists>h\\<in>normal_closure A. x + w = h + x\n  w' \\<in> normal_closure A\n  \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "from w(2) w'(2)"], ["proof (chain)\npicking this:\n  \\<exists>h\\<in>normal_closure A. x + w = h + x\n  \\<exists>h'\\<in>normal_closure A. x + w' = h' + x", "obtain h h'\n        where h : \"h \\<in> \\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>\" \"x + w  = h + x\"\n        and   h': \"h'\\<in> \\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>\" \"x + w' = h'+ x\""], ["proof (prove)\nusing this:\n  \\<exists>h\\<in>normal_closure A. x + w = h + x\n  \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\n\ngoal (1 subgoal):\n 1. (\\<And>h h'.\n        \\<lbrakk>h \\<in> normal_closure A; x + w = h + x;\n         h' \\<in> normal_closure A; x + w' = h' + x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  h \\<in> normal_closure A\n  x + w = h + x\n  h' \\<in> normal_closure A\n  x + w' = h' + x\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "have \"x + (w - w') = x + w - (-x + (x + w'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (w - w') = x + w - (- x + (x + w'))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  x + (w - w') = x + w - (- x + (x + w'))\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "also"], ["proof (state)\nthis:\n  x + (w - w') = x + w - (- x + (x + w'))\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "from h(2) h'(2)"], ["proof (chain)\npicking this:\n  x + w = h + x\n  x + w' = h' + x", "have \"\\<dots> = h + x + (-(h' + x) + x)\""], ["proof (prove)\nusing this:\n  x + w = h + x\n  x + w' = h' + x\n\ngoal (1 subgoal):\n 1. x + w - (- x + (x + w')) = h + x + (- (h' + x) + x)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  x + w - (- x + (x + w')) = h + x + (- (h' + x) + x)\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "also"], ["proof (state)\nthis:\n  x + w - (- x + (x + w')) = h + x + (- (h' + x) + x)\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "have \"\\<dots> = h + x + (-x + -h') + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h + x + (- (h' + x) + x) = h + x + (- x + - h') + x", "by (simp add: minus_add add.assoc)"], ["proof (state)\nthis:\n  h + x + (- (h' + x) + x) = h + x + (- x + - h') + x\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "finally"], ["proof (chain)\npicking this:\n  x + (w - w') = h + x + (- x + - h') + x", "have \"x + (w-w') = h - h' + x\""], ["proof (prove)\nusing this:\n  x + (w - w') = h + x + (- x + - h') + x\n\ngoal (1 subgoal):\n 1. x + (w - w') = h - h' + x", "using add.assoc[of \"h+x\" \"-x\" \"-h'\"]"], ["proof (prove)\nusing this:\n  x + (w - w') = h + x + (- x + - h') + x\n  h + x + - x + - h' = h + x + (- x + - h')\n\ngoal (1 subgoal):\n 1. x + (w - w') = h - h' + x", "by simp"], ["proof (state)\nthis:\n  x + (w - w') = h - h' + x\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w = h' + x;\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. x + w' = h' + x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            x + (w - w') = h' + x", "with h(1) h'(1)"], ["proof (chain)\npicking this:\n  h \\<in> normal_closure A\n  h' \\<in> normal_closure A\n  x + (w - w') = h - h' + x", "show  \"\\<exists>h\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>. x + (w - w') = h + x\""], ["proof (prove)\nusing this:\n  h \\<in> normal_closure A\n  h' \\<in> normal_closure A\n  x + (w - w') = h - h' + x\n\ngoal (1 subgoal):\n 1. \\<exists>h\\<in>normal_closure A. x + (w - w') = h + x", "using genby_diff_closed"], ["proof (prove)\nusing this:\n  h \\<in> normal_closure A\n  h' \\<in> normal_closure A\n  x + (w - w') = h - h' + x\n  \\<lbrakk>?w \\<in> \\<langle>?S\\<rangle>;\n   ?w' \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?w - ?w' \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>h\\<in>normal_closure A. x + (w - w') = h + x", "by    fast"], ["proof (state)\nthis:\n  \\<exists>h\\<in>normal_closure A. x + (w - w') = h + x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>h\\<in>normal_closure A.\n     \\<exists>h'\\<in>normal_closure A. x + h = h' + x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>G.\n     \\<forall>h\\<in>normal_closure A.\n        \\<exists>h'\\<in>normal_closure A. x + h = h' + x\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>G.\n       \\<forall>h\\<in>normal_closure A.\n          \\<exists>h'\\<in>normal_closure A. h + g = g + h'", "show \"\\<forall>x\\<in>G. \\<forall>h\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>.\n        \\<exists>h'\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>. h + x = x + h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>G.\n       \\<forall>h\\<in>normal_closure A.\n          \\<exists>h'\\<in>normal_closure A. h + x = x + h'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<forall>h\\<in>normal_closure A.\n          \\<exists>h'\\<in>normal_closure A. h + x = x + h'", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<forall>h\\<in>normal_closure A.\n          \\<exists>h'\\<in>normal_closure A. h + x = x + h'", "assume x: \"x\\<in>G\""], ["proof (state)\nthis:\n  x \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<forall>h\\<in>normal_closure A.\n          \\<exists>h'\\<in>normal_closure A. h + x = x + h'", "show \"\\<forall>h\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>.\n            \\<exists>h'\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>. h + x = x + h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h\\<in>normal_closure A.\n       \\<exists>h'\\<in>normal_closure A. h + x = x + h'", "proof (rule ballI, erule genby.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h. \\<exists>h'\\<in>normal_closure A. (0::'g) + x = x + h'\n 2. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. s + x = x + h'\n 3. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "show \"\\<exists>h\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>. 0 + x = x + h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h\\<in>normal_closure A. (0::'g) + x = x + h", "using genby_0_closed"], ["proof (prove)\nusing this:\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>h\\<in>normal_closure A. (0::'g) + x = x + h", "by force"], ["proof (state)\nthis:\n  \\<exists>h\\<in>normal_closure A. (0::'g) + x = x + h\n\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. s + x = x + h'\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. s + x = x + h'\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. s + x = x + h'\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "assume \"s \\<in> (\\<Union>g\\<in>G. lconjby g ` A)\""], ["proof (state)\nthis:\n  s \\<in> (\\<Union>g\\<in>G. lconjby g ` A)\n\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. s + x = x + h'\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "from this"], ["proof (chain)\npicking this:\n  s \\<in> (\\<Union>g\\<in>G. lconjby g ` A)", "obtain g a where ga: \"g\\<in>G\" \"a\\<in>A\" \"s = lconjby g a\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>g\\<in>G. lconjby g ` A)\n\ngoal (1 subgoal):\n 1. (\\<And>g a.\n        \\<lbrakk>g \\<in> G; a \\<in> A; s = lconjby g a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  g \\<in> G\n  a \\<in> A\n  s = lconjby g a\n\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. s + x = x + h'\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "from ga(3)"], ["proof (chain)\npicking this:\n  s = lconjby g a", "have \"s + x = x + (((-x + g) + a) + -g) + x\""], ["proof (prove)\nusing this:\n  s = lconjby g a\n\ngoal (1 subgoal):\n 1. s + x = x + (- x + g + a + - g) + x", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  s + x = x + (- x + g + a + - g) + x\n\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. s + x = x + h'\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "also"], ["proof (state)\nthis:\n  s + x = x + (- x + g + a + - g) + x\n\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. s + x = x + h'\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "have \"\\<dots> = x + (-x + g + a + -g + x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (- x + g + a + - g) + x = x + (- x + g + a + - g + x)", "by (simp add: add.assoc)"], ["proof (state)\nthis:\n  x + (- x + g + a + - g) + x = x + (- x + g + a + - g + x)\n\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. s + x = x + h'\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "finally"], ["proof (chain)\npicking this:\n  s + x = x + (- x + g + a + - g + x)", "have \"s + x = x + lconjby (-x+g) a\""], ["proof (prove)\nusing this:\n  s + x = x + (- x + g + a + - g + x)\n\ngoal (1 subgoal):\n 1. s + x = x + lconjby (- x + g) a", "by (simp add: algebra_simps lconjby_add)"], ["proof (state)\nthis:\n  s + x = x + lconjby (- x + g) a\n\ngoal (2 subgoals):\n 1. \\<And>h s.\n       s \\<in> (\\<Union>g\\<in>G. lconjby g ` A) \\<Longrightarrow>\n       \\<exists>h'\\<in>normal_closure A. s + x = x + h'\n 2. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "with x ga(1,2)"], ["proof (chain)\npicking this:\n  x \\<in> G\n  g \\<in> G\n  a \\<in> A\n  s + x = x + lconjby (- x + g) a", "show \"\\<exists>h\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>. s + x = x + h\""], ["proof (prove)\nusing this:\n  x \\<in> G\n  g \\<in> G\n  a \\<in> A\n  s + x = x + lconjby (- x + g) a\n\ngoal (1 subgoal):\n 1. \\<exists>h\\<in>normal_closure A. s + x = x + h", "using uminus_add_closed"], ["proof (prove)\nusing this:\n  x \\<in> G\n  g \\<in> G\n  a \\<in> A\n  s + x = x + lconjby (- x + g) a\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> - ?g + ?h \\<in> G\n\ngoal (1 subgoal):\n 1. \\<exists>h\\<in>normal_closure A. s + x = x + h", "by (blast intro: genby_genset_closed)"], ["proof (state)\nthis:\n  \\<exists>h\\<in>normal_closure A. s + x = x + h\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "fix w w'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "assume w :  \"w \\<in> \\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>\"\n                  \"\\<exists>h \\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>. w  + x = x + h\"\n        and  w':  \"w'\\<in> \\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>\"\n                  \"\\<exists>h'\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>. w' + x = x + h'\""], ["proof (state)\nthis:\n  w \\<in> normal_closure A\n  \\<exists>h\\<in>normal_closure A. w + x = x + h\n  w' \\<in> normal_closure A\n  \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "from w(2) w'(2)"], ["proof (chain)\npicking this:\n  \\<exists>h\\<in>normal_closure A. w + x = x + h\n  \\<exists>h'\\<in>normal_closure A. w' + x = x + h'", "obtain h h'\n        where h : \"h \\<in> \\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>\" \"w + x = x + h\"\n        and   h': \"h'\\<in> \\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>\" \"w' + x = x + h'\""], ["proof (prove)\nusing this:\n  \\<exists>h\\<in>normal_closure A. w + x = x + h\n  \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\n\ngoal (1 subgoal):\n 1. (\\<And>h h'.\n        \\<lbrakk>h \\<in> normal_closure A; w + x = x + h;\n         h' \\<in> normal_closure A; w' + x = x + h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  h \\<in> normal_closure A\n  w + x = x + h\n  h' \\<in> normal_closure A\n  w' + x = x + h'\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "have \"w - w' + x = w + x + (-x + -w') + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w - w' + x = w + x + (- x + - w') + x", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  w - w' + x = w + x + (- x + - w') + x\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "also"], ["proof (state)\nthis:\n  w - w' + x = w + x + (- x + - w') + x\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "from h(2) h'(2)"], ["proof (chain)\npicking this:\n  w + x = x + h\n  w' + x = x + h'", "have \"\\<dots> = x + h + (-h'+-x) + x\""], ["proof (prove)\nusing this:\n  w + x = x + h\n  w' + x = x + h'\n\ngoal (1 subgoal):\n 1. w + x + (- x + - w') + x = x + h + (- h' + - x) + x", "using minus_add[of w' x] minus_add[of x h']"], ["proof (prove)\nusing this:\n  w + x = x + h\n  w' + x = x + h'\n  - (w' + x) = - x + - w'\n  - (x + h') = - h' + - x\n\ngoal (1 subgoal):\n 1. w + x + (- x + - w') + x = x + h + (- h' + - x) + x", "by simp"], ["proof (state)\nthis:\n  w + x + (- x + - w') + x = x + h + (- h' + - x) + x\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "finally"], ["proof (chain)\npicking this:\n  w - w' + x = x + h + (- h' + - x) + x", "have \"w - w' + x = x + (h - h')\""], ["proof (prove)\nusing this:\n  w - w' + x = x + h + (- h' + - x) + x\n\ngoal (1 subgoal):\n 1. w - w' + x = x + (h - h')", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  w - w' + x = x + (h - h')\n\ngoal (1 subgoal):\n 1. \\<And>h w w'.\n       \\<lbrakk>w \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w + x = x + h';\n        w' \\<in> normal_closure A;\n        \\<exists>h'\\<in>normal_closure A. w' + x = x + h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h'\\<in>normal_closure A.\n                            w - w' + x = x + h'", "with h(1) h'(1)"], ["proof (chain)\npicking this:\n  h \\<in> normal_closure A\n  h' \\<in> normal_closure A\n  w - w' + x = x + (h - h')", "show \"\\<exists>h\\<in>\\<langle>\\<Union>g\\<in>G. lconjby g ` A\\<rangle>. w - w' + x = x + h\""], ["proof (prove)\nusing this:\n  h \\<in> normal_closure A\n  h' \\<in> normal_closure A\n  w - w' + x = x + (h - h')\n\ngoal (1 subgoal):\n 1. \\<exists>h\\<in>normal_closure A. w - w' + x = x + h", "using genby_diff_closed"], ["proof (prove)\nusing this:\n  h \\<in> normal_closure A\n  h' \\<in> normal_closure A\n  w - w' + x = x + (h - h')\n  \\<lbrakk>?w \\<in> \\<langle>?S\\<rangle>;\n   ?w' \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?w - ?w' \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>h\\<in>normal_closure A. w - w' + x = x + h", "by fast"], ["proof (state)\nthis:\n  \\<exists>h\\<in>normal_closure A. w - w' + x = x + h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>h\\<in>normal_closure A.\n     \\<exists>h'\\<in>normal_closure A. h + x = x + h'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>G.\n     \\<forall>h\\<in>normal_closure A.\n        \\<exists>h'\\<in>normal_closure A. h + x = x + h'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context Group *)"], ["", "subsubsection \\<open>Quotient groups\\<close>"], ["", "text \\<open>\n  Here we use the bridge built by @{const BinOpSetGroup} to make the quotient of a @{const Group}\n  by a normal subgroup into a @{const Group} itself.\n\\<close>"], ["", "context Group\nbegin"], ["", "lemma normal_quotient_add_well_defined:\n  assumes \"Subgroup H\" \"normal H\" \"g\\<in>G\" \"g'\\<in>G\"\n  shows   \"LCoset_rel H `` {g} + LCoset_rel H `` {g'} = LCoset_rel H `` {g+g'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LCoset_rel H `` {g} + LCoset_rel H `` {g'} = LCoset_rel H `` {g + g'}", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g + g'}\n 2. \\<And>x.\n       x \\<in> LCoset_rel H `` {g + g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g + g'}\n 2. \\<And>x.\n       x \\<in> LCoset_rel H `` {g + g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "assume \"x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}\""], ["proof (state)\nthis:\n  x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g + g'}\n 2. \\<And>x.\n       x \\<in> LCoset_rel H `` {g + g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "from this"], ["proof (chain)\npicking this:\n  x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "obtain y z\n    where     \"y \\<in> LCoset_rel H `` {g}\" \"z \\<in> LCoset_rel H `` {g'}\" \"x = y+z\""], ["proof (prove)\nusing this:\n  x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}\n\ngoal (1 subgoal):\n 1. (\\<And>y z.\n        \\<lbrakk>y \\<in> LCoset_rel H `` {g}; z \\<in> LCoset_rel H `` {g'};\n         x = y + z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_plus_def"], ["proof (prove)\nusing this:\n  x \\<in> {c. \\<exists>a\\<in>LCoset_rel H `` {g}.\n                 \\<exists>b\\<in>LCoset_rel H `` {g'}. c = a + b}\n\ngoal (1 subgoal):\n 1. (\\<And>y z.\n        \\<lbrakk>y \\<in> LCoset_rel H `` {g}; z \\<in> LCoset_rel H `` {g'};\n         x = y + z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by        fast"], ["proof (state)\nthis:\n  y \\<in> LCoset_rel H `` {g}\n  z \\<in> LCoset_rel H `` {g'}\n  x = y + z\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g + g'}\n 2. \\<And>x.\n       x \\<in> LCoset_rel H `` {g + g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "with assms"], ["proof (chain)\npicking this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  g \\<in> G\n  g' \\<in> G\n  y \\<in> LCoset_rel H `` {g}\n  z \\<in> LCoset_rel H `` {g'}\n  x = y + z", "show \"x \\<in> LCoset_rel H `` {g + g'}\""], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  g \\<in> G\n  g' \\<in> G\n  y \\<in> LCoset_rel H `` {g}\n  z \\<in> LCoset_rel H `` {g'}\n  x = y + z\n\ngoal (1 subgoal):\n 1. x \\<in> LCoset_rel H `` {g + g'}", "using lcoset_rel_def[of H] normal_lconjby_closed[of H g' \"-g'+z\"]\n          Group.add_closed\n          normal_rconjby_closed[of H g' \"-g + y + (z - g')\"]\n          add.assoc[of \"-g'\" \"-g\"]\n          add_closed lcoset_relI[of \"g+g'\" \"y+z\"]"], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  g \\<in> G\n  g' \\<in> G\n  y \\<in> LCoset_rel H `` {g}\n  z \\<in> LCoset_rel H `` {g'}\n  x = y + z\n  lcoset_rel H \\<equiv> {(x, y). - x + y \\<in> H}\n  \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H; g' \\<in> G;\n   - g' + z \\<in> H\\<rbrakk>\n  \\<Longrightarrow> lconjby g' (- g' + z) \\<in> H\n  \\<lbrakk>Group ?G; ?g \\<in> ?G; ?h \\<in> ?G\\<rbrakk>\n  \\<Longrightarrow> ?g + ?h \\<in> ?G\n  \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H; g' \\<in> G;\n   - g + y + (z - g') \\<in> H\\<rbrakk>\n  \\<Longrightarrow> rconjby g' (- g + y + (z - g')) \\<in> H\n  - g' + - g + ?c = - g' + (- g + ?c)\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g + ?h \\<in> G\n  - (g + g') + (y + z) \\<in> ?A \\<Longrightarrow>\n  (g + g', y + z) \\<in> lcoset_rel ?A\n\ngoal (1 subgoal):\n 1. x \\<in> LCoset_rel H `` {g + g'}", "by    (fastforce simp add: add.assoc minus_add)"], ["proof (state)\nthis:\n  x \\<in> LCoset_rel H `` {g + g'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g + g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g + g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g + g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "assume \"x \\<in> LCoset_rel H `` {g + g'}\""], ["proof (state)\nthis:\n  x \\<in> LCoset_rel H `` {g + g'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g + g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "moreover"], ["proof (state)\nthis:\n  x \\<in> LCoset_rel H `` {g + g'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g + g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "define h where \"h \\<equiv> -(g+g') + x\""], ["proof (state)\nthis:\n  h \\<equiv> - (g + g') + x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g + g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "moreover"], ["proof (state)\nthis:\n  h \\<equiv> - (g + g') + x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g + g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "hence \"x = g + (g' + h)\""], ["proof (prove)\nusing this:\n  h \\<equiv> - (g + g') + x\n\ngoal (1 subgoal):\n 1. x = g + (g' + h)", "using add.assoc[of \"-g'\" \"-g\" x]"], ["proof (prove)\nusing this:\n  h \\<equiv> - (g + g') + x\n  - g' + - g + x = - g' + (- g + x)\n\ngoal (1 subgoal):\n 1. x = g + (g' + h)", "by (simp add: add.assoc minus_add)"], ["proof (state)\nthis:\n  x = g + (g' + h)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> LCoset_rel H `` {g + g'} \\<Longrightarrow>\n       x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> LCoset_rel H `` {g + g'}\n  h \\<equiv> - (g + g') + x\n  x = g + (g' + h)", "show \"x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}\""], ["proof (prove)\nusing this:\n  x \\<in> LCoset_rel H `` {g + g'}\n  h \\<equiv> - (g + g') + x\n  x = g + (g' + h)\n\ngoal (1 subgoal):\n 1. x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "using assms(1,3,4) lcoset_rel_def[of H] add_closed\n          refl_onD[OF subgroup_refl_on_LCoset_rel, of H]"], ["proof (prove)\nusing this:\n  x \\<in> LCoset_rel H `` {g + g'}\n  h \\<equiv> - (g + g') + x\n  x = g + (g' + h)\n  Group H \\<and> order.greater_eq G H\n  g \\<in> G\n  g' \\<in> G\n  lcoset_rel H \\<equiv> {(x, y). - x + y \\<in> H}\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g + ?h \\<in> G\n  \\<lbrakk>Group H \\<and> order.greater_eq G H; ?a \\<in> G\\<rbrakk>\n  \\<Longrightarrow> (?a, ?a) \\<in> LCoset_rel H\n\ngoal (1 subgoal):\n 1. x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}", "by    force"], ["proof (state)\nthis:\n  x \\<in> LCoset_rel H `` {g} + LCoset_rel H `` {g'}\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"quotient_set H \\<equiv> G // LCoset_rel H\""], ["", "lemma BinOpSetGroup_normal_quotient:\n  assumes \"Subgroup H\" \"normal H\"\n  shows   \"BinOpSetGroup (quotient_set H) (+) H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BinOpSetGroup (G // LCoset_rel H) (+) H", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G // LCoset_rel H;\n        h \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h \\<in> G // LCoset_rel H\n 2. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)\n 3. H \\<in> G // LCoset_rel H\n 4. \\<And>g. g \\<in> G // LCoset_rel H \\<Longrightarrow> g + H = g\n 5. \\<And>g. g \\<in> G // LCoset_rel H \\<Longrightarrow> H + g = g\n 6. \\<And>g.\n       g \\<in> G // LCoset_rel H \\<Longrightarrow>\n       \\<exists>h\\<in>G // LCoset_rel H. g + h = H \\<and> h + g = H", "from assms(1)"], ["proof (chain)\npicking this:\n  Group H \\<and> order.greater_eq G H", "have H0: \"H = LCoset_rel H `` {0}\""], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n\ngoal (1 subgoal):\n 1. H = LCoset_rel H `` {0::'g}", "using trivial_LCoset"], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n  order.greater_eq G ?H \\<Longrightarrow> ?H = LCoset_rel ?H `` {0::'g}\n\ngoal (1 subgoal):\n 1. H = LCoset_rel H `` {0::'g}", "by auto"], ["proof (state)\nthis:\n  H = LCoset_rel H `` {0::'g}\n\ngoal (6 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G // LCoset_rel H;\n        h \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h \\<in> G // LCoset_rel H\n 2. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)\n 3. H \\<in> G // LCoset_rel H\n 4. \\<And>g. g \\<in> G // LCoset_rel H \\<Longrightarrow> g + H = g\n 5. \\<And>g. g \\<in> G // LCoset_rel H \\<Longrightarrow> H + g = g\n 6. \\<And>g.\n       g \\<in> G // LCoset_rel H \\<Longrightarrow>\n       \\<exists>h\\<in>G // LCoset_rel H. g + h = H \\<and> h + g = H", "from assms(1)"], ["proof (chain)\npicking this:\n  Group H \\<and> order.greater_eq G H", "show \"H \\<in> quotient_set H\""], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n\ngoal (1 subgoal):\n 1. H \\<in> G // LCoset_rel H", "using H0 zero_closed LCoset_rel_quotientI[of 0 H]"], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n  H = LCoset_rel H `` {0::'g}\n  (0::'g) \\<in> G\n  (0::'g) \\<in> G \\<Longrightarrow>\n  LCoset_rel H `` {0::'g} \\<in> G // LCoset_rel H\n\ngoal (1 subgoal):\n 1. H \\<in> G // LCoset_rel H", "by simp"], ["proof (state)\nthis:\n  H \\<in> G // LCoset_rel H\n\ngoal (5 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G // LCoset_rel H;\n        h \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h \\<in> G // LCoset_rel H\n 2. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)\n 3. \\<And>g. g \\<in> G // LCoset_rel H \\<Longrightarrow> g + H = g\n 4. \\<And>g. g \\<in> G // LCoset_rel H \\<Longrightarrow> H + g = g\n 5. \\<And>g.\n       g \\<in> G // LCoset_rel H \\<Longrightarrow>\n       \\<exists>h\\<in>G // LCoset_rel H. g + h = H \\<and> h + g = H", "fix x"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G // LCoset_rel H;\n        h \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h \\<in> G // LCoset_rel H\n 2. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)\n 3. \\<And>g. g \\<in> G // LCoset_rel H \\<Longrightarrow> g + H = g\n 4. \\<And>g. g \\<in> G // LCoset_rel H \\<Longrightarrow> H + g = g\n 5. \\<And>g.\n       g \\<in> G // LCoset_rel H \\<Longrightarrow>\n       \\<exists>h\\<in>G // LCoset_rel H. g + h = H \\<and> h + g = H", "assume \"x \\<in> quotient_set H\""], ["proof (state)\nthis:\n  x \\<in> G // LCoset_rel H\n\ngoal (5 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G // LCoset_rel H;\n        h \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h \\<in> G // LCoset_rel H\n 2. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)\n 3. \\<And>g. g \\<in> G // LCoset_rel H \\<Longrightarrow> g + H = g\n 4. \\<And>g. g \\<in> G // LCoset_rel H \\<Longrightarrow> H + g = g\n 5. \\<And>g.\n       g \\<in> G // LCoset_rel H \\<Longrightarrow>\n       \\<exists>h\\<in>G // LCoset_rel H. g + h = H \\<and> h + g = H", "from this"], ["proof (chain)\npicking this:\n  x \\<in> G // LCoset_rel H", "obtain gx where gx: \"gx\\<in>G\" \"x = LCoset_rel H `` {gx}\""], ["proof (prove)\nusing this:\n  x \\<in> G // LCoset_rel H\n\ngoal (1 subgoal):\n 1. (\\<And>gx.\n        \\<lbrakk>gx \\<in> G; x = LCoset_rel H `` {gx}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast elim: LCoset_rel_quotientE)"], ["proof (state)\nthis:\n  gx \\<in> G\n  x = LCoset_rel H `` {gx}\n\ngoal (5 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G // LCoset_rel H;\n        h \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h \\<in> G // LCoset_rel H\n 2. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)\n 3. \\<And>g. g \\<in> G // LCoset_rel H \\<Longrightarrow> g + H = g\n 4. \\<And>g. g \\<in> G // LCoset_rel H \\<Longrightarrow> H + g = g\n 5. \\<And>g.\n       g \\<in> G // LCoset_rel H \\<Longrightarrow>\n       \\<exists>h\\<in>G // LCoset_rel H. g + h = H \\<and> h + g = H", "with assms(1,2)"], ["proof (chain)\npicking this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  gx \\<in> G\n  x = LCoset_rel H `` {gx}", "show \"x+H = x\" \"H+x = x\""], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  gx \\<in> G\n  x = LCoset_rel H `` {gx}\n\ngoal (1 subgoal):\n 1. x + H = x &&& H + x = x", "using normal_quotient_add_well_defined[of H gx 0]\n          normal_quotient_add_well_defined[of H 0 gx]\n          H0 zero_closed"], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  gx \\<in> G\n  x = LCoset_rel H `` {gx}\n  \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H; gx \\<in> G;\n   (0::'g) \\<in> G\\<rbrakk>\n  \\<Longrightarrow> LCoset_rel H `` {gx} + LCoset_rel H `` {0::'g} =\n                    LCoset_rel H `` {gx + (0::'g)}\n  \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H; (0::'g) \\<in> G;\n   gx \\<in> G\\<rbrakk>\n  \\<Longrightarrow> LCoset_rel H `` {0::'g} + LCoset_rel H `` {gx} =\n                    LCoset_rel H `` {(0::'g) + gx}\n  H = LCoset_rel H `` {0::'g}\n  (0::'g) \\<in> G\n\ngoal (1 subgoal):\n 1. x + H = x &&& H + x = x", "by    auto"], ["proof (state)\nthis:\n  x + H = x\n  H + x = x\n\ngoal (3 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G // LCoset_rel H;\n        h \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h \\<in> G // LCoset_rel H\n 2. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)\n 3. \\<And>g.\n       g \\<in> G // LCoset_rel H \\<Longrightarrow>\n       \\<exists>h\\<in>G // LCoset_rel H. g + h = H \\<and> h + g = H", "from gx(1)"], ["proof (chain)\npicking this:\n  gx \\<in> G", "have \"LCoset_rel H `` {-gx} \\<in> quotient_set H\""], ["proof (prove)\nusing this:\n  gx \\<in> G\n\ngoal (1 subgoal):\n 1. LCoset_rel H `` {- gx} \\<in> G // LCoset_rel H", "using uminus_closed"], ["proof (prove)\nusing this:\n  gx \\<in> G\n  ?g \\<in> G \\<Longrightarrow> - ?g \\<in> G\n\ngoal (1 subgoal):\n 1. LCoset_rel H `` {- gx} \\<in> G // LCoset_rel H", "by (fast intro: LCoset_rel_quotientI)"], ["proof (state)\nthis:\n  LCoset_rel H `` {- gx} \\<in> G // LCoset_rel H\n\ngoal (3 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G // LCoset_rel H;\n        h \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h \\<in> G // LCoset_rel H\n 2. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)\n 3. \\<And>g.\n       g \\<in> G // LCoset_rel H \\<Longrightarrow>\n       \\<exists>h\\<in>G // LCoset_rel H. g + h = H \\<and> h + g = H", "moreover"], ["proof (state)\nthis:\n  LCoset_rel H `` {- gx} \\<in> G // LCoset_rel H\n\ngoal (3 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G // LCoset_rel H;\n        h \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h \\<in> G // LCoset_rel H\n 2. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)\n 3. \\<And>g.\n       g \\<in> G // LCoset_rel H \\<Longrightarrow>\n       \\<exists>h\\<in>G // LCoset_rel H. g + h = H \\<and> h + g = H", "from assms(1,2) gx"], ["proof (chain)\npicking this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  gx \\<in> G\n  x = LCoset_rel H `` {gx}", "have  \"x + LCoset_rel H `` {-gx} = H\" \"LCoset_rel H `` {-gx} + x = H\""], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  gx \\<in> G\n  x = LCoset_rel H `` {gx}\n\ngoal (1 subgoal):\n 1. x + LCoset_rel H `` {- gx} = H &&& LCoset_rel H `` {- gx} + x = H", "using H0 uminus_closed normal_quotient_add_well_defined"], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  gx \\<in> G\n  x = LCoset_rel H `` {gx}\n  H = LCoset_rel H `` {0::'g}\n  ?g \\<in> G \\<Longrightarrow> - ?g \\<in> G\n  \\<lbrakk>Group ?H \\<and> order.greater_eq G ?H; normal ?H; ?g \\<in> G;\n   ?g' \\<in> G\\<rbrakk>\n  \\<Longrightarrow> LCoset_rel ?H `` {?g} + LCoset_rel ?H `` {?g'} =\n                    LCoset_rel ?H `` {?g + ?g'}\n\ngoal (1 subgoal):\n 1. x + LCoset_rel H `` {- gx} = H &&& LCoset_rel H `` {- gx} + x = H", "by    auto"], ["proof (state)\nthis:\n  x + LCoset_rel H `` {- gx} = H\n  LCoset_rel H `` {- gx} + x = H\n\ngoal (3 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G // LCoset_rel H;\n        h \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h \\<in> G // LCoset_rel H\n 2. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)\n 3. \\<And>g.\n       g \\<in> G // LCoset_rel H \\<Longrightarrow>\n       \\<exists>h\\<in>G // LCoset_rel H. g + h = H \\<and> h + g = H", "ultimately"], ["proof (chain)\npicking this:\n  LCoset_rel H `` {- gx} \\<in> G // LCoset_rel H\n  x + LCoset_rel H `` {- gx} = H\n  LCoset_rel H `` {- gx} + x = H", "show \"\\<exists>x'\\<in>quotient_set H. x + x' = H \\<and> x' + x = H\""], ["proof (prove)\nusing this:\n  LCoset_rel H `` {- gx} \\<in> G // LCoset_rel H\n  x + LCoset_rel H `` {- gx} = H\n  LCoset_rel H `` {- gx} + x = H\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>G // LCoset_rel H. x + x' = H \\<and> x' + x = H", "by fast"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>G // LCoset_rel H. x + x' = H \\<and> x' + x = H\n\ngoal (2 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G // LCoset_rel H;\n        h \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h \\<in> G // LCoset_rel H\n 2. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G // LCoset_rel H;\n        h \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h \\<in> G // LCoset_rel H\n 2. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)", "assume \"y \\<in> quotient_set H\""], ["proof (state)\nthis:\n  y \\<in> G // LCoset_rel H\n\ngoal (2 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G // LCoset_rel H;\n        h \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h \\<in> G // LCoset_rel H\n 2. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)", "from this"], ["proof (chain)\npicking this:\n  y \\<in> G // LCoset_rel H", "obtain gy where gy: \"gy\\<in>G\" \"y = LCoset_rel H `` {gy}\""], ["proof (prove)\nusing this:\n  y \\<in> G // LCoset_rel H\n\ngoal (1 subgoal):\n 1. (\\<And>gy.\n        \\<lbrakk>gy \\<in> G; y = LCoset_rel H `` {gy}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fast elim: LCoset_rel_quotientE)"], ["proof (state)\nthis:\n  gy \\<in> G\n  y = LCoset_rel H `` {gy}\n\ngoal (2 subgoals):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> G // LCoset_rel H;\n        h \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h \\<in> G // LCoset_rel H\n 2. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)", "with assms gx"], ["proof (chain)\npicking this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  gx \\<in> G\n  x = LCoset_rel H `` {gx}\n  gy \\<in> G\n  y = LCoset_rel H `` {gy}", "show \"x+y \\<in> quotient_set H\""], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  gx \\<in> G\n  x = LCoset_rel H `` {gx}\n  gy \\<in> G\n  y = LCoset_rel H `` {gy}\n\ngoal (1 subgoal):\n 1. x + y \\<in> G // LCoset_rel H", "using add_closed normal_quotient_add_well_defined"], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  gx \\<in> G\n  x = LCoset_rel H `` {gx}\n  gy \\<in> G\n  y = LCoset_rel H `` {gy}\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g + ?h \\<in> G\n  \\<lbrakk>Group ?H \\<and> order.greater_eq G ?H; normal ?H; ?g \\<in> G;\n   ?g' \\<in> G\\<rbrakk>\n  \\<Longrightarrow> LCoset_rel ?H `` {?g} + LCoset_rel ?H `` {?g'} =\n                    LCoset_rel ?H `` {?g + ?g'}\n\ngoal (1 subgoal):\n 1. x + y \\<in> G // LCoset_rel H", "by    (auto intro: LCoset_rel_quotientI)"], ["proof (state)\nthis:\n  x + y \\<in> G // LCoset_rel H\n\ngoal (1 subgoal):\n 1. \\<And>g h k.\n       \\<lbrakk>g \\<in> G // LCoset_rel H; h \\<in> G // LCoset_rel H;\n        k \\<in> G // LCoset_rel H\\<rbrakk>\n       \\<Longrightarrow> g + h + k = g + (h + k)", "qed (rule add.assoc)"], ["", "abbreviation \"abs_lcoset_perm H \\<equiv>\n                BinOpSetGroup.Abs_G_perm (quotient_set H) (+)\""], ["", "abbreviation \"abs_lcoset_perm_lift H g \\<equiv> abs_lcoset_perm H (LCoset_rel H `` {g})\""], ["", "abbreviation \"abs_lcoset_perm_lift_arg_permutation g H \\<equiv> abs_lcoset_perm_lift H g\""], ["", "notation abs_lcoset_perm_lift_arg_permutation (\"\\<lceil>_|_\\<rceil>\" [51,51] 50)"], ["", "end"], ["", "(* context Group *)"], ["", "abbreviation \"Group_abs_lcoset_perm_lift_arg_permutation G' g H \\<equiv>\n  Group.abs_lcoset_perm_lift_arg_permutation G' g H\""], ["", "notation Group_abs_lcoset_perm_lift_arg_permutation (\"\\<lceil>_|_|_\\<rceil>\" [51,51,51] 50)"], ["", "context Group\nbegin"], ["", "lemmas lcoset_perm_def =\n  BinOpSetGroup.Abs_G_perm_def[OF BinOpSetGroup_normal_quotient]"], ["", "lemmas lcoset_perm_comp =\n  BinOpSetGroup.G_perm_comp[OF BinOpSetGroup_normal_quotient]"], ["", "lemmas bij_lcoset_perm =\n  BinOpSetGroup.bij_G_perm[OF BinOpSetGroup_normal_quotient]"], ["", "lemma trivial_lcoset_perm:\n  assumes \"Subgroup H\" \"normal H\" \"h\\<in>H\"\n  shows   \"restrict1 ((+) (LCoset_rel H `` {h})) (quotient_set H) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict1 ((+) (LCoset_rel H `` {h})) (G // LCoset_rel H) = id", "proof (rule ext, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> G // LCoset_rel H \\<Longrightarrow>\n       LCoset_rel H `` {h} + a = a", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> G // LCoset_rel H \\<Longrightarrow>\n       LCoset_rel H `` {h} + a = a", "assume x: \"x \\<in> quotient_set H\""], ["proof (state)\nthis:\n  x \\<in> G // LCoset_rel H\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> G // LCoset_rel H \\<Longrightarrow>\n       LCoset_rel H `` {h} + a = a", "then"], ["proof (chain)\npicking this:\n  x \\<in> G // LCoset_rel H", "obtain k where k: \"k\\<in>G\" \"x = LCoset_rel H `` {k}\""], ["proof (prove)\nusing this:\n  x \\<in> G // LCoset_rel H\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k \\<in> G; x = LCoset_rel H `` {k}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast elim: LCoset_rel_quotientE)"], ["proof (state)\nthis:\n  k \\<in> G\n  x = LCoset_rel H `` {k}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> G // LCoset_rel H \\<Longrightarrow>\n       LCoset_rel H `` {h} + a = a", "with x"], ["proof (chain)\npicking this:\n  x \\<in> G // LCoset_rel H\n  k \\<in> G\n  x = LCoset_rel H `` {k}", "have \"LCoset_rel H `` {h} + x = LCoset_rel H `` {h+k}\""], ["proof (prove)\nusing this:\n  x \\<in> G // LCoset_rel H\n  k \\<in> G\n  x = LCoset_rel H `` {k}\n\ngoal (1 subgoal):\n 1. LCoset_rel H `` {h} + x = LCoset_rel H `` {h + k}", "using assms normal_quotient_add_well_defined"], ["proof (prove)\nusing this:\n  x \\<in> G // LCoset_rel H\n  k \\<in> G\n  x = LCoset_rel H `` {k}\n  Group H \\<and> order.greater_eq G H\n  normal H\n  h \\<in> H\n  \\<lbrakk>Group ?H \\<and> order.greater_eq G ?H; normal ?H; ?g \\<in> G;\n   ?g' \\<in> G\\<rbrakk>\n  \\<Longrightarrow> LCoset_rel ?H `` {?g} + LCoset_rel ?H `` {?g'} =\n                    LCoset_rel ?H `` {?g + ?g'}\n\ngoal (1 subgoal):\n 1. LCoset_rel H `` {h} + x = LCoset_rel H `` {h + k}", "by auto"], ["proof (state)\nthis:\n  LCoset_rel H `` {h} + x = LCoset_rel H `` {h + k}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> G // LCoset_rel H \\<Longrightarrow>\n       LCoset_rel H `` {h} + a = a", "with assms k"], ["proof (chain)\npicking this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  h \\<in> H\n  k \\<in> G\n  x = LCoset_rel H `` {k}\n  LCoset_rel H `` {h} + x = LCoset_rel H `` {h + k}", "show \"LCoset_rel H `` {h} + x = x\""], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  h \\<in> H\n  k \\<in> G\n  x = LCoset_rel H `` {k}\n  LCoset_rel H `` {h} + x = LCoset_rel H `` {h + k}\n\ngoal (1 subgoal):\n 1. LCoset_rel H `` {h} + x = x", "using add_closed[of h k] lcoset_relI[of k \"h+k\" H]\n          normal_rconjby_closed[of H k h]\n          eq_equiv_class_iff[OF lcoset_subgroup_rel_equiv, of H]"], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  h \\<in> H\n  k \\<in> G\n  x = LCoset_rel H `` {k}\n  LCoset_rel H `` {h} + x = LCoset_rel H `` {h + k}\n  \\<lbrakk>h \\<in> G; k \\<in> G\\<rbrakk> \\<Longrightarrow> h + k \\<in> G\n  - k + (h + k) \\<in> H \\<Longrightarrow> (k, h + k) \\<in> lcoset_rel H\n  \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H; k \\<in> G;\n   h \\<in> H\\<rbrakk>\n  \\<Longrightarrow> rconjby k h \\<in> H\n  \\<lbrakk>Group H \\<and> order.greater_eq G H; ?x \\<in> G;\n   ?y \\<in> G\\<rbrakk>\n  \\<Longrightarrow> (LCoset_rel H `` {?x} = LCoset_rel H `` {?y}) =\n                    ((?x, ?y) \\<in> LCoset_rel H)\n\ngoal (1 subgoal):\n 1. LCoset_rel H `` {h} + x = x", "by    (auto simp add: add.assoc)"], ["proof (state)\nthis:\n  LCoset_rel H `` {h} + x = x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition quotient_group :: \"'g set \\<Rightarrow> 'g set permutation set\" where\n  \"quotient_group H \\<equiv> BinOpSetGroup.pG (quotient_set H) (+)\""], ["", "abbreviation \"natural_quotient_hom H \\<equiv> restrict0 (\\<lambda>g. \\<lceil>g|H\\<rceil>) G\""], ["", "theorem quotient_group:\n  \"Subgroup H \\<Longrightarrow> normal H \\<Longrightarrow> Group (quotient_group H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H\\<rbrakk>\n    \\<Longrightarrow> Group (quotient_group H)", "unfolding quotient_group_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H\\<rbrakk>\n    \\<Longrightarrow> Group\n                       (BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+) `\n                        G // LCoset_rel H)", "using     BinOpSetGroup.Group[OF BinOpSetGroup_normal_quotient]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Group ?e \\<and> order.greater_eq G ?e; normal ?e\\<rbrakk>\n  \\<Longrightarrow> Group\n                     (BinOpSetGroup.Abs_G_perm (G // LCoset_rel ?e) (+) `\n                      G // LCoset_rel ?e)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H\\<rbrakk>\n    \\<Longrightarrow> Group\n                       (BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+) `\n                        G // LCoset_rel H)", "by        auto"], ["", "lemma natural_quotient_hom:\n  \"Subgroup H \\<Longrightarrow> normal H \\<Longrightarrow> GroupHom G (natural_quotient_hom H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H\\<rbrakk>\n    \\<Longrightarrow> GroupHom G\n                       (\\<lambda>a.\n                           if a \\<in> G\n                           then BinOpSetGroup.Abs_G_perm (G // LCoset_rel H)\n                                 (+) (LCoset_rel H `` {a})\n                           else 0)", "using add_closed bij_lcoset_perm lcoset_perm_def supp_restrict0\n        normal_quotient_add_well_defined[THEN sym]\n        LCoset_rel_quotientI[of _ H]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g + ?h \\<in> G\n  \\<lbrakk>Group ?e \\<and> order.greater_eq G ?e; normal ?e;\n   ?g \\<in> G // LCoset_rel ?e\\<rbrakk>\n  \\<Longrightarrow> bij (restrict1 ((+) ?g) (G // LCoset_rel ?e))\n  \\<lbrakk>Group ?e \\<and> order.greater_eq G ?e; normal ?e\\<rbrakk>\n  \\<Longrightarrow> BinOpSetGroup.Abs_G_perm (G // LCoset_rel ?e) (+)\n                     ?g \\<equiv>\n                    Abs_permutation\n                     (restrict1 ((+) ?g) (G // LCoset_rel ?e))\n  order.greater_eq ?A (supp (restrict0 ?f ?A))\n  \\<lbrakk>Group ?H1 \\<and> order.greater_eq G ?H1; normal ?H1; ?g1 \\<in> G;\n   ?g'1 \\<in> G\\<rbrakk>\n  \\<Longrightarrow> LCoset_rel ?H1 `` {?g1 + ?g'1} =\n                    LCoset_rel ?H1 `` {?g1} + LCoset_rel ?H1 `` {?g'1}\n  ?x \\<in> G \\<Longrightarrow> LCoset_rel H `` {?x} \\<in> G // LCoset_rel H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H\\<rbrakk>\n    \\<Longrightarrow> GroupHom G\n                       (\\<lambda>a.\n                           if a \\<in> G\n                           then BinOpSetGroup.Abs_G_perm (G // LCoset_rel H)\n                                 (+) (LCoset_rel H `` {a})\n                           else 0)", "by    unfold_locales\n        (force simp add: lcoset_perm_comp plus_permutation_abs_eq)"], ["", "lemma natural_quotient_hom_image:\n  \"natural_quotient_hom H ` G = quotient_group H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a.\n        if a \\<in> G\n        then BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+)\n              (LCoset_rel H `` {a})\n        else 0) `\n    G =\n    quotient_group H", "unfolding quotient_group_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a.\n        if a \\<in> G\n        then BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+)\n              (LCoset_rel H `` {a})\n        else 0) `\n    G =\n    BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+) ` G // LCoset_rel H", "by        (force elim: LCoset_rel_quotientE intro: LCoset_rel_quotientI)"], ["", "lemma quotient_group_UN: \"quotient_group H = (\\<lambda>g. \\<lceil>g|H\\<rceil>) ` G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quotient_group H =\n    (\\<lambda>g.\n        BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+)\n         (LCoset_rel H `` {g})) `\n    G", "using natural_quotient_hom_image"], ["proof (prove)\nusing this:\n  (\\<lambda>a.\n      if a \\<in> G\n      then BinOpSetGroup.Abs_G_perm (G // LCoset_rel ?H) (+)\n            (LCoset_rel ?H `` {a})\n      else 0) `\n  G =\n  quotient_group ?H\n\ngoal (1 subgoal):\n 1. quotient_group H =\n    (\\<lambda>g.\n        BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+)\n         (LCoset_rel H `` {g})) `\n    G", "by auto"], ["", "lemma quotient_identity_rule: \"\\<lbrakk> Subgroup H; normal H; h\\<in>H \\<rbrakk> \\<Longrightarrow> \\<lceil>h|H\\<rceil> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H;\n     h \\<in> H\\<rbrakk>\n    \\<Longrightarrow> BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+)\n                       (LCoset_rel H `` {h}) =\n                      0", "using lcoset_perm_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>Group ?e \\<and> order.greater_eq G ?e; normal ?e\\<rbrakk>\n  \\<Longrightarrow> BinOpSetGroup.Abs_G_perm (G // LCoset_rel ?e) (+)\n                     ?g \\<equiv>\n                    Abs_permutation\n                     (restrict1 ((+) ?g) (G // LCoset_rel ?e))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H;\n     h \\<in> H\\<rbrakk>\n    \\<Longrightarrow> BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+)\n                       (LCoset_rel H `` {h}) =\n                      0", "by    (simp add: trivial_lcoset_perm zero_permutation.abs_eq)"], ["", "lemma quotient_group_lift_to_quotient_set:\n  \"\\<lbrakk> Subgroup H; normal H; g\\<in>G \\<rbrakk> \\<Longrightarrow> (\\<lceil>g|H\\<rceil>) \\<rightarrow> H = LCoset_rel H `` {g}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+)\n                       (LCoset_rel H `` {g}) \\<rightarrow>\n                      H =\n                      LCoset_rel H `` {g}", "using LCoset_rel_quotientI\n        BinOpSetGroup.G_perm_apply_identity[\n          OF BinOpSetGroup_normal_quotient\n        ]"], ["proof (prove)\nusing this:\n  ?x \\<in> G \\<Longrightarrow>\n  LCoset_rel ?uu `` {?x} \\<in> G // LCoset_rel ?uu\n  \\<lbrakk>Group ?e \\<and> order.greater_eq G ?e; normal ?e;\n   ?g \\<in> G // LCoset_rel ?e\\<rbrakk>\n  \\<Longrightarrow> BinOpSetGroup.Abs_G_perm (G // LCoset_rel ?e) (+)\n                     ?g \\<rightarrow>\n                    ?e =\n                    ?g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+)\n                       (LCoset_rel H `` {g}) \\<rightarrow>\n                      H =\n                      LCoset_rel H `` {g}", "by    simp"], ["", "end"], ["", "(* context Group *)"], ["", "subsubsection \\<open>The induced homomorphism on a quotient group\\<close>"], ["", "text \\<open>\n  A normal subgroup contained in the kernel of a homomorphism gives rise to a homomorphism on the\n  quotient group by that subgroup. When the subgroup is the kernel itself (which is always normal),\n  we obtain an isomorphism on the quotient.\n\\<close>"], ["", "context GroupHom\nbegin"], ["", "lemma respects_Ker_lcosets: \"H \\<subseteq> Ker \\<Longrightarrow> T respects (LCoset_rel H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq Ker H \\<Longrightarrow> T respects LCoset_rel H", "using     uminus_add_in_Ker_eq_eq_im"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> (- ?g + ?h \\<in> Ker) = (T ?g = T ?h)\n\ngoal (1 subgoal):\n 1. order.greater_eq Ker H \\<Longrightarrow> T respects LCoset_rel H", "unfolding lcoset_rel_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk>\n  \\<Longrightarrow> (- ?g + ?h \\<in> Ker) = (T ?g = T ?h)\n\ngoal (1 subgoal):\n 1. order.greater_eq Ker H \\<Longrightarrow>\n    T respects Restr {(x, y). - x + y \\<in> H} G", "by        (blast intro: congruentI)"], ["", "abbreviation \"quotient_hom H \\<equiv>\n  BinOpSetGroup.lift_hom (quotient_set H) (+) (quotientfun T)\""], ["", "lemmas normal_subgroup_quotientfun_classrep_equality =\n  quotientfun_classrep_equality[\n    OF subgroup_refl_on_LCoset_rel, OF _ respects_Ker_lcosets\n  ]"], ["", "lemma quotient_hom_im:\n  \"\\<lbrakk> Subgroup H; normal H; H \\<subseteq> Ker; g\\<in>G \\<rbrakk> \\<Longrightarrow> quotient_hom H (\\<lceil>g|H\\<rceil>) = T g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H;\n     order.greater_eq Ker H; g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> restrict0\n                       (quotientfun T \\<circ>\n                        the_inv_into (G // LCoset_rel H)\n                         (BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+)))\n                       (BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+) `\n                        G // LCoset_rel H)\n                       (BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+)\n                         (LCoset_rel H `` {g})) =\n                      T g", "using quotient_group_def quotient_group_UN quotient_group_lift_to_quotient_set\n        BinOpSetGroup.inv_correspondence_conv_apply[\n          OF BinOpSetGroup_normal_quotient\n        ]\n        normal_subgroup_quotientfun_classrep_equality"], ["proof (prove)\nusing this:\n  quotient_group ?H \\<equiv>\n  BinOpSetGroup.Abs_G_perm (G // LCoset_rel ?H) (+) ` G // LCoset_rel ?H\n  quotient_group ?H =\n  (\\<lambda>g.\n      BinOpSetGroup.Abs_G_perm (G // LCoset_rel ?H) (+)\n       (LCoset_rel ?H `` {g})) `\n  G\n  \\<lbrakk>Group ?H \\<and> order.greater_eq G ?H; normal ?H;\n   ?g \\<in> G\\<rbrakk>\n  \\<Longrightarrow> BinOpSetGroup.Abs_G_perm (G // LCoset_rel ?H) (+)\n                     (LCoset_rel ?H `` {?g}) \\<rightarrow>\n                    ?H =\n                    LCoset_rel ?H `` {?g}\n  \\<lbrakk>Group ?e \\<and> order.greater_eq G ?e; normal ?e;\n   ?x \\<in> BinOpSetGroup.Abs_G_perm (G // LCoset_rel ?e) (+) `\n            G // LCoset_rel ?e\\<rbrakk>\n  \\<Longrightarrow> the_inv_into (G // LCoset_rel ?e)\n                     (BinOpSetGroup.Abs_G_perm (G // LCoset_rel ?e) (+))\n                     ?x =\n                    ?x \\<rightarrow> ?e\n  \\<lbrakk>Group ?H \\<and> order.greater_eq G ?H; order.greater_eq Ker ?H;\n   ?a \\<in> G\\<rbrakk>\n  \\<Longrightarrow> quotientfun T (LCoset_rel ?H `` {?a}) = T ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Group H \\<and> order.greater_eq G H; normal H;\n     order.greater_eq Ker H; g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> restrict0\n                       (quotientfun T \\<circ>\n                        the_inv_into (G // LCoset_rel H)\n                         (BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+)))\n                       (BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+) `\n                        G // LCoset_rel H)\n                       (BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+)\n                         (LCoset_rel H `` {g})) =\n                      T g", "by    auto"], ["", "lemma quotient_hom:\n  assumes \"Subgroup H\" \"normal H\" \"H \\<subseteq> Ker\"\n  shows   \"GroupHom (quotient_group H) (quotient_hom H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupHom (quotient_group H)\n     (restrict0\n       (quotientfun T \\<circ>\n        the_inv_into (G // LCoset_rel H)\n         (BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+)))\n       (BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+) `\n        G // LCoset_rel H))", "unfolding quotient_group_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupHom\n     (BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+) ` G // LCoset_rel H)\n     (restrict0\n       (quotientfun T \\<circ>\n        the_inv_into (G // LCoset_rel H)\n         (BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+)))\n       (BinOpSetGroup.Abs_G_perm (G // LCoset_rel H) (+) `\n        G // LCoset_rel H))", "proof (\n  rule BinOpSetGroup.lift_hom, rule BinOpSetGroup_normal_quotient, rule assms(1),\n  rule assms(2)\n)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>G // LCoset_rel H.\n       \\<forall>h\\<in>G // LCoset_rel H.\n          quotientfun T (g + h) = quotientfun T g + quotientfun T h", "from assms"], ["proof (chain)\npicking this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  order.greater_eq Ker H", "show  \"\\<forall>x \\<in> quotient_set H. \\<forall>y \\<in> quotient_set H.\n            quotientfun T (x + y) = quotientfun T x + quotientfun T y\""], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  order.greater_eq Ker H\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>G // LCoset_rel H.\n       \\<forall>y\\<in>G // LCoset_rel H.\n          quotientfun T (x + y) = quotientfun T x + quotientfun T y", "using normal_quotient_add_well_defined normal_subgroup_quotientfun_classrep_equality\n          add_closed hom"], ["proof (prove)\nusing this:\n  Group H \\<and> order.greater_eq G H\n  normal H\n  order.greater_eq Ker H\n  \\<lbrakk>Group ?H \\<and> order.greater_eq G ?H; normal ?H; ?g \\<in> G;\n   ?g' \\<in> G\\<rbrakk>\n  \\<Longrightarrow> LCoset_rel ?H `` {?g} + LCoset_rel ?H `` {?g'} =\n                    LCoset_rel ?H `` {?g + ?g'}\n  \\<lbrakk>Group ?H \\<and> order.greater_eq G ?H; order.greater_eq Ker ?H;\n   ?a \\<in> G\\<rbrakk>\n  \\<Longrightarrow> quotientfun T (LCoset_rel ?H `` {?a}) = T ?a\n  \\<lbrakk>?g \\<in> G; ?h \\<in> G\\<rbrakk> \\<Longrightarrow> ?g + ?h \\<in> G\n  \\<lbrakk>?g \\<in> G; ?g' \\<in> G\\<rbrakk>\n  \\<Longrightarrow> T (?g + ?g') = T ?g + T ?g'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>G // LCoset_rel H.\n       \\<forall>y\\<in>G // LCoset_rel H.\n          quotientfun T (x + y) = quotientfun T x + quotientfun T y", "by    (fastforce elim: LCoset_rel_quotientE)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>G // LCoset_rel H.\n     \\<forall>y\\<in>G // LCoset_rel H.\n        quotientfun T (x + y) = quotientfun T x + quotientfun T y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context GroupHom *)"], ["", "subsection \\<open>Free groups\\<close>"], ["", "subsubsection \\<open>Words in letters of @{type signed} type\\<close>"], ["", "paragraph \\<open>Definitions and basic fact\\<close>"], ["", "text \\<open>\n  We pair elements of some type with type @{typ bool}, where the @{typ bool} part of the pair\n  indicates inversion.\n\\<close>"], ["", "abbreviation \"pairtrue  \\<equiv> \\<lambda>s. (s,True)\""], ["", "abbreviation \"pairfalse \\<equiv> \\<lambda>s. (s,False)\""], ["", "abbreviation flip_signed :: \"'a signed \\<Rightarrow> 'a signed\"\n  where \"flip_signed \\<equiv> apsnd (\\<lambda>b. \\<not>b)\""], ["", "abbreviation nflipped_signed :: \"'a signed \\<Rightarrow> 'a signed \\<Rightarrow> bool\"\n  where \"nflipped_signed x y \\<equiv> y \\<noteq> flip_signed x\""], ["", "lemma flip_signed_order2: \"flip_signed (flip_signed x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip_signed (flip_signed x) = x", "using apsnd_conv[of \"\\<lambda>b. \\<not>b\" \"fst x\" \"snd x\"]"], ["proof (prove)\nusing this:\n  flip_signed (fst x, snd x) = (fst x, \\<not> snd x)\n\ngoal (1 subgoal):\n 1. flip_signed (flip_signed x) = x", "by simp"], ["", "abbreviation charpair :: \"'a::uminus set \\<Rightarrow> 'a \\<Rightarrow> 'a signed\"\n  where \"charpair S s \\<equiv> if s\\<in>S then (s,True) else (-s,False)\""], ["", "lemma map_charpair_uniform:\n  \"ss\\<in>lists S \\<Longrightarrow> map (charpair S) ss = map pairtrue ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow> map (charpair S) ss = map pairtrue ss", "by (induct ss) auto"], ["", "lemma fst_set_map_charpair_un_uminus:\n  fixes ss :: \"'a::group_add list\"\n  shows \"ss\\<in>lists (S \\<union> uminus ` S) \\<Longrightarrow> fst ` set (map (charpair S) ss) \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists (S \\<union> uminus ` S) \\<Longrightarrow>\n    order.greater_eq S (fst ` set (map (charpair S) ss))", "by (induct ss) auto"], ["", "abbreviation apply_sign :: \"('a\\<Rightarrow>'b::uminus) \\<Rightarrow> 'a signed \\<Rightarrow> 'b\"\n  where \"apply_sign f x \\<equiv> (if snd x then f (fst x) else - f (fst x))\""], ["", "text \\<open>\n  A word in such pairs will be considered proper if it does not contain consecutive letters that\n  have opposite signs (and so are considered inverse), since such consecutive letters would be\n  cancelled in a group.\n\\<close>"], ["", "abbreviation proper_signed_list :: \"'a signed list \\<Rightarrow> bool\"\n  where \"proper_signed_list \\<equiv> binrelchain nflipped_signed\""], ["", "lemma proper_map_flip_signed:\n  \"proper_signed_list xs \\<Longrightarrow> proper_signed_list (map flip_signed xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_signed_list xs \\<Longrightarrow>\n    proper_signed_list (map flip_signed xs)", "by (induct xs rule: list_induct_CCons) auto"], ["", "lemma proper_rev_map_flip_signed:\n  \"proper_signed_list xs \\<Longrightarrow> proper_signed_list (rev (map flip_signed xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_signed_list xs \\<Longrightarrow>\n    proper_signed_list (rev (map flip_signed xs))", "using proper_map_flip_signed binrelchain_sym_rev[of nflipped_signed]"], ["proof (prove)\nusing this:\n  proper_signed_list ?xs \\<Longrightarrow>\n  proper_signed_list (map flip_signed ?xs)\n  \\<lbrakk>\\<And>x y.\n              nflipped_signed x y \\<Longrightarrow> nflipped_signed y x;\n   proper_signed_list ?xs\\<rbrakk>\n  \\<Longrightarrow> proper_signed_list (rev ?xs)\n\ngoal (1 subgoal):\n 1. proper_signed_list xs \\<Longrightarrow>\n    proper_signed_list (rev (map flip_signed xs))", "by fastforce"], ["", "lemma uniform_snd_imp_proper_signed_list:\n  \"snd ` set xs \\<subseteq> {b} \\<Longrightarrow> proper_signed_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq {b} (snd ` set xs) \\<Longrightarrow>\n    proper_signed_list xs", "proof (induct xs rule: list_induct_CCons)"], ["proof (state)\ngoal (3 subgoals):\n 1. order.greater_eq {b} (snd ` set []) \\<Longrightarrow>\n    proper_signed_list []\n 2. \\<And>x.\n       order.greater_eq {b} (snd ` set [x]) \\<Longrightarrow>\n       proper_signed_list [x]\n 3. \\<And>x y xs.\n       \\<lbrakk>order.greater_eq {b} (snd ` set (y # xs)) \\<Longrightarrow>\n                proper_signed_list (y # xs);\n        order.greater_eq {b} (snd ` set (x # y # xs))\\<rbrakk>\n       \\<Longrightarrow> proper_signed_list (x # y # xs)", "case CCons"], ["proof (state)\nthis:\n  order.greater_eq {b} (snd ` set (y_ # xs_)) \\<Longrightarrow>\n  proper_signed_list (y_ # xs_)\n  order.greater_eq {b} (snd ` set (x_ # y_ # xs_))\n\ngoal (3 subgoals):\n 1. order.greater_eq {b} (snd ` set []) \\<Longrightarrow>\n    proper_signed_list []\n 2. \\<And>x.\n       order.greater_eq {b} (snd ` set [x]) \\<Longrightarrow>\n       proper_signed_list [x]\n 3. \\<And>x y xs.\n       \\<lbrakk>order.greater_eq {b} (snd ` set (y # xs)) \\<Longrightarrow>\n                proper_signed_list (y # xs);\n        order.greater_eq {b} (snd ` set (x # y # xs))\\<rbrakk>\n       \\<Longrightarrow> proper_signed_list (x # y # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  order.greater_eq {b} (snd ` set (y_ # xs_)) \\<Longrightarrow>\n  proper_signed_list (y_ # xs_)\n  order.greater_eq {b} (snd ` set (x_ # y_ # xs_))\n\ngoal (1 subgoal):\n 1. proper_signed_list (x_ # y_ # xs_)", "by force"], ["proof (state)\nthis:\n  proper_signed_list (x_ # y_ # xs_)\n\ngoal (2 subgoals):\n 1. order.greater_eq {b} (snd ` set []) \\<Longrightarrow>\n    proper_signed_list []\n 2. \\<And>x.\n       order.greater_eq {b} (snd ` set [x]) \\<Longrightarrow>\n       proper_signed_list [x]", "qed auto"], ["", "lemma proper_signed_list_map_uniform_snd:\n  \"proper_signed_list (map (\\<lambda>s. (s,b)) as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_signed_list (map (\\<lambda>s. (s, b)) as)", "using uniform_snd_imp_proper_signed_list[of _ b]"], ["proof (prove)\nusing this:\n  order.greater_eq {b} (snd ` set ?xs) \\<Longrightarrow>\n  proper_signed_list ?xs\n\ngoal (1 subgoal):\n 1. proper_signed_list (map (\\<lambda>s. (s, b)) as)", "by force"], ["", "paragraph \\<open>Algebra\\<close>"], ["", "text \\<open>\n  Addition is performed by appending words and recursively removing any newly created adjacent\n  pairs of inverse letters. Since we will only ever be adding proper words, we only need to care\n  about newly created adjacent inverse pairs in the middle.\n\\<close>"], ["", "function prappend_signed_list :: \"'a signed list \\<Rightarrow> 'a signed list \\<Rightarrow> 'a signed list\"\n  where \"prappend_signed_list xs [] = xs\"\n      | \"prappend_signed_list [] ys = ys\"\n      | \"prappend_signed_list (xs@[x]) (y#ys) = (\n          if y = flip_signed x then prappend_signed_list xs ys else xs @ x # y # ys\n        )\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>xs. x = (xs, []) \\<Longrightarrow> P;\n        \\<And>ys. x = ([], ys) \\<Longrightarrow> P;\n        \\<And>xs xa y ys.\n           x = (xs @ [xa], y # ys) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>xs xsa. (xs, []) = (xsa, []) \\<Longrightarrow> xs = xsa\n 3. \\<And>xs ys. (xs, []) = ([], ys) \\<Longrightarrow> xs = ys\n 4. \\<And>xs xsa x y ys.\n       (xs, []) = (xsa @ [x], y # ys) \\<Longrightarrow>\n       xs =\n       (if y = flip_signed x then prappend_signed_list_sumC (xsa, ys)\n        else xsa @ x # y # ys)\n 5. \\<And>ys ysa. ([], ys) = ([], ysa) \\<Longrightarrow> ys = ysa\n 6. \\<And>ys xs x y ysa.\n       ([], ys) = (xs @ [x], y # ysa) \\<Longrightarrow>\n       ys =\n       (if y = flip_signed x then prappend_signed_list_sumC (xs, ysa)\n        else xs @ x # y # ysa)\n 7. \\<And>xs x y ys xsa xa ya ysa.\n       (xs @ [x], y # ys) = (xsa @ [xa], ya # ysa) \\<Longrightarrow>\n       (if y = flip_signed x then prappend_signed_list_sumC (xs, ys)\n        else xs @ x # y # ys) =\n       (if ya = flip_signed xa then prappend_signed_list_sumC (xsa, ysa)\n        else xsa @ xa # ya # ysa)", "by (auto) (rule two_prod_lists_cases_snoc_Cons)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All prappend_signed_list_dom", "by (relation \"measure (\\<lambda>(xs,ys). length xs + length ys)\") auto"], ["", "lemma proper_prappend_signed_list:\n  \"proper_signed_list xs \\<Longrightarrow> proper_signed_list ys\n    \\<Longrightarrow> proper_signed_list (prappend_signed_list xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs; proper_signed_list ys\\<rbrakk>\n    \\<Longrightarrow> proper_signed_list (prappend_signed_list xs ys)", "proof (induct xs ys rule: list_induct2_snoc_Cons)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>proper_signed_list []; proper_signed_list ys\\<rbrakk>\n       \\<Longrightarrow> proper_signed_list (prappend_signed_list [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list []\\<rbrakk>\n       \\<Longrightarrow> proper_signed_list (prappend_signed_list xs [])\n 3. \\<And>xs x y ys.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 proper_signed_list ys\\<rbrakk>\n                \\<Longrightarrow> proper_signed_list\n                                   (prappend_signed_list xs ys);\n        proper_signed_list (xs @ [x]); proper_signed_list (y # ys)\\<rbrakk>\n       \\<Longrightarrow> proper_signed_list\n                          (prappend_signed_list (xs @ [x]) (y # ys))", "case (snoc_Cons xs x y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>proper_signed_list xs; proper_signed_list ys\\<rbrakk>\n  \\<Longrightarrow> proper_signed_list (prappend_signed_list xs ys)\n  proper_signed_list (xs @ [x])\n  proper_signed_list (y # ys)\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>proper_signed_list []; proper_signed_list ys\\<rbrakk>\n       \\<Longrightarrow> proper_signed_list (prappend_signed_list [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list []\\<rbrakk>\n       \\<Longrightarrow> proper_signed_list (prappend_signed_list xs [])\n 3. \\<And>xs x y ys.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 proper_signed_list ys\\<rbrakk>\n                \\<Longrightarrow> proper_signed_list\n                                   (prappend_signed_list xs ys);\n        proper_signed_list (xs @ [x]); proper_signed_list (y # ys)\\<rbrakk>\n       \\<Longrightarrow> proper_signed_list\n                          (prappend_signed_list (xs @ [x]) (y # ys))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))", "proof (cases \"y = flip_signed x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = flip_signed x \\<Longrightarrow>\n    proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))\n 2. nflipped_signed x y \\<Longrightarrow>\n    proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))", "case True"], ["proof (state)\nthis:\n  y = flip_signed x\n\ngoal (2 subgoals):\n 1. y = flip_signed x \\<Longrightarrow>\n    proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))\n 2. nflipped_signed x y \\<Longrightarrow>\n    proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))", "with snoc_Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>proper_signed_list xs; proper_signed_list ys\\<rbrakk>\n  \\<Longrightarrow> proper_signed_list (prappend_signed_list xs ys)\n  proper_signed_list (xs @ [x])\n  proper_signed_list (y # ys)\n  y = flip_signed x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list xs; proper_signed_list ys\\<rbrakk>\n  \\<Longrightarrow> proper_signed_list (prappend_signed_list xs ys)\n  proper_signed_list (xs @ [x])\n  proper_signed_list (y # ys)\n  y = flip_signed x\n\ngoal (1 subgoal):\n 1. proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))", "using binrelchain_append_reduce1[of nflipped_signed]\n            binrelchain_Cons_reduce[of nflipped_signed y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list xs; proper_signed_list ys\\<rbrakk>\n  \\<Longrightarrow> proper_signed_list (prappend_signed_list xs ys)\n  proper_signed_list (xs @ [x])\n  proper_signed_list (y # ys)\n  y = flip_signed x\n  proper_signed_list (?xs @ ?ys) \\<Longrightarrow> proper_signed_list ?xs\n  proper_signed_list (y # ?xs) \\<Longrightarrow> proper_signed_list ?xs\n\ngoal (1 subgoal):\n 1. proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))", "by    auto"], ["proof (state)\nthis:\n  proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))\n\ngoal (1 subgoal):\n 1. nflipped_signed x y \\<Longrightarrow>\n    proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nflipped_signed x y \\<Longrightarrow>\n    proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))", "case False"], ["proof (state)\nthis:\n  nflipped_signed x y\n\ngoal (1 subgoal):\n 1. nflipped_signed x y \\<Longrightarrow>\n    proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))", "with snoc_Cons(2,3)"], ["proof (chain)\npicking this:\n  proper_signed_list (xs @ [x])\n  proper_signed_list (y # ys)\n  nflipped_signed x y", "show ?thesis"], ["proof (prove)\nusing this:\n  proper_signed_list (xs @ [x])\n  proper_signed_list (y # ys)\n  nflipped_signed x y\n\ngoal (1 subgoal):\n 1. proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))", "using binrelchain_join[of nflipped_signed]"], ["proof (prove)\nusing this:\n  proper_signed_list (xs @ [x])\n  proper_signed_list (y # ys)\n  nflipped_signed x y\n  \\<lbrakk>proper_signed_list (?xs @ [?x]); proper_signed_list (?y # ?ys);\n   nflipped_signed ?x ?y\\<rbrakk>\n  \\<Longrightarrow> proper_signed_list (?xs @ ?x # ?y # ?ys)\n\ngoal (1 subgoal):\n 1. proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))", "by simp"], ["proof (state)\nthis:\n  proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proper_signed_list (prappend_signed_list (xs @ [x]) (y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>proper_signed_list []; proper_signed_list ys\\<rbrakk>\n       \\<Longrightarrow> proper_signed_list (prappend_signed_list [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list []\\<rbrakk>\n       \\<Longrightarrow> proper_signed_list (prappend_signed_list xs [])", "qed auto"], ["", "lemma fully_prappend_signed_list:\n  \"prappend_signed_list (rev (map flip_signed xs)) xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prappend_signed_list (rev (map flip_signed xs)) xs = []", "by (induct xs) auto"], ["", "lemma prappend_signed_list_single_Cons:\n  \"prappend_signed_list [x] (y#ys) = (if y = flip_signed x then ys else x#y#ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prappend_signed_list [x] (y # ys) =\n    (if y = flip_signed x then ys else x # y # ys)", "using prappend_signed_list.simps(3)[of \"[]\" x]"], ["proof (prove)\nusing this:\n  prappend_signed_list ([] @ [x]) (?y # ?ys) =\n  (if ?y = flip_signed x then prappend_signed_list [] ?ys\n   else [] @ x # ?y # ?ys)\n\ngoal (1 subgoal):\n 1. prappend_signed_list [x] (y # ys) =\n    (if y = flip_signed x then ys else x # y # ys)", "by simp"], ["", "lemma prappend_signed_list_map_uniform_snd:\n  \"prappend_signed_list (map (\\<lambda>s. (s,b)) xs) (map (\\<lambda>s. (s,b)) ys) =\n    map (\\<lambda>s. (s,b)) xs @ map (\\<lambda>s. (s,b)) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prappend_signed_list (map (\\<lambda>s. (s, b)) xs)\n     (map (\\<lambda>s. (s, b)) ys) =\n    map (\\<lambda>s. (s, b)) xs @ map (\\<lambda>s. (s, b)) ys", "by (cases xs ys rule: two_lists_cases_snoc_Cons) auto"], ["", "lemma prappend_signed_list_assoc_conv_snoc2Cons:\n  assumes \"proper_signed_list (xs@[y])\" \"proper_signed_list (y#ys)\"\n  shows   \"prappend_signed_list (xs@[y]) ys = prappend_signed_list xs (y#ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prappend_signed_list (xs @ [y]) ys = prappend_signed_list xs (y # ys)", "proof (cases xs ys rule: two_lists_cases_snoc_Cons')"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>xs = []; ys = []\\<rbrakk>\n    \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                      prappend_signed_list xs (y # ys)\n 2. \\<And>ya ysa.\n       \\<lbrakk>xs = []; ys = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)\n 3. \\<And>xsa x.\n       \\<lbrakk>xs = xsa @ [x]; ys = []\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)\n 4. \\<And>xsa x ya ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)", "case Nil1"], ["proof (state)\nthis:\n  xs = []\n  ys = y_ # ys_\n\ngoal (4 subgoals):\n 1. \\<lbrakk>xs = []; ys = []\\<rbrakk>\n    \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                      prappend_signed_list xs (y # ys)\n 2. \\<And>ya ysa.\n       \\<lbrakk>xs = []; ys = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)\n 3. \\<And>xsa x.\n       \\<lbrakk>xs = xsa @ [x]; ys = []\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)\n 4. \\<And>xsa x ya ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)", "with assms(2)"], ["proof (chain)\npicking this:\n  proper_signed_list (y # ys)\n  xs = []\n  ys = y_ # ys_", "show ?thesis"], ["proof (prove)\nusing this:\n  proper_signed_list (y # ys)\n  xs = []\n  ys = y_ # ys_\n\ngoal (1 subgoal):\n 1. prappend_signed_list (xs @ [y]) ys = prappend_signed_list xs (y # ys)", "by (simp add: prappend_signed_list_single_Cons)"], ["proof (state)\nthis:\n  prappend_signed_list (xs @ [y]) ys = prappend_signed_list xs (y # ys)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>xs = []; ys = []\\<rbrakk>\n    \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                      prappend_signed_list xs (y # ys)\n 2. \\<And>xsa x.\n       \\<lbrakk>xs = xsa @ [x]; ys = []\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)\n 3. \\<And>xsa x ya ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>xs = []; ys = []\\<rbrakk>\n    \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                      prappend_signed_list xs (y # ys)\n 2. \\<And>xsa x.\n       \\<lbrakk>xs = xsa @ [x]; ys = []\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)\n 3. \\<And>xsa x ya ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)", "case Nil2"], ["proof (state)\nthis:\n  xs = xs_ @ [x_]\n  ys = []\n\ngoal (3 subgoals):\n 1. \\<lbrakk>xs = []; ys = []\\<rbrakk>\n    \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                      prappend_signed_list xs (y # ys)\n 2. \\<And>xsa x.\n       \\<lbrakk>xs = xsa @ [x]; ys = []\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)\n 3. \\<And>xsa x ya ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)", "with assms(1)"], ["proof (chain)\npicking this:\n  proper_signed_list (xs @ [y])\n  xs = xs_ @ [x_]\n  ys = []", "show ?thesis"], ["proof (prove)\nusing this:\n  proper_signed_list (xs @ [y])\n  xs = xs_ @ [x_]\n  ys = []\n\ngoal (1 subgoal):\n 1. prappend_signed_list (xs @ [y]) ys = prappend_signed_list xs (y # ys)", "using binrelchain_append_reduce2"], ["proof (prove)\nusing this:\n  proper_signed_list (xs @ [y])\n  xs = xs_ @ [x_]\n  ys = []\n  binrelchain ?P (?xs @ ?ys) \\<Longrightarrow> binrelchain ?P ?ys\n\ngoal (1 subgoal):\n 1. prappend_signed_list (xs @ [y]) ys = prappend_signed_list xs (y # ys)", "by force"], ["proof (state)\nthis:\n  prappend_signed_list (xs @ [y]) ys = prappend_signed_list xs (y # ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = []; ys = []\\<rbrakk>\n    \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                      prappend_signed_list xs (y # ys)\n 2. \\<And>xsa x ya ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = []; ys = []\\<rbrakk>\n    \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                      prappend_signed_list xs (y # ys)\n 2. \\<And>xsa x ya ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)", "case (snoc_Cons as a b bs)"], ["proof (state)\nthis:\n  xs = as @ [a]\n  ys = b # bs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = []; ys = []\\<rbrakk>\n    \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                      prappend_signed_list xs (y # ys)\n 2. \\<And>xsa x ya ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = ya # ysa\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                         prappend_signed_list xs (y # ys)", "with assms"], ["proof (chain)\npicking this:\n  proper_signed_list (xs @ [y])\n  proper_signed_list (y # ys)\n  xs = as @ [a]\n  ys = b # bs", "show ?thesis"], ["proof (prove)\nusing this:\n  proper_signed_list (xs @ [y])\n  proper_signed_list (y # ys)\n  xs = as @ [a]\n  ys = b # bs\n\ngoal (1 subgoal):\n 1. prappend_signed_list (xs @ [y]) ys = prappend_signed_list xs (y # ys)", "using prappend_signed_list.simps(3)[of \"as@[a]\"]\n          binrelchain_append_reduce2[of nflipped_signed as \"[a,y]\"]"], ["proof (prove)\nusing this:\n  proper_signed_list (xs @ [y])\n  proper_signed_list (y # ys)\n  xs = as @ [a]\n  ys = b # bs\n  prappend_signed_list ((as @ [a]) @ [?x]) (?y # ?ys) =\n  (if ?y = flip_signed ?x then prappend_signed_list (as @ [a]) ?ys\n   else (as @ [a]) @ ?x # ?y # ?ys)\n  proper_signed_list (as @ [a, y]) \\<Longrightarrow>\n  proper_signed_list [a, y]\n\ngoal (1 subgoal):\n 1. prappend_signed_list (xs @ [y]) ys = prappend_signed_list xs (y # ys)", "by    simp"], ["proof (state)\nthis:\n  prappend_signed_list (xs @ [y]) ys = prappend_signed_list xs (y # ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = []; ys = []\\<rbrakk>\n    \\<Longrightarrow> prappend_signed_list (xs @ [y]) ys =\n                      prappend_signed_list xs (y # ys)", "qed simp"], ["", "lemma prappend_signed_list_assoc:\n  \"\\<lbrakk> proper_signed_list xs; proper_signed_list ys; proper_signed_list zs \\<rbrakk> \\<Longrightarrow>\n    prappend_signed_list (prappend_signed_list xs ys) zs =\n      prappend_signed_list xs (prappend_signed_list ys zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n     proper_signed_list zs\\<rbrakk>\n    \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs ys) zs =\n                      prappend_signed_list xs (prappend_signed_list ys zs)", "proof (induct xs ys zs rule: list_induct3_snoc_Conssnoc_Cons_pairwise)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>proper_signed_list []; proper_signed_list ys;\n        proper_signed_list zs\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list [] ys)\n                          zs =\n                         prappend_signed_list []\n                          (prappend_signed_list ys zs)\n 2. \\<And>xs zs.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list [];\n        proper_signed_list zs\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs [])\n                          zs =\n                         prappend_signed_list xs\n                          (prappend_signed_list [] zs)\n 3. \\<And>xs ys.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n        proper_signed_list []\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs ys)\n                          [] =\n                         prappend_signed_list xs\n                          (prappend_signed_list ys [])\n 4. \\<And>xs x y z zs.\n       \\<lbrakk>proper_signed_list (xs @ [x]); proper_signed_list [y];\n        proper_signed_list (z # zs)\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list\n                          (prappend_signed_list (xs @ [x]) [y]) (z # zs) =\n                         prappend_signed_list (xs @ [x])\n                          (prappend_signed_list [y] (z # zs))\n 5. \\<And>xs x y ys w z zs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n                 proper_signed_list zs\\<rbrakk>\n                \\<Longrightarrow> prappend_signed_list\n                                   (prappend_signed_list xs ys) zs =\n                                  prappend_signed_list xs\n                                   (prappend_signed_list ys zs);\n        \\<lbrakk>proper_signed_list xs; proper_signed_list (ys @ [w]);\n         proper_signed_list (z # zs)\\<rbrakk>\n        \\<Longrightarrow> prappend_signed_list\n                           (prappend_signed_list xs (ys @ [w])) (z # zs) =\n                          prappend_signed_list xs\n                           (prappend_signed_list (ys @ [w]) (z # zs));\n        \\<lbrakk>proper_signed_list (xs @ [x]); proper_signed_list (y # ys);\n         proper_signed_list zs\\<rbrakk>\n        \\<Longrightarrow> prappend_signed_list\n                           (prappend_signed_list (xs @ [x]) (y # ys)) zs =\n                          prappend_signed_list (xs @ [x])\n                           (prappend_signed_list (y # ys) zs);\n        proper_signed_list (xs @ [x]); proper_signed_list (y # ys @ [w]);\n        proper_signed_list (z # zs)\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list\n                          (prappend_signed_list (xs @ [x]) (y # ys @ [w]))\n                          (z # zs) =\n                         prappend_signed_list (xs @ [x])\n                          (prappend_signed_list (y # ys @ [w]) (z # zs))", "case (snoc_single_Cons xs x y z zs)"], ["proof (state)\nthis:\n  proper_signed_list (xs @ [x])\n  proper_signed_list [y]\n  proper_signed_list (z # zs)\n\ngoal (5 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>proper_signed_list []; proper_signed_list ys;\n        proper_signed_list zs\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list [] ys)\n                          zs =\n                         prappend_signed_list []\n                          (prappend_signed_list ys zs)\n 2. \\<And>xs zs.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list [];\n        proper_signed_list zs\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs [])\n                          zs =\n                         prappend_signed_list xs\n                          (prappend_signed_list [] zs)\n 3. \\<And>xs ys.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n        proper_signed_list []\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs ys)\n                          [] =\n                         prappend_signed_list xs\n                          (prappend_signed_list ys [])\n 4. \\<And>xs x y z zs.\n       \\<lbrakk>proper_signed_list (xs @ [x]); proper_signed_list [y];\n        proper_signed_list (z # zs)\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list\n                          (prappend_signed_list (xs @ [x]) [y]) (z # zs) =\n                         prappend_signed_list (xs @ [x])\n                          (prappend_signed_list [y] (z # zs))\n 5. \\<And>xs x y ys w z zs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n                 proper_signed_list zs\\<rbrakk>\n                \\<Longrightarrow> prappend_signed_list\n                                   (prappend_signed_list xs ys) zs =\n                                  prappend_signed_list xs\n                                   (prappend_signed_list ys zs);\n        \\<lbrakk>proper_signed_list xs; proper_signed_list (ys @ [w]);\n         proper_signed_list (z # zs)\\<rbrakk>\n        \\<Longrightarrow> prappend_signed_list\n                           (prappend_signed_list xs (ys @ [w])) (z # zs) =\n                          prappend_signed_list xs\n                           (prappend_signed_list (ys @ [w]) (z # zs));\n        \\<lbrakk>proper_signed_list (xs @ [x]); proper_signed_list (y # ys);\n         proper_signed_list zs\\<rbrakk>\n        \\<Longrightarrow> prappend_signed_list\n                           (prappend_signed_list (xs @ [x]) (y # ys)) zs =\n                          prappend_signed_list (xs @ [x])\n                           (prappend_signed_list (y # ys) zs);\n        proper_signed_list (xs @ [x]); proper_signed_list (y # ys @ [w]);\n        proper_signed_list (z # zs)\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list\n                          (prappend_signed_list (xs @ [x]) (y # ys @ [w]))\n                          (z # zs) =\n                         prappend_signed_list (xs @ [x])\n                          (prappend_signed_list (y # ys @ [w]) (z # zs))", "thus ?case"], ["proof (prove)\nusing this:\n  proper_signed_list (xs @ [x])\n  proper_signed_list [y]\n  proper_signed_list (z # zs)\n\ngoal (1 subgoal):\n 1. prappend_signed_list (prappend_signed_list (xs @ [x]) [y]) (z # zs) =\n    prappend_signed_list (xs @ [x]) (prappend_signed_list [y] (z # zs))", "using prappend_signed_list.simps(3)[of \"[]\" y]\n          prappend_signed_list.simps(3)[of \"xs@[x]\"]"], ["proof (prove)\nusing this:\n  proper_signed_list (xs @ [x])\n  proper_signed_list [y]\n  proper_signed_list (z # zs)\n  prappend_signed_list ([] @ [y]) (?y # ?ys) =\n  (if ?y = flip_signed y then prappend_signed_list [] ?ys\n   else [] @ y # ?y # ?ys)\n  prappend_signed_list ((xs @ [x]) @ [?x]) (?y # ?ys) =\n  (if ?y = flip_signed ?x then prappend_signed_list (xs @ [x]) ?ys\n   else (xs @ [x]) @ ?x # ?y # ?ys)\n\ngoal (1 subgoal):\n 1. prappend_signed_list (prappend_signed_list (xs @ [x]) [y]) (z # zs) =\n    prappend_signed_list (xs @ [x]) (prappend_signed_list [y] (z # zs))", "by    (cases \"y = flip_signed x\" \"z = flip_signed y\" rule: two_cases)\n          (auto simp add:\n            flip_signed_order2 prappend_signed_list_assoc_conv_snoc2Cons\n          )"], ["proof (state)\nthis:\n  prappend_signed_list (prappend_signed_list (xs @ [x]) [y]) (z # zs) =\n  prappend_signed_list (xs @ [x]) (prappend_signed_list [y] (z # zs))\n\ngoal (4 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>proper_signed_list []; proper_signed_list ys;\n        proper_signed_list zs\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list [] ys)\n                          zs =\n                         prappend_signed_list []\n                          (prappend_signed_list ys zs)\n 2. \\<And>xs zs.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list [];\n        proper_signed_list zs\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs [])\n                          zs =\n                         prappend_signed_list xs\n                          (prappend_signed_list [] zs)\n 3. \\<And>xs ys.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n        proper_signed_list []\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs ys)\n                          [] =\n                         prappend_signed_list xs\n                          (prappend_signed_list ys [])\n 4. \\<And>xs x y ys w z zs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n                 proper_signed_list zs\\<rbrakk>\n                \\<Longrightarrow> prappend_signed_list\n                                   (prappend_signed_list xs ys) zs =\n                                  prappend_signed_list xs\n                                   (prappend_signed_list ys zs);\n        \\<lbrakk>proper_signed_list xs; proper_signed_list (ys @ [w]);\n         proper_signed_list (z # zs)\\<rbrakk>\n        \\<Longrightarrow> prappend_signed_list\n                           (prappend_signed_list xs (ys @ [w])) (z # zs) =\n                          prappend_signed_list xs\n                           (prappend_signed_list (ys @ [w]) (z # zs));\n        \\<lbrakk>proper_signed_list (xs @ [x]); proper_signed_list (y # ys);\n         proper_signed_list zs\\<rbrakk>\n        \\<Longrightarrow> prappend_signed_list\n                           (prappend_signed_list (xs @ [x]) (y # ys)) zs =\n                          prappend_signed_list (xs @ [x])\n                           (prappend_signed_list (y # ys) zs);\n        proper_signed_list (xs @ [x]); proper_signed_list (y # ys @ [w]);\n        proper_signed_list (z # zs)\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list\n                          (prappend_signed_list (xs @ [x]) (y # ys @ [w]))\n                          (z # zs) =\n                         prappend_signed_list (xs @ [x])\n                          (prappend_signed_list (y # ys @ [w]) (z # zs))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>proper_signed_list []; proper_signed_list ys;\n        proper_signed_list zs\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list [] ys)\n                          zs =\n                         prappend_signed_list []\n                          (prappend_signed_list ys zs)\n 2. \\<And>xs zs.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list [];\n        proper_signed_list zs\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs [])\n                          zs =\n                         prappend_signed_list xs\n                          (prappend_signed_list [] zs)\n 3. \\<And>xs ys.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n        proper_signed_list []\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs ys)\n                          [] =\n                         prappend_signed_list xs\n                          (prappend_signed_list ys [])\n 4. \\<And>xs x y ys w z zs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n                 proper_signed_list zs\\<rbrakk>\n                \\<Longrightarrow> prappend_signed_list\n                                   (prappend_signed_list xs ys) zs =\n                                  prappend_signed_list xs\n                                   (prappend_signed_list ys zs);\n        \\<lbrakk>proper_signed_list xs; proper_signed_list (ys @ [w]);\n         proper_signed_list (z # zs)\\<rbrakk>\n        \\<Longrightarrow> prappend_signed_list\n                           (prappend_signed_list xs (ys @ [w])) (z # zs) =\n                          prappend_signed_list xs\n                           (prappend_signed_list (ys @ [w]) (z # zs));\n        \\<lbrakk>proper_signed_list (xs @ [x]); proper_signed_list (y # ys);\n         proper_signed_list zs\\<rbrakk>\n        \\<Longrightarrow> prappend_signed_list\n                           (prappend_signed_list (xs @ [x]) (y # ys)) zs =\n                          prappend_signed_list (xs @ [x])\n                           (prappend_signed_list (y # ys) zs);\n        proper_signed_list (xs @ [x]); proper_signed_list (y # ys @ [w]);\n        proper_signed_list (z # zs)\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list\n                          (prappend_signed_list (xs @ [x]) (y # ys @ [w]))\n                          (z # zs) =\n                         prappend_signed_list (xs @ [x])\n                          (prappend_signed_list (y # ys @ [w]) (z # zs))", "case (snoc_Conssnoc_Cons xs x y ys w z zs)"], ["proof (state)\nthis:\n  \\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n   proper_signed_list zs\\<rbrakk>\n  \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs ys) zs =\n                    prappend_signed_list xs (prappend_signed_list ys zs)\n  \\<lbrakk>proper_signed_list xs; proper_signed_list (ys @ [w]);\n   proper_signed_list (z # zs)\\<rbrakk>\n  \\<Longrightarrow> prappend_signed_list\n                     (prappend_signed_list xs (ys @ [w])) (z # zs) =\n                    prappend_signed_list xs\n                     (prappend_signed_list (ys @ [w]) (z # zs))\n  \\<lbrakk>proper_signed_list (xs @ [x]); proper_signed_list (y # ys);\n   proper_signed_list zs\\<rbrakk>\n  \\<Longrightarrow> prappend_signed_list\n                     (prappend_signed_list (xs @ [x]) (y # ys)) zs =\n                    prappend_signed_list (xs @ [x])\n                     (prappend_signed_list (y # ys) zs)\n  proper_signed_list (xs @ [x])\n  proper_signed_list (y # ys @ [w])\n  proper_signed_list (z # zs)\n\ngoal (4 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>proper_signed_list []; proper_signed_list ys;\n        proper_signed_list zs\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list [] ys)\n                          zs =\n                         prappend_signed_list []\n                          (prappend_signed_list ys zs)\n 2. \\<And>xs zs.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list [];\n        proper_signed_list zs\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs [])\n                          zs =\n                         prappend_signed_list xs\n                          (prappend_signed_list [] zs)\n 3. \\<And>xs ys.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n        proper_signed_list []\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs ys)\n                          [] =\n                         prappend_signed_list xs\n                          (prappend_signed_list ys [])\n 4. \\<And>xs x y ys w z zs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n                 proper_signed_list zs\\<rbrakk>\n                \\<Longrightarrow> prappend_signed_list\n                                   (prappend_signed_list xs ys) zs =\n                                  prappend_signed_list xs\n                                   (prappend_signed_list ys zs);\n        \\<lbrakk>proper_signed_list xs; proper_signed_list (ys @ [w]);\n         proper_signed_list (z # zs)\\<rbrakk>\n        \\<Longrightarrow> prappend_signed_list\n                           (prappend_signed_list xs (ys @ [w])) (z # zs) =\n                          prappend_signed_list xs\n                           (prappend_signed_list (ys @ [w]) (z # zs));\n        \\<lbrakk>proper_signed_list (xs @ [x]); proper_signed_list (y # ys);\n         proper_signed_list zs\\<rbrakk>\n        \\<Longrightarrow> prappend_signed_list\n                           (prappend_signed_list (xs @ [x]) (y # ys)) zs =\n                          prappend_signed_list (xs @ [x])\n                           (prappend_signed_list (y # ys) zs);\n        proper_signed_list (xs @ [x]); proper_signed_list (y # ys @ [w]);\n        proper_signed_list (z # zs)\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list\n                          (prappend_signed_list (xs @ [x]) (y # ys @ [w]))\n                          (z # zs) =\n                         prappend_signed_list (xs @ [x])\n                          (prappend_signed_list (y # ys @ [w]) (z # zs))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n   proper_signed_list zs\\<rbrakk>\n  \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs ys) zs =\n                    prappend_signed_list xs (prappend_signed_list ys zs)\n  \\<lbrakk>proper_signed_list xs; proper_signed_list (ys @ [w]);\n   proper_signed_list (z # zs)\\<rbrakk>\n  \\<Longrightarrow> prappend_signed_list\n                     (prappend_signed_list xs (ys @ [w])) (z # zs) =\n                    prappend_signed_list xs\n                     (prappend_signed_list (ys @ [w]) (z # zs))\n  \\<lbrakk>proper_signed_list (xs @ [x]); proper_signed_list (y # ys);\n   proper_signed_list zs\\<rbrakk>\n  \\<Longrightarrow> prappend_signed_list\n                     (prappend_signed_list (xs @ [x]) (y # ys)) zs =\n                    prappend_signed_list (xs @ [x])\n                     (prappend_signed_list (y # ys) zs)\n  proper_signed_list (xs @ [x])\n  proper_signed_list (y # ys @ [w])\n  proper_signed_list (z # zs)\n\ngoal (1 subgoal):\n 1. prappend_signed_list (prappend_signed_list (xs @ [x]) (y # ys @ [w]))\n     (z # zs) =\n    prappend_signed_list (xs @ [x])\n     (prappend_signed_list (y # ys @ [w]) (z # zs))", "using binrelchain_Cons_reduce[of nflipped_signed y \"ys@[w]\"]\n          binrelchain_Cons_reduce[of nflipped_signed z zs]\n          binrelchain_append_reduce1[of nflipped_signed xs]\n          binrelchain_append_reduce1[of nflipped_signed \"y#ys\"]\n          binrelchain_Conssnoc_reduce[of nflipped_signed y ys]\n          prappend_signed_list.simps(3)[of \"y#ys\"]\n          prappend_signed_list.simps(3)[of \"xs@x#y#ys\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n   proper_signed_list zs\\<rbrakk>\n  \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs ys) zs =\n                    prappend_signed_list xs (prappend_signed_list ys zs)\n  \\<lbrakk>proper_signed_list xs; proper_signed_list (ys @ [w]);\n   proper_signed_list (z # zs)\\<rbrakk>\n  \\<Longrightarrow> prappend_signed_list\n                     (prappend_signed_list xs (ys @ [w])) (z # zs) =\n                    prappend_signed_list xs\n                     (prappend_signed_list (ys @ [w]) (z # zs))\n  \\<lbrakk>proper_signed_list (xs @ [x]); proper_signed_list (y # ys);\n   proper_signed_list zs\\<rbrakk>\n  \\<Longrightarrow> prappend_signed_list\n                     (prappend_signed_list (xs @ [x]) (y # ys)) zs =\n                    prappend_signed_list (xs @ [x])\n                     (prappend_signed_list (y # ys) zs)\n  proper_signed_list (xs @ [x])\n  proper_signed_list (y # ys @ [w])\n  proper_signed_list (z # zs)\n  proper_signed_list (y # ys @ [w]) \\<Longrightarrow>\n  proper_signed_list (ys @ [w])\n  proper_signed_list (z # zs) \\<Longrightarrow> proper_signed_list zs\n  proper_signed_list (xs @ ?ys) \\<Longrightarrow> proper_signed_list xs\n  proper_signed_list ((y # ys) @ ?ys) \\<Longrightarrow>\n  proper_signed_list (y # ys)\n  proper_signed_list (y # ys @ [?y]) \\<Longrightarrow> proper_signed_list ys\n  prappend_signed_list ((y # ys) @ [?x]) (?y # ?ys) =\n  (if ?y = flip_signed ?x then prappend_signed_list (y # ys) ?ys\n   else (y # ys) @ ?x # ?y # ?ys)\n  prappend_signed_list ((xs @ x # y # ys) @ [?x]) (?y # ?ys) =\n  (if ?y = flip_signed ?x then prappend_signed_list (xs @ x # y # ys) ?ys\n   else (xs @ x # y # ys) @ ?x # ?y # ?ys)\n\ngoal (1 subgoal):\n 1. prappend_signed_list (prappend_signed_list (xs @ [x]) (y # ys @ [w]))\n     (z # zs) =\n    prappend_signed_list (xs @ [x])\n     (prappend_signed_list (y # ys @ [w]) (z # zs))", "by    (cases \"y = flip_signed x\" \"z = flip_signed w\" rule: two_cases) auto"], ["proof (state)\nthis:\n  prappend_signed_list (prappend_signed_list (xs @ [x]) (y # ys @ [w]))\n   (z # zs) =\n  prappend_signed_list (xs @ [x])\n   (prappend_signed_list (y # ys @ [w]) (z # zs))\n\ngoal (3 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>proper_signed_list []; proper_signed_list ys;\n        proper_signed_list zs\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list [] ys)\n                          zs =\n                         prappend_signed_list []\n                          (prappend_signed_list ys zs)\n 2. \\<And>xs zs.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list [];\n        proper_signed_list zs\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs [])\n                          zs =\n                         prappend_signed_list xs\n                          (prappend_signed_list [] zs)\n 3. \\<And>xs ys.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list ys;\n        proper_signed_list []\\<rbrakk>\n       \\<Longrightarrow> prappend_signed_list (prappend_signed_list xs ys)\n                          [] =\n                         prappend_signed_list xs\n                          (prappend_signed_list ys [])", "qed auto"], ["", "lemma fst_set_prappend_signed_list:\n  \"fst ` set (prappend_signed_list xs ys) \\<subseteq> fst ` (set xs \\<union> set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (fst ` (set xs \\<union> set ys))\n     (fst ` set (prappend_signed_list xs ys))", "by (induct xs ys rule: list_induct2_snoc_Cons) auto"], ["", "lemma collapse_flipped_signed:\n  \"prappend_signed_list [(s,b)] [(s,\\<not>b)] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prappend_signed_list [(s, b)] [(s, \\<not> b)] = []", "using prappend_signed_list.simps(3)[of \"[]\" \"(s,b)\"]"], ["proof (prove)\nusing this:\n  prappend_signed_list ([] @ [(s, b)]) (?y # ?ys) =\n  (if ?y = flip_signed (s, b) then prappend_signed_list [] ?ys\n   else [] @ (s, b) # ?y # ?ys)\n\ngoal (1 subgoal):\n 1. prappend_signed_list [(s, b)] [(s, \\<not> b)] = []", "by simp"], ["", "subsubsection \\<open>The collection of proper signed lists as a type\\<close>"], ["", "text \\<open>\n  Here we create a type out of the collection of proper signed lists. This type will be of class\n  @{class group_add}, with the empty list as zero, the modified append operation\n  @{const prappend_signed_list} as addition, and inversion performed by flipping the signs of the\n  elements in the list and then reversing the order.\n\\<close>"], ["", "paragraph \\<open>Type definition, instantiations, and instances\\<close>"], ["", "text \\<open>Here we define the type and instantiate it with respect to various type classes.\\<close>"], ["", "typedef 'a freeword = \"{as::'a signed list. proper_signed_list as}\"\n  morphisms freeword Abs_freeword"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {as. proper_signed_list as}", "using binrelchain.simps(1)"], ["proof (prove)\nusing this:\n  binrelchain ?P [] = True\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {as. proper_signed_list as}", "by fast"], ["", "text \\<open>\n  These two functions act as the natural injections of letters and words in the letter type into\n  the @{type freeword} type.\n\\<close>"], ["", "abbreviation Abs_freeletter :: \"'a \\<Rightarrow> 'a freeword\"\n  where \"Abs_freeletter s \\<equiv> Abs_freeword [pairtrue s]\""], ["", "abbreviation Abs_freelist :: \"'a list \\<Rightarrow> 'a freeword\"\n  where \"Abs_freelist as \\<equiv> Abs_freeword (map pairtrue as)\""], ["", "abbreviation Abs_freelistfst :: \"'a signed list \\<Rightarrow> 'a freeword\"\n  where \"Abs_freelistfst xs \\<equiv> Abs_freelist (map fst xs)\""], ["", "setup_lifting type_definition_freeword"], ["", "instantiation freeword :: (type) zero\nbegin"], ["", "lift_definition zero_freeword :: \"'a freeword\" is \"[]::'a signed list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_signed_list []", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a freeword, zero_class)", ".."], ["", "end"], ["", "instantiation freeword :: (type) plus\nbegin"], ["", "lift_definition plus_freeword :: \"'a freeword \\<Rightarrow> 'a freeword \\<Rightarrow> 'a freeword\"\n  is    \"prappend_signed_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>proper_signed_list list1; proper_signed_list list2\\<rbrakk>\n       \\<Longrightarrow> proper_signed_list\n                          (prappend_signed_list list1 list2)", "using proper_prappend_signed_list"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list ?xs; proper_signed_list ?ys\\<rbrakk>\n  \\<Longrightarrow> proper_signed_list (prappend_signed_list ?xs ?ys)\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>proper_signed_list list1; proper_signed_list list2\\<rbrakk>\n       \\<Longrightarrow> proper_signed_list\n                          (prappend_signed_list list1 list2)", "by    fast"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a freeword, plus_class)", ".."], ["", "end"], ["", "instantiation freeword :: (type) uminus\nbegin"], ["", "lift_definition uminus_freeword :: \"'a freeword \\<Rightarrow> 'a freeword\"\n  is \"\\<lambda>xs. rev (map flip_signed xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       proper_signed_list list \\<Longrightarrow>\n       proper_signed_list (rev (map flip_signed list))", "by (rule proper_rev_map_flip_signed)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a freeword, uminus_class)", ".."], ["", "end"], ["", "instantiation freeword :: (type) minus\nbegin"], ["", "lift_definition minus_freeword :: \"'a freeword \\<Rightarrow> 'a freeword \\<Rightarrow> 'a freeword\"\n  is \"\\<lambda>xs ys. prappend_signed_list xs (rev (map flip_signed ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>proper_signed_list list1; proper_signed_list list2\\<rbrakk>\n       \\<Longrightarrow> proper_signed_list\n                          (prappend_signed_list list1\n                            (rev (map flip_signed list2)))", "using proper_rev_map_flip_signed proper_prappend_signed_list"], ["proof (prove)\nusing this:\n  proper_signed_list ?xs \\<Longrightarrow>\n  proper_signed_list (rev (map flip_signed ?xs))\n  \\<lbrakk>proper_signed_list ?xs; proper_signed_list ?ys\\<rbrakk>\n  \\<Longrightarrow> proper_signed_list (prappend_signed_list ?xs ?ys)\n\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       \\<lbrakk>proper_signed_list list1; proper_signed_list list2\\<rbrakk>\n       \\<Longrightarrow> proper_signed_list\n                          (prappend_signed_list list1\n                            (rev (map flip_signed list2)))", "by fast"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a freeword, minus_class)", ".."], ["", "end"], ["", "instance freeword :: (type) semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a freeword, semigroup_add_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c. a + b + c = a + (b + c)", "fix a b c :: \"'a freeword\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c. a + b + c = a + (b + c)", "show \"a + b + c = a + (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "using prappend_signed_list_assoc[of \"freeword a\" \"freeword b\" \"freeword c\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list (freeword a); proper_signed_list (freeword b);\n   proper_signed_list (freeword c)\\<rbrakk>\n  \\<Longrightarrow> prappend_signed_list\n                     (prappend_signed_list (freeword a) (freeword b))\n                     (freeword c) =\n                    prappend_signed_list (freeword a)\n                     (prappend_signed_list (freeword b) (freeword c))\n\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "by    transfer simp"], ["proof (state)\nthis:\n  a + b + c = a + (b + c)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance freeword :: (type) monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a freeword, monoid_add_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. 0 + a = a\n 2. \\<And>a. a + 0 = a", "fix a b c :: \"'a freeword\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. 0 + a = a\n 2. \\<And>a. a + 0 = a", "show \"0 + a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + a = a", "by transfer simp"], ["proof (state)\nthis:\n  0 + a = a\n\ngoal (1 subgoal):\n 1. \\<And>a. a + 0 = a", "show \"a + 0 = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + 0 = a", "by transfer simp"], ["proof (state)\nthis:\n  a + 0 = a\n\ngoal:\nNo subgoals!", "qed"], ["", "instance freeword :: (type) group_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a freeword, group_add_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. - a + a = 0\n 2. \\<And>a b. a + - b = a - b", "fix a b :: \"'a freeword\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. - a + a = 0\n 2. \\<And>a b. a + - b = a - b", "show \"- a + a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a + a = 0", "using fully_prappend_signed_list[of \"freeword a\"]"], ["proof (prove)\nusing this:\n  prappend_signed_list (rev (map flip_signed (freeword a))) (freeword a) =\n  []\n\ngoal (1 subgoal):\n 1. - a + a = 0", "by transfer simp"], ["proof (state)\nthis:\n  - a + a = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b. a + - b = a - b", "show \"a + - b = a - b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + - b = a - b", "by transfer simp"], ["proof (state)\nthis:\n  a + - b = a - b\n\ngoal:\nNo subgoals!", "qed"], ["", "paragraph \\<open>Basic algebra and transfer facts in the @{type freeword} type\\<close>"], ["", "text \\<open>\n  Here we record basic algebraic manipulations for the @{type freeword} type as well as various\n  transfer facts for dealing with representations of elements of @{type freeword} type as lists of\n  signed letters.\n\\<close>"], ["", "abbreviation Abs_freeletter_add :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a freeword\" (infixl \"[+]\" 65)\n  where \"s [+] t \\<equiv> Abs_freeletter s + Abs_freeletter t\""], ["", "lemma Abs_freeword_Cons:\n  assumes \"proper_signed_list (x#xs)\"\n  shows \"Abs_freeword (x#xs) = Abs_freeword [x] + Abs_freeword xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs", "using add_0_right[of \"Abs_freeword [x]\"]"], ["proof (prove)\nusing this:\n  xs = []\n  Abs_freeword [x] + 0 = Abs_freeword [x]\n\ngoal (1 subgoal):\n 1. Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs", "by (simp add: zero_freeword.abs_eq)"], ["proof (state)\nthis:\n  Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs", "case (Cons y ys)"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs", "with assms"], ["proof (chain)\npicking this:\n  proper_signed_list (x # xs)\n  xs = y # ys", "have  \"freeword (Abs_freeword (x#xs)) =\n            freeword (Abs_freeword [x] + Abs_freeword xs)\""], ["proof (prove)\nusing this:\n  proper_signed_list (x # xs)\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. freeword (Abs_freeword (x # xs)) =\n    freeword (Abs_freeword [x] + Abs_freeword xs)", "by    (simp add:\n            plus_freeword.rep_eq Abs_freeword_inverse\n            prappend_signed_list_single_Cons\n          )"], ["proof (state)\nthis:\n  freeword (Abs_freeword (x # xs)) =\n  freeword (Abs_freeword [x] + Abs_freeword xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  freeword (Abs_freeword (x # xs)) =\n  freeword (Abs_freeword [x] + Abs_freeword xs)\n\ngoal (1 subgoal):\n 1. Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs", "using freeword_inject"], ["proof (prove)\nusing this:\n  freeword (Abs_freeword (x # xs)) =\n  freeword (Abs_freeword [x] + Abs_freeword xs)\n  (freeword ?x = freeword ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs", "by fast"], ["proof (state)\nthis:\n  Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Abs_freelist_Cons: \"Abs_freelist (x#xs) = Abs_freeletter x + Abs_freelist xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_freelist (x # xs) = Abs_freeletter x + Abs_freelist xs", "using proper_signed_list_map_uniform_snd[of True \"x#xs\"] Abs_freeword_Cons"], ["proof (prove)\nusing this:\n  proper_signed_list (map pairtrue (x # xs))\n  proper_signed_list (?x # ?xs) \\<Longrightarrow>\n  Abs_freeword (?x # ?xs) = Abs_freeword [?x] + Abs_freeword ?xs\n\ngoal (1 subgoal):\n 1. Abs_freelist (x # xs) = Abs_freeletter x + Abs_freelist xs", "by    simp"], ["", "lemma plus_freeword_abs_eq:\n  \"proper_signed_list xs \\<Longrightarrow> proper_signed_list ys \\<Longrightarrow>\n    Abs_freeword xs + Abs_freeword ys = Abs_freeword (prappend_signed_list xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs; proper_signed_list ys\\<rbrakk>\n    \\<Longrightarrow> Abs_freeword xs + Abs_freeword ys =\n                      Abs_freeword (prappend_signed_list xs ys)", "using plus_freeword.abs_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>eq_onp proper_signed_list ?xa ?xa;\n   eq_onp proper_signed_list ?x ?x\\<rbrakk>\n  \\<Longrightarrow> Abs_freeword ?xa + Abs_freeword ?x =\n                    Abs_freeword (prappend_signed_list ?xa ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs; proper_signed_list ys\\<rbrakk>\n    \\<Longrightarrow> Abs_freeword xs + Abs_freeword ys =\n                      Abs_freeword (prappend_signed_list xs ys)", "unfolding eq_onp_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list ?xa \\<and> ?xa = ?xa;\n   proper_signed_list ?x \\<and> ?x = ?x\\<rbrakk>\n  \\<Longrightarrow> Abs_freeword ?xa + Abs_freeword ?x =\n                    Abs_freeword (prappend_signed_list ?xa ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs; proper_signed_list ys\\<rbrakk>\n    \\<Longrightarrow> Abs_freeword xs + Abs_freeword ys =\n                      Abs_freeword (prappend_signed_list xs ys)", "by simp"], ["", "lemma Abs_freeletter_add: \"s [+] t = Abs_freelist [s,t]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s [+] t = Abs_freelist [s, t]", "using Abs_freelist_Cons[of s \"[t]\"]"], ["proof (prove)\nusing this:\n  Abs_freelist [s, t] = Abs_freeletter s + Abs_freelist [t]\n\ngoal (1 subgoal):\n 1. s [+] t = Abs_freelist [s, t]", "by simp"], ["", "lemma uminus_freeword_Abs_eq:\n  \"proper_signed_list xs \\<Longrightarrow>\n    - Abs_freeword xs = Abs_freeword (rev (map flip_signed xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_signed_list xs \\<Longrightarrow>\n    - Abs_freeword xs = Abs_freeword (rev (map flip_signed xs))", "using uminus_freeword.abs_eq"], ["proof (prove)\nusing this:\n  eq_onp proper_signed_list ?x ?x \\<Longrightarrow>\n  - Abs_freeword ?x = Abs_freeword (rev (map flip_signed ?x))\n\ngoal (1 subgoal):\n 1. proper_signed_list xs \\<Longrightarrow>\n    - Abs_freeword xs = Abs_freeword (rev (map flip_signed xs))", "unfolding eq_onp_def"], ["proof (prove)\nusing this:\n  proper_signed_list ?x \\<and> ?x = ?x \\<Longrightarrow>\n  - Abs_freeword ?x = Abs_freeword (rev (map flip_signed ?x))\n\ngoal (1 subgoal):\n 1. proper_signed_list xs \\<Longrightarrow>\n    - Abs_freeword xs = Abs_freeword (rev (map flip_signed xs))", "by simp"], ["", "lemma uminus_Abs_freeword_singleton:\n  \"- Abs_freeword [(s,b)] = Abs_freeword [(s,\\<not> b)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - Abs_freeword [(s, b)] = Abs_freeword [(s, \\<not> b)]", "using uminus_freeword_Abs_eq[of \"[(s,b)]\"]"], ["proof (prove)\nusing this:\n  proper_signed_list [(s, b)] \\<Longrightarrow>\n  - Abs_freeword [(s, b)] = Abs_freeword (rev (map flip_signed [(s, b)]))\n\ngoal (1 subgoal):\n 1. - Abs_freeword [(s, b)] = Abs_freeword [(s, \\<not> b)]", "by simp"], ["", "lemma Abs_freeword_append_uniform_snd:\n  \"Abs_freeword (map (\\<lambda>s. (s,b)) (xs@ys)) =\n    Abs_freeword (map (\\<lambda>s. (s,b)) xs) + Abs_freeword (map (\\<lambda>s. (s,b)) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_freeword (map (\\<lambda>s. (s, b)) (xs @ ys)) =\n    Abs_freeword (map (\\<lambda>s. (s, b)) xs) +\n    Abs_freeword (map (\\<lambda>s. (s, b)) ys)", "using proper_signed_list_map_uniform_snd[of b xs]\n        proper_signed_list_map_uniform_snd[of b ys]\n        plus_freeword_abs_eq prappend_signed_list_map_uniform_snd[of b xs ys]"], ["proof (prove)\nusing this:\n  proper_signed_list (map (\\<lambda>s. (s, b)) xs)\n  proper_signed_list (map (\\<lambda>s. (s, b)) ys)\n  \\<lbrakk>proper_signed_list ?xs; proper_signed_list ?ys\\<rbrakk>\n  \\<Longrightarrow> Abs_freeword ?xs + Abs_freeword ?ys =\n                    Abs_freeword (prappend_signed_list ?xs ?ys)\n  prappend_signed_list (map (\\<lambda>s. (s, b)) xs)\n   (map (\\<lambda>s. (s, b)) ys) =\n  map (\\<lambda>s. (s, b)) xs @ map (\\<lambda>s. (s, b)) ys\n\ngoal (1 subgoal):\n 1. Abs_freeword (map (\\<lambda>s. (s, b)) (xs @ ys)) =\n    Abs_freeword (map (\\<lambda>s. (s, b)) xs) +\n    Abs_freeword (map (\\<lambda>s. (s, b)) ys)", "by    force"], ["", "lemmas Abs_freelist_append = Abs_freeword_append_uniform_snd[of True]"], ["", "lemma Abs_freelist_append_append:\n  \"Abs_freelist (xs@ys@zs) = Abs_freelist xs + Abs_freelist ys + Abs_freelist zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_freelist (xs @ ys @ zs) =\n    Abs_freelist xs + Abs_freelist ys + Abs_freelist zs", "using Abs_freelist_append[of \"xs@ys\"] Abs_freelist_append"], ["proof (prove)\nusing this:\n  Abs_freelist ((xs @ ys) @ ?ys) = Abs_freelist (xs @ ys) + Abs_freelist ?ys\n  Abs_freelist (?xs @ ?ys) = Abs_freelist ?xs + Abs_freelist ?ys\n\ngoal (1 subgoal):\n 1. Abs_freelist (xs @ ys @ zs) =\n    Abs_freelist xs + Abs_freelist ys + Abs_freelist zs", "by simp"], ["", "lemma Abs_freelist_inverse: \"freeword (Abs_freelist as) = map pairtrue as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeword (Abs_freelist as) = map pairtrue as", "using proper_signed_list_map_uniform_snd Abs_freeword_inverse"], ["proof (prove)\nusing this:\n  proper_signed_list (map (\\<lambda>s. (s, ?b)) ?as)\n  ?y \\<in> {as. proper_signed_list as} \\<Longrightarrow>\n  freeword (Abs_freeword ?y) = ?y\n\ngoal (1 subgoal):\n 1. freeword (Abs_freelist as) = map pairtrue as", "by fast"], ["", "lemma Abs_freeword_singleton_conv_apply_sign_freeletter:\n  \"Abs_freeword [x] = apply_sign Abs_freeletter x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_freeword [x] = apply_sign Abs_freeletter x", "by (cases x) (auto simp add: uminus_Abs_freeword_singleton)"], ["", "lemma Abs_freeword_conv_freeletter_sum_list:\n  \"proper_signed_list xs \\<Longrightarrow>\n    Abs_freeword xs = (\\<Sum>x\\<leftarrow>xs. apply_sign Abs_freeletter x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_signed_list xs \\<Longrightarrow>\n    Abs_freeword xs = sum_list (map (apply_sign Abs_freeletter) xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. proper_signed_list [] \\<Longrightarrow>\n    Abs_freeword [] = sum_list (map (apply_sign Abs_freeletter) [])\n 2. \\<And>a xs.\n       \\<lbrakk>proper_signed_list xs \\<Longrightarrow>\n                Abs_freeword xs =\n                sum_list (map (apply_sign Abs_freeletter) xs);\n        proper_signed_list (a # xs)\\<rbrakk>\n       \\<Longrightarrow> Abs_freeword (a # xs) =\n                         sum_list (map (apply_sign Abs_freeletter) (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  proper_signed_list xs \\<Longrightarrow>\n  Abs_freeword xs = sum_list (map (apply_sign Abs_freeletter) xs)\n  proper_signed_list (x # xs)\n\ngoal (2 subgoals):\n 1. proper_signed_list [] \\<Longrightarrow>\n    Abs_freeword [] = sum_list (map (apply_sign Abs_freeletter) [])\n 2. \\<And>a xs.\n       \\<lbrakk>proper_signed_list xs \\<Longrightarrow>\n                Abs_freeword xs =\n                sum_list (map (apply_sign Abs_freeletter) xs);\n        proper_signed_list (a # xs)\\<rbrakk>\n       \\<Longrightarrow> Abs_freeword (a # xs) =\n                         sum_list (map (apply_sign Abs_freeletter) (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  proper_signed_list xs \\<Longrightarrow>\n  Abs_freeword xs = sum_list (map (apply_sign Abs_freeletter) xs)\n  proper_signed_list (x # xs)\n\ngoal (1 subgoal):\n 1. Abs_freeword (x # xs) =\n    sum_list (map (apply_sign Abs_freeletter) (x # xs))", "using Abs_freeword_Cons[of x] binrelchain_Cons_reduce[of _ x]"], ["proof (prove)\nusing this:\n  proper_signed_list xs \\<Longrightarrow>\n  Abs_freeword xs = sum_list (map (apply_sign Abs_freeletter) xs)\n  proper_signed_list (x # xs)\n  proper_signed_list (x # ?xs) \\<Longrightarrow>\n  Abs_freeword (x # ?xs) = Abs_freeword [x] + Abs_freeword ?xs\n  binrelchain ?P (x # ?xs) \\<Longrightarrow> binrelchain ?P ?xs\n\ngoal (1 subgoal):\n 1. Abs_freeword (x # xs) =\n    sum_list (map (apply_sign Abs_freeletter) (x # xs))", "by (simp add: Abs_freeword_singleton_conv_apply_sign_freeletter)"], ["proof (state)\nthis:\n  Abs_freeword (x # xs) =\n  sum_list (map (apply_sign Abs_freeletter) (x # xs))\n\ngoal (1 subgoal):\n 1. proper_signed_list [] \\<Longrightarrow>\n    Abs_freeword [] = sum_list (map (apply_sign Abs_freeletter) [])", "qed (simp add: zero_freeword.abs_eq)"], ["", "lemma freeword_conv_freeletter_sum_list:\n  \"x = (\\<Sum>s\\<leftarrow>freeword x. apply_sign Abs_freeletter s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = sum_list (map (apply_sign Abs_freeletter) (freeword x))", "using Abs_freeword_conv_freeletter_sum_list[of \"freeword x\"] freeword"], ["proof (prove)\nusing this:\n  proper_signed_list (freeword x) \\<Longrightarrow>\n  Abs_freeword (freeword x) =\n  sum_list (map (apply_sign Abs_freeletter) (freeword x))\n  freeword ?x \\<in> {as. proper_signed_list as}\n\ngoal (1 subgoal):\n 1. x = sum_list (map (apply_sign Abs_freeletter) (freeword x))", "by    (auto simp add: freeword_inverse)"], ["", "lemma Abs_freeletter_prod_conv_Abs_freeword:\n  \"snd x \\<Longrightarrow> Abs_freeletter (fst x) = Abs_freeword [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd x \\<Longrightarrow> Abs_freeletter (fst x) = Abs_freeword [x]", "using prod_eqI[of x \"pairtrue (fst x)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>fst x = fst (pairtrue (fst x));\n   snd x = snd (pairtrue (fst x))\\<rbrakk>\n  \\<Longrightarrow> x = pairtrue (fst x)\n\ngoal (1 subgoal):\n 1. snd x \\<Longrightarrow> Abs_freeletter (fst x) = Abs_freeword [x]", "by simp"], ["", "subsubsection \\<open>Lifts of functions on the letter type\\<close>"], ["", "text \\<open>\n  Here we lift functions on the letter type to type @{type freeword}. In particular, we are\n  interested in the case where the function being lifted has codomain of class @{class group_add}.\n\\<close>"], ["", "paragraph \\<open>The universal property\\<close>"], ["", "text \\<open>\n  The universal property for free groups says that every function from the letter type to some\n  @{class group_add} type gives rise to a unique homomorphism.\n\\<close>"], ["", "lemma extend_map_to_freeword_hom':\n  fixes   f :: \"'a \\<Rightarrow> 'b::group_add\"\n  defines h: \"h::'a signed \\<Rightarrow> 'b \\<equiv> \\<lambda>(s,b). if b then f s else - (f s)\"\n  defines g: \"g::'a signed list \\<Rightarrow> 'b \\<equiv> \\<lambda>xs. sum_list (map h xs)\"\n  shows   \"g (prappend_signed_list xs ys) = g xs + g ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (prappend_signed_list xs ys) = g xs + g ys", "proof (induct xs ys rule: list_induct2_snoc_Cons)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys. g (prappend_signed_list [] ys) = g [] + g ys\n 2. \\<And>xs. g (prappend_signed_list xs []) = g xs + g []\n 3. \\<And>xs x y ys.\n       g (prappend_signed_list xs ys) = g xs + g ys \\<Longrightarrow>\n       g (prappend_signed_list (xs @ [x]) (y # ys)) =\n       g (xs @ [x]) + g (y # ys)", "case (snoc_Cons xs x y ys)"], ["proof (state)\nthis:\n  g (prappend_signed_list xs ys) = g xs + g ys\n\ngoal (3 subgoals):\n 1. \\<And>ys. g (prappend_signed_list [] ys) = g [] + g ys\n 2. \\<And>xs. g (prappend_signed_list xs []) = g xs + g []\n 3. \\<And>xs x y ys.\n       g (prappend_signed_list xs ys) = g xs + g ys \\<Longrightarrow>\n       g (prappend_signed_list (xs @ [x]) (y # ys)) =\n       g (xs @ [x]) + g (y # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)", "proof (cases \"y = flip_signed x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = flip_signed x \\<Longrightarrow>\n    g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)\n 2. nflipped_signed x y \\<Longrightarrow>\n    g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)", "case True"], ["proof (state)\nthis:\n  y = flip_signed x\n\ngoal (2 subgoals):\n 1. y = flip_signed x \\<Longrightarrow>\n    g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)\n 2. nflipped_signed x y \\<Longrightarrow>\n    g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)", "with h"], ["proof (chain)\npicking this:\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n  y = flip_signed x", "have \"h y = - h x\""], ["proof (prove)\nusing this:\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n  y = flip_signed x\n\ngoal (1 subgoal):\n 1. h y = - h x", "using split_beta'[of \"\\<lambda>s b. if b then f s else - (f s)\"]"], ["proof (prove)\nusing this:\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n  y = flip_signed x\n  (\\<lambda>(x, y). if y then f x else - f x) = apply_sign f\n\ngoal (1 subgoal):\n 1. h y = - h x", "by simp"], ["proof (state)\nthis:\n  h y = - h x\n\ngoal (2 subgoals):\n 1. y = flip_signed x \\<Longrightarrow>\n    g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)\n 2. nflipped_signed x y \\<Longrightarrow>\n    g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)", "with g"], ["proof (chain)\npicking this:\n  g \\<equiv> \\<lambda>xs. sum_list (map h xs)\n  h y = - h x", "have \"g (xs @ [x]) + g (y # ys) = g xs + g ys\""], ["proof (prove)\nusing this:\n  g \\<equiv> \\<lambda>xs. sum_list (map h xs)\n  h y = - h x\n\ngoal (1 subgoal):\n 1. g (xs @ [x]) + g (y # ys) = g xs + g ys", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  g (xs @ [x]) + g (y # ys) = g xs + g ys\n\ngoal (2 subgoals):\n 1. y = flip_signed x \\<Longrightarrow>\n    g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)\n 2. nflipped_signed x y \\<Longrightarrow>\n    g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)", "with True snoc_Cons"], ["proof (chain)\npicking this:\n  y = flip_signed x\n  g (prappend_signed_list xs ys) = g xs + g ys\n  g (xs @ [x]) + g (y # ys) = g xs + g ys", "show ?thesis"], ["proof (prove)\nusing this:\n  y = flip_signed x\n  g (prappend_signed_list xs ys) = g xs + g ys\n  g (xs @ [x]) + g (y # ys) = g xs + g ys\n\ngoal (1 subgoal):\n 1. g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)", "by simp"], ["proof (state)\nthis:\n  g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)\n\ngoal (1 subgoal):\n 1. nflipped_signed x y \\<Longrightarrow>\n    g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nflipped_signed x y \\<Longrightarrow>\n    g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)", "case False"], ["proof (state)\nthis:\n  nflipped_signed x y\n\ngoal (1 subgoal):\n 1. nflipped_signed x y \\<Longrightarrow>\n    g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)", "with g"], ["proof (chain)\npicking this:\n  g \\<equiv> \\<lambda>xs. sum_list (map h xs)\n  nflipped_signed x y", "show ?thesis"], ["proof (prove)\nusing this:\n  g \\<equiv> \\<lambda>xs. sum_list (map h xs)\n  nflipped_signed x y\n\ngoal (1 subgoal):\n 1. g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)", "using sum_list.append[of \"map h (xs@[x])\" \"map h (y#ys)\"]"], ["proof (prove)\nusing this:\n  g \\<equiv> \\<lambda>xs. sum_list (map h xs)\n  nflipped_signed x y\n  sum_list (map h (xs @ [x]) @ map h (y # ys)) =\n  sum_list (map h (xs @ [x])) + sum_list (map h (y # ys))\n\ngoal (1 subgoal):\n 1. g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)", "by simp"], ["proof (state)\nthis:\n  g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g (prappend_signed_list (xs @ [x]) (y # ys)) = g (xs @ [x]) + g (y # ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys. g (prappend_signed_list [] ys) = g [] + g ys\n 2. \\<And>xs. g (prappend_signed_list xs []) = g xs + g []", "qed (auto simp add: h g)"], ["", "lemma extend_map_to_freeword_hom1:\n  fixes   f :: \"'a \\<Rightarrow> 'b::group_add\"\n  defines \"h::'a signed \\<Rightarrow> 'b \\<equiv> \\<lambda>(s,b). if b then f s else - (f s)\"\n  defines \"g::'a freeword \\<Rightarrow> 'b \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\"\n  shows   \"g (Abs_freeletter s) = f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (Abs_freeletter s) = f s", "using   assms"], ["proof (prove)\nusing this:\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n  g \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\n\ngoal (1 subgoal):\n 1. g (Abs_freeletter s) = f s", "by      (simp add: Abs_freeword_inverse)"], ["", "lemma extend_map_to_freeword_hom2:\n  fixes   f :: \"'a \\<Rightarrow> 'b::group_add\"\n  defines \"h::'a signed \\<Rightarrow> 'b \\<equiv> \\<lambda>(s,b). if b then f s else - (f s)\"\n  defines \"g::'a freeword \\<Rightarrow> 'b \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\"\n  shows   \"UGroupHom g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UGroupHom g", "using   assms"], ["proof (prove)\nusing this:\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n  g \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\n\ngoal (1 subgoal):\n 1. UGroupHom g", "by      (\n            auto intro: UGroupHomI\n            simp add: plus_freeword.rep_eq extend_map_to_freeword_hom'\n          )"], ["", "lemma uniqueness_of_extended_map_to_freeword_hom':\n  fixes   f :: \"'a \\<Rightarrow> 'b::group_add\"\n  defines h: \"h::'a signed \\<Rightarrow> 'b \\<equiv> \\<lambda>(s,b). if b then f s else - (f s)\"\n  defines g: \"g::'a signed list \\<Rightarrow> 'b \\<equiv> \\<lambda>xs. sum_list (map h xs)\"\n  assumes singles: \"\\<And>s. k [(s,True)] = f s\"\n  and     adds   : \"\\<And>xs ys. proper_signed_list xs \\<Longrightarrow> proper_signed_list ys\n            \\<Longrightarrow> k (prappend_signed_list xs ys) = k xs + k ys\"\n  shows   \"proper_signed_list xs \\<Longrightarrow> k xs = g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_signed_list xs \\<Longrightarrow> k xs = g xs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_signed_list xs \\<Longrightarrow> k xs = g xs", "have knil: \"k [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k [] = (0::'b)", "using adds[of \"[]\" \"[]\"] add.assoc[of \"k []\" \"k []\" \"- k []\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list []; proper_signed_list []\\<rbrakk>\n  \\<Longrightarrow> k (prappend_signed_list [] []) = k [] + k []\n  k [] + k [] + - k [] = k [] + (k [] + - k [])\n\ngoal (1 subgoal):\n 1. k [] = (0::'b)", "by simp"], ["proof (state)\nthis:\n  k [] = (0::'b)\n\ngoal (1 subgoal):\n 1. proper_signed_list xs \\<Longrightarrow> k xs = g xs", "have ksingle: \"\\<And>x. k [x] = g [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. k [x] = g [x]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. k [x] = g [x]", "fix x :: \"'a signed\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. k [x] = g [x]", "obtain s b where x: \"x = (s,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s b. x = (s, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (s, b)\n\ngoal (1 subgoal):\n 1. \\<And>x. k [x] = g [x]", "show \"k [x] = g [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k [x] = g [x]", "proof (cases b)"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<Longrightarrow> k [x] = g [x]\n 2. \\<not> b \\<Longrightarrow> k [x] = g [x]", "case False"], ["proof (state)\nthis:\n  \\<not> b\n\ngoal (2 subgoals):\n 1. b \\<Longrightarrow> k [x] = g [x]\n 2. \\<not> b \\<Longrightarrow> k [x] = g [x]", "from adds x singles"], ["proof (chain)\npicking this:\n  \\<lbrakk>proper_signed_list ?xs; proper_signed_list ?ys\\<rbrakk>\n  \\<Longrightarrow> k (prappend_signed_list ?xs ?ys) = k ?xs + k ?ys\n  x = (s, b)\n  k [pairtrue ?s] = f ?s", "have  \"k (prappend_signed_list [x] [(s,True)]) = k [x] + f s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list ?xs; proper_signed_list ?ys\\<rbrakk>\n  \\<Longrightarrow> k (prappend_signed_list ?xs ?ys) = k ?xs + k ?ys\n  x = (s, b)\n  k [pairtrue ?s] = f ?s\n\ngoal (1 subgoal):\n 1. k (prappend_signed_list [x] [pairtrue s]) = k [x] + f s", "by    simp"], ["proof (state)\nthis:\n  k (prappend_signed_list [x] [pairtrue s]) = k [x] + f s\n\ngoal (2 subgoals):\n 1. b \\<Longrightarrow> k [x] = g [x]\n 2. \\<not> b \\<Longrightarrow> k [x] = g [x]", "moreover"], ["proof (state)\nthis:\n  k (prappend_signed_list [x] [pairtrue s]) = k [x] + f s\n\ngoal (2 subgoals):\n 1. b \\<Longrightarrow> k [x] = g [x]\n 2. \\<not> b \\<Longrightarrow> k [x] = g [x]", "have \"prappend_signed_list [(s,False)] [(s,True)] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prappend_signed_list [pairfalse s] [pairtrue s] = []", "using collapse_flipped_signed[of s False]"], ["proof (prove)\nusing this:\n  prappend_signed_list [pairfalse s] [(s, \\<not> False)] = []\n\ngoal (1 subgoal):\n 1. prappend_signed_list [pairfalse s] [pairtrue s] = []", "by simp"], ["proof (state)\nthis:\n  prappend_signed_list [pairfalse s] [pairtrue s] = []\n\ngoal (2 subgoals):\n 1. b \\<Longrightarrow> k [x] = g [x]\n 2. \\<not> b \\<Longrightarrow> k [x] = g [x]", "ultimately"], ["proof (chain)\npicking this:\n  k (prappend_signed_list [x] [pairtrue s]) = k [x] + f s\n  prappend_signed_list [pairfalse s] [pairtrue s] = []", "have \"- f s = k [x] + f s + - f s\""], ["proof (prove)\nusing this:\n  k (prappend_signed_list [x] [pairtrue s]) = k [x] + f s\n  prappend_signed_list [pairfalse s] [pairtrue s] = []\n\ngoal (1 subgoal):\n 1. - f s = k [x] + f s + - f s", "using x False knil"], ["proof (prove)\nusing this:\n  k (prappend_signed_list [x] [pairtrue s]) = k [x] + f s\n  prappend_signed_list [pairfalse s] [pairtrue s] = []\n  x = (s, b)\n  \\<not> b\n  k [] = (0::'b)\n\ngoal (1 subgoal):\n 1. - f s = k [x] + f s + - f s", "by simp"], ["proof (state)\nthis:\n  - f s = k [x] + f s + - f s\n\ngoal (2 subgoals):\n 1. b \\<Longrightarrow> k [x] = g [x]\n 2. \\<not> b \\<Longrightarrow> k [x] = g [x]", "with x False g h"], ["proof (chain)\npicking this:\n  x = (s, b)\n  \\<not> b\n  g \\<equiv> \\<lambda>xs. sum_list (map h xs)\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n  - f s = k [x] + f s + - f s", "show \"k [x] = g [x]\""], ["proof (prove)\nusing this:\n  x = (s, b)\n  \\<not> b\n  g \\<equiv> \\<lambda>xs. sum_list (map h xs)\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n  - f s = k [x] + f s + - f s\n\ngoal (1 subgoal):\n 1. k [x] = g [x]", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  k [x] = g [x]\n\ngoal (1 subgoal):\n 1. b \\<Longrightarrow> k [x] = g [x]", "qed (simp add: x g h singles)"], ["proof (state)\nthis:\n  k [x] = g [x]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k [?x] = g [?x]\n\ngoal (1 subgoal):\n 1. proper_signed_list xs \\<Longrightarrow> k xs = g xs", "show \"proper_signed_list xs \\<Longrightarrow> k xs = g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_signed_list xs \\<Longrightarrow> k xs = g xs", "proof (induct xs rule: list_induct_CCons)"], ["proof (state)\ngoal (3 subgoals):\n 1. proper_signed_list [] \\<Longrightarrow> k [] = g []\n 2. \\<And>x. proper_signed_list [x] \\<Longrightarrow> k [x] = g [x]\n 3. \\<And>x y xs.\n       \\<lbrakk>proper_signed_list (y # xs) \\<Longrightarrow>\n                k (y # xs) = g (y # xs);\n        proper_signed_list (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> k (x # y # xs) = g (x # y # xs)", "case (CCons x y xs)"], ["proof (state)\nthis:\n  proper_signed_list (y # xs) \\<Longrightarrow> k (y # xs) = g (y # xs)\n  proper_signed_list (x # y # xs)\n\ngoal (3 subgoals):\n 1. proper_signed_list [] \\<Longrightarrow> k [] = g []\n 2. \\<And>x. proper_signed_list [x] \\<Longrightarrow> k [x] = g [x]\n 3. \\<And>x y xs.\n       \\<lbrakk>proper_signed_list (y # xs) \\<Longrightarrow>\n                k (y # xs) = g (y # xs);\n        proper_signed_list (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> k (x # y # xs) = g (x # y # xs)", "with g h"], ["proof (chain)\npicking this:\n  g \\<equiv> \\<lambda>xs. sum_list (map h xs)\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n  proper_signed_list (y # xs) \\<Longrightarrow> k (y # xs) = g (y # xs)\n  proper_signed_list (x # y # xs)", "show ?case"], ["proof (prove)\nusing this:\n  g \\<equiv> \\<lambda>xs. sum_list (map h xs)\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n  proper_signed_list (y # xs) \\<Longrightarrow> k (y # xs) = g (y # xs)\n  proper_signed_list (x # y # xs)\n\ngoal (1 subgoal):\n 1. k (x # y # xs) = g (x # y # xs)", "using adds[of \"[x]\" \"y#xs\"]"], ["proof (prove)\nusing this:\n  g \\<equiv> \\<lambda>xs. sum_list (map h xs)\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n  proper_signed_list (y # xs) \\<Longrightarrow> k (y # xs) = g (y # xs)\n  proper_signed_list (x # y # xs)\n  \\<lbrakk>proper_signed_list [x]; proper_signed_list (y # xs)\\<rbrakk>\n  \\<Longrightarrow> k (prappend_signed_list [x] (y # xs)) =\n                    k [x] + k (y # xs)\n\ngoal (1 subgoal):\n 1. k (x # y # xs) = g (x # y # xs)", "by    (simp add:\n              prappend_signed_list_single_Cons\n              ksingle extend_map_to_freeword_hom'\n            )"], ["proof (state)\nthis:\n  k (x # y # xs) = g (x # y # xs)\n\ngoal (2 subgoals):\n 1. proper_signed_list [] \\<Longrightarrow> k [] = g []\n 2. \\<And>x. proper_signed_list [x] \\<Longrightarrow> k [x] = g [x]", "qed (auto simp add: g h knil ksingle)"], ["proof (state)\nthis:\n  proper_signed_list xs \\<Longrightarrow> k xs = g xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uniqueness_of_extended_map_to_freeword_hom:\n  fixes   f :: \"'a \\<Rightarrow> 'b::group_add\"\n  defines \"h::'a signed \\<Rightarrow> 'b \\<equiv> \\<lambda>(s,b). if b then f s else - (f s)\"\n  defines \"g::'a freeword \\<Rightarrow> 'b \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\"\n  assumes k: \"k \\<circ> Abs_freeletter = f\" \"UGroupHom k\"\n  shows   \"k = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = g", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. k x = g x", "fix x::\"'a freeword\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. k x = g x", "define k' where k': \"k' \\<equiv> k \\<circ> Abs_freeword\""], ["proof (state)\nthis:\n  k' \\<equiv> k \\<circ> Abs_freeword\n\ngoal (1 subgoal):\n 1. \\<And>x. k x = g x", "have \"k' (freeword x) = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' (freeword x) = g x", "unfolding h_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k' (freeword x) =\n    (\\<Sum>(s, b)\\<leftarrow>freeword x. if b then f s else - f s)", "proof (rule uniqueness_of_extended_map_to_freeword_hom')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s. k' [pairtrue s] = f s\n 2. \\<And>xs ys.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list ys\\<rbrakk>\n       \\<Longrightarrow> k' (prappend_signed_list xs ys) = k' xs + k' ys\n 3. proper_signed_list (freeword x)", "from k' k(1)"], ["proof (chain)\npicking this:\n  k' \\<equiv> k \\<circ> Abs_freeword\n  k \\<circ> Abs_freeletter = f", "show \"\\<And>s. k' [pairtrue s] = f s\""], ["proof (prove)\nusing this:\n  k' \\<equiv> k \\<circ> Abs_freeword\n  k \\<circ> Abs_freeletter = f\n\ngoal (1 subgoal):\n 1. \\<And>s. k' [pairtrue s] = f s", "by auto"], ["proof (state)\nthis:\n  k' [pairtrue ?s] = f ?s\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list ys\\<rbrakk>\n       \\<Longrightarrow> k' (prappend_signed_list xs ys) = k' xs + k' ys\n 2. proper_signed_list (freeword x)", "show \"\\<And>xs ys. proper_signed_list xs \\<Longrightarrow> proper_signed_list ys\n            \\<Longrightarrow> k' (prappend_signed_list xs ys) = k' xs + k' ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list ys\\<rbrakk>\n       \\<Longrightarrow> k' (prappend_signed_list xs ys) = k' xs + k' ys", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list ys\\<rbrakk>\n       \\<Longrightarrow> k' (prappend_signed_list xs ys) = k' xs + k' ys", "fix xs ys :: \"'a signed list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list ys\\<rbrakk>\n       \\<Longrightarrow> k' (prappend_signed_list xs ys) = k' xs + k' ys", "assume xsys: \"proper_signed_list xs\" \"proper_signed_list ys\""], ["proof (state)\nthis:\n  proper_signed_list xs\n  proper_signed_list ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>proper_signed_list xs; proper_signed_list ys\\<rbrakk>\n       \\<Longrightarrow> k' (prappend_signed_list xs ys) = k' xs + k' ys", "with k'"], ["proof (chain)\npicking this:\n  k' \\<equiv> k \\<circ> Abs_freeword\n  proper_signed_list xs\n  proper_signed_list ys", "show  \"k' (prappend_signed_list xs ys) = k' xs + k' ys\""], ["proof (prove)\nusing this:\n  k' \\<equiv> k \\<circ> Abs_freeword\n  proper_signed_list xs\n  proper_signed_list ys\n\ngoal (1 subgoal):\n 1. k' (prappend_signed_list xs ys) = k' xs + k' ys", "using UGroupHom.hom[OF k(2), of \"Abs_freeword xs\" \"Abs_freeword ys\"]"], ["proof (prove)\nusing this:\n  k' \\<equiv> k \\<circ> Abs_freeword\n  proper_signed_list xs\n  proper_signed_list ys\n  k (Abs_freeword xs + Abs_freeword ys) =\n  k (Abs_freeword xs) + k (Abs_freeword ys)\n\ngoal (1 subgoal):\n 1. k' (prappend_signed_list xs ys) = k' xs + k' ys", "by    (simp add: plus_freeword_abs_eq)"], ["proof (state)\nthis:\n  k' (prappend_signed_list xs ys) = k' xs + k' ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>proper_signed_list ?xs; proper_signed_list ?ys\\<rbrakk>\n  \\<Longrightarrow> k' (prappend_signed_list ?xs ?ys) = k' ?xs + k' ?ys\n\ngoal (1 subgoal):\n 1. proper_signed_list (freeword x)", "show \"proper_signed_list (freeword x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_signed_list (freeword x)", "using freeword"], ["proof (prove)\nusing this:\n  freeword ?x \\<in> {as. proper_signed_list as}\n\ngoal (1 subgoal):\n 1. proper_signed_list (freeword x)", "by fast"], ["proof (state)\nthis:\n  proper_signed_list (freeword x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k' (freeword x) = g x\n\ngoal (1 subgoal):\n 1. \\<And>x. k x = g x", "with k'"], ["proof (chain)\npicking this:\n  k' \\<equiv> k \\<circ> Abs_freeword\n  k' (freeword x) = g x", "show \"k x = g x\""], ["proof (prove)\nusing this:\n  k' \\<equiv> k \\<circ> Abs_freeword\n  k' (freeword x) = g x\n\ngoal (1 subgoal):\n 1. k x = g x", "using freeword_inverse[of x]"], ["proof (prove)\nusing this:\n  k' \\<equiv> k \\<circ> Abs_freeword\n  k' (freeword x) = g x\n  Abs_freeword (freeword x) = x\n\ngoal (1 subgoal):\n 1. k x = g x", "by simp"], ["proof (state)\nthis:\n  k x = g x\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem universal_property:\n  fixes f :: \"'a \\<Rightarrow> 'b::group_add\"\n  shows \"\\<exists>!g::'a freeword\\<Rightarrow>'b. g \\<circ> Abs_freeletter = f \\<and> UGroupHom g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!g. g \\<circ> Abs_freeletter = f \\<and> UGroupHom g", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ?a \\<circ> Abs_freeletter = f \\<and> UGroupHom ?a\n 2. \\<And>g.\n       g \\<circ> Abs_freeletter = f \\<and> UGroupHom g \\<Longrightarrow>\n       g = ?a", "define h where h: \"h \\<equiv> \\<lambda>(s,b). if b then f s else - (f s)\""], ["proof (state)\nthis:\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n\ngoal (2 subgoals):\n 1. ?a \\<circ> Abs_freeletter = f \\<and> UGroupHom ?a\n 2. \\<And>g.\n       g \\<circ> Abs_freeletter = f \\<and> UGroupHom g \\<Longrightarrow>\n       g = ?a", "define g where g: \"g \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\""], ["proof (state)\nthis:\n  g \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\n\ngoal (2 subgoals):\n 1. ?a \\<circ> Abs_freeletter = f \\<and> UGroupHom ?a\n 2. \\<And>g.\n       g \\<circ> Abs_freeletter = f \\<and> UGroupHom g \\<Longrightarrow>\n       g = ?a", "from g h"], ["proof (chain)\npicking this:\n  g \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s", "show \"g \\<circ> Abs_freeletter = f \\<and> UGroupHom g\""], ["proof (prove)\nusing this:\n  g \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n\ngoal (1 subgoal):\n 1. g \\<circ> Abs_freeletter = f \\<and> UGroupHom g", "using extend_map_to_freeword_hom1[of f] extend_map_to_freeword_hom2"], ["proof (prove)\nusing this:\n  g \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n  (\\<Sum>(s,\n      b)\\<leftarrow>freeword\n                     (Abs_freeletter ?s). if b then f s else - f s) =\n  f ?s\n  UGroupHom\n   (\\<lambda>x.\n       \\<Sum>(s, b)\\<leftarrow>freeword x. if b then ?f s else - ?f s)\n\ngoal (1 subgoal):\n 1. g \\<circ> Abs_freeletter = f \\<and> UGroupHom g", "by    auto"], ["proof (state)\nthis:\n  g \\<circ> Abs_freeletter = f \\<and> UGroupHom g\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       g \\<circ> Abs_freeletter = f \\<and> UGroupHom g \\<Longrightarrow>\n       g =\n       (\\<lambda>x.\n           \\<Sum>(s, b)\\<leftarrow>freeword x. if b then f s else - f s)", "from g h"], ["proof (chain)\npicking this:\n  g \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s", "show \"\\<And>k. k \\<circ> Abs_freeletter = f \\<and> UGroupHom k \\<Longrightarrow> k = g\""], ["proof (prove)\nusing this:\n  g \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<circ> Abs_freeletter = f \\<and> UGroupHom k \\<Longrightarrow>\n       k = g", "using uniqueness_of_extended_map_to_freeword_hom"], ["proof (prove)\nusing this:\n  g \\<equiv> \\<lambda>x. sum_list (map h (freeword x))\n  h \\<equiv> \\<lambda>(s, b). if b then f s else - f s\n  \\<lbrakk>?k \\<circ> Abs_freeletter = ?f; UGroupHom ?k\\<rbrakk>\n  \\<Longrightarrow> ?k =\n                    (\\<lambda>x.\n                        \\<Sum>(s,\n                           b)\\<leftarrow>freeword\n    x. if b then ?f s else - ?f s)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<circ> Abs_freeletter = f \\<and> UGroupHom k \\<Longrightarrow>\n       k = g", "by auto"], ["proof (state)\nthis:\n  ?k \\<circ> Abs_freeletter = f \\<and> UGroupHom ?k \\<Longrightarrow> ?k = g\n\ngoal:\nNo subgoals!", "qed"], ["", "paragraph \\<open>Properties of homomorphisms afforded by the universal property\\<close>"], ["", "text \\<open>\n  The lift of a function on the letter set is the unique additive function on @{type freeword}\n  that agrees with the original function on letters.\n\\<close>"], ["", "definition freeword_funlift :: \"('a \\<Rightarrow> 'b::group_add) \\<Rightarrow> ('a freeword\\<Rightarrow>'b::group_add)\"\n  where \"freeword_funlift f \\<equiv> (THE g. g \\<circ> Abs_freeletter = f \\<and> UGroupHom g)\""], ["", "lemma additive_freeword_funlift: \"UGroupHom (freeword_funlift f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UGroupHom (freeword_funlift f)", "using theI'[OF universal_property, of f]"], ["proof (prove)\nusing this:\n  (THE x. x \\<circ> Abs_freeletter = f \\<and> UGroupHom x) \\<circ>\n  Abs_freeletter =\n  f \\<and>\n  UGroupHom (THE x. x \\<circ> Abs_freeletter = f \\<and> UGroupHom x)\n\ngoal (1 subgoal):\n 1. UGroupHom (freeword_funlift f)", "unfolding freeword_funlift_def"], ["proof (prove)\nusing this:\n  (THE x. x \\<circ> Abs_freeletter = f \\<and> UGroupHom x) \\<circ>\n  Abs_freeletter =\n  f \\<and>\n  UGroupHom (THE x. x \\<circ> Abs_freeletter = f \\<and> UGroupHom x)\n\ngoal (1 subgoal):\n 1. UGroupHom (THE g. g \\<circ> Abs_freeletter = f \\<and> UGroupHom g)", "by simp"], ["", "lemma freeword_funlift_Abs_freeletter: \"freeword_funlift f (Abs_freeletter s) = f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeletter s) = f s", "using     theI'[OF universal_property, of f]\n            comp_apply[of \"freeword_funlift f\" Abs_freeletter]"], ["proof (prove)\nusing this:\n  (THE x. x \\<circ> Abs_freeletter = f \\<and> UGroupHom x) \\<circ>\n  Abs_freeletter =\n  f \\<and>\n  UGroupHom (THE x. x \\<circ> Abs_freeletter = f \\<and> UGroupHom x)\n  (freeword_funlift f \\<circ> Abs_freeletter) ?x =\n  freeword_funlift f (Abs_freeletter ?x)\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeletter s) = f s", "unfolding freeword_funlift_def"], ["proof (prove)\nusing this:\n  (THE x. x \\<circ> Abs_freeletter = f \\<and> UGroupHom x) \\<circ>\n  Abs_freeletter =\n  f \\<and>\n  UGroupHom (THE x. x \\<circ> Abs_freeletter = f \\<and> UGroupHom x)\n  ((THE g. g \\<circ> Abs_freeletter = f \\<and> UGroupHom g) \\<circ>\n   Abs_freeletter)\n   ?x =\n  (THE g. g \\<circ> Abs_freeletter = f \\<and> UGroupHom g)\n   (Abs_freeletter ?x)\n\ngoal (1 subgoal):\n 1. (THE g. g \\<circ> Abs_freeletter = f \\<and> UGroupHom g)\n     (Abs_freeletter s) =\n    f s", "by        fastforce"], ["", "lemmas freeword_funlift_add         = UGroupHom.hom        [OF additive_freeword_funlift]"], ["", "lemmas freeword_funlift_0           = UGroupHom.im_zero    [OF additive_freeword_funlift]"], ["", "lemmas freeword_funlift_uminus      = UGroupHom.im_uminus  [OF additive_freeword_funlift]"], ["", "lemmas freeword_funlift_diff        = UGroupHom.im_diff    [OF additive_freeword_funlift]"], ["", "lemmas freeword_funlift_lconjby     = UGroupHom.im_lconjby [OF additive_freeword_funlift]"], ["", "lemma freeword_funlift_uminus_Abs_freeletter:\n  \"freeword_funlift f (Abs_freeword [(s,False)]) = - f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword [pairfalse s]) = - f s", "using freeword_funlift_uminus[of f \"Abs_freeword [(s,False)]\"]\n        uminus_freeword_Abs_eq[of \"[(s,False)]\"]\n        freeword_funlift_Abs_freeletter[of f]"], ["proof (prove)\nusing this:\n  freeword_funlift f (- Abs_freeword [pairfalse s]) =\n  - freeword_funlift f (Abs_freeword [pairfalse s])\n  proper_signed_list [pairfalse s] \\<Longrightarrow>\n  - Abs_freeword [pairfalse s] =\n  Abs_freeword (rev (map flip_signed [pairfalse s]))\n  freeword_funlift f (Abs_freeletter ?s) = f ?s\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword [pairfalse s]) = - f s", "by    simp"], ["", "lemma freeword_funlift_Abs_freeword_singleton:\n  \"freeword_funlift f (Abs_freeword [x]) = apply_sign f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword [x]) = apply_sign f x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword [x]) = apply_sign f x", "obtain s b where x: \"x = (s,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s b. x = (s, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (s, b)\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword [x]) = apply_sign f x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = (s, b)\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword [x]) = apply_sign f x", "using freeword_funlift_Abs_freeletter freeword_funlift_uminus_Abs_freeletter"], ["proof (prove)\nusing this:\n  x = (s, b)\n  freeword_funlift ?f (Abs_freeletter ?s) = ?f ?s\n  freeword_funlift ?f (Abs_freeword [pairfalse ?s]) = - ?f ?s\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword [x]) = apply_sign f x", "by    (cases b) auto"], ["proof (state)\nthis:\n  freeword_funlift f (Abs_freeword [x]) = apply_sign f x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freeword_funlift_Abs_freeword_Cons:\n  assumes \"proper_signed_list (x#xs)\"\n  shows   \"freeword_funlift f (Abs_freeword (x#xs)) =\n            apply_sign f x + freeword_funlift f (Abs_freeword xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword (x # xs)) =\n    apply_sign f x + freeword_funlift f (Abs_freeword xs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword (x # xs)) =\n    apply_sign f x + freeword_funlift f (Abs_freeword xs)", "from assms"], ["proof (chain)\npicking this:\n  proper_signed_list (x # xs)", "have \"freeword_funlift f (Abs_freeword (x#xs)) =\n            freeword_funlift f (Abs_freeword [x]) +\n            freeword_funlift f (Abs_freeword xs)\""], ["proof (prove)\nusing this:\n  proper_signed_list (x # xs)\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword (x # xs)) =\n    freeword_funlift f (Abs_freeword [x]) +\n    freeword_funlift f (Abs_freeword xs)", "using Abs_freeword_Cons[of x xs] freeword_funlift_add"], ["proof (prove)\nusing this:\n  proper_signed_list (x # xs)\n  proper_signed_list (x # xs) \\<Longrightarrow>\n  Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs\n  freeword_funlift ?f (?g + ?g') =\n  freeword_funlift ?f ?g + freeword_funlift ?f ?g'\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword (x # xs)) =\n    freeword_funlift f (Abs_freeword [x]) +\n    freeword_funlift f (Abs_freeword xs)", "by simp"], ["proof (state)\nthis:\n  freeword_funlift f (Abs_freeword (x # xs)) =\n  freeword_funlift f (Abs_freeword [x]) +\n  freeword_funlift f (Abs_freeword xs)\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword (x # xs)) =\n    apply_sign f x + freeword_funlift f (Abs_freeword xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  freeword_funlift f (Abs_freeword (x # xs)) =\n  freeword_funlift f (Abs_freeword [x]) +\n  freeword_funlift f (Abs_freeword xs)\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword (x # xs)) =\n    apply_sign f x + freeword_funlift f (Abs_freeword xs)", "using freeword_funlift_Abs_freeword_singleton[of f x]"], ["proof (prove)\nusing this:\n  freeword_funlift f (Abs_freeword (x # xs)) =\n  freeword_funlift f (Abs_freeword [x]) +\n  freeword_funlift f (Abs_freeword xs)\n  freeword_funlift f (Abs_freeword [x]) = apply_sign f x\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword (x # xs)) =\n    apply_sign f x + freeword_funlift f (Abs_freeword xs)", "by simp"], ["proof (state)\nthis:\n  freeword_funlift f (Abs_freeword (x # xs)) =\n  apply_sign f x + freeword_funlift f (Abs_freeword xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freeword_funlift_Abs_freeword:\n  \"proper_signed_list xs \\<Longrightarrow> freeword_funlift f (Abs_freeword xs) =\n    (\\<Sum>x\\<leftarrow>xs. apply_sign f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_signed_list xs \\<Longrightarrow>\n    freeword_funlift f (Abs_freeword xs) = sum_list (map (apply_sign f) xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. proper_signed_list [] \\<Longrightarrow>\n    freeword_funlift f (Abs_freeword []) = sum_list (map (apply_sign f) [])\n 2. \\<And>a xs.\n       \\<lbrakk>proper_signed_list xs \\<Longrightarrow>\n                freeword_funlift f (Abs_freeword xs) =\n                sum_list (map (apply_sign f) xs);\n        proper_signed_list (a # xs)\\<rbrakk>\n       \\<Longrightarrow> freeword_funlift f (Abs_freeword (a # xs)) =\n                         sum_list (map (apply_sign f) (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  proper_signed_list xs \\<Longrightarrow>\n  freeword_funlift f (Abs_freeword xs) = sum_list (map (apply_sign f) xs)\n  proper_signed_list (x # xs)\n\ngoal (2 subgoals):\n 1. proper_signed_list [] \\<Longrightarrow>\n    freeword_funlift f (Abs_freeword []) = sum_list (map (apply_sign f) [])\n 2. \\<And>a xs.\n       \\<lbrakk>proper_signed_list xs \\<Longrightarrow>\n                freeword_funlift f (Abs_freeword xs) =\n                sum_list (map (apply_sign f) xs);\n        proper_signed_list (a # xs)\\<rbrakk>\n       \\<Longrightarrow> freeword_funlift f (Abs_freeword (a # xs)) =\n                         sum_list (map (apply_sign f) (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  proper_signed_list xs \\<Longrightarrow>\n  freeword_funlift f (Abs_freeword xs) = sum_list (map (apply_sign f) xs)\n  proper_signed_list (x # xs)\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword (x # xs)) =\n    sum_list (map (apply_sign f) (x # xs))", "using freeword_funlift_Abs_freeword_Cons[of _ _ f]\n          binrelchain_Cons_reduce[of _ x xs]"], ["proof (prove)\nusing this:\n  proper_signed_list xs \\<Longrightarrow>\n  freeword_funlift f (Abs_freeword xs) = sum_list (map (apply_sign f) xs)\n  proper_signed_list (x # xs)\n  proper_signed_list (?x # ?xs) \\<Longrightarrow>\n  freeword_funlift f (Abs_freeword (?x # ?xs)) =\n  apply_sign f ?x + freeword_funlift f (Abs_freeword ?xs)\n  binrelchain ?P (x # xs) \\<Longrightarrow> binrelchain ?P xs\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword (x # xs)) =\n    sum_list (map (apply_sign f) (x # xs))", "by    simp"], ["proof (state)\nthis:\n  freeword_funlift f (Abs_freeword (x # xs)) =\n  sum_list (map (apply_sign f) (x # xs))\n\ngoal (1 subgoal):\n 1. proper_signed_list [] \\<Longrightarrow>\n    freeword_funlift f (Abs_freeword []) = sum_list (map (apply_sign f) [])", "qed (simp add: zero_freeword.abs_eq[THEN sym] freeword_funlift_0)"], ["", "lemma freeword_funlift_Abs_freelist:\n  \"freeword_funlift f (Abs_freelist xs) = (\\<Sum>x\\<leftarrow>xs. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freelist xs) = sum_list (map f xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. freeword_funlift f (Abs_freelist []) = sum_list (map f [])\n 2. \\<And>a xs.\n       freeword_funlift f (Abs_freelist xs) =\n       sum_list (map f xs) \\<Longrightarrow>\n       freeword_funlift f (Abs_freelist (a # xs)) =\n       sum_list (map f (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  freeword_funlift f (Abs_freelist xs) = sum_list (map f xs)\n\ngoal (2 subgoals):\n 1. freeword_funlift f (Abs_freelist []) = sum_list (map f [])\n 2. \\<And>a xs.\n       freeword_funlift f (Abs_freelist xs) =\n       sum_list (map f xs) \\<Longrightarrow>\n       freeword_funlift f (Abs_freelist (a # xs)) =\n       sum_list (map f (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  freeword_funlift f (Abs_freelist xs) = sum_list (map f xs)\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freelist (x # xs)) = sum_list (map f (x # xs))", "using Abs_freelist_Cons[of x xs]"], ["proof (prove)\nusing this:\n  freeword_funlift f (Abs_freelist xs) = sum_list (map f xs)\n  Abs_freelist (x # xs) = Abs_freeletter x + Abs_freelist xs\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freelist (x # xs)) = sum_list (map f (x # xs))", "by    (simp add: freeword_funlift_add freeword_funlift_Abs_freeletter)"], ["proof (state)\nthis:\n  freeword_funlift f (Abs_freelist (x # xs)) = sum_list (map f (x # xs))\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freelist []) = sum_list (map f [])", "qed (simp add: zero_freeword.abs_eq[THEN sym] freeword_funlift_0)"], ["", "lemma freeword_funlift_im':\n  \"proper_signed_list xs \\<Longrightarrow> fst ` set xs \\<subseteq> S \\<Longrightarrow>\n    freeword_funlift f (Abs_freeword xs) \\<in> \\<langle>f`S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs;\n     order.greater_eq S (fst ` set xs)\\<rbrakk>\n    \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                      \\<in> \\<langle>f ` S\\<rangle>", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>proper_signed_list [];\n     order.greater_eq S (fst ` set [])\\<rbrakk>\n    \\<Longrightarrow> freeword_funlift f (Abs_freeword [])\n                      \\<in> \\<langle>f ` S\\<rangle>\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                                  \\<in> \\<langle>f ` S\\<rangle>;\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> freeword_funlift f (Abs_freeword (a # xs))\n                         \\<in> \\<langle>f ` S\\<rangle>", "case Nil"], ["proof (state)\nthis:\n  proper_signed_list []\n  order.greater_eq S (fst ` set [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>proper_signed_list [];\n     order.greater_eq S (fst ` set [])\\<rbrakk>\n    \\<Longrightarrow> freeword_funlift f (Abs_freeword [])\n                      \\<in> \\<langle>f ` S\\<rangle>\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                                  \\<in> \\<langle>f ` S\\<rangle>;\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> freeword_funlift f (Abs_freeword (a # xs))\n                         \\<in> \\<langle>f ` S\\<rangle>", "have \"Abs_freeword ([]::'a signed list) = (0::'a freeword)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_freeword [] = 0", "using zero_freeword.abs_eq[THEN sym]"], ["proof (prove)\nusing this:\n  Abs_freeword [] = 0\n\ngoal (1 subgoal):\n 1. Abs_freeword [] = 0", "by simp"], ["proof (state)\nthis:\n  Abs_freeword [] = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>proper_signed_list [];\n     order.greater_eq S (fst ` set [])\\<rbrakk>\n    \\<Longrightarrow> freeword_funlift f (Abs_freeword [])\n                      \\<in> \\<langle>f ` S\\<rangle>\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                                  \\<in> \\<langle>f ` S\\<rangle>;\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> freeword_funlift f (Abs_freeword (a # xs))\n                         \\<in> \\<langle>f ` S\\<rangle>", "thus \"freeword_funlift f (Abs_freeword ([]::'a signed list)) \\<in> \\<langle>f`S\\<rangle>\""], ["proof (prove)\nusing this:\n  Abs_freeword [] = 0\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword []) \\<in> \\<langle>f ` S\\<rangle>", "using freeword_funlift_0[of f] genby_0_closed"], ["proof (prove)\nusing this:\n  Abs_freeword [] = 0\n  freeword_funlift f 0 = (0::'b)\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword []) \\<in> \\<langle>f ` S\\<rangle>", "by simp"], ["proof (state)\nthis:\n  freeword_funlift f (Abs_freeword []) \\<in> \\<langle>f ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                                  \\<in> \\<langle>f ` S\\<rangle>;\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> freeword_funlift f (Abs_freeword (a # xs))\n                         \\<in> \\<langle>f ` S\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                                  \\<in> \\<langle>f ` S\\<rangle>;\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> freeword_funlift f (Abs_freeword (a # xs))\n                         \\<in> \\<langle>f ` S\\<rangle>", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs)\\<rbrakk>\n  \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                    \\<in> \\<langle>f ` S\\<rangle>\n  proper_signed_list (x # xs)\n  order.greater_eq S (fst ` set (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                                  \\<in> \\<langle>f ` S\\<rangle>;\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> freeword_funlift f (Abs_freeword (a # xs))\n                         \\<in> \\<langle>f ` S\\<rangle>", "define y where y: \"y \\<equiv> apply_sign f x\""], ["proof (state)\nthis:\n  y \\<equiv> apply_sign f x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                                  \\<in> \\<langle>f ` S\\<rangle>;\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> freeword_funlift f (Abs_freeword (a # xs))\n                         \\<in> \\<langle>f ` S\\<rangle>", "define z where z: \"z \\<equiv> freeword_funlift f (Abs_freeword xs)\""], ["proof (state)\nthis:\n  z \\<equiv> freeword_funlift f (Abs_freeword xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                                  \\<in> \\<langle>f ` S\\<rangle>;\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> freeword_funlift f (Abs_freeword (a # xs))\n                         \\<in> \\<langle>f ` S\\<rangle>", "from Cons(3)"], ["proof (chain)\npicking this:\n  order.greater_eq S (fst ` set (x # xs))", "have \"fst ` set xs \\<subseteq> S\""], ["proof (prove)\nusing this:\n  order.greater_eq S (fst ` set (x # xs))\n\ngoal (1 subgoal):\n 1. order.greater_eq S (fst ` set xs)", "by simp"], ["proof (state)\nthis:\n  order.greater_eq S (fst ` set xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                                  \\<in> \\<langle>f ` S\\<rangle>;\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> freeword_funlift f (Abs_freeword (a # xs))\n                         \\<in> \\<langle>f ` S\\<rangle>", "with z Cons(1,2)"], ["proof (chain)\npicking this:\n  z \\<equiv> freeword_funlift f (Abs_freeword xs)\n  \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs)\\<rbrakk>\n  \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                    \\<in> \\<langle>f ` S\\<rangle>\n  proper_signed_list (x # xs)\n  order.greater_eq S (fst ` set xs)", "have \"z \\<in> \\<langle>f`S\\<rangle>\""], ["proof (prove)\nusing this:\n  z \\<equiv> freeword_funlift f (Abs_freeword xs)\n  \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs)\\<rbrakk>\n  \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                    \\<in> \\<langle>f ` S\\<rangle>\n  proper_signed_list (x # xs)\n  order.greater_eq S (fst ` set xs)\n\ngoal (1 subgoal):\n 1. z \\<in> \\<langle>f ` S\\<rangle>", "using binrelchain_Cons_reduce"], ["proof (prove)\nusing this:\n  z \\<equiv> freeword_funlift f (Abs_freeword xs)\n  \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs)\\<rbrakk>\n  \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                    \\<in> \\<langle>f ` S\\<rangle>\n  proper_signed_list (x # xs)\n  order.greater_eq S (fst ` set xs)\n  binrelchain ?P (?x # ?xs) \\<Longrightarrow> binrelchain ?P ?xs\n\ngoal (1 subgoal):\n 1. z \\<in> \\<langle>f ` S\\<rangle>", "by fast"], ["proof (state)\nthis:\n  z \\<in> \\<langle>f ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                                  \\<in> \\<langle>f ` S\\<rangle>;\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> freeword_funlift f (Abs_freeword (a # xs))\n                         \\<in> \\<langle>f ` S\\<rangle>", "with y Cons(3)"], ["proof (chain)\npicking this:\n  y \\<equiv> apply_sign f x\n  order.greater_eq S (fst ` set (x # xs))\n  z \\<in> \\<langle>f ` S\\<rangle>", "have \"y + z \\<in> \\<langle>f`S\\<rangle>\""], ["proof (prove)\nusing this:\n  y \\<equiv> apply_sign f x\n  order.greater_eq S (fst ` set (x # xs))\n  z \\<in> \\<langle>f ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. y + z \\<in> \\<langle>f ` S\\<rangle>", "using genby_genset_closed[of _ \"f`S\"]\n          genby_uminus_closed genby_add_closed[of y]"], ["proof (prove)\nusing this:\n  y \\<equiv> apply_sign f x\n  order.greater_eq S (fst ` set (x # xs))\n  z \\<in> \\<langle>f ` S\\<rangle>\n  ?s \\<in> f ` S \\<Longrightarrow> ?s \\<in> \\<langle>f ` S\\<rangle>\n  ?g \\<in> \\<langle>?S\\<rangle> \\<Longrightarrow>\n  - ?g \\<in> \\<langle>?S\\<rangle>\n  \\<lbrakk>y \\<in> \\<langle>?S\\<rangle>;\n   ?h \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> y + ?h \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. y + z \\<in> \\<langle>f ` S\\<rangle>", "by    fastforce"], ["proof (state)\nthis:\n  y + z \\<in> \\<langle>f ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> freeword_funlift f (Abs_freeword xs)\n                                  \\<in> \\<langle>f ` S\\<rangle>;\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> freeword_funlift f (Abs_freeword (a # xs))\n                         \\<in> \\<langle>f ` S\\<rangle>", "with Cons(2) y z"], ["proof (chain)\npicking this:\n  proper_signed_list (x # xs)\n  y \\<equiv> apply_sign f x\n  z \\<equiv> freeword_funlift f (Abs_freeword xs)\n  y + z \\<in> \\<langle>f ` S\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  proper_signed_list (x # xs)\n  y \\<equiv> apply_sign f x\n  z \\<equiv> freeword_funlift f (Abs_freeword xs)\n  y + z \\<in> \\<langle>f ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword (x # xs)) \\<in> \\<langle>f ` S\\<rangle>", "using freeword_funlift_Abs_freeword_Cons\n          subst[\n            OF  sym,\n            of  \"freeword_funlift f (Abs_freeword (x#xs))\" \"y+z\"\n                \"\\<lambda>b. b\\<in>\\<langle>f`S\\<rangle>\"\n          ]"], ["proof (prove)\nusing this:\n  proper_signed_list (x # xs)\n  y \\<equiv> apply_sign f x\n  z \\<equiv> freeword_funlift f (Abs_freeword xs)\n  y + z \\<in> \\<langle>f ` S\\<rangle>\n  proper_signed_list (?x # ?xs) \\<Longrightarrow>\n  freeword_funlift ?f (Abs_freeword (?x # ?xs)) =\n  apply_sign ?f ?x + freeword_funlift ?f (Abs_freeword ?xs)\n  \\<lbrakk>freeword_funlift f (Abs_freeword (x # xs)) = y + z;\n   y + z \\<in> \\<langle>f ` S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> freeword_funlift f (Abs_freeword (x # xs))\n                    \\<in> \\<langle>f ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword (x # xs)) \\<in> \\<langle>f ` S\\<rangle>", "by    fast"], ["proof (state)\nthis:\n  freeword_funlift f (Abs_freeword (x # xs)) \\<in> \\<langle>f ` S\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Free groups on a set\\<close>"], ["", "text \\<open>\n  We now take the free group on a set to be the set in the @{type freeword} type with letters\n  restricted to the given set.\n\\<close>"], ["", "paragraph \\<open>Definition and basic facts\\<close>"], ["", "text \\<open>\n  Here we define the set of elements of the free group over a set of letters, and record basic\n  facts about that set.\n\\<close>"], ["", "definition FreeGroup :: \"'a set \\<Rightarrow> 'a freeword set\"\n  where \"FreeGroup S \\<equiv> {x. fst ` set (freeword x) \\<subseteq> S}\""], ["", "lemma FreeGroupI_transfer:\n  \"proper_signed_list xs \\<Longrightarrow> fst ` set xs \\<subseteq> S \\<Longrightarrow> Abs_freeword xs \\<in> FreeGroup S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs;\n     order.greater_eq S (fst ` set xs)\\<rbrakk>\n    \\<Longrightarrow> Abs_freeword xs \\<in> FreeGroup S", "using Abs_freeword_inverse"], ["proof (prove)\nusing this:\n  ?y \\<in> {as. proper_signed_list as} \\<Longrightarrow>\n  freeword (Abs_freeword ?y) = ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs;\n     order.greater_eq S (fst ` set xs)\\<rbrakk>\n    \\<Longrightarrow> Abs_freeword xs \\<in> FreeGroup S", "unfolding FreeGroup_def"], ["proof (prove)\nusing this:\n  ?y \\<in> {as. proper_signed_list as} \\<Longrightarrow>\n  freeword (Abs_freeword ?y) = ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs;\n     order.greater_eq S (fst ` set xs)\\<rbrakk>\n    \\<Longrightarrow> Abs_freeword xs\n                      \\<in> {x. order.greater_eq S (fst ` set (freeword x))}", "by fastforce"], ["", "lemma FreeGroupD: \"x \\<in> FreeGroup S \\<Longrightarrow> fst ` set (freeword x) \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> FreeGroup S \\<Longrightarrow>\n    order.greater_eq S (fst ` set (freeword x))", "using FreeGroup_def"], ["proof (prove)\nusing this:\n  FreeGroup ?S \\<equiv> {x. order.greater_eq ?S (fst ` set (freeword x))}\n\ngoal (1 subgoal):\n 1. x \\<in> FreeGroup S \\<Longrightarrow>\n    order.greater_eq S (fst ` set (freeword x))", "by fast"], ["", "lemma FreeGroupD_transfer:\n  \"proper_signed_list xs \\<Longrightarrow> Abs_freeword xs \\<in> FreeGroup S \\<Longrightarrow> fst ` set xs \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs;\n     Abs_freeword xs \\<in> FreeGroup S\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq S (fst ` set xs)", "using Abs_freeword_inverse"], ["proof (prove)\nusing this:\n  ?y \\<in> {as. proper_signed_list as} \\<Longrightarrow>\n  freeword (Abs_freeword ?y) = ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs;\n     Abs_freeword xs \\<in> FreeGroup S\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq S (fst ` set xs)", "unfolding FreeGroup_def"], ["proof (prove)\nusing this:\n  ?y \\<in> {as. proper_signed_list as} \\<Longrightarrow>\n  freeword (Abs_freeword ?y) = ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs;\n     Abs_freeword xs\n     \\<in> {x. order.greater_eq S (fst ` set (freeword x))}\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq S (fst ` set xs)", "by fastforce"], ["", "lemma FreeGroupD_transfer':\n  \"Abs_freelist xs \\<in> FreeGroup S \\<Longrightarrow> xs \\<in> lists S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_freelist xs \\<in> FreeGroup S \\<Longrightarrow> xs \\<in> lists S", "using proper_signed_list_map_uniform_snd FreeGroupD_transfer"], ["proof (prove)\nusing this:\n  proper_signed_list (map (\\<lambda>s. (s, ?b)) ?as)\n  \\<lbrakk>proper_signed_list ?xs;\n   Abs_freeword ?xs \\<in> FreeGroup ?S\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq ?S (fst ` set ?xs)\n\ngoal (1 subgoal):\n 1. Abs_freelist xs \\<in> FreeGroup S \\<Longrightarrow> xs \\<in> lists S", "by fastforce"], ["", "lemma FreeGroup_0_closed: \"0 \\<in> FreeGroup S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> FreeGroup S", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<in> FreeGroup S", "have \"(0::'a freeword) = Abs_freeword []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = Abs_freeword []", "using zero_freeword.abs_eq"], ["proof (prove)\nusing this:\n  0 = Abs_freeword []\n\ngoal (1 subgoal):\n 1. 0 = Abs_freeword []", "by fast"], ["proof (state)\nthis:\n  0 = Abs_freeword []\n\ngoal (1 subgoal):\n 1. 0 \\<in> FreeGroup S", "moreover"], ["proof (state)\nthis:\n  0 = Abs_freeword []\n\ngoal (1 subgoal):\n 1. 0 \\<in> FreeGroup S", "have \"Abs_freeword [] \\<in> FreeGroup S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_freeword [] \\<in> FreeGroup S", "using FreeGroupI_transfer[of \"[]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list [];\n   order.greater_eq ?S (fst ` set [])\\<rbrakk>\n  \\<Longrightarrow> Abs_freeword [] \\<in> FreeGroup ?S\n\ngoal (1 subgoal):\n 1. Abs_freeword [] \\<in> FreeGroup S", "by simp"], ["proof (state)\nthis:\n  Abs_freeword [] \\<in> FreeGroup S\n\ngoal (1 subgoal):\n 1. 0 \\<in> FreeGroup S", "ultimately"], ["proof (chain)\npicking this:\n  0 = Abs_freeword []\n  Abs_freeword [] \\<in> FreeGroup S", "show ?thesis"], ["proof (prove)\nusing this:\n  0 = Abs_freeword []\n  Abs_freeword [] \\<in> FreeGroup S\n\ngoal (1 subgoal):\n 1. 0 \\<in> FreeGroup S", "by simp"], ["proof (state)\nthis:\n  0 \\<in> FreeGroup S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FreeGroup_diff_closed:\n  assumes \"x \\<in> FreeGroup S\" \"y \\<in> FreeGroup S\"\n  shows   \"x-y \\<in> FreeGroup S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - y \\<in> FreeGroup S", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x - y \\<in> FreeGroup S", "define xs where xs: \"xs \\<equiv> freeword x\""], ["proof (state)\nthis:\n  xs \\<equiv> freeword x\n\ngoal (1 subgoal):\n 1. x - y \\<in> FreeGroup S", "define ys where ys: \"ys \\<equiv> freeword y\""], ["proof (state)\nthis:\n  ys \\<equiv> freeword y\n\ngoal (1 subgoal):\n 1. x - y \\<in> FreeGroup S", "have \"freeword (x-y) =\n        prappend_signed_list (freeword x) (rev (map flip_signed (freeword y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeword (x - y) =\n    prappend_signed_list (freeword x) (rev (map flip_signed (freeword y)))", "by transfer simp"], ["proof (state)\nthis:\n  freeword (x - y) =\n  prappend_signed_list (freeword x) (rev (map flip_signed (freeword y)))\n\ngoal (1 subgoal):\n 1. x - y \\<in> FreeGroup S", "hence \"fst ` set (freeword (x-y)) \\<subseteq> fst ` (set (freeword x) \\<union> set (freeword y))\""], ["proof (prove)\nusing this:\n  freeword (x - y) =\n  prappend_signed_list (freeword x) (rev (map flip_signed (freeword y)))\n\ngoal (1 subgoal):\n 1. order.greater_eq (fst ` (set (freeword x) \\<union> set (freeword y)))\n     (fst ` set (freeword (x - y)))", "using fst_set_prappend_signed_list"], ["proof (prove)\nusing this:\n  freeword (x - y) =\n  prappend_signed_list (freeword x) (rev (map flip_signed (freeword y)))\n  order.greater_eq (fst ` (set ?xs \\<union> set ?ys))\n   (fst ` set (prappend_signed_list ?xs ?ys))\n\ngoal (1 subgoal):\n 1. order.greater_eq (fst ` (set (freeword x) \\<union> set (freeword y)))\n     (fst ` set (freeword (x - y)))", "by force"], ["proof (state)\nthis:\n  order.greater_eq (fst ` (set (freeword x) \\<union> set (freeword y)))\n   (fst ` set (freeword (x - y)))\n\ngoal (1 subgoal):\n 1. x - y \\<in> FreeGroup S", "with assms"], ["proof (chain)\npicking this:\n  x \\<in> FreeGroup S\n  y \\<in> FreeGroup S\n  order.greater_eq (fst ` (set (freeword x) \\<union> set (freeword y)))\n   (fst ` set (freeword (x - y)))", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> FreeGroup S\n  y \\<in> FreeGroup S\n  order.greater_eq (fst ` (set (freeword x) \\<union> set (freeword y)))\n   (fst ` set (freeword (x - y)))\n\ngoal (1 subgoal):\n 1. x - y \\<in> FreeGroup S", "unfolding FreeGroup_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. order.greater_eq S (fst ` set (freeword x))}\n  y \\<in> {x. order.greater_eq S (fst ` set (freeword x))}\n  order.greater_eq (fst ` (set (freeword x) \\<union> set (freeword y)))\n   (fst ` set (freeword (x - y)))\n\ngoal (1 subgoal):\n 1. x - y \\<in> {x. order.greater_eq S (fst ` set (freeword x))}", "by fast"], ["proof (state)\nthis:\n  x - y \\<in> FreeGroup S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FreeGroup_Group: \"Group (FreeGroup S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group (FreeGroup S)", "using FreeGroup_0_closed FreeGroup_diff_closed"], ["proof (prove)\nusing this:\n  0 \\<in> FreeGroup ?S\n  \\<lbrakk>?x \\<in> FreeGroup ?S; ?y \\<in> FreeGroup ?S\\<rbrakk>\n  \\<Longrightarrow> ?x - ?y \\<in> FreeGroup ?S\n\ngoal (1 subgoal):\n 1. Group (FreeGroup S)", "by unfold_locales fast"], ["", "lemmas FreeGroup_add_closed    = Group.add_closed    [OF FreeGroup_Group]"], ["", "lemmas FreeGroup_uminus_closed = Group.uminus_closed [OF FreeGroup_Group]"], ["", "lemmas FreeGroup_genby_set_lconjby_set_rconjby_closed =\n  Group.genby_set_lconjby_set_rconjby_closed[OF FreeGroup_Group]"], ["", "lemma Abs_freelist_in_FreeGroup: \"ss \\<in> lists S \\<Longrightarrow> Abs_freelist ss \\<in> FreeGroup S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow> Abs_freelist ss \\<in> FreeGroup S", "using proper_signed_list_map_uniform_snd"], ["proof (prove)\nusing this:\n  proper_signed_list (map (\\<lambda>s. (s, ?b)) ?as)\n\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow> Abs_freelist ss \\<in> FreeGroup S", "by (fastforce intro: FreeGroupI_transfer)"], ["", "lemma Abs_freeletter_in_FreeGroup_iff: \"(Abs_freeletter s \\<in> FreeGroup S) = (s\\<in>S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_freeletter s \\<in> FreeGroup S) = (s \\<in> S)", "using Abs_freeword_inverse[of \"[pairtrue s]\"]"], ["proof (prove)\nusing this:\n  [pairtrue s] \\<in> {as. proper_signed_list as} \\<Longrightarrow>\n  freeword (Abs_freeletter s) = [pairtrue s]\n\ngoal (1 subgoal):\n 1. (Abs_freeletter s \\<in> FreeGroup S) = (s \\<in> S)", "unfolding FreeGroup_def"], ["proof (prove)\nusing this:\n  [pairtrue s] \\<in> {as. proper_signed_list as} \\<Longrightarrow>\n  freeword (Abs_freeletter s) = [pairtrue s]\n\ngoal (1 subgoal):\n 1. (Abs_freeletter s\n     \\<in> {x. order.greater_eq S (fst ` set (freeword x))}) =\n    (s \\<in> S)", "by simp"], ["", "paragraph \\<open>Lifts of functions from the letter set to some type of class @{class group_add}\\<close>"], ["", "text \\<open>\n  We again obtain a universal property for functions from the (restricted) letter set to some type\n  of class @{class group_add}.\n\\<close>"], ["", "abbreviation \"res_freeword_funlift f S \\<equiv>\n                restrict0 (freeword_funlift f) (FreeGroup S)\""], ["", "lemma freeword_funlift_im: \"x \\<in> FreeGroup S \\<Longrightarrow> freeword_funlift f x \\<in> \\<langle>f ` S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> FreeGroup S \\<Longrightarrow>\n    freeword_funlift f x \\<in> \\<langle>f ` S\\<rangle>", "using     freeword[of x] freeword_funlift_im'[of \"freeword x\"]\n            freeword_inverse[of x]"], ["proof (prove)\nusing this:\n  freeword x \\<in> {as. proper_signed_list as}\n  \\<lbrakk>proper_signed_list (freeword x);\n   order.greater_eq ?S (fst ` set (freeword x))\\<rbrakk>\n  \\<Longrightarrow> freeword_funlift ?f (Abs_freeword (freeword x))\n                    \\<in> \\<langle>?f ` ?S\\<rangle>\n  Abs_freeword (freeword x) = x\n\ngoal (1 subgoal):\n 1. x \\<in> FreeGroup S \\<Longrightarrow>\n    freeword_funlift f x \\<in> \\<langle>f ` S\\<rangle>", "unfolding FreeGroup_def"], ["proof (prove)\nusing this:\n  freeword x \\<in> {as. proper_signed_list as}\n  \\<lbrakk>proper_signed_list (freeword x);\n   order.greater_eq ?S (fst ` set (freeword x))\\<rbrakk>\n  \\<Longrightarrow> freeword_funlift ?f (Abs_freeword (freeword x))\n                    \\<in> \\<langle>?f ` ?S\\<rangle>\n  Abs_freeword (freeword x) = x\n\ngoal (1 subgoal):\n 1. x \\<in> {x. order.greater_eq S\n                 (fst ` set (freeword x))} \\<Longrightarrow>\n    freeword_funlift f x \\<in> \\<langle>f ` S\\<rangle>", "by        auto"], ["", "lemma freeword_funlift_surj':\n  \"ys \\<in> lists (f`S \\<union> uminus`f`S) \\<Longrightarrow> sum_list ys \\<in> freeword_funlift f ` FreeGroup S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> lists (f ` S \\<union> uminus ` f ` S) \\<Longrightarrow>\n    sum_list ys \\<in> freeword_funlift f ` FreeGroup S", "proof (induct ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> lists (f ` S \\<union> uminus ` f ` S) \\<Longrightarrow>\n    sum_list [] \\<in> freeword_funlift f ` FreeGroup S\n 2. \\<And>a ys.\n       \\<lbrakk>ys \\<in> lists\n                          (f ` S \\<union> uminus ` f ` S) \\<Longrightarrow>\n                sum_list ys \\<in> freeword_funlift f ` FreeGroup S;\n        a # ys \\<in> lists (f ` S \\<union> uminus ` f ` S)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ys)\n                         \\<in> freeword_funlift f ` FreeGroup S", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> lists (f ` S \\<union> uminus ` f ` S)\n\ngoal (2 subgoals):\n 1. [] \\<in> lists (f ` S \\<union> uminus ` f ` S) \\<Longrightarrow>\n    sum_list [] \\<in> freeword_funlift f ` FreeGroup S\n 2. \\<And>a ys.\n       \\<lbrakk>ys \\<in> lists\n                          (f ` S \\<union> uminus ` f ` S) \\<Longrightarrow>\n                sum_list ys \\<in> freeword_funlift f ` FreeGroup S;\n        a # ys \\<in> lists (f ` S \\<union> uminus ` f ` S)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ys)\n                         \\<in> freeword_funlift f ` FreeGroup S", "thus ?case"], ["proof (prove)\nusing this:\n  [] \\<in> lists (f ` S \\<union> uminus ` f ` S)\n\ngoal (1 subgoal):\n 1. sum_list [] \\<in> freeword_funlift f ` FreeGroup S", "using FreeGroup_0_closed freeword_funlift_0"], ["proof (prove)\nusing this:\n  [] \\<in> lists (f ` S \\<union> uminus ` f ` S)\n  0 \\<in> FreeGroup ?S\n  freeword_funlift ?f 0 = (0::?'h)\n\ngoal (1 subgoal):\n 1. sum_list [] \\<in> freeword_funlift f ` FreeGroup S", "by fastforce"], ["proof (state)\nthis:\n  sum_list [] \\<in> freeword_funlift f ` FreeGroup S\n\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>ys \\<in> lists\n                          (f ` S \\<union> uminus ` f ` S) \\<Longrightarrow>\n                sum_list ys \\<in> freeword_funlift f ` FreeGroup S;\n        a # ys \\<in> lists (f ` S \\<union> uminus ` f ` S)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ys)\n                         \\<in> freeword_funlift f ` FreeGroup S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>ys \\<in> lists\n                          (f ` S \\<union> uminus ` f ` S) \\<Longrightarrow>\n                sum_list ys \\<in> freeword_funlift f ` FreeGroup S;\n        a # ys \\<in> lists (f ` S \\<union> uminus ` f ` S)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ys)\n                         \\<in> freeword_funlift f ` FreeGroup S", "case (Cons y ys)"], ["proof (state)\nthis:\n  ys \\<in> lists (f ` S \\<union> uminus ` f ` S) \\<Longrightarrow>\n  sum_list ys \\<in> freeword_funlift f ` FreeGroup S\n  y # ys \\<in> lists (f ` S \\<union> uminus ` f ` S)\n\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>ys \\<in> lists\n                          (f ` S \\<union> uminus ` f ` S) \\<Longrightarrow>\n                sum_list ys \\<in> freeword_funlift f ` FreeGroup S;\n        a # ys \\<in> lists (f ` S \\<union> uminus ` f ` S)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ys)\n                         \\<in> freeword_funlift f ` FreeGroup S", "from this"], ["proof (chain)\npicking this:\n  ys \\<in> lists (f ` S \\<union> uminus ` f ` S) \\<Longrightarrow>\n  sum_list ys \\<in> freeword_funlift f ` FreeGroup S\n  y # ys \\<in> lists (f ` S \\<union> uminus ` f ` S)", "obtain x\n    where x: \"x \\<in> FreeGroup S\" \"sum_list ys = freeword_funlift f x\""], ["proof (prove)\nusing this:\n  ys \\<in> lists (f ` S \\<union> uminus ` f ` S) \\<Longrightarrow>\n  sum_list ys \\<in> freeword_funlift f ` FreeGroup S\n  y # ys \\<in> lists (f ` S \\<union> uminus ` f ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> FreeGroup S;\n         sum_list ys = freeword_funlift f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  x \\<in> FreeGroup S\n  sum_list ys = freeword_funlift f x\n\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>ys \\<in> lists\n                          (f ` S \\<union> uminus ` f ` S) \\<Longrightarrow>\n                sum_list ys \\<in> freeword_funlift f ` FreeGroup S;\n        a # ys \\<in> lists (f ` S \\<union> uminus ` f ` S)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ys)\n                         \\<in> freeword_funlift f ` FreeGroup S", "show \"sum_list (y#ys) \\<in> freeword_funlift f ` FreeGroup S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "proof (cases \"y \\<in> f`S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S\n 2. y \\<notin> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "case True"], ["proof (state)\nthis:\n  y \\<in> f ` S\n\ngoal (2 subgoals):\n 1. y \\<in> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S\n 2. y \\<notin> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "from this"], ["proof (chain)\npicking this:\n  y \\<in> f ` S", "obtain s where s: \"s\\<in>S\" \"y = f s\""], ["proof (prove)\nusing this:\n  y \\<in> f ` S\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> S; y = f s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  s \\<in> S\n  y = f s\n\ngoal (2 subgoals):\n 1. y \\<in> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S\n 2. y \\<notin> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "from s(1) x(1)"], ["proof (chain)\npicking this:\n  s \\<in> S\n  x \\<in> FreeGroup S", "have \"Abs_freeletter s + x \\<in> FreeGroup S\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  x \\<in> FreeGroup S\n\ngoal (1 subgoal):\n 1. Abs_freeletter s + x \\<in> FreeGroup S", "using FreeGroupI_transfer[of _ S] FreeGroup_add_closed[of _ S]"], ["proof (prove)\nusing this:\n  s \\<in> S\n  x \\<in> FreeGroup S\n  \\<lbrakk>proper_signed_list ?xs;\n   order.greater_eq S (fst ` set ?xs)\\<rbrakk>\n  \\<Longrightarrow> Abs_freeword ?xs \\<in> FreeGroup S\n  \\<lbrakk>?g \\<in> FreeGroup S; ?h \\<in> FreeGroup S\\<rbrakk>\n  \\<Longrightarrow> ?g + ?h \\<in> FreeGroup S\n\ngoal (1 subgoal):\n 1. Abs_freeletter s + x \\<in> FreeGroup S", "by force"], ["proof (state)\nthis:\n  Abs_freeletter s + x \\<in> FreeGroup S\n\ngoal (2 subgoals):\n 1. y \\<in> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S\n 2. y \\<notin> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "moreover"], ["proof (state)\nthis:\n  Abs_freeletter s + x \\<in> FreeGroup S\n\ngoal (2 subgoals):\n 1. y \\<in> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S\n 2. y \\<notin> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "from s(2) x(2)"], ["proof (chain)\npicking this:\n  y = f s\n  sum_list ys = freeword_funlift f x", "have  \"freeword_funlift f (Abs_freeletter s + x) = sum_list (y#ys)\""], ["proof (prove)\nusing this:\n  y = f s\n  sum_list ys = freeword_funlift f x\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeletter s + x) = sum_list (y # ys)", "using freeword_funlift_add[of f] freeword_funlift_Abs_freeletter"], ["proof (prove)\nusing this:\n  y = f s\n  sum_list ys = freeword_funlift f x\n  freeword_funlift f (?g + ?g') =\n  freeword_funlift f ?g + freeword_funlift f ?g'\n  freeword_funlift ?f (Abs_freeletter ?s) = ?f ?s\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeletter s + x) = sum_list (y # ys)", "by    simp"], ["proof (state)\nthis:\n  freeword_funlift f (Abs_freeletter s + x) = sum_list (y # ys)\n\ngoal (2 subgoals):\n 1. y \\<in> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S\n 2. y \\<notin> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "ultimately"], ["proof (chain)\npicking this:\n  Abs_freeletter s + x \\<in> FreeGroup S\n  freeword_funlift f (Abs_freeletter s + x) = sum_list (y # ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  Abs_freeletter s + x \\<in> FreeGroup S\n  freeword_funlift f (Abs_freeletter s + x) = sum_list (y # ys)\n\ngoal (1 subgoal):\n 1. sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "by force"], ["proof (state)\nthis:\n  sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S\n\ngoal (1 subgoal):\n 1. y \\<notin> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "case False"], ["proof (state)\nthis:\n  y \\<notin> f ` S\n\ngoal (1 subgoal):\n 1. y \\<notin> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "with Cons(2)"], ["proof (chain)\npicking this:\n  y # ys \\<in> lists (f ` S \\<union> uminus ` f ` S)\n  y \\<notin> f ` S", "obtain s where s: \"s\\<in>S\" \"y = - f s\""], ["proof (prove)\nusing this:\n  y # ys \\<in> lists (f ` S \\<union> uminus ` f ` S)\n  y \\<notin> f ` S\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> S; y = - f s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s \\<in> S\n  y = - f s\n\ngoal (1 subgoal):\n 1. y \\<notin> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "from s(1) x(1)"], ["proof (chain)\npicking this:\n  s \\<in> S\n  x \\<in> FreeGroup S", "have \"Abs_freeword [(s,False)] + x \\<in> FreeGroup S\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  x \\<in> FreeGroup S\n\ngoal (1 subgoal):\n 1. Abs_freeword [pairfalse s] + x \\<in> FreeGroup S", "using FreeGroupI_transfer[of _ S] FreeGroup_add_closed[of _ S]"], ["proof (prove)\nusing this:\n  s \\<in> S\n  x \\<in> FreeGroup S\n  \\<lbrakk>proper_signed_list ?xs;\n   order.greater_eq S (fst ` set ?xs)\\<rbrakk>\n  \\<Longrightarrow> Abs_freeword ?xs \\<in> FreeGroup S\n  \\<lbrakk>?g \\<in> FreeGroup S; ?h \\<in> FreeGroup S\\<rbrakk>\n  \\<Longrightarrow> ?g + ?h \\<in> FreeGroup S\n\ngoal (1 subgoal):\n 1. Abs_freeword [pairfalse s] + x \\<in> FreeGroup S", "by force"], ["proof (state)\nthis:\n  Abs_freeword [pairfalse s] + x \\<in> FreeGroup S\n\ngoal (1 subgoal):\n 1. y \\<notin> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "moreover"], ["proof (state)\nthis:\n  Abs_freeword [pairfalse s] + x \\<in> FreeGroup S\n\ngoal (1 subgoal):\n 1. y \\<notin> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "from s(2) x(2)"], ["proof (chain)\npicking this:\n  y = - f s\n  sum_list ys = freeword_funlift f x", "have  \"freeword_funlift f (Abs_freeword [(s,False)] + x) = sum_list (y#ys)\""], ["proof (prove)\nusing this:\n  y = - f s\n  sum_list ys = freeword_funlift f x\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword [pairfalse s] + x) = sum_list (y # ys)", "using freeword_funlift_add[of f] freeword_funlift_uminus_Abs_freeletter"], ["proof (prove)\nusing this:\n  y = - f s\n  sum_list ys = freeword_funlift f x\n  freeword_funlift f (?g + ?g') =\n  freeword_funlift f ?g + freeword_funlift f ?g'\n  freeword_funlift ?f (Abs_freeword [pairfalse ?s]) = - ?f ?s\n\ngoal (1 subgoal):\n 1. freeword_funlift f (Abs_freeword [pairfalse s] + x) = sum_list (y # ys)", "by    simp"], ["proof (state)\nthis:\n  freeword_funlift f (Abs_freeword [pairfalse s] + x) = sum_list (y # ys)\n\ngoal (1 subgoal):\n 1. y \\<notin> f ` S \\<Longrightarrow>\n    sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "ultimately"], ["proof (chain)\npicking this:\n  Abs_freeword [pairfalse s] + x \\<in> FreeGroup S\n  freeword_funlift f (Abs_freeword [pairfalse s] + x) = sum_list (y # ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  Abs_freeword [pairfalse s] + x \\<in> FreeGroup S\n  freeword_funlift f (Abs_freeword [pairfalse s] + x) = sum_list (y # ys)\n\ngoal (1 subgoal):\n 1. sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S", "by force"], ["proof (state)\nthis:\n  sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (y # ys) \\<in> freeword_funlift f ` FreeGroup S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freeword_funlift_surj:\n  fixes f :: \"'a \\<Rightarrow> 'b::group_add\"\n  shows \"freeword_funlift f ` FreeGroup S = \\<langle>f`S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeword_funlift f ` FreeGroup S = \\<langle>f ` S\\<rangle>", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> freeword_funlift f ` FreeGroup S \\<Longrightarrow>\n       x \\<in> \\<langle>f ` S\\<rangle>\n 2. \\<And>x.\n       x \\<in> \\<langle>f ` S\\<rangle> \\<Longrightarrow>\n       x \\<in> freeword_funlift f ` FreeGroup S", "show \"\\<And>a. a \\<in> freeword_funlift f ` FreeGroup S \\<Longrightarrow> a \\<in> \\<langle>f`S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> freeword_funlift f ` FreeGroup S \\<Longrightarrow>\n       a \\<in> \\<langle>f ` S\\<rangle>", "using freeword_funlift_im"], ["proof (prove)\nusing this:\n  ?x \\<in> FreeGroup ?S \\<Longrightarrow>\n  freeword_funlift ?f ?x \\<in> \\<langle>?f ` ?S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> freeword_funlift f ` FreeGroup S \\<Longrightarrow>\n       a \\<in> \\<langle>f ` S\\<rangle>", "by auto"], ["proof (state)\nthis:\n  ?a \\<in> freeword_funlift f ` FreeGroup S \\<Longrightarrow>\n  ?a \\<in> \\<langle>f ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>f ` S\\<rangle> \\<Longrightarrow>\n       x \\<in> freeword_funlift f ` FreeGroup S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>f ` S\\<rangle> \\<Longrightarrow>\n       x \\<in> freeword_funlift f ` FreeGroup S", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>f ` S\\<rangle> \\<Longrightarrow>\n       x \\<in> freeword_funlift f ` FreeGroup S", "assume \"w\\<in>\\<langle>f`S\\<rangle>\""], ["proof (state)\nthis:\n  w \\<in> \\<langle>f ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>f ` S\\<rangle> \\<Longrightarrow>\n       x \\<in> freeword_funlift f ` FreeGroup S", "from this"], ["proof (chain)\npicking this:\n  w \\<in> \\<langle>f ` S\\<rangle>", "obtain ys where ys: \"ys \\<in> lists (f`S \\<union> uminus`f`S)\" \"w = sum_list ys\""], ["proof (prove)\nusing this:\n  w \\<in> \\<langle>f ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>ys \\<in> lists (f ` S \\<union> uminus ` f ` S);\n         w = sum_list ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using genby_eq_sum_lists[of \"f`S\"]"], ["proof (prove)\nusing this:\n  w \\<in> \\<langle>f ` S\\<rangle>\n  \\<langle>f ` S\\<rangle> =\n  (\\<Union>ss\\<in>lists (f ` S \\<union> uminus ` f ` S). {sum_list ss})\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>ys \\<in> lists (f ` S \\<union> uminus ` f ` S);\n         w = sum_list ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ys \\<in> lists (f ` S \\<union> uminus ` f ` S)\n  w = sum_list ys\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>f ` S\\<rangle> \\<Longrightarrow>\n       x \\<in> freeword_funlift f ` FreeGroup S", "thus \"w \\<in> freeword_funlift f ` FreeGroup S\""], ["proof (prove)\nusing this:\n  ys \\<in> lists (f ` S \\<union> uminus ` f ` S)\n  w = sum_list ys\n\ngoal (1 subgoal):\n 1. w \\<in> freeword_funlift f ` FreeGroup S", "using freeword_funlift_surj'"], ["proof (prove)\nusing this:\n  ys \\<in> lists (f ` S \\<union> uminus ` f ` S)\n  w = sum_list ys\n  ?ys \\<in> lists (?f ` ?S \\<union> uminus ` ?f ` ?S) \\<Longrightarrow>\n  sum_list ?ys \\<in> freeword_funlift ?f ` FreeGroup ?S\n\ngoal (1 subgoal):\n 1. w \\<in> freeword_funlift f ` FreeGroup S", "by simp"], ["proof (state)\nthis:\n  w \\<in> freeword_funlift f ` FreeGroup S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_restrict0_freeword_funlift:\n  \"GroupHom (FreeGroup S) (res_freeword_funlift f S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupHom (FreeGroup S) (res_freeword_funlift f S)", "using UGroupHom.restrict0 additive_freeword_funlift FreeGroup_Group"], ["proof (prove)\nusing this:\n  \\<lbrakk>UGroupHom ?T; Group ?G\\<rbrakk>\n  \\<Longrightarrow> GroupHom ?G (restrict0 ?T ?G)\n  UGroupHom (freeword_funlift ?f)\n  Group (FreeGroup ?S)\n\ngoal (1 subgoal):\n 1. GroupHom (FreeGroup S) (res_freeword_funlift f S)", "by    auto"], ["", "lemma uniqueness_of_restricted_lift:\n  assumes \"GroupHom (FreeGroup S) T\" \"\\<forall>s\\<in>S. T (Abs_freeletter s) = f s\"\n  shows   \"T = res_freeword_funlift f S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T = res_freeword_funlift f S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. T a = res_freeword_funlift f S a", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. T a = res_freeword_funlift f S a", "define F where \"F \\<equiv> res_freeword_funlift f S\""], ["proof (state)\nthis:\n  F \\<equiv> res_freeword_funlift f S\n\ngoal (1 subgoal):\n 1. \\<And>a. T a = res_freeword_funlift f S a", "define u_Abs where \"u_Abs \\<equiv> \\<lambda>a::'a signed. apply_sign Abs_freeletter a\""], ["proof (state)\nthis:\n  u_Abs \\<equiv> apply_sign Abs_freeletter\n\ngoal (1 subgoal):\n 1. \\<And>a. T a = res_freeword_funlift f S a", "show \"T x = F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T x = F x", "proof (cases \"x \\<in> FreeGroup S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> FreeGroup S \\<Longrightarrow> T x = F x\n 2. x \\<notin> FreeGroup S \\<Longrightarrow> T x = F x", "case True"], ["proof (state)\nthis:\n  x \\<in> FreeGroup S\n\ngoal (2 subgoals):\n 1. x \\<in> FreeGroup S \\<Longrightarrow> T x = F x\n 2. x \\<notin> FreeGroup S \\<Longrightarrow> T x = F x", "have 1: \"set (map u_Abs (freeword x)) \\<subseteq> FreeGroup S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (FreeGroup S) (set (map u_Abs (freeword x)))", "using u_Abs_def FreeGroupD[OF True]\n            Abs_freeletter_in_FreeGroup_iff[of _ S]\n            FreeGroup_uminus_closed"], ["proof (prove)\nusing this:\n  u_Abs \\<equiv> apply_sign Abs_freeletter\n  order.greater_eq S (fst ` set (freeword x))\n  (Abs_freeletter ?s \\<in> FreeGroup S) = (?s \\<in> S)\n  ?g \\<in> FreeGroup ?S \\<Longrightarrow> - ?g \\<in> FreeGroup ?S\n\ngoal (1 subgoal):\n 1. order.greater_eq (FreeGroup S) (set (map u_Abs (freeword x)))", "by    auto"], ["proof (state)\nthis:\n  order.greater_eq (FreeGroup S) (set (map u_Abs (freeword x)))\n\ngoal (2 subgoals):\n 1. x \\<in> FreeGroup S \\<Longrightarrow> T x = F x\n 2. x \\<notin> FreeGroup S \\<Longrightarrow> T x = F x", "moreover"], ["proof (state)\nthis:\n  order.greater_eq (FreeGroup S) (set (map u_Abs (freeword x)))\n\ngoal (2 subgoals):\n 1. x \\<in> FreeGroup S \\<Longrightarrow> T x = F x\n 2. x \\<notin> FreeGroup S \\<Longrightarrow> T x = F x", "from u_Abs_def"], ["proof (chain)\npicking this:\n  u_Abs \\<equiv> apply_sign Abs_freeletter", "have  \"x = (\\<Sum>a\\<leftarrow>freeword x. u_Abs a)\""], ["proof (prove)\nusing this:\n  u_Abs \\<equiv> apply_sign Abs_freeletter\n\ngoal (1 subgoal):\n 1. x = sum_list (map u_Abs (freeword x))", "using freeword_conv_freeletter_sum_list"], ["proof (prove)\nusing this:\n  u_Abs \\<equiv> apply_sign Abs_freeletter\n  ?x = sum_list (map (apply_sign Abs_freeletter) (freeword ?x))\n\ngoal (1 subgoal):\n 1. x = sum_list (map u_Abs (freeword x))", "by fast"], ["proof (state)\nthis:\n  x = sum_list (map u_Abs (freeword x))\n\ngoal (2 subgoals):\n 1. x \\<in> FreeGroup S \\<Longrightarrow> T x = F x\n 2. x \\<notin> FreeGroup S \\<Longrightarrow> T x = F x", "ultimately"], ["proof (chain)\npicking this:\n  order.greater_eq (FreeGroup S) (set (map u_Abs (freeword x)))\n  x = sum_list (map u_Abs (freeword x))", "have  \"T x = (\\<Sum>a\\<leftarrow>freeword x. T (u_Abs a))\"\n            \"F x = (\\<Sum>a\\<leftarrow>freeword x. F (u_Abs a))\""], ["proof (prove)\nusing this:\n  order.greater_eq (FreeGroup S) (set (map u_Abs (freeword x)))\n  x = sum_list (map u_Abs (freeword x))\n\ngoal (1 subgoal):\n 1. T x = (\\<Sum>a\\<leftarrow>freeword x. T (u_Abs a)) &&&\n    F x = (\\<Sum>a\\<leftarrow>freeword x. F (u_Abs a))", "using F_def\n            GroupHom.im_sum_list_map[OF assms(1), of u_Abs \"freeword x\"]\n            GroupHom.im_sum_list_map[\n              OF hom_restrict0_freeword_funlift,\n              of u_Abs \"freeword x\" S f\n            ]"], ["proof (prove)\nusing this:\n  order.greater_eq (FreeGroup S) (set (map u_Abs (freeword x)))\n  x = sum_list (map u_Abs (freeword x))\n  F \\<equiv> res_freeword_funlift f S\n  order.greater_eq (FreeGroup S)\n   (set (map u_Abs (freeword x))) \\<Longrightarrow>\n  T (sum_list (map u_Abs (freeword x))) =\n  (\\<Sum>a\\<leftarrow>freeword x. T (u_Abs a))\n  order.greater_eq (FreeGroup S)\n   (set (map u_Abs (freeword x))) \\<Longrightarrow>\n  res_freeword_funlift f S (sum_list (map u_Abs (freeword x))) =\n  (\\<Sum>a\\<leftarrow>freeword x. res_freeword_funlift f S (u_Abs a))\n\ngoal (1 subgoal):\n 1. T x = (\\<Sum>a\\<leftarrow>freeword x. T (u_Abs a)) &&&\n    F x = (\\<Sum>a\\<leftarrow>freeword x. F (u_Abs a))", "by auto"], ["proof (state)\nthis:\n  T x = (\\<Sum>a\\<leftarrow>freeword x. T (u_Abs a))\n  F x = (\\<Sum>a\\<leftarrow>freeword x. F (u_Abs a))\n\ngoal (2 subgoals):\n 1. x \\<in> FreeGroup S \\<Longrightarrow> T x = F x\n 2. x \\<notin> FreeGroup S \\<Longrightarrow> T x = F x", "moreover"], ["proof (state)\nthis:\n  T x = (\\<Sum>a\\<leftarrow>freeword x. T (u_Abs a))\n  F x = (\\<Sum>a\\<leftarrow>freeword x. F (u_Abs a))\n\ngoal (2 subgoals):\n 1. x \\<in> FreeGroup S \\<Longrightarrow> T x = F x\n 2. x \\<notin> FreeGroup S \\<Longrightarrow> T x = F x", "have \"\\<forall>a\\<in>set (freeword x). T (u_Abs a) = F (u_Abs a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (freeword x). T (u_Abs a) = F (u_Abs a)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> set (freeword x) \\<Longrightarrow> T (u_Abs a) = F (u_Abs a)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> set (freeword x) \\<Longrightarrow> T (u_Abs a) = F (u_Abs a)", "assume \"a \\<in> set (freeword x)\""], ["proof (state)\nthis:\n  a \\<in> set (freeword x)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> set (freeword x) \\<Longrightarrow> T (u_Abs a) = F (u_Abs a)", "moreover"], ["proof (state)\nthis:\n  a \\<in> set (freeword x)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> set (freeword x) \\<Longrightarrow> T (u_Abs a) = F (u_Abs a)", "define b where \"b \\<equiv> Abs_freeletter (fst a)\""], ["proof (state)\nthis:\n  b \\<equiv> Abs_freeletter (fst a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> set (freeword x) \\<Longrightarrow> T (u_Abs a) = F (u_Abs a)", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> set (freeword x)\n  b \\<equiv> Abs_freeletter (fst a)", "show \"T (u_Abs a) = F (u_Abs a)\""], ["proof (prove)\nusing this:\n  a \\<in> set (freeword x)\n  b \\<equiv> Abs_freeletter (fst a)\n\ngoal (1 subgoal):\n 1. T (u_Abs a) = F (u_Abs a)", "using F_def u_Abs_def True assms(2) FreeGroupD[of x S]\n              GroupHom.im_uminus[OF assms(1)] \n              Abs_freeletter_in_FreeGroup_iff[of \"fst a\" S]\n              GroupHom.im_uminus[OF hom_restrict0_freeword_funlift, of b S f]\n              freeword_funlift_Abs_freeletter[of f]"], ["proof (prove)\nusing this:\n  a \\<in> set (freeword x)\n  b \\<equiv> Abs_freeletter (fst a)\n  F \\<equiv> res_freeword_funlift f S\n  u_Abs \\<equiv> apply_sign Abs_freeletter\n  x \\<in> FreeGroup S\n  \\<forall>s\\<in>S. T (Abs_freeletter s) = f s\n  x \\<in> FreeGroup S \\<Longrightarrow>\n  order.greater_eq S (fst ` set (freeword x))\n  T (- ?g) = - T ?g\n  (Abs_freeletter (fst a) \\<in> FreeGroup S) = (fst a \\<in> S)\n  res_freeword_funlift f S (- b) = - res_freeword_funlift f S b\n  freeword_funlift f (Abs_freeletter ?s) = f ?s\n\ngoal (1 subgoal):\n 1. T (u_Abs a) = F (u_Abs a)", "by    auto"], ["proof (state)\nthis:\n  T (u_Abs a) = F (u_Abs a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (freeword x). T (u_Abs a) = F (u_Abs a)\n\ngoal (2 subgoals):\n 1. x \\<in> FreeGroup S \\<Longrightarrow> T x = F x\n 2. x \\<notin> FreeGroup S \\<Longrightarrow> T x = F x", "ultimately"], ["proof (chain)\npicking this:\n  T x = (\\<Sum>a\\<leftarrow>freeword x. T (u_Abs a))\n  F x = (\\<Sum>a\\<leftarrow>freeword x. F (u_Abs a))\n  \\<forall>a\\<in>set (freeword x). T (u_Abs a) = F (u_Abs a)", "show ?thesis"], ["proof (prove)\nusing this:\n  T x = (\\<Sum>a\\<leftarrow>freeword x. T (u_Abs a))\n  F x = (\\<Sum>a\\<leftarrow>freeword x. F (u_Abs a))\n  \\<forall>a\\<in>set (freeword x). T (u_Abs a) = F (u_Abs a)\n\ngoal (1 subgoal):\n 1. T x = F x", "using F_def\n            sum_list_map_cong[of \"freeword x\" \"\\<lambda>s. T (u_Abs s)\" \"\\<lambda>s. F (u_Abs s)\"]"], ["proof (prove)\nusing this:\n  T x = (\\<Sum>a\\<leftarrow>freeword x. T (u_Abs a))\n  F x = (\\<Sum>a\\<leftarrow>freeword x. F (u_Abs a))\n  \\<forall>a\\<in>set (freeword x). T (u_Abs a) = F (u_Abs a)\n  F \\<equiv> res_freeword_funlift f S\n  (\\<And>xa.\n      xa \\<in> set (freeword x) \\<Longrightarrow>\n      T (u_Abs xa) = F (u_Abs xa)) \\<Longrightarrow>\n  (\\<Sum>s\\<leftarrow>freeword x. T (u_Abs s)) =\n  (\\<Sum>s\\<leftarrow>freeword x. F (u_Abs s))\n\ngoal (1 subgoal):\n 1. T x = F x", "by    simp"], ["proof (state)\nthis:\n  T x = F x\n\ngoal (1 subgoal):\n 1. x \\<notin> FreeGroup S \\<Longrightarrow> T x = F x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> FreeGroup S \\<Longrightarrow> T x = F x", "case False"], ["proof (state)\nthis:\n  x \\<notin> FreeGroup S\n\ngoal (1 subgoal):\n 1. x \\<notin> FreeGroup S \\<Longrightarrow> T x = F x", "with assms(1) F_def"], ["proof (chain)\npicking this:\n  GroupHom (FreeGroup S) T\n  F \\<equiv> res_freeword_funlift f S\n  x \\<notin> FreeGroup S", "show ?thesis"], ["proof (prove)\nusing this:\n  GroupHom (FreeGroup S) T\n  F \\<equiv> res_freeword_funlift f S\n  x \\<notin> FreeGroup S\n\ngoal (1 subgoal):\n 1. T x = F x", "using hom_restrict0_freeword_funlift GroupHom.supp suppI_contra[of x T]\n            suppI_contra[of x F]"], ["proof (prove)\nusing this:\n  GroupHom (FreeGroup S) T\n  F \\<equiv> res_freeword_funlift f S\n  x \\<notin> FreeGroup S\n  GroupHom (FreeGroup ?S) (res_freeword_funlift ?f ?S)\n  GroupHom ?G ?T \\<Longrightarrow> order.greater_eq ?G (supp ?T)\n  x \\<notin> supp T \\<Longrightarrow> T x = (0::'b)\n  x \\<notin> supp F \\<Longrightarrow> F x = (0::'b)\n\ngoal (1 subgoal):\n 1. T x = F x", "by    fastforce"], ["proof (state)\nthis:\n  T x = F x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T x = F x\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem FreeGroup_universal_property:\n  fixes f :: \"'a \\<Rightarrow> 'b::group_add\"\n  shows \"\\<exists>!T::'a freeword\\<Rightarrow>'b. (\\<forall>s\\<in>S. T (Abs_freeletter s) = f s) \\<and>\n          GroupHom (FreeGroup S) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!T.\n       (\\<forall>s\\<in>S. T (Abs_freeletter s) = f s) \\<and>\n       GroupHom (FreeGroup S) T", "proof (rule ex1I, rule conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>s\\<in>S. ?a (Abs_freeletter s) = f s\n 2. GroupHom (FreeGroup S) ?a\n 3. \\<And>T.\n       (\\<forall>s\\<in>S. T (Abs_freeletter s) = f s) \\<and>\n       GroupHom (FreeGroup S) T \\<Longrightarrow>\n       T = ?a", "show \"\\<forall>s\\<in>S. res_freeword_funlift f S (Abs_freeletter s) = f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. res_freeword_funlift f S (Abs_freeletter s) = f s", "using Abs_freeletter_in_FreeGroup_iff[of _ S] freeword_funlift_Abs_freeletter"], ["proof (prove)\nusing this:\n  (Abs_freeletter ?s \\<in> FreeGroup S) = (?s \\<in> S)\n  freeword_funlift ?f (Abs_freeletter ?s) = ?f ?s\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. res_freeword_funlift f S (Abs_freeletter s) = f s", "by    auto"], ["proof (state)\nthis:\n  \\<forall>s\\<in>S. res_freeword_funlift f S (Abs_freeletter s) = f s\n\ngoal (2 subgoals):\n 1. GroupHom (FreeGroup S) (res_freeword_funlift f S)\n 2. \\<And>T.\n       (\\<forall>s\\<in>S. T (Abs_freeletter s) = f s) \\<and>\n       GroupHom (FreeGroup S) T \\<Longrightarrow>\n       T = res_freeword_funlift f S", "show \"\\<And>T. (\\<forall>s\\<in>S. T (Abs_freeletter s) = f s) \\<and>\n          GroupHom (FreeGroup S) T \\<Longrightarrow>\n          T = restrict0 (freeword_funlift f) (FreeGroup S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T.\n       (\\<forall>s\\<in>S. T (Abs_freeletter s) = f s) \\<and>\n       GroupHom (FreeGroup S) T \\<Longrightarrow>\n       T = res_freeword_funlift f S", "using uniqueness_of_restricted_lift"], ["proof (prove)\nusing this:\n  \\<lbrakk>GroupHom (FreeGroup ?S) ?T;\n   \\<forall>s\\<in>?S. ?T (Abs_freeletter s) = ?f s\\<rbrakk>\n  \\<Longrightarrow> ?T = res_freeword_funlift ?f ?S\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       (\\<forall>s\\<in>S. T (Abs_freeletter s) = f s) \\<and>\n       GroupHom (FreeGroup S) T \\<Longrightarrow>\n       T = res_freeword_funlift f S", "by auto"], ["proof (state)\nthis:\n  (\\<forall>s\\<in>S. ?T (Abs_freeletter s) = f s) \\<and>\n  GroupHom (FreeGroup S) ?T \\<Longrightarrow>\n  ?T = res_freeword_funlift f S\n\ngoal (1 subgoal):\n 1. GroupHom (FreeGroup S) (res_freeword_funlift f S)", "qed (rule hom_restrict0_freeword_funlift)"], ["", "subsubsection \\<open>Group presentations\\<close>"], ["", "text \\<open>\n  We now define a group presentation to be the quotient of a free group by the subgroup generated by\n  all conjugates of a set of relators. We are most concerned with lifting functions on the letter\n  set to the free group and with the associated induced homomorphisms on the quotient.\n\\<close>"], ["", "paragraph \\<open>A first group presentation locale and basic facts\\<close>"], ["", "text \\<open>\n  Here we define a locale that provides a way to construct a group by providing sets of generators\n  and relator words.\n\\<close>"], ["", "locale GroupByPresentation =\n  fixes   S :: \"'a set\"  \\<comment> \\<open>the set of generators\\<close>\n  and     P :: \"'a signed list set\" \\<comment> \\<open>the set of relator words\\<close>\n  assumes P_S: \"ps\\<in>P \\<Longrightarrow> fst ` set ps \\<subseteq> S\"\n  and     proper_P: \"ps\\<in>P \\<Longrightarrow> proper_signed_list ps\"\nbegin"], ["", "abbreviation \"P' \\<equiv> Abs_freeword ` P\" \\<comment> \\<open>the set of relators\\<close>"], ["", "abbreviation \"Q \\<equiv> Group.normal_closure (FreeGroup S) P'\"\n\\<comment> \\<open>the normal subgroup generated by relators inside the free group\\<close>"], ["", "abbreviation \"G \\<equiv> Group.quotient_group (FreeGroup S) Q\""], ["", "lemmas G_UN = Group.quotient_group_UN[OF FreeGroup_Group, of S Q]"], ["", "lemma P'_FreeS: \"P' \\<subseteq> FreeGroup S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (FreeGroup S) P'", "using P_S proper_P"], ["proof (prove)\nusing this:\n  ?ps \\<in> P \\<Longrightarrow> order.greater_eq S (fst ` set ?ps)\n  ?ps \\<in> P \\<Longrightarrow> proper_signed_list ?ps\n\ngoal (1 subgoal):\n 1. order.greater_eq (FreeGroup S) P'", "by (blast intro: FreeGroupI_transfer)"], ["", "lemma relators: \"P' \\<subseteq> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle> P'", "using FreeGroup_0_closed genby_genset_subset"], ["proof (prove)\nusing this:\n  0 \\<in> FreeGroup ?S\n  order.greater_eq \\<langle>?S\\<rangle> ?S\n\ngoal (1 subgoal):\n 1. order.greater_eq\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle> P'", "by fastforce"], ["", "lemmas lconjby_P'_FreeS =\n  Group.set_lconjby_subset_closed[\n    OF FreeGroup_Group _ P'_FreeS, OF basic_monos(1)\n  ]"], ["", "lemmas Q_FreeS =\n  Group.genby_closed[OF FreeGroup_Group lconjby_P'_FreeS]"], ["", "lemmas Q_subgroup_FreeS =\n  Group.genby_subgroup[OF FreeGroup_Group lconjby_P'_FreeS]"], ["", "lemmas normal_Q = Group.normal_closure[OF FreeGroup_Group, OF P'_FreeS]"], ["", "lemmas natural_hom =\n  Group.natural_quotient_hom[\n    OF FreeGroup_Group Q_subgroup_FreeS normal_Q\n  ]"], ["", "lemmas natural_hom_image =\n  Group.natural_quotient_hom_image[OF FreeGroup_Group, of S Q]"], ["", "end"], ["", "(* context GroupByPresentation *)"], ["", "paragraph \\<open>Functions on the quotient induced from lifted functions\\<close>"], ["", "text \\<open>\n  A function on the generator set into a type of class @{class group_add} lifts to a unique\n  homomorphism on the free group. If this lift is trivial on relators, then it factors to a\n  homomorphism of the group described by the generators and relators.\n\\<close>"], ["", "locale GroupByPresentationInducedFun = GroupByPresentation S P\n  for     S :: \"'a set\"\n  and     P :: \"'a signed list set\" \\<comment> \\<open>the set of relator words\\<close>\n+ fixes   f :: \"'a \\<Rightarrow> 'b::group_add\"\n  assumes lift_f_trivial_P:\n    \"ps\\<in>P \\<Longrightarrow> freeword_funlift f (Abs_freeword ps) = 0\"\nbegin"], ["", "abbreviation \"lift_f \\<equiv> freeword_funlift f\""], ["", "definition induced_hom :: \"'a freeword set permutation \\<Rightarrow> 'b\"\n  where \"induced_hom \\<equiv> GroupHom.quotient_hom (FreeGroup S)\n          (restrict0 lift_f (FreeGroup S)) Q\"\n  \\<comment> \\<open>the @{const restrict0} operation is really only necessary to make\n@{const GroupByPresentationInducedFun.induced_hom} a @{const GroupHom}\\<close>"], ["", "abbreviation \"F \\<equiv> induced_hom\""], ["", "lemma lift_f_trivial_P': \"p\\<in>P' \\<Longrightarrow> lift_f p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> P' \\<Longrightarrow> lift_f p = (0::'b)", "using lift_f_trivial_P"], ["proof (prove)\nusing this:\n  ?ps \\<in> P \\<Longrightarrow> lift_f (Abs_freeword ?ps) = (0::'b)\n\ngoal (1 subgoal):\n 1. p \\<in> P' \\<Longrightarrow> lift_f p = (0::'b)", "by fast"], ["", "lemma lift_f_trivial_lconjby_P': \"p\\<in>P' \\<Longrightarrow> lift_f (lconjby w p) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> P' \\<Longrightarrow> lift_f (lconjby w p) = (0::'b)", "using freeword_funlift_lconjby[of f] lift_f_trivial_P'"], ["proof (prove)\nusing this:\n  lift_f (lconjby ?x ?g) = lconjby (lift_f ?x) (lift_f ?g)\n  ?p \\<in> P' \\<Longrightarrow> lift_f ?p = (0::'b)\n\ngoal (1 subgoal):\n 1. p \\<in> P' \\<Longrightarrow> lift_f (lconjby w p) = (0::'b)", "by simp"], ["", "lemma lift_f_trivial_Q: \"q\\<in>Q \\<Longrightarrow> lift_f q = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                        lconjby g ` P'\\<rangle> \\<Longrightarrow>\n    lift_f q = (0::'b)", "proof (erule genby.induct, rule freeword_funlift_0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> (\\<Union>g\\<in>FreeGroup S. lconjby g ` P') \\<Longrightarrow>\n       lift_f s = (0::'b)\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                    lconjby g ` P'\\<rangle>;\n        lift_f w = (0::'b);\n        w' \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                             lconjby g ` P'\\<rangle>;\n        lift_f w' = (0::'b)\\<rbrakk>\n       \\<Longrightarrow> lift_f (w - w') = (0::'b)", "show \"\\<And>s. s \\<in> (\\<Union>w \\<in> FreeGroup S. lconjby w ` P') \\<Longrightarrow> lift_f s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> (\\<Union>w\\<in>FreeGroup S. lconjby w ` P') \\<Longrightarrow>\n       lift_f s = (0::'b)", "using lift_f_trivial_lconjby_P'"], ["proof (prove)\nusing this:\n  ?p \\<in> P' \\<Longrightarrow> lift_f (lconjby ?w ?p) = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> (\\<Union>w\\<in>FreeGroup S. lconjby w ` P') \\<Longrightarrow>\n       lift_f s = (0::'b)", "by fast"], ["proof (state)\nthis:\n  ?s \\<in> (\\<Union>w\\<in>FreeGroup S. lconjby w ` P') \\<Longrightarrow>\n  lift_f ?s = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                    lconjby g ` P'\\<rangle>;\n        lift_f w = (0::'b);\n        w' \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                             lconjby g ` P'\\<rangle>;\n        lift_f w' = (0::'b)\\<rbrakk>\n       \\<Longrightarrow> lift_f (w - w') = (0::'b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                    lconjby g ` P'\\<rangle>;\n        lift_f w = (0::'b);\n        w' \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                             lconjby g ` P'\\<rangle>;\n        lift_f w' = (0::'b)\\<rbrakk>\n       \\<Longrightarrow> lift_f (w - w') = (0::'b)", "fix w w' :: \"'a freeword\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                    lconjby g ` P'\\<rangle>;\n        lift_f w = (0::'b);\n        w' \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                             lconjby g ` P'\\<rangle>;\n        lift_f w' = (0::'b)\\<rbrakk>\n       \\<Longrightarrow> lift_f (w - w') = (0::'b)", "assume ww': \"lift_f w = 0\" \"lift_f w' = 0\""], ["proof (state)\nthis:\n  lift_f w = (0::'b)\n  lift_f w' = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                    lconjby g ` P'\\<rangle>;\n        lift_f w = (0::'b);\n        w' \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                             lconjby g ` P'\\<rangle>;\n        lift_f w' = (0::'b)\\<rbrakk>\n       \\<Longrightarrow> lift_f (w - w') = (0::'b)", "have \"lift_f (w - w') = lift_f w - lift_f w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_f (w - w') = lift_f w - lift_f w'", "using freeword_funlift_diff[of f w]"], ["proof (prove)\nusing this:\n  lift_f (w - ?g') = lift_f w - lift_f ?g'\n\ngoal (1 subgoal):\n 1. lift_f (w - w') = lift_f w - lift_f w'", "by simp"], ["proof (state)\nthis:\n  lift_f (w - w') = lift_f w - lift_f w'\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                    lconjby g ` P'\\<rangle>;\n        lift_f w = (0::'b);\n        w' \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                             lconjby g ` P'\\<rangle>;\n        lift_f w' = (0::'b)\\<rbrakk>\n       \\<Longrightarrow> lift_f (w - w') = (0::'b)", "with ww'"], ["proof (chain)\npicking this:\n  lift_f w = (0::'b)\n  lift_f w' = (0::'b)\n  lift_f (w - w') = lift_f w - lift_f w'", "show \"lift_f (w-w') = 0\""], ["proof (prove)\nusing this:\n  lift_f w = (0::'b)\n  lift_f w' = (0::'b)\n  lift_f (w - w') = lift_f w - lift_f w'\n\ngoal (1 subgoal):\n 1. lift_f (w - w') = (0::'b)", "by simp"], ["proof (state)\nthis:\n  lift_f (w - w') = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_f_ker_Q: \"Q \\<subseteq> ker lift_f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (ker lift_f)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "using lift_f_trivial_Q"], ["proof (prove)\nusing this:\n  ?q \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g ` P'\\<rangle> \\<Longrightarrow>\n  lift_f ?q = (0::'b)\n\ngoal (1 subgoal):\n 1. order.greater_eq (ker lift_f)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "unfolding ker_def"], ["proof (prove)\nusing this:\n  ?q \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g ` P'\\<rangle> \\<Longrightarrow>\n  lift_f ?q = (0::'b)\n\ngoal (1 subgoal):\n 1. order.greater_eq {a. lift_f a = (0::'b)}\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "by auto"], ["", "lemma lift_f_Ker_Q: \"Q \\<subseteq> GroupHom.Ker (FreeGroup S) lift_f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (ker lift_f \\<inter> FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "using lift_f_ker_Q Q_FreeS"], ["proof (prove)\nusing this:\n  order.greater_eq (ker lift_f)\n   \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>\n  order.greater_eq (FreeGroup S)\n   \\<langle>\\<Union>h\\<in>FreeGroup S. lconjby h ` P'\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq (ker lift_f \\<inter> FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "by fast"], ["", "lemma restrict0_lift_f_Ker_Q:\n  \"Q \\<subseteq> GroupHom.Ker (FreeGroup S) (restrict0 lift_f (FreeGroup S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (ker (res_freeword_funlift f S) \\<inter> FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "using lift_f_Ker_Q ker_subset_ker_restrict0"], ["proof (prove)\nusing this:\n  order.greater_eq (ker lift_f \\<inter> FreeGroup S)\n   \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>\n  order.greater_eq (ker (restrict0 ?f ?A)) (ker ?f)\n\ngoal (1 subgoal):\n 1. order.greater_eq (ker (res_freeword_funlift f S) \\<inter> FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "by fast"], ["", "lemma induced_hom_equality:\n  \"w \\<in> FreeGroup S \\<Longrightarrow> F (\\<lceil>FreeGroup S|w|Q\\<rceil>) = lift_f w\"\n\\<comment> \\<open>algebraic properties of the induced homomorphism could be proved using its properties as a group\n  homomorphism, but it's generally easier to prove them using the algebraic properties of the lift\n  via this lemma\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> FreeGroup S \\<Longrightarrow>\n    F (BinOpSetGroup.Abs_G_perm\n        (FreeGroup S //\n         Restr\n          (lcoset_rel\n            \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n          (FreeGroup S))\n        (+)\n        (Restr\n          (lcoset_rel\n            \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n          (FreeGroup S) ``\n         {w})) =\n    lift_f w", "unfolding induced_hom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> FreeGroup S \\<Longrightarrow>\n    restrict0\n     (quotientfun (res_freeword_funlift f S) \\<circ>\n      the_inv_into\n       (FreeGroup S //\n        Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S))\n       (BinOpSetGroup.Abs_G_perm\n         (FreeGroup S //\n          Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S))\n         (+)))\n     (BinOpSetGroup.Abs_G_perm\n       (FreeGroup S //\n        Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S))\n       (+) `\n      FreeGroup S //\n      Restr\n       (lcoset_rel\n         \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n       (FreeGroup S))\n     (BinOpSetGroup.Abs_G_perm\n       (FreeGroup S //\n        Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S))\n       (+)\n       (Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S) ``\n        {w})) =\n    lift_f w", "using     GroupHom.quotient_hom_im hom_restrict0_freeword_funlift\n            Q_subgroup_FreeS normal_Q restrict0_lift_f_Ker_Q"], ["proof (prove)\nusing this:\n  \\<lbrakk>GroupHom ?G ?T; Group ?H \\<and> order.greater_eq ?G ?H;\n   Group.normal ?G ?H; order.greater_eq (ker ?T \\<inter> ?G) ?H;\n   ?g \\<in> ?G\\<rbrakk>\n  \\<Longrightarrow> restrict0\n                     (quotientfun ?T \\<circ>\n                      the_inv_into (?G // Restr (lcoset_rel ?H) ?G)\n                       (BinOpSetGroup.Abs_G_perm\n                         (?G // Restr (lcoset_rel ?H) ?G) (+)))\n                     (BinOpSetGroup.Abs_G_perm\n                       (?G // Restr (lcoset_rel ?H) ?G) (+) `\n                      ?G // Restr (lcoset_rel ?H) ?G)\n                     (BinOpSetGroup.Abs_G_perm\n                       (?G // Restr (lcoset_rel ?H) ?G) (+)\n                       (Restr (lcoset_rel ?H) ?G `` {?g})) =\n                    ?T ?g\n  GroupHom (FreeGroup ?S) (res_freeword_funlift ?f ?S)\n  Group \\<langle>\\<Union>h\\<in>FreeGroup S. lconjby h ` P'\\<rangle> \\<and>\n  order.greater_eq (FreeGroup S)\n   \\<langle>\\<Union>h\\<in>FreeGroup S. lconjby h ` P'\\<rangle>\n  Group.normal (FreeGroup S)\n   \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>\n  order.greater_eq (ker (res_freeword_funlift f S) \\<inter> FreeGroup S)\n   \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>\n\ngoal (1 subgoal):\n 1. w \\<in> FreeGroup S \\<Longrightarrow>\n    restrict0\n     (quotientfun (res_freeword_funlift f S) \\<circ>\n      the_inv_into\n       (FreeGroup S //\n        Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S))\n       (BinOpSetGroup.Abs_G_perm\n         (FreeGroup S //\n          Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S))\n         (+)))\n     (BinOpSetGroup.Abs_G_perm\n       (FreeGroup S //\n        Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S))\n       (+) `\n      FreeGroup S //\n      Restr\n       (lcoset_rel\n         \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n       (FreeGroup S))\n     (BinOpSetGroup.Abs_G_perm\n       (FreeGroup S //\n        Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S))\n       (+)\n       (Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S) ``\n        {w})) =\n    lift_f w", "by        fastforce"], ["", "lemma hom_induced_hom: \"GroupHom G F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupHom\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n     F", "unfolding induced_hom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupHom\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n     (restrict0\n       (quotientfun (res_freeword_funlift f S) \\<circ>\n        the_inv_into\n         (FreeGroup S //\n          Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S))\n         (BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)))\n       (BinOpSetGroup.Abs_G_perm\n         (FreeGroup S //\n          Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S))\n         (+) `\n        FreeGroup S //\n        Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S)))", "using     GroupHom.quotient_hom hom_restrict0_freeword_funlift\n            Q_subgroup_FreeS normal_Q restrict0_lift_f_Ker_Q"], ["proof (prove)\nusing this:\n  \\<lbrakk>GroupHom ?G ?T; Group ?H \\<and> order.greater_eq ?G ?H;\n   Group.normal ?G ?H; order.greater_eq (ker ?T \\<inter> ?G) ?H\\<rbrakk>\n  \\<Longrightarrow> GroupHom (Group.quotient_group ?G ?H)\n                     (restrict0\n                       (quotientfun ?T \\<circ>\n                        the_inv_into (?G // Restr (lcoset_rel ?H) ?G)\n                         (BinOpSetGroup.Abs_G_perm\n                           (?G // Restr (lcoset_rel ?H) ?G) (+)))\n                       (BinOpSetGroup.Abs_G_perm\n                         (?G // Restr (lcoset_rel ?H) ?G) (+) `\n                        ?G // Restr (lcoset_rel ?H) ?G))\n  GroupHom (FreeGroup ?S) (res_freeword_funlift ?f ?S)\n  Group \\<langle>\\<Union>h\\<in>FreeGroup S. lconjby h ` P'\\<rangle> \\<and>\n  order.greater_eq (FreeGroup S)\n   \\<langle>\\<Union>h\\<in>FreeGroup S. lconjby h ` P'\\<rangle>\n  Group.normal (FreeGroup S)\n   \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>\n  order.greater_eq (ker (res_freeword_funlift f S) \\<inter> FreeGroup S)\n   \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>\n\ngoal (1 subgoal):\n 1. GroupHom\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n     (restrict0\n       (quotientfun (res_freeword_funlift f S) \\<circ>\n        the_inv_into\n         (FreeGroup S //\n          Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S))\n         (BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)))\n       (BinOpSetGroup.Abs_G_perm\n         (FreeGroup S //\n          Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S))\n         (+) `\n        FreeGroup S //\n        Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S)))", "by        fast"], ["", "lemma induced_hom_Abs_freeletter_equality:\n  \"s\\<in>S \\<Longrightarrow> F (\\<lceil>FreeGroup S|Abs_freeletter s|Q\\<rceil>) = f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow>\n    F (BinOpSetGroup.Abs_G_perm\n        (FreeGroup S //\n         Restr\n          (lcoset_rel\n            \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n          (FreeGroup S))\n        (+)\n        (Restr\n          (lcoset_rel\n            \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n          (FreeGroup S) ``\n         {Abs_freeletter s})) =\n    f s", "using Abs_freeletter_in_FreeGroup_iff[of s S]"], ["proof (prove)\nusing this:\n  (Abs_freeletter s \\<in> FreeGroup S) = (s \\<in> S)\n\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow>\n    F (BinOpSetGroup.Abs_G_perm\n        (FreeGroup S //\n         Restr\n          (lcoset_rel\n            \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n          (FreeGroup S))\n        (+)\n        (Restr\n          (lcoset_rel\n            \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n          (FreeGroup S) ``\n         {Abs_freeletter s})) =\n    f s", "by    (simp add: induced_hom_equality freeword_funlift_Abs_freeletter)"], ["", "lemma uniqueness_of_induced_hom':\n  defines \"q \\<equiv> Group.natural_quotient_hom (FreeGroup S) Q\"\n  assumes \"GroupHom G T\" \"\\<forall>s\\<in>S. T (\\<lceil>FreeGroup S|Abs_freeletter s|Q\\<rceil>) = f s\"\n  shows   \"T \\<circ> q = F \\<circ> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<circ> q = F \\<circ> q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. T \\<circ> q = F \\<circ> q", "from assms"], ["proof (chain)\npicking this:\n  q \\<equiv>\n  \\<lambda>a.\n     if a \\<in> FreeGroup S\n     then BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)\n           (Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S) ``\n            {a})\n     else 0\n  GroupHom\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n   T\n  \\<forall>s\\<in>S.\n     T (BinOpSetGroup.Abs_G_perm\n         (FreeGroup S //\n          Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S))\n         (+)\n         (Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S) ``\n          {Abs_freeletter s})) =\n     f s", "have \"T\\<circ>q = res_freeword_funlift f S\""], ["proof (prove)\nusing this:\n  q \\<equiv>\n  \\<lambda>a.\n     if a \\<in> FreeGroup S\n     then BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)\n           (Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S) ``\n            {a})\n     else 0\n  GroupHom\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n   T\n  \\<forall>s\\<in>S.\n     T (BinOpSetGroup.Abs_G_perm\n         (FreeGroup S //\n          Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S))\n         (+)\n         (Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S) ``\n          {Abs_freeletter s})) =\n     f s\n\ngoal (1 subgoal):\n 1. T \\<circ> q = res_freeword_funlift f S", "using natural_hom natural_hom_image Abs_freeletter_in_FreeGroup_iff[of _ S]"], ["proof (prove)\nusing this:\n  q \\<equiv>\n  \\<lambda>a.\n     if a \\<in> FreeGroup S\n     then BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)\n           (Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S) ``\n            {a})\n     else 0\n  GroupHom\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n   T\n  \\<forall>s\\<in>S.\n     T (BinOpSetGroup.Abs_G_perm\n         (FreeGroup S //\n          Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S))\n         (+)\n         (Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S) ``\n          {Abs_freeletter s})) =\n     f s\n  GroupHom (FreeGroup S)\n   (\\<lambda>a.\n       if a \\<in> FreeGroup S\n       then BinOpSetGroup.Abs_G_perm\n             (FreeGroup S //\n              Restr\n               (lcoset_rel\n                 \\<langle>\\<Union>g\\<in>FreeGroup S.\n                             lconjby g ` P'\\<rangle>)\n               (FreeGroup S))\n             (+)\n             (Restr\n               (lcoset_rel\n                 \\<langle>\\<Union>g\\<in>FreeGroup S.\n                             lconjby g ` P'\\<rangle>)\n               (FreeGroup S) ``\n              {a})\n       else 0)\n  (\\<lambda>a.\n      if a \\<in> FreeGroup S\n      then BinOpSetGroup.Abs_G_perm\n            (FreeGroup S //\n             Restr\n              (lcoset_rel\n                \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n              (FreeGroup S))\n            (+)\n            (Restr\n              (lcoset_rel\n                \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n              (FreeGroup S) ``\n             {a})\n      else 0) `\n  FreeGroup S =\n  Group.quotient_group (FreeGroup S)\n   \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>\n  (Abs_freeletter ?s \\<in> FreeGroup S) = (?s \\<in> S)\n\ngoal (1 subgoal):\n 1. T \\<circ> q = res_freeword_funlift f S", "by    (force intro: uniqueness_of_restricted_lift GroupHom.comp)"], ["proof (state)\nthis:\n  T \\<circ> q = res_freeword_funlift f S\n\ngoal (1 subgoal):\n 1. T \\<circ> q = F \\<circ> q", "moreover"], ["proof (state)\nthis:\n  T \\<circ> q = res_freeword_funlift f S\n\ngoal (1 subgoal):\n 1. T \\<circ> q = F \\<circ> q", "from q_def"], ["proof (chain)\npicking this:\n  q \\<equiv>\n  \\<lambda>a.\n     if a \\<in> FreeGroup S\n     then BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)\n           (Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S) ``\n            {a})\n     else 0", "have \"F \\<circ> q = res_freeword_funlift f S\""], ["proof (prove)\nusing this:\n  q \\<equiv>\n  \\<lambda>a.\n     if a \\<in> FreeGroup S\n     then BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)\n           (Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S) ``\n            {a})\n     else 0\n\ngoal (1 subgoal):\n 1. F \\<circ> q = res_freeword_funlift f S", "using induced_hom_equality GroupHom.im_zero[OF hom_induced_hom]"], ["proof (prove)\nusing this:\n  q \\<equiv>\n  \\<lambda>a.\n     if a \\<in> FreeGroup S\n     then BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)\n           (Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S) ``\n            {a})\n     else 0\n  ?w \\<in> FreeGroup S \\<Longrightarrow>\n  F (BinOpSetGroup.Abs_G_perm\n      (FreeGroup S //\n       Restr\n        (lcoset_rel\n          \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n        (FreeGroup S))\n      (+)\n      (Restr\n        (lcoset_rel\n          \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n        (FreeGroup S) ``\n       {?w})) =\n  lift_f ?w\n  F 0 = (0::'b)\n\ngoal (1 subgoal):\n 1. F \\<circ> q = res_freeword_funlift f S", "by    auto"], ["proof (state)\nthis:\n  F \\<circ> q = res_freeword_funlift f S\n\ngoal (1 subgoal):\n 1. T \\<circ> q = F \\<circ> q", "ultimately"], ["proof (chain)\npicking this:\n  T \\<circ> q = res_freeword_funlift f S\n  F \\<circ> q = res_freeword_funlift f S", "show ?thesis"], ["proof (prove)\nusing this:\n  T \\<circ> q = res_freeword_funlift f S\n  F \\<circ> q = res_freeword_funlift f S\n\ngoal (1 subgoal):\n 1. T \\<circ> q = F \\<circ> q", "by simp"], ["proof (state)\nthis:\n  T \\<circ> q = F \\<circ> q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uniqueness_of_induced_hom:\n  assumes \"GroupHom G T\" \"\\<forall>s\\<in>S. T (\\<lceil>FreeGroup S|Abs_freeletter s|Q\\<rceil>) = f s\"\n  shows   \"T = F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T = F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. T x = F x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. T x = F x", "show \"T x = F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T x = F x", "proof (cases \"x\\<in>G\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> Group.quotient_group (FreeGroup S)\n             \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g ` P'\\<rangle> \\<Longrightarrow>\n    T x = F x\n 2. x \\<notin> Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g ` P'\\<rangle> \\<Longrightarrow>\n    T x = F x", "case True"], ["proof (state)\nthis:\n  x \\<in> Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>\n\ngoal (2 subgoals):\n 1. x \\<in> Group.quotient_group (FreeGroup S)\n             \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g ` P'\\<rangle> \\<Longrightarrow>\n    T x = F x\n 2. x \\<notin> Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g ` P'\\<rangle> \\<Longrightarrow>\n    T x = F x", "define q where \"q \\<equiv> Group.natural_quotient_hom (FreeGroup S) Q\""], ["proof (state)\nthis:\n  q \\<equiv>\n  \\<lambda>a.\n     if a \\<in> FreeGroup S\n     then BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)\n           (Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S) ``\n            {a})\n     else 0\n\ngoal (2 subgoals):\n 1. x \\<in> Group.quotient_group (FreeGroup S)\n             \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g ` P'\\<rangle> \\<Longrightarrow>\n    T x = F x\n 2. x \\<notin> Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g ` P'\\<rangle> \\<Longrightarrow>\n    T x = F x", "from True"], ["proof (chain)\npicking this:\n  x \\<in> Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "obtain w where \"w \\<in> FreeGroup S\" \"x = (\\<lceil>FreeGroup S|w|Q\\<rceil>)\""], ["proof (prove)\nusing this:\n  x \\<in> Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> FreeGroup S;\n         x =\n         BinOpSetGroup.Abs_G_perm\n          (FreeGroup S //\n           Restr\n            (lcoset_rel\n              \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n            (FreeGroup S))\n          (+)\n          (Restr\n            (lcoset_rel\n              \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n            (FreeGroup S) ``\n           {w})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using G_UN"], ["proof (prove)\nusing this:\n  x \\<in> Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>\n  Group.quotient_group (FreeGroup S)\n   \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle> =\n  (\\<lambda>g.\n      BinOpSetGroup.Abs_G_perm\n       (FreeGroup S //\n        Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S))\n       (+)\n       (Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S) ``\n        {g})) `\n  FreeGroup S\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> FreeGroup S;\n         x =\n         BinOpSetGroup.Abs_G_perm\n          (FreeGroup S //\n           Restr\n            (lcoset_rel\n              \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n            (FreeGroup S))\n          (+)\n          (Restr\n            (lcoset_rel\n              \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n            (FreeGroup S) ``\n           {w})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  w \\<in> FreeGroup S\n  x =\n  BinOpSetGroup.Abs_G_perm\n   (FreeGroup S //\n    Restr\n     (lcoset_rel\n       \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n     (FreeGroup S))\n   (+)\n   (Restr\n     (lcoset_rel\n       \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n     (FreeGroup S) ``\n    {w})\n\ngoal (2 subgoals):\n 1. x \\<in> Group.quotient_group (FreeGroup S)\n             \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g ` P'\\<rangle> \\<Longrightarrow>\n    T x = F x\n 2. x \\<notin> Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g ` P'\\<rangle> \\<Longrightarrow>\n    T x = F x", "with q_def"], ["proof (chain)\npicking this:\n  q \\<equiv>\n  \\<lambda>a.\n     if a \\<in> FreeGroup S\n     then BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)\n           (Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S) ``\n            {a})\n     else 0\n  w \\<in> FreeGroup S\n  x =\n  BinOpSetGroup.Abs_G_perm\n   (FreeGroup S //\n    Restr\n     (lcoset_rel\n       \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n     (FreeGroup S))\n   (+)\n   (Restr\n     (lcoset_rel\n       \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n     (FreeGroup S) ``\n    {w})", "have \"T x = (T\\<circ>q) w\" \"F x = (F\\<circ>q) w\""], ["proof (prove)\nusing this:\n  q \\<equiv>\n  \\<lambda>a.\n     if a \\<in> FreeGroup S\n     then BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)\n           (Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S) ``\n            {a})\n     else 0\n  w \\<in> FreeGroup S\n  x =\n  BinOpSetGroup.Abs_G_perm\n   (FreeGroup S //\n    Restr\n     (lcoset_rel\n       \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n     (FreeGroup S))\n   (+)\n   (Restr\n     (lcoset_rel\n       \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n     (FreeGroup S) ``\n    {w})\n\ngoal (1 subgoal):\n 1. T x = (T \\<circ> q) w &&& F x = (F \\<circ> q) w", "by auto"], ["proof (state)\nthis:\n  T x = (T \\<circ> q) w\n  F x = (F \\<circ> q) w\n\ngoal (2 subgoals):\n 1. x \\<in> Group.quotient_group (FreeGroup S)\n             \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g ` P'\\<rangle> \\<Longrightarrow>\n    T x = F x\n 2. x \\<notin> Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g ` P'\\<rangle> \\<Longrightarrow>\n    T x = F x", "with assms q_def"], ["proof (chain)\npicking this:\n  GroupHom\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n   T\n  \\<forall>s\\<in>S.\n     T (BinOpSetGroup.Abs_G_perm\n         (FreeGroup S //\n          Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S))\n         (+)\n         (Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S) ``\n          {Abs_freeletter s})) =\n     f s\n  q \\<equiv>\n  \\<lambda>a.\n     if a \\<in> FreeGroup S\n     then BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)\n           (Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S) ``\n            {a})\n     else 0\n  T x = (T \\<circ> q) w\n  F x = (F \\<circ> q) w", "show ?thesis"], ["proof (prove)\nusing this:\n  GroupHom\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n   T\n  \\<forall>s\\<in>S.\n     T (BinOpSetGroup.Abs_G_perm\n         (FreeGroup S //\n          Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S))\n         (+)\n         (Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S) ``\n          {Abs_freeletter s})) =\n     f s\n  q \\<equiv>\n  \\<lambda>a.\n     if a \\<in> FreeGroup S\n     then BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)\n           (Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S) ``\n            {a})\n     else 0\n  T x = (T \\<circ> q) w\n  F x = (F \\<circ> q) w\n\ngoal (1 subgoal):\n 1. T x = F x", "using uniqueness_of_induced_hom'"], ["proof (prove)\nusing this:\n  GroupHom\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n   T\n  \\<forall>s\\<in>S.\n     T (BinOpSetGroup.Abs_G_perm\n         (FreeGroup S //\n          Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S))\n         (+)\n         (Restr\n           (lcoset_rel\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n           (FreeGroup S) ``\n          {Abs_freeletter s})) =\n     f s\n  q \\<equiv>\n  \\<lambda>a.\n     if a \\<in> FreeGroup S\n     then BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)\n           (Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S) ``\n            {a})\n     else 0\n  T x = (T \\<circ> q) w\n  F x = (F \\<circ> q) w\n  \\<lbrakk>GroupHom\n            (Group.quotient_group (FreeGroup S)\n              \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n            ?T;\n   \\<forall>s\\<in>S.\n      ?T (BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)\n           (Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S) ``\n            {Abs_freeletter s})) =\n      f s\\<rbrakk>\n  \\<Longrightarrow> ?T \\<circ>\n                    (\\<lambda>a.\n                        if a \\<in> FreeGroup S\n                        then BinOpSetGroup.Abs_G_perm\n                              (FreeGroup S //\n                               Restr\n                                (lcoset_rel\n                                  \\<langle>\\<Union>g\\<in>FreeGroup S.\n        lconjby g ` P'\\<rangle>)\n                                (FreeGroup S))\n                              (+)\n                              (Restr\n                                (lcoset_rel\n                                  \\<langle>\\<Union>g\\<in>FreeGroup S.\n        lconjby g ` P'\\<rangle>)\n                                (FreeGroup S) ``\n                               {a})\n                        else 0) =\n                    F \\<circ>\n                    (\\<lambda>a.\n                        if a \\<in> FreeGroup S\n                        then BinOpSetGroup.Abs_G_perm\n                              (FreeGroup S //\n                               Restr\n                                (lcoset_rel\n                                  \\<langle>\\<Union>g\\<in>FreeGroup S.\n        lconjby g ` P'\\<rangle>)\n                                (FreeGroup S))\n                              (+)\n                              (Restr\n                                (lcoset_rel\n                                  \\<langle>\\<Union>g\\<in>FreeGroup S.\n        lconjby g ` P'\\<rangle>)\n                                (FreeGroup S) ``\n                               {a})\n                        else 0)\n\ngoal (1 subgoal):\n 1. T x = F x", "by simp"], ["proof (state)\nthis:\n  T x = F x\n\ngoal (1 subgoal):\n 1. x \\<notin> Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g ` P'\\<rangle> \\<Longrightarrow>\n    T x = F x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g ` P'\\<rangle> \\<Longrightarrow>\n    T x = F x", "case False"], ["proof (state)\nthis:\n  x \\<notin> Group.quotient_group (FreeGroup S)\n              \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<notin> Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g ` P'\\<rangle> \\<Longrightarrow>\n    T x = F x", "with assms(1)"], ["proof (chain)\npicking this:\n  GroupHom\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n   T\n  x \\<notin> Group.quotient_group (FreeGroup S)\n              \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  GroupHom\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n   T\n  x \\<notin> Group.quotient_group (FreeGroup S)\n              \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>\n\ngoal (1 subgoal):\n 1. T x = F x", "using hom_induced_hom GroupHom.supp suppI_contra[of x T]\n            suppI_contra[of x F]"], ["proof (prove)\nusing this:\n  GroupHom\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n   T\n  x \\<notin> Group.quotient_group (FreeGroup S)\n              \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>\n  GroupHom\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n   F\n  GroupHom ?G ?T \\<Longrightarrow> order.greater_eq ?G (supp ?T)\n  x \\<notin> supp T \\<Longrightarrow> T x = (0::'b)\n  x \\<notin> supp F \\<Longrightarrow> F x = (0::'b)\n\ngoal (1 subgoal):\n 1. T x = F x", "by    fastforce"], ["proof (state)\nthis:\n  T x = F x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T x = F x\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem induced_hom_universal_property:\n  \"\\<exists>!F. GroupHom G F \\<and> (\\<forall>s\\<in>S. F (\\<lceil>FreeGroup S|Abs_freeletter s|Q\\<rceil>) = f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!F.\n       GroupHom\n        (Group.quotient_group (FreeGroup S)\n          \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n        F \\<and>\n       (\\<forall>s\\<in>S.\n           F (BinOpSetGroup.Abs_G_perm\n               (FreeGroup S //\n                Restr\n                 (lcoset_rel\n                   \\<langle>\\<Union>g\\<in>FreeGroup S.\n                               lconjby g ` P'\\<rangle>)\n                 (FreeGroup S))\n               (+)\n               (Restr\n                 (lcoset_rel\n                   \\<langle>\\<Union>g\\<in>FreeGroup S.\n                               lconjby g ` P'\\<rangle>)\n                 (FreeGroup S) ``\n                {Abs_freeletter s})) =\n           f s)", "using hom_induced_hom induced_hom_Abs_freeletter_equality\n        uniqueness_of_induced_hom"], ["proof (prove)\nusing this:\n  GroupHom\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n   F\n  ?s \\<in> S \\<Longrightarrow>\n  F (BinOpSetGroup.Abs_G_perm\n      (FreeGroup S //\n       Restr\n        (lcoset_rel\n          \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n        (FreeGroup S))\n      (+)\n      (Restr\n        (lcoset_rel\n          \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n        (FreeGroup S) ``\n       {Abs_freeletter ?s})) =\n  f ?s\n  \\<lbrakk>GroupHom\n            (Group.quotient_group (FreeGroup S)\n              \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n            ?T;\n   \\<forall>s\\<in>S.\n      ?T (BinOpSetGroup.Abs_G_perm\n           (FreeGroup S //\n            Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S))\n           (+)\n           (Restr\n             (lcoset_rel\n               \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n             (FreeGroup S) ``\n            {Abs_freeletter s})) =\n      f s\\<rbrakk>\n  \\<Longrightarrow> ?T = F\n\ngoal (1 subgoal):\n 1. \\<exists>!F.\n       GroupHom\n        (Group.quotient_group (FreeGroup S)\n          \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n        F \\<and>\n       (\\<forall>s\\<in>S.\n           F (BinOpSetGroup.Abs_G_perm\n               (FreeGroup S //\n                Restr\n                 (lcoset_rel\n                   \\<langle>\\<Union>g\\<in>FreeGroup S.\n                               lconjby g ` P'\\<rangle>)\n                 (FreeGroup S))\n               (+)\n               (Restr\n                 (lcoset_rel\n                   \\<langle>\\<Union>g\\<in>FreeGroup S.\n                               lconjby g ` P'\\<rangle>)\n                 (FreeGroup S) ``\n                {Abs_freeletter s})) =\n           f s)", "by    blast"], ["", "lemma induced_hom_Abs_freelist_conv_sum_list:\n  \"ss\\<in>lists S \\<Longrightarrow> F (\\<lceil>FreeGroup S|Abs_freelist ss|Q\\<rceil>) = (\\<Sum>s\\<leftarrow>ss. f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    F (BinOpSetGroup.Abs_G_perm\n        (FreeGroup S //\n         Restr\n          (lcoset_rel\n            \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n          (FreeGroup S))\n        (+)\n        (Restr\n          (lcoset_rel\n            \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n          (FreeGroup S) ``\n         {Abs_freelist ss})) =\n    sum_list (map f ss)", "by  (simp add:\n        Abs_freelist_in_FreeGroup induced_hom_equality freeword_funlift_Abs_freelist\n      )"], ["", "lemma induced_hom_surj: \"F`G = \\<langle>f`S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F `\n    Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle> =\n    \\<langle>f ` S\\<rangle>", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> F `\n               Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g ` P'\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>f ` S\\<rangle>\n 2. \\<And>x.\n       x \\<in> \\<langle>f ` S\\<rangle> \\<Longrightarrow>\n       x \\<in> F `\n               Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "show \"\\<And>x. x\\<in>F`G \\<Longrightarrow> x\\<in>\\<langle>f`S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F `\n               Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g ` P'\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>f ` S\\<rangle>", "using G_UN induced_hom_equality freeword_funlift_surj[of f S]"], ["proof (prove)\nusing this:\n  Group.quotient_group (FreeGroup S)\n   \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle> =\n  (\\<lambda>g.\n      BinOpSetGroup.Abs_G_perm\n       (FreeGroup S //\n        Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S))\n       (+)\n       (Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S) ``\n        {g})) `\n  FreeGroup S\n  ?w \\<in> FreeGroup S \\<Longrightarrow>\n  F (BinOpSetGroup.Abs_G_perm\n      (FreeGroup S //\n       Restr\n        (lcoset_rel\n          \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n        (FreeGroup S))\n      (+)\n      (Restr\n        (lcoset_rel\n          \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n        (FreeGroup S) ``\n       {?w})) =\n  lift_f ?w\n  lift_f ` FreeGroup S = \\<langle>f ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F `\n               Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g ` P'\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>f ` S\\<rangle>", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> F `\n           Group.quotient_group (FreeGroup S)\n            \\<langle>\\<Union>g\\<in>FreeGroup S.\n                        lconjby g ` P'\\<rangle> \\<Longrightarrow>\n  ?x \\<in> \\<langle>f ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>f ` S\\<rangle> \\<Longrightarrow>\n       x \\<in> F `\n               Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>f ` S\\<rangle> \\<Longrightarrow>\n       x \\<in> F `\n               Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>f ` S\\<rangle> \\<Longrightarrow>\n       x \\<in> F `\n               Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "assume \"x\\<in>\\<langle>f`S\\<rangle>\""], ["proof (state)\nthis:\n  x \\<in> \\<langle>f ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>f ` S\\<rangle> \\<Longrightarrow>\n       x \\<in> F `\n               Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "hence \"x \\<in> lift_f ` FreeGroup S\""], ["proof (prove)\nusing this:\n  x \\<in> \\<langle>f ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> lift_f ` FreeGroup S", "using freeword_funlift_surj[of f S]"], ["proof (prove)\nusing this:\n  x \\<in> \\<langle>f ` S\\<rangle>\n  lift_f ` FreeGroup S = \\<langle>f ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> lift_f ` FreeGroup S", "by fast"], ["proof (state)\nthis:\n  x \\<in> lift_f ` FreeGroup S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>f ` S\\<rangle> \\<Longrightarrow>\n       x \\<in> F `\n               Group.quotient_group (FreeGroup S)\n                \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "thus \"x \\<in> F`G\""], ["proof (prove)\nusing this:\n  x \\<in> lift_f ` FreeGroup S\n\ngoal (1 subgoal):\n 1. x \\<in> F `\n            Group.quotient_group (FreeGroup S)\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "using induced_hom_equality G_UN"], ["proof (prove)\nusing this:\n  x \\<in> lift_f ` FreeGroup S\n  ?w \\<in> FreeGroup S \\<Longrightarrow>\n  F (BinOpSetGroup.Abs_G_perm\n      (FreeGroup S //\n       Restr\n        (lcoset_rel\n          \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n        (FreeGroup S))\n      (+)\n      (Restr\n        (lcoset_rel\n          \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n        (FreeGroup S) ``\n       {?w})) =\n  lift_f ?w\n  Group.quotient_group (FreeGroup S)\n   \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle> =\n  (\\<lambda>g.\n      BinOpSetGroup.Abs_G_perm\n       (FreeGroup S //\n        Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S))\n       (+)\n       (Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>)\n         (FreeGroup S) ``\n        {g})) `\n  FreeGroup S\n\ngoal (1 subgoal):\n 1. x \\<in> F `\n            Group.quotient_group (FreeGroup S)\n             \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>", "by force"], ["proof (state)\nthis:\n  x \\<in> F `\n          Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S. lconjby g ` P'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context GroupByPresentationInducedFun *)"], ["", "paragraph \\<open>Groups affording a presentation\\<close>"], ["", "text \\<open>\n  The locale @{const GroupByPresentation} allows the construction of a @{const Group} out of any\n  type from a set of generating letters and a set of relator words in (signed) letters. The\n  following locale concerns the question of when the @{const Group} generated by a set in class\n  @{class group_add} is isomorphic to a group presentation.\n\\<close>"], ["", "locale GroupWithGeneratorsRelators =\n  fixes S :: \"'g::group_add set\" \\<comment> \\<open>the set of generators\\<close>\n  and   R :: \"'g list set\" \\<comment> \\<open>the set of relator words\\<close>\n  assumes relators: \"rs\\<in>R \\<Longrightarrow> rs \\<in> lists (S \\<union> uminus ` S)\"\n                    \"rs\\<in>R \\<Longrightarrow> sum_list rs = 0\"\n                    \"rs\\<in>R \\<Longrightarrow> proper_signed_list (map (charpair S) rs)\"\nbegin"], ["", "abbreviation \"P \\<equiv> map (charpair S) ` R\""], ["", "abbreviation \"P' \\<equiv> GroupByPresentation.P' P\""], ["", "abbreviation \"Q \\<equiv> GroupByPresentation.Q S P\""], ["", "abbreviation \"G \\<equiv> GroupByPresentation.G S P\""], ["", "abbreviation \"relator_freeword rs \\<equiv> Abs_freeword (map (charpair S) rs)\"\n\\<comment> \\<open>this maps R onto P'\\<close>"], ["", "abbreviation \"freeliftid \\<equiv> freeword_funlift id\""], ["", "abbreviation induced_id :: \"'g freeword set permutation \\<Rightarrow> 'g\"\n  where \"induced_id \\<equiv> GroupByPresentationInducedFun.induced_hom S P id\""], ["", "lemma GroupByPresentation_S_P: \"GroupByPresentation S P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupByPresentation S P", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ps. ps \\<in> P \\<Longrightarrow> order.greater_eq S (fst ` set ps)\n 2. \\<And>ps. ps \\<in> P \\<Longrightarrow> proper_signed_list ps", "show \"\\<And>ps. ps \\<in> P \\<Longrightarrow> fst ` set ps \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> P \\<Longrightarrow> order.greater_eq S (fst ` set ps)", "using fst_set_map_charpair_un_uminus relators(1)"], ["proof (prove)\nusing this:\n  ?ss \\<in> lists (?S \\<union> uminus ` ?S) \\<Longrightarrow>\n  order.greater_eq ?S (fst ` set (map (charpair ?S) ?ss))\n  ?rs \\<in> R \\<Longrightarrow> ?rs \\<in> lists (S \\<union> uminus ` S)\n\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> P \\<Longrightarrow> order.greater_eq S (fst ` set ps)", "by fast"], ["proof (state)\nthis:\n  ?ps \\<in> P \\<Longrightarrow> order.greater_eq S (fst ` set ?ps)\n\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> P \\<Longrightarrow> proper_signed_list ps", "show \"\\<And>ps. ps \\<in> P \\<Longrightarrow> proper_signed_list ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> P \\<Longrightarrow> proper_signed_list ps", "using relators(3)"], ["proof (prove)\nusing this:\n  ?rs \\<in> R \\<Longrightarrow> proper_signed_list (map (charpair S) ?rs)\n\ngoal (1 subgoal):\n 1. \\<And>ps. ps \\<in> P \\<Longrightarrow> proper_signed_list ps", "by fast"], ["proof (state)\nthis:\n  ?ps \\<in> P \\<Longrightarrow> proper_signed_list ?ps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas G_UN     = GroupByPresentation.G_UN[OF GroupByPresentation_S_P]"], ["", "lemmas P'_FreeS = GroupByPresentation.P'_FreeS[OF GroupByPresentation_S_P]"], ["", "lemma freeliftid_trivial_relator_freeword_R:\n  \"rs\\<in>R \\<Longrightarrow> freeliftid (relator_freeword rs) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<in> R \\<Longrightarrow>\n    freeword_funlift id (relator_freeword rs) = (0::'g)", "using relators(2,3) freeword_funlift_Abs_freeword[of \"map (charpair S) rs\" id]\n        sum_list_map_cong[of rs \"(apply_sign id) \\<circ> (charpair S)\" id]"], ["proof (prove)\nusing this:\n  ?rs \\<in> R \\<Longrightarrow> sum_list ?rs = (0::'g)\n  ?rs \\<in> R \\<Longrightarrow> proper_signed_list (map (charpair S) ?rs)\n  proper_signed_list (map (charpair S) rs) \\<Longrightarrow>\n  freeword_funlift id (relator_freeword rs) =\n  sum_list (map (apply_sign id) (map (charpair S) rs))\n  (\\<And>x.\n      x \\<in> set rs \\<Longrightarrow>\n      (apply_sign id \\<circ> charpair S) x = id x) \\<Longrightarrow>\n  sum_list (map (apply_sign id \\<circ> charpair S) rs) =\n  sum_list (map id rs)\n\ngoal (1 subgoal):\n 1. rs \\<in> R \\<Longrightarrow>\n    freeword_funlift id (relator_freeword rs) = (0::'g)", "by    simp"], ["", "lemma freeliftid_trivial_P: \"ps\\<in>P \\<Longrightarrow> freeliftid (Abs_freeword ps) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<in> P \\<Longrightarrow>\n    freeword_funlift id (Abs_freeword ps) = (0::'g)", "using freeliftid_trivial_relator_freeword_R"], ["proof (prove)\nusing this:\n  ?rs \\<in> R \\<Longrightarrow>\n  freeword_funlift id (relator_freeword ?rs) = (0::'g)\n\ngoal (1 subgoal):\n 1. ps \\<in> P \\<Longrightarrow>\n    freeword_funlift id (Abs_freeword ps) = (0::'g)", "by fast"], ["", "lemma GroupByPresentationInducedFun_S_P_id:\n  \"GroupByPresentationInducedFun S P id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupByPresentationInducedFun S P id", "by  (\n        intro_locales, rule GroupByPresentation_S_P,\n        unfold_locales, rule freeliftid_trivial_P\n      )"], ["", "lemma induced_id_Abs_freelist_conv_sum_list:\n  \"ss\\<in>lists S \\<Longrightarrow> induced_id (\\<lceil>FreeGroup S|Abs_freelist ss|Q\\<rceil>) = sum_list ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    GroupByPresentationInducedFun.induced_hom S P id\n     (BinOpSetGroup.Abs_G_perm\n       (FreeGroup S //\n        Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g ` Abs_freeword ` P\\<rangle>)\n         (FreeGroup S))\n       (+)\n       (Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g ` Abs_freeword ` P\\<rangle>)\n         (FreeGroup S) ``\n        {Abs_freelist ss})) =\n    sum_list ss", "by  (simp add:\n        GroupByPresentationInducedFun.induced_hom_Abs_freelist_conv_sum_list[\n          OF GroupByPresentationInducedFun_S_P_id\n        ]\n      )"], ["", "lemma lconj_relator_freeword_R:\n  \"\\<lbrakk> rs\\<in>R; proper_signed_list xs; fst ` set xs \\<subseteq> S \\<rbrakk> \\<Longrightarrow>\n    lconjby (Abs_freeword xs) (relator_freeword rs) \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs \\<in> R; proper_signed_list xs;\n     order.greater_eq S (fst ` set xs)\\<rbrakk>\n    \\<Longrightarrow> lconjby (Abs_freeword xs) (relator_freeword rs)\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` P\\<rangle>", "by (blast intro: genby_genset_closed FreeGroupI_transfer)"], ["", "lemma rconj_relator_freeword:\n  assumes \"rs\\<in>R\" \"proper_signed_list xs\" \"fst ` set xs \\<subseteq> S\"\n  shows   \"rconjby (Abs_freeword xs) (relator_freeword rs) \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rconjby (Abs_freeword xs) (relator_freeword rs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g ` Abs_freeword ` P\\<rangle>", "proof (rule genby_genset_closed, rule UN_I)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?a2 \\<in> FreeGroup S\n 2. rconjby (Abs_freeword xs) (relator_freeword rs)\n    \\<in> lconjby ?a2 ` Abs_freeword ` P", "show \"- Abs_freeword xs \\<in> FreeGroup S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - Abs_freeword xs \\<in> FreeGroup S", "using FreeGroupI_transfer[OF assms(2,3)] FreeGroup_uminus_closed"], ["proof (prove)\nusing this:\n  Abs_freeword xs \\<in> FreeGroup S\n  ?g \\<in> FreeGroup ?S \\<Longrightarrow> - ?g \\<in> FreeGroup ?S\n\ngoal (1 subgoal):\n 1. - Abs_freeword xs \\<in> FreeGroup S", "by fast"], ["proof (state)\nthis:\n  - Abs_freeword xs \\<in> FreeGroup S\n\ngoal (1 subgoal):\n 1. rconjby (Abs_freeword xs) (relator_freeword rs)\n    \\<in> lconjby (- Abs_freeword xs) ` Abs_freeword ` P", "from assms(1)"], ["proof (chain)\npicking this:\n  rs \\<in> R", "show  \"rconjby (Abs_freeword xs) (relator_freeword rs) \\<in>\n            lconjby (- Abs_freeword xs) ` Abs_freeword ` P\""], ["proof (prove)\nusing this:\n  rs \\<in> R\n\ngoal (1 subgoal):\n 1. rconjby (Abs_freeword xs) (relator_freeword rs)\n    \\<in> lconjby (- Abs_freeword xs) ` Abs_freeword ` P", "by    simp"], ["proof (state)\nthis:\n  rconjby (Abs_freeword xs) (relator_freeword rs)\n  \\<in> lconjby (- Abs_freeword xs) ` Abs_freeword ` P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lconjby_Abs_freelist_relator_freeword:\n  \"\\<lbrakk> rs\\<in>R; xs\\<in>lists S \\<rbrakk> \\<Longrightarrow> lconjby (Abs_freelist xs) (relator_freeword rs) \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs \\<in> R; xs \\<in> lists S\\<rbrakk>\n    \\<Longrightarrow> lconjby (Abs_freelist xs) (relator_freeword rs)\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` P\\<rangle>", "using proper_signed_list_map_uniform_snd"], ["proof (prove)\nusing this:\n  proper_signed_list (map (\\<lambda>s. (s, ?b)) ?as)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rs \\<in> R; xs \\<in> lists S\\<rbrakk>\n    \\<Longrightarrow> lconjby (Abs_freelist xs) (relator_freeword rs)\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` P\\<rangle>", "by (force intro: lconj_relator_freeword_R)"], ["", "text \\<open>\n  Here we record that the lift of the identity map to the free group on @{term S} induces a\n  homomorphic surjection onto the group generated by @{term S} from the group presentation on\n  @{term S}, subject to the same relations as the elements of @{term S}.\n\\<close>"], ["", "theorem induced_id_hom_surj: \"GroupHom G induced_id\" \"induced_id ` G = \\<langle>S\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupHom\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` P\\<rangle>)\n     (GroupByPresentationInducedFun.induced_hom S P id) &&&\n    GroupByPresentationInducedFun.induced_hom S P id `\n    Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S.\n                 lconjby g ` Abs_freeword ` P\\<rangle> =\n    \\<langle>S\\<rangle>", "using GroupByPresentationInducedFun.hom_induced_hom[\n          OF GroupByPresentationInducedFun_S_P_id\n        ]\n        GroupByPresentationInducedFun.induced_hom_surj[\n          OF GroupByPresentationInducedFun_S_P_id\n        ]"], ["proof (prove)\nusing this:\n  GroupHom\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S.\n                 lconjby g ` Abs_freeword ` P\\<rangle>)\n   (GroupByPresentationInducedFun.induced_hom S P id)\n  GroupByPresentationInducedFun.induced_hom S P id `\n  Group.quotient_group (FreeGroup S)\n   \\<langle>\\<Union>g\\<in>FreeGroup S.\n               lconjby g ` Abs_freeword ` P\\<rangle> =\n  \\<langle>id ` S\\<rangle>\n\ngoal (1 subgoal):\n 1. GroupHom\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` P\\<rangle>)\n     (GroupByPresentationInducedFun.induced_hom S P id) &&&\n    GroupByPresentationInducedFun.induced_hom S P id `\n    Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S.\n                 lconjby g ` Abs_freeword ` P\\<rangle> =\n    \\<langle>S\\<rangle>", "by    auto"], ["", "end"], ["", "(* context GroupWithGeneratorsRelators *)"], ["", "locale GroupPresentation = GroupWithGeneratorsRelators S R\n  for S :: \"'g::group_add set\" \\<comment> \\<open>the set of generators\\<close>\n  and R :: \"'g list set\" \\<comment> \\<open>the set of relator words\\<close>\n+ assumes induced_id_inj: \"inj_on induced_id G\"\nbegin"], ["", "abbreviation \"inv_induced_id \\<equiv> the_inv_into G induced_id\""], ["", "lemma inv_induced_id_sum_list_S:\n  \"ss \\<in> lists S \\<Longrightarrow> inv_induced_id (sum_list ss) = (\\<lceil>FreeGroup S|Abs_freelist ss|Q\\<rceil>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    the_inv_into\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` P\\<rangle>)\n     (GroupByPresentationInducedFun.induced_hom S P id) (sum_list ss) =\n    BinOpSetGroup.Abs_G_perm\n     (FreeGroup S //\n      Restr\n       (lcoset_rel\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g ` Abs_freeword ` P\\<rangle>)\n       (FreeGroup S))\n     (+)\n     (Restr\n       (lcoset_rel\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g ` Abs_freeword ` P\\<rangle>)\n       (FreeGroup S) ``\n      {Abs_freelist ss})", "using G_UN induced_id_inj induced_id_Abs_freelist_conv_sum_list\n        Abs_freelist_in_FreeGroup"], ["proof (prove)\nusing this:\n  Group.quotient_group (FreeGroup S)\n   \\<langle>\\<Union>g\\<in>FreeGroup S.\n               lconjby g ` Abs_freeword ` P\\<rangle> =\n  (\\<lambda>g.\n      BinOpSetGroup.Abs_G_perm\n       (FreeGroup S //\n        Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g ` Abs_freeword ` P\\<rangle>)\n         (FreeGroup S))\n       (+)\n       (Restr\n         (lcoset_rel\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g ` Abs_freeword ` P\\<rangle>)\n         (FreeGroup S) ``\n        {g})) `\n  FreeGroup S\n  inj_on (GroupByPresentationInducedFun.induced_hom S P id)\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S.\n                 lconjby g ` Abs_freeword ` P\\<rangle>)\n  ?ss \\<in> lists S \\<Longrightarrow>\n  GroupByPresentationInducedFun.induced_hom S P id\n   (BinOpSetGroup.Abs_G_perm\n     (FreeGroup S //\n      Restr\n       (lcoset_rel\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g ` Abs_freeword ` P\\<rangle>)\n       (FreeGroup S))\n     (+)\n     (Restr\n       (lcoset_rel\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g ` Abs_freeword ` P\\<rangle>)\n       (FreeGroup S) ``\n      {Abs_freelist ?ss})) =\n  sum_list ?ss\n  ?ss \\<in> lists ?S \\<Longrightarrow> Abs_freelist ?ss \\<in> FreeGroup ?S\n\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    the_inv_into\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` P\\<rangle>)\n     (GroupByPresentationInducedFun.induced_hom S P id) (sum_list ss) =\n    BinOpSetGroup.Abs_G_perm\n     (FreeGroup S //\n      Restr\n       (lcoset_rel\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g ` Abs_freeword ` P\\<rangle>)\n       (FreeGroup S))\n     (+)\n     (Restr\n       (lcoset_rel\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g ` Abs_freeword ` P\\<rangle>)\n       (FreeGroup S) ``\n      {Abs_freelist ss})", "by    (blast intro: the_inv_into_f_eq)"], ["", "end"], ["", "(* GroupPresentation *)"], ["", "subsection \\<open>Words over a generating set\\<close>"], ["", "text \\<open>\n  Here we gather the necessary constructions and facts for studying a group generated by some set\n  in terms of words in the generators.\n\\<close>"], ["", "context monoid_add\nbegin"], ["", "abbreviation \"word_for A a as \\<equiv> as \\<in> lists A \\<and> sum_list as = a\""], ["", "definition reduced_word_for :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> 'a list \\<Rightarrow> bool\"\n  where \"reduced_word_for A a as \\<equiv> is_arg_min length (word_for A a) as\""], ["", "abbreviation \"reduced_word A as \\<equiv> reduced_word_for A (sum_list as) as\""], ["", "abbreviation \"reduced_words_for A a \\<equiv> Collect (reduced_word_for A a)\""], ["", "abbreviation reduced_letter_set :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> 'a set\"\n  where \"reduced_letter_set A a \\<equiv> \\<Union>( set ` (reduced_words_for A a) )\"\n  \\<comment> \\<open>will be empty if @{term a} is not in the set generated by @{term A}\\<close>"], ["", "definition word_length :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> nat\"\n  where \"word_length A a \\<equiv> length (arg_min length (word_for A a))\""], ["", "lemma reduced_word_forI:\n  assumes   \"as \\<in> lists A\" \"sum_list as = a\"\n            \"\\<And>bs. bs \\<in> lists A \\<Longrightarrow> sum_list bs = a \\<Longrightarrow> length as \\<le> length bs\"\n  shows     \"reduced_word_for A a as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_word_for A a as", "using     assms"], ["proof (prove)\nusing this:\n  as \\<in> lists A\n  sum_list as = a\n  \\<lbrakk>?bs \\<in> lists A; sum_list ?bs = a\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length ?bs) (length as)\n\ngoal (1 subgoal):\n 1. reduced_word_for A a as", "unfolding reduced_word_for_def"], ["proof (prove)\nusing this:\n  as \\<in> lists A\n  sum_list as = a\n  \\<lbrakk>?bs \\<in> lists A; sum_list ?bs = a\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length ?bs) (length as)\n\ngoal (1 subgoal):\n 1. is_arg_min length (word_for A a) as", "by        (force intro: is_arg_minI)"], ["", "lemma reduced_word_forI_compare:\n  \"\\<lbrakk> reduced_word_for A a as; bs \\<in> lists A; sum_list bs = a; length bs = length as \\<rbrakk>\n    \\<Longrightarrow> reduced_word_for A a bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reduced_word_for A a as; bs \\<in> lists A; sum_list bs = a;\n     length bs = length as\\<rbrakk>\n    \\<Longrightarrow> reduced_word_for A a bs", "using reduced_word_for_def is_arg_min_eq[of length]"], ["proof (prove)\nusing this:\n  reduced_word_for ?A ?a ?as \\<equiv> is_arg_min length (word_for ?A ?a) ?as\n  \\<lbrakk>is_arg_min length ?P ?x; ?P ?z; length ?z = length ?x\\<rbrakk>\n  \\<Longrightarrow> is_arg_min length ?P ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reduced_word_for A a as; bs \\<in> lists A; sum_list bs = a;\n     length bs = length as\\<rbrakk>\n    \\<Longrightarrow> reduced_word_for A a bs", "by fast"], ["", "lemma reduced_word_for_lists: \"reduced_word_for A a as \\<Longrightarrow> as \\<in> lists A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_word_for A a as \\<Longrightarrow> as \\<in> lists A", "using reduced_word_for_def is_arg_minD1"], ["proof (prove)\nusing this:\n  reduced_word_for ?A ?a ?as \\<equiv> is_arg_min length (word_for ?A ?a) ?as\n  is_arg_min ?m ?P ?x \\<Longrightarrow> ?P ?x\n\ngoal (1 subgoal):\n 1. reduced_word_for A a as \\<Longrightarrow> as \\<in> lists A", "by fast"], ["", "lemma reduced_word_for_sum_list: \"reduced_word_for A a as \\<Longrightarrow> sum_list as = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_word_for A a as \\<Longrightarrow> sum_list as = a", "using reduced_word_for_def is_arg_minD1"], ["proof (prove)\nusing this:\n  reduced_word_for ?A ?a ?as \\<equiv> is_arg_min length (word_for ?A ?a) ?as\n  is_arg_min ?m ?P ?x \\<Longrightarrow> ?P ?x\n\ngoal (1 subgoal):\n 1. reduced_word_for A a as \\<Longrightarrow> sum_list as = a", "by fast"], ["", "lemma reduced_word_for_minimal:\n  \"\\<lbrakk> reduced_word_for A a as; bs \\<in> lists A; sum_list bs = a \\<rbrakk> \\<Longrightarrow>\n    length as \\<le> length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reduced_word_for A a as; bs \\<in> lists A;\n     sum_list bs = a\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq (length bs) (length as)", "using reduced_word_for_def is_arg_minD2[of length]"], ["proof (prove)\nusing this:\n  reduced_word_for ?A ?a ?as \\<equiv> is_arg_min length (word_for ?A ?a) ?as\n  \\<lbrakk>is_arg_min length ?P ?x; ?P ?y\\<rbrakk>\n  \\<Longrightarrow> \\<not> order.greater (length ?x) (length ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reduced_word_for A a as; bs \\<in> lists A;\n     sum_list bs = a\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq (length bs) (length as)", "by fastforce"], ["", "lemma reduced_word_for_length:\n  \"reduced_word_for A a as \\<Longrightarrow> length as = word_length A a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_word_for A a as \\<Longrightarrow> length as = word_length A a", "unfolding word_length_def reduced_word_for_def is_arg_min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_for A a as \\<and>\n    (\\<nexists>y.\n        word_for A a y \\<and>\n        order.greater (length as) (length y)) \\<Longrightarrow>\n    length as = length (arg_min length (word_for A a))", "by (fastforce intro: arg_min_equality[THEN sym])"], ["", "lemma reduced_word_for_eq_length:\n  \"reduced_word_for A a as \\<Longrightarrow> reduced_word_for A a bs \\<Longrightarrow> length as = length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reduced_word_for A a as; reduced_word_for A a bs\\<rbrakk>\n    \\<Longrightarrow> length as = length bs", "using reduced_word_for_length"], ["proof (prove)\nusing this:\n  reduced_word_for ?A ?a ?as \\<Longrightarrow>\n  length ?as = word_length ?A ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reduced_word_for A a as; reduced_word_for A a bs\\<rbrakk>\n    \\<Longrightarrow> length as = length bs", "by simp"], ["", "lemma reduced_word_for_arg_min:\n  \"as \\<in> lists A \\<Longrightarrow> sum_list as = a \\<Longrightarrow>\n    reduced_word_for A a (arg_min length (word_for A a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<in> lists A; sum_list as = a\\<rbrakk>\n    \\<Longrightarrow> reduced_word_for A a (arg_min length (word_for A a))", "using     is_arg_min_arg_min_nat[of \"word_for A a\"]"], ["proof (prove)\nusing this:\n  word_for A a ?x \\<Longrightarrow>\n  is_arg_min ?m (word_for A a) (arg_min ?m (word_for A a))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<in> lists A; sum_list as = a\\<rbrakk>\n    \\<Longrightarrow> reduced_word_for A a (arg_min length (word_for A a))", "unfolding reduced_word_for_def"], ["proof (prove)\nusing this:\n  word_for A a ?x \\<Longrightarrow>\n  is_arg_min ?m (word_for A a) (arg_min ?m (word_for A a))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<in> lists A; sum_list as = a\\<rbrakk>\n    \\<Longrightarrow> is_arg_min length (word_for A a)\n                       (arg_min length (word_for A a))", "by        fast"], ["", "lemma nil_reduced_word_for_0: \"reduced_word_for A 0 []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_word_for A (0::'a) []", "by (auto intro: reduced_word_forI)"], ["", "lemma reduced_word_for_0_imp_nil: \"reduced_word_for A 0 as \\<Longrightarrow> as = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_word_for A (0::'a) as \\<Longrightarrow> as = []", "using     nil_reduced_word_for_0[of A] reduced_word_for_minimal[of A 0 as]"], ["proof (prove)\nusing this:\n  reduced_word_for A (0::'a) []\n  \\<lbrakk>reduced_word_for A (0::'a) as; ?bs \\<in> lists A;\n   sum_list ?bs = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length ?bs) (length as)\n\ngoal (1 subgoal):\n 1. reduced_word_for A (0::'a) as \\<Longrightarrow> as = []", "unfolding reduced_word_for_def is_arg_min_def"], ["proof (prove)\nusing this:\n  word_for A (0::'a) [] \\<and>\n  (\\<nexists>y.\n      word_for A (0::'a) y \\<and> order.greater (length []) (length y))\n  \\<lbrakk>word_for A (0::'a) as \\<and>\n           (\\<nexists>y.\n               word_for A (0::'a) y \\<and>\n               order.greater (length as) (length y));\n   ?bs \\<in> lists A; sum_list ?bs = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length ?bs) (length as)\n\ngoal (1 subgoal):\n 1. word_for A (0::'a) as \\<and>\n    (\\<nexists>y.\n        word_for A (0::'a) y \\<and>\n        order.greater (length as) (length y)) \\<Longrightarrow>\n    as = []", "by (metis (mono_tags, hide_lams) length_0_conv length_greater_0_conv)"], ["", "lemma not_reduced_word_for:\n  \"\\<lbrakk> bs \\<in> lists A; sum_list bs = a; length bs < length as \\<rbrakk> \\<Longrightarrow>\n    \\<not> reduced_word_for A a as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bs \\<in> lists A; sum_list bs = a;\n     order.greater (length as) (length bs)\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word_for A a as", "using reduced_word_for_minimal"], ["proof (prove)\nusing this:\n  \\<lbrakk>reduced_word_for ?A ?a ?as; ?bs \\<in> lists ?A;\n   sum_list ?bs = ?a\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length ?bs) (length ?as)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bs \\<in> lists A; sum_list bs = a;\n     order.greater (length as) (length bs)\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word_for A a as", "by fastforce"], ["", "lemma reduced_word_for_imp_reduced_word:\n  \"reduced_word_for A a as \\<Longrightarrow> reduced_word A as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_word_for A a as \\<Longrightarrow> reduced_word A as", "unfolding reduced_word_for_def is_arg_min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. word_for A a as \\<and>\n    (\\<nexists>y.\n        word_for A a y \\<and>\n        order.greater (length as) (length y)) \\<Longrightarrow>\n    word_for A (sum_list as) as \\<and>\n    (\\<nexists>y.\n        word_for A (sum_list as) y \\<and>\n        order.greater (length as) (length y))", "by (fast intro: reduced_word_forI)"], ["", "lemma sum_list_zero_nreduced:\n  \"as \\<noteq> [] \\<Longrightarrow> sum_list as = 0 \\<Longrightarrow> \\<not> reduced_word A as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<noteq> []; sum_list as = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A as", "using not_reduced_word_for[of \"[]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>[] \\<in> lists ?A; sum_list [] = ?a;\n   order.greater (length ?as) (length [])\\<rbrakk>\n  \\<Longrightarrow> \\<not> reduced_word_for ?A ?a ?as\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<noteq> []; sum_list as = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A as", "by simp"], ["", "lemma order2_nreduced: \"a+a=0 \\<Longrightarrow> \\<not> reduced_word A [a,a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + a = (0::'a) \\<Longrightarrow> \\<not> reduced_word A [a, a]", "using sum_list_zero_nreduced"], ["proof (prove)\nusing this:\n  \\<lbrakk>?as \\<noteq> []; sum_list ?as = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> \\<not> reduced_word ?A ?as\n\ngoal (1 subgoal):\n 1. a + a = (0::'a) \\<Longrightarrow> \\<not> reduced_word A [a, a]", "by simp"], ["", "lemma reduced_word_append_reduce_contra1:\n  assumes \"\\<not> reduced_word A as\"\n  shows   \"\\<not> reduced_word A (as@bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "proof (cases \"as \\<in> lists A\" \"bs \\<in> lists A\" rule: two_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<in> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 3. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 4. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "case both"], ["proof (state)\nthis:\n  as \\<in> lists A\n  bs \\<in> lists A\n\ngoal (4 subgoals):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<in> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 3. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 4. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "define cs where cs: \"cs \\<equiv> ARG_MIN length cs. cs \\<in> lists A \\<and> sum_list cs = sum_list as\""], ["proof (state)\nthis:\n  cs \\<equiv> arg_min length (word_for A (sum_list as))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<in> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 3. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 4. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "with both(1)"], ["proof (chain)\npicking this:\n  as \\<in> lists A\n  cs \\<equiv> arg_min length (word_for A (sum_list as))", "have \"reduced_word_for A (sum_list as) cs\""], ["proof (prove)\nusing this:\n  as \\<in> lists A\n  cs \\<equiv> arg_min length (word_for A (sum_list as))\n\ngoal (1 subgoal):\n 1. reduced_word_for A (sum_list as) cs", "using reduced_word_for_def is_arg_min_arg_min_nat[of \"word_for A (sum_list as)\"]"], ["proof (prove)\nusing this:\n  as \\<in> lists A\n  cs \\<equiv> arg_min length (word_for A (sum_list as))\n  reduced_word_for ?A ?a ?as \\<equiv> is_arg_min length (word_for ?A ?a) ?as\n  word_for A (sum_list as) ?x \\<Longrightarrow>\n  is_arg_min ?m (word_for A (sum_list as))\n   (arg_min ?m (word_for A (sum_list as)))\n\ngoal (1 subgoal):\n 1. reduced_word_for A (sum_list as) cs", "by    auto"], ["proof (state)\nthis:\n  reduced_word_for A (sum_list as) cs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<in> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 3. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 4. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "with assms both"], ["proof (chain)\npicking this:\n  \\<not> reduced_word A as\n  as \\<in> lists A\n  bs \\<in> lists A\n  reduced_word_for A (sum_list as) cs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> reduced_word A as\n  as \\<in> lists A\n  bs \\<in> lists A\n  reduced_word_for A (sum_list as) cs\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "using reduced_word_for_lists reduced_word_for_sum_list\n          reduced_word_for_minimal[of A \"sum_list as\" cs as]\n          reduced_word_forI_compare[of A \"sum_list as\" cs as]\n          not_reduced_word_for[of \"cs@bs\" A \"sum_list (as@bs)\"]"], ["proof (prove)\nusing this:\n  \\<not> reduced_word A as\n  as \\<in> lists A\n  bs \\<in> lists A\n  reduced_word_for A (sum_list as) cs\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> sum_list ?as = ?a\n  \\<lbrakk>reduced_word_for A (sum_list as) cs; as \\<in> lists A;\n   sum_list as = sum_list as\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length as) (length cs)\n  \\<lbrakk>reduced_word_for A (sum_list as) cs; as \\<in> lists A;\n   sum_list as = sum_list as; length as = length cs\\<rbrakk>\n  \\<Longrightarrow> reduced_word A as\n  \\<lbrakk>cs @ bs \\<in> lists A; sum_list (cs @ bs) = sum_list (as @ bs);\n   order.greater (length ?as) (length (cs @ bs))\\<rbrakk>\n  \\<Longrightarrow> \\<not> reduced_word_for A (sum_list (as @ bs)) ?as\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "by    fastforce"], ["proof (state)\nthis:\n  \\<not> reduced_word A (as @ bs)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 3. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 3. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "case one"], ["proof (state)\nthis:\n  as \\<in> lists A\n  bs \\<notin> lists A\n\ngoal (3 subgoals):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 3. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  as \\<in> lists A\n  bs \\<notin> lists A\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "using reduced_word_for_lists"], ["proof (prove)\nusing this:\n  as \\<in> lists A\n  bs \\<notin> lists A\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> reduced_word A (as @ bs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "case other"], ["proof (state)\nthis:\n  as \\<notin> lists A\n  bs \\<in> lists A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  as \\<notin> lists A\n  bs \\<in> lists A\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "using reduced_word_for_lists"], ["proof (prove)\nusing this:\n  as \\<notin> lists A\n  bs \\<in> lists A\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> reduced_word A (as @ bs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "case neither"], ["proof (state)\nthis:\n  as \\<notin> lists A\n  bs \\<notin> lists A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  as \\<notin> lists A\n  bs \\<notin> lists A\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "using reduced_word_for_lists"], ["proof (prove)\nusing this:\n  as \\<notin> lists A\n  bs \\<notin> lists A\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> reduced_word A (as @ bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduced_word_append_reduce_contra2:\n  assumes \"\\<not> reduced_word A bs\"\n  shows   \"\\<not> reduced_word A (as@bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "proof (cases \"as \\<in> lists A\" \"bs \\<in> lists A\" rule: two_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<in> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 3. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 4. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "case both"], ["proof (state)\nthis:\n  as \\<in> lists A\n  bs \\<in> lists A\n\ngoal (4 subgoals):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<in> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 3. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 4. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "define cs where cs: \"cs \\<equiv> ARG_MIN length cs. cs \\<in> lists A \\<and> sum_list cs = sum_list bs\""], ["proof (state)\nthis:\n  cs \\<equiv> arg_min length (word_for A (sum_list bs))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<in> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 3. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 4. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "with both(2)"], ["proof (chain)\npicking this:\n  bs \\<in> lists A\n  cs \\<equiv> arg_min length (word_for A (sum_list bs))", "have \"reduced_word_for A (sum_list bs) cs\""], ["proof (prove)\nusing this:\n  bs \\<in> lists A\n  cs \\<equiv> arg_min length (word_for A (sum_list bs))\n\ngoal (1 subgoal):\n 1. reduced_word_for A (sum_list bs) cs", "using reduced_word_for_def is_arg_min_arg_min_nat[of \"word_for A (sum_list bs)\" ]"], ["proof (prove)\nusing this:\n  bs \\<in> lists A\n  cs \\<equiv> arg_min length (word_for A (sum_list bs))\n  reduced_word_for ?A ?a ?as \\<equiv> is_arg_min length (word_for ?A ?a) ?as\n  word_for A (sum_list bs) ?x \\<Longrightarrow>\n  is_arg_min ?m (word_for A (sum_list bs))\n   (arg_min ?m (word_for A (sum_list bs)))\n\ngoal (1 subgoal):\n 1. reduced_word_for A (sum_list bs) cs", "by    auto"], ["proof (state)\nthis:\n  reduced_word_for A (sum_list bs) cs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<in> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 3. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 4. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "with assms both"], ["proof (chain)\npicking this:\n  \\<not> reduced_word A bs\n  as \\<in> lists A\n  bs \\<in> lists A\n  reduced_word_for A (sum_list bs) cs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> reduced_word A bs\n  as \\<in> lists A\n  bs \\<in> lists A\n  reduced_word_for A (sum_list bs) cs\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "using reduced_word_for_lists reduced_word_for_sum_list\n          reduced_word_for_minimal[of A \"sum_list bs\" cs bs]\n          reduced_word_forI_compare[of A \"sum_list bs\" cs bs]\n          not_reduced_word_for[of \"as@cs\" A \"sum_list (as@bs)\"]"], ["proof (prove)\nusing this:\n  \\<not> reduced_word A bs\n  as \\<in> lists A\n  bs \\<in> lists A\n  reduced_word_for A (sum_list bs) cs\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> sum_list ?as = ?a\n  \\<lbrakk>reduced_word_for A (sum_list bs) cs; bs \\<in> lists A;\n   sum_list bs = sum_list bs\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length bs) (length cs)\n  \\<lbrakk>reduced_word_for A (sum_list bs) cs; bs \\<in> lists A;\n   sum_list bs = sum_list bs; length bs = length cs\\<rbrakk>\n  \\<Longrightarrow> reduced_word A bs\n  \\<lbrakk>as @ cs \\<in> lists A; sum_list (as @ cs) = sum_list (as @ bs);\n   order.greater (length ?as) (length (as @ cs))\\<rbrakk>\n  \\<Longrightarrow> \\<not> reduced_word_for A (sum_list (as @ bs)) ?as\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "by    fastforce"], ["proof (state)\nthis:\n  \\<not> reduced_word A (as @ bs)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 3. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 3. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "case one"], ["proof (state)\nthis:\n  as \\<in> lists A\n  bs \\<notin> lists A\n\ngoal (3 subgoals):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 3. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  as \\<in> lists A\n  bs \\<notin> lists A\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "using reduced_word_for_lists"], ["proof (prove)\nusing this:\n  as \\<in> lists A\n  bs \\<notin> lists A\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> reduced_word A (as @ bs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "case other"], ["proof (state)\nthis:\n  as \\<notin> lists A\n  bs \\<in> lists A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>as \\<notin> lists A; bs \\<in> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)\n 2. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  as \\<notin> lists A\n  bs \\<in> lists A\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "using reduced_word_for_lists"], ["proof (prove)\nusing this:\n  as \\<notin> lists A\n  bs \\<in> lists A\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> reduced_word A (as @ bs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "case neither"], ["proof (state)\nthis:\n  as \\<notin> lists A\n  bs \\<notin> lists A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<notin> lists A; bs \\<notin> lists A\\<rbrakk>\n    \\<Longrightarrow> \\<not> reduced_word A (as @ bs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  as \\<notin> lists A\n  bs \\<notin> lists A\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "using reduced_word_for_lists"], ["proof (prove)\nusing this:\n  as \\<notin> lists A\n  bs \\<notin> lists A\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A (as @ bs)", "by fastforce"], ["proof (state)\nthis:\n  \\<not> reduced_word A (as @ bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contains_nreduced_imp_nreduced:\n  \"\\<not> reduced_word A bs \\<Longrightarrow> \\<not> reduced_word A (as@bs@cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> reduced_word A bs \\<Longrightarrow>\n    \\<not> reduced_word A (as @ bs @ cs)", "using reduced_word_append_reduce_contra1 reduced_word_append_reduce_contra2"], ["proof (prove)\nusing this:\n  \\<not> reduced_word ?A ?as \\<Longrightarrow>\n  \\<not> reduced_word ?A (?as @ ?bs)\n  \\<not> reduced_word ?A ?bs \\<Longrightarrow>\n  \\<not> reduced_word ?A (?as @ ?bs)\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A bs \\<Longrightarrow>\n    \\<not> reduced_word A (as @ bs @ cs)", "by    fast"], ["", "lemma contains_order2_nreduced: \"a+a=0 \\<Longrightarrow> \\<not> reduced_word A (as@[a,a]@bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + a = (0::'a) \\<Longrightarrow>\n    \\<not> reduced_word A (as @ [a, a] @ bs)", "using order2_nreduced contains_nreduced_imp_nreduced"], ["proof (prove)\nusing this:\n  ?a + ?a = (0::'a) \\<Longrightarrow> \\<not> reduced_word ?A [?a, ?a]\n  \\<not> reduced_word ?A ?bs \\<Longrightarrow>\n  \\<not> reduced_word ?A (?as @ ?bs @ ?cs)\n\ngoal (1 subgoal):\n 1. a + a = (0::'a) \\<Longrightarrow>\n    \\<not> reduced_word A (as @ [a, a] @ bs)", "by fast"], ["", "lemma reduced_word_Cons_reduce_contra:\n  \"\\<not> reduced_word A as \\<Longrightarrow> \\<not> reduced_word A (a#as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> reduced_word A as \\<Longrightarrow>\n    \\<not> reduced_word A (a # as)", "using reduced_word_append_reduce_contra2[of A as \"[a]\"]"], ["proof (prove)\nusing this:\n  \\<not> reduced_word A as \\<Longrightarrow>\n  \\<not> reduced_word A ([a] @ as)\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word A as \\<Longrightarrow>\n    \\<not> reduced_word A (a # as)", "by simp"], ["", "lemma reduced_word_Cons_reduce: \"reduced_word A (a#as) \\<Longrightarrow> reduced_word A as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_word A (a # as) \\<Longrightarrow> reduced_word A as", "using reduced_word_Cons_reduce_contra"], ["proof (prove)\nusing this:\n  \\<not> reduced_word ?A ?as \\<Longrightarrow>\n  \\<not> reduced_word ?A (?a # ?as)\n\ngoal (1 subgoal):\n 1. reduced_word A (a # as) \\<Longrightarrow> reduced_word A as", "by fast"], ["", "lemma reduced_word_singleton:\n  assumes \"a\\<in>A\" \"a\\<noteq>0\"\n  shows   \"reduced_word A [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_word A [a]", "proof (rule reduced_word_forI)"], ["proof (state)\ngoal (3 subgoals):\n 1. [a] \\<in> lists A\n 2. sum_list [a] = sum_list [a]\n 3. \\<And>bs.\n       \\<lbrakk>bs \\<in> lists A; sum_list bs = sum_list [a]\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (length bs) (length [a])", "from assms(1)"], ["proof (chain)\npicking this:\n  a \\<in> A", "show \"[a] \\<in> lists A\""], ["proof (prove)\nusing this:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. [a] \\<in> lists A", "by simp"], ["proof (state)\nthis:\n  [a] \\<in> lists A\n\ngoal (2 subgoals):\n 1. sum_list [a] = sum_list [a]\n 2. \\<And>bs.\n       \\<lbrakk>bs \\<in> lists A; sum_list bs = sum_list [a]\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (length bs) (length [a])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list [a] = sum_list [a]\n 2. \\<And>bs.\n       \\<lbrakk>bs \\<in> lists A; sum_list bs = sum_list [a]\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (length bs) (length [a])", "fix bs"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list [a] = sum_list [a]\n 2. \\<And>bs.\n       \\<lbrakk>bs \\<in> lists A; sum_list bs = sum_list [a]\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (length bs) (length [a])", "assume bs: \"bs \\<in> lists A\" \"sum_list bs = sum_list [a]\""], ["proof (state)\nthis:\n  bs \\<in> lists A\n  sum_list bs = sum_list [a]\n\ngoal (2 subgoals):\n 1. sum_list [a] = sum_list [a]\n 2. \\<And>bs.\n       \\<lbrakk>bs \\<in> lists A; sum_list bs = sum_list [a]\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (length bs) (length [a])", "with assms(2)"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a)\n  bs \\<in> lists A\n  sum_list bs = sum_list [a]", "show \"length [a] \\<le> length bs\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n  bs \\<in> lists A\n  sum_list bs = sum_list [a]\n\ngoal (1 subgoal):\n 1. order.greater_eq (length bs) (length [a])", "by (cases bs) auto"], ["proof (state)\nthis:\n  order.greater_eq (length bs) (length [a])\n\ngoal (1 subgoal):\n 1. sum_list [a] = sum_list [a]", "qed simp"], ["", "lemma el_reduced:\n  assumes \"0 \\<notin> A\" \"as \\<in> lists A\" \"sum_list as \\<in> A\" \"reduced_word A as\"\n  shows \"length as = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as = 1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. length as = 1", "define n where n: \"n \\<equiv> length as\""], ["proof (state)\nthis:\n  n \\<equiv> length as\n\ngoal (1 subgoal):\n 1. length as = 1", "from assms(3)"], ["proof (chain)\npicking this:\n  sum_list as \\<in> A", "obtain a where \"[a]\\<in>lists A\" \"sum_list as = sum_list [a]\""], ["proof (prove)\nusing this:\n  sum_list as \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>[a] \\<in> lists A; sum_list as = sum_list [a]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [a] \\<in> lists A\n  sum_list as = sum_list [a]\n\ngoal (1 subgoal):\n 1. length as = 1", "with n assms(1,3,4)"], ["proof (chain)\npicking this:\n  n \\<equiv> length as\n  (0::'a) \\<notin> A\n  sum_list as \\<in> A\n  reduced_word A as\n  [a] \\<in> lists A\n  sum_list as = sum_list [a]", "have \"n\\<le>1\" \"n>0\""], ["proof (prove)\nusing this:\n  n \\<equiv> length as\n  (0::'a) \\<notin> A\n  sum_list as \\<in> A\n  reduced_word A as\n  [a] \\<in> lists A\n  sum_list as = sum_list [a]\n\ngoal (1 subgoal):\n 1. order.greater_eq 1 n &&& order.greater n 0", "using reduced_word_for_minimal[of A _ as \"[a]\"]"], ["proof (prove)\nusing this:\n  n \\<equiv> length as\n  (0::'a) \\<notin> A\n  sum_list as \\<in> A\n  reduced_word A as\n  [a] \\<in> lists A\n  sum_list as = sum_list [a]\n  \\<lbrakk>reduced_word_for A ?a as; [a] \\<in> lists A;\n   sum_list [a] = ?a\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length [a]) (length as)\n\ngoal (1 subgoal):\n 1. order.greater_eq 1 n &&& order.greater n 0", "by auto"], ["proof (state)\nthis:\n  order.greater_eq 1 n\n  order.greater n 0\n\ngoal (1 subgoal):\n 1. length as = 1", "hence \"n = 1\""], ["proof (prove)\nusing this:\n  order.greater_eq 1 n\n  order.greater n 0\n\ngoal (1 subgoal):\n 1. n = 1", "by simp"], ["proof (state)\nthis:\n  n = 1\n\ngoal (1 subgoal):\n 1. length as = 1", "with n"], ["proof (chain)\npicking this:\n  n \\<equiv> length as\n  n = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<equiv> length as\n  n = 1\n\ngoal (1 subgoal):\n 1. length as = 1", "by fast"], ["proof (state)\nthis:\n  length as = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduced_letter_set_0: \"reduced_letter_set A 0 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_letter_set A (0::'a) = {}", "using reduced_word_for_0_imp_nil"], ["proof (prove)\nusing this:\n  reduced_word_for ?A (0::'a) ?as \\<Longrightarrow> ?as = []\n\ngoal (1 subgoal):\n 1. reduced_letter_set A (0::'a) = {}", "by simp"], ["", "lemma reduced_letter_set_subset: \"reduced_letter_set A a \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq A (reduced_letter_set A a)", "using reduced_word_for_lists"], ["proof (prove)\nusing this:\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. order.greater_eq A (reduced_letter_set A a)", "by fast"], ["", "lemma reduced_word_forI_length:\n  \"\\<lbrakk> as \\<in> lists A; sum_list as = a; length as = word_length A a \\<rbrakk> \\<Longrightarrow>\n    reduced_word_for A a as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<in> lists A; sum_list as = a;\n     length as = word_length A a\\<rbrakk>\n    \\<Longrightarrow> reduced_word_for A a as", "using reduced_word_for_arg_min reduced_word_for_length\n        reduced_word_forI_compare[of A a _ as]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?as \\<in> lists ?A; sum_list ?as = ?a\\<rbrakk>\n  \\<Longrightarrow> reduced_word_for ?A ?a (arg_min length (word_for ?A ?a))\n  reduced_word_for ?A ?a ?as \\<Longrightarrow>\n  length ?as = word_length ?A ?a\n  \\<lbrakk>reduced_word_for A a ?as; as \\<in> lists A; sum_list as = a;\n   length as = length ?as\\<rbrakk>\n  \\<Longrightarrow> reduced_word_for A a as\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<in> lists A; sum_list as = a;\n     length as = word_length A a\\<rbrakk>\n    \\<Longrightarrow> reduced_word_for A a as", "by    fastforce"], ["", "lemma word_length_le:\n  \"as \\<in> lists A \\<Longrightarrow> sum_list as = a \\<Longrightarrow> word_length A a \\<le> length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<in> lists A; sum_list as = a\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq (length as) (word_length A a)", "using reduced_word_for_arg_min reduced_word_for_length\n        reduced_word_for_minimal[of A]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?as \\<in> lists ?A; sum_list ?as = ?a\\<rbrakk>\n  \\<Longrightarrow> reduced_word_for ?A ?a (arg_min length (word_for ?A ?a))\n  reduced_word_for ?A ?a ?as \\<Longrightarrow>\n  length ?as = word_length ?A ?a\n  \\<lbrakk>reduced_word_for A ?a ?as; ?bs \\<in> lists A;\n   sum_list ?bs = ?a\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length ?bs) (length ?as)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<in> lists A; sum_list as = a\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq (length as) (word_length A a)", "by    fastforce"], ["", "lemma reduced_word_forI_length':\n  \"\\<lbrakk> as \\<in> lists A; sum_list as = a; length as \\<le> word_length A a \\<rbrakk> \\<Longrightarrow>\n    reduced_word_for A a as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<in> lists A; sum_list as = a;\n     order.greater_eq (word_length A a) (length as)\\<rbrakk>\n    \\<Longrightarrow> reduced_word_for A a as", "using word_length_le[of as A] reduced_word_forI_length[of as A]"], ["proof (prove)\nusing this:\n  \\<lbrakk>as \\<in> lists A; sum_list as = ?a\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length as) (word_length A ?a)\n  \\<lbrakk>as \\<in> lists A; sum_list as = ?a;\n   length as = word_length A ?a\\<rbrakk>\n  \\<Longrightarrow> reduced_word_for A ?a as\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<in> lists A; sum_list as = a;\n     order.greater_eq (word_length A a) (length as)\\<rbrakk>\n    \\<Longrightarrow> reduced_word_for A a as", "by fastforce"], ["", "lemma word_length_lt:\n  \"as \\<in> lists A \\<Longrightarrow> sum_list as = a \\<Longrightarrow> \\<not> reduced_word_for A a as \\<Longrightarrow>\n    word_length A a < length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<in> lists A; sum_list as = a;\n     \\<not> reduced_word_for A a as\\<rbrakk>\n    \\<Longrightarrow> order.greater (length as) (word_length A a)", "using reduced_word_forI_length'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?as \\<in> lists ?A; sum_list ?as = ?a;\n   order.greater_eq (word_length ?A ?a) (length ?as)\\<rbrakk>\n  \\<Longrightarrow> reduced_word_for ?A ?a ?as\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<in> lists A; sum_list as = a;\n     \\<not> reduced_word_for A a as\\<rbrakk>\n    \\<Longrightarrow> order.greater (length as) (word_length A a)", "by fastforce"], ["", "end"], ["", "(* context monoid_add *)"], ["", "lemma in_genby_reduced_letter_set:\n  assumes \"as \\<in> lists A\" \"sum_list as = a\"\n  shows   \"a \\<in> \\<langle>reduced_letter_set A a\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<langle>reduced_letter_set A a\\<rangle>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> \\<langle>reduced_letter_set A a\\<rangle>", "define xs where xs: \"xs \\<equiv> arg_min length (word_for A a)\""], ["proof (state)\nthis:\n  xs \\<equiv> arg_min length (word_for A a)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<langle>reduced_letter_set A a\\<rangle>", "with assms"], ["proof (chain)\npicking this:\n  as \\<in> lists A\n  sum_list as = a\n  xs \\<equiv> arg_min length (word_for A a)", "have \"xs \\<in> lists (reduced_letter_set A a)\" \"sum_list xs = a\""], ["proof (prove)\nusing this:\n  as \\<in> lists A\n  sum_list as = a\n  xs \\<equiv> arg_min length (word_for A a)\n\ngoal (1 subgoal):\n 1. xs \\<in> lists (reduced_letter_set A a) &&& sum_list xs = a", "using reduced_word_for_arg_min[of as A] reduced_word_for_sum_list"], ["proof (prove)\nusing this:\n  as \\<in> lists A\n  sum_list as = a\n  xs \\<equiv> arg_min length (word_for A a)\n  \\<lbrakk>as \\<in> lists A; sum_list as = ?a\\<rbrakk>\n  \\<Longrightarrow> reduced_word_for A ?a (arg_min length (word_for A ?a))\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> sum_list ?as = ?a\n\ngoal (1 subgoal):\n 1. xs \\<in> lists (reduced_letter_set A a) &&& sum_list xs = a", "by auto"], ["proof (state)\nthis:\n  xs \\<in> lists (reduced_letter_set A a)\n  sum_list xs = a\n\ngoal (1 subgoal):\n 1. a \\<in> \\<langle>reduced_letter_set A a\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs \\<in> lists (reduced_letter_set A a)\n  sum_list xs = a\n\ngoal (1 subgoal):\n 1. a \\<in> \\<langle>reduced_letter_set A a\\<rangle>", "using genby_eq_sum_lists"], ["proof (prove)\nusing this:\n  xs \\<in> lists (reduced_letter_set A a)\n  sum_list xs = a\n  \\<langle>?S\\<rangle> =\n  (\\<Union>ss\\<in>lists (?S \\<union> uminus ` ?S). {sum_list ss})\n\ngoal (1 subgoal):\n 1. a \\<in> \\<langle>reduced_letter_set A a\\<rangle>", "by force"], ["proof (state)\nthis:\n  a \\<in> \\<langle>reduced_letter_set A a\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduced_word_for_genby_arg_min:\n  fixes   A :: \"'a::group_add set\"\n  defines \"B \\<equiv> A \\<union> uminus ` A\"\n  assumes \"a\\<in>\\<langle>A\\<rangle>\"\n  shows   \"reduced_word_for B a (arg_min length (word_for B a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_word_for B a (arg_min length (word_for B a))", "using   assms genby_eq_sum_lists[of A] reduced_word_for_arg_min[of _ B a]"], ["proof (prove)\nusing this:\n  B \\<equiv> A \\<union> uminus ` A\n  a \\<in> \\<langle>A\\<rangle>\n  \\<langle>A\\<rangle> =\n  (\\<Union>ss\\<in>lists (A \\<union> uminus ` A). {sum_list ss})\n  \\<lbrakk>?as \\<in> lists B; sum_list ?as = a\\<rbrakk>\n  \\<Longrightarrow> reduced_word_for B a (arg_min length (word_for B a))\n\ngoal (1 subgoal):\n 1. reduced_word_for B a (arg_min length (word_for B a))", "by      auto"], ["", "lemma reduced_word_for_genby_sym_arg_min:\n  assumes \"uminus ` A \\<subseteq> A\" \"a\\<in>\\<langle>A\\<rangle>\"\n  shows   \"reduced_word_for A a (arg_min length (word_for A a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_word_for A a (arg_min length (word_for A a))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. reduced_word_for A a (arg_min length (word_for A a))", "from assms(1)"], ["proof (chain)\npicking this:\n  order.greater_eq A (uminus ` A)", "have \"A = A \\<union> uminus ` A\""], ["proof (prove)\nusing this:\n  order.greater_eq A (uminus ` A)\n\ngoal (1 subgoal):\n 1. A = A \\<union> uminus ` A", "by auto"], ["proof (state)\nthis:\n  A = A \\<union> uminus ` A\n\ngoal (1 subgoal):\n 1. reduced_word_for A a (arg_min length (word_for A a))", "with assms(2)"], ["proof (chain)\npicking this:\n  a \\<in> \\<langle>A\\<rangle>\n  A = A \\<union> uminus ` A", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> \\<langle>A\\<rangle>\n  A = A \\<union> uminus ` A\n\ngoal (1 subgoal):\n 1. reduced_word_for A a (arg_min length (word_for A a))", "using reduced_word_for_genby_arg_min[of a A]"], ["proof (prove)\nusing this:\n  a \\<in> \\<langle>A\\<rangle>\n  A = A \\<union> uminus ` A\n  a \\<in> \\<langle>A\\<rangle> \\<Longrightarrow>\n  reduced_word_for (A \\<union> uminus ` A) a\n   (arg_min length (word_for (A \\<union> uminus ` A) a))\n\ngoal (1 subgoal):\n 1. reduced_word_for A a (arg_min length (word_for A a))", "by simp"], ["proof (state)\nthis:\n  reduced_word_for A a (arg_min length (word_for A a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_genby_imp_in_reduced_letter_set:\n  fixes   A :: \"'a::group_add set\"\n  defines \"B \\<equiv> A \\<union> uminus ` A\"\n  assumes \"a \\<in> \\<langle>A\\<rangle>\"\n  shows   \"a \\<in> \\<langle>reduced_letter_set B a\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<langle>reduced_letter_set B a\\<rangle>", "using   assms genby_eq_sum_lists[of A] in_genby_reduced_letter_set[of _ B]"], ["proof (prove)\nusing this:\n  B \\<equiv> A \\<union> uminus ` A\n  a \\<in> \\<langle>A\\<rangle>\n  \\<langle>A\\<rangle> =\n  (\\<Union>ss\\<in>lists (A \\<union> uminus ` A). {sum_list ss})\n  \\<lbrakk>?as \\<in> lists B; sum_list ?as = ?a\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> \\<langle>reduced_letter_set B ?a\\<rangle>\n\ngoal (1 subgoal):\n 1. a \\<in> \\<langle>reduced_letter_set B a\\<rangle>", "by      auto"], ["", "lemma in_genby_sym_imp_in_reduced_letter_set:\n  \"uminus ` A \\<subseteq> A \\<Longrightarrow> a \\<in> \\<langle>A\\<rangle> \\<Longrightarrow> a \\<in> \\<langle>reduced_letter_set A a\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq A (uminus ` A);\n     a \\<in> \\<langle>A\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> a \\<in> \\<langle>reduced_letter_set A a\\<rangle>", "using in_genby_imp_in_reduced_letter_set"], ["proof (prove)\nusing this:\n  ?a \\<in> \\<langle>?A\\<rangle> \\<Longrightarrow>\n  ?a \\<in> \\<langle>reduced_letter_set (?A \\<union> uminus ` ?A) ?a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq A (uminus ` A);\n     a \\<in> \\<langle>A\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> a \\<in> \\<langle>reduced_letter_set A a\\<rangle>", "by (fastforce simp add: Un_absorb2)"], ["", "end"], ["", "(* theory *)"]]}