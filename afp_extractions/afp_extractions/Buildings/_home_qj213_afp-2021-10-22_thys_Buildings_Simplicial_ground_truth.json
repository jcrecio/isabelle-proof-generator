{"file_name": "/home/qj213/afp-2021-10-22/thys/Buildings/Simplicial.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Buildings", "problem_names": ["lemma facetrelI: \"v \\<notin> y \\<Longrightarrow> x = insert v y \\<Longrightarrow> y \\<lhd> x\"", "lemma facetrelI_card: \"y \\<subseteq> x \\<Longrightarrow> card (x-y) = 1 \\<Longrightarrow> y \\<lhd> x\"", "lemma facetrel_complement_vertex: \"y\\<lhd>x \\<Longrightarrow> x = insert v y \\<Longrightarrow> v\\<notin>y\"", "lemma facetrel_diff_vertex: \"v\\<in>x \\<Longrightarrow> x-{v} \\<lhd> x\"", "lemma facetrel_conv_insert: \"y \\<lhd> x \\<Longrightarrow> v \\<in> x - y \\<Longrightarrow> x = insert v y\"", "lemma facetrel_psubset: \"y \\<lhd> x \\<Longrightarrow> y \\<subset> x\"", "lemma facetrel_subset: \"y \\<lhd> x \\<Longrightarrow> y \\<subseteq> x\"", "lemma facetrel_card: \"y \\<lhd> x \\<Longrightarrow> card (x-y) = 1\"", "lemma finite_facetrel_card: \"finite x \\<Longrightarrow> y\\<lhd>x \\<Longrightarrow> card x = Suc (card y)\"", "lemma facetrelI_cardSuc: \"z\\<subseteq>x \\<Longrightarrow> card x = Suc (card z) \\<Longrightarrow> z\\<lhd>x\"", "lemma facet2_subset: \"\\<lbrakk> z\\<lhd>x; z\\<lhd>y; x\\<inter>y - z \\<noteq> {} \\<rbrakk> \\<Longrightarrow> x \\<subseteq> y\"", "lemma inj_on_pullback_facet:\n  assumes \"inj_on f x\" \"z \\<lhd> f`x\"\n  obtains y where \"y \\<lhd> x\" \"f`y = z\"", "lemma adjacentI: \"z\\<lhd>x \\<Longrightarrow> z\\<lhd>y \\<Longrightarrow> x \\<sim> y\"", "lemma empty_not_adjacent: \"\\<not> {} \\<sim> x\"", "lemma adjacent_sym: \"x \\<sim> y \\<Longrightarrow> y \\<sim> x\"", "lemma adjacent_refl:\n  assumes \"x \\<noteq> {}\"\n  shows   \"x \\<sim> x\"", "lemma common_facet: \"\\<lbrakk> z\\<lhd>x; z\\<lhd>y; x \\<noteq> y \\<rbrakk> \\<Longrightarrow> z = x \\<inter> y\"", "lemma adjacent_int_facet1: \"x \\<sim> y \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> (x \\<inter> y) \\<lhd> x\"", "lemma adjacent_int_facet2: \"x \\<sim> y \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> (x \\<inter> y) \\<lhd> y\"", "lemma adjacent_conv_insert: \"x \\<sim> y \\<Longrightarrow> v \\<in> x - y \\<Longrightarrow> x = insert v (x\\<inter>y)\"", "lemma adjacent_int_decomp:\n  \"x \\<sim> y \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> \\<exists>v. v \\<notin> y \\<and> x = insert v (x\\<inter>y)\"", "lemma adj_antivertex:\n  assumes \"x\\<sim>y\" \"x\\<noteq>y\"\n  shows   \"\\<exists>!v. v\\<in>x-y\"", "lemma adjacent_card: \"x \\<sim> y \\<Longrightarrow> card x = card y\"", "lemma adjacent_to_adjacent_int_subset:\n  assumes \"C \\<sim> D\" \"f`C \\<sim> f`D\" \"f`C \\<noteq> f`D\"\n  shows   \"f`C \\<inter> f`D \\<subseteq> f`(C\\<inter>D)\"", "lemma adjacent_to_adjacent_int:\n  \"\\<lbrakk> C \\<sim> D; f`C \\<sim> f`D; f`C \\<noteq> f`D \\<rbrakk> \\<Longrightarrow> f`(C\\<inter>D) = f`C \\<inter> f`D\"", "lemmas adjacentchain_Cons_reduce   = binrelchain_Cons_reduce   [of adjacent]", "lemmas adjacentchain_obtain_proper = binrelchain_obtain_proper [of _ _ adjacent]", "lemma adjacentchain_card: \"adjacentchain (x#xs@[y]) \\<Longrightarrow> card x = card y\"", "lemma finite_simplex: \"x\\<in>X \\<Longrightarrow> finite x\"", "lemma singleton_simplex: \"v\\<in>\\<Union>X \\<Longrightarrow> {v} \\<in> X\"", "lemma maxsimpI: \"x \\<in> X \\<Longrightarrow> (\\<And>z. z\\<in>X \\<Longrightarrow> x\\<subseteq>z \\<Longrightarrow> z=x) \\<Longrightarrow> maxsimp x\"", "lemma maxsimpD_simplex: \"maxsimp x \\<Longrightarrow> x\\<in>X\"", "lemma maxsimpD_maximal: \"maxsimp x \\<Longrightarrow> z\\<in>X \\<Longrightarrow> x\\<subseteq>z \\<Longrightarrow> z=x\"", "lemmas finite_maxsimp = finite_simplex[OF maxsimpD_simplex]", "lemma maxsimp_nempty: \"X \\<noteq> {{}} \\<Longrightarrow> maxsimp x \\<Longrightarrow> x \\<noteq> {}\"", "lemma maxsimp_vertices: \"maxsimp x \\<Longrightarrow> x\\<subseteq>\\<Union>X\"", "lemma adjacentsetD_adj: \"y \\<in> adjacentset x \\<Longrightarrow> x\\<sim>y\"", "lemma max_in_subcomplex:\n  \"\\<lbrakk> Subcomplex Y; y \\<in> Y; maxsimp y \\<rbrakk> \\<Longrightarrow> SimplicialComplex.maxsimp Y y\"", "lemma face_im:\n  assumes \"w \\<in> X\" \"y \\<subseteq> f`w\"\n  defines \"u \\<equiv> {a\\<in>w. f a \\<in> y}\"\n  shows \"y \\<in> f\\<turnstile>X\"", "lemma im_faces: \"x \\<in> f \\<turnstile> X \\<Longrightarrow> y \\<subseteq> x \\<Longrightarrow> y \\<in> f \\<turnstile> X\"", "lemma map_is_simplicial_morph: \"SimplicialComplex (f\\<turnstile>X)\"", "lemma vertex_set_int:\n  assumes \"SimplicialComplex Y\"\n  shows   \"\\<Union>(X\\<inter>Y) = \\<Union>X \\<inter> \\<Union>Y\"", "lemma maxsimpchain_snocI:\n  \"\\<lbrakk> maxsimpchain (xs@[x]); maxsimp y; x\\<sim>y \\<rbrakk> \\<Longrightarrow> maxsimpchain (xs@[x,y])\"", "lemma maxsimpchainD_maxsimp:\n  \"maxsimpchain xs \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> maxsimp x\"", "lemma maxsimpchainD_adj: \"maxsimpchain xs \\<Longrightarrow> adjacentchain xs\"", "lemma maxsimpchain_CConsI:\n  \"\\<lbrakk> maxsimp w; maxsimpchain (x#xs); w\\<sim>x \\<rbrakk> \\<Longrightarrow> maxsimpchain (w#x#xs)\"", "lemma maxsimpchain_Cons_reduce:\n  \"maxsimpchain (x#xs) \\<Longrightarrow> maxsimpchain xs\"", "lemma maxsimpchain_append_reduce1:\n  \"maxsimpchain (xs@ys) \\<Longrightarrow> maxsimpchain xs\"", "lemma maxsimpchain_append_reduce2:\n  \"maxsimpchain (xs@ys) \\<Longrightarrow> maxsimpchain ys\"", "lemma maxsimpchain_remdup_adj:\n  \"maxsimpchain (xs@[x,x]@ys) \\<Longrightarrow> maxsimpchain (xs@[x]@ys)\"", "lemma maxsimpchain_rev: \"maxsimpchain xs \\<Longrightarrow> maxsimpchain (rev xs)\"", "lemma maxsimpchain_overlap_join:\n  \"maxsimpchain (xs@[w]) \\<Longrightarrow> maxsimpchain (w#ys) \\<Longrightarrow>\n    maxsimpchain (xs@w#ys)\"", "lemma pmaxsimpchain: \"pmaxsimpchain xs \\<Longrightarrow> maxsimpchain xs\"", "lemma pmaxsimpchainI_maxsimpchain:\n  \"maxsimpchain xs \\<Longrightarrow> distinct xs \\<Longrightarrow> pmaxsimpchain xs\"", "lemma pmaxsimpchain_CConsI:\n  \"\\<lbrakk> maxsimp w; pmaxsimpchain (x#xs); w\\<sim>x; w \\<notin> set (x#xs) \\<rbrakk> \\<Longrightarrow>\n    pmaxsimpchain (w#x#xs)\"", "lemmas pmaxsimpchainD_maxsimp =\n  maxsimpchainD_maxsimp[OF pmaxsimpchain]", "lemmas pmaxsimpchainD_adj =\n  maxsimpchainD_adj [OF pmaxsimpchain]", "lemma pmaxsimpchainD_distinct: \"pmaxsimpchain xs \\<Longrightarrow> distinct xs\"", "lemma pmaxsimpchain_Cons_reduce:\n  \"pmaxsimpchain (x#xs) \\<Longrightarrow> pmaxsimpchain xs\"", "lemma pmaxsimpchain_append_reduce1:\n  \"pmaxsimpchain (xs@ys) \\<Longrightarrow> pmaxsimpchain xs\"", "lemma maxsimpchain_obtain_pmaxsimpchain:\n  assumes \"x\\<noteq>y\" \"maxsimpchain (x#xs@[y])\"\n  shows   \"\\<exists>ys. set ys \\<subseteq> set xs \\<and> length ys \\<le> length xs \\<and>\n            pmaxsimpchain (x#ys@[y])\"", "lemma min_maxsimpchainD_maxsimpchain:\n  assumes \"min_maxsimpchain xs\"\n  shows   \"maxsimpchain xs\"", "lemma min_maxsimpchainD_min_betw:\n  \"min_maxsimpchain (x#xs@[y]) \\<Longrightarrow> maxsimpchain (x#ys@[y]) \\<Longrightarrow>\n    length ys \\<ge> length xs\"", "lemma min_maxsimpchainI_betw:\n  assumes \"x\\<noteq>y\" \"maxsimpchain (x#xs@[y])\"\n          \"\\<And>ys. maxsimpchain (x#ys@[y]) \\<Longrightarrow> length xs \\<le> length ys\"\n  shows   \"min_maxsimpchain (x#xs@[y])\"", "lemma min_maxsimpchainI_betw_compare:\n  assumes \"x\\<noteq>y\" \"maxsimpchain (x#xs@[y])\"\n          \"min_maxsimpchain (x#ys@[y])\" \"length xs = length ys\"\n  shows   \"min_maxsimpchain (x#xs@[y])\"", "lemma min_maxsimpchain_pmaxsimpchain:\n  assumes \"min_maxsimpchain xs\"\n  shows   \"pmaxsimpchain xs\"", "lemma min_maxsimpchain_rev:\n  assumes \"min_maxsimpchain xs\"\n  shows   \"min_maxsimpchain (rev xs)\"", "lemma min_maxsimpchain_adj:\n  \"\\<lbrakk> maxsimp x; maxsimp y; x\\<sim>y; x\\<noteq>y \\<rbrakk> \\<Longrightarrow> min_maxsimpchain [x,y]\"", "lemma min_maxsimpchain_betw_CCons_reduce:\n  assumes \"min_maxsimpchain (w#x#ys@[z])\"\n  shows   \"min_maxsimpchain (x#ys@[z])\"", "lemma min_maxsimpchain_betw_uniform_length:\n  assumes \"min_maxsimpchain (x#xs@[y])\" \"min_maxsimpchain (x#ys@[y])\"\n  shows   \"length xs = length ys\"", "lemma not_min_maxsimpchainI_betw:\n  \"\\<lbrakk> maxsimpchain (x#ys@[y]); length ys < length xs \\<rbrakk> \\<Longrightarrow>\n    \\<not> min_maxsimpchain (x#xs@[y])\"", "lemma maxsimpchain_in_subcomplex:\n  \"\\<lbrakk> Subcomplex Y; set ys \\<subseteq> Y; maxsimpchain ys \\<rbrakk> \\<Longrightarrow>\n    SimplicialComplex.maxsimpchain Y ys\"", "lemmas morph = map_is_simplicial_morph[of f]", "lemma iso_codim_map:\n  \"x \\<in> X \\<Longrightarrow> y \\<in> X \\<Longrightarrow> card (f`x - f`y) = card (x-y)\"", "lemma maxsimp_im_max: \"maxsimp x \\<Longrightarrow> w \\<in> X \\<Longrightarrow> f`x \\<subseteq> f`w \\<Longrightarrow> f`w = f`x\"", "lemma maxsimp_map:\n  \"maxsimp x \\<Longrightarrow> SimplicialComplex.maxsimp (f\\<turnstile>X) (f`x)\"", "lemma iso_adj_int_im:\n  assumes \"maxsimp x\" \"maxsimp y\" \"x\\<sim>y\" \"x\\<noteq>y\"\n  shows \"(f`x \\<inter> f`y) \\<lhd> f`x\"", "lemma iso_adj_map:\n  assumes \"maxsimp x\" \"maxsimp y\" \"x\\<sim>y\" \"x\\<noteq>y\"\n  shows   \"f`x \\<sim> f`y\"", "lemma pmaxsimpchain_map:\n  \"pmaxsimpchain xs \\<Longrightarrow> SimplicialComplex.pmaxsimpchain (f\\<turnstile>X) (f\\<Turnstile>xs)\"", "lemma poset_is_SimplicialComplex:\n  assumes \"\\<forall>x\\<in>P. simplex_like (P.\\<^bold>\\<le>x)\"\n  shows   \"SimplicialComplex (PosetComplex P)\"", "lemma poset_to_PosetComplex_OrderingSetMap:\n  assumes \"\\<And>x. x\\<in>P \\<Longrightarrow> simplex_like (P.\\<^bold>\\<le>x)\"\n  shows   \"OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) (\\<subseteq>) (\\<subset>) P (poset_simplex_map P)\"", "lemma smap_onto_PosetComplex: \"smap ` P = PosetComplex P\"", "lemma ordsetmap_smap: \"\\<lbrakk> a\\<in>P; b\\<in>P; a\\<^bold>\\<le>b \\<rbrakk> \\<Longrightarrow> smap a \\<subseteq> smap b\"", "lemma inj_on_smap: \"inj_on smap P\"", "lemma OrderingSetIso_smap:\n  \"OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) (\\<subseteq>) (\\<subset>) P smap\"", "lemmas rev_ordsetmap_smap =\n  OrderingSetIso.rev_ordsetmap[OF OrderingSetIso_smap]"], "translations": [["", "lemma facetrelI: \"v \\<notin> y \\<Longrightarrow> x = insert v y \\<Longrightarrow> y \\<lhd> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> y; x = insert v y\\<rbrakk>\n    \\<Longrightarrow> y \\<lhd> x", "using facetrel_def"], ["proof (prove)\nusing this:\n  ?y \\<lhd> ?x \\<equiv> \\<exists>v. v \\<notin> ?y \\<and> ?x = insert v ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> y; x = insert v y\\<rbrakk>\n    \\<Longrightarrow> y \\<lhd> x", "by fast"], ["", "lemma facetrelI_card: \"y \\<subseteq> x \\<Longrightarrow> card (x-y) = 1 \\<Longrightarrow> y \\<lhd> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq x y; card (x - y) = 1\\<rbrakk>\n    \\<Longrightarrow> y \\<lhd> x", "using card1[of \"x-y\"]"], ["proof (prove)\nusing this:\n  card (x - y) = 1 \\<Longrightarrow> \\<exists>a. x - y = {a}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq x y; card (x - y) = 1\\<rbrakk>\n    \\<Longrightarrow> y \\<lhd> x", "by (blast intro: facetrelI)"], ["", "lemma facetrel_complement_vertex: \"y\\<lhd>x \\<Longrightarrow> x = insert v y \\<Longrightarrow> v\\<notin>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<lhd> x; x = insert v y\\<rbrakk>\n    \\<Longrightarrow> v \\<notin> y", "using facetrel_def[of y x]"], ["proof (prove)\nusing this:\n  y \\<lhd> x \\<equiv> \\<exists>v. v \\<notin> y \\<and> x = insert v y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<lhd> x; x = insert v y\\<rbrakk>\n    \\<Longrightarrow> v \\<notin> y", "by fastforce"], ["", "lemma facetrel_diff_vertex: \"v\\<in>x \\<Longrightarrow> x-{v} \\<lhd> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> x \\<Longrightarrow> x - {v} \\<lhd> x", "by (auto intro: facetrelI)"], ["", "lemma facetrel_conv_insert: \"y \\<lhd> x \\<Longrightarrow> v \\<in> x - y \\<Longrightarrow> x = insert v y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<lhd> x; v \\<in> x - y\\<rbrakk>\n    \\<Longrightarrow> x = insert v y", "unfolding facetrel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>v. v \\<notin> y \\<and> x = insert v y;\n     v \\<in> x - y\\<rbrakk>\n    \\<Longrightarrow> x = insert v y", "by fast"], ["", "lemma facetrel_psubset: \"y \\<lhd> x \\<Longrightarrow> y \\<subset> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<lhd> x \\<Longrightarrow> order.greater x y", "unfolding facetrel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<notin> y \\<and> x = insert v y \\<Longrightarrow>\n    order.greater x y", "by fast"], ["", "lemma facetrel_subset: \"y \\<lhd> x \\<Longrightarrow> y \\<subseteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<lhd> x \\<Longrightarrow> order.greater_eq x y", "using facetrel_psubset"], ["proof (prove)\nusing this:\n  ?y \\<lhd> ?x \\<Longrightarrow> order.greater ?x ?y\n\ngoal (1 subgoal):\n 1. y \\<lhd> x \\<Longrightarrow> order.greater_eq x y", "by fast"], ["", "lemma facetrel_card: \"y \\<lhd> x \\<Longrightarrow> card (x-y) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<lhd> x \\<Longrightarrow> card (x - y) = 1", "using insert_Diff_if[of _ y y]"], ["proof (prove)\nusing this:\n  insert ?x y - y = (if ?x \\<in> y then y - y else insert ?x (y - y))\n\ngoal (1 subgoal):\n 1. y \\<lhd> x \\<Longrightarrow> card (x - y) = 1", "unfolding facetrel_def"], ["proof (prove)\nusing this:\n  insert ?x y - y = (if ?x \\<in> y then y - y else insert ?x (y - y))\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<notin> y \\<and> x = insert v y \\<Longrightarrow>\n    card (x - y) = 1", "by fastforce"], ["", "lemma finite_facetrel_card: \"finite x \\<Longrightarrow> y\\<lhd>x \\<Longrightarrow> card x = Suc (card y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite x; y \\<lhd> x\\<rbrakk>\n    \\<Longrightarrow> card x = Suc (card y)", "using facetrel_def[of y x] card_insert_disjoint[of x]"], ["proof (prove)\nusing this:\n  y \\<lhd> x \\<equiv> \\<exists>v. v \\<notin> y \\<and> x = insert v y\n  \\<lbrakk>finite x; ?x \\<notin> x\\<rbrakk>\n  \\<Longrightarrow> card (insert ?x x) = Suc (card x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite x; y \\<lhd> x\\<rbrakk>\n    \\<Longrightarrow> card x = Suc (card y)", "by auto"], ["", "lemma facetrelI_cardSuc: \"z\\<subseteq>x \\<Longrightarrow> card x = Suc (card z) \\<Longrightarrow> z\\<lhd>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq x z; card x = Suc (card z)\\<rbrakk>\n    \\<Longrightarrow> z \\<lhd> x", "using card_ge_0_finite finite_subset[of z] card_Diff_subset[of z x]"], ["proof (prove)\nusing this:\n  order.greater (card ?A) 0 \\<Longrightarrow> finite ?A\n  \\<lbrakk>order.greater_eq ?B z; finite ?B\\<rbrakk>\n  \\<Longrightarrow> finite z\n  \\<lbrakk>finite z; order.greater_eq x z\\<rbrakk>\n  \\<Longrightarrow> card (x - z) = card x - card z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq x z; card x = Suc (card z)\\<rbrakk>\n    \\<Longrightarrow> z \\<lhd> x", "by    (force intro: facetrelI_card)"], ["", "lemma facet2_subset: \"\\<lbrakk> z\\<lhd>x; z\\<lhd>y; x\\<inter>y - z \\<noteq> {} \\<rbrakk> \\<Longrightarrow> x \\<subseteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<lhd> x; z \\<lhd> y; x \\<inter> y - z \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq y x", "unfolding facetrel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>v. v \\<notin> z \\<and> x = insert v z;\n     \\<exists>v. v \\<notin> z \\<and> y = insert v z;\n     x \\<inter> y - z \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq y x", "by force"], ["", "lemma inj_on_pullback_facet:\n  assumes \"inj_on f x\" \"z \\<lhd> f`x\"\n  obtains y where \"y \\<lhd> x\" \"f`y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<lhd> x; f ` y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<lhd> x; f ` y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?y2 \\<lhd> x\n 2. (\\<And>y.\n        \\<lbrakk>y \\<lhd> x; f ` y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    f ` ?y2 = z", "from assms(2)"], ["proof (chain)\npicking this:\n  z \\<lhd> f ` x", "obtain v where v: \"v\\<notin>z\" \"f`x = insert v z\""], ["proof (prove)\nusing this:\n  z \\<lhd> f ` x\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<notin> z; f ` x = insert v z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using facetrel_def[of z]"], ["proof (prove)\nusing this:\n  z \\<lhd> f ` x\n  z \\<lhd> ?x \\<equiv> \\<exists>v. v \\<notin> z \\<and> ?x = insert v z\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<notin> z; f ` x = insert v z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<notin> z\n  f ` x = insert v z\n\ngoal (2 subgoals):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<lhd> x; f ` y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?y2 \\<lhd> x\n 2. (\\<And>y.\n        \\<lbrakk>y \\<lhd> x; f ` y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    f ` ?y2 = z", "define u and y where \"u \\<equiv> the_inv_into x f v\" and y: \"y \\<equiv> {v\\<in>x. f v \\<in> z}\""], ["proof (state)\nthis:\n  u \\<equiv> the_inv_into x f v\n  y \\<equiv> {v \\<in> x. f v \\<in> z}\n\ngoal (2 subgoals):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<lhd> x; f ` y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?y2 \\<lhd> x\n 2. (\\<And>y.\n        \\<lbrakk>y \\<lhd> x; f ` y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    f ` ?y2 = z", "moreover"], ["proof (state)\nthis:\n  u \\<equiv> the_inv_into x f v\n  y \\<equiv> {v \\<in> x. f v \\<in> z}\n\ngoal (2 subgoals):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<lhd> x; f ` y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?y2 \\<lhd> x\n 2. (\\<And>y.\n        \\<lbrakk>y \\<lhd> x; f ` y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    f ` ?y2 = z", "with assms(2) v"], ["proof (chain)\npicking this:\n  z \\<lhd> f ` x\n  v \\<notin> z\n  f ` x = insert v z\n  u \\<equiv> the_inv_into x f v\n  y \\<equiv> {v \\<in> x. f v \\<in> z}", "have \"x = insert u y\""], ["proof (prove)\nusing this:\n  z \\<lhd> f ` x\n  v \\<notin> z\n  f ` x = insert v z\n  u \\<equiv> the_inv_into x f v\n  y \\<equiv> {v \\<in> x. f v \\<in> z}\n\ngoal (1 subgoal):\n 1. x = insert u y", "using the_inv_into_f_eq[OF assms(1)] the_inv_into_into[OF assms(1)]"], ["proof (prove)\nusing this:\n  z \\<lhd> f ` x\n  v \\<notin> z\n  f ` x = insert v z\n  u \\<equiv> the_inv_into x f v\n  y \\<equiv> {v \\<in> x. f v \\<in> z}\n  \\<lbrakk>f ?x = ?y; ?x \\<in> x\\<rbrakk>\n  \\<Longrightarrow> the_inv_into x f ?y = ?x\n  \\<lbrakk>?x \\<in> f ` x; order.greater_eq ?B x\\<rbrakk>\n  \\<Longrightarrow> the_inv_into x f ?x \\<in> ?B\n\ngoal (1 subgoal):\n 1. x = insert u y", "by fastforce"], ["proof (state)\nthis:\n  x = insert u y\n\ngoal (2 subgoals):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<lhd> x; f ` y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?y2 \\<lhd> x\n 2. (\\<And>y.\n        \\<lbrakk>y \\<lhd> x; f ` y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    f ` ?y2 = z", "ultimately"], ["proof (chain)\npicking this:\n  u \\<equiv> the_inv_into x f v\n  y \\<equiv> {v \\<in> x. f v \\<in> z}\n  x = insert u y", "show \"y \\<lhd> x\""], ["proof (prove)\nusing this:\n  u \\<equiv> the_inv_into x f v\n  y \\<equiv> {v \\<in> x. f v \\<in> z}\n  x = insert u y\n\ngoal (1 subgoal):\n 1. y \\<lhd> x", "using v f_the_inv_into_f[OF assms(1)]"], ["proof (prove)\nusing this:\n  u \\<equiv> the_inv_into x f v\n  y \\<equiv> {v \\<in> x. f v \\<in> z}\n  x = insert u y\n  v \\<notin> z\n  f ` x = insert v z\n  ?y \\<in> f ` x \\<Longrightarrow> f (the_inv_into x f ?y) = ?y\n\ngoal (1 subgoal):\n 1. y \\<lhd> x", "by (force intro: facetrelI)"], ["proof (state)\nthis:\n  y \\<lhd> x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<lhd> x; f ` y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    f ` {v \\<in> x. f v \\<in> z} = z", "from y assms(2)"], ["proof (chain)\npicking this:\n  y \\<equiv> {v \\<in> x. f v \\<in> z}\n  z \\<lhd> f ` x", "show \"f`y = z\""], ["proof (prove)\nusing this:\n  y \\<equiv> {v \\<in> x. f v \\<in> z}\n  z \\<lhd> f ` x\n\ngoal (1 subgoal):\n 1. f ` y = z", "using facetrel_subset"], ["proof (prove)\nusing this:\n  y \\<equiv> {v \\<in> x. f v \\<in> z}\n  z \\<lhd> f ` x\n  ?y \\<lhd> ?x \\<Longrightarrow> order.greater_eq ?x ?y\n\ngoal (1 subgoal):\n 1. f ` y = z", "by fast"], ["proof (state)\nthis:\n  f ` y = z\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Adjacency\\<close>"], ["", "definition adjacent :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> bool\" (infix \"\\<sim>\" 70)\n  where \"x \\<sim> y \\<equiv> \\<exists>z. z\\<lhd>x \\<and> z\\<lhd>y\""], ["", "lemma adjacentI: \"z\\<lhd>x \\<Longrightarrow> z\\<lhd>y \\<Longrightarrow> x \\<sim> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<lhd> x; z \\<lhd> y\\<rbrakk> \\<Longrightarrow> x \\<sim> y", "using adjacent_def"], ["proof (prove)\nusing this:\n  ?x \\<sim> ?y \\<equiv> \\<exists>z. z \\<lhd> ?x \\<and> z \\<lhd> ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<lhd> x; z \\<lhd> y\\<rbrakk> \\<Longrightarrow> x \\<sim> y", "by fast"], ["", "lemma empty_not_adjacent: \"\\<not> {} \\<sim> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> {} \\<sim> x", "unfolding facetrel_def adjacent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>z.\n       (\\<exists>v. v \\<notin> z \\<and> {} = insert v z) \\<and>\n       (\\<exists>v. v \\<notin> z \\<and> x = insert v z)", "by fast"], ["", "lemma adjacent_sym: \"x \\<sim> y \\<Longrightarrow> y \\<sim> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sim> y \\<Longrightarrow> y \\<sim> x", "unfolding adjacent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<lhd> x \\<and> z \\<lhd> y \\<Longrightarrow>\n    \\<exists>z. z \\<lhd> y \\<and> z \\<lhd> x", "by fast"], ["", "lemma adjacent_refl:\n  assumes \"x \\<noteq> {}\"\n  shows   \"x \\<sim> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sim> x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<sim> x", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> {}", "obtain v where v: \"v\\<in>x\""], ["proof (prove)\nusing this:\n  x \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>v. v \\<in> x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fast"], ["proof (state)\nthis:\n  v \\<in> x\n\ngoal (1 subgoal):\n 1. x \\<sim> x", "thus \"x \\<sim> x\""], ["proof (prove)\nusing this:\n  v \\<in> x\n\ngoal (1 subgoal):\n 1. x \\<sim> x", "using facetrelI[of v \"x-{v}\"]"], ["proof (prove)\nusing this:\n  v \\<in> x\n  \\<lbrakk>v \\<notin> x - {v}; ?x = insert v (x - {v})\\<rbrakk>\n  \\<Longrightarrow> x - {v} \\<lhd> ?x\n\ngoal (1 subgoal):\n 1. x \\<sim> x", "unfolding adjacent_def"], ["proof (prove)\nusing this:\n  v \\<in> x\n  \\<lbrakk>v \\<notin> x - {v}; ?x = insert v (x - {v})\\<rbrakk>\n  \\<Longrightarrow> x - {v} \\<lhd> ?x\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<lhd> x \\<and> z \\<lhd> x", "by fast"], ["proof (state)\nthis:\n  x \\<sim> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma common_facet: \"\\<lbrakk> z\\<lhd>x; z\\<lhd>y; x \\<noteq> y \\<rbrakk> \\<Longrightarrow> z = x \\<inter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<lhd> x; z \\<lhd> y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> z = x \\<inter> y", "using facetrel_subset facet2_subset"], ["proof (prove)\nusing this:\n  ?y \\<lhd> ?x \\<Longrightarrow> order.greater_eq ?x ?y\n  \\<lbrakk>?z \\<lhd> ?x; ?z \\<lhd> ?y;\n   ?x \\<inter> ?y - ?z \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq ?y ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<lhd> x; z \\<lhd> y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> z = x \\<inter> y", "by fast"], ["", "lemma adjacent_int_facet1: \"x \\<sim> y \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> (x \\<inter> y) \\<lhd> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sim> y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x \\<inter> y \\<lhd> x", "using common_facet"], ["proof (prove)\nusing this:\n  \\<lbrakk>?z \\<lhd> ?x; ?z \\<lhd> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> ?z = ?x \\<inter> ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sim> y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x \\<inter> y \\<lhd> x", "unfolding adjacent_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?z \\<lhd> ?x; ?z \\<lhd> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> ?z = ?x \\<inter> ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>z. z \\<lhd> x \\<and> z \\<lhd> y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x \\<inter> y \\<lhd> x", "by fast"], ["", "lemma adjacent_int_facet2: \"x \\<sim> y \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> (x \\<inter> y) \\<lhd> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sim> y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x \\<inter> y \\<lhd> y", "using adjacent_sym adjacent_int_facet1"], ["proof (prove)\nusing this:\n  ?x \\<sim> ?y \\<Longrightarrow> ?y \\<sim> ?x\n  \\<lbrakk>?x \\<sim> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<inter> ?y \\<lhd> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sim> y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> x \\<inter> y \\<lhd> y", "by (fastforce simp add: Int_commute)"], ["", "lemma adjacent_conv_insert: \"x \\<sim> y \\<Longrightarrow> v \\<in> x - y \\<Longrightarrow> x = insert v (x\\<inter>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sim> y; v \\<in> x - y\\<rbrakk>\n    \\<Longrightarrow> x = insert v (x \\<inter> y)", "using adjacent_int_facet1 facetrel_conv_insert"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<sim> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<inter> ?y \\<lhd> ?x\n  \\<lbrakk>?y \\<lhd> ?x; ?v \\<in> ?x - ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = insert ?v ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sim> y; v \\<in> x - y\\<rbrakk>\n    \\<Longrightarrow> x = insert v (x \\<inter> y)", "by fast"], ["", "lemma adjacent_int_decomp:\n  \"x \\<sim> y \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> \\<exists>v. v \\<notin> y \\<and> x = insert v (x\\<inter>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sim> y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v.\n                         v \\<notin> y \\<and> x = insert v (x \\<inter> y)", "using adjacent_int_facet1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<sim> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<inter> ?y \\<lhd> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sim> y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v.\n                         v \\<notin> y \\<and> x = insert v (x \\<inter> y)", "unfolding facetrel_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<sim> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v.\n                       v \\<notin> ?x \\<inter> ?y \\<and>\n                       ?x = insert v (?x \\<inter> ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sim> y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v.\n                         v \\<notin> y \\<and> x = insert v (x \\<inter> y)", "by fast"], ["", "lemma adj_antivertex:\n  assumes \"x\\<sim>y\" \"x\\<noteq>y\"\n  shows   \"\\<exists>!v. v\\<in>x-y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!v. v \\<in> x - y", "proof (rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v. v \\<in> x - y\n 2. \\<And>v ya.\n       \\<lbrakk>v \\<in> x - y; ya \\<in> x - y\\<rbrakk>\n       \\<Longrightarrow> v = ya", "from assms"], ["proof (chain)\npicking this:\n  x \\<sim> y\n  x \\<noteq> y", "obtain w where w: \"w\\<notin>y\" \"x = insert w (x\\<inter>y)\""], ["proof (prove)\nusing this:\n  x \\<sim> y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<notin> y; x = insert w (x \\<inter> y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using adjacent_int_decomp"], ["proof (prove)\nusing this:\n  x \\<sim> y\n  x \\<noteq> y\n  \\<lbrakk>?x \\<sim> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v.\n                       v \\<notin> ?y \\<and> ?x = insert v (?x \\<inter> ?y)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<notin> y; x = insert w (x \\<inter> y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  w \\<notin> y\n  x = insert w (x \\<inter> y)\n\ngoal (2 subgoals):\n 1. \\<exists>v. v \\<in> x - y\n 2. \\<And>v ya.\n       \\<lbrakk>v \\<in> x - y; ya \\<in> x - y\\<rbrakk>\n       \\<Longrightarrow> v = ya", "thus \"\\<exists>v. v\\<in>x-y\""], ["proof (prove)\nusing this:\n  w \\<notin> y\n  x = insert w (x \\<inter> y)\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<in> x - y", "by auto"], ["proof (state)\nthis:\n  \\<exists>v. v \\<in> x - y\n\ngoal (1 subgoal):\n 1. \\<And>v ya.\n       \\<lbrakk>v \\<in> x - y; ya \\<in> x - y\\<rbrakk>\n       \\<Longrightarrow> v = ya", "from w"], ["proof (chain)\npicking this:\n  w \\<notin> y\n  x = insert w (x \\<inter> y)", "have \"\\<And>v. v\\<in>x-y \\<Longrightarrow> v=w\""], ["proof (prove)\nusing this:\n  w \\<notin> y\n  x = insert w (x \\<inter> y)\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> x - y \\<Longrightarrow> v = w", "by fast"], ["proof (state)\nthis:\n  ?v \\<in> x - y \\<Longrightarrow> ?v = w\n\ngoal (1 subgoal):\n 1. \\<And>v ya.\n       \\<lbrakk>v \\<in> x - y; ya \\<in> x - y\\<rbrakk>\n       \\<Longrightarrow> v = ya", "thus \"\\<And>v v'. v\\<in>x-y \\<Longrightarrow> v'\\<in>x-y \\<Longrightarrow> v=v'\""], ["proof (prove)\nusing this:\n  ?v \\<in> x - y \\<Longrightarrow> ?v = w\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>v \\<in> x - y; v' \\<in> x - y\\<rbrakk>\n       \\<Longrightarrow> v = v'", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?v \\<in> x - y; ?v' \\<in> x - y\\<rbrakk>\n  \\<Longrightarrow> ?v = ?v'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adjacent_card: \"x \\<sim> y \\<Longrightarrow> card x = card y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sim> y \\<Longrightarrow> card x = card y", "unfolding adjacent_def facetrel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       (\\<exists>v. v \\<notin> z \\<and> x = insert v z) \\<and>\n       (\\<exists>v. v \\<notin> z \\<and> y = insert v z) \\<Longrightarrow>\n    card x = card y", "by (cases \"finite x\" \"x=y\" rule: two_cases) auto"], ["", "lemma adjacent_to_adjacent_int_subset:\n  assumes \"C \\<sim> D\" \"f`C \\<sim> f`D\" \"f`C \\<noteq> f`D\"\n  shows   \"f`C \\<inter> f`D \\<subseteq> f`(C\\<inter>D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (f ` (C \\<inter> D)) (f ` C \\<inter> f ` D)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` C \\<inter> f ` D \\<Longrightarrow>\n       x \\<in> f ` (C \\<inter> D)", "from assms(1,3)"], ["proof (chain)\npicking this:\n  C \\<sim> D\n  f ` C \\<noteq> f ` D", "obtain v where v: \"v \\<notin> D\" \"C = insert v (C\\<inter>D)\""], ["proof (prove)\nusing this:\n  C \\<sim> D\n  f ` C \\<noteq> f ` D\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<notin> D; C = insert v (C \\<inter> D)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using adjacent_int_decomp"], ["proof (prove)\nusing this:\n  C \\<sim> D\n  f ` C \\<noteq> f ` D\n  \\<lbrakk>?x \\<sim> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v.\n                       v \\<notin> ?y \\<and> ?x = insert v (?x \\<inter> ?y)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<notin> D; C = insert v (C \\<inter> D)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  v \\<notin> D\n  C = insert v (C \\<inter> D)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` C \\<inter> f ` D \\<Longrightarrow>\n       x \\<in> f ` (C \\<inter> D)", "from assms(2,3)"], ["proof (chain)\npicking this:\n  f ` C \\<sim> f ` D\n  f ` C \\<noteq> f ` D", "obtain w where w: \"w \\<notin> f`D\" \"f`C = insert w (f`C\\<inter>f`D)\""], ["proof (prove)\nusing this:\n  f ` C \\<sim> f ` D\n  f ` C \\<noteq> f ` D\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<notin> f ` D;\n         f ` C = insert w (f ` C \\<inter> f ` D)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using adjacent_int_decomp[of \"f`C\" \"f`D\"]"], ["proof (prove)\nusing this:\n  f ` C \\<sim> f ` D\n  f ` C \\<noteq> f ` D\n  \\<lbrakk>f ` C \\<sim> f ` D; f ` C \\<noteq> f ` D\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v.\n                       v \\<notin> f ` D \\<and>\n                       f ` C = insert v (f ` C \\<inter> f ` D)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<notin> f ` D;\n         f ` C = insert w (f ` C \\<inter> f ` D)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  w \\<notin> f ` D\n  f ` C = insert w (f ` C \\<inter> f ` D)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` C \\<inter> f ` D \\<Longrightarrow>\n       x \\<in> f ` (C \\<inter> D)", "from w"], ["proof (chain)\npicking this:\n  w \\<notin> f ` D\n  f ` C = insert w (f ` C \\<inter> f ` D)", "have w': \"w \\<in> f`C - f`D\""], ["proof (prove)\nusing this:\n  w \\<notin> f ` D\n  f ` C = insert w (f ` C \\<inter> f ` D)\n\ngoal (1 subgoal):\n 1. w \\<in> f ` C - f ` D", "by fast"], ["proof (state)\nthis:\n  w \\<in> f ` C - f ` D\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` C \\<inter> f ` D \\<Longrightarrow>\n       x \\<in> f ` (C \\<inter> D)", "with v assms(1,2)"], ["proof (chain)\npicking this:\n  v \\<notin> D\n  C = insert v (C \\<inter> D)\n  C \\<sim> D\n  f ` C \\<sim> f ` D\n  w \\<in> f ` C - f ` D", "have fv_w: \"f v = w\""], ["proof (prove)\nusing this:\n  v \\<notin> D\n  C = insert v (C \\<inter> D)\n  C \\<sim> D\n  f ` C \\<sim> f ` D\n  w \\<in> f ` C - f ` D\n\ngoal (1 subgoal):\n 1. f v = w", "using adjacent_conv_insert"], ["proof (prove)\nusing this:\n  v \\<notin> D\n  C = insert v (C \\<inter> D)\n  C \\<sim> D\n  f ` C \\<sim> f ` D\n  w \\<in> f ` C - f ` D\n  \\<lbrakk>?x \\<sim> ?y; ?v \\<in> ?x - ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = insert ?v (?x \\<inter> ?y)\n\ngoal (1 subgoal):\n 1. f v = w", "by fast"], ["proof (state)\nthis:\n  f v = w\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` C \\<inter> f ` D \\<Longrightarrow>\n       x \\<in> f ` (C \\<inter> D)", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` C \\<inter> f ` D \\<Longrightarrow>\n       x \\<in> f ` (C \\<inter> D)", "assume \"b \\<in> f`C \\<inter> f`D\""], ["proof (state)\nthis:\n  b \\<in> f ` C \\<inter> f ` D\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` C \\<inter> f ` D \\<Longrightarrow>\n       x \\<in> f ` (C \\<inter> D)", "from this"], ["proof (chain)\npicking this:\n  b \\<in> f ` C \\<inter> f ` D", "obtain a1 a2\n    where a1: \"a1 \\<in> C\" \"b = f a1\"\n    and   a2: \"a2 \\<in> D\" \"b = f a2\""], ["proof (prove)\nusing this:\n  b \\<in> f ` C \\<inter> f ` D\n\ngoal (1 subgoal):\n 1. (\\<And>a1 a2.\n        \\<lbrakk>a1 \\<in> C; b = f a1; a2 \\<in> D; b = f a2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  a1 \\<in> C\n  b = f a1\n  a2 \\<in> D\n  b = f a2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` C \\<inter> f ` D \\<Longrightarrow>\n       x \\<in> f ` (C \\<inter> D)", "from v a1 a2(2)"], ["proof (chain)\npicking this:\n  v \\<notin> D\n  C = insert v (C \\<inter> D)\n  a1 \\<in> C\n  b = f a1\n  b = f a2", "have \"a1 \\<notin> D \\<Longrightarrow> f a2 = w\""], ["proof (prove)\nusing this:\n  v \\<notin> D\n  C = insert v (C \\<inter> D)\n  a1 \\<in> C\n  b = f a1\n  b = f a2\n\ngoal (1 subgoal):\n 1. a1 \\<notin> D \\<Longrightarrow> f a2 = w", "using fv_w"], ["proof (prove)\nusing this:\n  v \\<notin> D\n  C = insert v (C \\<inter> D)\n  a1 \\<in> C\n  b = f a1\n  b = f a2\n  f v = w\n\ngoal (1 subgoal):\n 1. a1 \\<notin> D \\<Longrightarrow> f a2 = w", "by auto"], ["proof (state)\nthis:\n  a1 \\<notin> D \\<Longrightarrow> f a2 = w\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` C \\<inter> f ` D \\<Longrightarrow>\n       x \\<in> f ` (C \\<inter> D)", "with a2(1) w'"], ["proof (chain)\npicking this:\n  a2 \\<in> D\n  w \\<in> f ` C - f ` D\n  a1 \\<notin> D \\<Longrightarrow> f a2 = w", "have \"a1 \\<in> D\""], ["proof (prove)\nusing this:\n  a2 \\<in> D\n  w \\<in> f ` C - f ` D\n  a1 \\<notin> D \\<Longrightarrow> f a2 = w\n\ngoal (1 subgoal):\n 1. a1 \\<in> D", "by fast"], ["proof (state)\nthis:\n  a1 \\<in> D\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> f ` C \\<inter> f ` D \\<Longrightarrow>\n       x \\<in> f ` (C \\<inter> D)", "with a1"], ["proof (chain)\npicking this:\n  a1 \\<in> C\n  b = f a1\n  a1 \\<in> D", "show \"b \\<in> f`(C\\<inter>D)\""], ["proof (prove)\nusing this:\n  a1 \\<in> C\n  b = f a1\n  a1 \\<in> D\n\ngoal (1 subgoal):\n 1. b \\<in> f ` (C \\<inter> D)", "by fast"], ["proof (state)\nthis:\n  b \\<in> f ` (C \\<inter> D)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adjacent_to_adjacent_int:\n  \"\\<lbrakk> C \\<sim> D; f`C \\<sim> f`D; f`C \\<noteq> f`D \\<rbrakk> \\<Longrightarrow> f`(C\\<inter>D) = f`C \\<inter> f`D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<sim> D; f ` C \\<sim> f ` D; f ` C \\<noteq> f ` D\\<rbrakk>\n    \\<Longrightarrow> f ` (C \\<inter> D) = f ` C \\<inter> f ` D", "using adjacent_to_adjacent_int_subset"], ["proof (prove)\nusing this:\n  \\<lbrakk>?C \\<sim> ?D; ?f ` ?C \\<sim> ?f ` ?D;\n   ?f ` ?C \\<noteq> ?f ` ?D\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (?f ` (?C \\<inter> ?D))\n                     (?f ` ?C \\<inter> ?f ` ?D)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<sim> D; f ` C \\<sim> f ` D; f ` C \\<noteq> f ` D\\<rbrakk>\n    \\<Longrightarrow> f ` (C \\<inter> D) = f ` C \\<inter> f ` D", "by fast"], ["", "subsubsection \\<open>Chains of adjacent sets\\<close>"], ["", "abbreviation \"adjacentchain  \\<equiv> binrelchain adjacent\""], ["", "abbreviation \"padjacentchain \\<equiv> proper_binrelchain adjacent\""], ["", "lemmas adjacentchain_Cons_reduce   = binrelchain_Cons_reduce   [of adjacent]"], ["", "lemmas adjacentchain_obtain_proper = binrelchain_obtain_proper [of _ _ adjacent]"], ["", "lemma adjacentchain_card: \"adjacentchain (x#xs@[y]) \\<Longrightarrow> card x = card y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacentchain (x # xs @ [y]) \\<Longrightarrow> card x = card y", "using adjacent_card"], ["proof (prove)\nusing this:\n  ?x \\<sim> ?y \\<Longrightarrow> card ?x = card ?y\n\ngoal (1 subgoal):\n 1. adjacentchain (x # xs @ [y]) \\<Longrightarrow> card x = card y", "by (induct xs arbitrary: x) auto"], ["", "subsection \\<open>Locale and basic facts\\<close>"], ["", "locale SimplicialComplex =\n  fixes   X :: \"'a set set\"\n  assumes finite_simplices: \"\\<forall>x\\<in>X. finite x\"\n  and     faces           : \"x\\<in>X \\<Longrightarrow> y\\<subseteq>x \\<Longrightarrow> y\\<in>X\""], ["", "context SimplicialComplex\nbegin"], ["", "abbreviation \"Subcomplex Y \\<equiv> Y \\<subseteq> X \\<and> SimplicialComplex Y\""], ["", "definition \"maxsimp x \\<equiv> x\\<in>X \\<and> (\\<forall>z\\<in>X. x\\<subseteq>z \\<longrightarrow> z=x)\""], ["", "definition adjacentset :: \"'a set \\<Rightarrow> 'a set set\"\n  where \"adjacentset x = {y\\<in>X. x\\<sim>y}\""], ["", "lemma finite_simplex: \"x\\<in>X \\<Longrightarrow> finite x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> finite x", "using finite_simplices"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X. finite x\n\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> finite x", "by simp"], ["", "lemma singleton_simplex: \"v\\<in>\\<Union>X \\<Longrightarrow> {v} \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> \\<Union> X \\<Longrightarrow> {v} \\<in> X", "using faces"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> X; order.greater_eq ?x ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> X\n\ngoal (1 subgoal):\n 1. v \\<in> \\<Union> X \\<Longrightarrow> {v} \\<in> X", "by auto"], ["", "lemma maxsimpI: \"x \\<in> X \\<Longrightarrow> (\\<And>z. z\\<in>X \\<Longrightarrow> x\\<subseteq>z \\<Longrightarrow> z=x) \\<Longrightarrow> maxsimp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X;\n     \\<And>z.\n        \\<lbrakk>z \\<in> X; order.greater_eq z x\\<rbrakk>\n        \\<Longrightarrow> z = x\\<rbrakk>\n    \\<Longrightarrow> maxsimp x", "using maxsimp_def"], ["proof (prove)\nusing this:\n  maxsimp ?x \\<equiv>\n  ?x \\<in> X \\<and>\n  (\\<forall>z\\<in>X. order.greater_eq z ?x \\<longrightarrow> z = ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X;\n     \\<And>z.\n        \\<lbrakk>z \\<in> X; order.greater_eq z x\\<rbrakk>\n        \\<Longrightarrow> z = x\\<rbrakk>\n    \\<Longrightarrow> maxsimp x", "by auto"], ["", "lemma maxsimpD_simplex: \"maxsimp x \\<Longrightarrow> x\\<in>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxsimp x \\<Longrightarrow> x \\<in> X", "using maxsimp_def"], ["proof (prove)\nusing this:\n  maxsimp ?x \\<equiv>\n  ?x \\<in> X \\<and>\n  (\\<forall>z\\<in>X. order.greater_eq z ?x \\<longrightarrow> z = ?x)\n\ngoal (1 subgoal):\n 1. maxsimp x \\<Longrightarrow> x \\<in> X", "by fast"], ["", "lemma maxsimpD_maximal: \"maxsimp x \\<Longrightarrow> z\\<in>X \\<Longrightarrow> x\\<subseteq>z \\<Longrightarrow> z=x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimp x; z \\<in> X; order.greater_eq z x\\<rbrakk>\n    \\<Longrightarrow> z = x", "using maxsimp_def"], ["proof (prove)\nusing this:\n  maxsimp ?x \\<equiv>\n  ?x \\<in> X \\<and>\n  (\\<forall>z\\<in>X. order.greater_eq z ?x \\<longrightarrow> z = ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimp x; z \\<in> X; order.greater_eq z x\\<rbrakk>\n    \\<Longrightarrow> z = x", "by auto"], ["", "lemmas finite_maxsimp = finite_simplex[OF maxsimpD_simplex]"], ["", "lemma maxsimp_nempty: \"X \\<noteq> {{}} \\<Longrightarrow> maxsimp x \\<Longrightarrow> x \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {{}}; maxsimp x\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> {}", "unfolding maxsimp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {{}};\n     x \\<in> X \\<and>\n     (\\<forall>z\\<in>X.\n         order.greater_eq z x \\<longrightarrow> z = x)\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> {}", "by fast"], ["", "lemma maxsimp_vertices: \"maxsimp x \\<Longrightarrow> x\\<subseteq>\\<Union>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxsimp x \\<Longrightarrow> order.greater_eq (\\<Union> X) x", "using maxsimpD_simplex"], ["proof (prove)\nusing this:\n  maxsimp ?x \\<Longrightarrow> ?x \\<in> X\n\ngoal (1 subgoal):\n 1. maxsimp x \\<Longrightarrow> order.greater_eq (\\<Union> X) x", "by fast"], ["", "lemma adjacentsetD_adj: \"y \\<in> adjacentset x \\<Longrightarrow> x\\<sim>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> adjacentset x \\<Longrightarrow> x \\<sim> y", "using adjacentset_def"], ["proof (prove)\nusing this:\n  adjacentset ?x = {y \\<in> X. ?x \\<sim> y}\n\ngoal (1 subgoal):\n 1. y \\<in> adjacentset x \\<Longrightarrow> x \\<sim> y", "by fast"], ["", "lemma max_in_subcomplex:\n  \"\\<lbrakk> Subcomplex Y; y \\<in> Y; maxsimp y \\<rbrakk> \\<Longrightarrow> SimplicialComplex.maxsimp Y y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq X Y \\<and> SimplicialComplex Y; y \\<in> Y;\n     maxsimp y\\<rbrakk>\n    \\<Longrightarrow> SimplicialComplex.maxsimp Y y", "using maxsimpD_maximal"], ["proof (prove)\nusing this:\n  \\<lbrakk>maxsimp ?x; ?z \\<in> X; order.greater_eq ?z ?x\\<rbrakk>\n  \\<Longrightarrow> ?z = ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq X Y \\<and> SimplicialComplex Y; y \\<in> Y;\n     maxsimp y\\<rbrakk>\n    \\<Longrightarrow> SimplicialComplex.maxsimp Y y", "by (fast intro: SimplicialComplex.maxsimpI)"], ["", "lemma face_im:\n  assumes \"w \\<in> X\" \"y \\<subseteq> f`w\"\n  defines \"u \\<equiv> {a\\<in>w. f a \\<in> y}\"\n  shows \"y \\<in> f\\<turnstile>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> f \\<turnstile> X", "using assms faces[of w u] image_eqI[of y \"(`) f\" u X]"], ["proof (prove)\nusing this:\n  w \\<in> X\n  order.greater_eq (f ` w) y\n  u \\<equiv> {a \\<in> w. f a \\<in> y}\n  \\<lbrakk>w \\<in> X; order.greater_eq w u\\<rbrakk>\n  \\<Longrightarrow> u \\<in> X\n  \\<lbrakk>y = f ` u; u \\<in> X\\<rbrakk>\n  \\<Longrightarrow> y \\<in> f \\<turnstile> X\n\ngoal (1 subgoal):\n 1. y \\<in> f \\<turnstile> X", "by    fast"], ["", "lemma im_faces: \"x \\<in> f \\<turnstile> X \\<Longrightarrow> y \\<subseteq> x \\<Longrightarrow> y \\<in> f \\<turnstile> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> f \\<turnstile> X; order.greater_eq x y\\<rbrakk>\n    \\<Longrightarrow> y \\<in> f \\<turnstile> X", "using faces face_im[of _ y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> X; order.greater_eq ?x ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> X\n  \\<lbrakk>?w \\<in> X; order.greater_eq (?f ` ?w) y\\<rbrakk>\n  \\<Longrightarrow> y \\<in> ?f \\<turnstile> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> f \\<turnstile> X; order.greater_eq x y\\<rbrakk>\n    \\<Longrightarrow> y \\<in> f \\<turnstile> X", "by (cases \"y={}\") auto"], ["", "lemma map_is_simplicial_morph: \"SimplicialComplex (f\\<turnstile>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplex (f \\<turnstile> X)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>f \\<turnstile> X. finite x\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> f \\<turnstile> X; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f \\<turnstile> X", "show \"\\<forall>x\\<in>f\\<turnstile>X. finite x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>f \\<turnstile> X. finite x", "using finite_simplices"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X. finite x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>f \\<turnstile> X. finite x", "by fast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>f \\<turnstile> X. finite x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> f \\<turnstile> X; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f \\<turnstile> X", "show \"\\<And>x y. x \\<in>f\\<turnstile>X \\<Longrightarrow> y\\<subseteq>x \\<Longrightarrow> y\\<in>f\\<turnstile>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> f \\<turnstile> X; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f \\<turnstile> X", "using im_faces"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> ?f \\<turnstile> X; order.greater_eq ?x ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> ?f \\<turnstile> X\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> f \\<turnstile> X; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f \\<turnstile> X", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> f \\<turnstile> X; order.greater_eq ?x ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> f \\<turnstile> X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vertex_set_int:\n  assumes \"SimplicialComplex Y\"\n  shows   \"\\<Union>(X\\<inter>Y) = \\<Union>X \\<inter> \\<Union>Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (X \\<inter> Y) = \\<Union> X \\<inter> \\<Union> Y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq (\\<Union> X \\<inter> \\<Union> Y)\n     (\\<Union> (X \\<inter> Y))\n 2. order.greater_eq (\\<Union> (X \\<inter> Y))\n     (\\<Union> X \\<inter> \\<Union> Y)", "have \"\\<And>v. v \\<in> \\<Union>X \\<inter> \\<Union>Y \\<Longrightarrow> v\\<in> \\<Union>(X\\<inter>Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> \\<Union> X \\<inter> \\<Union> Y \\<Longrightarrow>\n       v \\<in> \\<Union> (X \\<inter> Y)", "using faces SimplicialComplex.faces[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> X; order.greater_eq ?x ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> X\n  \\<lbrakk>?x \\<in> Y; order.greater_eq ?x ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> \\<Union> X \\<inter> \\<Union> Y \\<Longrightarrow>\n       v \\<in> \\<Union> (X \\<inter> Y)", "by auto"], ["proof (state)\nthis:\n  ?v \\<in> \\<Union> X \\<inter> \\<Union> Y \\<Longrightarrow>\n  ?v \\<in> \\<Union> (X \\<inter> Y)\n\ngoal (2 subgoals):\n 1. order.greater_eq (\\<Union> X \\<inter> \\<Union> Y)\n     (\\<Union> (X \\<inter> Y))\n 2. order.greater_eq (\\<Union> (X \\<inter> Y))\n     (\\<Union> X \\<inter> \\<Union> Y)", "thus \"\\<Union>(X\\<inter>Y) \\<supseteq> \\<Union>X \\<inter> \\<Union>Y\""], ["proof (prove)\nusing this:\n  ?v \\<in> \\<Union> X \\<inter> \\<Union> Y \\<Longrightarrow>\n  ?v \\<in> \\<Union> (X \\<inter> Y)\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<Union> (X \\<inter> Y))\n     (\\<Union> X \\<inter> \\<Union> Y)", "by fast"], ["proof (state)\nthis:\n  order.greater_eq (\\<Union> (X \\<inter> Y))\n   (\\<Union> X \\<inter> \\<Union> Y)\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<Union> X \\<inter> \\<Union> Y)\n     (\\<Union> (X \\<inter> Y))", "qed auto"], ["", "end"], ["", "(* context SimplicialComplex *)"], ["", "subsection \\<open>Chains of maximal simplices\\<close>"], ["", "text \\<open>\n  Chains of maximal simplices (with respect to adjacency) will allow us to walk through chamber\n  complexes. But there is much we can say about them in simplicial complexes. We will call a chain\n  of maximal simplices proper (using the prefix \\<open>p\\<close> as a naming convention to denote proper)\n  if no maximal simplex appears more than once in the chain. (Some sources elect to call improper\n  chains prechains, and reserve the name chain to describe a proper chain. And usually a slightly\n  weaker notion of proper is used, requiring only that no maximal simplex appear twice in succession. But\n  it essentially makes no difference, and we found it easier to use @{const distinct} rather than\n  @{term \"binrelchain not_equal\"}.)\n\\<close>"], ["", "context SimplicialComplex\nbegin"], ["", "definition \"maxsimpchain xs  \\<equiv> (\\<forall>x\\<in>set xs. maxsimp x) \\<and> adjacentchain xs\""], ["", "definition \"pmaxsimpchain xs \\<equiv> (\\<forall>x\\<in>set xs. maxsimp x) \\<and> padjacentchain xs\""], ["", "function min_maxsimpchain :: \"'a set list \\<Rightarrow> bool\"\n  where\n    \"min_maxsimpchain [] = True\"\n  | \"min_maxsimpchain [x] = maxsimp x\"\n  | \"min_maxsimpchain (x#xs@[y]) =\n      (x\\<noteq>y \\<and> is_arg_min length (\\<lambda>zs. maxsimpchain (x#zs@[y])) xs)\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = [] \\<Longrightarrow> P;\n        \\<And>xa. x = [xa] \\<Longrightarrow> P;\n        \\<And>xa xs y. x = xa # xs @ [y] \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. [] = [] \\<Longrightarrow> True = True\n 3. \\<And>x. [] = [x] \\<Longrightarrow> True = maxsimp x\n 4. \\<And>x xs y.\n       [] = x # xs @ [y] \\<Longrightarrow>\n       True =\n       (x \\<noteq> y \\<and>\n        is_arg_min length (\\<lambda>zs. maxsimpchain (x # zs @ [y])) xs)\n 5. \\<And>x xa. [x] = [xa] \\<Longrightarrow> maxsimp x = maxsimp xa\n 6. \\<And>x xa xs y.\n       [x] = xa # xs @ [y] \\<Longrightarrow>\n       maxsimp x =\n       (xa \\<noteq> y \\<and>\n        is_arg_min length (\\<lambda>zs. maxsimpchain (xa # zs @ [y])) xs)\n 7. \\<And>x xs y xa xsa ya.\n       x # xs @ [y] = xa # xsa @ [ya] \\<Longrightarrow>\n       (x \\<noteq> y \\<and>\n        is_arg_min length (\\<lambda>zs. maxsimpchain (x # zs @ [y])) xs) =\n       (xa \\<noteq> ya \\<and>\n        is_arg_min length (\\<lambda>zs. maxsimpchain (xa # zs @ [ya])) xsa)", "by (auto, rule list_cases_Cons_snoc)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All min_maxsimpchain_dom", "by (relation \"measure length\") auto"], ["", "lemma maxsimpchain_snocI:\n  \"\\<lbrakk> maxsimpchain (xs@[x]); maxsimp y; x\\<sim>y \\<rbrakk> \\<Longrightarrow> maxsimpchain (xs@[x,y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimpchain (xs @ [x]); maxsimp y; x \\<sim> y\\<rbrakk>\n    \\<Longrightarrow> maxsimpchain (xs @ [x, y])", "using maxsimpchain_def binrelchain_snoc maxsimpchain_def"], ["proof (prove)\nusing this:\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n  \\<lbrakk>binrelchain ?P (?xs @ [?x]); ?P ?x ?y\\<rbrakk>\n  \\<Longrightarrow> binrelchain ?P (?xs @ [?x, ?y])\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimpchain (xs @ [x]); maxsimp y; x \\<sim> y\\<rbrakk>\n    \\<Longrightarrow> maxsimpchain (xs @ [x, y])", "by auto"], ["", "lemma maxsimpchainD_maxsimp:\n  \"maxsimpchain xs \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> maxsimp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimpchain xs; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> maxsimp x", "using maxsimpchain_def"], ["proof (prove)\nusing this:\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimpchain xs; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> maxsimp x", "by fast"], ["", "lemma maxsimpchainD_adj: \"maxsimpchain xs \\<Longrightarrow> adjacentchain xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxsimpchain xs \\<Longrightarrow> adjacentchain xs", "using maxsimpchain_def"], ["proof (prove)\nusing this:\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. maxsimpchain xs \\<Longrightarrow> adjacentchain xs", "by fast"], ["", "lemma maxsimpchain_CConsI:\n  \"\\<lbrakk> maxsimp w; maxsimpchain (x#xs); w\\<sim>x \\<rbrakk> \\<Longrightarrow> maxsimpchain (w#x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimp w; maxsimpchain (x # xs); w \\<sim> x\\<rbrakk>\n    \\<Longrightarrow> maxsimpchain (w # x # xs)", "using maxsimpchain_def"], ["proof (prove)\nusing this:\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimp w; maxsimpchain (x # xs); w \\<sim> x\\<rbrakk>\n    \\<Longrightarrow> maxsimpchain (w # x # xs)", "by auto"], ["", "lemma maxsimpchain_Cons_reduce:\n  \"maxsimpchain (x#xs) \\<Longrightarrow> maxsimpchain xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxsimpchain (x # xs) \\<Longrightarrow> maxsimpchain xs", "using     adjacentchain_Cons_reduce maxsimpchain_def"], ["proof (prove)\nusing this:\n  adjacentchain (?x # ?xs) \\<Longrightarrow> adjacentchain ?xs\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. maxsimpchain (x # xs) \\<Longrightarrow> maxsimpchain xs", "by fastforce"], ["", "lemma maxsimpchain_append_reduce1:\n  \"maxsimpchain (xs@ys) \\<Longrightarrow> maxsimpchain xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxsimpchain (xs @ ys) \\<Longrightarrow> maxsimpchain xs", "using binrelchain_append_reduce1 maxsimpchain_def"], ["proof (prove)\nusing this:\n  binrelchain ?P (?xs @ ?ys) \\<Longrightarrow> binrelchain ?P ?xs\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. maxsimpchain (xs @ ys) \\<Longrightarrow> maxsimpchain xs", "by auto"], ["", "lemma maxsimpchain_append_reduce2:\n  \"maxsimpchain (xs@ys) \\<Longrightarrow> maxsimpchain ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxsimpchain (xs @ ys) \\<Longrightarrow> maxsimpchain ys", "using binrelchain_append_reduce2 maxsimpchain_def"], ["proof (prove)\nusing this:\n  binrelchain ?P (?xs @ ?ys) \\<Longrightarrow> binrelchain ?P ?ys\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. maxsimpchain (xs @ ys) \\<Longrightarrow> maxsimpchain ys", "by auto"], ["", "lemma maxsimpchain_remdup_adj:\n  \"maxsimpchain (xs@[x,x]@ys) \\<Longrightarrow> maxsimpchain (xs@[x]@ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxsimpchain (xs @ [x, x] @ ys) \\<Longrightarrow>\n    maxsimpchain (xs @ [x] @ ys)", "using maxsimpchain_def binrelchain_remdup_adj"], ["proof (prove)\nusing this:\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n  binrelchain ?P (?xs @ [?x, ?x] @ ?ys) \\<Longrightarrow>\n  binrelchain ?P (?xs @ ?x # ?ys)\n\ngoal (1 subgoal):\n 1. maxsimpchain (xs @ [x, x] @ ys) \\<Longrightarrow>\n    maxsimpchain (xs @ [x] @ ys)", "by auto"], ["", "lemma maxsimpchain_rev: \"maxsimpchain xs \\<Longrightarrow> maxsimpchain (rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxsimpchain xs \\<Longrightarrow> maxsimpchain (rev xs)", "using     maxsimpchainD_maxsimp adjacent_sym\n            binrelchain_sym_rev[of adjacent]"], ["proof (prove)\nusing this:\n  \\<lbrakk>maxsimpchain ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> maxsimp ?x\n  ?x \\<sim> ?y \\<Longrightarrow> ?y \\<sim> ?x\n  \\<lbrakk>\\<And>x y. x \\<sim> y \\<Longrightarrow> y \\<sim> x;\n   adjacentchain ?xs\\<rbrakk>\n  \\<Longrightarrow> adjacentchain (rev ?xs)\n\ngoal (1 subgoal):\n 1. maxsimpchain xs \\<Longrightarrow> maxsimpchain (rev xs)", "unfolding maxsimpchain_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs;\n   ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> maxsimp ?x\n  ?x \\<sim> ?y \\<Longrightarrow> ?y \\<sim> ?x\n  \\<lbrakk>\\<And>x y. x \\<sim> y \\<Longrightarrow> y \\<sim> x;\n   adjacentchain ?xs\\<rbrakk>\n  \\<Longrightarrow> adjacentchain (rev ?xs)\n\ngoal (1 subgoal):\n 1. Ball (set xs) maxsimp \\<and> adjacentchain xs \\<Longrightarrow>\n    Ball (set (rev xs)) maxsimp \\<and> adjacentchain (rev xs)", "by        fastforce"], ["", "lemma maxsimpchain_overlap_join:\n  \"maxsimpchain (xs@[w]) \\<Longrightarrow> maxsimpchain (w#ys) \\<Longrightarrow>\n    maxsimpchain (xs@w#ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimpchain (xs @ [w]); maxsimpchain (w # ys)\\<rbrakk>\n    \\<Longrightarrow> maxsimpchain (xs @ w # ys)", "using binrelchain_overlap_join maxsimpchain_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>binrelchain ?P (?xs @ [?x]); binrelchain ?P (?x # ?ys)\\<rbrakk>\n  \\<Longrightarrow> binrelchain ?P (?xs @ ?x # ?ys)\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimpchain (xs @ [w]); maxsimpchain (w # ys)\\<rbrakk>\n    \\<Longrightarrow> maxsimpchain (xs @ w # ys)", "by auto"], ["", "lemma pmaxsimpchain: \"pmaxsimpchain xs \\<Longrightarrow> maxsimpchain xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmaxsimpchain xs \\<Longrightarrow> maxsimpchain xs", "using maxsimpchain_def pmaxsimpchain_def"], ["proof (prove)\nusing this:\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n  pmaxsimpchain ?xs \\<equiv>\n  Ball (set ?xs) maxsimp \\<and> padjacentchain ?xs\n\ngoal (1 subgoal):\n 1. pmaxsimpchain xs \\<Longrightarrow> maxsimpchain xs", "by fast"], ["", "lemma pmaxsimpchainI_maxsimpchain:\n  \"maxsimpchain xs \\<Longrightarrow> distinct xs \\<Longrightarrow> pmaxsimpchain xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimpchain xs; distinct xs\\<rbrakk>\n    \\<Longrightarrow> pmaxsimpchain xs", "using maxsimpchain_def pmaxsimpchain_def"], ["proof (prove)\nusing this:\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n  pmaxsimpchain ?xs \\<equiv>\n  Ball (set ?xs) maxsimp \\<and> padjacentchain ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimpchain xs; distinct xs\\<rbrakk>\n    \\<Longrightarrow> pmaxsimpchain xs", "by fast"], ["", "lemma pmaxsimpchain_CConsI:\n  \"\\<lbrakk> maxsimp w; pmaxsimpchain (x#xs); w\\<sim>x; w \\<notin> set (x#xs) \\<rbrakk> \\<Longrightarrow>\n    pmaxsimpchain (w#x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimp w; pmaxsimpchain (x # xs); w \\<sim> x;\n     w \\<notin> set (x # xs)\\<rbrakk>\n    \\<Longrightarrow> pmaxsimpchain (w # x # xs)", "using pmaxsimpchain_def"], ["proof (prove)\nusing this:\n  pmaxsimpchain ?xs \\<equiv>\n  Ball (set ?xs) maxsimp \\<and> padjacentchain ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimp w; pmaxsimpchain (x # xs); w \\<sim> x;\n     w \\<notin> set (x # xs)\\<rbrakk>\n    \\<Longrightarrow> pmaxsimpchain (w # x # xs)", "by auto"], ["", "lemmas pmaxsimpchainD_maxsimp =\n  maxsimpchainD_maxsimp[OF pmaxsimpchain]"], ["", "lemmas pmaxsimpchainD_adj =\n  maxsimpchainD_adj [OF pmaxsimpchain]"], ["", "lemma pmaxsimpchainD_distinct: \"pmaxsimpchain xs \\<Longrightarrow> distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmaxsimpchain xs \\<Longrightarrow> distinct xs", "using pmaxsimpchain_def"], ["proof (prove)\nusing this:\n  pmaxsimpchain ?xs \\<equiv>\n  Ball (set ?xs) maxsimp \\<and> padjacentchain ?xs\n\ngoal (1 subgoal):\n 1. pmaxsimpchain xs \\<Longrightarrow> distinct xs", "by fast"], ["", "lemma pmaxsimpchain_Cons_reduce:\n  \"pmaxsimpchain (x#xs) \\<Longrightarrow> pmaxsimpchain xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmaxsimpchain (x # xs) \\<Longrightarrow> pmaxsimpchain xs", "using maxsimpchain_Cons_reduce pmaxsimpchain pmaxsimpchainD_distinct"], ["proof (prove)\nusing this:\n  maxsimpchain (?x # ?xs) \\<Longrightarrow> maxsimpchain ?xs\n  pmaxsimpchain ?xs \\<Longrightarrow> maxsimpchain ?xs\n  pmaxsimpchain ?xs \\<Longrightarrow> distinct ?xs\n\ngoal (1 subgoal):\n 1. pmaxsimpchain (x # xs) \\<Longrightarrow> pmaxsimpchain xs", "by    (fastforce intro: pmaxsimpchainI_maxsimpchain)"], ["", "lemma pmaxsimpchain_append_reduce1:\n  \"pmaxsimpchain (xs@ys) \\<Longrightarrow> pmaxsimpchain xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmaxsimpchain (xs @ ys) \\<Longrightarrow> pmaxsimpchain xs", "using maxsimpchain_append_reduce1 pmaxsimpchain pmaxsimpchainD_distinct"], ["proof (prove)\nusing this:\n  maxsimpchain (?xs @ ?ys) \\<Longrightarrow> maxsimpchain ?xs\n  pmaxsimpchain ?xs \\<Longrightarrow> maxsimpchain ?xs\n  pmaxsimpchain ?xs \\<Longrightarrow> distinct ?xs\n\ngoal (1 subgoal):\n 1. pmaxsimpchain (xs @ ys) \\<Longrightarrow> pmaxsimpchain xs", "by    (fastforce intro: pmaxsimpchainI_maxsimpchain)"], ["", "lemma maxsimpchain_obtain_pmaxsimpchain:\n  assumes \"x\\<noteq>y\" \"maxsimpchain (x#xs@[y])\"\n  shows   \"\\<exists>ys. set ys \\<subseteq> set xs \\<and> length ys \\<le> length xs \\<and>\n            pmaxsimpchain (x#ys@[y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       order.greater_eq (set xs) (set ys) \\<and>\n       order.greater_eq (length xs) (length ys) \\<and>\n       pmaxsimpchain (x # ys @ [y])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       order.greater_eq (set xs) (set ys) \\<and>\n       order.greater_eq (length xs) (length ys) \\<and>\n       pmaxsimpchain (x # ys @ [y])", "obtain ys\n    where ys: \"set ys \\<subseteq> set xs\" \"length ys \\<le> length xs\" \"padjacentchain (x#ys@[y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>order.greater_eq (set xs) (set ys);\n         order.greater_eq (length xs) (length ys);\n         padjacentchain (x # ys @ [y])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using maxsimpchainD_adj[OF assms(2)]\n          adjacentchain_obtain_proper[OF assms(1)]"], ["proof (prove)\nusing this:\n  adjacentchain (x # xs @ [y])\n  adjacentchain (x # ?xs @ [y]) \\<Longrightarrow>\n  \\<exists>zs.\n     order.greater_eq (set ?xs) (set zs) \\<and>\n     order.greater_eq (length ?xs) (length zs) \\<and>\n     padjacentchain (x # zs @ [y])\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>order.greater_eq (set xs) (set ys);\n         order.greater_eq (length xs) (length ys);\n         padjacentchain (x # ys @ [y])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  order.greater_eq (set xs) (set ys)\n  order.greater_eq (length xs) (length ys)\n  padjacentchain (x # ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       order.greater_eq (set xs) (set ys) \\<and>\n       order.greater_eq (length xs) (length ys) \\<and>\n       pmaxsimpchain (x # ys @ [y])", "from ys(1) assms(2)"], ["proof (chain)\npicking this:\n  order.greater_eq (set xs) (set ys)\n  maxsimpchain (x # xs @ [y])", "have \"\\<forall>a\\<in>set (x#ys@[y]). maxsimp a\""], ["proof (prove)\nusing this:\n  order.greater_eq (set xs) (set ys)\n  maxsimpchain (x # xs @ [y])\n\ngoal (1 subgoal):\n 1. Ball (set (x # ys @ [y])) maxsimp", "using maxsimpchainD_maxsimp"], ["proof (prove)\nusing this:\n  order.greater_eq (set xs) (set ys)\n  maxsimpchain (x # xs @ [y])\n  \\<lbrakk>maxsimpchain ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> maxsimp ?x\n\ngoal (1 subgoal):\n 1. Ball (set (x # ys @ [y])) maxsimp", "by auto"], ["proof (state)\nthis:\n  Ball (set (x # ys @ [y])) maxsimp\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       order.greater_eq (set xs) (set ys) \\<and>\n       order.greater_eq (length xs) (length ys) \\<and>\n       pmaxsimpchain (x # ys @ [y])", "with ys"], ["proof (chain)\npicking this:\n  order.greater_eq (set xs) (set ys)\n  order.greater_eq (length xs) (length ys)\n  padjacentchain (x # ys @ [y])\n  Ball (set (x # ys @ [y])) maxsimp", "show ?thesis"], ["proof (prove)\nusing this:\n  order.greater_eq (set xs) (set ys)\n  order.greater_eq (length xs) (length ys)\n  padjacentchain (x # ys @ [y])\n  Ball (set (x # ys @ [y])) maxsimp\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       order.greater_eq (set xs) (set ys) \\<and>\n       order.greater_eq (length xs) (length ys) \\<and>\n       pmaxsimpchain (x # ys @ [y])", "unfolding pmaxsimpchain_def"], ["proof (prove)\nusing this:\n  order.greater_eq (set xs) (set ys)\n  order.greater_eq (length xs) (length ys)\n  padjacentchain (x # ys @ [y])\n  Ball (set (x # ys @ [y])) maxsimp\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       order.greater_eq (set xs) (set ys) \\<and>\n       order.greater_eq (length xs) (length ys) \\<and>\n       Ball (set (x # ys @ [y])) maxsimp \\<and>\n       padjacentchain (x # ys @ [y])", "by auto"], ["proof (state)\nthis:\n  \\<exists>ys.\n     order.greater_eq (set xs) (set ys) \\<and>\n     order.greater_eq (length xs) (length ys) \\<and>\n     pmaxsimpchain (x # ys @ [y])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_maxsimpchainD_maxsimpchain:\n  assumes \"min_maxsimpchain xs\"\n  shows   \"maxsimpchain xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxsimpchain xs", "proof (cases xs rule: list_cases_Cons_snoc)"], ["proof (state)\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> maxsimpchain xs\n 2. \\<And>x. xs = [x] \\<Longrightarrow> maxsimpchain xs\n 3. \\<And>x ys y. xs = x # ys @ [y] \\<Longrightarrow> maxsimpchain xs", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> maxsimpchain xs\n 2. \\<And>x. xs = [x] \\<Longrightarrow> maxsimpchain xs\n 3. \\<And>x ys y. xs = x # ys @ [y] \\<Longrightarrow> maxsimpchain xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. maxsimpchain xs", "using maxsimpchain_def"], ["proof (prove)\nusing this:\n  xs = []\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. maxsimpchain xs", "by simp"], ["proof (state)\nthis:\n  maxsimpchain xs\n\ngoal (2 subgoals):\n 1. \\<And>x. xs = [x] \\<Longrightarrow> maxsimpchain xs\n 2. \\<And>x ys y. xs = x # ys @ [y] \\<Longrightarrow> maxsimpchain xs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. xs = [x] \\<Longrightarrow> maxsimpchain xs\n 2. \\<And>x ys y. xs = x # ys @ [y] \\<Longrightarrow> maxsimpchain xs", "case Single"], ["proof (state)\nthis:\n  xs = [x_]\n\ngoal (2 subgoals):\n 1. \\<And>x. xs = [x] \\<Longrightarrow> maxsimpchain xs\n 2. \\<And>x ys y. xs = x # ys @ [y] \\<Longrightarrow> maxsimpchain xs", "with assms"], ["proof (chain)\npicking this:\n  min_maxsimpchain xs\n  xs = [x_]", "show ?thesis"], ["proof (prove)\nusing this:\n  min_maxsimpchain xs\n  xs = [x_]\n\ngoal (1 subgoal):\n 1. maxsimpchain xs", "using maxsimpchain_def"], ["proof (prove)\nusing this:\n  min_maxsimpchain xs\n  xs = [x_]\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. maxsimpchain xs", "by simp"], ["proof (state)\nthis:\n  maxsimpchain xs\n\ngoal (1 subgoal):\n 1. \\<And>x ys y. xs = x # ys @ [y] \\<Longrightarrow> maxsimpchain xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ys y. xs = x # ys @ [y] \\<Longrightarrow> maxsimpchain xs", "case Cons_snoc"], ["proof (state)\nthis:\n  xs = x_ # ys_ @ [y_]\n\ngoal (1 subgoal):\n 1. \\<And>x ys y. xs = x # ys @ [y] \\<Longrightarrow> maxsimpchain xs", "with assms"], ["proof (chain)\npicking this:\n  min_maxsimpchain xs\n  xs = x_ # ys_ @ [y_]", "show ?thesis"], ["proof (prove)\nusing this:\n  min_maxsimpchain xs\n  xs = x_ # ys_ @ [y_]\n\ngoal (1 subgoal):\n 1. maxsimpchain xs", "using is_arg_minD1"], ["proof (prove)\nusing this:\n  min_maxsimpchain xs\n  xs = x_ # ys_ @ [y_]\n  is_arg_min ?m ?P ?x \\<Longrightarrow> ?P ?x\n\ngoal (1 subgoal):\n 1. maxsimpchain xs", "by fastforce"], ["proof (state)\nthis:\n  maxsimpchain xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_maxsimpchainD_min_betw:\n  \"min_maxsimpchain (x#xs@[y]) \\<Longrightarrow> maxsimpchain (x#ys@[y]) \\<Longrightarrow>\n    length ys \\<ge> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>min_maxsimpchain (x # xs @ [y]);\n     maxsimpchain (x # ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq (length ys) (length xs)", "using is_arg_minD2"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_arg_min ?m ?P ?x; ?P ?y\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?m ?y < ?m ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>min_maxsimpchain (x # xs @ [y]);\n     maxsimpchain (x # ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq (length ys) (length xs)", "by fastforce"], ["", "lemma min_maxsimpchainI_betw:\n  assumes \"x\\<noteq>y\" \"maxsimpchain (x#xs@[y])\"\n          \"\\<And>ys. maxsimpchain (x#ys@[y]) \\<Longrightarrow> length xs \\<le> length ys\"\n  shows   \"min_maxsimpchain (x#xs@[y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_maxsimpchain (x # xs @ [y])", "using   assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  maxsimpchain (x # xs @ [y])\n  maxsimpchain (x # ?ys @ [y]) \\<Longrightarrow>\n  order.greater_eq (length ?ys) (length xs)\n\ngoal (1 subgoal):\n 1. min_maxsimpchain (x # xs @ [y])", "by (simp add: is_arg_min_linorderI)"], ["", "lemma min_maxsimpchainI_betw_compare:\n  assumes \"x\\<noteq>y\" \"maxsimpchain (x#xs@[y])\"\n          \"min_maxsimpchain (x#ys@[y])\" \"length xs = length ys\"\n  shows   \"min_maxsimpchain (x#xs@[y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_maxsimpchain (x # xs @ [y])", "using   assms min_maxsimpchainD_min_betw min_maxsimpchainI_betw"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  maxsimpchain (x # xs @ [y])\n  min_maxsimpchain (x # ys @ [y])\n  length xs = length ys\n  \\<lbrakk>min_maxsimpchain (?x # ?xs @ [?y]);\n   maxsimpchain (?x # ?ys @ [?y])\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length ?ys) (length ?xs)\n  \\<lbrakk>?x \\<noteq> ?y; maxsimpchain (?x # ?xs @ [?y]);\n   \\<And>ys.\n      maxsimpchain (?x # ys @ [?y]) \\<Longrightarrow>\n      order.greater_eq (length ys) (length ?xs)\\<rbrakk>\n  \\<Longrightarrow> min_maxsimpchain (?x # ?xs @ [?y])\n\ngoal (1 subgoal):\n 1. min_maxsimpchain (x # xs @ [y])", "by      auto"], ["", "lemma min_maxsimpchain_pmaxsimpchain:\n  assumes \"min_maxsimpchain xs\"\n  shows   \"pmaxsimpchain xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmaxsimpchain xs", "proof (\n  rule pmaxsimpchainI_maxsimpchain, rule min_maxsimpchainD_maxsimpchain,\n  rule assms, cases xs rule: list_cases_Cons_snoc\n)"], ["proof (state)\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> distinct xs\n 2. \\<And>x. xs = [x] \\<Longrightarrow> distinct xs\n 3. \\<And>x ys y. xs = x # ys @ [y] \\<Longrightarrow> distinct xs", "case (Cons_snoc x ys y)"], ["proof (state)\nthis:\n  xs = x # ys @ [y]\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> distinct xs\n 2. \\<And>x. xs = [x] \\<Longrightarrow> distinct xs\n 3. \\<And>x ys y. xs = x # ys @ [y] \\<Longrightarrow> distinct xs", "have \"\\<not> distinct (x#ys@[y]) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> distinct (x # ys @ [y]) \\<Longrightarrow> False", "proof (cases \"x\\<in>set ys\" \"y\\<in>set ys\" rule: two_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<in> set ys;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<in> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "case both"], ["proof (state)\nthis:\n  x \\<in> set ys\n  y \\<in> set ys\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<in> set ys;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<in> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "from both(1)"], ["proof (chain)\npicking this:\n  x \\<in> set ys", "obtain as bs where \"ys = as@x#bs\""], ["proof (prove)\nusing this:\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        ys = as @ x # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using in_set_conv_decomp[of x ys]"], ["proof (prove)\nusing this:\n  x \\<in> set ys\n  (x \\<in> set ys) = (\\<exists>ysa zs. ys = ysa @ x # zs)\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        ys = as @ x # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  ys = as @ x # bs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<in> set ys;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<in> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "with assms Cons_snoc"], ["proof (chain)\npicking this:\n  min_maxsimpchain xs\n  xs = x # ys @ [y]\n  ys = as @ x # bs", "show False"], ["proof (prove)\nusing this:\n  min_maxsimpchain xs\n  xs = x # ys @ [y]\n  ys = as @ x # bs\n\ngoal (1 subgoal):\n 1. False", "using min_maxsimpchainD_maxsimpchain[OF assms]\n            maxsimpchain_append_reduce2[of \"x#as\"]\n            min_maxsimpchainD_min_betw[of x ys y]"], ["proof (prove)\nusing this:\n  min_maxsimpchain xs\n  xs = x # ys @ [y]\n  ys = as @ x # bs\n  maxsimpchain xs\n  maxsimpchain ((x # as) @ ?ys) \\<Longrightarrow> maxsimpchain ?ys\n  \\<lbrakk>min_maxsimpchain (x # ys @ [y]);\n   maxsimpchain (x # ?ys @ [y])\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length ?ys) (length ys)\n\ngoal (1 subgoal):\n 1. False", "by    fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<in> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<in> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "case one"], ["proof (state)\nthis:\n  x \\<in> set ys\n  y \\<notin> set ys\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<in> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "from one(1)"], ["proof (chain)\npicking this:\n  x \\<in> set ys", "obtain as bs where \"ys = as@x#bs\""], ["proof (prove)\nusing this:\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        ys = as @ x # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using in_set_conv_decomp[of x ys]"], ["proof (prove)\nusing this:\n  x \\<in> set ys\n  (x \\<in> set ys) = (\\<exists>ysa zs. ys = ysa @ x # zs)\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        ys = as @ x # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  ys = as @ x # bs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<in> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "with assms Cons_snoc"], ["proof (chain)\npicking this:\n  min_maxsimpchain xs\n  xs = x # ys @ [y]\n  ys = as @ x # bs", "show False"], ["proof (prove)\nusing this:\n  min_maxsimpchain xs\n  xs = x # ys @ [y]\n  ys = as @ x # bs\n\ngoal (1 subgoal):\n 1. False", "using min_maxsimpchainD_maxsimpchain[OF assms]\n            maxsimpchain_append_reduce2[of \"x#as\"]\n            min_maxsimpchainD_min_betw[of x ys y]"], ["proof (prove)\nusing this:\n  min_maxsimpchain xs\n  xs = x # ys @ [y]\n  ys = as @ x # bs\n  maxsimpchain xs\n  maxsimpchain ((x # as) @ ?ys) \\<Longrightarrow> maxsimpchain ?ys\n  \\<lbrakk>min_maxsimpchain (x # ys @ [y]);\n   maxsimpchain (x # ?ys @ [y])\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length ?ys) (length ys)\n\ngoal (1 subgoal):\n 1. False", "by    fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "case other"], ["proof (state)\nthis:\n  x \\<notin> set ys\n  y \\<in> set ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "from other(2)"], ["proof (chain)\npicking this:\n  y \\<in> set ys", "obtain as bs where \"ys = as@y#bs\""], ["proof (prove)\nusing this:\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        ys = as @ y # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using in_set_conv_decomp[of y ys]"], ["proof (prove)\nusing this:\n  y \\<in> set ys\n  (y \\<in> set ys) = (\\<exists>ysa zs. ys = ysa @ y # zs)\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        ys = as @ y # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  ys = as @ y # bs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "with assms Cons_snoc"], ["proof (chain)\npicking this:\n  min_maxsimpchain xs\n  xs = x # ys @ [y]\n  ys = as @ y # bs", "show False"], ["proof (prove)\nusing this:\n  min_maxsimpchain xs\n  xs = x # ys @ [y]\n  ys = as @ y # bs\n\ngoal (1 subgoal):\n 1. False", "using min_maxsimpchainD_maxsimpchain[OF assms]\n            maxsimpchain_append_reduce1[of \"x#as@[y]\"]\n            min_maxsimpchainD_min_betw[of x ys y]"], ["proof (prove)\nusing this:\n  min_maxsimpchain xs\n  xs = x # ys @ [y]\n  ys = as @ y # bs\n  maxsimpchain xs\n  maxsimpchain ((x # as @ [y]) @ ?ys) \\<Longrightarrow>\n  maxsimpchain (x # as @ [y])\n  \\<lbrakk>min_maxsimpchain (x # ys @ [y]);\n   maxsimpchain (x # ?ys @ [y])\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length ?ys) (length ys)\n\ngoal (1 subgoal):\n 1. False", "by    fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "case neither"], ["proof (state)\nthis:\n  x \\<notin> set ys\n  y \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  x \\<notin> set ys\n  y \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"\\<not> distinct (x # ys @ [y])\""], ["proof (state)\nthis:\n  \\<not> distinct (x # ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> set ys\n  y \\<notin> set ys\n  \\<not> distinct (x # ys @ [y])", "obtain as a bs cs where \"ys = as@[a]@bs@[a]@cs\""], ["proof (prove)\nusing this:\n  x \\<notin> set ys\n  y \\<notin> set ys\n  \\<not> distinct (x # ys @ [y])\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs cs.\n        ys = as @ [a] @ bs @ [a] @ cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms Cons_snoc not_distinct_decomp[of ys]"], ["proof (prove)\nusing this:\n  x \\<notin> set ys\n  y \\<notin> set ys\n  \\<not> distinct (x # ys @ [y])\n  min_maxsimpchain xs\n  xs = x # ys @ [y]\n  \\<not> distinct ys \\<Longrightarrow>\n  \\<exists>xs ysa zs y. ys = xs @ [y] @ ysa @ [y] @ zs\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs cs.\n        ys = as @ [a] @ bs @ [a] @ cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ys = as @ [a] @ bs @ [a] @ cs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> distinct (x # ys @ [y]); x \\<notin> set ys;\n     y \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> False", "with assms Cons_snoc"], ["proof (chain)\npicking this:\n  min_maxsimpchain xs\n  xs = x # ys @ [y]\n  ys = as @ [a] @ bs @ [a] @ cs", "show False"], ["proof (prove)\nusing this:\n  min_maxsimpchain xs\n  xs = x # ys @ [y]\n  ys = as @ [a] @ bs @ [a] @ cs\n\ngoal (1 subgoal):\n 1. False", "using min_maxsimpchainD_maxsimpchain[OF assms]\n            maxsimpchain_append_reduce1[of \"x#as@[a]\"]\n            maxsimpchain_append_reduce2[of \"x#as@[a]@bs\" \"a#cs@[y]\"]\n            maxsimpchain_overlap_join[of \"x#as\" a \"cs@[y]\"]\n            min_maxsimpchainD_min_betw[of x ys y \"as@a#cs\"]"], ["proof (prove)\nusing this:\n  min_maxsimpchain xs\n  xs = x # ys @ [y]\n  ys = as @ [a] @ bs @ [a] @ cs\n  maxsimpchain xs\n  maxsimpchain ((x # as @ [a]) @ ?ys) \\<Longrightarrow>\n  maxsimpchain (x # as @ [a])\n  maxsimpchain ((x # as @ [a] @ bs) @ a # cs @ [y]) \\<Longrightarrow>\n  maxsimpchain (a # cs @ [y])\n  \\<lbrakk>maxsimpchain ((x # as) @ [a]);\n   maxsimpchain (a # cs @ [y])\\<rbrakk>\n  \\<Longrightarrow> maxsimpchain ((x # as) @ a # cs @ [y])\n  \\<lbrakk>min_maxsimpchain (x # ys @ [y]);\n   maxsimpchain (x # (as @ a # cs) @ [y])\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length (as @ a # cs)) (length ys)\n\ngoal (1 subgoal):\n 1. False", "by    auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> distinct (x # ys @ [y]) \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> distinct xs\n 2. \\<And>x. xs = [x] \\<Longrightarrow> distinct xs\n 3. \\<And>x ys y. xs = x # ys @ [y] \\<Longrightarrow> distinct xs", "with Cons_snoc"], ["proof (chain)\npicking this:\n  xs = x # ys @ [y]\n  \\<not> distinct (x # ys @ [y]) \\<Longrightarrow> False", "show \"distinct xs\""], ["proof (prove)\nusing this:\n  xs = x # ys @ [y]\n  \\<not> distinct (x # ys @ [y]) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. distinct xs", "by fast"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> distinct xs\n 2. \\<And>x. xs = [x] \\<Longrightarrow> distinct xs", "qed auto"], ["", "lemma min_maxsimpchain_rev:\n  assumes \"min_maxsimpchain xs\"\n  shows   \"min_maxsimpchain (rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_maxsimpchain (rev xs)", "proof (cases xs rule: list_cases_Cons_snoc)"], ["proof (state)\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> min_maxsimpchain (rev xs)\n 2. \\<And>x. xs = [x] \\<Longrightarrow> min_maxsimpchain (rev xs)\n 3. \\<And>x ys y.\n       xs = x # ys @ [y] \\<Longrightarrow> min_maxsimpchain (rev xs)", "case Single"], ["proof (state)\nthis:\n  xs = [x_]\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> min_maxsimpchain (rev xs)\n 2. \\<And>x. xs = [x] \\<Longrightarrow> min_maxsimpchain (rev xs)\n 3. \\<And>x ys y.\n       xs = x # ys @ [y] \\<Longrightarrow> min_maxsimpchain (rev xs)", "with assms"], ["proof (chain)\npicking this:\n  min_maxsimpchain xs\n  xs = [x_]", "show ?thesis"], ["proof (prove)\nusing this:\n  min_maxsimpchain xs\n  xs = [x_]\n\ngoal (1 subgoal):\n 1. min_maxsimpchain (rev xs)", "using min_maxsimpchainD_maxsimpchain maxsimpchainD_maxsimp"], ["proof (prove)\nusing this:\n  min_maxsimpchain xs\n  xs = [x_]\n  min_maxsimpchain ?xs \\<Longrightarrow> maxsimpchain ?xs\n  \\<lbrakk>maxsimpchain ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> maxsimp ?x\n\ngoal (1 subgoal):\n 1. min_maxsimpchain (rev xs)", "by simp"], ["proof (state)\nthis:\n  min_maxsimpchain (rev xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> min_maxsimpchain (rev xs)\n 2. \\<And>x ys y.\n       xs = x # ys @ [y] \\<Longrightarrow> min_maxsimpchain (rev xs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> min_maxsimpchain (rev xs)\n 2. \\<And>x ys y.\n       xs = x # ys @ [y] \\<Longrightarrow> min_maxsimpchain (rev xs)", "case (Cons_snoc x ys y)"], ["proof (state)\nthis:\n  xs = x # ys @ [y]\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> min_maxsimpchain (rev xs)\n 2. \\<And>x ys y.\n       xs = x # ys @ [y] \\<Longrightarrow> min_maxsimpchain (rev xs)", "moreover"], ["proof (state)\nthis:\n  xs = x # ys @ [y]\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> min_maxsimpchain (rev xs)\n 2. \\<And>x ys y.\n       xs = x # ys @ [y] \\<Longrightarrow> min_maxsimpchain (rev xs)", "have \"min_maxsimpchain (y # rev ys @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_maxsimpchain (y # rev ys @ [x])", "proof (rule min_maxsimpchainI_betw)"], ["proof (state)\ngoal (3 subgoals):\n 1. y \\<noteq> x\n 2. maxsimpchain (y # rev ys @ [x])\n 3. \\<And>ysa.\n       maxsimpchain (y # ysa @ [x]) \\<Longrightarrow>\n       order.greater_eq (length ysa) (length (rev ys))", "from Cons_snoc assms"], ["proof (chain)\npicking this:\n  xs = x # ys @ [y]\n  min_maxsimpchain xs", "show \"y\\<noteq>x\""], ["proof (prove)\nusing this:\n  xs = x # ys @ [y]\n  min_maxsimpchain xs\n\ngoal (1 subgoal):\n 1. y \\<noteq> x", "using min_maxsimpchain_pmaxsimpchain pmaxsimpchainD_distinct"], ["proof (prove)\nusing this:\n  xs = x # ys @ [y]\n  min_maxsimpchain xs\n  min_maxsimpchain ?xs \\<Longrightarrow> pmaxsimpchain ?xs\n  pmaxsimpchain ?xs \\<Longrightarrow> distinct ?xs\n\ngoal (1 subgoal):\n 1. y \\<noteq> x", "by auto"], ["proof (state)\nthis:\n  y \\<noteq> x\n\ngoal (2 subgoals):\n 1. maxsimpchain (y # rev ys @ [x])\n 2. \\<And>ysa.\n       maxsimpchain (y # ysa @ [x]) \\<Longrightarrow>\n       order.greater_eq (length ysa) (length (rev ys))", "from Cons_snoc"], ["proof (chain)\npicking this:\n  xs = x # ys @ [y]", "show \"maxsimpchain (y # rev ys @ [x])\""], ["proof (prove)\nusing this:\n  xs = x # ys @ [y]\n\ngoal (1 subgoal):\n 1. maxsimpchain (y # rev ys @ [x])", "using min_maxsimpchainD_maxsimpchain[OF assms] maxsimpchain_rev"], ["proof (prove)\nusing this:\n  xs = x # ys @ [y]\n  maxsimpchain xs\n  maxsimpchain ?xs \\<Longrightarrow> maxsimpchain (rev ?xs)\n\ngoal (1 subgoal):\n 1. maxsimpchain (y # rev ys @ [x])", "by    fastforce"], ["proof (state)\nthis:\n  maxsimpchain (y # rev ys @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>ysa.\n       maxsimpchain (y # ysa @ [x]) \\<Longrightarrow>\n       order.greater_eq (length ysa) (length (rev ys))", "from Cons_snoc assms"], ["proof (chain)\npicking this:\n  xs = x # ys @ [y]\n  min_maxsimpchain xs", "show  \"\\<And>zs. maxsimpchain (y#zs@[x]) \\<Longrightarrow> length (rev ys) \\<le> length zs\""], ["proof (prove)\nusing this:\n  xs = x # ys @ [y]\n  min_maxsimpchain xs\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       maxsimpchain (y # zs @ [x]) \\<Longrightarrow>\n       order.greater_eq (length zs) (length (rev ys))", "using maxsimpchain_rev min_maxsimpchainD_min_betw[of x ys y]"], ["proof (prove)\nusing this:\n  xs = x # ys @ [y]\n  min_maxsimpchain xs\n  maxsimpchain ?xs \\<Longrightarrow> maxsimpchain (rev ?xs)\n  \\<lbrakk>min_maxsimpchain (x # ys @ [y]);\n   maxsimpchain (x # ?ys @ [y])\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length ?ys) (length ys)\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       maxsimpchain (y # zs @ [x]) \\<Longrightarrow>\n       order.greater_eq (length zs) (length (rev ys))", "by    fastforce"], ["proof (state)\nthis:\n  maxsimpchain (y # ?zs @ [x]) \\<Longrightarrow>\n  order.greater_eq (length ?zs) (length (rev ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  min_maxsimpchain (y # rev ys @ [x])\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> min_maxsimpchain (rev xs)\n 2. \\<And>x ys y.\n       xs = x # ys @ [y] \\<Longrightarrow> min_maxsimpchain (rev xs)", "ultimately"], ["proof (chain)\npicking this:\n  xs = x # ys @ [y]\n  min_maxsimpchain (y # rev ys @ [x])", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = x # ys @ [y]\n  min_maxsimpchain (y # rev ys @ [x])\n\ngoal (1 subgoal):\n 1. min_maxsimpchain (rev xs)", "by simp"], ["proof (state)\nthis:\n  min_maxsimpchain (rev xs)\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> min_maxsimpchain (rev xs)", "qed simp"], ["", "lemma min_maxsimpchain_adj:\n  \"\\<lbrakk> maxsimp x; maxsimp y; x\\<sim>y; x\\<noteq>y \\<rbrakk> \\<Longrightarrow> min_maxsimpchain [x,y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimp x; maxsimp y; x \\<sim> y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> min_maxsimpchain [x, y]", "using maxsimpchain_def min_maxsimpchainI_betw[of x y \"[]\"]"], ["proof (prove)\nusing this:\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n  \\<lbrakk>x \\<noteq> y; maxsimpchain (x # [] @ [y]);\n   \\<And>ys.\n      maxsimpchain (x # ys @ [y]) \\<Longrightarrow>\n      order.greater_eq (length ys) (length [])\\<rbrakk>\n  \\<Longrightarrow> min_maxsimpchain (x # [] @ [y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimp x; maxsimp y; x \\<sim> y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> min_maxsimpchain [x, y]", "by simp"], ["", "lemma min_maxsimpchain_betw_CCons_reduce:\n  assumes \"min_maxsimpchain (w#x#ys@[z])\"\n  shows   \"min_maxsimpchain (x#ys@[z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_maxsimpchain (x # ys @ [z])", "proof (rule min_maxsimpchainI_betw)"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<noteq> z\n 2. maxsimpchain (x # ys @ [z])\n 3. \\<And>ysa.\n       maxsimpchain (x # ysa @ [z]) \\<Longrightarrow>\n       order.greater_eq (length ysa) (length ys)", "from assms"], ["proof (chain)\npicking this:\n  min_maxsimpchain (w # x # ys @ [z])", "show \"x\\<noteq>z\""], ["proof (prove)\nusing this:\n  min_maxsimpchain (w # x # ys @ [z])\n\ngoal (1 subgoal):\n 1. x \\<noteq> z", "using min_maxsimpchain_pmaxsimpchain pmaxsimpchainD_distinct"], ["proof (prove)\nusing this:\n  min_maxsimpchain (w # x # ys @ [z])\n  min_maxsimpchain ?xs \\<Longrightarrow> pmaxsimpchain ?xs\n  pmaxsimpchain ?xs \\<Longrightarrow> distinct ?xs\n\ngoal (1 subgoal):\n 1. x \\<noteq> z", "by    fastforce"], ["proof (state)\nthis:\n  x \\<noteq> z\n\ngoal (2 subgoals):\n 1. maxsimpchain (x # ys @ [z])\n 2. \\<And>ysa.\n       maxsimpchain (x # ysa @ [z]) \\<Longrightarrow>\n       order.greater_eq (length ysa) (length ys)", "show \"maxsimpchain (x#ys@[z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxsimpchain (x # ys @ [z])", "using min_maxsimpchainD_maxsimpchain[OF assms]\n          maxsimpchain_Cons_reduce"], ["proof (prove)\nusing this:\n  maxsimpchain (w # x # ys @ [z])\n  maxsimpchain (?x # ?xs) \\<Longrightarrow> maxsimpchain ?xs\n\ngoal (1 subgoal):\n 1. maxsimpchain (x # ys @ [z])", "by    fast"], ["proof (state)\nthis:\n  maxsimpchain (x # ys @ [z])\n\ngoal (1 subgoal):\n 1. \\<And>ysa.\n       maxsimpchain (x # ysa @ [z]) \\<Longrightarrow>\n       order.greater_eq (length ysa) (length ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ysa.\n       maxsimpchain (x # ysa @ [z]) \\<Longrightarrow>\n       order.greater_eq (length ysa) (length ys)", "fix zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ysa.\n       maxsimpchain (x # ysa @ [z]) \\<Longrightarrow>\n       order.greater_eq (length ysa) (length ys)", "assume \"maxsimpchain (x#zs@[z])\""], ["proof (state)\nthis:\n  maxsimpchain (x # zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<And>ysa.\n       maxsimpchain (x # ysa @ [z]) \\<Longrightarrow>\n       order.greater_eq (length ysa) (length ys)", "hence \"maxsimpchain (w#x#zs@[z])\""], ["proof (prove)\nusing this:\n  maxsimpchain (x # zs @ [z])\n\ngoal (1 subgoal):\n 1. maxsimpchain (w # x # zs @ [z])", "using min_maxsimpchainD_maxsimpchain[OF assms] maxsimpchain_def"], ["proof (prove)\nusing this:\n  maxsimpchain (x # zs @ [z])\n  maxsimpchain (w # x # ys @ [z])\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. maxsimpchain (w # x # zs @ [z])", "by    fastforce"], ["proof (state)\nthis:\n  maxsimpchain (w # x # zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<And>ysa.\n       maxsimpchain (x # ysa @ [z]) \\<Longrightarrow>\n       order.greater_eq (length ysa) (length ys)", "with assms"], ["proof (chain)\npicking this:\n  min_maxsimpchain (w # x # ys @ [z])\n  maxsimpchain (w # x # zs @ [z])", "show \"length ys \\<le> length zs\""], ["proof (prove)\nusing this:\n  min_maxsimpchain (w # x # ys @ [z])\n  maxsimpchain (w # x # zs @ [z])\n\ngoal (1 subgoal):\n 1. order.greater_eq (length zs) (length ys)", "using min_maxsimpchainD_min_betw[of w \"x#ys\" z \"x#zs\"]"], ["proof (prove)\nusing this:\n  min_maxsimpchain (w # x # ys @ [z])\n  maxsimpchain (w # x # zs @ [z])\n  \\<lbrakk>min_maxsimpchain (w # (x # ys) @ [z]);\n   maxsimpchain (w # (x # zs) @ [z])\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length (x # zs)) (length (x # ys))\n\ngoal (1 subgoal):\n 1. order.greater_eq (length zs) (length ys)", "by simp"], ["proof (state)\nthis:\n  order.greater_eq (length zs) (length ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_maxsimpchain_betw_uniform_length:\n  assumes \"min_maxsimpchain (x#xs@[y])\" \"min_maxsimpchain (x#ys@[y])\"\n  shows   \"length xs = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys", "using   min_maxsimpchainD_min_betw[OF assms(1)]\n          min_maxsimpchainD_min_betw[OF assms(2)]\n          min_maxsimpchainD_maxsimpchain[OF assms(1)]\n          min_maxsimpchainD_maxsimpchain[OF assms(2)]"], ["proof (prove)\nusing this:\n  maxsimpchain (x # ?ys @ [y]) \\<Longrightarrow>\n  order.greater_eq (length ?ys) (length xs)\n  maxsimpchain (x # ?ys @ [y]) \\<Longrightarrow>\n  order.greater_eq (length ?ys) (length ys)\n  maxsimpchain (x # xs @ [y])\n  maxsimpchain (x # ys @ [y])\n\ngoal (1 subgoal):\n 1. length xs = length ys", "by      fastforce"], ["", "lemma not_min_maxsimpchainI_betw:\n  \"\\<lbrakk> maxsimpchain (x#ys@[y]); length ys < length xs \\<rbrakk> \\<Longrightarrow>\n    \\<not> min_maxsimpchain (x#xs@[y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimpchain (x # ys @ [y]);\n     order.greater (length xs) (length ys)\\<rbrakk>\n    \\<Longrightarrow> \\<not> min_maxsimpchain (x # xs @ [y])", "using min_maxsimpchainD_min_betw not_less"], ["proof (prove)\nusing this:\n  \\<lbrakk>min_maxsimpchain (?x # ?xs @ [?y]);\n   maxsimpchain (?x # ?ys @ [?y])\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length ?ys) (length ?xs)\n  (\\<not> order.greater ?y ?x) = order.greater_eq ?x ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimpchain (x # ys @ [y]);\n     order.greater (length xs) (length ys)\\<rbrakk>\n    \\<Longrightarrow> \\<not> min_maxsimpchain (x # xs @ [y])", "by blast"], ["", "lemma maxsimpchain_in_subcomplex:\n  \"\\<lbrakk> Subcomplex Y; set ys \\<subseteq> Y; maxsimpchain ys \\<rbrakk> \\<Longrightarrow>\n    SimplicialComplex.maxsimpchain Y ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq X Y \\<and> SimplicialComplex Y;\n     order.greater_eq Y (set ys); maxsimpchain ys\\<rbrakk>\n    \\<Longrightarrow> SimplicialComplex.maxsimpchain Y ys", "using maxsimpchain_def max_in_subcomplex\n        SimplicialComplex.maxsimpchain_def"], ["proof (prove)\nusing this:\n  maxsimpchain ?xs \\<equiv> Ball (set ?xs) maxsimp \\<and> adjacentchain ?xs\n  \\<lbrakk>order.greater_eq X ?Y \\<and> SimplicialComplex ?Y; ?y \\<in> ?Y;\n   maxsimp ?y\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp ?Y ?y\n  SimplicialComplex ?X \\<Longrightarrow>\n  SimplicialComplex.maxsimpchain ?X ?xs \\<equiv>\n  (\\<forall>x\\<in>set ?xs. SimplicialComplex.maxsimp ?X x) \\<and>\n  adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order.greater_eq X Y \\<and> SimplicialComplex Y;\n     order.greater_eq Y (set ys); maxsimpchain ys\\<rbrakk>\n    \\<Longrightarrow> SimplicialComplex.maxsimpchain Y ys", "by    force"], ["", "end"], ["", "(* context SimplicialComplex *)"], ["", "subsection \\<open>Isomorphisms of simplicial complexes\\<close>"], ["", "text \\<open>\n  Here we develop the concept of isomorphism of simplicial complexes. Note that we have not\n  bothered to first develop the concept of morphism of simplicial complexes, since every function\n  on the vertex set of a simplicial complex can be considered a morphism of complexes (see lemma\n  \\<open>map_is_simplicial_morph\\<close> above).\n\\<close>"], ["", "locale SimplicialComplexIsomorphism = SimplicialComplex X\n  for X :: \"'a set set\"\n+ fixes f :: \"'a \\<Rightarrow> 'b\"\n  assumes inj: \"inj_on f (\\<Union>X)\"\nbegin"], ["", "lemmas morph = map_is_simplicial_morph[of f]"], ["", "lemma iso_codim_map:\n  \"x \\<in> X \\<Longrightarrow> y \\<in> X \\<Longrightarrow> card (f`x - f`y) = card (x-y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X; y \\<in> X\\<rbrakk>\n    \\<Longrightarrow> card (f ` x - f ` y) = card (x - y)", "using inj inj_on_image_set_diff[of f _ x y] finite_simplex subset_inj_on[of f _ \"x-y\"]\n        inj_on_iff_eq_card[of \"x-y\"]"], ["proof (prove)\nusing this:\n  inj_on f (\\<Union> X)\n  \\<lbrakk>inj_on f ?C; order.greater_eq ?C (x - y);\n   order.greater_eq ?C y\\<rbrakk>\n  \\<Longrightarrow> f ` (x - y) = f ` x - f ` y\n  ?x \\<in> X \\<Longrightarrow> finite ?x\n  \\<lbrakk>inj_on f ?B; order.greater_eq ?B (x - y)\\<rbrakk>\n  \\<Longrightarrow> inj_on f (x - y)\n  finite (x - y) \\<Longrightarrow>\n  inj_on ?f (x - y) = (card (?f ` (x - y)) = card (x - y))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X; y \\<in> X\\<rbrakk>\n    \\<Longrightarrow> card (f ` x - f ` y) = card (x - y)", "by    fastforce"], ["", "lemma maxsimp_im_max: \"maxsimp x \\<Longrightarrow> w \\<in> X \\<Longrightarrow> f`x \\<subseteq> f`w \\<Longrightarrow> f`w = f`x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimp x; w \\<in> X; order.greater_eq (f ` w) (f ` x)\\<rbrakk>\n    \\<Longrightarrow> f ` w = f ` x", "using maxsimpD_simplex inj_onD[OF inj] maxsimpD_maximal[of x w]"], ["proof (prove)\nusing this:\n  maxsimp ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>f ?x = f ?y; ?x \\<in> \\<Union> X; ?y \\<in> \\<Union> X\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  \\<lbrakk>maxsimp x; w \\<in> X; order.greater_eq w x\\<rbrakk>\n  \\<Longrightarrow> w = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>maxsimp x; w \\<in> X; order.greater_eq (f ` w) (f ` x)\\<rbrakk>\n    \\<Longrightarrow> f ` w = f ` x", "by blast"], ["", "lemma maxsimp_map:\n  \"maxsimp x \\<Longrightarrow> SimplicialComplex.maxsimp (f\\<turnstile>X) (f`x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxsimp x \\<Longrightarrow>\n    SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` x)", "using maxsimpD_simplex maxsimp_im_max morph\n        SimplicialComplex.maxsimpI[of \"f\\<turnstile>X\" \"f`x\"]"], ["proof (prove)\nusing this:\n  maxsimp ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>maxsimp ?x; ?w \\<in> X;\n   order.greater_eq (f ` ?w) (f ` ?x)\\<rbrakk>\n  \\<Longrightarrow> f ` ?w = f ` ?x\n  SimplicialComplex (f \\<turnstile> X)\n  \\<lbrakk>SimplicialComplex (f \\<turnstile> X);\n   f ` x \\<in> f \\<turnstile> X;\n   \\<And>z.\n      \\<lbrakk>z \\<in> f \\<turnstile> X; order.greater_eq z (f ` x)\\<rbrakk>\n      \\<Longrightarrow> z = f ` x\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` x)\n\ngoal (1 subgoal):\n 1. maxsimp x \\<Longrightarrow>\n    SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` x)", "by    fastforce"], ["", "lemma iso_adj_int_im:\n  assumes \"maxsimp x\" \"maxsimp y\" \"x\\<sim>y\" \"x\\<noteq>y\"\n  shows \"(f`x \\<inter> f`y) \\<lhd> f`x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` x \\<inter> f ` y \\<lhd> f ` x", "proof (rule facetrelI_card)"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq (f ` x) (f ` x \\<inter> f ` y)\n 2. card (f ` x - f ` x \\<inter> f ` y) = 1", "from assms(1,2)"], ["proof (chain)\npicking this:\n  maxsimp x\n  maxsimp y", "have  1: \"f ` x \\<subseteq> f ` y \\<Longrightarrow> f ` y = f ` x\""], ["proof (prove)\nusing this:\n  maxsimp x\n  maxsimp y\n\ngoal (1 subgoal):\n 1. order.greater_eq (f ` y) (f ` x) \\<Longrightarrow> f ` y = f ` x", "using maxsimp_map SimplicialComplex.maxsimpD_simplex[OF morph]\n          SimplicialComplex.maxsimpD_maximal[OF morph]"], ["proof (prove)\nusing this:\n  maxsimp x\n  maxsimp y\n  maxsimp ?x \\<Longrightarrow>\n  SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` ?x)\n  SimplicialComplex.maxsimp (f \\<turnstile> X) ?x \\<Longrightarrow>\n  ?x \\<in> f \\<turnstile> X\n  \\<lbrakk>SimplicialComplex.maxsimp (f \\<turnstile> X) ?x;\n   ?z \\<in> f \\<turnstile> X; order.greater_eq ?z ?x\\<rbrakk>\n  \\<Longrightarrow> ?z = ?x\n\ngoal (1 subgoal):\n 1. order.greater_eq (f ` y) (f ` x) \\<Longrightarrow> f ` y = f ` x", "by    simp"], ["proof (state)\nthis:\n  order.greater_eq (f ` y) (f ` x) \\<Longrightarrow> f ` y = f ` x\n\ngoal (2 subgoals):\n 1. order.greater_eq (f ` x) (f ` x \\<inter> f ` y)\n 2. card (f ` x - f ` x \\<inter> f ` y) = 1", "thus \"f`x \\<inter> f`y \\<subseteq> f`x\""], ["proof (prove)\nusing this:\n  order.greater_eq (f ` y) (f ` x) \\<Longrightarrow> f ` y = f ` x\n\ngoal (1 subgoal):\n 1. order.greater_eq (f ` x) (f ` x \\<inter> f ` y)", "by fast"], ["proof (state)\nthis:\n  order.greater_eq (f ` x) (f ` x \\<inter> f ` y)\n\ngoal (1 subgoal):\n 1. card (f ` x - f ` x \\<inter> f ` y) = 1", "from assms(1)"], ["proof (chain)\npicking this:\n  maxsimp x", "have \"card (f`x - f`x \\<inter> f`y) \\<le> card (f`x - f`(x\\<inter>y))\""], ["proof (prove)\nusing this:\n  maxsimp x\n\ngoal (1 subgoal):\n 1. order.greater_eq (card (f ` x - f ` (x \\<inter> y)))\n     (card (f ` x - f ` x \\<inter> f ` y))", "using finite_maxsimp card_mono[of \"f`x - f`(x\\<inter>y)\" \"f`x - f`x \\<inter> f`y\"]"], ["proof (prove)\nusing this:\n  maxsimp x\n  maxsimp ?x \\<Longrightarrow> finite ?x\n  \\<lbrakk>finite (f ` x - f ` (x \\<inter> y));\n   order.greater_eq (f ` x - f ` (x \\<inter> y))\n    (f ` x - f ` x \\<inter> f ` y)\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (card (f ` x - f ` (x \\<inter> y)))\n                     (card (f ` x - f ` x \\<inter> f ` y))\n\ngoal (1 subgoal):\n 1. order.greater_eq (card (f ` x - f ` (x \\<inter> y)))\n     (card (f ` x - f ` x \\<inter> f ` y))", "by fast"], ["proof (state)\nthis:\n  order.greater_eq (card (f ` x - f ` (x \\<inter> y)))\n   (card (f ` x - f ` x \\<inter> f ` y))\n\ngoal (1 subgoal):\n 1. card (f ` x - f ` x \\<inter> f ` y) = 1", "moreover"], ["proof (state)\nthis:\n  order.greater_eq (card (f ` x - f ` (x \\<inter> y)))\n   (card (f ` x - f ` x \\<inter> f ` y))\n\ngoal (1 subgoal):\n 1. card (f ` x - f ` x \\<inter> f ` y) = 1", "from assms(1,3,4)"], ["proof (chain)\npicking this:\n  maxsimp x\n  x \\<sim> y\n  x \\<noteq> y", "have \"card (f`x - f`(x\\<inter>y)) = 1\""], ["proof (prove)\nusing this:\n  maxsimp x\n  x \\<sim> y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. card (f ` x - f ` (x \\<inter> y)) = 1", "using maxsimpD_simplex faces[of x] maxsimpD_simplex\n          iso_codim_map adjacent_int_facet1[of x y] facetrel_card"], ["proof (prove)\nusing this:\n  maxsimp x\n  x \\<sim> y\n  x \\<noteq> y\n  maxsimp ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>x \\<in> X; order.greater_eq x ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> X\n  maxsimp ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>?x \\<in> X; ?y \\<in> X\\<rbrakk>\n  \\<Longrightarrow> card (f ` ?x - f ` ?y) = card (?x - ?y)\n  \\<lbrakk>x \\<sim> y; x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> x \\<inter> y \\<lhd> x\n  ?y \\<lhd> ?x \\<Longrightarrow> card (?x - ?y) = 1\n\ngoal (1 subgoal):\n 1. card (f ` x - f ` (x \\<inter> y)) = 1", "by    fastforce"], ["proof (state)\nthis:\n  card (f ` x - f ` (x \\<inter> y)) = 1\n\ngoal (1 subgoal):\n 1. card (f ` x - f ` x \\<inter> f ` y) = 1", "ultimately"], ["proof (chain)\npicking this:\n  order.greater_eq (card (f ` x - f ` (x \\<inter> y)))\n   (card (f ` x - f ` x \\<inter> f ` y))\n  card (f ` x - f ` (x \\<inter> y)) = 1", "have \"card (f`x - f`x \\<inter> f`y) \\<le> 1\""], ["proof (prove)\nusing this:\n  order.greater_eq (card (f ` x - f ` (x \\<inter> y)))\n   (card (f ` x - f ` x \\<inter> f ` y))\n  card (f ` x - f ` (x \\<inter> y)) = 1\n\ngoal (1 subgoal):\n 1. order.greater_eq 1 (card (f ` x - f ` x \\<inter> f ` y))", "by simp"], ["proof (state)\nthis:\n  order.greater_eq 1 (card (f ` x - f ` x \\<inter> f ` y))\n\ngoal (1 subgoal):\n 1. card (f ` x - f ` x \\<inter> f ` y) = 1", "moreover"], ["proof (state)\nthis:\n  order.greater_eq 1 (card (f ` x - f ` x \\<inter> f ` y))\n\ngoal (1 subgoal):\n 1. card (f ` x - f ` x \\<inter> f ` y) = 1", "from assms(1,2,4)"], ["proof (chain)\npicking this:\n  maxsimp x\n  maxsimp y\n  x \\<noteq> y", "have \"card (f`x - f`x \\<inter> f`y) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  maxsimp x\n  maxsimp y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. card (f ` x - f ` x \\<inter> f ` y) \\<noteq> 0", "using 1 maxsimpD_simplex finite_maxsimp\n          inj_onD[OF induced_pow_fun_inj_on, OF inj, of x y]"], ["proof (prove)\nusing this:\n  maxsimp x\n  maxsimp y\n  x \\<noteq> y\n  order.greater_eq (f ` y) (f ` x) \\<Longrightarrow> f ` y = f ` x\n  maxsimp ?x \\<Longrightarrow> ?x \\<in> X\n  maxsimp ?x \\<Longrightarrow> finite ?x\n  \\<lbrakk>f ` x = f ` y; x \\<in> Pow (\\<Union> X);\n   y \\<in> Pow (\\<Union> X)\\<rbrakk>\n  \\<Longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. card (f ` x - f ` x \\<inter> f ` y) \\<noteq> 0", "by    auto"], ["proof (state)\nthis:\n  card (f ` x - f ` x \\<inter> f ` y) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (f ` x - f ` x \\<inter> f ` y) = 1", "ultimately"], ["proof (chain)\npicking this:\n  order.greater_eq 1 (card (f ` x - f ` x \\<inter> f ` y))\n  card (f ` x - f ` x \\<inter> f ` y) \\<noteq> 0", "show \"card (f`x - f`x \\<inter> f`y) = 1\""], ["proof (prove)\nusing this:\n  order.greater_eq 1 (card (f ` x - f ` x \\<inter> f ` y))\n  card (f ` x - f ` x \\<inter> f ` y) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (f ` x - f ` x \\<inter> f ` y) = 1", "by simp"], ["proof (state)\nthis:\n  card (f ` x - f ` x \\<inter> f ` y) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iso_adj_map:\n  assumes \"maxsimp x\" \"maxsimp y\" \"x\\<sim>y\" \"x\\<noteq>y\"\n  shows   \"f`x \\<sim> f`y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` x \\<sim> f ` y", "using assms(3,4) iso_adj_int_im[OF assms] adjacent_sym\n        iso_adj_int_im[OF assms(2) assms(1)]"], ["proof (prove)\nusing this:\n  x \\<sim> y\n  x \\<noteq> y\n  f ` x \\<inter> f ` y \\<lhd> f ` x\n  ?x \\<sim> ?y \\<Longrightarrow> ?y \\<sim> ?x\n  \\<lbrakk>y \\<sim> x; y \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> f ` y \\<inter> f ` x \\<lhd> f ` y\n\ngoal (1 subgoal):\n 1. f ` x \\<sim> f ` y", "by    (auto simp add: Int_commute intro: adjacentI)"], ["", "lemma pmaxsimpchain_map:\n  \"pmaxsimpchain xs \\<Longrightarrow> SimplicialComplex.pmaxsimpchain (f\\<turnstile>X) (f\\<Turnstile>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmaxsimpchain xs \\<Longrightarrow>\n    SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (f \\<Turnstile> xs)", "proof (induct xs rule: list_induct_CCons)"], ["proof (state)\ngoal (3 subgoals):\n 1. pmaxsimpchain [] \\<Longrightarrow>\n    SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (f \\<Turnstile> [])\n 2. \\<And>x.\n       pmaxsimpchain [x] \\<Longrightarrow>\n       SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n        (f \\<Turnstile> [x])\n 3. \\<And>x y xs.\n       \\<lbrakk>pmaxsimpchain (y # xs) \\<Longrightarrow>\n                SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                 (f \\<Turnstile> (y # xs));\n        pmaxsimpchain (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                          (f \\<Turnstile> (x # y # xs))", "case Nil"], ["proof (state)\nthis:\n  pmaxsimpchain []\n\ngoal (3 subgoals):\n 1. pmaxsimpchain [] \\<Longrightarrow>\n    SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (f \\<Turnstile> [])\n 2. \\<And>x.\n       pmaxsimpchain [x] \\<Longrightarrow>\n       SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n        (f \\<Turnstile> [x])\n 3. \\<And>x y xs.\n       \\<lbrakk>pmaxsimpchain (y # xs) \\<Longrightarrow>\n                SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                 (f \\<Turnstile> (y # xs));\n        pmaxsimpchain (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                          (f \\<Turnstile> (x # y # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (f \\<Turnstile> [])", "using map_is_simplicial_morph SimplicialComplex.pmaxsimpchain_def"], ["proof (prove)\nusing this:\n  SimplicialComplex (?f \\<turnstile> X)\n  SimplicialComplex ?X \\<Longrightarrow>\n  SimplicialComplex.pmaxsimpchain ?X ?xs \\<equiv>\n  (\\<forall>x\\<in>set ?xs. SimplicialComplex.maxsimp ?X x) \\<and>\n  padjacentchain ?xs\n\ngoal (1 subgoal):\n 1. SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (f \\<Turnstile> [])", "by    fastforce"], ["proof (state)\nthis:\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (f \\<Turnstile> [])\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       pmaxsimpchain [x] \\<Longrightarrow>\n       SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n        (f \\<Turnstile> [x])\n 2. \\<And>x y xs.\n       \\<lbrakk>pmaxsimpchain (y # xs) \\<Longrightarrow>\n                SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                 (f \\<Turnstile> (y # xs));\n        pmaxsimpchain (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                          (f \\<Turnstile> (x # y # xs))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       pmaxsimpchain [x] \\<Longrightarrow>\n       SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n        (f \\<Turnstile> [x])\n 2. \\<And>x y xs.\n       \\<lbrakk>pmaxsimpchain (y # xs) \\<Longrightarrow>\n                SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                 (f \\<Turnstile> (y # xs));\n        pmaxsimpchain (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                          (f \\<Turnstile> (x # y # xs))", "case (Single x)"], ["proof (state)\nthis:\n  pmaxsimpchain [x]\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       pmaxsimpchain [x] \\<Longrightarrow>\n       SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n        (f \\<Turnstile> [x])\n 2. \\<And>x y xs.\n       \\<lbrakk>pmaxsimpchain (y # xs) \\<Longrightarrow>\n                SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                 (f \\<Turnstile> (y # xs));\n        pmaxsimpchain (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                          (f \\<Turnstile> (x # y # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  pmaxsimpchain [x]\n\ngoal (1 subgoal):\n 1. SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (f \\<Turnstile> [x])", "using map_is_simplicial_morph pmaxsimpchainD_maxsimp maxsimp_map\n          SimplicialComplex.pmaxsimpchain_def"], ["proof (prove)\nusing this:\n  pmaxsimpchain [x]\n  SimplicialComplex (?f \\<turnstile> X)\n  \\<lbrakk>pmaxsimpchain ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> maxsimp ?x\n  maxsimp ?x \\<Longrightarrow>\n  SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` ?x)\n  SimplicialComplex ?X \\<Longrightarrow>\n  SimplicialComplex.pmaxsimpchain ?X ?xs \\<equiv>\n  (\\<forall>x\\<in>set ?xs. SimplicialComplex.maxsimp ?X x) \\<and>\n  padjacentchain ?xs\n\ngoal (1 subgoal):\n 1. SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (f \\<Turnstile> [x])", "by    fastforce"], ["proof (state)\nthis:\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) (f \\<Turnstile> [x])\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>pmaxsimpchain (y # xs) \\<Longrightarrow>\n                SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                 (f \\<Turnstile> (y # xs));\n        pmaxsimpchain (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                          (f \\<Turnstile> (x # y # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>pmaxsimpchain (y # xs) \\<Longrightarrow>\n                SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                 (f \\<Turnstile> (y # xs));\n        pmaxsimpchain (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                          (f \\<Turnstile> (x # y # xs))", "case (CCons x y xs)"], ["proof (state)\nthis:\n  pmaxsimpchain (y # xs) \\<Longrightarrow>\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n   (f \\<Turnstile> (y # xs))\n  pmaxsimpchain (x # y # xs)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>pmaxsimpchain (y # xs) \\<Longrightarrow>\n                SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                 (f \\<Turnstile> (y # xs));\n        pmaxsimpchain (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                          (f \\<Turnstile> (x # y # xs))", "have \"SimplicialComplex.pmaxsimpchain (f \\<turnstile> X) ( f`x # f`y # f\\<Turnstile>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n     (f ` x # f ` y # f \\<Turnstile> xs)", "proof (\n    rule SimplicialComplex.pmaxsimpchain_CConsI,\n    rule map_is_simplicial_morph\n  )"], ["proof (state)\ngoal (4 subgoals):\n 1. SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` x)\n 2. SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n     (f ` y # f \\<Turnstile> xs)\n 3. f ` x \\<sim> f ` y\n 4. f ` x \\<notin> set (f ` y # f \\<Turnstile> xs)", "from CCons(2)"], ["proof (chain)\npicking this:\n  pmaxsimpchain (x # y # xs)", "show \"SimplicialComplex.maxsimp (f\\<turnstile>X) (f`x)\""], ["proof (prove)\nusing this:\n  pmaxsimpchain (x # y # xs)\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` x)", "using pmaxsimpchainD_maxsimp maxsimp_map"], ["proof (prove)\nusing this:\n  pmaxsimpchain (x # y # xs)\n  \\<lbrakk>pmaxsimpchain ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> maxsimp ?x\n  maxsimp ?x \\<Longrightarrow>\n  SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` ?x)\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` x)", "by simp"], ["proof (state)\nthis:\n  SimplicialComplex.maxsimp (f \\<turnstile> X) (f ` x)\n\ngoal (3 subgoals):\n 1. SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n     (f ` y # f \\<Turnstile> xs)\n 2. f ` x \\<sim> f ` y\n 3. f ` x \\<notin> set (f ` y # f \\<Turnstile> xs)", "from CCons"], ["proof (chain)\npicking this:\n  pmaxsimpchain (y # xs) \\<Longrightarrow>\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n   (f \\<Turnstile> (y # xs))\n  pmaxsimpchain (x # y # xs)", "show \"SimplicialComplex.pmaxsimpchain (f\\<turnstile>X) (f`y # f\\<Turnstile>xs)\""], ["proof (prove)\nusing this:\n  pmaxsimpchain (y # xs) \\<Longrightarrow>\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n   (f \\<Turnstile> (y # xs))\n  pmaxsimpchain (x # y # xs)\n\ngoal (1 subgoal):\n 1. SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n     (f ` y # f \\<Turnstile> xs)", "using pmaxsimpchain_Cons_reduce"], ["proof (prove)\nusing this:\n  pmaxsimpchain (y # xs) \\<Longrightarrow>\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n   (f \\<Turnstile> (y # xs))\n  pmaxsimpchain (x # y # xs)\n  pmaxsimpchain (?x # ?xs) \\<Longrightarrow> pmaxsimpchain ?xs\n\ngoal (1 subgoal):\n 1. SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n     (f ` y # f \\<Turnstile> xs)", "by simp"], ["proof (state)\nthis:\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n   (f ` y # f \\<Turnstile> xs)\n\ngoal (2 subgoals):\n 1. f ` x \\<sim> f ` y\n 2. f ` x \\<notin> set (f ` y # f \\<Turnstile> xs)", "from CCons(2)"], ["proof (chain)\npicking this:\n  pmaxsimpchain (x # y # xs)", "show \"f`x \\<sim> f`y\""], ["proof (prove)\nusing this:\n  pmaxsimpchain (x # y # xs)\n\ngoal (1 subgoal):\n 1. f ` x \\<sim> f ` y", "using pmaxsimpchain_def iso_adj_map"], ["proof (prove)\nusing this:\n  pmaxsimpchain (x # y # xs)\n  pmaxsimpchain ?xs \\<equiv>\n  Ball (set ?xs) maxsimp \\<and> padjacentchain ?xs\n  \\<lbrakk>maxsimp ?x; maxsimp ?y; ?x \\<sim> ?y; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> f ` ?x \\<sim> f ` ?y\n\ngoal (1 subgoal):\n 1. f ` x \\<sim> f ` y", "by simp"], ["proof (state)\nthis:\n  f ` x \\<sim> f ` y\n\ngoal (1 subgoal):\n 1. f ` x \\<notin> set (f ` y # f \\<Turnstile> xs)", "from inj CCons(2)"], ["proof (chain)\npicking this:\n  inj_on f (\\<Union> X)\n  pmaxsimpchain (x # y # xs)", "have \"distinct (f\\<Turnstile>(x#y#xs))\""], ["proof (prove)\nusing this:\n  inj_on f (\\<Union> X)\n  pmaxsimpchain (x # y # xs)\n\ngoal (1 subgoal):\n 1. distinct (f \\<Turnstile> (x # y # xs))", "using     maxsimpD_simplex inj_on_distinct_setlistmapim"], ["proof (prove)\nusing this:\n  inj_on f (\\<Union> X)\n  pmaxsimpchain (x # y # xs)\n  maxsimp ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>inj_on ?f ?A; \\<forall>X\\<in>set ?Xs. order.greater_eq ?A X;\n   distinct ?Xs\\<rbrakk>\n  \\<Longrightarrow> distinct (?f \\<Turnstile> ?Xs)\n\ngoal (1 subgoal):\n 1. distinct (f \\<Turnstile> (x # y # xs))", "unfolding pmaxsimpchain_def"], ["proof (prove)\nusing this:\n  inj_on f (\\<Union> X)\n  Ball (set (x # y # xs)) maxsimp \\<and> padjacentchain (x # y # xs)\n  maxsimp ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>inj_on ?f ?A; \\<forall>X\\<in>set ?Xs. order.greater_eq ?A X;\n   distinct ?Xs\\<rbrakk>\n  \\<Longrightarrow> distinct (?f \\<Turnstile> ?Xs)\n\ngoal (1 subgoal):\n 1. distinct (f \\<Turnstile> (x # y # xs))", "by        blast"], ["proof (state)\nthis:\n  distinct (f \\<Turnstile> (x # y # xs))\n\ngoal (1 subgoal):\n 1. f ` x \\<notin> set (f ` y # f \\<Turnstile> xs)", "thus \"f`x \\<notin> set (f`y # f\\<Turnstile>xs)\""], ["proof (prove)\nusing this:\n  distinct (f \\<Turnstile> (x # y # xs))\n\ngoal (1 subgoal):\n 1. f ` x \\<notin> set (f ` y # f \\<Turnstile> xs)", "by simp"], ["proof (state)\nthis:\n  f ` x \\<notin> set (f ` y # f \\<Turnstile> xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n   (f ` x # f ` y # f \\<Turnstile> xs)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs.\n       \\<lbrakk>pmaxsimpchain (y # xs) \\<Longrightarrow>\n                SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                 (f \\<Turnstile> (y # xs));\n        pmaxsimpchain (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n                          (f \\<Turnstile> (x # y # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n   (f ` x # f ` y # f \\<Turnstile> xs)\n\ngoal (1 subgoal):\n 1. SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n     (f \\<Turnstile> (x # y # xs))", "by simp"], ["proof (state)\nthis:\n  SimplicialComplex.pmaxsimpchain (f \\<turnstile> X)\n   (f \\<Turnstile> (x # y # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context SimplicialComplexIsomorphism *)"], ["", "subsection \\<open>The complex associated to a poset\\<close>"], ["", "text \\<open>\n  A simplicial complex is naturally a poset under the subset relation. The following develops the\n  reverse direction: constructing a simplicial complex from a suitable poset.\n\\<close>"], ["", "context ordering\nbegin"], ["", "definition PosetComplex :: \"'a set \\<Rightarrow> 'a set set\"\n  where \"PosetComplex P \\<equiv> (\\<Union>x\\<in>P. { {y. pseudominimal_in (P.\\<^bold>\\<le>x) y} })\""], ["", "lemma poset_is_SimplicialComplex:\n  assumes \"\\<forall>x\\<in>P. simplex_like (P.\\<^bold>\\<le>x)\"\n  shows   \"SimplicialComplex (PosetComplex P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplex (PosetComplex P)", "proof (rule SimplicialComplex.intro, rule ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> PosetComplex P \\<Longrightarrow> finite x\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> PosetComplex P; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> PosetComplex P", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> PosetComplex P \\<Longrightarrow> finite x\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> PosetComplex P; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> PosetComplex P", "assume \"a \\<in> PosetComplex P\""], ["proof (state)\nthis:\n  a \\<in> PosetComplex P\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> PosetComplex P \\<Longrightarrow> finite x\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> PosetComplex P; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> PosetComplex P", "from this"], ["proof (chain)\npicking this:\n  a \\<in> PosetComplex P", "obtain x where \"x\\<in>P\" \"a = {y. pseudominimal_in (P.\\<^bold>\\<le>x) y}\""], ["proof (prove)\nusing this:\n  a \\<in> PosetComplex P\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> P;\n         a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding PosetComplex_def"], ["proof (prove)\nusing this:\n  a \\<in> (\\<Union>x\\<in>P. {{y. pseudominimal_in (P .\\<^bold>\\<le> x) y}})\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> P;\n         a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  x \\<in> P\n  a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> PosetComplex P \\<Longrightarrow> finite x\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> PosetComplex P; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> PosetComplex P", "with assms"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>P. simplex_like (P .\\<^bold>\\<le> x)\n  x \\<in> P\n  a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}", "show \"finite a\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>P. simplex_like (P .\\<^bold>\\<le> x)\n  x \\<in> P\n  a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}\n\ngoal (1 subgoal):\n 1. finite a", "using pseudominimal_inD1 simplex_likeD_finite finite_subset[of a \"P.\\<^bold>\\<le>x\"]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>P. simplex_like (P .\\<^bold>\\<le> x)\n  x \\<in> P\n  a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}\n  pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n  simplex_like ?P \\<Longrightarrow> finite ?P\n  \\<lbrakk>order.greater_eq (P .\\<^bold>\\<le> x) a;\n   finite (P .\\<^bold>\\<le> x)\\<rbrakk>\n  \\<Longrightarrow> finite a\n\ngoal (1 subgoal):\n 1. finite a", "by fast"], ["proof (state)\nthis:\n  finite a\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> PosetComplex P; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> PosetComplex P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> PosetComplex P; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> PosetComplex P", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> PosetComplex P; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> PosetComplex P", "assume ab: \"a \\<in> PosetComplex P\" \"b\\<subseteq>a\""], ["proof (state)\nthis:\n  a \\<in> PosetComplex P\n  order.greater_eq a b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> PosetComplex P; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> PosetComplex P", "from ab(1)"], ["proof (chain)\npicking this:\n  a \\<in> PosetComplex P", "obtain x where x: \"x\\<in>P\" \"a = {y. pseudominimal_in (P.\\<^bold>\\<le>x) y}\""], ["proof (prove)\nusing this:\n  a \\<in> PosetComplex P\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> P;\n         a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding PosetComplex_def"], ["proof (prove)\nusing this:\n  a \\<in> (\\<Union>x\\<in>P. {{y. pseudominimal_in (P .\\<^bold>\\<le> x) y}})\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> P;\n         a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  x \\<in> P\n  a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> PosetComplex P; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> PosetComplex P", "from assms x(1)"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>P. simplex_like (P .\\<^bold>\\<le> x)\n  x \\<in> P", "obtain f and A::\"nat set\"\n    where fA: \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) (P.\\<^bold>\\<le>x) f\"\n              \"f`(P.\\<^bold>\\<le>x) = Pow A\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>P. simplex_like (P .\\<^bold>\\<le> x)\n  x \\<in> P\n\ngoal (1 subgoal):\n 1. (\\<And>f A.\n        \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><)\n                  dual_order.greater_eq dual_order.greater\n                  (P .\\<^bold>\\<le> x) f;\n         f ` (P .\\<^bold>\\<le> x) = Pow A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using simplex_likeD_iso[of \"P.\\<^bold>\\<le>x\"]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>P. simplex_like (P .\\<^bold>\\<le> x)\n  x \\<in> P\n  simplex_like (P .\\<^bold>\\<le> x) \\<Longrightarrow>\n  \\<exists>f A.\n     OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n      dual_order.greater (P .\\<^bold>\\<le> x) f \\<and>\n     f ` (P .\\<^bold>\\<le> x) = Pow A\n\ngoal (1 subgoal):\n 1. (\\<And>f A.\n        \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><)\n                  dual_order.greater_eq dual_order.greater\n                  (P .\\<^bold>\\<le> x) f;\n         f ` (P .\\<^bold>\\<le> x) = Pow A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> x) f\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> PosetComplex P; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> PosetComplex P", "define x' where x': \"x' \\<equiv> the_inv_into (P.\\<^bold>\\<le>x) f (\\<Union>(f`b))\""], ["proof (state)\nthis:\n  x' \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` b))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> PosetComplex P; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> PosetComplex P", "from fA x(2) ab(2) x'"], ["proof (chain)\npicking this:\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> x) f\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}\n  order.greater_eq a b\n  x' \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` b))", "have x'_P: \"x'\\<in>P\""], ["proof (prove)\nusing this:\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> x) f\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}\n  order.greater_eq a b\n  x' \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` b))\n\ngoal (1 subgoal):\n 1. x' \\<in> P", "using collect_pseudominimals_below_in_poset[of P x f]"], ["proof (prove)\nusing this:\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> x) f\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}\n  order.greater_eq a b\n  x' \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` b))\n  \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n            dual_order.greater (P .\\<^bold>\\<le> x) f;\n   f ` (P .\\<^bold>\\<le> x) = Pow ?A;\n   order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} ?a\\<rbrakk>\n  \\<Longrightarrow> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` ?a))\n                    \\<in> P\n\ngoal (1 subgoal):\n 1. x' \\<in> P", "by simp"], ["proof (state)\nthis:\n  x' \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> PosetComplex P; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> PosetComplex P", "moreover"], ["proof (state)\nthis:\n  x' \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> PosetComplex P; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> PosetComplex P", "from x fA ab(2) x'"], ["proof (chain)\npicking this:\n  x \\<in> P\n  a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> x) f\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq a b\n  x' \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` b))", "have \"b = {y. pseudominimal_in (P.\\<^bold>\\<le>x') y}\""], ["proof (prove)\nusing this:\n  x \\<in> P\n  a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> x) f\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq a b\n  x' \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` b))\n\ngoal (1 subgoal):\n 1. b = {y. pseudominimal_in (P .\\<^bold>\\<le> x') y}", "using collect_pseudominimals_below_in_eq[of x P f]"], ["proof (prove)\nusing this:\n  x \\<in> P\n  a = {y. pseudominimal_in (P .\\<^bold>\\<le> x) y}\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> x) f\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq a b\n  x' \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` b))\n  \\<lbrakk>x \\<in> P;\n   OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n    dual_order.greater (P .\\<^bold>\\<le> x) f;\n   f ` (P .\\<^bold>\\<le> x) = Pow ?A;\n   order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} ?a\\<rbrakk>\n  \\<Longrightarrow> ?a =\n                    {y. pseudominimal_in\n                         (P .\\<^bold>\\<le>\n                          the_inv_into (P .\\<^bold>\\<le> x) f\n                           (\\<Union> (f ` ?a)))\n                         y}\n\ngoal (1 subgoal):\n 1. b = {y. pseudominimal_in (P .\\<^bold>\\<le> x') y}", "by simp"], ["proof (state)\nthis:\n  b = {y. pseudominimal_in (P .\\<^bold>\\<le> x') y}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> PosetComplex P; order.greater_eq x y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> PosetComplex P", "ultimately"], ["proof (chain)\npicking this:\n  x' \\<in> P\n  b = {y. pseudominimal_in (P .\\<^bold>\\<le> x') y}", "show \"b \\<in> PosetComplex P\""], ["proof (prove)\nusing this:\n  x' \\<in> P\n  b = {y. pseudominimal_in (P .\\<^bold>\\<le> x') y}\n\ngoal (1 subgoal):\n 1. b \\<in> PosetComplex P", "unfolding PosetComplex_def"], ["proof (prove)\nusing this:\n  x' \\<in> P\n  b = {y. pseudominimal_in (P .\\<^bold>\\<le> x') y}\n\ngoal (1 subgoal):\n 1. b \\<in> (\\<Union>x\\<in>P.\n                {{y. pseudominimal_in (P .\\<^bold>\\<le> x) y}})", "by fast"], ["proof (state)\nthis:\n  b \\<in> PosetComplex P\n\ngoal:\nNo subgoals!", "qed"], ["", "definition poset_simplex_map :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> 'a set\"\n  where \"poset_simplex_map P x = {y. pseudominimal_in (P.\\<^bold>\\<le>x) y}\""], ["", "lemma poset_to_PosetComplex_OrderingSetMap:\n  assumes \"\\<And>x. x\\<in>P \\<Longrightarrow> simplex_like (P.\\<^bold>\\<le>x)\"\n  shows   \"OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) (\\<subseteq>) (\\<subset>) P (poset_simplex_map P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n     dual_order.greater P (poset_simplex_map P)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P; b \\<succeq> a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (poset_simplex_map P b)\n                          (poset_simplex_map P a)", "from assms"], ["proof (chain)\npicking this:\n  ?x \\<in> P \\<Longrightarrow> simplex_like (P .\\<^bold>\\<le> ?x)", "show  \"\\<And>a b. \\<lbrakk> a\\<in>P; b\\<in>P; a\\<^bold>\\<le>b \\<rbrakk> \\<Longrightarrow>\n            poset_simplex_map P a \\<subseteq> poset_simplex_map P b\""], ["proof (prove)\nusing this:\n  ?x \\<in> P \\<Longrightarrow> simplex_like (P .\\<^bold>\\<le> ?x)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P; b \\<succeq> a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (poset_simplex_map P b)\n                          (poset_simplex_map P a)", "using     simplex_like_has_bottom pseudominimal_in_below_in"], ["proof (prove)\nusing this:\n  ?x \\<in> P \\<Longrightarrow> simplex_like (P .\\<^bold>\\<le> ?x)\n  simplex_like ?P \\<Longrightarrow> has_bottom ?P\n  \\<lbrakk>has_bottom (?P .\\<^bold>\\<le> ?y); ?x \\<in> ?P; ?y \\<succeq> ?x;\n   pseudominimal_in (?P .\\<^bold>\\<le> ?x) ?w\\<rbrakk>\n  \\<Longrightarrow> pseudominimal_in (?P .\\<^bold>\\<le> ?y) ?w\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P; b \\<succeq> a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (poset_simplex_map P b)\n                          (poset_simplex_map P a)", "unfolding poset_simplex_map_def"], ["proof (prove)\nusing this:\n  ?x \\<in> P \\<Longrightarrow> simplex_like (P .\\<^bold>\\<le> ?x)\n  simplex_like ?P \\<Longrightarrow> has_bottom ?P\n  \\<lbrakk>has_bottom (?P .\\<^bold>\\<le> ?y); ?x \\<in> ?P; ?y \\<succeq> ?x;\n   pseudominimal_in (?P .\\<^bold>\\<le> ?x) ?w\\<rbrakk>\n  \\<Longrightarrow> pseudominimal_in (?P .\\<^bold>\\<le> ?y) ?w\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P; b \\<succeq> a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq\n                          (Collect (pseudominimal_in (P .\\<^bold>\\<le> b)))\n                          (Collect (pseudominimal_in (P .\\<^bold>\\<le> a)))", "by        fast"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P; ?b \\<succeq> ?a\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (poset_simplex_map P ?b)\n                     (poset_simplex_map P ?a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ordering *)"], ["", "text \\<open>\n  When a poset affords a simplicial complex, there is a natural morphism of posets from the\n  source poset into the poset of sets in the complex, as above. However, some further assumptions\n  are necessary to ensure that this morphism is an isomorphism. These conditions are collected in\n  the following locale.\n\\<close>"], ["", "locale ComplexLikePoset = ordering less_eq less\n  for less_eq  :: \"'a\\<Rightarrow>'a\\<Rightarrow>bool\" (infix \"\\<^bold>\\<le>\"  50)\n  and less     :: \"'a\\<Rightarrow>'a\\<Rightarrow>bool\" (infix \"\\<^bold><\"  50)\n+ fixes   P :: \"'a set\"\n  assumes below_in_P_simplex_like: \"x\\<in>P \\<Longrightarrow> simplex_like (P.\\<^bold>\\<le>x)\"\n  and     P_has_bottom           : \"has_bottom P\"\n  and     P_has_glbs             : \"x\\<in>P \\<Longrightarrow> y\\<in>P \\<Longrightarrow> \\<exists>b. glbound_in_of P x y b\"\nbegin"], ["", "abbreviation \"smap \\<equiv> poset_simplex_map P\""], ["", "lemma smap_onto_PosetComplex: \"smap ` P = PosetComplex P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap ` P = PosetComplex P", "using poset_simplex_map_def PosetComplex_def"], ["proof (prove)\nusing this:\n  poset_simplex_map ?P ?x = {y. pseudominimal_in (?P .\\<^bold>\\<le> ?x) y}\n  PosetComplex ?P \\<equiv>\n  \\<Union>x\\<in>?P. {{y. pseudominimal_in (?P .\\<^bold>\\<le> x) y}}\n\ngoal (1 subgoal):\n 1. smap ` P = PosetComplex P", "by auto"], ["", "lemma ordsetmap_smap: \"\\<lbrakk> a\\<in>P; b\\<in>P; a\\<^bold>\\<le>b \\<rbrakk> \\<Longrightarrow> smap a \\<subseteq> smap b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> P; b \\<in> P; b \\<succeq> a\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq (smap b) (smap a)", "using OrderingSetMap.ordsetmap[\n          OF poset_to_PosetComplex_OrderingSetMap, OF below_in_P_simplex_like\n        ]\n        poset_simplex_map_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. x \\<in> P \\<Longrightarrow> x \\<in> P; ?a \\<in> P;\n   ?b \\<in> P; ?b \\<succeq> ?a\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (smap ?b) (smap ?a)\n  poset_simplex_map ?P ?x = {y. pseudominimal_in (?P .\\<^bold>\\<le> ?x) y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> P; b \\<in> P; b \\<succeq> a\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq (smap b) (smap a)", "by    simp"], ["", "lemma inj_on_smap: \"inj_on smap P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on smap P", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> P; y \\<in> P; smap x = smap y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> P; y \\<in> P; smap x = smap y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume xy: \"x\\<in>P\" \"y\\<in>P\" \"smap x = smap y\""], ["proof (state)\nthis:\n  x \\<in> P\n  y \\<in> P\n  smap x = smap y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> P; y \\<in> P; smap x = smap y\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (cases \"smap x = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. smap x = {} \\<Longrightarrow> x = y\n 2. smap x \\<noteq> {} \\<Longrightarrow> x = y", "case True"], ["proof (state)\nthis:\n  smap x = {}\n\ngoal (2 subgoals):\n 1. smap x = {} \\<Longrightarrow> x = y\n 2. smap x \\<noteq> {} \\<Longrightarrow> x = y", "with xy"], ["proof (chain)\npicking this:\n  x \\<in> P\n  y \\<in> P\n  smap x = smap y\n  smap x = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> P\n  y \\<in> P\n  smap x = smap y\n  smap x = {}\n\ngoal (1 subgoal):\n 1. x = y", "using poset_simplex_map_def below_in_P_simplex_like P_has_bottom\n            simplex_like_no_pseudominimal_in_below_in_imp_singleton[of x P]\n            simplex_like_no_pseudominimal_in_below_in_imp_singleton[of y P]\n            below_in_singleton_is_bottom[of P x] below_in_singleton_is_bottom[of P y]"], ["proof (prove)\nusing this:\n  x \\<in> P\n  y \\<in> P\n  smap x = smap y\n  smap x = {}\n  poset_simplex_map ?P ?x = {y. pseudominimal_in (?P .\\<^bold>\\<le> ?x) y}\n  ?x \\<in> P \\<Longrightarrow> simplex_like (P .\\<^bold>\\<le> ?x)\n  has_bottom P\n  \\<lbrakk>x \\<in> P; simplex_like (P .\\<^bold>\\<le> x);\n   \\<And>z. \\<not> pseudominimal_in (P .\\<^bold>\\<le> x) z\\<rbrakk>\n  \\<Longrightarrow> P .\\<^bold>\\<le> x = {x}\n  \\<lbrakk>y \\<in> P; simplex_like (P .\\<^bold>\\<le> y);\n   \\<And>z. \\<not> pseudominimal_in (P .\\<^bold>\\<le> y) z\\<rbrakk>\n  \\<Longrightarrow> P .\\<^bold>\\<le> y = {y}\n  \\<lbrakk>has_bottom P; x \\<in> P; P .\\<^bold>\\<le> x = {x}\\<rbrakk>\n  \\<Longrightarrow> x = bottom P\n  \\<lbrakk>has_bottom P; y \\<in> P; P .\\<^bold>\\<le> y = {y}\\<rbrakk>\n  \\<Longrightarrow> y = bottom P\n\ngoal (1 subgoal):\n 1. x = y", "by    auto"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. smap x \\<noteq> {} \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. smap x \\<noteq> {} \\<Longrightarrow> x = y", "case False"], ["proof (state)\nthis:\n  smap x \\<noteq> {}\n\ngoal (1 subgoal):\n 1. smap x \\<noteq> {} \\<Longrightarrow> x = y", "from this"], ["proof (chain)\npicking this:\n  smap x \\<noteq> {}", "obtain z where \"z \\<in> smap x\""], ["proof (prove)\nusing this:\n  smap x \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>z. z \\<in> smap x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  z \\<in> smap x\n\ngoal (1 subgoal):\n 1. smap x \\<noteq> {} \\<Longrightarrow> x = y", "with xy(3)"], ["proof (chain)\npicking this:\n  smap x = smap y\n  z \\<in> smap x", "have z1: \"z \\<in> P.\\<^bold>\\<le>x\" \"z \\<in> P.\\<^bold>\\<le>y\""], ["proof (prove)\nusing this:\n  smap x = smap y\n  z \\<in> smap x\n\ngoal (1 subgoal):\n 1. z \\<in> P .\\<^bold>\\<le> x &&& z \\<in> P .\\<^bold>\\<le> y", "using pseudominimal_inD1 poset_simplex_map_def"], ["proof (prove)\nusing this:\n  smap x = smap y\n  z \\<in> smap x\n  pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n  poset_simplex_map ?P ?x = {y. pseudominimal_in (?P .\\<^bold>\\<le> ?x) y}\n\ngoal (1 subgoal):\n 1. z \\<in> P .\\<^bold>\\<le> x &&& z \\<in> P .\\<^bold>\\<le> y", "by auto"], ["proof (state)\nthis:\n  z \\<in> P .\\<^bold>\\<le> x\n  z \\<in> P .\\<^bold>\\<le> y\n\ngoal (1 subgoal):\n 1. smap x \\<noteq> {} \\<Longrightarrow> x = y", "hence \"lbound_of x y z\""], ["proof (prove)\nusing this:\n  z \\<in> P .\\<^bold>\\<le> x\n  z \\<in> P .\\<^bold>\\<le> y\n\ngoal (1 subgoal):\n 1. lbound_of x y z", "by (auto intro: lbound_ofI)"], ["proof (state)\nthis:\n  lbound_of x y z\n\ngoal (1 subgoal):\n 1. smap x \\<noteq> {} \\<Longrightarrow> x = y", "with z1(1)"], ["proof (chain)\npicking this:\n  z \\<in> P .\\<^bold>\\<le> x\n  lbound_of x y z", "obtain b where b: \"glbound_in_of P x y b\""], ["proof (prove)\nusing this:\n  z \\<in> P .\\<^bold>\\<le> x\n  lbound_of x y z\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        glbound_in_of P x y b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using xy(1,2) P_has_glbs"], ["proof (prove)\nusing this:\n  z \\<in> P .\\<^bold>\\<le> x\n  lbound_of x y z\n  x \\<in> P\n  y \\<in> P\n  \\<lbrakk>?x \\<in> P; ?y \\<in> P\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b. glbound_in_of P ?x ?y b\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        glbound_in_of P x y b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  glbound_in_of P x y b\n\ngoal (1 subgoal):\n 1. smap x \\<noteq> {} \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  glbound_in_of P x y b\n\ngoal (1 subgoal):\n 1. smap x \\<noteq> {} \\<Longrightarrow> x = y", "have \"b \\<in> P.\\<^bold>\\<le>x\" \"b \\<in> P.\\<^bold>\\<le>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> P .\\<^bold>\\<le> x &&& b \\<in> P .\\<^bold>\\<le> y", "using glbound_in_ofD_in[OF b] glbound_in_of_less_eq1[OF b]\n            glbound_in_of_less_eq2[OF b]"], ["proof (prove)\nusing this:\n  b \\<in> P\n  x \\<succeq> b\n  y \\<succeq> b\n\ngoal (1 subgoal):\n 1. b \\<in> P .\\<^bold>\\<le> x &&& b \\<in> P .\\<^bold>\\<le> y", "by    auto"], ["proof (state)\nthis:\n  b \\<in> P .\\<^bold>\\<le> x\n  b \\<in> P .\\<^bold>\\<le> y\n\ngoal (1 subgoal):\n 1. smap x \\<noteq> {} \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  glbound_in_of P x y b\n  b \\<in> P .\\<^bold>\\<le> x\n  b \\<in> P .\\<^bold>\\<le> y", "show ?thesis"], ["proof (prove)\nusing this:\n  glbound_in_of P x y b\n  b \\<in> P .\\<^bold>\\<le> x\n  b \\<in> P .\\<^bold>\\<le> y\n\ngoal (1 subgoal):\n 1. x = y", "using     xy below_in_P_simplex_like \n                pseudominimal_in_below_in_less_eq_glbound[of P x _ y b]\n                simplex_like_below_in_above_pseudominimal_is_top[of x P]\n                simplex_like_below_in_above_pseudominimal_is_top[of y P]"], ["proof (prove)\nusing this:\n  glbound_in_of P x y b\n  b \\<in> P .\\<^bold>\\<le> x\n  b \\<in> P .\\<^bold>\\<le> y\n  x \\<in> P\n  y \\<in> P\n  smap x = smap y\n  ?x \\<in> P \\<Longrightarrow> simplex_like (P .\\<^bold>\\<le> ?x)\n  \\<lbrakk>pseudominimal_in (P .\\<^bold>\\<le> x) ?w;\n   pseudominimal_in (P .\\<^bold>\\<le> y) ?w; glbound_in_of P x y b\\<rbrakk>\n  \\<Longrightarrow> b \\<succeq> ?w\n  \\<lbrakk>x \\<in> P; simplex_like (P .\\<^bold>\\<le> x);\n   ?t \\<in> P .\\<^bold>\\<le> x;\n   \\<And>y.\n      pseudominimal_in (P .\\<^bold>\\<le> x) y \\<Longrightarrow>\n      ?t \\<succeq> y\\<rbrakk>\n  \\<Longrightarrow> ?t = x\n  \\<lbrakk>y \\<in> P; simplex_like (P .\\<^bold>\\<le> y);\n   ?t \\<in> P .\\<^bold>\\<le> y;\n   \\<And>ya.\n      pseudominimal_in (P .\\<^bold>\\<le> y) ya \\<Longrightarrow>\n      ?t \\<succeq> ya\\<rbrakk>\n  \\<Longrightarrow> ?t = y\n\ngoal (1 subgoal):\n 1. x = y", "unfolding poset_simplex_map_def"], ["proof (prove)\nusing this:\n  glbound_in_of P x y b\n  b \\<in> P .\\<^bold>\\<le> x\n  b \\<in> P .\\<^bold>\\<le> y\n  x \\<in> P\n  y \\<in> P\n  Collect (pseudominimal_in (P .\\<^bold>\\<le> x)) =\n  Collect (pseudominimal_in (P .\\<^bold>\\<le> y))\n  ?x \\<in> P \\<Longrightarrow> simplex_like (P .\\<^bold>\\<le> ?x)\n  \\<lbrakk>pseudominimal_in (P .\\<^bold>\\<le> x) ?w;\n   pseudominimal_in (P .\\<^bold>\\<le> y) ?w; glbound_in_of P x y b\\<rbrakk>\n  \\<Longrightarrow> b \\<succeq> ?w\n  \\<lbrakk>x \\<in> P; simplex_like (P .\\<^bold>\\<le> x);\n   ?t \\<in> P .\\<^bold>\\<le> x;\n   \\<And>y.\n      pseudominimal_in (P .\\<^bold>\\<le> x) y \\<Longrightarrow>\n      ?t \\<succeq> y\\<rbrakk>\n  \\<Longrightarrow> ?t = x\n  \\<lbrakk>y \\<in> P; simplex_like (P .\\<^bold>\\<le> y);\n   ?t \\<in> P .\\<^bold>\\<le> y;\n   \\<And>ya.\n      pseudominimal_in (P .\\<^bold>\\<le> y) ya \\<Longrightarrow>\n      ?t \\<succeq> ya\\<rbrakk>\n  \\<Longrightarrow> ?t = y\n\ngoal (1 subgoal):\n 1. x = y", "by        force"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OrderingSetIso_smap:\n  \"OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) (\\<subseteq>) (\\<subset>) P smap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n     dual_order.greater P smap", "proof (rule OrderingSetMap.isoI)"], ["proof (state)\ngoal (3 subgoals):\n 1. OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n     dual_order.greater P smap\n 2. inj_on smap P\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P;\n        order.greater_eq (smap b) (smap a)\\<rbrakk>\n       \\<Longrightarrow> b \\<succeq> a", "show \"OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) (\\<subseteq>) (\\<subset>) P smap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n     dual_order.greater P smap", "using poset_simplex_map_def below_in_P_simplex_like\n          poset_to_PosetComplex_OrderingSetMap"], ["proof (prove)\nusing this:\n  poset_simplex_map ?P ?x = {y. pseudominimal_in (?P .\\<^bold>\\<le> ?x) y}\n  ?x \\<in> P \\<Longrightarrow> simplex_like (P .\\<^bold>\\<le> ?x)\n  (\\<And>x.\n      x \\<in> ?P \\<Longrightarrow>\n      simplex_like (?P .\\<^bold>\\<le> x)) \\<Longrightarrow>\n  OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater ?P (poset_simplex_map ?P)\n\ngoal (1 subgoal):\n 1. OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n     dual_order.greater P smap", "by    simp"], ["proof (state)\nthis:\n  OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater P smap\n\ngoal (2 subgoals):\n 1. inj_on smap P\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P;\n        order.greater_eq (smap b) (smap a)\\<rbrakk>\n       \\<Longrightarrow> b \\<succeq> a", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on smap P\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P;\n        order.greater_eq (smap b) (smap a)\\<rbrakk>\n       \\<Longrightarrow> b \\<succeq> a", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on smap P\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P;\n        order.greater_eq (smap b) (smap a)\\<rbrakk>\n       \\<Longrightarrow> b \\<succeq> a", "assume xy: \"x\\<in>P\" \"y\\<in>P\" \"smap x \\<subseteq> smap y\""], ["proof (state)\nthis:\n  x \\<in> P\n  y \\<in> P\n  order.greater_eq (smap y) (smap x)\n\ngoal (2 subgoals):\n 1. inj_on smap P\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P;\n        order.greater_eq (smap b) (smap a)\\<rbrakk>\n       \\<Longrightarrow> b \\<succeq> a", "from xy(2)"], ["proof (chain)\npicking this:\n  y \\<in> P", "have \"simplex_like (P.\\<^bold>\\<le>y)\""], ["proof (prove)\nusing this:\n  y \\<in> P\n\ngoal (1 subgoal):\n 1. simplex_like (P .\\<^bold>\\<le> y)", "using below_in_P_simplex_like"], ["proof (prove)\nusing this:\n  y \\<in> P\n  ?x \\<in> P \\<Longrightarrow> simplex_like (P .\\<^bold>\\<le> ?x)\n\ngoal (1 subgoal):\n 1. simplex_like (P .\\<^bold>\\<le> y)", "by fast"], ["proof (state)\nthis:\n  simplex_like (P .\\<^bold>\\<le> y)\n\ngoal (2 subgoals):\n 1. inj_on smap P\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P;\n        order.greater_eq (smap b) (smap a)\\<rbrakk>\n       \\<Longrightarrow> b \\<succeq> a", "from this"], ["proof (chain)\npicking this:\n  simplex_like (P .\\<^bold>\\<le> y)", "obtain g and A::\"nat set\"\n    where \"OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) (\\<subseteq>) (\\<subset>) (P.\\<^bold>\\<le>y) g\"\n          \"g`(P.\\<^bold>\\<le>y) = Pow A\""], ["proof (prove)\nusing this:\n  simplex_like (P .\\<^bold>\\<le> y)\n\ngoal (1 subgoal):\n 1. (\\<And>g A.\n        \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><)\n                  dual_order.greater_eq dual_order.greater\n                  (P .\\<^bold>\\<le> y) g;\n         g ` (P .\\<^bold>\\<le> y) = Pow A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using simplex_likeD_iso[of \"P.\\<^bold>\\<le>y\"]"], ["proof (prove)\nusing this:\n  simplex_like (P .\\<^bold>\\<le> y)\n  simplex_like (P .\\<^bold>\\<le> y) \\<Longrightarrow>\n  \\<exists>f A.\n     OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n      dual_order.greater (P .\\<^bold>\\<le> y) f \\<and>\n     f ` (P .\\<^bold>\\<le> y) = Pow A\n\ngoal (1 subgoal):\n 1. (\\<And>g A.\n        \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><)\n                  dual_order.greater_eq dual_order.greater\n                  (P .\\<^bold>\\<le> y) g;\n         g ` (P .\\<^bold>\\<le> y) = Pow A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> y) g\n  g ` (P .\\<^bold>\\<le> y) = Pow A\n\ngoal (2 subgoals):\n 1. inj_on smap P\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P;\n        order.greater_eq (smap b) (smap a)\\<rbrakk>\n       \\<Longrightarrow> b \\<succeq> a", "with xy"], ["proof (chain)\npicking this:\n  x \\<in> P\n  y \\<in> P\n  order.greater_eq (smap y) (smap x)\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> y) g\n  g ` (P .\\<^bold>\\<le> y) = Pow A", "show \"x\\<^bold>\\<le>y\""], ["proof (prove)\nusing this:\n  x \\<in> P\n  y \\<in> P\n  order.greater_eq (smap y) (smap x)\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> y) g\n  g ` (P .\\<^bold>\\<le> y) = Pow A\n\ngoal (1 subgoal):\n 1. y \\<succeq> x", "using poset_simplex_map_def collect_pseudominimals_below_in_eq[of y P g]\n          collect_pseudominimals_below_in_poset[of P y g]\n          inj_onD[OF inj_on_smap, of \"the_inv_into (P.\\<^bold>\\<le>y) g (\\<Union>(g ` smap x))\" x]\n          collect_pseudominimals_below_in_less_eq_top[of P y g A \"smap x\"]"], ["proof (prove)\nusing this:\n  x \\<in> P\n  y \\<in> P\n  order.greater_eq (smap y) (smap x)\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> y) g\n  g ` (P .\\<^bold>\\<le> y) = Pow A\n  poset_simplex_map ?P ?x = {y. pseudominimal_in (?P .\\<^bold>\\<le> ?x) y}\n  \\<lbrakk>y \\<in> P;\n   OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n    dual_order.greater (P .\\<^bold>\\<le> y) g;\n   g ` (P .\\<^bold>\\<le> y) = Pow ?A;\n   order.greater_eq {ya. pseudominimal_in (P .\\<^bold>\\<le> y) ya}\n    ?a\\<rbrakk>\n  \\<Longrightarrow> ?a =\n                    {ya.\n                     pseudominimal_in\n                      (P .\\<^bold>\\<le>\n                       the_inv_into (P .\\<^bold>\\<le> y) g\n                        (\\<Union> (g ` ?a)))\n                      ya}\n  \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n            dual_order.greater (P .\\<^bold>\\<le> y) g;\n   g ` (P .\\<^bold>\\<le> y) = Pow ?A;\n   order.greater_eq {ya. pseudominimal_in (P .\\<^bold>\\<le> y) ya}\n    ?a\\<rbrakk>\n  \\<Longrightarrow> the_inv_into (P .\\<^bold>\\<le> y) g (\\<Union> (g ` ?a))\n                    \\<in> P\n  \\<lbrakk>smap\n            (the_inv_into (P .\\<^bold>\\<le> y) g (\\<Union> (g ` smap x))) =\n           smap x;\n   the_inv_into (P .\\<^bold>\\<le> y) g (\\<Union> (g ` smap x)) \\<in> P;\n   x \\<in> P\\<rbrakk>\n  \\<Longrightarrow> the_inv_into (P .\\<^bold>\\<le> y) g\n                     (\\<Union> (g ` smap x)) =\n                    x\n  \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n            dual_order.greater (P .\\<^bold>\\<le> y) g;\n   g ` (P .\\<^bold>\\<le> y) = Pow A;\n   order.greater_eq {ya. pseudominimal_in (P .\\<^bold>\\<le> y) ya}\n    (smap x)\\<rbrakk>\n  \\<Longrightarrow> y \\<succeq>\n                    the_inv_into (P .\\<^bold>\\<le> y) g\n                     (\\<Union> (g ` smap x))\n\ngoal (1 subgoal):\n 1. y \\<succeq> x", "by    simp"], ["proof (state)\nthis:\n  y \\<succeq> x\n\ngoal (1 subgoal):\n 1. inj_on smap P", "qed (rule inj_on_smap)"], ["", "lemmas rev_ordsetmap_smap =\n  OrderingSetIso.rev_ordsetmap[OF OrderingSetIso_smap]"], ["", "end"], ["", "(* context ComplexLikePoset *)"], ["", "end"], ["", "(* theory *)"]]}