{"file_name": "/home/qj213/afp-2021-10-22/thys/Buildings/Prelim.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Buildings", "problem_names": ["lemma nat_cases_2Suc [case_names 0 1 SucSuc]:\n  assumes      0: \"n = 0 \\<Longrightarrow> P\"\n  and          1: \"n = 1 \\<Longrightarrow> P\"\n  and     SucSuc: \"\\<And>m. n = Suc (Suc m) \\<Longrightarrow> P\"\n  shows \"P\"", "lemma nat_even_induct [case_names _ 0 SucSuc]:\n  assumes   even: \"even n\"\n  and          0: \"P 0\"\n  and     SucSuc: \"\\<And>m. even m \\<Longrightarrow> P m \\<Longrightarrow> P (Suc (Suc m))\"\n  shows   \"P n\"", "lemma nat_induct_step2 [case_names 0 1 SucSuc]:\n  assumes      0: \"P 0\"\n  and          1: \"P 1\"\n  and     SucSuc: \"\\<And>m. P m \\<Longrightarrow> P (Suc (Suc m))\"\n  shows   \"P n\"", "lemma ex1_unique: \"\\<exists>!x. P x \\<Longrightarrow> P a \\<Longrightarrow> P b \\<Longrightarrow> a=b\"", "lemma not_the1:\n  assumes \"\\<exists>!x. P x\" \"y \\<noteq> (THE x. P x)\"\n  shows   \"\\<not> P y\"", "lemma two_cases [case_names both one other neither]:\n  assumes both   : \"P \\<Longrightarrow> Q \\<Longrightarrow> R\"\n  and     one    : \"P \\<Longrightarrow> \\<not>Q \\<Longrightarrow> R\"\n  and     other  : \"\\<not>P \\<Longrightarrow> Q \\<Longrightarrow> R\"\n  and     neither: \"\\<not>P \\<Longrightarrow> \\<not>Q \\<Longrightarrow> R\"\n  shows   \"R\"", "lemma bex1_equality: \"\\<lbrakk> \\<exists>!x\\<in>A. P x; x\\<in>A; P x; y\\<in>A; P y \\<rbrakk> \\<Longrightarrow> x=y\"", "lemma prod_ballI: \"(\\<And>a b. (a,b)\\<in>A \\<Longrightarrow> P a b) \\<Longrightarrow> \\<forall>(a,b)\\<in>A. P a b\"", "lemmas seteqI = set_eqI[OF iffI]", "lemma set_decomp_subset:\n  \"\\<lbrakk> U = A\\<union>B; A\\<subseteq>X; B\\<subseteq>Y; X\\<subseteq>U; X\\<inter>Y = {} \\<rbrakk> \\<Longrightarrow> A = X\"", "lemma insert_subset_equality: \"\\<lbrakk> a\\<notin>A; a\\<notin>B; insert a A = insert a B \\<rbrakk> \\<Longrightarrow> A=B\"", "lemma insert_compare_element: \"a\\<notin>A \\<Longrightarrow> insert b A = insert a A \\<Longrightarrow> b=a\"", "lemma card1:\n  assumes \"card A = 1\"\n  shows \"\\<exists>a. A = {a}\"", "lemma singleton_pow: \"a\\<in>A \\<Longrightarrow> {a}\\<in>Pow A\"", "lemma separated_byI: \"x\\<in>A \\<Longrightarrow> y\\<in>B \\<Longrightarrow> separated_by {A,B} x y\"", "lemma separated_by_disjoint: \"\\<lbrakk> separated_by {A,B} x y; A\\<inter>B={}; x\\<in>A \\<rbrakk> \\<Longrightarrow> y\\<in>B\"", "lemma separated_by_in_other: \"separated_by {A,B} x y \\<Longrightarrow> x\\<notin>A \\<Longrightarrow> x\\<in>B \\<and> y\\<in>A\"", "lemma separated_by_not_empty: \"separated_by w x y \\<Longrightarrow> w\\<noteq>{}\"", "lemma not_self_separated_by_disjoint: \"A\\<inter>B={} \\<Longrightarrow> \\<not> separated_by {A,B} x x\"", "lemma cong_let: \"(let x = y in f x) = f y\"", "lemma sym_sym: \"sym (A\\<times>A)\"", "lemma trans_sym: \"trans (A\\<times>A)\"", "lemma map_prod_sym: \"sym A \\<Longrightarrow> sym (map_prod f f ` A)\"", "lemma restrict1_image: \"B\\<subseteq>A \\<Longrightarrow> restrict1 f A ` B = f`B\"", "lemma fun_eq_onI: \"(\\<And>a. a\\<in>A \\<Longrightarrow> f a = g a) \\<Longrightarrow> fun_eq_on f g A\"", "lemma fun_eq_onD: \"fun_eq_on f g A \\<Longrightarrow> a \\<in> A \\<Longrightarrow> f a = g a\"", "lemma fun_eq_on_UNIV: \"(fun_eq_on f g UNIV) = (f=g)\"", "lemma fun_eq_on_subset: \"fun_eq_on f g A \\<Longrightarrow> B\\<subseteq>A \\<Longrightarrow> fun_eq_on f g B\"", "lemma fun_eq_on_sym: \"fun_eq_on f g A \\<Longrightarrow> fun_eq_on g f A\"", "lemma fun_eq_on_trans: \"fun_eq_on f g A \\<Longrightarrow> fun_eq_on g h A \\<Longrightarrow> fun_eq_on f h A\"", "lemma fun_eq_on_cong: \"fun_eq_on f h A \\<Longrightarrow> fun_eq_on g h A \\<Longrightarrow> fun_eq_on f g A\"", "lemma fun_eq_on_im : \"fun_eq_on f g A \\<Longrightarrow> B\\<subseteq>A \\<Longrightarrow> f`B = g`B\"", "lemma fun_eq_on_subset_and_diff_imp_eq_on:\n  assumes \"A\\<subseteq>B\" \"fun_eq_on f g A\" \"fun_eq_on f g (B-A)\"\n  shows   \"fun_eq_on f g B\"", "lemma fun_eq_on_set_and_comp_imp_eq:\n  \"fun_eq_on f g A \\<Longrightarrow> fun_eq_on f g (-A) \\<Longrightarrow> f = g\"", "lemma fun_eq_on_bij_betw: \"fun_eq_on f g A \\<Longrightarrow> bij_betw f A B = bij_betw g A B\"", "lemma fun_eq_on_restrict1: \"fun_eq_on (restrict1 f A) f A\"", "lemmas fixespointwiseI           = fun_eq_onI       [of   _ _ id]", "lemmas fixespointwiseD           = fun_eq_onD       [of     _ id]", "lemmas fixespointwise_cong       = fun_eq_on_trans  [of _ _ _ id]", "lemmas fixespointwise_subset     = fun_eq_on_subset [of     _ id]", "lemmas fixespointwise2_imp_eq_on = fun_eq_on_cong   [of     _ id]", "lemmas fixespointwise_subset_and_diff_imp_eq_on =\n  fun_eq_on_subset_and_diff_imp_eq_on[of _ _ _ id]", "lemma id_fixespointwise: \"fixespointwise id A\"", "lemma fixespointwise_im: \"fixespointwise f A \\<Longrightarrow> B\\<subseteq>A \\<Longrightarrow> f`B = B\"", "lemma fixespointwise_comp:\n  \"fixespointwise f A \\<Longrightarrow> fixespointwise g A \\<Longrightarrow> fixespointwise (g\\<circ>f) A\"", "lemma fixespointwise_insert:\n  assumes \"fixespointwise f A\" \"f ` (insert a A) = insert a A\"\n  shows   \"fixespointwise f (insert a A)\"", "lemma fixespointwise_restrict1:\n  \"fixespointwise f A \\<Longrightarrow> fixespointwise (restrict1 f B) A\"", "lemma fold_fixespointwise:\n  \"\\<forall>x\\<in>set xs. fixespointwise (f x) A \\<Longrightarrow> fixespointwise (fold f xs) A\"", "lemma funpower_fixespointwise:\n  assumes \"fixespointwise f A\"\n  shows   \"fixespointwise (f^^n) A\"", "lemma inj_on_to_singleton:\n  assumes \"inj_on f A\" \"f`A = {b}\"\n  shows \"\\<exists>a. A = {a}\"", "lemmas inj_inj_on = subset_inj_on[of _ UNIV, OF _ subset_UNIV]", "lemma inj_on_eq_image': \"\\<lbrakk> inj_on f A; X\\<subseteq>A; Y\\<subseteq>A; f`X\\<subseteq>f`Y \\<rbrakk> \\<Longrightarrow> X\\<subseteq>Y\"", "lemma inj_on_eq_image: \"\\<lbrakk> inj_on f A; X\\<subseteq>A; Y\\<subseteq>A; f`X=f`Y \\<rbrakk> \\<Longrightarrow> X=Y\"", "lemmas inj_eq_image = inj_on_eq_image[OF _ subset_UNIV subset_UNIV]", "lemma induced_pow_fun_inj_on:\n  assumes \"inj_on f A\"\n  shows   \"inj_on ((`) f) (Pow A)\"", "lemma inj_on_minus_set: \"inj_on ((-) A) (Pow A)\"", "lemma induced_pow_fun_surj:\n  \"((`) f) ` (Pow A) = Pow (f`A)\"", "lemma bij_betw_f_the_inv_into_f:\n  \"bij_betw f A B \\<Longrightarrow> y\\<in>B \\<Longrightarrow> f (the_inv_into A f y) = y\"\n\\<comment> \\<open>an equivalent lemma appears in the HOL library, but this version avoids the double\n  @{const bij_betw} premises\\<close>", "lemma bij_betw_the_inv_into_onto: \"bij_betw f A B \\<Longrightarrow> the_inv_into A f ` B = A\"", "lemma bij_betw_imp_bij_betw_Pow:\n  assumes \"bij_betw f A B\"\n  shows   \"bij_betw ((`) f) (Pow A) (Pow B)\"", "lemma comps_fixpointwise_imp_bij_betw:\n  assumes \"f`X\\<subseteq>Y\" \"g`Y\\<subseteq>X\" \"fixespointwise (g\\<circ>f) X\" \"fixespointwise (f\\<circ>g) Y\"\n  shows   \"bij_betw f X Y\"", "lemma set_permutation_bij_restrict1:\n  assumes \"bij_betw f A A\"\n  shows   \"bij (restrict1 f A)\"", "lemma set_permutation_the_inv_restrict1:\n  assumes \"bij_betw f A A\"\n  shows   \"the_inv (restrict1 f A) = restrict1 (the_inv_into A f) A\"", "lemma the_inv_into_the_inv_into:\n  \"inj_on f A \\<Longrightarrow> a\\<in>A \\<Longrightarrow> the_inv_into (f`A) (the_inv_into A f) a = f a\"", "lemma the_inv_into_f_im_f_im:\n  assumes \"inj_on f A\" \"x\\<subseteq>A\"\n  shows   \"the_inv_into A f ` f ` x = x\"", "lemma f_im_the_inv_into_f_im:\n  assumes \"inj_on f A\" \"x\\<subseteq>f`A\"\n  shows   \"f ` the_inv_into A f ` x = x\"", "lemma the_inv_leftinv: \"bij f \\<Longrightarrow> the_inv f \\<circ> f = id\"", "lemma setsetmapim_comp: \"(f\\<circ>g)\\<turnstile>A = f\\<turnstile>(g\\<turnstile>A)\"", "lemma setlistmapim_comp: \"(f\\<circ>g)\\<Turnstile>xs = f\\<Turnstile>(g\\<Turnstile>xs)\"", "lemma setsetmapim_cong_subset:\n  assumes \"fun_eq_on g f (\\<Union>A)\" \"B\\<subseteq>A\"\n  shows   \"g\\<turnstile>B \\<subseteq> f\\<turnstile>B\"", "lemma setsetmapim_cong: \n  assumes \"fun_eq_on g f (\\<Union>A)\" \"B\\<subseteq>A\"\n  shows   \"g\\<turnstile>B = f\\<turnstile>B\"", "lemma setsetmapim_restrict1: \"B\\<subseteq>A \\<Longrightarrow> restrict1 f (\\<Union>A) \\<turnstile> B = f\\<turnstile>B\"", "lemma setsetmapim_the_inv_into:\n  assumes \"inj_on f (\\<Union>A)\"\n  shows   \"(the_inv_into (\\<Union>A) f) \\<turnstile> (f\\<turnstile>A) = A\"", "lemma respects_imp_unique_image_rel: \"f respects r \\<Longrightarrow> y\\<in>f`r``{a} \\<Longrightarrow> y = f a\"", "lemma ex1_class_image:\n  assumes \"refl_on A r\" \"f respects r\" \"X\\<in>A//r\"\n  shows   \"\\<exists>!b. b\\<in>f`X\"", "lemma quotientfun_equality:\n  assumes   \"refl_on A r\" \"f respects r\" \"X\\<in>A//r\" \"b\\<in>f`X\"\n  shows     \"quotientfun f X = b\"", "lemma quotientfun_classrep_equality:\n  \"\\<lbrakk> refl_on A r; f respects r; a\\<in>A \\<rbrakk> \\<Longrightarrow> quotientfun f (r``{a}) = f a\"", "lemma suppI_contra: \"x \\<notin> supp f \\<Longrightarrow> f x = 0\"", "lemma suppD_contra: \"f x = 0 \\<Longrightarrow> x \\<notin> supp f\"", "lemma supp_restrict0 : \"supp (restrict0 f A) \\<subseteq> A\"", "lemma snoc_conv_cons: \"\\<exists>x xs. ys@[y] = x#xs\"", "lemma cons_conv_snoc: \"\\<exists>ys y. x#xs = ys@[y]\"", "lemma same_length_eq_append:\n  \"length as = length bs \\<Longrightarrow> as@cs = bs@ds \\<Longrightarrow> as = bs\"", "lemma count_list_append:\n  \"count_list (xs@ys) a = count_list xs a + count_list ys a\"", "lemma count_list_snoc:\n  \"count_list (xs@[x]) y = (if y=x then Suc (count_list xs y) else count_list xs y)\"", "lemma distinct_count_list:\n  \"distinct xs \\<Longrightarrow> count_list xs a = (if a \\<in> set xs then 1 else 0)\"", "lemma map_fst_map_const_snd: \"map fst (map (\\<lambda>s. (s,b)) xs) = xs\"", "lemma inj_on_distinct_setlistmapim:\n  assumes \"inj_on f A\"\n  shows \"\\<forall>X\\<in>set Xs. X \\<subseteq> A \\<Longrightarrow> distinct Xs \\<Longrightarrow> distinct (f\\<Turnstile>Xs)\"", "lemma list_cases_Cons_snoc [case_names Nil Single Cons_snoc]:\n  assumes       Nil: \"xs = [] \\<Longrightarrow> P\"\n  and        Single: \"\\<And>x. xs = [x] \\<Longrightarrow> P\"\n  and     Cons_snoc: \"\\<And>x ys y. xs = x # ys @ [y] \\<Longrightarrow> P\"\n  shows \"P\"", "lemma two_lists_cases_Cons_Cons [case_names Nil1 Nil2 ConsCons]:\n  assumes     Nil1: \"\\<And>ys. as = [] \\<Longrightarrow> bs = ys \\<Longrightarrow> P\"\n  and         Nil2: \"\\<And>xs. as = xs \\<Longrightarrow> bs = [] \\<Longrightarrow> P\"\n  and     ConsCons: \"\\<And>x xs y ys. as = x # xs \\<Longrightarrow> bs = y # ys \\<Longrightarrow> P\"\n  shows \"P\"", "lemma two_lists_cases_snoc_Cons [case_names Nil1 Nil2 snoc_Cons]:\n  assumes      Nil1: \"\\<And>ys. as = [] \\<Longrightarrow> bs = ys \\<Longrightarrow> P\"\n  and          Nil2: \"\\<And>xs. as = xs \\<Longrightarrow> bs = [] \\<Longrightarrow> P\"\n  and     snoc_Cons: \"\\<And>xs x y ys. as = xs @ [x] \\<Longrightarrow> bs = y # ys \\<Longrightarrow> P\"\n  shows \"P\"", "lemma two_lists_cases_snoc_Cons' [case_names both_Nil Nil1 Nil2 snoc_Cons]:\n  assumes  both_Nil: \"as = [] \\<Longrightarrow> bs = [] \\<Longrightarrow> P\"\n  and          Nil1: \"\\<And>y ys. as = [] \\<Longrightarrow> bs = y#ys \\<Longrightarrow> P\"\n  and          Nil2: \"\\<And>xs x. as = xs@[x] \\<Longrightarrow> bs = [] \\<Longrightarrow> P\"\n  and     snoc_Cons: \"\\<And>xs x y ys. as = xs @ [x] \\<Longrightarrow> bs = y # ys \\<Longrightarrow> P\"\n  shows \"P\"", "lemma two_prod_lists_cases_snoc_Cons:\n  assumes \"\\<And>xs. as = xs \\<Longrightarrow> bs = [] \\<Longrightarrow> P\" \"\\<And>ys. as = [] \\<Longrightarrow> bs = ys \\<Longrightarrow> P\"\n          \"\\<And>xs aa ba ab bb ys. as = xs @ [(aa, ba)] \\<and> bs = (ab, bb) # ys \\<Longrightarrow> P\"\n  shows \"P\"", "lemma three_lists_cases_snoc_mid_Cons\n      [case_names Nil1 Nil2 Nil3 snoc_single_Cons snoc_mid_Cons]:\n  assumes             Nil1: \"\\<And>ys zs. as = [] \\<Longrightarrow> bs = ys \\<Longrightarrow> cs = zs \\<Longrightarrow> P\"\n  and                 Nil2: \"\\<And>xs zs. as = xs \\<Longrightarrow> bs = [] \\<Longrightarrow> cs = zs \\<Longrightarrow> P\"\n  and                 Nil3: \"\\<And>xs ys. as = xs \\<Longrightarrow> bs = ys \\<Longrightarrow> cs = [] \\<Longrightarrow> P\"\n  and     snoc_single_Cons:\n    \"\\<And>xs x y z zs. as = xs @ [x] \\<Longrightarrow> bs = [y] \\<Longrightarrow> cs = z # zs \\<Longrightarrow> P\"\n  and        snoc_mid_Cons:\n    \"\\<And>xs x w ys y z zs. as = xs @ [x] \\<Longrightarrow> bs = w # ys @ [y] \\<Longrightarrow>\n      cs = z # zs \\<Longrightarrow> P\"\n  shows \"P\"", "lemma list_induct_CCons [case_names Nil Single CCons]:\n  assumes Nil   : \"P []\"\n  and     Single: \"\\<And>x. P [x]\"\n  and     CCons : \"\\<And>x y xs. P (y#xs) \\<Longrightarrow> P (x # y # xs)\"\n  shows   \"P xs\"", "lemma list_induct_ssnoc [case_names Nil Single ssnoc]:\n  assumes Nil   : \"P []\"\n  and     Single: \"\\<And>x. P [x]\"\n  and     ssnoc : \"\\<And>xs x y. P (xs@[x]) \\<Longrightarrow> P (xs@[x,y])\"\n  shows   \"P xs\"", "lemma list_induct2_snoc [case_names Nil1 Nil2 snoc]:\n  assumes Nil1: \"\\<And>ys. P [] ys\"\n  and     Nil2: \"\\<And>xs. P xs []\"\n  and     snoc: \"\\<And>xs x ys y. P xs ys \\<Longrightarrow> P (xs@[x]) (ys@[y])\"\n  shows   \"P xs ys\"", "lemma list_induct2_snoc_Cons [case_names Nil1 Nil2 snoc_Cons]:\n  assumes Nil1     : \"\\<And>ys. P [] ys\"\n  and     Nil2     : \"\\<And>xs. P xs []\"\n  and     snoc_Cons: \"\\<And>xs x y ys. P xs ys \\<Longrightarrow> P (xs@[x]) (y#ys)\"\n  shows   \"P xs ys\"", "lemma prod_list_induct3_snoc_Conssnoc_Cons_pairwise:\n  assumes \"\\<And>ys zs. Q ([],ys,zs)\" \"\\<And>xs zs. Q (xs,[],zs)\" \"\\<And>xs ys. Q (xs,ys,[])\"\n          \"\\<And>xs x y z zs. Q (xs@[x],[y],z#zs)\"\n  and     step:\n    \"\\<And>xs x y ys w z zs. Q (xs,ys,zs) \\<Longrightarrow> Q (xs,ys@[w],z#zs) \\<Longrightarrow>\n      Q (xs@[x],y#ys,zs) \\<Longrightarrow> Q (xs@[x],y#ys@[w],z#zs)\"\n  shows   \"Q t\"", "lemma list_induct3_snoc_Conssnoc_Cons_pairwise\n      [case_names Nil1 Nil2 Nil3 snoc_single_Cons snoc_Conssnoc_Cons]:\n  assumes Nil1              : \"\\<And>ys zs. P [] ys zs\"\n  and     Nil2              : \"\\<And>xs zs. P xs [] zs\"\n  and     Nil3              : \"\\<And>xs ys. P xs ys []\"\n  and     snoc_single_Cons  : \"\\<And>xs x y z zs. P (xs@[x]) [y] (z#zs)\"\n  and     snoc_Conssnoc_Cons:\n    \"\\<And>xs x y ys w z zs. P xs ys zs \\<Longrightarrow> P xs (ys@[w]) (z#zs) \\<Longrightarrow>\n      P (xs@[x]) (y#ys) zs \\<Longrightarrow> P (xs@[x]) (y#ys@[w]) (z#zs)\"\n  shows   \"P xs ys zs\"", "lemma alternating_list2: \"alternating_list 2 s t = [s,t]\"", "lemma length_alternating_list: \"length (alternating_list n s t) = n\"", "lemma alternating_list_Suc_Cons:\n  \"alternating_list (Suc k) s t = s # alternating_list k t s\"", "lemma alternating_list_SucSuc_ConsCons:\n  \"alternating_list (Suc (Suc k)) s t = s # t # alternating_list k s t\"", "lemma alternating_list_alternates:\n  \"alternating_list n s t = as@[a,b,c]@bs \\<Longrightarrow> a=c\"", "lemma alternating_list_split:\n  \"alternating_list (m+n) s t = alternating_list m s t @\n    (if even m then alternating_list n s t else alternating_list n t s)\"", "lemma alternating_list_append:\n  \"even m \\<Longrightarrow>\n    alternating_list m s t @ alternating_list n s t = alternating_list (m+n) s t\"\n  \"odd m \\<Longrightarrow>\n    alternating_list m s t @ alternating_list n t s = alternating_list (m+n) s t\"", "lemma rev_alternating_list:\n  \"rev (alternating_list n s t) =\n    (if even n then alternating_list n t s else alternating_list n s t)\"", "lemma set_alternating_list: \"set (alternating_list n s t) \\<subseteq> {s,t}\"", "lemma set_alternating_list1:\n  assumes \"n \\<ge> 1\"\n  shows \"s \\<in> set (alternating_list n s t)\"", "lemma set_alternating_list2:\n  \"n \\<ge> 2 \\<Longrightarrow> set (alternating_list n s t) = {s,t}\"", "lemma alternating_list_in_lists: \"a\\<in>A \\<Longrightarrow> b\\<in>A \\<Longrightarrow> alternating_list n a b \\<in> lists A\"", "lemma binrelchain_Cons_reduce: \"binrelchain P (x#xs) \\<Longrightarrow> binrelchain P xs\"", "lemma binrelchain_append_reduce1: \"binrelchain P (xs@ys) \\<Longrightarrow> binrelchain P xs\"", "lemma binrelchain_append_reduce2:\n  \"binrelchain P (xs@ys) \\<Longrightarrow> binrelchain P ys\"", "lemma binrelchain_Conssnoc_reduce:\n  \"binrelchain P (x#xs@[y]) \\<Longrightarrow> binrelchain P xs\"", "lemma binrelchain_overlap_join:\n  \"binrelchain P (xs@[x]) \\<Longrightarrow> binrelchain P (x#ys) \\<Longrightarrow> binrelchain P (xs@x#ys)\"", "lemma binrelchain_join:\n  \"\\<lbrakk> binrelchain P (xs@[x]); binrelchain P (y#ys); P x y \\<rbrakk> \\<Longrightarrow>\n    binrelchain P (xs @ x # y # ys)\"", "lemma binrelchain_snoc:\n  \"binrelchain P (xs@[x]) \\<Longrightarrow> P x y \\<Longrightarrow> binrelchain P (xs@[x,y])\"", "lemma binrelchain_sym_rev:\n  assumes \"\\<And>x y. P x y \\<Longrightarrow> P y x\"\n  shows   \"binrelchain P xs \\<Longrightarrow> binrelchain P (rev xs)\"", "lemma binrelchain_remdup_adj:\n  \"binrelchain P (xs@[x,x]@ys) \\<Longrightarrow> binrelchain P (xs@x#ys)\"", "lemma binrelchain_obtain_proper:\n  \"x\\<noteq>y \\<Longrightarrow> binrelchain P (x#xs@[y]) \\<Longrightarrow>\n    \\<exists>zs. set zs \\<subseteq> set xs \\<and> length zs \\<le> length xs \\<and> proper_binrelchain P (x#zs@[y])\"", "lemma binrelchain_trans_Cons_snoc:\n  assumes \"\\<And>x y z. P x y \\<Longrightarrow> P y z \\<Longrightarrow> P x z\"\n  shows   \"binrelchain P (x#xs@[y]) \\<Longrightarrow> P x y\"", "lemma binrelchain_cong:\n  assumes \"\\<And>x y. P x y \\<Longrightarrow> Q x y\"\n  shows   \"binrelchain P xs \\<Longrightarrow> binrelchain Q xs\"", "lemma binrelchain_funcong_Cons_snoc:\n  assumes \"\\<And>x y. P x y \\<Longrightarrow> f y = f x\" \"binrelchain P (x#xs@[y])\"\n  shows   \"f y = f x\"", "lemma binrelchain_funcong_extra_condition_Cons_snoc:\n  assumes \"\\<And>x y. Q x \\<Longrightarrow> P x y \\<Longrightarrow> Q y\" \"\\<And>x y. Q x \\<Longrightarrow> P x y \\<Longrightarrow> f y = f x\"\n  shows   \"Q x \\<Longrightarrow> binrelchain P (x#zs@[y]) \\<Longrightarrow> f y = f x\"", "lemma binrelchain_setfuncong_Cons_snoc:\n  \"\\<lbrakk> \\<forall>x\\<in>A. \\<forall>y. P x y \\<longrightarrow> y\\<in>A; \\<forall>x\\<in>A. \\<forall>y. P x y \\<longrightarrow> f y = f x; x\\<in>A;\n      binrelchain P (x#zs@[y]) \\<rbrakk> \\<Longrightarrow> f y = f x\"", "lemma binrelchain_propcong_Cons_snoc:\n  assumes \"\\<And>x y. Q x \\<Longrightarrow> P x y \\<Longrightarrow> Q y\"\n  shows   \"Q x \\<Longrightarrow> binrelchain P (x#xs@[y]) \\<Longrightarrow> Q y\"", "lemma subseqs_Cons: \"subseqs (x#xs) = map (Cons x) (subseqs xs) @ (subseqs xs)\"", "lemma nil_ssubseqs: \"[] \\<in> ssubseqs xs\"", "lemma ssubseqs_Cons: \"ssubseqs (x#xs) = (Cons x) ` (ssubseqs xs) \\<union> ssubseqs xs\"", "lemma ssubseqs_refl: \"xs \\<in> ssubseqs xs\"", "lemma ssubseqs_subset: \"as \\<in> ssubseqs bs \\<Longrightarrow> ssubseqs as \\<subseteq> ssubseqs bs\"", "lemma ssubseqs_lists:\n  \"as \\<in> lists A \\<Longrightarrow> bs \\<in> ssubseqs as \\<Longrightarrow> bs \\<in> lists A\"", "lemma delete1_ssubseqs:\n  \"as@bs \\<in> ssubseqs (as@[a]@bs)\"", "lemma delete2_ssubseqs:\n  \"as@bs@cs \\<in> ssubseqs (as@[a]@bs@[b]@cs)\"", "lemma dual: \"ordering greater_eq greater\"", "lemma comp:\n  assumes \"OrderingSetMap less_eq' less' less_eq'' less'' Q g\" \"f`P \\<subseteq> Q\"\n  shows   \"OrderingSetMap less_eq less less_eq'' less'' P (g\\<circ>f)\"", "lemma subset: \"Q\\<subseteq>P \\<Longrightarrow> OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) (\\<^bold>\\<le>*) (\\<^bold><*) Q f\"", "lemma dual:\n  \"OrderingSetMap domain.greater_eq domain.greater\n    codomain.greater_eq codomain.greater P f\"", "lemma (in OrderingSetMap) isoI:\n  assumes \"inj_on f P\" \"\\<And>a b. a\\<in>P \\<Longrightarrow> b\\<in>P \\<Longrightarrow> f a \\<^bold>\\<le>* f b \\<Longrightarrow> a \\<^bold>\\<le> b\"\n  shows   \"OrderingSetIso less_eq less less_eq' less' P f\"", "lemma OrderingSetIsoI_orders_greater2less:\n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  assumes \"inj_on f P\" \"\\<And>a b. a \\<in> P \\<Longrightarrow> b \\<in> P \\<Longrightarrow> (b\\<le>a) = (f a \\<le> f b)\"\n  shows   \"OrderingSetIso (greater_eq::'a\\<Rightarrow>'a\\<Rightarrow>bool) (greater::'a\\<Rightarrow>'a\\<Rightarrow>bool)\n            (less_eq::'b\\<Rightarrow>'b\\<Rightarrow>bool) (less::'b\\<Rightarrow>'b\\<Rightarrow>bool) P f\"", "lemmas ordsetmap = ordsetmap", "lemma ordsetmap_strict: \"\\<lbrakk> a\\<in>P; b\\<in>P; a\\<^bold><b \\<rbrakk> \\<Longrightarrow> f a \\<^bold><* f b\"", "lemmas inv_ordsetmap = OrderingSetMap.ordsetmap[OF rev_OrderingSetMap]", "lemma rev_ordsetmap: \"\\<lbrakk> a\\<in>P; b\\<in>P; f a \\<^bold>\\<le>* f b \\<rbrakk> \\<Longrightarrow> a \\<^bold>\\<le> b\"", "lemma inv_iso: \"OrderingSetIso less_eq' less' less_eq less (f`P) (the_inv_into P f)\"", "lemmas inv_ordsetmap_strict = OrderingSetIso.ordsetmap_strict[OF inv_iso]", "lemma rev_ordsetmap_strict: \"\\<lbrakk> a\\<in>P; b\\<in>P; f a \\<^bold><* f b \\<rbrakk> \\<Longrightarrow> a \\<^bold>< b\"", "lemma iso_comp:\n  assumes \"OrderingSetIso less_eq' less' less_eq'' less'' Q g\" \"f`P \\<subseteq> Q\"\n  shows   \"OrderingSetIso less_eq less less_eq'' less'' P (g\\<circ>f)\"", "lemma iso_subset:\n  \"Q\\<subseteq>P \\<Longrightarrow> OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) (\\<^bold>\\<le>*) (\\<^bold><*) Q f\"", "lemma iso_dual:\n  \"OrderingSetIso domain.greater_eq domain.greater\n    codomain.greater_eq codomain.greater P f\"", "lemma induced_pow_fun_subset_ordering_iso:\n  assumes \"inj_on f A\"\n  shows   \"subset_ordering_iso (Pow A) ((`) f)\"", "lemma is_arg_minI:\n  \"\\<lbrakk> P x; \\<And>y. P y \\<Longrightarrow> \\<not> m y < m x \\<rbrakk> \\<Longrightarrow> is_arg_min m P x\"", "lemma is_arg_min_linorderI:\n  \"\\<lbrakk> P x; \\<And>y. P y \\<Longrightarrow> m x \\<le> (m y::_::linorder) \\<rbrakk> \\<Longrightarrow> is_arg_min m P x\"", "lemma is_arg_min_eq:\n  \"\\<lbrakk> is_arg_min m P x; P z; m z = m x \\<rbrakk> \\<Longrightarrow> is_arg_min m P z\"", "lemma is_arg_minD1: \"is_arg_min m P x \\<Longrightarrow> P x\"", "lemma is_arg_minD2: \"is_arg_min m P x \\<Longrightarrow> P y \\<Longrightarrow> \\<not> m y < m x\"", "lemma is_arg_min_size: fixes m :: \"'a \\<Rightarrow> 'b::linorder\"\nshows \"is_arg_min m P x \\<Longrightarrow> m x = m (arg_min m P)\"", "lemma is_arg_min_size_subprop:\n  fixes   m :: \"'a\\<Rightarrow>'b::linorder\"\n  assumes \"is_arg_min m P x\" \"Q x\" \"\\<And>y. Q y \\<Longrightarrow> P y\"\n  shows   \"m (arg_min m Q) = m (arg_min m P)\"", "lemma has_bottomI: \"z\\<in>P \\<Longrightarrow> (\\<And>x. x\\<in>P \\<Longrightarrow> z \\<^bold>\\<le> x) \\<Longrightarrow> has_bottom P\"", "lemma has_uniq_bottom: \"has_bottom P \\<Longrightarrow> \\<exists>!z\\<in>P. \\<forall>x\\<in>P. z\\<^bold>\\<le>x\"", "lemma bottomD:\n  assumes   \"has_bottom P\"\n  shows     \"bottom P \\<in> P\" \"x\\<in>P \\<Longrightarrow> bottom P \\<^bold>\\<le> x\"", "lemma bottomI: \"z\\<in>P \\<Longrightarrow> (\\<And>y. y\\<in>P \\<Longrightarrow> z \\<^bold>\\<le> y) \\<Longrightarrow> z = bottom P\"", "lemma has_bottom_pow: \"order.has_bottom (Pow A)\"", "lemma bottom_pow: \"order.bottom (Pow A) = {}\"", "lemma im_has_bottom: \"domain.has_bottom P \\<Longrightarrow> codomain.has_bottom (f`P)\"", "lemma im_bottom: \"domain.has_bottom P \\<Longrightarrow> f dombot = codbot\"", "lemma (in OrderingSetIso) pullback_has_bottom:\n  assumes \"codomain.has_bottom (f`P)\"\n  shows   \"domain.has_bottom P\"", "lemma (in OrderingSetIso) pullback_bottom:\n  \"\\<lbrakk> domain.has_bottom P; x\\<in>P; f x = codomain.bottom (f`P) \\<rbrakk> \\<Longrightarrow>\n    x = domain.bottom P\"", "lemma minimal_inD1: \"minimal_in P x \\<Longrightarrow> x\\<in>P\"", "lemma minimal_inD2: \"minimal_in P x \\<Longrightarrow> z\\<in>P \\<Longrightarrow> \\<not> z \\<^bold>< x\"", "lemma pseudominimal_inD1: \"pseudominimal_in P x \\<Longrightarrow> x\\<in>P\"", "lemma pseudominimal_inD2:\n  \"pseudominimal_in P x \\<Longrightarrow> z\\<in>P \\<Longrightarrow> z\\<^bold><x \\<Longrightarrow> z = bottom P\"", "lemma pseudominimal_inI:\n  assumes   \"x\\<in>P\" \"x \\<noteq> bottom P\" \"\\<And>z. z\\<in>P \\<Longrightarrow> z\\<^bold><x \\<Longrightarrow> z = bottom P\"\n  shows     \"pseudominimal_in P x\"", "lemma pseudominimal_ne_bottom: \"pseudominimal_in P x \\<Longrightarrow> x \\<noteq> bottom P\"", "lemma pseudominimal_comp:\n  \"\\<lbrakk> pseudominimal_in P x; pseudominimal_in P y; x\\<^bold>\\<le>y \\<rbrakk> \\<Longrightarrow> x = y\"", "lemma pseudominimal_in_pow:\n  assumes \"order.pseudominimal_in (Pow A) x\"\n  shows \"\\<exists>a\\<in>A. x = {a}\"", "lemma pseudominimal_in_pow_singleton:\n  \"a\\<in>A \\<Longrightarrow> order.pseudominimal_in (Pow A) {a}\"", "lemma no_pseudominimal_in_pow_is_empty:\n  \"(\\<And>x. \\<not> order.pseudominimal_in (Pow A) {x}) \\<Longrightarrow> A = {}\"", "lemma (in OrderingSetIso) pseudominimal_map:\n  \"domain.has_bottom P \\<Longrightarrow> domain.pseudominimal_in P x \\<Longrightarrow>\n    codomain.pseudominimal_in (f`P) (f x)\"", "lemma (in OrderingSetIso) pullback_pseudominimal_in:\n  \"\\<lbrakk> domain.has_bottom P; x\\<in>P; codomain.pseudominimal_in (f`P) (f x) \\<rbrakk> \\<Longrightarrow>\n      domain.pseudominimal_in P x\"", "lemma below_in_refl: \"x\\<in>P \\<Longrightarrow> x \\<in> P.\\<^bold>\\<le>x\"", "lemma below_in_singleton: \"x\\<in>P \\<Longrightarrow> P.\\<^bold>\\<le>x \\<subseteq> {y} \\<Longrightarrow> y = x\"", "lemma bottom_in_below_in: \"has_bottom P \\<Longrightarrow> x\\<in>P \\<Longrightarrow> bottom P \\<in> P.\\<^bold>\\<le>x\"", "lemma below_in_singleton_is_bottom:\n  \"\\<lbrakk> has_bottom P; x\\<in>P; P.\\<^bold>\\<le>x = {x} \\<rbrakk> \\<Longrightarrow> x = bottom P\"", "lemma bottom_below_in:\n  \"has_bottom P \\<Longrightarrow> x\\<in>P \\<Longrightarrow> bottom (P.\\<^bold>\\<le>x) = bottom P\"", "lemma bottom_below_in_relative:\n  \"\\<lbrakk> has_bottom (P.\\<^bold>\\<le>y); x\\<in>P; x\\<^bold>\\<le>y \\<rbrakk> \\<Longrightarrow> bottom (P.\\<^bold>\\<le>x) = bottom (P.\\<^bold>\\<le>y)\"", "lemma has_bottom_pseudominimal_in_below_inI:\n  assumes \"has_bottom P\" \"x\\<in>P\" \"pseudominimal_in P y\" \"y\\<^bold>\\<le>x\"\n  shows   \"pseudominimal_in (P.\\<^bold>\\<le>x) y\"", "lemma has_bottom_pseudominimal_in_below_in:\n  assumes \"has_bottom P\" \"x\\<in>P\" \"pseudominimal_in (P.\\<^bold>\\<le>x) y\"\n  shows   \"pseudominimal_in P y\"", "lemma pseudominimal_in_below_in:\n  assumes   \"has_bottom (P.\\<^bold>\\<le>y)\" \"x\\<in>P\" \"x\\<^bold>\\<le>y\" \"pseudominimal_in (P.\\<^bold>\\<le>x) w\"\n  shows     \"pseudominimal_in (P.\\<^bold>\\<le>y) w\"", "lemma collect_pseudominimals_below_in_less_eq_top:\n  assumes \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) (P.\\<^bold>\\<le>x) f\"\n          \"f`(P.\\<^bold>\\<le>x) = Pow A\" \"a \\<subseteq> {y. pseudominimal_in (P.\\<^bold>\\<le>x) y}\"\n  defines \"w \\<equiv> the_inv_into (P.\\<^bold>\\<le>x) f (\\<Union>(f`a))\"\n  shows   \"w \\<^bold>\\<le> x\"", "lemma collect_pseudominimals_below_in_poset:\n  assumes   \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) (P.\\<^bold>\\<le>x) f\"\n            \"f`(P.\\<^bold>\\<le>x) = Pow A\"\n            \"a \\<subseteq> {y. pseudominimal_in (P.\\<^bold>\\<le>x) y}\"\n  defines   \"w \\<equiv> the_inv_into (P.\\<^bold>\\<le>x) f (\\<Union>(f`a))\"\n  shows     \"w \\<in> P\"", "lemma collect_pseudominimals_below_in_eq:\n  assumes \"x\\<in>P\" \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) (P.\\<^bold>\\<le>x) f\"\n          \"f`(P.\\<^bold>\\<le>x) = Pow A\" \"a \\<subseteq> {y. pseudominimal_in (P.\\<^bold>\\<le>x) y}\"\n  defines w: \"w \\<equiv> the_inv_into (P.\\<^bold>\\<le>x) f (\\<Union>(f`a))\"\n  shows   \"a = {y. pseudominimal_in (P.\\<^bold>\\<le>w) y}\"", "lemma lbound_ofI: \"b\\<^bold>\\<le>x \\<Longrightarrow> b\\<^bold>\\<le>y \\<Longrightarrow> lbound_of x y b\"", "lemma lbound_ofD1: \"lbound_of x y b \\<Longrightarrow> b\\<^bold>\\<le>x\"", "lemma lbound_ofD2: \"lbound_of x y b \\<Longrightarrow> b\\<^bold>\\<le>y\"", "lemma glbound_in_ofI:\n  \"\\<lbrakk> b\\<in>P; lbound_of x y b; \\<And>a. a\\<in>P \\<Longrightarrow> lbound_of x y a \\<Longrightarrow> a\\<^bold>\\<le>b \\<rbrakk> \\<Longrightarrow>\n    glbound_in_of P x y b\"", "lemma glbound_in_ofD_in: \"glbound_in_of P x y b \\<Longrightarrow> b\\<in>P\"", "lemma glbound_in_ofD_lbound: \"glbound_in_of P x y b \\<Longrightarrow> lbound_of x y b\"", "lemma glbound_in_ofD_glbound:\n  \"glbound_in_of P x y b \\<Longrightarrow> a\\<in>P \\<Longrightarrow> lbound_of x y a \\<Longrightarrow> a\\<^bold>\\<le>b\"", "lemma glbound_in_of_less_eq1: \"glbound_in_of P x y b \\<Longrightarrow> b\\<^bold>\\<le>x\"", "lemma glbound_in_of_less_eq2: \"glbound_in_of P x y b \\<Longrightarrow> b\\<^bold>\\<le>y\"", "lemma pseudominimal_in_below_in_less_eq_glbound:\n  assumes \"pseudominimal_in (P.\\<^bold>\\<le>x) w\" \"pseudominimal_in (P.\\<^bold>\\<le>y) w\"\n          \"glbound_in_of P x y b\"\n  shows   \"w \\<^bold>\\<le> b\"", "lemma simplex_likeI:\n  assumes \"finite P\" \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) P f\"\n          \"f`P = Pow (A::nat set)\"\n  shows   \"simplex_like P\"", "lemma simplex_likeD_finite: \"simplex_like P \\<Longrightarrow> finite P\"", "lemma simplex_likeD_iso:\n  \"simplex_like P \\<Longrightarrow>\n    \\<exists>f A::nat set. OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) P f \\<and> f`P = Pow A\"", "lemma simplex_like_has_bottom: \"simplex_like P \\<Longrightarrow> has_bottom P\"", "lemma simplex_like_no_pseudominimal_imp_singleton:\n  assumes \"simplex_like P\" \"\\<And>x. \\<not> pseudominimal_in P x\"\n  shows \"\\<exists>p. P = {p}\"", "lemma simplex_like_no_pseudominimal_in_below_in_imp_singleton:\n  \"\\<lbrakk> x\\<in>P; simplex_like (P.\\<^bold>\\<le>x); \\<And>z. \\<not> pseudominimal_in (P.\\<^bold>\\<le>x) z \\<rbrakk> \\<Longrightarrow>\n    P.\\<^bold>\\<le>x = {x}\"", "lemma pseudo_simplex_like_has_bottom:\n  \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) P f \\<Longrightarrow> f`P = Pow A \\<Longrightarrow>\n    has_bottom P\"", "lemma pseudo_simplex_like_above_pseudominimal_is_top:\n  assumes \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) P f\" \"f`P = Pow A\" \"t\\<in>P\"\n          \"\\<And>x. pseudominimal_in P x \\<Longrightarrow> x \\<^bold>\\<le> t\"\n  shows   \"f t = A\"", "lemma pseudo_simplex_like_below_in_above_pseudominimal_is_top:\n  assumes \"x\\<in>P\" \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) (P.\\<^bold>\\<le>x) f\"\n          \"f`(P.\\<^bold>\\<le>x) = Pow A\" \"t \\<in> P.\\<^bold>\\<le>x\"\n          \"\\<And>y. pseudominimal_in (P.\\<^bold>\\<le>x) y \\<Longrightarrow> y \\<^bold>\\<le> t\"\n  shows   \"t = x\"", "lemma simplex_like_below_in_above_pseudominimal_is_top:\n  assumes \"x\\<in>P\" \"simplex_like (P.\\<^bold>\\<le>x)\" \"t \\<in> P.\\<^bold>\\<le>x\"\n          \"\\<And>y. pseudominimal_in (P.\\<^bold>\\<le>x) y \\<Longrightarrow> y \\<^bold>\\<le> t\"\n  shows   \"t = x\"", "lemma (in OrderingSetIso) simplex_like_map:\n  assumes \"domain.simplex_like P\"\n  shows   \"codomain.simplex_like (f`P)\"", "lemma (in OrderingSetIso) pullback_simplex_like:\n  assumes \"finite P\" \"codomain.simplex_like (f`P)\"\n  shows   \"domain.simplex_like P\"", "lemma simplex_like_pow:\n  assumes \"finite A\"\n  shows \"order.simplex_like (Pow A)\"", "lemma supset_poset: \"ordering (\\<supseteq>) (\\<supset>)\"", "lemmas supset_bottomI            = ordering.bottomI            [OF supset_poset]", "lemmas supset_pseudominimal_inI  = ordering.pseudominimal_inI  [OF supset_poset]", "lemmas supset_pseudominimal_inD1 = ordering.pseudominimal_inD1 [OF supset_poset]", "lemmas supset_pseudominimal_inD2 = ordering.pseudominimal_inD2 [OF supset_poset]", "lemmas supset_lbound_ofI         = ordering.lbound_ofI         [OF supset_poset]", "lemmas supset_lbound_of_def      = ordering.lbound_of_def      [OF supset_poset]", "lemmas supset_glbound_in_ofI     = ordering.glbound_in_ofI     [OF supset_poset]", "lemmas supset_pseudominimal_ne_bottom =\n  ordering.pseudominimal_ne_bottom[OF supset_poset]", "lemmas supset_has_bottom_pseudominimal_in_below_inI =\n  ordering.has_bottom_pseudominimal_in_below_inI[OF supset_poset]", "lemmas supset_has_bottom_pseudominimal_in_below_in =\n  ordering.has_bottom_pseudominimal_in_below_in[OF supset_poset]", "lemma OrderingSetIso_pow_complement:\n  \"OrderingSetIso (\\<supseteq>) (\\<supset>) (\\<subseteq>) (\\<subset>) (Pow A) ((-) A)\"", "lemma simplex_like_pow_above_in:\n  assumes \"finite A\" \"X\\<subseteq>A\"\n  shows   \"supset_simplex_like ((Pow A).\\<supseteq>X)\""], "translations": [["", "lemma nat_cases_2Suc [case_names 0 1 SucSuc]:\n  assumes      0: \"n = 0 \\<Longrightarrow> P\"\n  and          1: \"n = 1 \\<Longrightarrow> P\"\n  and     SucSuc: \"\\<And>m. n = Suc (Suc m) \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> P\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> P", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> P\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> P", "with 1 SucSuc"], ["proof (chain)\npicking this:\n  n = 1 \\<Longrightarrow> P\n  n = Suc (Suc ?m) \\<Longrightarrow> P\n  n = Suc m", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 1 \\<Longrightarrow> P\n  n = Suc (Suc ?m) \\<Longrightarrow> P\n  n = Suc m\n\ngoal (1 subgoal):\n 1. P", "by (cases m) auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> P", "qed (simp add: 0)"], ["", "lemma nat_even_induct [case_names _ 0 SucSuc]:\n  assumes   even: \"even n\"\n  and          0: \"P 0\"\n  and     SucSuc: \"\\<And>m. even m \\<Longrightarrow> P m \\<Longrightarrow> P (Suc (Suc m))\"\n  shows   \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P n", "from assms"], ["proof (chain)\npicking this:\n  even n\n  P 0\n  \\<lbrakk>even ?m; P ?m\\<rbrakk> \\<Longrightarrow> P (Suc (Suc ?m))", "obtain k where \"n = 2*k\""], ["proof (prove)\nusing this:\n  even n\n  P 0\n  \\<lbrakk>even ?m; P ?m\\<rbrakk> \\<Longrightarrow> P (Suc (Suc ?m))\n\ngoal (1 subgoal):\n 1. (\\<And>k. n = 2 * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using evenE"], ["proof (prove)\nusing this:\n  even n\n  P 0\n  \\<lbrakk>even ?m; P ?m\\<rbrakk> \\<Longrightarrow> P (Suc (Suc ?m))\n  \\<lbrakk>even ?a;\n   \\<And>b. ?a = (2::?'a) * b \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>k. n = 2 * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  n = 2 * k\n\ngoal (1 subgoal):\n 1. P n", "moreover"], ["proof (state)\nthis:\n  n = 2 * k\n\ngoal (1 subgoal):\n 1. P n", "from assms"], ["proof (chain)\npicking this:\n  even n\n  P 0\n  \\<lbrakk>even ?m; P ?m\\<rbrakk> \\<Longrightarrow> P (Suc (Suc ?m))", "have \"P (2*k)\""], ["proof (prove)\nusing this:\n  even n\n  P 0\n  \\<lbrakk>even ?m; P ?m\\<rbrakk> \\<Longrightarrow> P (Suc (Suc ?m))\n\ngoal (1 subgoal):\n 1. P (2 * k)", "by (induct k) auto"], ["proof (state)\nthis:\n  P (2 * k)\n\ngoal (1 subgoal):\n 1. P n", "ultimately"], ["proof (chain)\npicking this:\n  n = 2 * k\n  P (2 * k)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 2 * k\n  P (2 * k)\n\ngoal (1 subgoal):\n 1. P n", "by fast"], ["proof (state)\nthis:\n  P n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_induct_step2 [case_names 0 1 SucSuc]:\n  assumes      0: \"P 0\"\n  and          1: \"P 1\"\n  and     SucSuc: \"\\<And>m. P m \\<Longrightarrow> P (Suc (Suc m))\"\n  shows   \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "proof (cases \"even n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. even n \\<Longrightarrow> P n\n 2. odd n \\<Longrightarrow> P n", "case True"], ["proof (state)\nthis:\n  even n\n\ngoal (2 subgoals):\n 1. even n \\<Longrightarrow> P n\n 2. odd n \\<Longrightarrow> P n", "from this"], ["proof (chain)\npicking this:\n  even n", "obtain k where \"n = 2*k\""], ["proof (prove)\nusing this:\n  even n\n\ngoal (1 subgoal):\n 1. (\\<And>k. n = 2 * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using evenE"], ["proof (prove)\nusing this:\n  even n\n  \\<lbrakk>even ?a;\n   \\<And>b. ?a = (2::?'a) * b \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>k. n = 2 * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  n = 2 * k\n\ngoal (2 subgoals):\n 1. even n \\<Longrightarrow> P n\n 2. odd n \\<Longrightarrow> P n", "moreover"], ["proof (state)\nthis:\n  n = 2 * k\n\ngoal (2 subgoals):\n 1. even n \\<Longrightarrow> P n\n 2. odd n \\<Longrightarrow> P n", "have \"P (2*k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (2 * k)", "using 0 SucSuc"], ["proof (prove)\nusing this:\n  P 0\n  P ?m \\<Longrightarrow> P (Suc (Suc ?m))\n\ngoal (1 subgoal):\n 1. P (2 * k)", "by (induct k) auto"], ["proof (state)\nthis:\n  P (2 * k)\n\ngoal (2 subgoals):\n 1. even n \\<Longrightarrow> P n\n 2. odd n \\<Longrightarrow> P n", "ultimately"], ["proof (chain)\npicking this:\n  n = 2 * k\n  P (2 * k)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 2 * k\n  P (2 * k)\n\ngoal (1 subgoal):\n 1. P n", "by fast"], ["proof (state)\nthis:\n  P n\n\ngoal (1 subgoal):\n 1. odd n \\<Longrightarrow> P n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. odd n \\<Longrightarrow> P n", "case False"], ["proof (state)\nthis:\n  odd n\n\ngoal (1 subgoal):\n 1. odd n \\<Longrightarrow> P n", "from this"], ["proof (chain)\npicking this:\n  odd n", "obtain k where \"n = 2*k+1\""], ["proof (prove)\nusing this:\n  odd n\n\ngoal (1 subgoal):\n 1. (\\<And>k. n = 2 * k + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using oddE"], ["proof (prove)\nusing this:\n  odd n\n  \\<lbrakk>odd ?a;\n   \\<And>b. ?a = (2::?'a) * b + (1::?'a) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>k. n = 2 * k + 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = 2 * k + 1\n\ngoal (1 subgoal):\n 1. odd n \\<Longrightarrow> P n", "moreover"], ["proof (state)\nthis:\n  n = 2 * k + 1\n\ngoal (1 subgoal):\n 1. odd n \\<Longrightarrow> P n", "have \"P (2*k+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (2 * k + 1)", "using 1 SucSuc"], ["proof (prove)\nusing this:\n  P 1\n  P ?m \\<Longrightarrow> P (Suc (Suc ?m))\n\ngoal (1 subgoal):\n 1. P (2 * k + 1)", "by (induct k) auto"], ["proof (state)\nthis:\n  P (2 * k + 1)\n\ngoal (1 subgoal):\n 1. odd n \\<Longrightarrow> P n", "ultimately"], ["proof (chain)\npicking this:\n  n = 2 * k + 1\n  P (2 * k + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 2 * k + 1\n  P (2 * k + 1)\n\ngoal (1 subgoal):\n 1. P n", "by fast"], ["proof (state)\nthis:\n  P n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Logic\\<close>"], ["", "lemma ex1_unique: \"\\<exists>!x. P x \\<Longrightarrow> P a \\<Longrightarrow> P b \\<Longrightarrow> a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>!x. P x; P a; P b\\<rbrakk> \\<Longrightarrow> a = b", "by blast"], ["", "lemma not_the1:\n  assumes \"\\<exists>!x. P x\" \"y \\<noteq> (THE x. P x)\"\n  shows   \"\\<not> P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P y", "using assms(2) the1_equality[OF assms(1)]"], ["proof (prove)\nusing this:\n  y \\<noteq> (THE x. P x)\n  P ?a \\<Longrightarrow> (THE x. P x) = ?a\n\ngoal (1 subgoal):\n 1. \\<not> P y", "by    auto"], ["", "lemma two_cases [case_names both one other neither]:\n  assumes both   : \"P \\<Longrightarrow> Q \\<Longrightarrow> R\"\n  and     one    : \"P \\<Longrightarrow> \\<not>Q \\<Longrightarrow> R\"\n  and     other  : \"\\<not>P \\<Longrightarrow> Q \\<Longrightarrow> R\"\n  and     neither: \"\\<not>P \\<Longrightarrow> \\<not>Q \\<Longrightarrow> R\"\n  shows   \"R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R", "using   assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>P; Q\\<rbrakk> \\<Longrightarrow> R\n  \\<lbrakk>P; \\<not> Q\\<rbrakk> \\<Longrightarrow> R\n  \\<lbrakk>\\<not> P; Q\\<rbrakk> \\<Longrightarrow> R\n  \\<lbrakk>\\<not> P; \\<not> Q\\<rbrakk> \\<Longrightarrow> R\n\ngoal (1 subgoal):\n 1. R", "by      fast"], ["", "subsection \\<open>Sets\\<close>"], ["", "lemma bex1_equality: \"\\<lbrakk> \\<exists>!x\\<in>A. P x; x\\<in>A; P x; y\\<in>A; P y \\<rbrakk> \\<Longrightarrow> x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>!x. x \\<in> A \\<and> P x; x \\<in> A; P x; y \\<in> A;\n     P y\\<rbrakk>\n    \\<Longrightarrow> x = y", "by blast"], ["", "lemma prod_ballI: \"(\\<And>a b. (a,b)\\<in>A \\<Longrightarrow> P a b) \\<Longrightarrow> \\<forall>(a,b)\\<in>A. P a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. (a, b) \\<in> A \\<Longrightarrow> P a b) \\<Longrightarrow>\n    \\<forall>(a, b)\\<in>A. P a b", "by fast"], ["", "lemmas seteqI = set_eqI[OF iffI]"], ["", "lemma set_decomp_subset:\n  \"\\<lbrakk> U = A\\<union>B; A\\<subseteq>X; B\\<subseteq>Y; X\\<subseteq>U; X\\<inter>Y = {} \\<rbrakk> \\<Longrightarrow> A = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>U = A \\<union> B; A \\<subseteq> X; B \\<subseteq> Y;\n     X \\<subseteq> U; X \\<inter> Y = {}\\<rbrakk>\n    \\<Longrightarrow> A = X", "by auto"], ["", "lemma insert_subset_equality: \"\\<lbrakk> a\\<notin>A; a\\<notin>B; insert a A = insert a B \\<rbrakk> \\<Longrightarrow> A=B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<notin> A; a \\<notin> B; insert a A = insert a B\\<rbrakk>\n    \\<Longrightarrow> A = B", "by auto"], ["", "lemma insert_compare_element: \"a\\<notin>A \\<Longrightarrow> insert b A = insert a A \\<Longrightarrow> b=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<notin> A; insert b A = insert a A\\<rbrakk>\n    \\<Longrightarrow> b = a", "by auto"], ["", "lemma card1:\n  assumes \"card A = 1\"\n  shows \"\\<exists>a. A = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. A = {a}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. A = {a}", "from assms"], ["proof (chain)\npicking this:\n  card A = 1", "obtain a where a: \"a \\<in> A\""], ["proof (prove)\nusing this:\n  card A = 1\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>a. A = {a}", "with assms"], ["proof (chain)\npicking this:\n  card A = 1\n  a \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  card A = 1\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>a. A = {a}", "using card_ge_0_finite[of A] card_subset_eq[of A \"{a}\"]"], ["proof (prove)\nusing this:\n  card A = 1\n  a \\<in> A\n  0 < card A \\<Longrightarrow> finite A\n  \\<lbrakk>finite A; {a} \\<subseteq> A; card {a} = card A\\<rbrakk>\n  \\<Longrightarrow> {a} = A\n\ngoal (1 subgoal):\n 1. \\<exists>a. A = {a}", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. A = {a}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_pow: \"a\\<in>A \\<Longrightarrow> {a}\\<in>Pow A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> A \\<Longrightarrow> {a} \\<in> Pow A", "using Pow_mono Pow_top"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> ?B \\<Longrightarrow> Pow ?A \\<subseteq> Pow ?B\n  ?A \\<in> Pow ?A\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<Longrightarrow> {a} \\<in> Pow A", "by fast"], ["", "definition separated_by :: \"'a set set \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  where \"separated_by w x y \\<equiv> \\<exists>A B. w={A,B} \\<and> x\\<in>A \\<and> y\\<in>B\""], ["", "lemma separated_byI: \"x\\<in>A \\<Longrightarrow> y\\<in>B \\<Longrightarrow> separated_by {A,B} x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A; y \\<in> B\\<rbrakk>\n    \\<Longrightarrow> separated_by {A, B} x y", "using separated_by_def"], ["proof (prove)\nusing this:\n  separated_by ?w ?x ?y \\<equiv>\n  \\<exists>A B. ?w = {A, B} \\<and> ?x \\<in> A \\<and> ?y \\<in> B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A; y \\<in> B\\<rbrakk>\n    \\<Longrightarrow> separated_by {A, B} x y", "by fastforce"], ["", "lemma separated_by_disjoint: \"\\<lbrakk> separated_by {A,B} x y; A\\<inter>B={}; x\\<in>A \\<rbrakk> \\<Longrightarrow> y\\<in>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>separated_by {A, B} x y; A \\<inter> B = {}; x \\<in> A\\<rbrakk>\n    \\<Longrightarrow> y \\<in> B", "unfolding separated_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>Aa Ba.\n                {A, B} = {Aa, Ba} \\<and> x \\<in> Aa \\<and> y \\<in> Ba;\n     A \\<inter> B = {}; x \\<in> A\\<rbrakk>\n    \\<Longrightarrow> y \\<in> B", "by fast"], ["", "lemma separated_by_in_other: \"separated_by {A,B} x y \\<Longrightarrow> x\\<notin>A \\<Longrightarrow> x\\<in>B \\<and> y\\<in>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>separated_by {A, B} x y; x \\<notin> A\\<rbrakk>\n    \\<Longrightarrow> x \\<in> B \\<and> y \\<in> A", "unfolding separated_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>Aa Ba.\n                {A, B} = {Aa, Ba} \\<and> x \\<in> Aa \\<and> y \\<in> Ba;\n     x \\<notin> A\\<rbrakk>\n    \\<Longrightarrow> x \\<in> B \\<and> y \\<in> A", "by auto"], ["", "lemma separated_by_not_empty: \"separated_by w x y \\<Longrightarrow> w\\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated_by w x y \\<Longrightarrow> w \\<noteq> {}", "unfolding separated_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       w = {A, B} \\<and> x \\<in> A \\<and> y \\<in> B \\<Longrightarrow>\n    w \\<noteq> {}", "by fast"], ["", "lemma not_self_separated_by_disjoint: \"A\\<inter>B={} \\<Longrightarrow> \\<not> separated_by {A,B} x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B = {} \\<Longrightarrow> \\<not> separated_by {A, B} x x", "unfolding separated_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B = {} \\<Longrightarrow>\n    \\<nexists>Aa Ba. {A, B} = {Aa, Ba} \\<and> x \\<in> Aa \\<and> x \\<in> Ba", "by auto"], ["", "subsection \\<open>Functions and relations\\<close>"], ["", "subsubsection \\<open>Miscellaneous\\<close>"], ["", "lemma cong_let: \"(let x = y in f x) = f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let y f = f y", "by simp"], ["", "lemma sym_sym: \"sym (A\\<times>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym (A \\<times> A)", "by (fast intro: symI)"], ["", "lemma trans_sym: \"trans (A\\<times>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (A \\<times> A)", "by (fast intro: transI)"], ["", "lemma map_prod_sym: \"sym A \\<Longrightarrow> sym (map_prod f f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym A \\<Longrightarrow> sym (map_prod f f ` A)", "using symD[of A] map_prod_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>sym A; (?b, ?a) \\<in> A\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b) \\<in> A\n  map_prod ?f ?g = (\\<lambda>(x, y). (?f x, ?g y))\n\ngoal (1 subgoal):\n 1. sym A \\<Longrightarrow> sym (map_prod f f ` A)", "by (fast intro: symI)"], ["", "abbreviation restrict1 :: \"('a\\<Rightarrow>'a) \\<Rightarrow> 'a set \\<Rightarrow> ('a\\<Rightarrow>'a)\"\n  where \"restrict1 f A \\<equiv> (\\<lambda>a. if a\\<in>A then f a else a)\""], ["", "lemma restrict1_image: \"B\\<subseteq>A \\<Longrightarrow> restrict1 f A ` B = f`B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<subseteq> A \\<Longrightarrow> restrict1 f A ` B = f ` B", "by auto"], ["", "subsubsection \\<open>Equality of functions restricted to a set\\<close>"], ["", "definition \"fun_eq_on f g A \\<equiv> (\\<forall>a\\<in>A. f a = g a)\""], ["", "lemma fun_eq_onI: \"(\\<And>a. a\\<in>A \\<Longrightarrow> f a = g a) \\<Longrightarrow> fun_eq_on f g A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> A \\<Longrightarrow> f a = g a) \\<Longrightarrow>\n    fun_eq_on f g A", "using fun_eq_on_def"], ["proof (prove)\nusing this:\n  fun_eq_on ?f ?g ?A \\<equiv> \\<forall>a\\<in>?A. ?f a = ?g a\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> A \\<Longrightarrow> f a = g a) \\<Longrightarrow>\n    fun_eq_on f g A", "by fast"], ["", "lemma fun_eq_onD: \"fun_eq_on f g A \\<Longrightarrow> a \\<in> A \\<Longrightarrow> f a = g a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_eq_on f g A; a \\<in> A\\<rbrakk> \\<Longrightarrow> f a = g a", "using fun_eq_on_def"], ["proof (prove)\nusing this:\n  fun_eq_on ?f ?g ?A \\<equiv> \\<forall>a\\<in>?A. ?f a = ?g a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_eq_on f g A; a \\<in> A\\<rbrakk> \\<Longrightarrow> f a = g a", "by fast"], ["", "lemma fun_eq_on_UNIV: \"(fun_eq_on f g UNIV) = (f=g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_eq_on f g UNIV = (f = g)", "unfolding fun_eq_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a\\<in>UNIV. f a = g a) = (f = g)", "by fast"], ["", "lemma fun_eq_on_subset: \"fun_eq_on f g A \\<Longrightarrow> B\\<subseteq>A \\<Longrightarrow> fun_eq_on f g B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_eq_on f g A; B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> fun_eq_on f g B", "unfolding fun_eq_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>A. f a = g a; B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>B. f a = g a", "by fast"], ["", "lemma fun_eq_on_sym: \"fun_eq_on f g A \\<Longrightarrow> fun_eq_on g f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_eq_on f g A \\<Longrightarrow> fun_eq_on g f A", "using fun_eq_onD"], ["proof (prove)\nusing this:\n  \\<lbrakk>fun_eq_on ?f ?g ?A; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f ?a = ?g ?a\n\ngoal (1 subgoal):\n 1. fun_eq_on f g A \\<Longrightarrow> fun_eq_on g f A", "by (fastforce intro: fun_eq_onI)"], ["", "lemma fun_eq_on_trans: \"fun_eq_on f g A \\<Longrightarrow> fun_eq_on g h A \\<Longrightarrow> fun_eq_on f h A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_eq_on f g A; fun_eq_on g h A\\<rbrakk>\n    \\<Longrightarrow> fun_eq_on f h A", "using fun_eq_onD fun_eq_onD"], ["proof (prove)\nusing this:\n  \\<lbrakk>fun_eq_on ?f ?g ?A; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f ?a = ?g ?a\n  \\<lbrakk>fun_eq_on ?f ?g ?A; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f ?a = ?g ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_eq_on f g A; fun_eq_on g h A\\<rbrakk>\n    \\<Longrightarrow> fun_eq_on f h A", "by (fastforce intro: fun_eq_onI)"], ["", "lemma fun_eq_on_cong: \"fun_eq_on f h A \\<Longrightarrow> fun_eq_on g h A \\<Longrightarrow> fun_eq_on f g A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_eq_on f h A; fun_eq_on g h A\\<rbrakk>\n    \\<Longrightarrow> fun_eq_on f g A", "using fun_eq_on_trans fun_eq_on_sym"], ["proof (prove)\nusing this:\n  \\<lbrakk>fun_eq_on ?f ?g ?A; fun_eq_on ?g ?h ?A\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on ?f ?h ?A\n  fun_eq_on ?f ?g ?A \\<Longrightarrow> fun_eq_on ?g ?f ?A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_eq_on f h A; fun_eq_on g h A\\<rbrakk>\n    \\<Longrightarrow> fun_eq_on f g A", "by fastforce"], ["", "lemma fun_eq_on_im : \"fun_eq_on f g A \\<Longrightarrow> B\\<subseteq>A \\<Longrightarrow> f`B = g`B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_eq_on f g A; B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> f ` B = g ` B", "using fun_eq_onD"], ["proof (prove)\nusing this:\n  \\<lbrakk>fun_eq_on ?f ?g ?A; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f ?a = ?g ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_eq_on f g A; B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> f ` B = g ` B", "by force"], ["", "lemma fun_eq_on_subset_and_diff_imp_eq_on:\n  assumes \"A\\<subseteq>B\" \"fun_eq_on f g A\" \"fun_eq_on f g (B-A)\"\n  shows   \"fun_eq_on f g B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_eq_on f g B", "proof (rule fun_eq_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> B \\<Longrightarrow> f a = g a", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> B \\<Longrightarrow> f a = g a", "assume \"x\\<in>B\""], ["proof (state)\nthis:\n  x \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> B \\<Longrightarrow> f a = g a", "with assms(1)"], ["proof (chain)\npicking this:\n  A \\<subseteq> B\n  x \\<in> B", "show \"f x = g x\""], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n  x \\<in> B\n\ngoal (1 subgoal):\n 1. f x = g x", "using fun_eq_onD[OF assms(2)] fun_eq_onD[OF assms(3)]"], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n  x \\<in> B\n  ?a \\<in> A \\<Longrightarrow> f ?a = g ?a\n  ?a \\<in> B - A \\<Longrightarrow> f ?a = g ?a\n\ngoal (1 subgoal):\n 1. f x = g x", "by    (cases \"x\\<in>A\") auto"], ["proof (state)\nthis:\n  f x = g x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fun_eq_on_set_and_comp_imp_eq:\n  \"fun_eq_on f g A \\<Longrightarrow> fun_eq_on f g (-A) \\<Longrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_eq_on f g A; fun_eq_on f g (- A)\\<rbrakk>\n    \\<Longrightarrow> f = g", "using fun_eq_on_subset_and_diff_imp_eq_on[of A UNIV]"], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<subseteq> UNIV; fun_eq_on ?f ?g A;\n   fun_eq_on ?f ?g (UNIV - A)\\<rbrakk>\n  \\<Longrightarrow> fun_eq_on ?f ?g UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_eq_on f g A; fun_eq_on f g (- A)\\<rbrakk>\n    \\<Longrightarrow> f = g", "by    (simp add: Compl_eq_Diff_UNIV fun_eq_on_UNIV)"], ["", "lemma fun_eq_on_bij_betw: \"fun_eq_on f g A \\<Longrightarrow> bij_betw f A B = bij_betw g A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_eq_on f g A \\<Longrightarrow> bij_betw f A B = bij_betw g A B", "using bij_betw_cong"], ["proof (prove)\nusing this:\n  (\\<And>a. a \\<in> ?A \\<Longrightarrow> ?f a = ?g a) \\<Longrightarrow>\n  bij_betw ?f ?A ?A' = bij_betw ?g ?A ?A'\n\ngoal (1 subgoal):\n 1. fun_eq_on f g A \\<Longrightarrow> bij_betw f A B = bij_betw g A B", "unfolding fun_eq_on_def"], ["proof (prove)\nusing this:\n  (\\<And>a. a \\<in> ?A \\<Longrightarrow> ?f a = ?g a) \\<Longrightarrow>\n  bij_betw ?f ?A ?A' = bij_betw ?g ?A ?A'\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>A. f a = g a \\<Longrightarrow>\n    bij_betw f A B = bij_betw g A B", "by fast"], ["", "lemma fun_eq_on_restrict1: \"fun_eq_on (restrict1 f A) f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_eq_on (restrict1 f A) f A", "by (auto intro: fun_eq_onI)"], ["", "abbreviation \"fixespointwise f A \\<equiv> fun_eq_on f id A\""], ["", "lemmas fixespointwiseI           = fun_eq_onI       [of   _ _ id]"], ["", "lemmas fixespointwiseD           = fun_eq_onD       [of     _ id]"], ["", "lemmas fixespointwise_cong       = fun_eq_on_trans  [of _ _ _ id]"], ["", "lemmas fixespointwise_subset     = fun_eq_on_subset [of     _ id]"], ["", "lemmas fixespointwise2_imp_eq_on = fun_eq_on_cong   [of     _ id]"], ["", "lemmas fixespointwise_subset_and_diff_imp_eq_on =\n  fun_eq_on_subset_and_diff_imp_eq_on[of _ _ _ id]"], ["", "lemma id_fixespointwise: \"fixespointwise id A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise id A", "using fun_eq_on_def"], ["proof (prove)\nusing this:\n  fun_eq_on ?f ?g ?A \\<equiv> \\<forall>a\\<in>?A. ?f a = ?g a\n\ngoal (1 subgoal):\n 1. fixespointwise id A", "by fast"], ["", "lemma fixespointwise_im: \"fixespointwise f A \\<Longrightarrow> B\\<subseteq>A \\<Longrightarrow> f`B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fixespointwise f A; B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> f ` B = B", "by (auto simp add: fun_eq_on_im)"], ["", "lemma fixespointwise_comp:\n  \"fixespointwise f A \\<Longrightarrow> fixespointwise g A \\<Longrightarrow> fixespointwise (g\\<circ>f) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fixespointwise f A; fixespointwise g A\\<rbrakk>\n    \\<Longrightarrow> fixespointwise (g \\<circ> f) A", "unfolding fun_eq_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>A. f a = id a;\n     \\<forall>a\\<in>A. g a = id a\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>A. (g \\<circ> f) a = id a", "by simp"], ["", "lemma fixespointwise_insert:\n  assumes \"fixespointwise f A\" \"f ` (insert a A) = insert a A\"\n  shows   \"fixespointwise f (insert a A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise f (insert a A)", "using   assms(2) insert_compare_element[of a A \"f a\"]\n          fixespointwiseD[OF assms(1)] fixespointwise_im[OF assms(1)]"], ["proof (prove)\nusing this:\n  f ` insert a A = insert a A\n  \\<lbrakk>a \\<notin> A; insert (f a) A = insert a A\\<rbrakk>\n  \\<Longrightarrow> f a = a\n  ?a \\<in> A \\<Longrightarrow> f ?a = id ?a\n  ?B \\<subseteq> A \\<Longrightarrow> f ` ?B = ?B\n\ngoal (1 subgoal):\n 1. fixespointwise f (insert a A)", "by      (cases \"a\\<in>A\") (auto intro: fixespointwiseI)"], ["", "lemma fixespointwise_restrict1:\n  \"fixespointwise f A \\<Longrightarrow> fixespointwise (restrict1 f B) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise f A \\<Longrightarrow> fixespointwise (restrict1 f B) A", "using fixespointwiseD[of f]"], ["proof (prove)\nusing this:\n  \\<lbrakk>fixespointwise f ?A; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> f ?a = id ?a\n\ngoal (1 subgoal):\n 1. fixespointwise f A \\<Longrightarrow> fixespointwise (restrict1 f B) A", "by (auto intro: fixespointwiseI)"], ["", "lemma fold_fixespointwise:\n  \"\\<forall>x\\<in>set xs. fixespointwise (f x) A \\<Longrightarrow> fixespointwise (fold f xs) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. fixespointwise (f x) A \\<Longrightarrow>\n    fixespointwise (fold f xs) A", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set []. fixespointwise (f x) A \\<Longrightarrow>\n    fixespointwise (fold f []) A\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   fixespointwise (f x) A \\<Longrightarrow>\n                fixespointwise (fold f xs) A;\n        \\<forall>x\\<in>set (a # xs). fixespointwise (f x) A\\<rbrakk>\n       \\<Longrightarrow> fixespointwise (fold f (a # xs)) A", "case Nil"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set []. fixespointwise (f x) A\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set []. fixespointwise (f x) A \\<Longrightarrow>\n    fixespointwise (fold f []) A\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   fixespointwise (f x) A \\<Longrightarrow>\n                fixespointwise (fold f xs) A;\n        \\<forall>x\\<in>set (a # xs). fixespointwise (f x) A\\<rbrakk>\n       \\<Longrightarrow> fixespointwise (fold f (a # xs)) A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise (fold f []) A", "using id_fixespointwise subst[of id]"], ["proof (prove)\nusing this:\n  fixespointwise id ?A\n  \\<lbrakk>id = ?t; ?P id\\<rbrakk> \\<Longrightarrow> ?P ?t\n\ngoal (1 subgoal):\n 1. fixespointwise (fold f []) A", "by fastforce"], ["proof (state)\nthis:\n  fixespointwise (fold f []) A\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   fixespointwise (f x) A \\<Longrightarrow>\n                fixespointwise (fold f xs) A;\n        \\<forall>x\\<in>set (a # xs). fixespointwise (f x) A\\<rbrakk>\n       \\<Longrightarrow> fixespointwise (fold f (a # xs)) A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   fixespointwise (f x) A \\<Longrightarrow>\n                fixespointwise (fold f xs) A;\n        \\<forall>x\\<in>set (a # xs). fixespointwise (f x) A\\<rbrakk>\n       \\<Longrightarrow> fixespointwise (fold f (a # xs)) A", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. fixespointwise (f x) A \\<Longrightarrow>\n  fixespointwise (fold f xs) A\n  \\<forall>x\\<in>set (x # xs). fixespointwise (f x) A\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   fixespointwise (f x) A \\<Longrightarrow>\n                fixespointwise (fold f xs) A;\n        \\<forall>x\\<in>set (a # xs). fixespointwise (f x) A\\<rbrakk>\n       \\<Longrightarrow> fixespointwise (fold f (a # xs)) A", "hence \"fixespointwise (fold f xs \\<circ> f x) A\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. fixespointwise (f x) A \\<Longrightarrow>\n  fixespointwise (fold f xs) A\n  \\<forall>x\\<in>set (x # xs). fixespointwise (f x) A\n\ngoal (1 subgoal):\n 1. fixespointwise (fold f xs \\<circ> f x) A", "using fixespointwise_comp[of \"f x\" A \"fold f xs\"]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. fixespointwise (f x) A \\<Longrightarrow>\n  fixespointwise (fold f xs) A\n  \\<forall>x\\<in>set (x # xs). fixespointwise (f x) A\n  \\<lbrakk>fixespointwise (f x) A; fixespointwise (fold f xs) A\\<rbrakk>\n  \\<Longrightarrow> fixespointwise (fold f xs \\<circ> f x) A\n\ngoal (1 subgoal):\n 1. fixespointwise (fold f xs \\<circ> f x) A", "by fastforce"], ["proof (state)\nthis:\n  fixespointwise (fold f xs \\<circ> f x) A\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   fixespointwise (f x) A \\<Longrightarrow>\n                fixespointwise (fold f xs) A;\n        \\<forall>x\\<in>set (a # xs). fixespointwise (f x) A\\<rbrakk>\n       \\<Longrightarrow> fixespointwise (fold f (a # xs)) A", "moreover"], ["proof (state)\nthis:\n  fixespointwise (fold f xs \\<circ> f x) A\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   fixespointwise (f x) A \\<Longrightarrow>\n                fixespointwise (fold f xs) A;\n        \\<forall>x\\<in>set (a # xs). fixespointwise (f x) A\\<rbrakk>\n       \\<Longrightarrow> fixespointwise (fold f (a # xs)) A", "have \"fold f xs \\<circ> f x = fold f (x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold f xs \\<circ> f x = fold f (x # xs)", "by simp"], ["proof (state)\nthis:\n  fold f xs \\<circ> f x = fold f (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   fixespointwise (f x) A \\<Longrightarrow>\n                fixespointwise (fold f xs) A;\n        \\<forall>x\\<in>set (a # xs). fixespointwise (f x) A\\<rbrakk>\n       \\<Longrightarrow> fixespointwise (fold f (a # xs)) A", "ultimately"], ["proof (chain)\npicking this:\n  fixespointwise (fold f xs \\<circ> f x) A\n  fold f xs \\<circ> f x = fold f (x # xs)", "show ?case"], ["proof (prove)\nusing this:\n  fixespointwise (fold f xs \\<circ> f x) A\n  fold f xs \\<circ> f x = fold f (x # xs)\n\ngoal (1 subgoal):\n 1. fixespointwise (fold f (x # xs)) A", "using subst[of _ _ \"\\<lambda>f. fixespointwise f A\"]"], ["proof (prove)\nusing this:\n  fixespointwise (fold f xs \\<circ> f x) A\n  fold f xs \\<circ> f x = fold f (x # xs)\n  \\<lbrakk>?s = ?t; fixespointwise ?s A\\<rbrakk>\n  \\<Longrightarrow> fixespointwise ?t A\n\ngoal (1 subgoal):\n 1. fixespointwise (fold f (x # xs)) A", "by fast"], ["proof (state)\nthis:\n  fixespointwise (fold f (x # xs)) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma funpower_fixespointwise:\n  assumes \"fixespointwise f A\"\n  shows   \"fixespointwise (f^^n) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise (f ^^ n) A", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. fixespointwise (f ^^ 0) A\n 2. \\<And>n.\n       fixespointwise (f ^^ n) A \\<Longrightarrow>\n       fixespointwise (f ^^ Suc n) A", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. fixespointwise (f ^^ 0) A\n 2. \\<And>n.\n       fixespointwise (f ^^ n) A \\<Longrightarrow>\n       fixespointwise (f ^^ Suc n) A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fixespointwise (f ^^ 0) A", "using id_fixespointwise subst[of id]"], ["proof (prove)\nusing this:\n  fixespointwise id ?A\n  \\<lbrakk>id = ?t; ?P id\\<rbrakk> \\<Longrightarrow> ?P ?t\n\ngoal (1 subgoal):\n 1. fixespointwise (f ^^ 0) A", "by fastforce"], ["proof (state)\nthis:\n  fixespointwise (f ^^ 0) A\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       fixespointwise (f ^^ n) A \\<Longrightarrow>\n       fixespointwise (f ^^ Suc n) A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       fixespointwise (f ^^ n) A \\<Longrightarrow>\n       fixespointwise (f ^^ Suc n) A", "case (Suc m)"], ["proof (state)\nthis:\n  fixespointwise (f ^^ m) A\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       fixespointwise (f ^^ n) A \\<Longrightarrow>\n       fixespointwise (f ^^ Suc n) A", "with assms"], ["proof (chain)\npicking this:\n  fixespointwise f A\n  fixespointwise (f ^^ m) A", "have \"fixespointwise (f \\<circ> (f^^m)) A\""], ["proof (prove)\nusing this:\n  fixespointwise f A\n  fixespointwise (f ^^ m) A\n\ngoal (1 subgoal):\n 1. fixespointwise (f \\<circ> f ^^ m) A", "using fixespointwise_comp"], ["proof (prove)\nusing this:\n  fixespointwise f A\n  fixespointwise (f ^^ m) A\n  \\<lbrakk>fixespointwise ?f ?A; fixespointwise ?g ?A\\<rbrakk>\n  \\<Longrightarrow> fixespointwise (?g \\<circ> ?f) ?A\n\ngoal (1 subgoal):\n 1. fixespointwise (f \\<circ> f ^^ m) A", "by fast"], ["proof (state)\nthis:\n  fixespointwise (f \\<circ> f ^^ m) A\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       fixespointwise (f ^^ n) A \\<Longrightarrow>\n       fixespointwise (f ^^ Suc n) A", "moreover"], ["proof (state)\nthis:\n  fixespointwise (f \\<circ> f ^^ m) A\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       fixespointwise (f ^^ n) A \\<Longrightarrow>\n       fixespointwise (f ^^ Suc n) A", "have \"f \\<circ> (f^^m) = f^^(Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> f ^^ m = f ^^ Suc m", "by simp"], ["proof (state)\nthis:\n  f \\<circ> f ^^ m = f ^^ Suc m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       fixespointwise (f ^^ n) A \\<Longrightarrow>\n       fixespointwise (f ^^ Suc n) A", "ultimately"], ["proof (chain)\npicking this:\n  fixespointwise (f \\<circ> f ^^ m) A\n  f \\<circ> f ^^ m = f ^^ Suc m", "show ?case"], ["proof (prove)\nusing this:\n  fixespointwise (f \\<circ> f ^^ m) A\n  f \\<circ> f ^^ m = f ^^ Suc m\n\ngoal (1 subgoal):\n 1. fixespointwise (f ^^ Suc m) A", "using subst[of _ _ \"\\<lambda>f. fixespointwise f A\"]"], ["proof (prove)\nusing this:\n  fixespointwise (f \\<circ> f ^^ m) A\n  f \\<circ> f ^^ m = f ^^ Suc m\n  \\<lbrakk>?s = ?t; fixespointwise ?s A\\<rbrakk>\n  \\<Longrightarrow> fixespointwise ?t A\n\ngoal (1 subgoal):\n 1. fixespointwise (f ^^ Suc m) A", "by fast"], ["proof (state)\nthis:\n  fixespointwise (f ^^ Suc m) A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Injectivity, surjectivity, bijectivity, and inverses\\<close>"], ["", "lemma inj_on_to_singleton:\n  assumes \"inj_on f A\" \"f`A = {b}\"\n  shows \"\\<exists>a. A = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. A = {a}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a. A = {a}", "from assms(2)"], ["proof (chain)\npicking this:\n  f ` A = {b}", "obtain a where a: \"a\\<in>A\" \"f a = b\""], ["proof (prove)\nusing this:\n  f ` A = {b}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> A; f a = b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  a \\<in> A\n  f a = b\n\ngoal (1 subgoal):\n 1. \\<exists>a. A = {a}", "with assms"], ["proof (chain)\npicking this:\n  inj_on f A\n  f ` A = {b}\n  a \\<in> A\n  f a = b", "have \"A = {a}\""], ["proof (prove)\nusing this:\n  inj_on f A\n  f ` A = {b}\n  a \\<in> A\n  f a = b\n\ngoal (1 subgoal):\n 1. A = {a}", "using inj_onD[of f A]"], ["proof (prove)\nusing this:\n  inj_on f A\n  f ` A = {b}\n  a \\<in> A\n  f a = b\n  \\<lbrakk>inj_on f A; f ?x = f ?y; ?x \\<in> A; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. A = {a}", "by blast"], ["proof (state)\nthis:\n  A = {a}\n\ngoal (1 subgoal):\n 1. \\<exists>a. A = {a}", "thus ?thesis"], ["proof (prove)\nusing this:\n  A = {a}\n\ngoal (1 subgoal):\n 1. \\<exists>a. A = {a}", "by fast"], ["proof (state)\nthis:\n  \\<exists>a. A = {a}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas inj_inj_on = subset_inj_on[of _ UNIV, OF _ subset_UNIV]"], ["", "lemma inj_on_eq_image': \"\\<lbrakk> inj_on f A; X\\<subseteq>A; Y\\<subseteq>A; f`X\\<subseteq>f`Y \\<rbrakk> \\<Longrightarrow> X\\<subseteq>Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; X \\<subseteq> A; Y \\<subseteq> A;\n     f ` X \\<subseteq> f ` Y\\<rbrakk>\n    \\<Longrightarrow> X \\<subseteq> Y", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>A.\n                \\<forall>y\\<in>A. f x = f y \\<longrightarrow> x = y;\n     X \\<subseteq> A; Y \\<subseteq> A; f ` X \\<subseteq> f ` Y\\<rbrakk>\n    \\<Longrightarrow> X \\<subseteq> Y", "by fast"], ["", "lemma inj_on_eq_image: \"\\<lbrakk> inj_on f A; X\\<subseteq>A; Y\\<subseteq>A; f`X=f`Y \\<rbrakk> \\<Longrightarrow> X=Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; X \\<subseteq> A; Y \\<subseteq> A;\n     f ` X = f ` Y\\<rbrakk>\n    \\<Longrightarrow> X = Y", "using inj_on_eq_image'[of f A X Y] inj_on_eq_image'[of f A Y X]"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on f A; X \\<subseteq> A; Y \\<subseteq> A;\n   f ` X \\<subseteq> f ` Y\\<rbrakk>\n  \\<Longrightarrow> X \\<subseteq> Y\n  \\<lbrakk>inj_on f A; Y \\<subseteq> A; X \\<subseteq> A;\n   f ` Y \\<subseteq> f ` X\\<rbrakk>\n  \\<Longrightarrow> Y \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; X \\<subseteq> A; Y \\<subseteq> A;\n     f ` X = f ` Y\\<rbrakk>\n    \\<Longrightarrow> X = Y", "by simp"], ["", "lemmas inj_eq_image = inj_on_eq_image[OF _ subset_UNIV subset_UNIV]"], ["", "lemma induced_pow_fun_inj_on:\n  assumes \"inj_on f A\"\n  shows   \"inj_on ((`) f) (Pow A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((`) f) (Pow A)", "using   inj_onD[OF assms] inj_onI[of \"Pow A\" \"(`) f\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>f ?x = f ?y; ?x \\<in> A; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  (\\<And>x y.\n      \\<lbrakk>x \\<in> Pow A; y \\<in> Pow A; f ` x = f ` y\\<rbrakk>\n      \\<Longrightarrow> x = y) \\<Longrightarrow>\n  inj_on ((`) f) (Pow A)\n\ngoal (1 subgoal):\n 1. inj_on ((`) f) (Pow A)", "by      blast"], ["", "lemma inj_on_minus_set: \"inj_on ((-) A) (Pow A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((-) A) (Pow A)", "by (fast intro: inj_onI)"], ["", "lemma induced_pow_fun_surj:\n  \"((`) f) ` (Pow A) = Pow (f`A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) f ` Pow A = Pow (f ` A)", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> (`) f ` Pow A \\<Longrightarrow> x \\<in> Pow (f ` A)\n 2. \\<And>x. x \\<in> Pow (f ` A) \\<Longrightarrow> x \\<in> (`) f ` Pow A", "fix X"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> (`) f ` Pow A \\<Longrightarrow> x \\<in> Pow (f ` A)\n 2. \\<And>x. x \\<in> Pow (f ` A) \\<Longrightarrow> x \\<in> (`) f ` Pow A", "show \"X \\<in> ((`) f) ` (Pow A) \\<Longrightarrow> X \\<in> Pow (f`A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> (`) f ` Pow A \\<Longrightarrow> X \\<in> Pow (f ` A)", "by fast"], ["proof (state)\nthis:\n  X \\<in> (`) f ` Pow A \\<Longrightarrow> X \\<in> Pow (f ` A)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pow (f ` A) \\<Longrightarrow> x \\<in> (`) f ` Pow A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pow (f ` A) \\<Longrightarrow> x \\<in> (`) f ` Pow A", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pow (f ` A) \\<Longrightarrow> x \\<in> (`) f ` Pow A", "assume Y: \"Y \\<in> Pow (f`A)\""], ["proof (state)\nthis:\n  Y \\<in> Pow (f ` A)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pow (f ` A) \\<Longrightarrow> x \\<in> (`) f ` Pow A", "moreover"], ["proof (state)\nthis:\n  Y \\<in> Pow (f ` A)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pow (f ` A) \\<Longrightarrow> x \\<in> (`) f ` Pow A", "hence \"Y = f`{a\\<in>A. f a \\<in> Y}\""], ["proof (prove)\nusing this:\n  Y \\<in> Pow (f ` A)\n\ngoal (1 subgoal):\n 1. Y = f ` {a \\<in> A. f a \\<in> Y}", "by fast"], ["proof (state)\nthis:\n  Y = f ` {a \\<in> A. f a \\<in> Y}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pow (f ` A) \\<Longrightarrow> x \\<in> (`) f ` Pow A", "ultimately"], ["proof (chain)\npicking this:\n  Y \\<in> Pow (f ` A)\n  Y = f ` {a \\<in> A. f a \\<in> Y}", "show \"Y\\<in> ((`) f) ` (Pow A)\""], ["proof (prove)\nusing this:\n  Y \\<in> Pow (f ` A)\n  Y = f ` {a \\<in> A. f a \\<in> Y}\n\ngoal (1 subgoal):\n 1. Y \\<in> (`) f ` Pow A", "by auto"], ["proof (state)\nthis:\n  Y \\<in> (`) f ` Pow A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_betw_f_the_inv_into_f:\n  \"bij_betw f A B \\<Longrightarrow> y\\<in>B \\<Longrightarrow> f (the_inv_into A f y) = y\"\n\\<comment> \\<open>an equivalent lemma appears in the HOL library, but this version avoids the double\n  @{const bij_betw} premises\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij_betw f A B; y \\<in> B\\<rbrakk>\n    \\<Longrightarrow> f (the_inv_into A f y) = y", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A \\<and> f ` A = B; y \\<in> B\\<rbrakk>\n    \\<Longrightarrow> f (the_inv_into A f y) = y", "by (blast intro: f_the_inv_into_f)"], ["", "lemma bij_betw_the_inv_into_onto: \"bij_betw f A B \\<Longrightarrow> the_inv_into A f ` B = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw f A B \\<Longrightarrow> the_inv_into A f ` B = A", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f A \\<and> f ` A = B \\<Longrightarrow> the_inv_into A f ` B = A", "by force"], ["", "lemma bij_betw_imp_bij_betw_Pow:\n  assumes \"bij_betw f A B\"\n  shows   \"bij_betw ((`) f) (Pow A) (Pow B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw ((`) f) (Pow A) (Pow B)", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((`) f) (Pow A) \\<and> (`) f ` Pow A = Pow B", "proof (rule conjI, rule inj_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Pow A; y \\<in> Pow A; f ` x = f ` y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (`) f ` Pow A = Pow B", "show \"\\<And>x y. \\<lbrakk> x\\<in>Pow A; y\\<in>Pow A; f`x = f`y \\<rbrakk> \\<Longrightarrow> x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Pow A; y \\<in> Pow A; f ` x = f ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "using inj_onD[OF bij_betw_imp_inj_on, OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>f ?x = f ?y; ?x \\<in> A; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Pow A; y \\<in> Pow A; f ` x = f ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> Pow A; ?y \\<in> Pow A; f ` ?x = f ` ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. (`) f ` Pow A = Pow B", "show \"(`) f ` Pow A = Pow B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) f ` Pow A = Pow B", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (`) f ` Pow A \\<subseteq> Pow B\n 2. Pow B \\<subseteq> (`) f ` Pow A", "show \"(`) f ` Pow A \\<subseteq> Pow B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) f ` Pow A \\<subseteq> Pow B", "using bij_betw_imp_surj_on[OF assms]"], ["proof (prove)\nusing this:\n  f ` A = B\n\ngoal (1 subgoal):\n 1. (`) f ` Pow A \\<subseteq> Pow B", "by fast"], ["proof (state)\nthis:\n  (`) f ` Pow A \\<subseteq> Pow B\n\ngoal (1 subgoal):\n 1. Pow B \\<subseteq> (`) f ` Pow A", "show \"(`) f ` Pow A \\<supseteq> Pow B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pow B \\<subseteq> (`) f ` Pow A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pow B \\<Longrightarrow> x \\<in> (`) f ` Pow A", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pow B \\<Longrightarrow> x \\<in> (`) f ` Pow A", "assume y: \"y\\<in>Pow B\""], ["proof (state)\nthis:\n  y \\<in> Pow B\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pow B \\<Longrightarrow> x \\<in> (`) f ` Pow A", "with assms"], ["proof (chain)\npicking this:\n  bij_betw f A B\n  y \\<in> Pow B", "have \"y = f ` the_inv_into A f ` y\""], ["proof (prove)\nusing this:\n  bij_betw f A B\n  y \\<in> Pow B\n\ngoal (1 subgoal):\n 1. y = f ` the_inv_into A f ` y", "using bij_betw_f_the_inv_into_f[THEN sym]"], ["proof (prove)\nusing this:\n  bij_betw f A B\n  y \\<in> Pow B\n  \\<lbrakk>bij_betw ?f1 ?A1 ?B1; ?t \\<in> ?B1\\<rbrakk>\n  \\<Longrightarrow> ?t = ?f1 (the_inv_into ?A1 ?f1 ?t)\n\ngoal (1 subgoal):\n 1. y = f ` the_inv_into A f ` y", "by fastforce"], ["proof (state)\nthis:\n  y = f ` the_inv_into A f ` y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pow B \\<Longrightarrow> x \\<in> (`) f ` Pow A", "moreover"], ["proof (state)\nthis:\n  y = f ` the_inv_into A f ` y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pow B \\<Longrightarrow> x \\<in> (`) f ` Pow A", "from y assms"], ["proof (chain)\npicking this:\n  y \\<in> Pow B\n  bij_betw f A B", "have \"the_inv_into A f ` y \\<subseteq> A\""], ["proof (prove)\nusing this:\n  y \\<in> Pow B\n  bij_betw f A B\n\ngoal (1 subgoal):\n 1. the_inv_into A f ` y \\<subseteq> A", "using bij_betw_the_inv_into_onto"], ["proof (prove)\nusing this:\n  y \\<in> Pow B\n  bij_betw f A B\n  bij_betw ?f ?A ?B \\<Longrightarrow> the_inv_into ?A ?f ` ?B = ?A\n\ngoal (1 subgoal):\n 1. the_inv_into A f ` y \\<subseteq> A", "by fastforce"], ["proof (state)\nthis:\n  the_inv_into A f ` y \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pow B \\<Longrightarrow> x \\<in> (`) f ` Pow A", "ultimately"], ["proof (chain)\npicking this:\n  y = f ` the_inv_into A f ` y\n  the_inv_into A f ` y \\<subseteq> A", "show \"y \\<in> (`) f ` Pow A\""], ["proof (prove)\nusing this:\n  y = f ` the_inv_into A f ` y\n  the_inv_into A f ` y \\<subseteq> A\n\ngoal (1 subgoal):\n 1. y \\<in> (`) f ` Pow A", "by auto"], ["proof (state)\nthis:\n  y \\<in> (`) f ` Pow A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Pow B \\<subseteq> (`) f ` Pow A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (`) f ` Pow A = Pow B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comps_fixpointwise_imp_bij_betw:\n  assumes \"f`X\\<subseteq>Y\" \"g`Y\\<subseteq>X\" \"fixespointwise (g\\<circ>f) X\" \"fixespointwise (f\\<circ>g) Y\"\n  shows   \"bij_betw f X Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw f X Y", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f X \\<and> f ` X = Y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on f X\n 2. f ` X = Y", "show \"inj_on f X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f X", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> X; y \\<in> X; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> X; y \\<in> X; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"\\<lbrakk> x\\<in>X; y\\<in>X; f x = f y \\<rbrakk> \\<Longrightarrow> x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X; y \\<in> X; f x = f y\\<rbrakk>\n    \\<Longrightarrow> x = y", "using fixespointwiseD[OF assms(3), of x] fixespointwiseD[OF assms(3), of y]"], ["proof (prove)\nusing this:\n  x \\<in> X \\<Longrightarrow> (g \\<circ> f) x = id x\n  y \\<in> X \\<Longrightarrow> (g \\<circ> f) y = id y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X; y \\<in> X; f x = f y\\<rbrakk>\n    \\<Longrightarrow> x = y", "by    simp"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> X; y \\<in> X; f x = f y\\<rbrakk> \\<Longrightarrow> x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on f X\n\ngoal (1 subgoal):\n 1. f ` X = Y", "from assms(1,2)"], ["proof (chain)\npicking this:\n  f ` X \\<subseteq> Y\n  g ` Y \\<subseteq> X", "show \"f`X = Y\""], ["proof (prove)\nusing this:\n  f ` X \\<subseteq> Y\n  g ` Y \\<subseteq> X\n\ngoal (1 subgoal):\n 1. f ` X = Y", "using fixespointwiseD[OF assms(4)]"], ["proof (prove)\nusing this:\n  f ` X \\<subseteq> Y\n  g ` Y \\<subseteq> X\n  ?a \\<in> Y \\<Longrightarrow> (f \\<circ> g) ?a = id ?a\n\ngoal (1 subgoal):\n 1. f ` X = Y", "by force"], ["proof (state)\nthis:\n  f ` X = Y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_permutation_bij_restrict1:\n  assumes \"bij_betw f A A\"\n  shows   \"bij (restrict1 f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (restrict1 f A)", "proof (rule bijI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj (restrict1 f A)\n 2. surj (restrict1 f A)", "have bij_f: \"inj_on f A\" \"f`A = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f A &&& f ` A = A", "using iffD1[OF bij_betw_def, OF assms]"], ["proof (prove)\nusing this:\n  inj_on f A \\<and> f ` A = A\n\ngoal (1 subgoal):\n 1. inj_on f A &&& f ` A = A", "by auto"], ["proof (state)\nthis:\n  inj_on f A\n  f ` A = A\n\ngoal (2 subgoals):\n 1. inj (restrict1 f A)\n 2. surj (restrict1 f A)", "show \"inj (restrict1 f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (restrict1 f A)", "proof (rule injI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. restrict1 f A x = restrict1 f A y \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. restrict1 f A x = restrict1 f A y \\<Longrightarrow> x = y", "show \"restrict1 f A x = restrict1 f A y \\<Longrightarrow> x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict1 f A x = restrict1 f A y \\<Longrightarrow> x = y", "using inj_onD bij_f"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on ?f ?A; ?f ?x = ?f ?y; ?x \\<in> ?A; ?y \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  inj_on f A\n  f ` A = A\n\ngoal (1 subgoal):\n 1. restrict1 f A x = restrict1 f A y \\<Longrightarrow> x = y", "by (cases \"x\\<in>A\" \"y\\<in>A\" rule: two_cases) auto"], ["proof (state)\nthis:\n  restrict1 f A x = restrict1 f A y \\<Longrightarrow> x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj (restrict1 f A)\n\ngoal (1 subgoal):\n 1. surj (restrict1 f A)", "show \"surj (restrict1 f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj (restrict1 f A)", "proof (rule surjI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. restrict1 f A (?f x) = x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. restrict1 f A (?f x) = x", "define y where \"y \\<equiv> restrict1 (the_inv_into A f) A x\""], ["proof (state)\nthis:\n  y \\<equiv> restrict1 (the_inv_into A f) A x\n\ngoal (1 subgoal):\n 1. \\<And>x. restrict1 f A (?f x) = x", "thus \"restrict1 f A y = x\""], ["proof (prove)\nusing this:\n  y \\<equiv> restrict1 (the_inv_into A f) A x\n\ngoal (1 subgoal):\n 1. restrict1 f A y = x", "using the_inv_into_into[of f] bij_f f_the_inv_into_f[of f]"], ["proof (prove)\nusing this:\n  y \\<equiv> restrict1 (the_inv_into A f) A x\n  \\<lbrakk>inj_on f ?A; ?x \\<in> f ` ?A; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> the_inv_into ?A f ?x \\<in> ?B\n  inj_on f A\n  f ` A = A\n  \\<lbrakk>inj_on f ?A; ?y \\<in> f ` ?A\\<rbrakk>\n  \\<Longrightarrow> f (the_inv_into ?A f ?y) = ?y\n\ngoal (1 subgoal):\n 1. restrict1 f A y = x", "by (cases \"x\\<in>A\") auto"], ["proof (state)\nthis:\n  restrict1 f A y = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  surj (restrict1 f A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_permutation_the_inv_restrict1:\n  assumes \"bij_betw f A A\"\n  shows   \"the_inv (restrict1 f A) = restrict1 (the_inv_into A f) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv (restrict1 f A) = restrict1 (the_inv_into A f) A", "proof (rule ext, rule the_inv_into_f_eq)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a. inj (restrict1 f A)\n 2. \\<And>a. restrict1 f A (restrict1 (the_inv_into A f) A a) = a\n 3. \\<And>a. restrict1 (the_inv_into A f) A a \\<in> UNIV", "from assms"], ["proof (chain)\npicking this:\n  bij_betw f A A", "show \"inj (restrict1 f A)\""], ["proof (prove)\nusing this:\n  bij_betw f A A\n\ngoal (1 subgoal):\n 1. inj (restrict1 f A)", "using bij_is_inj set_permutation_bij_restrict1"], ["proof (prove)\nusing this:\n  bij_betw f A A\n  bij ?f \\<Longrightarrow> inj ?f\n  bij_betw ?f ?A ?A \\<Longrightarrow> bij (restrict1 ?f ?A)\n\ngoal (1 subgoal):\n 1. inj (restrict1 f A)", "by fast"], ["proof (state)\nthis:\n  inj (restrict1 f A)\n\ngoal (2 subgoals):\n 1. \\<And>a. restrict1 f A (restrict1 (the_inv_into A f) A a) = a\n 2. \\<And>a. restrict1 (the_inv_into A f) A a \\<in> UNIV", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. restrict1 f A (restrict1 (the_inv_into A f) A a) = a\n 2. \\<And>a. restrict1 (the_inv_into A f) A a \\<in> UNIV", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. restrict1 f A (restrict1 (the_inv_into A f) A a) = a\n 2. \\<And>a. restrict1 (the_inv_into A f) A a \\<in> UNIV", "from assms"], ["proof (chain)\npicking this:\n  bij_betw f A A", "show  \"restrict1 f A (restrict1 (the_inv_into A f) A a) = a\""], ["proof (prove)\nusing this:\n  bij_betw f A A\n\ngoal (1 subgoal):\n 1. restrict1 f A (restrict1 (the_inv_into A f) A a) = a", "using bij_betw_def[of f]"], ["proof (prove)\nusing this:\n  bij_betw f A A\n  bij_betw f ?A ?B = (inj_on f ?A \\<and> f ` ?A = ?B)\n\ngoal (1 subgoal):\n 1. restrict1 f A (restrict1 (the_inv_into A f) A a) = a", "by (simp add: the_inv_into_into f_the_inv_into_f)"], ["proof (state)\nthis:\n  restrict1 f A (restrict1 (the_inv_into A f) A a) = a\n\ngoal (1 subgoal):\n 1. \\<And>a. restrict1 (the_inv_into A f) A a \\<in> UNIV", "qed simp"], ["", "lemma the_inv_into_the_inv_into:\n  \"inj_on f A \\<Longrightarrow> a\\<in>A \\<Longrightarrow> the_inv_into (f`A) (the_inv_into A f) a = f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; a \\<in> A\\<rbrakk>\n    \\<Longrightarrow> the_inv_into (f ` A) (the_inv_into A f) a = f a", "using inj_on_the_inv_into"], ["proof (prove)\nusing this:\n  inj_on ?f ?A \\<Longrightarrow> inj_on (the_inv_into ?A ?f) (?f ` ?A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f A; a \\<in> A\\<rbrakk>\n    \\<Longrightarrow> the_inv_into (f ` A) (the_inv_into A f) a = f a", "by (force intro: the_inv_into_f_eq imageI)"], ["", "lemma the_inv_into_f_im_f_im:\n  assumes \"inj_on f A\" \"x\\<subseteq>A\"\n  shows   \"the_inv_into A f ` f ` x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv_into A f ` f ` x = x", "using   assms(2) the_inv_into_f_f[OF assms(1)]"], ["proof (prove)\nusing this:\n  x \\<subseteq> A\n  ?x \\<in> A \\<Longrightarrow> the_inv_into A f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. the_inv_into A f ` f ` x = x", "by      force"], ["", "lemma f_im_the_inv_into_f_im:\n  assumes \"inj_on f A\" \"x\\<subseteq>f`A\"\n  shows   \"f ` the_inv_into A f ` x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` the_inv_into A f ` x = x", "using   assms(2) f_the_inv_into_f[OF assms(1)]"], ["proof (prove)\nusing this:\n  x \\<subseteq> f ` A\n  ?y \\<in> f ` A \\<Longrightarrow> f (the_inv_into A f ?y) = ?y\n\ngoal (1 subgoal):\n 1. f ` the_inv_into A f ` x = x", "by      force"], ["", "lemma the_inv_leftinv: \"bij f \\<Longrightarrow> the_inv f \\<circ> f = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij f \\<Longrightarrow> the_inv f \\<circ> f = id", "using bij_def[of f] the_inv_f_f"], ["proof (prove)\nusing this:\n  bij f = (inj f \\<and> surj f)\n  inj ?f \\<Longrightarrow> the_inv ?f (?f ?x) = ?x\n\ngoal (1 subgoal):\n 1. bij f \\<Longrightarrow> the_inv f \\<circ> f = id", "by fastforce"], ["", "subsubsection \\<open>Induced functions on sets of sets and lists of sets\\<close>"], ["", "text \\<open>\n  Here we create convenience abbreviations for distributing a function over a set of sets and over\n  a list of sets.\n\\<close>"], ["", "abbreviation setsetmapim :: \"('a\\<Rightarrow>'b) \\<Rightarrow> 'a set set \\<Rightarrow> 'b set set\" (infix \"\\<turnstile>\" 70)\n  where \"f\\<turnstile>X \\<equiv> ((`) f) ` X\""], ["", "abbreviation setlistmapim :: \"('a\\<Rightarrow>'b) \\<Rightarrow> 'a set list \\<Rightarrow> 'b set list\" (infix \"\\<Turnstile>\" 70)\n  where \"f\\<Turnstile>Xs \\<equiv> map ((`) f) Xs\""], ["", "lemma setsetmapim_comp: \"(f\\<circ>g)\\<turnstile>A = f\\<turnstile>(g\\<turnstile>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> g) \\<turnstile> A = f \\<turnstile> (g \\<turnstile> A)", "by (auto simp add: image_comp)"], ["", "lemma setlistmapim_comp: \"(f\\<circ>g)\\<Turnstile>xs = f\\<Turnstile>(g\\<Turnstile>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> g) \\<Turnstile> xs = f \\<Turnstile> (g \\<Turnstile> xs)", "by auto"], ["", "lemma setsetmapim_cong_subset:\n  assumes \"fun_eq_on g f (\\<Union>A)\" \"B\\<subseteq>A\"\n  shows   \"g\\<turnstile>B \\<subseteq> f\\<turnstile>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<turnstile> B \\<subseteq> f \\<turnstile> B", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> g \\<turnstile> B \\<Longrightarrow> x \\<in> f \\<turnstile> B", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> g \\<turnstile> B \\<Longrightarrow> x \\<in> f \\<turnstile> B", "assume \"y \\<in> g\\<turnstile>B\""], ["proof (state)\nthis:\n  y \\<in> g \\<turnstile> B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> g \\<turnstile> B \\<Longrightarrow> x \\<in> f \\<turnstile> B", "from this"], ["proof (chain)\npicking this:\n  y \\<in> g \\<turnstile> B", "obtain x where \"x\\<in>B\" \"y = g`x\""], ["proof (prove)\nusing this:\n  y \\<in> g \\<turnstile> B\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; y = g ` x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  x \\<in> B\n  y = g ` x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> g \\<turnstile> B \\<Longrightarrow> x \\<in> f \\<turnstile> B", "with assms(2)"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  x \\<in> B\n  y = g ` x", "show \"y \\<in> f\\<turnstile>B\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  x \\<in> B\n  y = g ` x\n\ngoal (1 subgoal):\n 1. y \\<in> f \\<turnstile> B", "using fun_eq_on_im[OF assms(1), of x]"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  x \\<in> B\n  y = g ` x\n  x \\<subseteq> \\<Union> A \\<Longrightarrow> g ` x = f ` x\n\ngoal (1 subgoal):\n 1. y \\<in> f \\<turnstile> B", "by fast"], ["proof (state)\nthis:\n  y \\<in> f \\<turnstile> B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma setsetmapim_cong: \n  assumes \"fun_eq_on g f (\\<Union>A)\" \"B\\<subseteq>A\"\n  shows   \"g\\<turnstile>B = f\\<turnstile>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<turnstile> B = f \\<turnstile> B", "using   setsetmapim_cong_subset[OF assms]\n          setsetmapim_cong_subset[OF fun_eq_on_sym, OF assms]"], ["proof (prove)\nusing this:\n  g \\<turnstile> B \\<subseteq> f \\<turnstile> B\n  f \\<turnstile> B \\<subseteq> g \\<turnstile> B\n\ngoal (1 subgoal):\n 1. g \\<turnstile> B = f \\<turnstile> B", "by      fast"], ["", "lemma setsetmapim_restrict1: \"B\\<subseteq>A \\<Longrightarrow> restrict1 f (\\<Union>A) \\<turnstile> B = f\\<turnstile>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<subseteq> A \\<Longrightarrow>\n    restrict1 f (\\<Union> A) \\<turnstile> B = f \\<turnstile> B", "using setsetmapim_cong[of _ f] fun_eq_on_restrict1[of \"\\<Union>A\" f]"], ["proof (prove)\nusing this:\n  \\<lbrakk>fun_eq_on ?g f (\\<Union> ?A); ?B \\<subseteq> ?A\\<rbrakk>\n  \\<Longrightarrow> ?g \\<turnstile> ?B = f \\<turnstile> ?B\n  fun_eq_on (restrict1 f (\\<Union> A)) f (\\<Union> A)\n\ngoal (1 subgoal):\n 1. B \\<subseteq> A \\<Longrightarrow>\n    restrict1 f (\\<Union> A) \\<turnstile> B = f \\<turnstile> B", "by simp"], ["", "lemma setsetmapim_the_inv_into:\n  assumes \"inj_on f (\\<Union>A)\"\n  shows   \"(the_inv_into (\\<Union>A) f) \\<turnstile> (f\\<turnstile>A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A) = A", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile>\n               (f \\<turnstile> A) \\<Longrightarrow>\n       x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile>\n               (f \\<turnstile> A) \\<Longrightarrow>\n       x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "assume \"x \\<in> (the_inv_into (\\<Union>A) f) \\<turnstile> (f\\<turnstile>A)\""], ["proof (state)\nthis:\n  x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile>\n               (f \\<turnstile> A) \\<Longrightarrow>\n       x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "from this"], ["proof (chain)\npicking this:\n  x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "obtain y where y: \"y \\<in> f\\<turnstile>A\" \"x = the_inv_into (\\<Union>A) f ` y\""], ["proof (prove)\nusing this:\n  x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> f \\<turnstile> A;\n         x = the_inv_into (\\<Union> A) f ` y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> f \\<turnstile> A\n  x = the_inv_into (\\<Union> A) f ` y\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile>\n               (f \\<turnstile> A) \\<Longrightarrow>\n       x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "from y(1)"], ["proof (chain)\npicking this:\n  y \\<in> f \\<turnstile> A", "obtain z where z: \"z\\<in>A\" \"y = f`z\""], ["proof (prove)\nusing this:\n  y \\<in> f \\<turnstile> A\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> A; y = f ` z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  z \\<in> A\n  y = f ` z\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile>\n               (f \\<turnstile> A) \\<Longrightarrow>\n       x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "moreover"], ["proof (state)\nthis:\n  z \\<in> A\n  y = f ` z\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile>\n               (f \\<turnstile> A) \\<Longrightarrow>\n       x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "from z(1)"], ["proof (chain)\npicking this:\n  z \\<in> A", "have \"the_inv_into (\\<Union>A) f ` f ` z = z\""], ["proof (prove)\nusing this:\n  z \\<in> A\n\ngoal (1 subgoal):\n 1. the_inv_into (\\<Union> A) f ` f ` z = z", "using the_inv_into_f_f[OF assms]"], ["proof (prove)\nusing this:\n  z \\<in> A\n  ?x \\<in> \\<Union> A \\<Longrightarrow>\n  the_inv_into (\\<Union> A) f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. the_inv_into (\\<Union> A) f ` f ` z = z", "by force"], ["proof (state)\nthis:\n  the_inv_into (\\<Union> A) f ` f ` z = z\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile>\n               (f \\<turnstile> A) \\<Longrightarrow>\n       x \\<in> A\n 2. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "ultimately"], ["proof (chain)\npicking this:\n  z \\<in> A\n  y = f ` z\n  the_inv_into (\\<Union> A) f ` f ` z = z", "show \"x\\<in>A\""], ["proof (prove)\nusing this:\n  z \\<in> A\n  y = f ` z\n  the_inv_into (\\<Union> A) f ` f ` z = z\n\ngoal (1 subgoal):\n 1. x \\<in> A", "using y(2) the_inv_into_f_im_f_im[OF assms]"], ["proof (prove)\nusing this:\n  z \\<in> A\n  y = f ` z\n  the_inv_into (\\<Union> A) f ` f ` z = z\n  x = the_inv_into (\\<Union> A) f ` y\n  ?x \\<subseteq> \\<Union> A \\<Longrightarrow>\n  the_inv_into (\\<Union> A) f ` f ` ?x = ?x\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by simp"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "assume x: \"x\\<in>A\""], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "moreover"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "hence \"the_inv_into (\\<Union>A) f ` f ` x = x\""], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. the_inv_into (\\<Union> A) f ` f ` x = x", "using the_inv_into_f_im_f_im[OF assms, of x]"], ["proof (prove)\nusing this:\n  x \\<in> A\n  x \\<subseteq> \\<Union> A \\<Longrightarrow>\n  the_inv_into (\\<Union> A) f ` f ` x = x\n\ngoal (1 subgoal):\n 1. the_inv_into (\\<Union> A) f ` f ` x = x", "by fast"], ["proof (state)\nthis:\n  the_inv_into (\\<Union> A) f ` f ` x = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> A\n  the_inv_into (\\<Union> A) f ` f ` x = x", "show \"x \\<in> (the_inv_into (\\<Union>A) f) \\<turnstile> (f\\<turnstile>A)\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  the_inv_into (\\<Union> A) f ` f ` x = x\n\ngoal (1 subgoal):\n 1. x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)", "by auto"], ["proof (state)\nthis:\n  x \\<in> the_inv_into (\\<Union> A) f \\<turnstile> (f \\<turnstile> A)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Induced functions on quotients\\<close>"], ["", "text \\<open>\n  Here we construct the induced function on a quotient for an inducing function that respects the\n  relation that defines the quotient.\n\\<close>"], ["", "lemma respects_imp_unique_image_rel: \"f respects r \\<Longrightarrow> y\\<in>f`r``{a} \\<Longrightarrow> y = f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f respects r; y \\<in> f ` r `` {a}\\<rbrakk>\n    \\<Longrightarrow> y = f a", "using congruentD[of r f]"], ["proof (prove)\nusing this:\n  \\<lbrakk>f respects r; (?y, ?z) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> f ?y = f ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f respects r; y \\<in> f ` r `` {a}\\<rbrakk>\n    \\<Longrightarrow> y = f a", "by auto"], ["", "lemma ex1_class_image:\n  assumes \"refl_on A r\" \"f respects r\" \"X\\<in>A//r\"\n  shows   \"\\<exists>!b. b\\<in>f`X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!b. b \\<in> f ` X", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!b. b \\<in> f ` X", "from assms(3)"], ["proof (chain)\npicking this:\n  X \\<in> A // r", "obtain a where a: \"a\\<in>A\" \"X = r``{a}\""], ["proof (prove)\nusing this:\n  X \\<in> A // r\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> A; X = r `` {a}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: quotientE)"], ["proof (state)\nthis:\n  a \\<in> A\n  X = r `` {a}\n\ngoal (1 subgoal):\n 1. \\<exists>!b. b \\<in> f ` X", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> A\n  X = r `` {a}\n\ngoal (1 subgoal):\n 1. \\<exists>!b. b \\<in> f ` X", "using refl_onD[OF assms(1)] ex1I[of _ \"f a\"]\n          respects_imp_unique_image_rel[OF assms(2), of _ a]"], ["proof (prove)\nusing this:\n  a \\<in> A\n  X = r `` {a}\n  ?a \\<in> A \\<Longrightarrow> (?a, ?a) \\<in> r\n  \\<lbrakk>?P (f a); \\<And>x. ?P x \\<Longrightarrow> x = f a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!x. ?P x\n  ?y \\<in> f ` r `` {a} \\<Longrightarrow> ?y = f a\n\ngoal (1 subgoal):\n 1. \\<exists>!b. b \\<in> f ` X", "by    force"], ["proof (state)\nthis:\n  \\<exists>!b. b \\<in> f ` X\n\ngoal:\nNo subgoals!", "qed"], ["", "definition quotientfun :: \"('a\\<Rightarrow>'b) \\<Rightarrow> 'a set \\<Rightarrow> 'b\"\n  where \"quotientfun f X = (THE b. b\\<in>f`X)\""], ["", "lemma quotientfun_equality:\n  assumes   \"refl_on A r\" \"f respects r\" \"X\\<in>A//r\" \"b\\<in>f`X\"\n  shows     \"quotientfun f X = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quotientfun f X = b", "unfolding quotientfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE b. b \\<in> f ` X) = b", "using     assms(4) ex1_class_image[OF assms(1-3)]"], ["proof (prove)\nusing this:\n  b \\<in> f ` X\n  \\<exists>!b. b \\<in> f ` X\n\ngoal (1 subgoal):\n 1. (THE b. b \\<in> f ` X) = b", "by        (auto intro: the1_equality)"], ["", "lemma quotientfun_classrep_equality:\n  \"\\<lbrakk> refl_on A r; f respects r; a\\<in>A \\<rbrakk> \\<Longrightarrow> quotientfun f (r``{a}) = f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>refl_on A r; f respects r; a \\<in> A\\<rbrakk>\n    \\<Longrightarrow> quotientfun f (r `` {a}) = f a", "using refl_onD"], ["proof (prove)\nusing this:\n  \\<lbrakk>refl_on ?A ?r; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> (?a, ?a) \\<in> ?r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>refl_on A r; f respects r; a \\<in> A\\<rbrakk>\n    \\<Longrightarrow> quotientfun f (r `` {a}) = f a", "by (fastforce intro: quotientfun_equality quotientI)"], ["", "subsubsection \\<open>Support of a function\\<close>"], ["", "definition supp :: \"('a \\<Rightarrow> 'b::zero) \\<Rightarrow> 'a set\" where \"supp f = {x. f x \\<noteq> 0}\""], ["", "lemma suppI_contra: \"x \\<notin> supp f \\<Longrightarrow> f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> supp f \\<Longrightarrow> f x = (0::'b)", "using supp_def"], ["proof (prove)\nusing this:\n  supp ?f = {x. ?f x \\<noteq> (0::?'b)}\n\ngoal (1 subgoal):\n 1. x \\<notin> supp f \\<Longrightarrow> f x = (0::'b)", "by fast"], ["", "lemma suppD_contra: \"f x = 0 \\<Longrightarrow> x \\<notin> supp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = (0::'a) \\<Longrightarrow> x \\<notin> supp f", "using supp_def"], ["proof (prove)\nusing this:\n  supp ?f = {x. ?f x \\<noteq> (0::?'b)}\n\ngoal (1 subgoal):\n 1. f x = (0::'a) \\<Longrightarrow> x \\<notin> supp f", "by fast"], ["", "abbreviation restrict0 :: \"('a\\<Rightarrow>'b::zero) \\<Rightarrow> 'a set \\<Rightarrow> ('a\\<Rightarrow>'b)\"\n  where \"restrict0 f A \\<equiv> (\\<lambda>a. if a \\<in> A then f a else 0)\""], ["", "lemma supp_restrict0 : \"supp (restrict0 f A) \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (restrict0 f A) \\<subseteq> A", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. supp (restrict0 f A) \\<subseteq> A", "have \"\\<And>a. a \\<notin> A \\<Longrightarrow> a \\<notin> supp (restrict0 f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<notin> A \\<Longrightarrow> a \\<notin> supp (restrict0 f A)", "using suppD_contra[of \"restrict0 f A\"]"], ["proof (prove)\nusing this:\n  restrict0 f A ?x = (0::'b) \\<Longrightarrow>\n  ?x \\<notin> supp (restrict0 f A)\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<notin> A \\<Longrightarrow> a \\<notin> supp (restrict0 f A)", "by simp"], ["proof (state)\nthis:\n  ?a \\<notin> A \\<Longrightarrow> ?a \\<notin> supp (restrict0 f A)\n\ngoal (1 subgoal):\n 1. supp (restrict0 f A) \\<subseteq> A", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?a \\<notin> A \\<Longrightarrow> ?a \\<notin> supp (restrict0 f A)\n\ngoal (1 subgoal):\n 1. supp (restrict0 f A) \\<subseteq> A", "by fast"], ["proof (state)\nthis:\n  supp (restrict0 f A) \\<subseteq> A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lists\\<close>"], ["", "subsubsection \\<open>Miscellaneous facts\\<close>"], ["", "lemma snoc_conv_cons: \"\\<exists>x xs. ys@[y] = x#xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x xs. ys @ [y] = x # xs", "by (cases ys) auto"], ["", "lemma cons_conv_snoc: \"\\<exists>ys y. x#xs = ys@[y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys y. x # xs = ys @ [y]", "by (cases xs rule: rev_cases) auto"], ["", "lemma same_length_eq_append:\n  \"length as = length bs \\<Longrightarrow> as@cs = bs@ds \\<Longrightarrow> as = bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length as = length bs; as @ cs = bs @ ds\\<rbrakk>\n    \\<Longrightarrow> as = bs", "by (induct as bs rule: list_induct2) auto"], ["", "lemma count_list_append:\n  \"count_list (xs@ys) a = count_list xs a + count_list ys a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (xs @ ys) a = count_list xs a + count_list ys a", "by (induct xs) auto"], ["", "lemma count_list_snoc:\n  \"count_list (xs@[x]) y = (if y=x then Suc (count_list xs y) else count_list xs y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list (xs @ [x]) y =\n    (if y = x then Suc (count_list xs y) else count_list xs y)", "by (induct xs) auto"], ["", "lemma distinct_count_list:\n  \"distinct xs \\<Longrightarrow> count_list xs a = (if a \\<in> set xs then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow>\n    count_list xs a = (if a \\<in> set xs then 1 else 0)", "by (induct xs) auto"], ["", "lemma map_fst_map_const_snd: \"map fst (map (\\<lambda>s. (s,b)) xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (map (\\<lambda>s. (s, b)) xs) = xs", "by (induct xs) auto"], ["", "lemma inj_on_distinct_setlistmapim:\n  assumes \"inj_on f A\"\n  shows \"\\<forall>X\\<in>set Xs. X \\<subseteq> A \\<Longrightarrow> distinct Xs \\<Longrightarrow> distinct (f\\<Turnstile>Xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>X\\<in>set Xs. X \\<subseteq> A; distinct Xs\\<rbrakk>\n    \\<Longrightarrow> distinct (f \\<Turnstile> Xs)", "proof (induct Xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>X\\<in>set []. X \\<subseteq> A; distinct []\\<rbrakk>\n    \\<Longrightarrow> distinct (f \\<Turnstile> [])\n 2. \\<And>a Xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>X\\<in>set Xs. X \\<subseteq> A;\n                 distinct Xs\\<rbrakk>\n                \\<Longrightarrow> distinct (f \\<Turnstile> Xs);\n        \\<forall>X\\<in>set (a # Xs). X \\<subseteq> A;\n        distinct (a # Xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (f \\<Turnstile> (a # Xs))", "case (Cons X Xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>X\\<in>set Xs. X \\<subseteq> A; distinct Xs\\<rbrakk>\n  \\<Longrightarrow> distinct (f \\<Turnstile> Xs)\n  \\<forall>X\\<in>set (X # Xs). X \\<subseteq> A\n  distinct (X # Xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>X\\<in>set []. X \\<subseteq> A; distinct []\\<rbrakk>\n    \\<Longrightarrow> distinct (f \\<Turnstile> [])\n 2. \\<And>a Xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>X\\<in>set Xs. X \\<subseteq> A;\n                 distinct Xs\\<rbrakk>\n                \\<Longrightarrow> distinct (f \\<Turnstile> Xs);\n        \\<forall>X\\<in>set (a # Xs). X \\<subseteq> A;\n        distinct (a # Xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (f \\<Turnstile> (a # Xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (f \\<Turnstile> (X # Xs))", "proof (cases \"f`X \\<in> set (f\\<Turnstile>Xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f ` X \\<in> set (f \\<Turnstile> Xs) \\<Longrightarrow>\n    distinct (f \\<Turnstile> (X # Xs))\n 2. f ` X \\<notin> set (f \\<Turnstile> Xs) \\<Longrightarrow>\n    distinct (f \\<Turnstile> (X # Xs))", "case True"], ["proof (state)\nthis:\n  f ` X \\<in> set (f \\<Turnstile> Xs)\n\ngoal (2 subgoals):\n 1. f ` X \\<in> set (f \\<Turnstile> Xs) \\<Longrightarrow>\n    distinct (f \\<Turnstile> (X # Xs))\n 2. f ` X \\<notin> set (f \\<Turnstile> Xs) \\<Longrightarrow>\n    distinct (f \\<Turnstile> (X # Xs))", "from this"], ["proof (chain)\npicking this:\n  f ` X \\<in> set (f \\<Turnstile> Xs)", "obtain Y where Y: \"Y\\<in>set Xs\" \"f`X = f`Y\""], ["proof (prove)\nusing this:\n  f ` X \\<in> set (f \\<Turnstile> Xs)\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> set Xs; f ` X = f ` Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Y \\<in> set Xs\n  f ` X = f ` Y\n\ngoal (2 subgoals):\n 1. f ` X \\<in> set (f \\<Turnstile> Xs) \\<Longrightarrow>\n    distinct (f \\<Turnstile> (X # Xs))\n 2. f ` X \\<notin> set (f \\<Turnstile> Xs) \\<Longrightarrow>\n    distinct (f \\<Turnstile> (X # Xs))", "with assms Y(1) Cons(2,3)"], ["proof (chain)\npicking this:\n  inj_on f A\n  Y \\<in> set Xs\n  \\<forall>X\\<in>set (X # Xs). X \\<subseteq> A\n  distinct (X # Xs)\n  Y \\<in> set Xs\n  f ` X = f ` Y", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on f A\n  Y \\<in> set Xs\n  \\<forall>X\\<in>set (X # Xs). X \\<subseteq> A\n  distinct (X # Xs)\n  Y \\<in> set Xs\n  f ` X = f ` Y\n\ngoal (1 subgoal):\n 1. distinct (f \\<Turnstile> (X # Xs))", "using inj_on_eq_image[of f A X Y]"], ["proof (prove)\nusing this:\n  inj_on f A\n  Y \\<in> set Xs\n  \\<forall>X\\<in>set (X # Xs). X \\<subseteq> A\n  distinct (X # Xs)\n  Y \\<in> set Xs\n  f ` X = f ` Y\n  \\<lbrakk>inj_on f A; X \\<subseteq> A; Y \\<subseteq> A;\n   f ` X = f ` Y\\<rbrakk>\n  \\<Longrightarrow> X = Y\n\ngoal (1 subgoal):\n 1. distinct (f \\<Turnstile> (X # Xs))", "by fastforce"], ["proof (state)\nthis:\n  distinct (f \\<Turnstile> (X # Xs))\n\ngoal (1 subgoal):\n 1. f ` X \\<notin> set (f \\<Turnstile> Xs) \\<Longrightarrow>\n    distinct (f \\<Turnstile> (X # Xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f ` X \\<notin> set (f \\<Turnstile> Xs) \\<Longrightarrow>\n    distinct (f \\<Turnstile> (X # Xs))", "case False"], ["proof (state)\nthis:\n  f ` X \\<notin> set (f \\<Turnstile> Xs)\n\ngoal (1 subgoal):\n 1. f ` X \\<notin> set (f \\<Turnstile> Xs) \\<Longrightarrow>\n    distinct (f \\<Turnstile> (X # Xs))", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>X\\<in>set Xs. X \\<subseteq> A; distinct Xs\\<rbrakk>\n  \\<Longrightarrow> distinct (f \\<Turnstile> Xs)\n  \\<forall>X\\<in>set (X # Xs). X \\<subseteq> A\n  distinct (X # Xs)\n  f ` X \\<notin> set (f \\<Turnstile> Xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>X\\<in>set Xs. X \\<subseteq> A; distinct Xs\\<rbrakk>\n  \\<Longrightarrow> distinct (f \\<Turnstile> Xs)\n  \\<forall>X\\<in>set (X # Xs). X \\<subseteq> A\n  distinct (X # Xs)\n  f ` X \\<notin> set (f \\<Turnstile> Xs)\n\ngoal (1 subgoal):\n 1. distinct (f \\<Turnstile> (X # Xs))", "by simp"], ["proof (state)\nthis:\n  distinct (f \\<Turnstile> (X # Xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (f \\<Turnstile> (X # Xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>X\\<in>set []. X \\<subseteq> A; distinct []\\<rbrakk>\n    \\<Longrightarrow> distinct (f \\<Turnstile> [])", "qed simp"], ["", "subsubsection \\<open>Cases\\<close>"], ["", "lemma list_cases_Cons_snoc [case_names Nil Single Cons_snoc]:\n  assumes       Nil: \"xs = [] \\<Longrightarrow> P\"\n  and        Single: \"\\<And>x. xs = [x] \\<Longrightarrow> P\"\n  and     Cons_snoc: \"\\<And>x ys y. xs = x # ys @ [y] \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases xs, rule Nil)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> xs = []\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P", "case (Cons x xs)"], ["proof (state)\nthis:\n  xs = x # xs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> xs = []\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P", "with Single Cons_snoc"], ["proof (chain)\npicking this:\n  xs = [?x] \\<Longrightarrow> P\n  xs = ?x # ?ys @ [?y] \\<Longrightarrow> P\n  xs = x # xs", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = [?x] \\<Longrightarrow> P\n  xs = ?x # ?ys @ [?y] \\<Longrightarrow> P\n  xs = x # xs\n\ngoal (1 subgoal):\n 1. P", "by (cases xs rule: rev_cases) auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> xs = []", "qed"], ["", "lemma two_lists_cases_Cons_Cons [case_names Nil1 Nil2 ConsCons]:\n  assumes     Nil1: \"\\<And>ys. as = [] \\<Longrightarrow> bs = ys \\<Longrightarrow> P\"\n  and         Nil2: \"\\<And>xs. as = xs \\<Longrightarrow> bs = [] \\<Longrightarrow> P\"\n  and     ConsCons: \"\\<And>x xs y ys. as = x # xs \\<Longrightarrow> bs = y # ys \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> P\n 2. \\<And>a list. as = a # list \\<Longrightarrow> P", "case Cons"], ["proof (state)\nthis:\n  as = a_ # list_\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> P\n 2. \\<And>a list. as = a # list \\<Longrightarrow> P", "with assms(2,3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>as = ?xs; bs = []\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>as = ?x # ?xs; bs = ?y # ?ys\\<rbrakk> \\<Longrightarrow> P\n  as = a_ # list_", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>as = ?xs; bs = []\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>as = ?x # ?xs; bs = ?y # ?ys\\<rbrakk> \\<Longrightarrow> P\n  as = a_ # list_\n\ngoal (1 subgoal):\n 1. P", "by (cases bs) auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. as = [] \\<Longrightarrow> P", "qed (simp add: Nil1)"], ["", "lemma two_lists_cases_snoc_Cons [case_names Nil1 Nil2 snoc_Cons]:\n  assumes      Nil1: \"\\<And>ys. as = [] \\<Longrightarrow> bs = ys \\<Longrightarrow> P\"\n  and          Nil2: \"\\<And>xs. as = xs \\<Longrightarrow> bs = [] \\<Longrightarrow> P\"\n  and     snoc_Cons: \"\\<And>xs x y ys. as = xs @ [x] \\<Longrightarrow> bs = y # ys \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases as rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> P\n 2. \\<And>ys y. as = ys @ [y] \\<Longrightarrow> P", "case snoc"], ["proof (state)\nthis:\n  as = ys_ @ [y_]\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> P\n 2. \\<And>ys y. as = ys @ [y] \\<Longrightarrow> P", "with Nil2 snoc_Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>as = ?xs; bs = []\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>as = ?xs @ [?x]; bs = ?y # ?ys\\<rbrakk> \\<Longrightarrow> P\n  as = ys_ @ [y_]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>as = ?xs; bs = []\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>as = ?xs @ [?x]; bs = ?y # ?ys\\<rbrakk> \\<Longrightarrow> P\n  as = ys_ @ [y_]\n\ngoal (1 subgoal):\n 1. P", "by (cases bs) auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. as = [] \\<Longrightarrow> P", "qed (simp add: Nil1)"], ["", "lemma two_lists_cases_snoc_Cons' [case_names both_Nil Nil1 Nil2 snoc_Cons]:\n  assumes  both_Nil: \"as = [] \\<Longrightarrow> bs = [] \\<Longrightarrow> P\"\n  and          Nil1: \"\\<And>y ys. as = [] \\<Longrightarrow> bs = y#ys \\<Longrightarrow> P\"\n  and          Nil2: \"\\<And>xs x. as = xs@[x] \\<Longrightarrow> bs = [] \\<Longrightarrow> P\"\n  and     snoc_Cons: \"\\<And>xs x y ys. as = xs @ [x] \\<Longrightarrow> bs = y # ys \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases as bs rule: two_lists_cases_snoc_Cons)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys. \\<lbrakk>as = []; bs = ys\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>xs. \\<lbrakk>as = xs; bs = []\\<rbrakk> \\<Longrightarrow> P\n 3. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; bs = y # ys\\<rbrakk> \\<Longrightarrow> P", "case (Nil1 ys)"], ["proof (state)\nthis:\n  as = []\n  bs = ys\n\ngoal (3 subgoals):\n 1. \\<And>ys. \\<lbrakk>as = []; bs = ys\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>xs. \\<lbrakk>as = xs; bs = []\\<rbrakk> \\<Longrightarrow> P\n 3. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; bs = y # ys\\<rbrakk> \\<Longrightarrow> P", "with assms(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>as = []; bs = []\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>as = []; bs = ?y # ?ys\\<rbrakk> \\<Longrightarrow> P\n  as = []\n  bs = ys", "show \"P\""], ["proof (prove)\nusing this:\n  \\<lbrakk>as = []; bs = []\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>as = []; bs = ?y # ?ys\\<rbrakk> \\<Longrightarrow> P\n  as = []\n  bs = ys\n\ngoal (1 subgoal):\n 1. P", "by (cases ys) auto"], ["proof (state)\nthis:\n  P\n\ngoal (2 subgoals):\n 1. \\<And>xs. \\<lbrakk>as = xs; bs = []\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; bs = y # ys\\<rbrakk> \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. \\<lbrakk>as = xs; bs = []\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; bs = y # ys\\<rbrakk> \\<Longrightarrow> P", "case (Nil2 xs)"], ["proof (state)\nthis:\n  as = xs\n  bs = []\n\ngoal (2 subgoals):\n 1. \\<And>xs. \\<lbrakk>as = xs; bs = []\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; bs = y # ys\\<rbrakk> \\<Longrightarrow> P", "with assms(1,3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>as = []; bs = []\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>as = ?xs @ [?x]; bs = []\\<rbrakk> \\<Longrightarrow> P\n  as = xs\n  bs = []", "show \"P\""], ["proof (prove)\nusing this:\n  \\<lbrakk>as = []; bs = []\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>as = ?xs @ [?x]; bs = []\\<rbrakk> \\<Longrightarrow> P\n  as = xs\n  bs = []\n\ngoal (1 subgoal):\n 1. P", "by (cases xs rule: rev_cases) auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; bs = y # ys\\<rbrakk> \\<Longrightarrow> P", "qed (rule snoc_Cons)"], ["", "lemma two_prod_lists_cases_snoc_Cons:\n  assumes \"\\<And>xs. as = xs \\<Longrightarrow> bs = [] \\<Longrightarrow> P\" \"\\<And>ys. as = [] \\<Longrightarrow> bs = ys \\<Longrightarrow> P\"\n          \"\\<And>xs aa ba ab bb ys. as = xs @ [(aa, ba)] \\<and> bs = (ab, bb) # ys \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (rule two_lists_cases_snoc_Cons)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys. \\<lbrakk>?as = []; ?bs = ys\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>xs. \\<lbrakk>?as = xs; ?bs = []\\<rbrakk> \\<Longrightarrow> P\n 3. \\<And>xs x y ys.\n       \\<lbrakk>?as = xs @ [x]; ?bs = y # ys\\<rbrakk> \\<Longrightarrow> P", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>as = ?xs; bs = []\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>as = []; bs = ?ys\\<rbrakk> \\<Longrightarrow> P\n  as = ?xs @ [(?aa, ?ba)] \\<and> bs = (?ab, ?bb) # ?ys \\<Longrightarrow> P", "show  \"\\<And>ys. as = [] \\<Longrightarrow> bs = ys \\<Longrightarrow> P\" \"\\<And>xs. as = xs \\<Longrightarrow> bs = [] \\<Longrightarrow> P\""], ["proof (prove)\nusing this:\n  \\<lbrakk>as = ?xs; bs = []\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>as = []; bs = ?ys\\<rbrakk> \\<Longrightarrow> P\n  as = ?xs @ [(?aa, ?ba)] \\<and> bs = (?ab, ?bb) # ?ys \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. (\\<And>ys. \\<lbrakk>as = []; bs = ys\\<rbrakk> \\<Longrightarrow> P) &&&\n    (\\<And>xs. \\<lbrakk>as = xs; bs = []\\<rbrakk> \\<Longrightarrow> P)", "by    auto"], ["proof (state)\nthis:\n  \\<lbrakk>as = []; bs = ?ys\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>as = ?xs; bs = []\\<rbrakk> \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; bs = y # ys\\<rbrakk> \\<Longrightarrow> P", "from assms(3)"], ["proof (chain)\npicking this:\n  as = ?xs @ [(?aa, ?ba)] \\<and> bs = (?ab, ?bb) # ?ys \\<Longrightarrow> P", "show \"\\<And>xs x y ys. as = xs @ [x] \\<Longrightarrow> bs = y # ys \\<Longrightarrow> P\""], ["proof (prove)\nusing this:\n  as = ?xs @ [(?aa, ?ba)] \\<and> bs = (?ab, ?bb) # ?ys \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; bs = y # ys\\<rbrakk> \\<Longrightarrow> P", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>as = ?xs @ [?x]; bs = ?y # ?ys\\<rbrakk> \\<Longrightarrow> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma three_lists_cases_snoc_mid_Cons\n      [case_names Nil1 Nil2 Nil3 snoc_single_Cons snoc_mid_Cons]:\n  assumes             Nil1: \"\\<And>ys zs. as = [] \\<Longrightarrow> bs = ys \\<Longrightarrow> cs = zs \\<Longrightarrow> P\"\n  and                 Nil2: \"\\<And>xs zs. as = xs \\<Longrightarrow> bs = [] \\<Longrightarrow> cs = zs \\<Longrightarrow> P\"\n  and                 Nil3: \"\\<And>xs ys. as = xs \\<Longrightarrow> bs = ys \\<Longrightarrow> cs = [] \\<Longrightarrow> P\"\n  and     snoc_single_Cons:\n    \"\\<And>xs x y z zs. as = xs @ [x] \\<Longrightarrow> bs = [y] \\<Longrightarrow> cs = z # zs \\<Longrightarrow> P\"\n  and        snoc_mid_Cons:\n    \"\\<And>xs x w ys y z zs. as = xs @ [x] \\<Longrightarrow> bs = w # ys @ [y] \\<Longrightarrow>\n      cs = z # zs \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases as cs rule: two_lists_cases_snoc_Cons)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys. \\<lbrakk>as = []; cs = ys\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>xs. \\<lbrakk>as = xs; cs = []\\<rbrakk> \\<Longrightarrow> P\n 3. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; cs = y # ys\\<rbrakk> \\<Longrightarrow> P", "case Nil1"], ["proof (state)\nthis:\n  as = []\n  cs = ys_\n\ngoal (3 subgoals):\n 1. \\<And>ys. \\<lbrakk>as = []; cs = ys\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>xs. \\<lbrakk>as = xs; cs = []\\<rbrakk> \\<Longrightarrow> P\n 3. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; cs = y # ys\\<rbrakk> \\<Longrightarrow> P", "with assms(1)"], ["proof (chain)\npicking this:\n  \\<lbrakk>as = []; bs = ?ys; cs = ?zs\\<rbrakk> \\<Longrightarrow> P\n  as = []\n  cs = ys_", "show \"P\""], ["proof (prove)\nusing this:\n  \\<lbrakk>as = []; bs = ?ys; cs = ?zs\\<rbrakk> \\<Longrightarrow> P\n  as = []\n  cs = ys_\n\ngoal (1 subgoal):\n 1. P", "by simp"], ["proof (state)\nthis:\n  P\n\ngoal (2 subgoals):\n 1. \\<And>xs. \\<lbrakk>as = xs; cs = []\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; cs = y # ys\\<rbrakk> \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. \\<lbrakk>as = xs; cs = []\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; cs = y # ys\\<rbrakk> \\<Longrightarrow> P", "case Nil2"], ["proof (state)\nthis:\n  as = xs_\n  cs = []\n\ngoal (2 subgoals):\n 1. \\<And>xs. \\<lbrakk>as = xs; cs = []\\<rbrakk> \\<Longrightarrow> P\n 2. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; cs = y # ys\\<rbrakk> \\<Longrightarrow> P", "with assms(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>as = ?xs; bs = ?ys; cs = []\\<rbrakk> \\<Longrightarrow> P\n  as = xs_\n  cs = []", "show \"P\""], ["proof (prove)\nusing this:\n  \\<lbrakk>as = ?xs; bs = ?ys; cs = []\\<rbrakk> \\<Longrightarrow> P\n  as = xs_\n  cs = []\n\ngoal (1 subgoal):\n 1. P", "by simp"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; cs = y # ys\\<rbrakk> \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; cs = y # ys\\<rbrakk> \\<Longrightarrow> P", "case snoc_Cons"], ["proof (state)\nthis:\n  as = xs_ @ [x_]\n  cs = y_ # ys_\n\ngoal (1 subgoal):\n 1. \\<And>xs x y ys.\n       \\<lbrakk>as = xs @ [x]; cs = y # ys\\<rbrakk> \\<Longrightarrow> P", "with Nil2 snoc_single_Cons snoc_mid_Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>as = ?xs; bs = []; cs = ?zs\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>as = ?xs @ [?x]; bs = [?y]; cs = ?z # ?zs\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>as = ?xs @ [?x]; bs = ?w # ?ys @ [?y]; cs = ?z # ?zs\\<rbrakk>\n  \\<Longrightarrow> P\n  as = xs_ @ [x_]\n  cs = y_ # ys_", "show \"P\""], ["proof (prove)\nusing this:\n  \\<lbrakk>as = ?xs; bs = []; cs = ?zs\\<rbrakk> \\<Longrightarrow> P\n  \\<lbrakk>as = ?xs @ [?x]; bs = [?y]; cs = ?z # ?zs\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>as = ?xs @ [?x]; bs = ?w # ?ys @ [?y]; cs = ?z # ?zs\\<rbrakk>\n  \\<Longrightarrow> P\n  as = xs_ @ [x_]\n  cs = y_ # ys_\n\ngoal (1 subgoal):\n 1. P", "by (cases bs rule: list_cases_Cons_snoc) auto"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Induction\\<close>"], ["", "lemma list_induct_CCons [case_names Nil Single CCons]:\n  assumes Nil   : \"P []\"\n  and     Single: \"\\<And>x. P [x]\"\n  and     CCons : \"\\<And>x y xs. P (y#xs) \\<Longrightarrow> P (x # y # xs)\"\n  shows   \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. P []\n 2. \\<And>a xs. P xs \\<Longrightarrow> P (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  P xs\n\ngoal (2 subgoals):\n 1. P []\n 2. \\<And>a xs. P xs \\<Longrightarrow> P (a # xs)", "with Single CCons"], ["proof (chain)\npicking this:\n  P [?x]\n  P (?y # ?xs) \\<Longrightarrow> P (?x # ?y # ?xs)\n  P xs", "show ?case"], ["proof (prove)\nusing this:\n  P [?x]\n  P (?y # ?xs) \\<Longrightarrow> P (?x # ?y # ?xs)\n  P xs\n\ngoal (1 subgoal):\n 1. P (x # xs)", "by (cases xs) auto"], ["proof (state)\nthis:\n  P (x # xs)\n\ngoal (1 subgoal):\n 1. P []", "qed (rule Nil)"], ["", "lemma list_induct_ssnoc [case_names Nil Single ssnoc]:\n  assumes Nil   : \"P []\"\n  and     Single: \"\\<And>x. P [x]\"\n  and     ssnoc : \"\\<And>xs x y. P (xs@[x]) \\<Longrightarrow> P (xs@[x,y])\"\n  shows   \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "proof (induct xs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. P []\n 2. \\<And>x xs. P xs \\<Longrightarrow> P (xs @ [x])", "case (snoc x xs)"], ["proof (state)\nthis:\n  P xs\n\ngoal (2 subgoals):\n 1. P []\n 2. \\<And>x xs. P xs \\<Longrightarrow> P (xs @ [x])", "with Single ssnoc"], ["proof (chain)\npicking this:\n  P [?x]\n  P (?xs @ [?x]) \\<Longrightarrow> P (?xs @ [?x, ?y])\n  P xs", "show ?case"], ["proof (prove)\nusing this:\n  P [?x]\n  P (?xs @ [?x]) \\<Longrightarrow> P (?xs @ [?x, ?y])\n  P xs\n\ngoal (1 subgoal):\n 1. P (xs @ [x])", "by (cases xs rule: rev_cases) auto"], ["proof (state)\nthis:\n  P (xs @ [x])\n\ngoal (1 subgoal):\n 1. P []", "qed (rule Nil)"], ["", "lemma list_induct2_snoc [case_names Nil1 Nil2 snoc]:\n  assumes Nil1: \"\\<And>ys. P [] ys\"\n  and     Nil2: \"\\<And>xs. P xs []\"\n  and     snoc: \"\\<And>xs x ys y. P xs ys \\<Longrightarrow> P (xs@[x]) (ys@[y])\"\n  shows   \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "proof (induct xs arbitrary: ys rule: rev_induct, rule Nil1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xa. (\\<And>x. P xs x) \\<Longrightarrow> P (xs @ [x]) xa", "case (snoc b bs)"], ["proof (state)\nthis:\n  P bs ?ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs xa. (\\<And>x. P xs x) \\<Longrightarrow> P (xs @ [x]) xa", "with assms(2,3)"], ["proof (chain)\npicking this:\n  P ?xs []\n  P ?xs ?ys \\<Longrightarrow> P (?xs @ [?x]) (?ys @ [?y])\n  P bs ?ys", "show ?case"], ["proof (prove)\nusing this:\n  P ?xs []\n  P ?xs ?ys \\<Longrightarrow> P (?xs @ [?x]) (?ys @ [?y])\n  P bs ?ys\n\ngoal (1 subgoal):\n 1. P (bs @ [b]) ys", "by (cases ys rule: rev_cases) auto"], ["proof (state)\nthis:\n  P (bs @ [b]) ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_induct2_snoc_Cons [case_names Nil1 Nil2 snoc_Cons]:\n  assumes Nil1     : \"\\<And>ys. P [] ys\"\n  and     Nil2     : \"\\<And>xs. P xs []\"\n  and     snoc_Cons: \"\\<And>xs x y ys. P xs ys \\<Longrightarrow> P (xs@[x]) (y#ys)\"\n  shows   \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "proof (induct ys arbitrary: xs, rule Nil2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ys xs. (\\<And>xs. P xs ys) \\<Longrightarrow> P xs (a # ys)", "case (Cons y ys)"], ["proof (state)\nthis:\n  P ?xs ys\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs. (\\<And>xs. P xs ys) \\<Longrightarrow> P xs (a # ys)", "with Nil1 snoc_Cons"], ["proof (chain)\npicking this:\n  P [] ?ys\n  P ?xs ?ys \\<Longrightarrow> P (?xs @ [?x]) (?y # ?ys)\n  P ?xs ys", "show ?case"], ["proof (prove)\nusing this:\n  P [] ?ys\n  P ?xs ?ys \\<Longrightarrow> P (?xs @ [?x]) (?y # ?ys)\n  P ?xs ys\n\ngoal (1 subgoal):\n 1. P xs (y # ys)", "by (cases xs rule: rev_cases) auto"], ["proof (state)\nthis:\n  P xs (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_list_induct3_snoc_Conssnoc_Cons_pairwise:\n  assumes \"\\<And>ys zs. Q ([],ys,zs)\" \"\\<And>xs zs. Q (xs,[],zs)\" \"\\<And>xs ys. Q (xs,ys,[])\"\n          \"\\<And>xs x y z zs. Q (xs@[x],[y],z#zs)\"\n  and     step:\n    \"\\<And>xs x y ys w z zs. Q (xs,ys,zs) \\<Longrightarrow> Q (xs,ys@[w],z#zs) \\<Longrightarrow>\n      Q (xs@[x],y#ys,zs) \\<Longrightarrow> Q (xs@[x],y#ys@[w],z#zs)\"\n  shows   \"Q t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q t", "proof (\n  induct  t\n  taking: \"\\<lambda>(xs,ys,zs). length xs + length ys + length zs\"\n  rule  : measure_induct_rule\n)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (case y of\n            (xs, ys, zs) \\<Rightarrow> length xs + length ys + length zs)\n           < (case x of\n              (xs, ys, zs) \\<Rightarrow>\n                length xs + length ys + length zs) \\<Longrightarrow>\n           Q y) \\<Longrightarrow>\n       Q x", "case (less t)"], ["proof (state)\nthis:\n  (case ?y of (xs, ys, zs) \\<Rightarrow> length xs + length ys + length zs)\n  < (case t of\n     (xs, ys, zs) \\<Rightarrow>\n       length xs + length ys + length zs) \\<Longrightarrow>\n  Q ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (case y of\n            (xs, ys, zs) \\<Rightarrow> length xs + length ys + length zs)\n           < (case x of\n              (xs, ys, zs) \\<Rightarrow>\n                length xs + length ys + length zs) \\<Longrightarrow>\n           Q y) \\<Longrightarrow>\n       Q x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q t", "proof (cases t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c. t = (a, b, c) \\<Longrightarrow> Q t", "case (fields xs ys zs)"], ["proof (state)\nthis:\n  t = (xs, ys, zs)\n\ngoal (1 subgoal):\n 1. \\<And>a b c. t = (a, b, c) \\<Longrightarrow> Q t", "from assms less fields"], ["proof (chain)\npicking this:\n  Q ([], ?ys, ?zs)\n  Q (?xs, [], ?zs)\n  Q (?xs, ?ys, [])\n  Q (?xs @ [?x], [?y], ?z # ?zs)\n  \\<lbrakk>Q (?xs, ?ys, ?zs); Q (?xs, ?ys @ [?w], ?z # ?zs);\n   Q (?xs @ [?x], ?y # ?ys, ?zs)\\<rbrakk>\n  \\<Longrightarrow> Q (?xs @ [?x], ?y # ?ys @ [?w], ?z # ?zs)\n  (case ?y of (xs, ys, zs) \\<Rightarrow> length xs + length ys + length zs)\n  < (case t of\n     (xs, ys, zs) \\<Rightarrow>\n       length xs + length ys + length zs) \\<Longrightarrow>\n  Q ?y\n  t = (xs, ys, zs)", "show ?thesis"], ["proof (prove)\nusing this:\n  Q ([], ?ys, ?zs)\n  Q (?xs, [], ?zs)\n  Q (?xs, ?ys, [])\n  Q (?xs @ [?x], [?y], ?z # ?zs)\n  \\<lbrakk>Q (?xs, ?ys, ?zs); Q (?xs, ?ys @ [?w], ?z # ?zs);\n   Q (?xs @ [?x], ?y # ?ys, ?zs)\\<rbrakk>\n  \\<Longrightarrow> Q (?xs @ [?x], ?y # ?ys @ [?w], ?z # ?zs)\n  (case ?y of (xs, ys, zs) \\<Rightarrow> length xs + length ys + length zs)\n  < (case t of\n     (xs, ys, zs) \\<Rightarrow>\n       length xs + length ys + length zs) \\<Longrightarrow>\n  Q ?y\n  t = (xs, ys, zs)\n\ngoal (1 subgoal):\n 1. Q t", "by (cases xs ys zs rule: three_lists_cases_snoc_mid_Cons) auto"], ["proof (state)\nthis:\n  Q t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Q t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_induct3_snoc_Conssnoc_Cons_pairwise\n      [case_names Nil1 Nil2 Nil3 snoc_single_Cons snoc_Conssnoc_Cons]:\n  assumes Nil1              : \"\\<And>ys zs. P [] ys zs\"\n  and     Nil2              : \"\\<And>xs zs. P xs [] zs\"\n  and     Nil3              : \"\\<And>xs ys. P xs ys []\"\n  and     snoc_single_Cons  : \"\\<And>xs x y z zs. P (xs@[x]) [y] (z#zs)\"\n  and     snoc_Conssnoc_Cons:\n    \"\\<And>xs x y ys w z zs. P xs ys zs \\<Longrightarrow> P xs (ys@[w]) (z#zs) \\<Longrightarrow>\n      P (xs@[x]) (y#ys) zs \\<Longrightarrow> P (xs@[x]) (y#ys@[w]) (z#zs)\"\n  shows   \"P xs ys zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys zs", "using   assms\n          prod_list_induct3_snoc_Conssnoc_Cons_pairwise[of \"\\<lambda>(xs,ys,zs). P xs ys zs\"]"], ["proof (prove)\nusing this:\n  P [] ?ys ?zs\n  P ?xs [] ?zs\n  P ?xs ?ys []\n  P (?xs @ [?x]) [?y] (?z # ?zs)\n  \\<lbrakk>P ?xs ?ys ?zs; P ?xs (?ys @ [?w]) (?z # ?zs);\n   P (?xs @ [?x]) (?y # ?ys) ?zs\\<rbrakk>\n  \\<Longrightarrow> P (?xs @ [?x]) (?y # ?ys @ [?w]) (?z # ?zs)\n  \\<lbrakk>\\<And>ys zs.\n              case ([], ys, zs) of (xs, ys, zs) \\<Rightarrow> P xs ys zs;\n   \\<And>xs zs. case (xs, [], zs) of (xs, ys, zs) \\<Rightarrow> P xs ys zs;\n   \\<And>xs ys. case (xs, ys, []) of (xs, ys, zs) \\<Rightarrow> P xs ys zs;\n   \\<And>xs x y z zs.\n      case (xs @ [x], [y], z # zs) of (xs, ys, zs) \\<Rightarrow> P xs ys zs;\n   \\<And>xs x y ys w z zs.\n      \\<lbrakk>case (xs, ys, zs) of (xs, ys, zs) \\<Rightarrow> P xs ys zs;\n       case (xs, ys @ [w], z # zs) of (xs, ys, zs) \\<Rightarrow> P xs ys zs;\n       case (xs @ [x], y # ys, zs) of\n       (xs, ys, zs) \\<Rightarrow> P xs ys zs\\<rbrakk>\n      \\<Longrightarrow> case (xs @ [x], y # ys @ [w], z # zs) of\n                        (xs, ys, zs) \\<Rightarrow> P xs ys zs\\<rbrakk>\n  \\<Longrightarrow> case ?t of (xs, ys, zs) \\<Rightarrow> P xs ys zs\n\ngoal (1 subgoal):\n 1. P xs ys zs", "by      auto"], ["", "subsubsection \\<open>Alternating lists\\<close>"], ["", "primrec alternating_list :: \"nat \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a list\"\n  where zero: \"alternating_list 0 s t = []\"\n      | Suc : \"alternating_list (Suc k) s t =\n                alternating_list k s t @ [if even k then s else t]\"\n\\<comment> \\<open>could be defined using Cons, but we want the alternating list to always start with the same\nletter as it grows, and it's easier to do that via append\\<close>"], ["", "lemma alternating_list2: \"alternating_list 2 s t = [s,t]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alternating_list 2 s t = [s, t]", "using arg_cong[OF Suc_1, THEN sym, of \"\\<lambda>n. alternating_list n s t\"]"], ["proof (prove)\nusing this:\n  alternating_list 2 s t = alternating_list (Suc 1) s t\n\ngoal (1 subgoal):\n 1. alternating_list 2 s t = [s, t]", "by simp"], ["", "lemma length_alternating_list: \"length (alternating_list n s t) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (alternating_list n s t) = n", "by (induct n) auto"], ["", "lemma alternating_list_Suc_Cons:\n  \"alternating_list (Suc k) s t = s # alternating_list k t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alternating_list (Suc k) s t = s # alternating_list k t s", "by (induct k) auto"], ["", "lemma alternating_list_SucSuc_ConsCons:\n  \"alternating_list (Suc (Suc k)) s t = s # t # alternating_list k s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alternating_list (Suc (Suc k)) s t = s # t # alternating_list k s t", "using alternating_list_Suc_Cons[of \"Suc k\" s] alternating_list_Suc_Cons[of k t]"], ["proof (prove)\nusing this:\n  alternating_list (Suc (Suc k)) s ?t = s # alternating_list (Suc k) ?t s\n  alternating_list (Suc k) t ?t = t # alternating_list k ?t t\n\ngoal (1 subgoal):\n 1. alternating_list (Suc (Suc k)) s t = s # t # alternating_list k s t", "by    simp"], ["", "lemma alternating_list_alternates:\n  \"alternating_list n s t = as@[a,b,c]@bs \\<Longrightarrow> a=c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alternating_list n s t = as @ [a, b, c] @ bs \\<Longrightarrow> a = c", "proof (induct n arbitrary: bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       alternating_list 0 s t = as @ [a, b, c] @ bs \\<Longrightarrow> a = c\n 2. \\<And>n bs.\n       \\<lbrakk>\\<And>bs.\n                   alternating_list n s t =\n                   as @ [a, b, c] @ bs \\<Longrightarrow>\n                   a = c;\n        alternating_list (Suc n) s t = as @ [a, b, c] @ bs\\<rbrakk>\n       \\<Longrightarrow> a = c", "case (Suc m)"], ["proof (state)\nthis:\n  alternating_list m s t = as @ [a, b, c] @ ?bs \\<Longrightarrow> a = c\n  alternating_list (Suc m) s t = as @ [a, b, c] @ bs\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       alternating_list 0 s t = as @ [a, b, c] @ bs \\<Longrightarrow> a = c\n 2. \\<And>n bs.\n       \\<lbrakk>\\<And>bs.\n                   alternating_list n s t =\n                   as @ [a, b, c] @ bs \\<Longrightarrow>\n                   a = c;\n        alternating_list (Suc n) s t = as @ [a, b, c] @ bs\\<rbrakk>\n       \\<Longrightarrow> a = c", "hence prevcase:\n    \"\\<And>xs. alternating_list m s t = as @ [a,b,c] @ xs \\<Longrightarrow> a = c\"\n    \"alternating_list (Suc m) s t = as @ [a,b,c] @ bs\""], ["proof (prove)\nusing this:\n  alternating_list m s t = as @ [a, b, c] @ ?bs \\<Longrightarrow> a = c\n  alternating_list (Suc m) s t = as @ [a, b, c] @ bs\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        alternating_list m s t = as @ [a, b, c] @ xs \\<Longrightarrow>\n        a = c) &&&\n    alternating_list (Suc m) s t = as @ [a, b, c] @ bs", "by auto"], ["proof (state)\nthis:\n  alternating_list m s t = as @ [a, b, c] @ ?xs \\<Longrightarrow> a = c\n  alternating_list (Suc m) s t = as @ [a, b, c] @ bs\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       alternating_list 0 s t = as @ [a, b, c] @ bs \\<Longrightarrow> a = c\n 2. \\<And>n bs.\n       \\<lbrakk>\\<And>bs.\n                   alternating_list n s t =\n                   as @ [a, b, c] @ bs \\<Longrightarrow>\n                   a = c;\n        alternating_list (Suc n) s t = as @ [a, b, c] @ bs\\<rbrakk>\n       \\<Longrightarrow> a = c", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = c", "proof (cases bs rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow> a = c\n 2. \\<And>ys y. bs = ys @ [y] \\<Longrightarrow> a = c", "case Nil"], ["proof (state)\nthis:\n  bs = []\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow> a = c\n 2. \\<And>ys y. bs = ys @ [y] \\<Longrightarrow> a = c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = c", "proof (cases m)"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> a = c\n 2. \\<And>nat. m = Suc nat \\<Longrightarrow> a = c", "case 0"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> a = c\n 2. \\<And>nat. m = Suc nat \\<Longrightarrow> a = c", "with prevcase(2)"], ["proof (chain)\npicking this:\n  alternating_list (Suc m) s t = as @ [a, b, c] @ bs\n  m = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  alternating_list (Suc m) s t = as @ [a, b, c] @ bs\n  m = 0\n\ngoal (1 subgoal):\n 1. a = c", "by simp"], ["proof (state)\nthis:\n  a = c\n\ngoal (1 subgoal):\n 1. \\<And>nat. m = Suc nat \\<Longrightarrow> a = c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. m = Suc nat \\<Longrightarrow> a = c", "case (Suc k)"], ["proof (state)\nthis:\n  m = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>nat. m = Suc nat \\<Longrightarrow> a = c", "with prevcase(2) Nil"], ["proof (chain)\npicking this:\n  alternating_list (Suc m) s t = as @ [a, b, c] @ bs\n  bs = []\n  m = Suc k", "show ?thesis"], ["proof (prove)\nusing this:\n  alternating_list (Suc m) s t = as @ [a, b, c] @ bs\n  bs = []\n  m = Suc k\n\ngoal (1 subgoal):\n 1. a = c", "by (cases k) auto"], ["proof (state)\nthis:\n  a = c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a = c\n\ngoal (1 subgoal):\n 1. \\<And>ys y. bs = ys @ [y] \\<Longrightarrow> a = c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y. bs = ys @ [y] \\<Longrightarrow> a = c", "case (snoc ds d)"], ["proof (state)\nthis:\n  bs = ds @ [d]\n\ngoal (1 subgoal):\n 1. \\<And>ys y. bs = ys @ [y] \\<Longrightarrow> a = c", "with prevcase"], ["proof (chain)\npicking this:\n  alternating_list m s t = as @ [a, b, c] @ ?xs \\<Longrightarrow> a = c\n  alternating_list (Suc m) s t = as @ [a, b, c] @ bs\n  bs = ds @ [d]", "show ?thesis"], ["proof (prove)\nusing this:\n  alternating_list m s t = as @ [a, b, c] @ ?xs \\<Longrightarrow> a = c\n  alternating_list (Suc m) s t = as @ [a, b, c] @ bs\n  bs = ds @ [d]\n\ngoal (1 subgoal):\n 1. a = c", "by simp"], ["proof (state)\nthis:\n  a = c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a = c\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       alternating_list 0 s t = as @ [a, b, c] @ bs \\<Longrightarrow> a = c", "qed simp"], ["", "lemma alternating_list_split:\n  \"alternating_list (m+n) s t = alternating_list m s t @\n    (if even m then alternating_list n s t else alternating_list n t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alternating_list (m + n) s t =\n    alternating_list m s t @\n    (if even m then alternating_list n s t else alternating_list n t s)", "using alternating_list_SucSuc_ConsCons[of _ s]"], ["proof (prove)\nusing this:\n  alternating_list (Suc (Suc ?k)) s ?t = s # ?t # alternating_list ?k s ?t\n\ngoal (1 subgoal):\n 1. alternating_list (m + n) s t =\n    alternating_list m s t @\n    (if even m then alternating_list n s t else alternating_list n t s)", "by    (induct n rule: nat_induct_step2) auto"], ["", "lemma alternating_list_append:\n  \"even m \\<Longrightarrow>\n    alternating_list m s t @ alternating_list n s t = alternating_list (m+n) s t\"\n  \"odd m \\<Longrightarrow>\n    alternating_list m s t @ alternating_list n t s = alternating_list (m+n) s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (even m \\<Longrightarrow>\n     alternating_list m s t @ alternating_list n s t =\n     alternating_list (m + n) s t) &&&\n    (odd m \\<Longrightarrow>\n     alternating_list m s t @ alternating_list n t s =\n     alternating_list (m + n) s t)", "using alternating_list_split[THEN sym, of m]"], ["proof (prove)\nusing this:\n  alternating_list m ?s1 ?t1 @\n  (if even m then alternating_list ?n1 ?s1 ?t1\n   else alternating_list ?n1 ?t1 ?s1) =\n  alternating_list (m + ?n1) ?s1 ?t1\n\ngoal (1 subgoal):\n 1. (even m \\<Longrightarrow>\n     alternating_list m s t @ alternating_list n s t =\n     alternating_list (m + n) s t) &&&\n    (odd m \\<Longrightarrow>\n     alternating_list m s t @ alternating_list n t s =\n     alternating_list (m + n) s t)", "by auto"], ["", "lemma rev_alternating_list:\n  \"rev (alternating_list n s t) =\n    (if even n then alternating_list n t s else alternating_list n s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (alternating_list n s t) =\n    (if even n then alternating_list n t s else alternating_list n s t)", "using alternating_list_SucSuc_ConsCons[of _ s]"], ["proof (prove)\nusing this:\n  alternating_list (Suc (Suc ?k)) s ?t = s # ?t # alternating_list ?k s ?t\n\ngoal (1 subgoal):\n 1. rev (alternating_list n s t) =\n    (if even n then alternating_list n t s else alternating_list n s t)", "by    (induct n rule: nat_induct_step2) auto"], ["", "lemma set_alternating_list: \"set (alternating_list n s t) \\<subseteq> {s,t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (alternating_list n s t) \\<subseteq> {s, t}", "by (induct n) auto"], ["", "lemma set_alternating_list1:\n  assumes \"n \\<ge> 1\"\n  shows \"s \\<in> set (alternating_list n s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> set (alternating_list n s t)", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> s \\<in> set (alternating_list n s t)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> s \\<in> set (alternating_list n s t)", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> s \\<in> set (alternating_list n s t)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> s \\<in> set (alternating_list n s t)", "with assms"], ["proof (chain)\npicking this:\n  1 \\<le> n\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> n\n  n = 0\n\ngoal (1 subgoal):\n 1. s \\<in> set (alternating_list n s t)", "by simp"], ["proof (state)\nthis:\n  s \\<in> set (alternating_list n s t)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> s \\<in> set (alternating_list n s t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> s \\<in> set (alternating_list n s t)", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> s \\<in> set (alternating_list n s t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. s \\<in> set (alternating_list n s t)", "using alternating_list_Suc_Cons[of m s]"], ["proof (prove)\nusing this:\n  n = Suc m\n  alternating_list (Suc m) s ?t = s # alternating_list m ?t s\n\ngoal (1 subgoal):\n 1. s \\<in> set (alternating_list n s t)", "by simp"], ["proof (state)\nthis:\n  s \\<in> set (alternating_list n s t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_alternating_list2:\n  \"n \\<ge> 2 \\<Longrightarrow> set (alternating_list n s t) = {s,t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> n \\<Longrightarrow> set (alternating_list n s t) = {s, t}", "proof (induct n rule: nat_induct_step2)"], ["proof (state)\ngoal (3 subgoals):\n 1. 2 \\<le> 0 \\<Longrightarrow> set (alternating_list 0 s t) = {s, t}\n 2. 2 \\<le> 1 \\<Longrightarrow> set (alternating_list 1 s t) = {s, t}\n 3. \\<And>m.\n       \\<lbrakk>2 \\<le> m \\<Longrightarrow>\n                set (alternating_list m s t) = {s, t};\n        2 \\<le> Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> set (alternating_list (Suc (Suc m)) s t) = {s, t}", "case (SucSuc m)"], ["proof (state)\nthis:\n  2 \\<le> m \\<Longrightarrow> set (alternating_list m s t) = {s, t}\n  2 \\<le> Suc (Suc m)\n\ngoal (3 subgoals):\n 1. 2 \\<le> 0 \\<Longrightarrow> set (alternating_list 0 s t) = {s, t}\n 2. 2 \\<le> 1 \\<Longrightarrow> set (alternating_list 1 s t) = {s, t}\n 3. \\<And>m.\n       \\<lbrakk>2 \\<le> m \\<Longrightarrow>\n                set (alternating_list m s t) = {s, t};\n        2 \\<le> Suc (Suc m)\\<rbrakk>\n       \\<Longrightarrow> set (alternating_list (Suc (Suc m)) s t) = {s, t}", "thus ?case"], ["proof (prove)\nusing this:\n  2 \\<le> m \\<Longrightarrow> set (alternating_list m s t) = {s, t}\n  2 \\<le> Suc (Suc m)\n\ngoal (1 subgoal):\n 1. set (alternating_list (Suc (Suc m)) s t) = {s, t}", "using set_alternating_list alternating_list_SucSuc_ConsCons[of m s t]"], ["proof (prove)\nusing this:\n  2 \\<le> m \\<Longrightarrow> set (alternating_list m s t) = {s, t}\n  2 \\<le> Suc (Suc m)\n  set (alternating_list ?n ?s ?t) \\<subseteq> {?s, ?t}\n  alternating_list (Suc (Suc m)) s t = s # t # alternating_list m s t\n\ngoal (1 subgoal):\n 1. set (alternating_list (Suc (Suc m)) s t) = {s, t}", "by fastforce"], ["proof (state)\nthis:\n  set (alternating_list (Suc (Suc m)) s t) = {s, t}\n\ngoal (2 subgoals):\n 1. 2 \\<le> 0 \\<Longrightarrow> set (alternating_list 0 s t) = {s, t}\n 2. 2 \\<le> 1 \\<Longrightarrow> set (alternating_list 1 s t) = {s, t}", "qed auto"], ["", "lemma alternating_list_in_lists: \"a\\<in>A \\<Longrightarrow> b\\<in>A \\<Longrightarrow> alternating_list n a b \\<in> lists A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> A; b \\<in> A\\<rbrakk>\n    \\<Longrightarrow> alternating_list n a b \\<in> lists A", "by (induct n) auto"], ["", "subsubsection \\<open>Binary relation chains\\<close>"], ["", "text \\<open>Here we consider lists where each pair of adjacent elements satisfy a given relation.\\<close>"], ["", "fun binrelchain :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> bool\"\n  where \"binrelchain P []  = True\"\n      | \"binrelchain P [x] = True\"\n      | \"binrelchain P (x # y # xs) = (P x y \\<and> binrelchain P (y#xs))\""], ["", "lemma binrelchain_Cons_reduce: \"binrelchain P (x#xs) \\<Longrightarrow> binrelchain P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binrelchain P (x # xs) \\<Longrightarrow> binrelchain P xs", "by (induct xs) auto"], ["", "lemma binrelchain_append_reduce1: \"binrelchain P (xs@ys) \\<Longrightarrow> binrelchain P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binrelchain P (xs @ ys) \\<Longrightarrow> binrelchain P xs", "proof (induct xs rule: list_induct_CCons)"], ["proof (state)\ngoal (3 subgoals):\n 1. binrelchain P ([] @ ys) \\<Longrightarrow> binrelchain P []\n 2. \\<And>x. binrelchain P ([x] @ ys) \\<Longrightarrow> binrelchain P [x]\n 3. \\<And>x y xs.\n       \\<lbrakk>binrelchain P ((y # xs) @ ys) \\<Longrightarrow>\n                binrelchain P (y # xs);\n        binrelchain P ((x # y # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> binrelchain P (x # y # xs)", "case (CCons x y xs)"], ["proof (state)\nthis:\n  binrelchain P ((y # xs) @ ys) \\<Longrightarrow> binrelchain P (y # xs)\n  binrelchain P ((x # y # xs) @ ys)\n\ngoal (3 subgoals):\n 1. binrelchain P ([] @ ys) \\<Longrightarrow> binrelchain P []\n 2. \\<And>x. binrelchain P ([x] @ ys) \\<Longrightarrow> binrelchain P [x]\n 3. \\<And>x y xs.\n       \\<lbrakk>binrelchain P ((y # xs) @ ys) \\<Longrightarrow>\n                binrelchain P (y # xs);\n        binrelchain P ((x # y # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> binrelchain P (x # y # xs)", "with binrelchain_Cons_reduce"], ["proof (chain)\npicking this:\n  binrelchain ?P (?x # ?xs) \\<Longrightarrow> binrelchain ?P ?xs\n  binrelchain P ((y # xs) @ ys) \\<Longrightarrow> binrelchain P (y # xs)\n  binrelchain P ((x # y # xs) @ ys)", "show ?case"], ["proof (prove)\nusing this:\n  binrelchain ?P (?x # ?xs) \\<Longrightarrow> binrelchain ?P ?xs\n  binrelchain P ((y # xs) @ ys) \\<Longrightarrow> binrelchain P (y # xs)\n  binrelchain P ((x # y # xs) @ ys)\n\ngoal (1 subgoal):\n 1. binrelchain P (x # y # xs)", "by fastforce"], ["proof (state)\nthis:\n  binrelchain P (x # y # xs)\n\ngoal (2 subgoals):\n 1. binrelchain P ([] @ ys) \\<Longrightarrow> binrelchain P []\n 2. \\<And>x. binrelchain P ([x] @ ys) \\<Longrightarrow> binrelchain P [x]", "qed auto"], ["", "lemma binrelchain_append_reduce2:\n  \"binrelchain P (xs@ys) \\<Longrightarrow> binrelchain P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binrelchain P (xs @ ys) \\<Longrightarrow> binrelchain P ys", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. binrelchain P ([] @ ys) \\<Longrightarrow> binrelchain P ys\n 2. \\<And>a xs.\n       \\<lbrakk>binrelchain P (xs @ ys) \\<Longrightarrow> binrelchain P ys;\n        binrelchain P ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> binrelchain P ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  binrelchain P (xs @ ys) \\<Longrightarrow> binrelchain P ys\n  binrelchain P ((x # xs) @ ys)\n\ngoal (2 subgoals):\n 1. binrelchain P ([] @ ys) \\<Longrightarrow> binrelchain P ys\n 2. \\<And>a xs.\n       \\<lbrakk>binrelchain P (xs @ ys) \\<Longrightarrow> binrelchain P ys;\n        binrelchain P ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> binrelchain P ys", "with binrelchain_Cons_reduce"], ["proof (chain)\npicking this:\n  binrelchain ?P (?x # ?xs) \\<Longrightarrow> binrelchain ?P ?xs\n  binrelchain P (xs @ ys) \\<Longrightarrow> binrelchain P ys\n  binrelchain P ((x # xs) @ ys)", "show ?case"], ["proof (prove)\nusing this:\n  binrelchain ?P (?x # ?xs) \\<Longrightarrow> binrelchain ?P ?xs\n  binrelchain P (xs @ ys) \\<Longrightarrow> binrelchain P ys\n  binrelchain P ((x # xs) @ ys)\n\ngoal (1 subgoal):\n 1. binrelchain P ys", "by fastforce"], ["proof (state)\nthis:\n  binrelchain P ys\n\ngoal (1 subgoal):\n 1. binrelchain P ([] @ ys) \\<Longrightarrow> binrelchain P ys", "qed simp"], ["", "lemma binrelchain_Conssnoc_reduce:\n  \"binrelchain P (x#xs@[y]) \\<Longrightarrow> binrelchain P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binrelchain P (x # xs @ [y]) \\<Longrightarrow> binrelchain P xs", "using binrelchain_append_reduce1 binrelchain_Cons_reduce"], ["proof (prove)\nusing this:\n  binrelchain ?P (?xs @ ?ys) \\<Longrightarrow> binrelchain ?P ?xs\n  binrelchain ?P (?x # ?xs) \\<Longrightarrow> binrelchain ?P ?xs\n\ngoal (1 subgoal):\n 1. binrelchain P (x # xs @ [y]) \\<Longrightarrow> binrelchain P xs", "by fastforce"], ["", "lemma binrelchain_overlap_join:\n  \"binrelchain P (xs@[x]) \\<Longrightarrow> binrelchain P (x#ys) \\<Longrightarrow> binrelchain P (xs@x#ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>binrelchain P (xs @ [x]); binrelchain P (x # ys)\\<rbrakk>\n    \\<Longrightarrow> binrelchain P (xs @ x # ys)", "by (induct xs rule: list_induct_CCons) auto"], ["", "lemma binrelchain_join:\n  \"\\<lbrakk> binrelchain P (xs@[x]); binrelchain P (y#ys); P x y \\<rbrakk> \\<Longrightarrow>\n    binrelchain P (xs @ x # y # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>binrelchain P (xs @ [x]); binrelchain P (y # ys);\n     P x y\\<rbrakk>\n    \\<Longrightarrow> binrelchain P (xs @ x # y # ys)", "using binrelchain_overlap_join"], ["proof (prove)\nusing this:\n  \\<lbrakk>binrelchain ?P (?xs @ [?x]); binrelchain ?P (?x # ?ys)\\<rbrakk>\n  \\<Longrightarrow> binrelchain ?P (?xs @ ?x # ?ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>binrelchain P (xs @ [x]); binrelchain P (y # ys);\n     P x y\\<rbrakk>\n    \\<Longrightarrow> binrelchain P (xs @ x # y # ys)", "by fastforce"], ["", "lemma binrelchain_snoc:\n  \"binrelchain P (xs@[x]) \\<Longrightarrow> P x y \\<Longrightarrow> binrelchain P (xs@[x,y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>binrelchain P (xs @ [x]); P x y\\<rbrakk>\n    \\<Longrightarrow> binrelchain P (xs @ [x, y])", "using binrelchain_join"], ["proof (prove)\nusing this:\n  \\<lbrakk>binrelchain ?P (?xs @ [?x]); binrelchain ?P (?y # ?ys);\n   ?P ?x ?y\\<rbrakk>\n  \\<Longrightarrow> binrelchain ?P (?xs @ ?x # ?y # ?ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>binrelchain P (xs @ [x]); P x y\\<rbrakk>\n    \\<Longrightarrow> binrelchain P (xs @ [x, y])", "by fastforce"], ["", "lemma binrelchain_sym_rev:\n  assumes \"\\<And>x y. P x y \\<Longrightarrow> P y x\"\n  shows   \"binrelchain P xs \\<Longrightarrow> binrelchain P (rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binrelchain P xs \\<Longrightarrow> binrelchain P (rev xs)", "proof (induct xs rule: list_induct_CCons)"], ["proof (state)\ngoal (3 subgoals):\n 1. binrelchain P [] \\<Longrightarrow> binrelchain P (rev [])\n 2. \\<And>x. binrelchain P [x] \\<Longrightarrow> binrelchain P (rev [x])\n 3. \\<And>x y xs.\n       \\<lbrakk>binrelchain P (y # xs) \\<Longrightarrow>\n                binrelchain P (rev (y # xs));\n        binrelchain P (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> binrelchain P (rev (x # y # xs))", "case (CCons x y xs)"], ["proof (state)\nthis:\n  binrelchain P (y # xs) \\<Longrightarrow> binrelchain P (rev (y # xs))\n  binrelchain P (x # y # xs)\n\ngoal (3 subgoals):\n 1. binrelchain P [] \\<Longrightarrow> binrelchain P (rev [])\n 2. \\<And>x. binrelchain P [x] \\<Longrightarrow> binrelchain P (rev [x])\n 3. \\<And>x y xs.\n       \\<lbrakk>binrelchain P (y # xs) \\<Longrightarrow>\n                binrelchain P (rev (y # xs));\n        binrelchain P (x # y # xs)\\<rbrakk>\n       \\<Longrightarrow> binrelchain P (rev (x # y # xs))", "with assms"], ["proof (chain)\npicking this:\n  P ?x ?y \\<Longrightarrow> P ?y ?x\n  binrelchain P (y # xs) \\<Longrightarrow> binrelchain P (rev (y # xs))\n  binrelchain P (x # y # xs)", "show ?case"], ["proof (prove)\nusing this:\n  P ?x ?y \\<Longrightarrow> P ?y ?x\n  binrelchain P (y # xs) \\<Longrightarrow> binrelchain P (rev (y # xs))\n  binrelchain P (x # y # xs)\n\ngoal (1 subgoal):\n 1. binrelchain P (rev (x # y # xs))", "by (auto intro: binrelchain_snoc)"], ["proof (state)\nthis:\n  binrelchain P (rev (x # y # xs))\n\ngoal (2 subgoals):\n 1. binrelchain P [] \\<Longrightarrow> binrelchain P (rev [])\n 2. \\<And>x. binrelchain P [x] \\<Longrightarrow> binrelchain P (rev [x])", "qed auto"], ["", "lemma binrelchain_remdup_adj:\n  \"binrelchain P (xs@[x,x]@ys) \\<Longrightarrow> binrelchain P (xs@x#ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binrelchain P (xs @ [x, x] @ ys) \\<Longrightarrow>\n    binrelchain P (xs @ x # ys)", "by (induct xs rule: list_induct_CCons) auto"], ["", "abbreviation \"proper_binrelchain P xs \\<equiv> binrelchain P xs \\<and> distinct xs\""], ["", "lemma binrelchain_obtain_proper:\n  \"x\\<noteq>y \\<Longrightarrow> binrelchain P (x#xs@[y]) \\<Longrightarrow>\n    \\<exists>zs. set zs \\<subseteq> set xs \\<and> length zs \\<le> length xs \\<and> proper_binrelchain P (x#zs@[y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; binrelchain P (x # xs @ [y])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set xs \\<and>\n                         length zs \\<le> length xs \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "proof (induct xs arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> y; binrelchain P (x # [] @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs.\n                            set zs \\<subseteq> set [] \\<and>\n                            length zs \\<le> length [] \\<and>\n                            proper_binrelchain P (x # zs @ [y])\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<noteq> y;\n                    binrelchain P (x # xs @ [y])\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>zs.\n  set zs \\<subseteq> set xs \\<and>\n  length zs \\<le> length xs \\<and> proper_binrelchain P (x # zs @ [y]);\n        x \\<noteq> y; binrelchain P (x # (a # xs) @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs.\n                            set zs \\<subseteq> set (a # xs) \\<and>\n                            length zs \\<le> length (a # xs) \\<and>\n                            proper_binrelchain P (x # zs @ [y])", "case (Cons w ws)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<noteq> y; binrelchain P (?x # ws @ [y])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>zs.\n                       set zs \\<subseteq> set ws \\<and>\n                       length zs \\<le> length ws \\<and>\n                       proper_binrelchain P (?x # zs @ [y])\n  x \\<noteq> y\n  binrelchain P (x # (w # ws) @ [y])\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> y; binrelchain P (x # [] @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs.\n                            set zs \\<subseteq> set [] \\<and>\n                            length zs \\<le> length [] \\<and>\n                            proper_binrelchain P (x # zs @ [y])\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<noteq> y;\n                    binrelchain P (x # xs @ [y])\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>zs.\n  set zs \\<subseteq> set xs \\<and>\n  length zs \\<le> length xs \\<and> proper_binrelchain P (x # zs @ [y]);\n        x \\<noteq> y; binrelchain P (x # (a # xs) @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs.\n                            set zs \\<subseteq> set (a # xs) \\<and>\n                            length zs \\<le> length (a # xs) \\<and>\n                            proper_binrelchain P (x # zs @ [y])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "proof (cases \"w=x\" \"w=y\" rule: two_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w = x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 4. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "case one"], ["proof (state)\nthis:\n  w = x\n  w \\<noteq> y\n\ngoal (4 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w = x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 4. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "from one(1) Cons(3)"], ["proof (chain)\npicking this:\n  w = x\n  binrelchain P (x # (w # ws) @ [y])", "have \"binrelchain P (x#ws@[y])\""], ["proof (prove)\nusing this:\n  w = x\n  binrelchain P (x # (w # ws) @ [y])\n\ngoal (1 subgoal):\n 1. binrelchain P (x # ws @ [y])", "using binrelchain_Cons_reduce"], ["proof (prove)\nusing this:\n  w = x\n  binrelchain P (x # (w # ws) @ [y])\n  binrelchain ?P (?x # ?xs) \\<Longrightarrow> binrelchain ?P ?xs\n\ngoal (1 subgoal):\n 1. binrelchain P (x # ws @ [y])", "by simp"], ["proof (state)\nthis:\n  binrelchain P (x # ws @ [y])\n\ngoal (4 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w = x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 4. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "with Cons(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<noteq> y; binrelchain P (?x # ws @ [y])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>zs.\n                       set zs \\<subseteq> set ws \\<and>\n                       length zs \\<le> length ws \\<and>\n                       proper_binrelchain P (?x # zs @ [y])\n  x \\<noteq> y\n  binrelchain P (x # ws @ [y])", "obtain zs\n      where \"set zs \\<subseteq> set ws\" \"length zs \\<le> length ws\" \"proper_binrelchain P (x#zs@[y])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<noteq> y; binrelchain P (?x # ws @ [y])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>zs.\n                       set zs \\<subseteq> set ws \\<and>\n                       length zs \\<le> length ws \\<and>\n                       proper_binrelchain P (?x # zs @ [y])\n  x \\<noteq> y\n  binrelchain P (x # ws @ [y])\n\ngoal (1 subgoal):\n 1. (\\<And>zs.\n        \\<lbrakk>set zs \\<subseteq> set ws; length zs \\<le> length ws;\n         proper_binrelchain P (x # zs @ [y])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  set zs \\<subseteq> set ws\n  length zs \\<le> length ws\n  proper_binrelchain P (x # zs @ [y])\n\ngoal (4 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w = x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 4. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "thus ?thesis"], ["proof (prove)\nusing this:\n  set zs \\<subseteq> set ws\n  length zs \\<le> length ws\n  proper_binrelchain P (x # zs @ [y])\n\ngoal (1 subgoal):\n 1. \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "by auto"], ["proof (state)\nthis:\n  \\<exists>zs.\n     set zs \\<subseteq> set (w # ws) \\<and>\n     length zs \\<le> length (w # ws) \\<and>\n     proper_binrelchain P (x # zs @ [y])\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "case other"], ["proof (state)\nthis:\n  w \\<noteq> x\n  w = y\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "with Cons(3)"], ["proof (chain)\npicking this:\n  binrelchain P (x # (w # ws) @ [y])\n  w \\<noteq> x\n  w = y", "have \"proper_binrelchain P (x#[]@[y])\""], ["proof (prove)\nusing this:\n  binrelchain P (x # (w # ws) @ [y])\n  w \\<noteq> x\n  w = y\n\ngoal (1 subgoal):\n 1. proper_binrelchain P (x # [] @ [y])", "using binrelchain_append_reduce1"], ["proof (prove)\nusing this:\n  binrelchain P (x # (w # ws) @ [y])\n  w \\<noteq> x\n  w = y\n  binrelchain ?P (?xs @ ?ys) \\<Longrightarrow> binrelchain ?P ?xs\n\ngoal (1 subgoal):\n 1. proper_binrelchain P (x # [] @ [y])", "by simp"], ["proof (state)\nthis:\n  proper_binrelchain P (x # [] @ [y])\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "moreover"], ["proof (state)\nthis:\n  proper_binrelchain P (x # [] @ [y])\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "have \"length [] \\<le> length (w#ws)\" \"set [] \\<subseteq> set (w#ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [] \\<le> length (w # ws) &&& set [] \\<subseteq> set (w # ws)", "by auto"], ["proof (state)\nthis:\n  length [] \\<le> length (w # ws)\n  set [] \\<subseteq> set (w # ws)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "ultimately"], ["proof (chain)\npicking this:\n  proper_binrelchain P (x # [] @ [y])\n  length [] \\<le> length (w # ws)\n  set [] \\<subseteq> set (w # ws)", "show ?thesis"], ["proof (prove)\nusing this:\n  proper_binrelchain P (x # [] @ [y])\n  length [] \\<le> length (w # ws)\n  set [] \\<subseteq> set (w # ws)\n\ngoal (1 subgoal):\n 1. \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "by blast"], ["proof (state)\nthis:\n  \\<exists>zs.\n     set zs \\<subseteq> set (w # ws) \\<and>\n     length zs \\<le> length (w # ws) \\<and>\n     proper_binrelchain P (x # zs @ [y])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "case neither"], ["proof (state)\nthis:\n  w \\<noteq> x\n  w \\<noteq> y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "from Cons(3)"], ["proof (chain)\npicking this:\n  binrelchain P (x # (w # ws) @ [y])", "have \"binrelchain P (w#ws@[y])\""], ["proof (prove)\nusing this:\n  binrelchain P (x # (w # ws) @ [y])\n\ngoal (1 subgoal):\n 1. binrelchain P (w # ws @ [y])", "using binrelchain_Cons_reduce"], ["proof (prove)\nusing this:\n  binrelchain P (x # (w # ws) @ [y])\n  binrelchain ?P (?x # ?xs) \\<Longrightarrow> binrelchain ?P ?xs\n\ngoal (1 subgoal):\n 1. binrelchain P (w # ws @ [y])", "by simp"], ["proof (state)\nthis:\n  binrelchain P (w # ws @ [y])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "with neither(2) Cons(1)"], ["proof (chain)\npicking this:\n  w \\<noteq> y\n  \\<lbrakk>?x \\<noteq> y; binrelchain P (?x # ws @ [y])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>zs.\n                       set zs \\<subseteq> set ws \\<and>\n                       length zs \\<le> length ws \\<and>\n                       proper_binrelchain P (?x # zs @ [y])\n  binrelchain P (w # ws @ [y])", "obtain zs \n      where zs: \"set zs \\<subseteq> set ws\" \"length zs \\<le> length ws\"\n                \"proper_binrelchain P (w#zs@[y])\""], ["proof (prove)\nusing this:\n  w \\<noteq> y\n  \\<lbrakk>?x \\<noteq> y; binrelchain P (?x # ws @ [y])\\<rbrakk>\n  \\<Longrightarrow> \\<exists>zs.\n                       set zs \\<subseteq> set ws \\<and>\n                       length zs \\<le> length ws \\<and>\n                       proper_binrelchain P (?x # zs @ [y])\n  binrelchain P (w # ws @ [y])\n\ngoal (1 subgoal):\n 1. (\\<And>zs.\n        \\<lbrakk>set zs \\<subseteq> set ws; length zs \\<le> length ws;\n         proper_binrelchain P (w # zs @ [y])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  set zs \\<subseteq> set ws\n  length zs \\<le> length ws\n  proper_binrelchain P (w # zs @ [y])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> x; w \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "proof (cases \"x\\<in>set zs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])\n 2. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "case True"], ["proof (state)\nthis:\n  x \\<in> set zs\n\ngoal (2 subgoals):\n 1. x \\<in> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])\n 2. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "from this"], ["proof (chain)\npicking this:\n  x \\<in> set zs", "obtain as bs where asbs: \"zs = as@x#bs\""], ["proof (prove)\nusing this:\n  x \\<in> set zs\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        zs = as @ x # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using in_set_conv_decomp[of x]"], ["proof (prove)\nusing this:\n  x \\<in> set zs\n  (x \\<in> set ?xs) = (\\<exists>ys zs. ?xs = ys @ x # zs)\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        zs = as @ x # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  zs = as @ x # bs\n\ngoal (2 subgoals):\n 1. x \\<in> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])\n 2. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "with zs(3)"], ["proof (chain)\npicking this:\n  proper_binrelchain P (w # zs @ [y])\n  zs = as @ x # bs", "have \"proper_binrelchain P (x#bs@[y])\""], ["proof (prove)\nusing this:\n  proper_binrelchain P (w # zs @ [y])\n  zs = as @ x # bs\n\ngoal (1 subgoal):\n 1. proper_binrelchain P (x # bs @ [y])", "using binrelchain_append_reduce2[of P \"w#as\"]"], ["proof (prove)\nusing this:\n  proper_binrelchain P (w # zs @ [y])\n  zs = as @ x # bs\n  binrelchain P ((w # as) @ ?ys) \\<Longrightarrow> binrelchain P ?ys\n\ngoal (1 subgoal):\n 1. proper_binrelchain P (x # bs @ [y])", "by auto"], ["proof (state)\nthis:\n  proper_binrelchain P (x # bs @ [y])\n\ngoal (2 subgoals):\n 1. x \\<in> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])\n 2. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "moreover"], ["proof (state)\nthis:\n  proper_binrelchain P (x # bs @ [y])\n\ngoal (2 subgoals):\n 1. x \\<in> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])\n 2. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "from zs(1) asbs"], ["proof (chain)\npicking this:\n  set zs \\<subseteq> set ws\n  zs = as @ x # bs", "have \"set bs \\<subseteq> set (w#ws)\""], ["proof (prove)\nusing this:\n  set zs \\<subseteq> set ws\n  zs = as @ x # bs\n\ngoal (1 subgoal):\n 1. set bs \\<subseteq> set (w # ws)", "by auto"], ["proof (state)\nthis:\n  set bs \\<subseteq> set (w # ws)\n\ngoal (2 subgoals):\n 1. x \\<in> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])\n 2. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "moreover"], ["proof (state)\nthis:\n  set bs \\<subseteq> set (w # ws)\n\ngoal (2 subgoals):\n 1. x \\<in> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])\n 2. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "from asbs zs(2)"], ["proof (chain)\npicking this:\n  zs = as @ x # bs\n  length zs \\<le> length ws", "have \"length bs \\<le> length (w#ws)\""], ["proof (prove)\nusing this:\n  zs = as @ x # bs\n  length zs \\<le> length ws\n\ngoal (1 subgoal):\n 1. length bs \\<le> length (w # ws)", "by simp"], ["proof (state)\nthis:\n  length bs \\<le> length (w # ws)\n\ngoal (2 subgoals):\n 1. x \\<in> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])\n 2. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "ultimately"], ["proof (chain)\npicking this:\n  proper_binrelchain P (x # bs @ [y])\n  set bs \\<subseteq> set (w # ws)\n  length bs \\<le> length (w # ws)", "show ?thesis"], ["proof (prove)\nusing this:\n  proper_binrelchain P (x # bs @ [y])\n  set bs \\<subseteq> set (w # ws)\n  length bs \\<le> length (w # ws)\n\ngoal (1 subgoal):\n 1. \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "by auto"], ["proof (state)\nthis:\n  \\<exists>zs.\n     set zs \\<subseteq> set (w # ws) \\<and>\n     length zs \\<le> length (w # ws) \\<and>\n     proper_binrelchain P (x # zs @ [y])\n\ngoal (1 subgoal):\n 1. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "case False"], ["proof (state)\nthis:\n  x \\<notin> set zs\n\ngoal (1 subgoal):\n 1. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "with zs(3) neither(1) Cons(2,3)"], ["proof (chain)\npicking this:\n  proper_binrelchain P (w # zs @ [y])\n  w \\<noteq> x\n  x \\<noteq> y\n  binrelchain P (x # (w # ws) @ [y])\n  x \\<notin> set zs", "have \"proper_binrelchain P (x#(w#zs)@[y])\""], ["proof (prove)\nusing this:\n  proper_binrelchain P (w # zs @ [y])\n  w \\<noteq> x\n  x \\<noteq> y\n  binrelchain P (x # (w # ws) @ [y])\n  x \\<notin> set zs\n\ngoal (1 subgoal):\n 1. proper_binrelchain P (x # (w # zs) @ [y])", "by simp"], ["proof (state)\nthis:\n  proper_binrelchain P (x # (w # zs) @ [y])\n\ngoal (1 subgoal):\n 1. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "moreover"], ["proof (state)\nthis:\n  proper_binrelchain P (x # (w # zs) @ [y])\n\ngoal (1 subgoal):\n 1. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "from zs(1)"], ["proof (chain)\npicking this:\n  set zs \\<subseteq> set ws", "have \"set (w#zs) \\<subseteq> set (w#ws)\""], ["proof (prove)\nusing this:\n  set zs \\<subseteq> set ws\n\ngoal (1 subgoal):\n 1. set (w # zs) \\<subseteq> set (w # ws)", "by auto"], ["proof (state)\nthis:\n  set (w # zs) \\<subseteq> set (w # ws)\n\ngoal (1 subgoal):\n 1. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "moreover"], ["proof (state)\nthis:\n  set (w # zs) \\<subseteq> set (w # ws)\n\ngoal (1 subgoal):\n 1. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "from zs(2)"], ["proof (chain)\npicking this:\n  length zs \\<le> length ws", "have \"length (w#zs) \\<le> length (w#ws)\""], ["proof (prove)\nusing this:\n  length zs \\<le> length ws\n\ngoal (1 subgoal):\n 1. length (w # zs) \\<le> length (w # ws)", "by simp"], ["proof (state)\nthis:\n  length (w # zs) \\<le> length (w # ws)\n\ngoal (1 subgoal):\n 1. x \\<notin> set zs \\<Longrightarrow>\n    \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "ultimately"], ["proof (chain)\npicking this:\n  proper_binrelchain P (x # (w # zs) @ [y])\n  set (w # zs) \\<subseteq> set (w # ws)\n  length (w # zs) \\<le> length (w # ws)", "show ?thesis"], ["proof (prove)\nusing this:\n  proper_binrelchain P (x # (w # zs) @ [y])\n  set (w # zs) \\<subseteq> set (w # ws)\n  length (w # zs) \\<le> length (w # ws)\n\ngoal (1 subgoal):\n 1. \\<exists>zs.\n       set zs \\<subseteq> set (w # ws) \\<and>\n       length zs \\<le> length (w # ws) \\<and>\n       proper_binrelchain P (x # zs @ [y])", "by blast"], ["proof (state)\nthis:\n  \\<exists>zs.\n     set zs \\<subseteq> set (w # ws) \\<and>\n     length zs \\<le> length (w # ws) \\<and>\n     proper_binrelchain P (x # zs @ [y])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>zs.\n     set zs \\<subseteq> set (w # ws) \\<and>\n     length zs \\<le> length (w # ws) \\<and>\n     proper_binrelchain P (x # zs @ [y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w = x; w = y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         set zs \\<subseteq> set (w # ws) \\<and>\n                         length zs \\<le> length (w # ws) \\<and>\n                         proper_binrelchain P (x # zs @ [y])", "qed (fastforce simp add: Cons(2))"], ["proof (state)\nthis:\n  \\<exists>zs.\n     set zs \\<subseteq> set (w # ws) \\<and>\n     length zs \\<le> length (w # ws) \\<and>\n     proper_binrelchain P (x # zs @ [y])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> y; binrelchain P (x # [] @ [y])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs.\n                            set zs \\<subseteq> set [] \\<and>\n                            length zs \\<le> length [] \\<and>\n                            proper_binrelchain P (x # zs @ [y])", "qed simp"], ["", "lemma binrelchain_trans_Cons_snoc:\n  assumes \"\\<And>x y z. P x y \\<Longrightarrow> P y z \\<Longrightarrow> P x z\"\n  shows   \"binrelchain P (x#xs@[y]) \\<Longrightarrow> P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binrelchain P (x # xs @ [y]) \\<Longrightarrow> P x y", "proof (induct xs arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. binrelchain P (x # [] @ [y]) \\<Longrightarrow> P x y\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   binrelchain P (x # xs @ [y]) \\<Longrightarrow> P x y;\n        binrelchain P (x # (a # xs) @ [y])\\<rbrakk>\n       \\<Longrightarrow> P x y", "case Cons"], ["proof (state)\nthis:\n  binrelchain P (?x # xs_ @ [y]) \\<Longrightarrow> P ?x y\n  binrelchain P (x # (a_ # xs_) @ [y])\n\ngoal (2 subgoals):\n 1. \\<And>x. binrelchain P (x # [] @ [y]) \\<Longrightarrow> P x y\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   binrelchain P (x # xs @ [y]) \\<Longrightarrow> P x y;\n        binrelchain P (x # (a # xs) @ [y])\\<rbrakk>\n       \\<Longrightarrow> P x y", "with assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>P ?x ?y; P ?y ?z\\<rbrakk> \\<Longrightarrow> P ?x ?z\n  binrelchain P (?x # xs_ @ [y]) \\<Longrightarrow> P ?x y\n  binrelchain P (x # (a_ # xs_) @ [y])", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?x ?y; P ?y ?z\\<rbrakk> \\<Longrightarrow> P ?x ?z\n  binrelchain P (?x # xs_ @ [y]) \\<Longrightarrow> P ?x y\n  binrelchain P (x # (a_ # xs_) @ [y])\n\ngoal (1 subgoal):\n 1. P x y", "using binrelchain_Cons_reduce"], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?x ?y; P ?y ?z\\<rbrakk> \\<Longrightarrow> P ?x ?z\n  binrelchain P (?x # xs_ @ [y]) \\<Longrightarrow> P ?x y\n  binrelchain P (x # (a_ # xs_) @ [y])\n  binrelchain ?P (?x # ?xs) \\<Longrightarrow> binrelchain ?P ?xs\n\ngoal (1 subgoal):\n 1. P x y", "by auto"], ["proof (state)\nthis:\n  P x y\n\ngoal (1 subgoal):\n 1. \\<And>x. binrelchain P (x # [] @ [y]) \\<Longrightarrow> P x y", "qed simp"], ["", "lemma binrelchain_cong:\n  assumes \"\\<And>x y. P x y \\<Longrightarrow> Q x y\"\n  shows   \"binrelchain P xs \\<Longrightarrow> binrelchain Q xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binrelchain P xs \\<Longrightarrow> binrelchain Q xs", "using   assms binrelchain_Cons_reduce"], ["proof (prove)\nusing this:\n  P ?x ?y \\<Longrightarrow> Q ?x ?y\n  binrelchain ?P (?x # ?xs) \\<Longrightarrow> binrelchain ?P ?xs\n\ngoal (1 subgoal):\n 1. binrelchain P xs \\<Longrightarrow> binrelchain Q xs", "by      (induct xs rule: list_induct_CCons) auto"], ["", "lemma binrelchain_funcong_Cons_snoc:\n  assumes \"\\<And>x y. P x y \\<Longrightarrow> f y = f x\" \"binrelchain P (x#xs@[y])\"\n  shows   \"f y = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f y = f x", "using   assms binrelchain_cong[of P]\n          binrelchain_trans_Cons_snoc[of \"\\<lambda>x y. f y = f x\" x xs y]"], ["proof (prove)\nusing this:\n  P ?x ?y \\<Longrightarrow> f ?y = f ?x\n  binrelchain P (x # xs @ [y])\n  \\<lbrakk>\\<And>x y. P x y \\<Longrightarrow> ?Q x y;\n   binrelchain P ?xs\\<rbrakk>\n  \\<Longrightarrow> binrelchain ?Q ?xs\n  \\<lbrakk>\\<And>x y z.\n              \\<lbrakk>f y = f x; f z = f y\\<rbrakk>\n              \\<Longrightarrow> f z = f x;\n   binrelchain (\\<lambda>x y. f y = f x) (x # xs @ [y])\\<rbrakk>\n  \\<Longrightarrow> f y = f x\n\ngoal (1 subgoal):\n 1. f y = f x", "by      auto"], ["", "lemma binrelchain_funcong_extra_condition_Cons_snoc:\n  assumes \"\\<And>x y. Q x \\<Longrightarrow> P x y \\<Longrightarrow> Q y\" \"\\<And>x y. Q x \\<Longrightarrow> P x y \\<Longrightarrow> f y = f x\"\n  shows   \"Q x \\<Longrightarrow> binrelchain P (x#zs@[y]) \\<Longrightarrow> f y = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q x; binrelchain P (x # zs @ [y])\\<rbrakk>\n    \\<Longrightarrow> f y = f x", "proof (induct zs arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Q x; binrelchain P (x # [] @ [y])\\<rbrakk>\n       \\<Longrightarrow> f y = f x\n 2. \\<And>a zs x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>Q x; binrelchain P (x # zs @ [y])\\<rbrakk>\n                   \\<Longrightarrow> f y = f x;\n        Q x; binrelchain P (x # (a # zs) @ [y])\\<rbrakk>\n       \\<Longrightarrow> f y = f x", "case (Cons z zs)"], ["proof (state)\nthis:\n  \\<lbrakk>Q ?x; binrelchain P (?x # zs @ [y])\\<rbrakk>\n  \\<Longrightarrow> f y = f ?x\n  Q x\n  binrelchain P (x # (z # zs) @ [y])\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Q x; binrelchain P (x # [] @ [y])\\<rbrakk>\n       \\<Longrightarrow> f y = f x\n 2. \\<And>a zs x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>Q x; binrelchain P (x # zs @ [y])\\<rbrakk>\n                   \\<Longrightarrow> f y = f x;\n        Q x; binrelchain P (x # (a # zs) @ [y])\\<rbrakk>\n       \\<Longrightarrow> f y = f x", "with assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>Q ?x; P ?x ?y\\<rbrakk> \\<Longrightarrow> Q ?y\n  \\<lbrakk>Q ?x; P ?x ?y\\<rbrakk> \\<Longrightarrow> f ?y = f ?x\n  \\<lbrakk>Q ?x; binrelchain P (?x # zs @ [y])\\<rbrakk>\n  \\<Longrightarrow> f y = f ?x\n  Q x\n  binrelchain P (x # (z # zs) @ [y])", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>Q ?x; P ?x ?y\\<rbrakk> \\<Longrightarrow> Q ?y\n  \\<lbrakk>Q ?x; P ?x ?y\\<rbrakk> \\<Longrightarrow> f ?y = f ?x\n  \\<lbrakk>Q ?x; binrelchain P (?x # zs @ [y])\\<rbrakk>\n  \\<Longrightarrow> f y = f ?x\n  Q x\n  binrelchain P (x # (z # zs) @ [y])\n\ngoal (1 subgoal):\n 1. f y = f x", "using binrelchain_Cons_reduce[of P x \"z#zs@[y]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Q ?x; P ?x ?y\\<rbrakk> \\<Longrightarrow> Q ?y\n  \\<lbrakk>Q ?x; P ?x ?y\\<rbrakk> \\<Longrightarrow> f ?y = f ?x\n  \\<lbrakk>Q ?x; binrelchain P (?x # zs @ [y])\\<rbrakk>\n  \\<Longrightarrow> f y = f ?x\n  Q x\n  binrelchain P (x # (z # zs) @ [y])\n  binrelchain P (x # z # zs @ [y]) \\<Longrightarrow>\n  binrelchain P (z # zs @ [y])\n\ngoal (1 subgoal):\n 1. f y = f x", "by fastforce"], ["proof (state)\nthis:\n  f y = f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Q x; binrelchain P (x # [] @ [y])\\<rbrakk>\n       \\<Longrightarrow> f y = f x", "qed (simp add: assms)"], ["", "lemma binrelchain_setfuncong_Cons_snoc:\n  \"\\<lbrakk> \\<forall>x\\<in>A. \\<forall>y. P x y \\<longrightarrow> y\\<in>A; \\<forall>x\\<in>A. \\<forall>y. P x y \\<longrightarrow> f y = f x; x\\<in>A;\n      binrelchain P (x#zs@[y]) \\<rbrakk> \\<Longrightarrow> f y = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>A.\n                \\<forall>y. P x y \\<longrightarrow> y \\<in> A;\n     \\<forall>x\\<in>A. \\<forall>y. P x y \\<longrightarrow> f y = f x;\n     x \\<in> A; binrelchain P (x # zs @ [y])\\<rbrakk>\n    \\<Longrightarrow> f y = f x", "using binrelchain_funcong_extra_condition_Cons_snoc[of \"\\<lambda>x. x\\<in>A\" P f x zs y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>x \\<in> A; P x y\\<rbrakk>\n              \\<Longrightarrow> y \\<in> A;\n   \\<And>x y.\n      \\<lbrakk>x \\<in> A; P x y\\<rbrakk> \\<Longrightarrow> f y = f x;\n   x \\<in> A; binrelchain P (x # zs @ [y])\\<rbrakk>\n  \\<Longrightarrow> f y = f x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>A.\n                \\<forall>y. P x y \\<longrightarrow> y \\<in> A;\n     \\<forall>x\\<in>A. \\<forall>y. P x y \\<longrightarrow> f y = f x;\n     x \\<in> A; binrelchain P (x # zs @ [y])\\<rbrakk>\n    \\<Longrightarrow> f y = f x", "by    fast"], ["", "lemma binrelchain_propcong_Cons_snoc:\n  assumes \"\\<And>x y. Q x \\<Longrightarrow> P x y \\<Longrightarrow> Q y\"\n  shows   \"Q x \\<Longrightarrow> binrelchain P (x#xs@[y]) \\<Longrightarrow> Q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q x; binrelchain P (x # xs @ [y])\\<rbrakk>\n    \\<Longrightarrow> Q y", "proof (induct xs arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Q x; binrelchain P (x # [] @ [y])\\<rbrakk>\n       \\<Longrightarrow> Q y\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>Q x; binrelchain P (x # xs @ [y])\\<rbrakk>\n                   \\<Longrightarrow> Q y;\n        Q x; binrelchain P (x # (a # xs) @ [y])\\<rbrakk>\n       \\<Longrightarrow> Q y", "case Cons"], ["proof (state)\nthis:\n  \\<lbrakk>Q ?x; binrelchain P (?x # xs_ @ [y])\\<rbrakk>\n  \\<Longrightarrow> Q y\n  Q x\n  binrelchain P (x # (a_ # xs_) @ [y])\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Q x; binrelchain P (x # [] @ [y])\\<rbrakk>\n       \\<Longrightarrow> Q y\n 2. \\<And>a xs x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>Q x; binrelchain P (x # xs @ [y])\\<rbrakk>\n                   \\<Longrightarrow> Q y;\n        Q x; binrelchain P (x # (a # xs) @ [y])\\<rbrakk>\n       \\<Longrightarrow> Q y", "with assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>Q ?x; P ?x ?y\\<rbrakk> \\<Longrightarrow> Q ?y\n  \\<lbrakk>Q ?x; binrelchain P (?x # xs_ @ [y])\\<rbrakk>\n  \\<Longrightarrow> Q y\n  Q x\n  binrelchain P (x # (a_ # xs_) @ [y])", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>Q ?x; P ?x ?y\\<rbrakk> \\<Longrightarrow> Q ?y\n  \\<lbrakk>Q ?x; binrelchain P (?x # xs_ @ [y])\\<rbrakk>\n  \\<Longrightarrow> Q y\n  Q x\n  binrelchain P (x # (a_ # xs_) @ [y])\n\ngoal (1 subgoal):\n 1. Q y", "using binrelchain_Cons_reduce"], ["proof (prove)\nusing this:\n  \\<lbrakk>Q ?x; P ?x ?y\\<rbrakk> \\<Longrightarrow> Q ?y\n  \\<lbrakk>Q ?x; binrelchain P (?x # xs_ @ [y])\\<rbrakk>\n  \\<Longrightarrow> Q y\n  Q x\n  binrelchain P (x # (a_ # xs_) @ [y])\n  binrelchain ?P (?x # ?xs) \\<Longrightarrow> binrelchain ?P ?xs\n\ngoal (1 subgoal):\n 1. Q y", "by auto"], ["proof (state)\nthis:\n  Q y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Q x; binrelchain P (x # [] @ [y])\\<rbrakk>\n       \\<Longrightarrow> Q y", "qed (simp add: assms)"], ["", "subsubsection \\<open>Set of subseqs\\<close>"], ["", "lemma subseqs_Cons: \"subseqs (x#xs) = map (Cons x) (subseqs xs) @ (subseqs xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseqs (x # xs) = map ((#) x) (subseqs xs) @ subseqs xs", "using cong_let[of \"subseqs xs\" \"\\<lambda>xss. map (Cons x) xss @ xss\"]"], ["proof (prove)\nusing this:\n  (let xa = subseqs xs in map ((#) x) xa @ xa) =\n  map ((#) x) (subseqs xs) @ subseqs xs\n\ngoal (1 subgoal):\n 1. subseqs (x # xs) = map ((#) x) (subseqs xs) @ subseqs xs", "by simp"], ["", "abbreviation \"ssubseqs xs \\<equiv> set (subseqs xs)\""], ["", "lemma nil_ssubseqs: \"[] \\<in> ssubseqs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> ssubseqs xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> ssubseqs []\n 2. \\<And>a xs.\n       [] \\<in> ssubseqs xs \\<Longrightarrow> [] \\<in> ssubseqs (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  [] \\<in> ssubseqs xs\n\ngoal (2 subgoals):\n 1. [] \\<in> ssubseqs []\n 2. \\<And>a xs.\n       [] \\<in> ssubseqs xs \\<Longrightarrow> [] \\<in> ssubseqs (a # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  [] \\<in> ssubseqs xs\n\ngoal (1 subgoal):\n 1. [] \\<in> ssubseqs (x # xs)", "using subseqs_Cons[of x]"], ["proof (prove)\nusing this:\n  [] \\<in> ssubseqs xs\n  subseqs (x # ?xs) = map ((#) x) (subseqs ?xs) @ subseqs ?xs\n\ngoal (1 subgoal):\n 1. [] \\<in> ssubseqs (x # xs)", "by simp"], ["proof (state)\nthis:\n  [] \\<in> ssubseqs (x # xs)\n\ngoal (1 subgoal):\n 1. [] \\<in> ssubseqs []", "qed simp"], ["", "lemma ssubseqs_Cons: \"ssubseqs (x#xs) = (Cons x) ` (ssubseqs xs) \\<union> ssubseqs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ssubseqs (x # xs) = (#) x ` ssubseqs xs \\<union> ssubseqs xs", "using subseqs_Cons[of x]"], ["proof (prove)\nusing this:\n  subseqs (x # ?xs) = map ((#) x) (subseqs ?xs) @ subseqs ?xs\n\ngoal (1 subgoal):\n 1. ssubseqs (x # xs) = (#) x ` ssubseqs xs \\<union> ssubseqs xs", "by simp"], ["", "lemma ssubseqs_refl: \"xs \\<in> ssubseqs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> ssubseqs xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> ssubseqs []\n 2. \\<And>a xs.\n       xs \\<in> ssubseqs xs \\<Longrightarrow> a # xs \\<in> ssubseqs (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  xs \\<in> ssubseqs xs\n\ngoal (2 subgoals):\n 1. [] \\<in> ssubseqs []\n 2. \\<And>a xs.\n       xs \\<in> ssubseqs xs \\<Longrightarrow> a # xs \\<in> ssubseqs (a # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  xs \\<in> ssubseqs xs\n\ngoal (1 subgoal):\n 1. x # xs \\<in> ssubseqs (x # xs)", "using ssubseqs_Cons"], ["proof (prove)\nusing this:\n  xs \\<in> ssubseqs xs\n  ssubseqs (?x # ?xs) = (#) ?x ` ssubseqs ?xs \\<union> ssubseqs ?xs\n\ngoal (1 subgoal):\n 1. x # xs \\<in> ssubseqs (x # xs)", "by fast"], ["proof (state)\nthis:\n  x # xs \\<in> ssubseqs (x # xs)\n\ngoal (1 subgoal):\n 1. [] \\<in> ssubseqs []", "qed (rule nil_ssubseqs)"], ["", "lemma ssubseqs_subset: \"as \\<in> ssubseqs bs \\<Longrightarrow> ssubseqs as \\<subseteq> ssubseqs bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<in> ssubseqs bs \\<Longrightarrow>\n    ssubseqs as \\<subseteq> ssubseqs bs", "proof (induct bs arbitrary: as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as.\n       as \\<in> ssubseqs [] \\<Longrightarrow>\n       ssubseqs as \\<subseteq> ssubseqs []\n 2. \\<And>a bs as.\n       \\<lbrakk>\\<And>as.\n                   as \\<in> ssubseqs bs \\<Longrightarrow>\n                   ssubseqs as \\<subseteq> ssubseqs bs;\n        as \\<in> ssubseqs (a # bs)\\<rbrakk>\n       \\<Longrightarrow> ssubseqs as \\<subseteq> ssubseqs (a # bs)", "case (Cons b bs)"], ["proof (state)\nthis:\n  ?as \\<in> ssubseqs bs \\<Longrightarrow>\n  ssubseqs ?as \\<subseteq> ssubseqs bs\n  as \\<in> ssubseqs (b # bs)\n\ngoal (2 subgoals):\n 1. \\<And>as.\n       as \\<in> ssubseqs [] \\<Longrightarrow>\n       ssubseqs as \\<subseteq> ssubseqs []\n 2. \\<And>a bs as.\n       \\<lbrakk>\\<And>as.\n                   as \\<in> ssubseqs bs \\<Longrightarrow>\n                   ssubseqs as \\<subseteq> ssubseqs bs;\n        as \\<in> ssubseqs (a # bs)\\<rbrakk>\n       \\<Longrightarrow> ssubseqs as \\<subseteq> ssubseqs (a # bs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ssubseqs as \\<subseteq> ssubseqs (b # bs)", "proof (cases \"as \\<in> set (subseqs bs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as \\<in> ssubseqs bs \\<Longrightarrow>\n    ssubseqs as \\<subseteq> ssubseqs (b # bs)\n 2. as \\<notin> ssubseqs bs \\<Longrightarrow>\n    ssubseqs as \\<subseteq> ssubseqs (b # bs)", "case True"], ["proof (state)\nthis:\n  as \\<in> ssubseqs bs\n\ngoal (2 subgoals):\n 1. as \\<in> ssubseqs bs \\<Longrightarrow>\n    ssubseqs as \\<subseteq> ssubseqs (b # bs)\n 2. as \\<notin> ssubseqs bs \\<Longrightarrow>\n    ssubseqs as \\<subseteq> ssubseqs (b # bs)", "with Cons"], ["proof (chain)\npicking this:\n  ?as \\<in> ssubseqs bs \\<Longrightarrow>\n  ssubseqs ?as \\<subseteq> ssubseqs bs\n  as \\<in> ssubseqs (b # bs)\n  as \\<in> ssubseqs bs", "show ?thesis"], ["proof (prove)\nusing this:\n  ?as \\<in> ssubseqs bs \\<Longrightarrow>\n  ssubseqs ?as \\<subseteq> ssubseqs bs\n  as \\<in> ssubseqs (b # bs)\n  as \\<in> ssubseqs bs\n\ngoal (1 subgoal):\n 1. ssubseqs as \\<subseteq> ssubseqs (b # bs)", "using ssubseqs_Cons"], ["proof (prove)\nusing this:\n  ?as \\<in> ssubseqs bs \\<Longrightarrow>\n  ssubseqs ?as \\<subseteq> ssubseqs bs\n  as \\<in> ssubseqs (b # bs)\n  as \\<in> ssubseqs bs\n  ssubseqs (?x # ?xs) = (#) ?x ` ssubseqs ?xs \\<union> ssubseqs ?xs\n\ngoal (1 subgoal):\n 1. ssubseqs as \\<subseteq> ssubseqs (b # bs)", "by fastforce"], ["proof (state)\nthis:\n  ssubseqs as \\<subseteq> ssubseqs (b # bs)\n\ngoal (1 subgoal):\n 1. as \\<notin> ssubseqs bs \\<Longrightarrow>\n    ssubseqs as \\<subseteq> ssubseqs (b # bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<notin> ssubseqs bs \\<Longrightarrow>\n    ssubseqs as \\<subseteq> ssubseqs (b # bs)", "case False"], ["proof (state)\nthis:\n  as \\<notin> ssubseqs bs\n\ngoal (1 subgoal):\n 1. as \\<notin> ssubseqs bs \\<Longrightarrow>\n    ssubseqs as \\<subseteq> ssubseqs (b # bs)", "with Cons"], ["proof (chain)\npicking this:\n  ?as \\<in> ssubseqs bs \\<Longrightarrow>\n  ssubseqs ?as \\<subseteq> ssubseqs bs\n  as \\<in> ssubseqs (b # bs)\n  as \\<notin> ssubseqs bs", "show ?thesis"], ["proof (prove)\nusing this:\n  ?as \\<in> ssubseqs bs \\<Longrightarrow>\n  ssubseqs ?as \\<subseteq> ssubseqs bs\n  as \\<in> ssubseqs (b # bs)\n  as \\<notin> ssubseqs bs\n\ngoal (1 subgoal):\n 1. ssubseqs as \\<subseteq> ssubseqs (b # bs)", "using nil_ssubseqs[of \"b#bs\"] ssubseqs_Cons[of \"hd as\"] ssubseqs_Cons[of b]"], ["proof (prove)\nusing this:\n  ?as \\<in> ssubseqs bs \\<Longrightarrow>\n  ssubseqs ?as \\<subseteq> ssubseqs bs\n  as \\<in> ssubseqs (b # bs)\n  as \\<notin> ssubseqs bs\n  [] \\<in> ssubseqs (b # bs)\n  ssubseqs (hd as # ?xs) = (#) (hd as) ` ssubseqs ?xs \\<union> ssubseqs ?xs\n  ssubseqs (b # ?xs) = (#) b ` ssubseqs ?xs \\<union> ssubseqs ?xs\n\ngoal (1 subgoal):\n 1. ssubseqs as \\<subseteq> ssubseqs (b # bs)", "by    (cases as) auto"], ["proof (state)\nthis:\n  ssubseqs as \\<subseteq> ssubseqs (b # bs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ssubseqs as \\<subseteq> ssubseqs (b # bs)\n\ngoal (1 subgoal):\n 1. \\<And>as.\n       as \\<in> ssubseqs [] \\<Longrightarrow>\n       ssubseqs as \\<subseteq> ssubseqs []", "qed simp"], ["", "lemma ssubseqs_lists:\n  \"as \\<in> lists A \\<Longrightarrow> bs \\<in> ssubseqs as \\<Longrightarrow> bs \\<in> lists A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<in> lists A; bs \\<in> ssubseqs as\\<rbrakk>\n    \\<Longrightarrow> bs \\<in> lists A", "proof (induct as arbitrary: bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       \\<lbrakk>[] \\<in> lists A; bs \\<in> ssubseqs []\\<rbrakk>\n       \\<Longrightarrow> bs \\<in> lists A\n 2. \\<And>a as bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>as \\<in> lists A; bs \\<in> ssubseqs as\\<rbrakk>\n                   \\<Longrightarrow> bs \\<in> lists A;\n        a # as \\<in> lists A; bs \\<in> ssubseqs (a # as)\\<rbrakk>\n       \\<Longrightarrow> bs \\<in> lists A", "case (Cons a as)"], ["proof (state)\nthis:\n  \\<lbrakk>as \\<in> lists A; ?bs \\<in> ssubseqs as\\<rbrakk>\n  \\<Longrightarrow> ?bs \\<in> lists A\n  a # as \\<in> lists A\n  bs \\<in> ssubseqs (a # as)\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       \\<lbrakk>[] \\<in> lists A; bs \\<in> ssubseqs []\\<rbrakk>\n       \\<Longrightarrow> bs \\<in> lists A\n 2. \\<And>a as bs.\n       \\<lbrakk>\\<And>bs.\n                   \\<lbrakk>as \\<in> lists A; bs \\<in> ssubseqs as\\<rbrakk>\n                   \\<Longrightarrow> bs \\<in> lists A;\n        a # as \\<in> lists A; bs \\<in> ssubseqs (a # as)\\<rbrakk>\n       \\<Longrightarrow> bs \\<in> lists A", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>as \\<in> lists A; ?bs \\<in> ssubseqs as\\<rbrakk>\n  \\<Longrightarrow> ?bs \\<in> lists A\n  a # as \\<in> lists A\n  bs \\<in> ssubseqs (a # as)\n\ngoal (1 subgoal):\n 1. bs \\<in> lists A", "using ssubseqs_Cons[of a]"], ["proof (prove)\nusing this:\n  \\<lbrakk>as \\<in> lists A; ?bs \\<in> ssubseqs as\\<rbrakk>\n  \\<Longrightarrow> ?bs \\<in> lists A\n  a # as \\<in> lists A\n  bs \\<in> ssubseqs (a # as)\n  ssubseqs (a # ?xs) = (#) a ` ssubseqs ?xs \\<union> ssubseqs ?xs\n\ngoal (1 subgoal):\n 1. bs \\<in> lists A", "by fastforce"], ["proof (state)\nthis:\n  bs \\<in> lists A\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       \\<lbrakk>[] \\<in> lists A; bs \\<in> ssubseqs []\\<rbrakk>\n       \\<Longrightarrow> bs \\<in> lists A", "qed simp"], ["", "lemma delete1_ssubseqs:\n  \"as@bs \\<in> ssubseqs (as@[a]@bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as @ bs \\<in> ssubseqs (as @ [a] @ bs)", "proof (induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] @ bs \\<in> ssubseqs ([] @ [a] @ bs)\n 2. \\<And>aa as.\n       as @ bs \\<in> ssubseqs (as @ [a] @ bs) \\<Longrightarrow>\n       (aa # as) @ bs \\<in> ssubseqs ((aa # as) @ [a] @ bs)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] @ bs \\<in> ssubseqs ([] @ [a] @ bs)\n 2. \\<And>aa as.\n       as @ bs \\<in> ssubseqs (as @ [a] @ bs) \\<Longrightarrow>\n       (aa # as) @ bs \\<in> ssubseqs ((aa # as) @ [a] @ bs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] @ bs \\<in> ssubseqs ([] @ [a] @ bs)", "using ssubseqs_refl ssubseqs_Cons[of a bs]"], ["proof (prove)\nusing this:\n  ?xs \\<in> ssubseqs ?xs\n  ssubseqs (a # bs) = (#) a ` ssubseqs bs \\<union> ssubseqs bs\n\ngoal (1 subgoal):\n 1. [] @ bs \\<in> ssubseqs ([] @ [a] @ bs)", "by auto"], ["proof (state)\nthis:\n  [] @ bs \\<in> ssubseqs ([] @ [a] @ bs)\n\ngoal (1 subgoal):\n 1. \\<And>aa as.\n       as @ bs \\<in> ssubseqs (as @ [a] @ bs) \\<Longrightarrow>\n       (aa # as) @ bs \\<in> ssubseqs ((aa # as) @ [a] @ bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa as.\n       as @ bs \\<in> ssubseqs (as @ [a] @ bs) \\<Longrightarrow>\n       (aa # as) @ bs \\<in> ssubseqs ((aa # as) @ [a] @ bs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  xs @ bs \\<in> ssubseqs (xs @ [a] @ bs)\n\ngoal (1 subgoal):\n 1. \\<And>aa as.\n       as @ bs \\<in> ssubseqs (as @ [a] @ bs) \\<Longrightarrow>\n       (aa # as) @ bs \\<in> ssubseqs ((aa # as) @ [a] @ bs)", "thus ?case"], ["proof (prove)\nusing this:\n  xs @ bs \\<in> ssubseqs (xs @ [a] @ bs)\n\ngoal (1 subgoal):\n 1. (x # xs) @ bs \\<in> ssubseqs ((x # xs) @ [a] @ bs)", "using ssubseqs_Cons[of x]"], ["proof (prove)\nusing this:\n  xs @ bs \\<in> ssubseqs (xs @ [a] @ bs)\n  ssubseqs (x # ?xs) = (#) x ` ssubseqs ?xs \\<union> ssubseqs ?xs\n\ngoal (1 subgoal):\n 1. (x # xs) @ bs \\<in> ssubseqs ((x # xs) @ [a] @ bs)", "by simp"], ["proof (state)\nthis:\n  (x # xs) @ bs \\<in> ssubseqs ((x # xs) @ [a] @ bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete2_ssubseqs:\n  \"as@bs@cs \\<in> ssubseqs (as@[a]@bs@[b]@cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as @ bs @ cs \\<in> ssubseqs (as @ [a] @ bs @ [b] @ cs)", "using delete1_ssubseqs[of \"as@[a]@bs\"] delete1_ssubseqs ssubseqs_subset"], ["proof (prove)\nusing this:\n  (as @ [a] @ bs) @ ?bs \\<in> ssubseqs ((as @ [a] @ bs) @ [?a] @ ?bs)\n  ?as @ ?bs \\<in> ssubseqs (?as @ [?a] @ ?bs)\n  ?as \\<in> ssubseqs ?bs \\<Longrightarrow>\n  ssubseqs ?as \\<subseteq> ssubseqs ?bs\n\ngoal (1 subgoal):\n 1. as @ bs @ cs \\<in> ssubseqs (as @ [a] @ bs @ [b] @ cs)", "by    fastforce"], ["", "subsection \\<open>Orders and posets\\<close>"], ["", "text \\<open>\n  We have chosen to work with the @{const ordering} locale instead of the @{class order} class to\n  more easily facilitate simultaneously working with both an order and its dual.\n\\<close>"], ["", "subsubsection \\<open>Dual ordering\\<close>"], ["", "context ordering\nbegin"], ["", "abbreviation greater_eq  :: \"'a\\<Rightarrow>'a\\<Rightarrow>bool\" (infix \"\\<succeq>\" 50)\n  where \"greater_eq a b \\<equiv> less_eq b a\""], ["", "abbreviation greater  :: \"'a\\<Rightarrow>'a\\<Rightarrow>bool\" (infix \"\\<succ>\" 50)\n  where \"greater a b \\<equiv> less b a\""], ["", "lemma dual: \"ordering greater_eq greater\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordering (\\<succeq>) (\\<succ>)", "using strict_iff_order refl antisym trans"], ["proof (prove)\nusing this:\n  (?b \\<succ> ?a) = (?b \\<succeq> ?a \\<and> ?a \\<noteq> ?b)\n  ?a \\<succeq> ?a\n  \\<lbrakk>?b \\<succeq> ?a; ?a \\<succeq> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n  \\<lbrakk>?b \\<succeq> ?a; ?c \\<succeq> ?b\\<rbrakk>\n  \\<Longrightarrow> ?c \\<succeq> ?a\n\ngoal (1 subgoal):\n 1. ordering (\\<succeq>) (\\<succ>)", "by unfold_locales fastforce"], ["", "end"], ["", "(* context ordering *)"], ["", "subsubsection \\<open>Morphisms of posets\\<close>"], ["", "locale OrderingSetMap =\n  domain  : ordering less_eq less\n+ codomain: ordering less_eq' less' \n  for less_eq  :: \"'a\\<Rightarrow>'a\\<Rightarrow>bool\" (infix \"\\<^bold>\\<le>\"  50)\n  and less     :: \"'a\\<Rightarrow>'a\\<Rightarrow>bool\" (infix \"\\<^bold><\"  50)\n  and less_eq' :: \"'b\\<Rightarrow>'b\\<Rightarrow>bool\" (infix \"\\<^bold>\\<le>*\" 50)\n  and less'    :: \"'b\\<Rightarrow>'b\\<Rightarrow>bool\" (infix \"\\<^bold><*\" 50)\n+ fixes P :: \"'a set\"\n  and   f :: \"'a\\<Rightarrow>'b\"\n  assumes ordsetmap: \"a\\<in>P \\<Longrightarrow> b\\<in>P \\<Longrightarrow> a \\<^bold>\\<le> b \\<Longrightarrow> f a \\<^bold>\\<le>* f b\"\nbegin"], ["", "lemma comp:\n  assumes \"OrderingSetMap less_eq' less' less_eq'' less'' Q g\" \"f`P \\<subseteq> Q\"\n  shows   \"OrderingSetMap less_eq less less_eq'' less'' P (g\\<circ>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) less_eq'' less'' P\n     (g \\<circ> f)", "proof (\n  intro_locales, rule OrderingSetMap.axioms(2), rule assms(1), unfold_locales\n)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P; b \\<succeq> a\\<rbrakk>\n       \\<Longrightarrow> less_eq'' ((g \\<circ> f) a) ((g \\<circ> f) b)", "from assms(2)"], ["proof (chain)\npicking this:\n  order.greater_eq Q (f ` P)", "show  \"\\<And>a b. a \\<in> P \\<Longrightarrow> b \\<in> P \\<Longrightarrow> a \\<^bold>\\<le> b \\<Longrightarrow> less_eq'' ((g \\<circ> f) a) ((g \\<circ> f) b)\""], ["proof (prove)\nusing this:\n  order.greater_eq Q (f ` P)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P; b \\<succeq> a\\<rbrakk>\n       \\<Longrightarrow> less_eq'' ((g \\<circ> f) a) ((g \\<circ> f) b)", "using ordsetmap OrderingSetMap.ordsetmap[OF assms(1)]"], ["proof (prove)\nusing this:\n  order.greater_eq Q (f ` P)\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P; ?b \\<succeq> ?a\\<rbrakk>\n  \\<Longrightarrow> codomain.greater_eq (f ?b) (f ?a)\n  \\<lbrakk>?a \\<in> Q; ?b \\<in> Q; codomain.greater_eq ?b ?a\\<rbrakk>\n  \\<Longrightarrow> less_eq'' (g ?a) (g ?b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P; b \\<succeq> a\\<rbrakk>\n       \\<Longrightarrow> less_eq'' ((g \\<circ> f) a) ((g \\<circ> f) b)", "by    force"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P; ?b \\<succeq> ?a\\<rbrakk>\n  \\<Longrightarrow> less_eq'' ((g \\<circ> f) ?a) ((g \\<circ> f) ?b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subset: \"Q\\<subseteq>P \\<Longrightarrow> OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) (\\<^bold>\\<le>*) (\\<^bold><*) Q f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq P Q \\<Longrightarrow>\n    OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) (\\<^bold>\\<le>*) (\\<^bold><*)\n     Q f", "using ordsetmap"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P; ?b \\<succeq> ?a\\<rbrakk>\n  \\<Longrightarrow> codomain.greater_eq (f ?b) (f ?a)\n\ngoal (1 subgoal):\n 1. order.greater_eq P Q \\<Longrightarrow>\n    OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) (\\<^bold>\\<le>*) (\\<^bold><*)\n     Q f", "by unfold_locales fast"], ["", "lemma dual:\n  \"OrderingSetMap domain.greater_eq domain.greater\n    codomain.greater_eq codomain.greater P f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetMap (\\<succeq>) (\\<succ>) codomain.greater_eq\n     codomain.greater P f", "proof (intro_locales, rule domain.dual, rule codomain.dual, unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P; a \\<succeq> b\\<rbrakk>\n       \\<Longrightarrow> codomain.greater_eq (f a) (f b)", "from ordsetmap"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P; ?b \\<succeq> ?a\\<rbrakk>\n  \\<Longrightarrow> codomain.greater_eq (f ?b) (f ?a)", "show \"\\<And>a b. a\\<in>P \\<Longrightarrow> b\\<in>P \\<Longrightarrow> a\\<succeq>b \\<Longrightarrow> f b \\<^bold>\\<le>* f a\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P; ?b \\<succeq> ?a\\<rbrakk>\n  \\<Longrightarrow> codomain.greater_eq (f ?b) (f ?a)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P; a \\<succeq> b\\<rbrakk>\n       \\<Longrightarrow> codomain.greater_eq (f a) (f b)", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P; ?a \\<succeq> ?b\\<rbrakk>\n  \\<Longrightarrow> codomain.greater_eq (f ?a) (f ?b)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context OrderingSetMap *)"], ["", "locale OrderingSetIso = OrderingSetMap less_eq less less_eq' less' P f\n  for less_eq  :: \"'a\\<Rightarrow>'a\\<Rightarrow>bool\" (infix \"\\<^bold>\\<le>\"  50)\n  and less     :: \"'a\\<Rightarrow>'a\\<Rightarrow>bool\" (infix \"\\<^bold><\"  50)\n  and less_eq' :: \"'b\\<Rightarrow>'b\\<Rightarrow>bool\" (infix \"\\<^bold>\\<le>*\" 50)\n  and less'    :: \"'b\\<Rightarrow>'b\\<Rightarrow>bool\" (infix \"\\<^bold><*\" 50)\n  and P :: \"'a set\"\n  and f :: \"'a\\<Rightarrow>'b\"\n+ assumes inj               : \"inj_on f P\"\n  and     rev_OrderingSetMap:\n    \"OrderingSetMap less_eq' less' less_eq less (f`P) (the_inv_into P f)\""], ["", "abbreviation \"subset_ordering_iso \\<equiv> OrderingSetIso (\\<subseteq>) (\\<subset>) (\\<subseteq>) (\\<subset>)\""], ["", "lemma (in OrderingSetMap) isoI:\n  assumes \"inj_on f P\" \"\\<And>a b. a\\<in>P \\<Longrightarrow> b\\<in>P \\<Longrightarrow> f a \\<^bold>\\<le>* f b \\<Longrightarrow> a \\<^bold>\\<le> b\"\n  shows   \"OrderingSetIso less_eq less less_eq' less' P f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) (\\<^bold>\\<le>*) (\\<^bold><*)\n     P f", "using   assms the_inv_into_f_f[OF assms(1)]"], ["proof (prove)\nusing this:\n  inj_on f P\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P;\n   codomain.greater_eq (f ?b) (f ?a)\\<rbrakk>\n  \\<Longrightarrow> ?b \\<succeq> ?a\n  ?x \\<in> P \\<Longrightarrow> the_inv_into P f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) (\\<^bold>\\<le>*) (\\<^bold><*)\n     P f", "by      unfold_locales auto"], ["", "lemma OrderingSetIsoI_orders_greater2less:\n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  assumes \"inj_on f P\" \"\\<And>a b. a \\<in> P \\<Longrightarrow> b \\<in> P \\<Longrightarrow> (b\\<le>a) = (f a \\<le> f b)\"\n  shows   \"OrderingSetIso (greater_eq::'a\\<Rightarrow>'a\\<Rightarrow>bool) (greater::'a\\<Rightarrow>'a\\<Rightarrow>bool)\n            (less_eq::'b\\<Rightarrow>'b\\<Rightarrow>bool) (less::'b\\<Rightarrow>'b\\<Rightarrow>bool) P f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetIso order.greater_eq order.greater dual_order.greater_eq\n     dual_order.greater P f", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P; order.greater_eq a b\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (f b) (f a)\n 2. inj_on f P\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> f ` P; b \\<in> f ` P; order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into P f a)\n                          (the_inv_into P f b)", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq ?a ?b = order.greater_eq (f ?b) (f ?a)", "show \"\\<And>a b. a \\<in> P \\<Longrightarrow> b \\<in> P \\<Longrightarrow> b\\<le>a \\<Longrightarrow> f a \\<le> f b\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq ?a ?b = order.greater_eq (f ?b) (f ?a)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P; order.greater_eq a b\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (f b) (f a)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P; order.greater_eq ?a ?b\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (f ?b) (f ?a)\n\ngoal (2 subgoals):\n 1. inj_on f P\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> f ` P; b \\<in> f ` P; order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into P f a)\n                          (the_inv_into P f b)", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq ?a ?b = order.greater_eq (f ?b) (f ?a)", "show  \"\\<And>a b. a \\<in> f ` P \\<Longrightarrow> b \\<in> f ` P \\<Longrightarrow> b\\<le>a \\<Longrightarrow>\n            the_inv_into P f a \\<le> the_inv_into P f b\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq ?a ?b = order.greater_eq (f ?b) (f ?a)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> f ` P; b \\<in> f ` P; order.greater_eq a b\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into P f b)\n                          (the_inv_into P f a)", "using the_inv_into_f_f[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq ?a ?b = order.greater_eq (f ?b) (f ?a)\n  ?x \\<in> P \\<Longrightarrow> the_inv_into P f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> f ` P; b \\<in> f ` P; order.greater_eq a b\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into P f b)\n                          (the_inv_into P f a)", "by    force"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> f ` P; ?b \\<in> f ` P; order.greater_eq ?a ?b\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (the_inv_into P f ?b)\n                     (the_inv_into P f ?a)\n\ngoal (1 subgoal):\n 1. inj_on f P", "qed (rule assms(1))"], ["", "context OrderingSetIso\nbegin"], ["", "lemmas ordsetmap = ordsetmap"], ["", "lemma ordsetmap_strict: \"\\<lbrakk> a\\<in>P; b\\<in>P; a\\<^bold><b \\<rbrakk> \\<Longrightarrow> f a \\<^bold><* f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> P; b \\<in> P; b \\<succ> a\\<rbrakk>\n    \\<Longrightarrow> codomain.greater (f b) (f a)", "using domain.strict_iff_order codomain.strict_iff_order ordsetmap inj\n        inj_on_contraD"], ["proof (prove)\nusing this:\n  (?b \\<succ> ?a) = (?b \\<succeq> ?a \\<and> ?a \\<noteq> ?b)\n  codomain.greater ?b ?a = (codomain.greater_eq ?b ?a \\<and> ?a \\<noteq> ?b)\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P; ?b \\<succeq> ?a\\<rbrakk>\n  \\<Longrightarrow> codomain.greater_eq (f ?b) (f ?a)\n  inj_on f P\n  \\<lbrakk>inj_on ?f ?A; ?x \\<noteq> ?y; ?x \\<in> ?A; ?y \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f ?x \\<noteq> ?f ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> P; b \\<in> P; b \\<succ> a\\<rbrakk>\n    \\<Longrightarrow> codomain.greater (f b) (f a)", "by    fastforce"], ["", "lemmas inv_ordsetmap = OrderingSetMap.ordsetmap[OF rev_OrderingSetMap]"], ["", "lemma rev_ordsetmap: \"\\<lbrakk> a\\<in>P; b\\<in>P; f a \\<^bold>\\<le>* f b \\<rbrakk> \\<Longrightarrow> a \\<^bold>\\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> P; b \\<in> P; codomain.greater_eq (f b) (f a)\\<rbrakk>\n    \\<Longrightarrow> b \\<succeq> a", "using inv_ordsetmap the_inv_into_f_f[OF inj]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> f ` P; ?b \\<in> f ` P;\n   codomain.greater_eq ?b ?a\\<rbrakk>\n  \\<Longrightarrow> the_inv_into P f ?b \\<succeq> the_inv_into P f ?a\n  ?x \\<in> P \\<Longrightarrow> the_inv_into P f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> P; b \\<in> P; codomain.greater_eq (f b) (f a)\\<rbrakk>\n    \\<Longrightarrow> b \\<succeq> a", "by fastforce"], ["", "lemma inv_iso: \"OrderingSetIso less_eq' less' less_eq less (f`P) (the_inv_into P f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) (\\<^bold>\\<le>) (\\<^bold><)\n     (f ` P) (the_inv_into P f)", "using inv_ordsetmap inj_on_the_inv_into[OF inj] the_inv_into_onto[OF inj]\n        ordsetmap the_inv_into_the_inv_into[OF inj]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> f ` P; ?b \\<in> f ` P;\n   codomain.greater_eq ?b ?a\\<rbrakk>\n  \\<Longrightarrow> the_inv_into P f ?b \\<succeq> the_inv_into P f ?a\n  inj_on (the_inv_into P f) (f ` P)\n  the_inv_into P f ` f ` P = P\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P; ?b \\<succeq> ?a\\<rbrakk>\n  \\<Longrightarrow> codomain.greater_eq (f ?b) (f ?a)\n  ?a \\<in> P \\<Longrightarrow>\n  the_inv_into (f ` P) (the_inv_into P f) ?a = f ?a\n\ngoal (1 subgoal):\n 1. OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) (\\<^bold>\\<le>) (\\<^bold><)\n     (f ` P) (the_inv_into P f)", "by    unfold_locales auto"], ["", "lemmas inv_ordsetmap_strict = OrderingSetIso.ordsetmap_strict[OF inv_iso]"], ["", "lemma rev_ordsetmap_strict: \"\\<lbrakk> a\\<in>P; b\\<in>P; f a \\<^bold><* f b \\<rbrakk> \\<Longrightarrow> a \\<^bold>< b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> P; b \\<in> P; codomain.greater (f b) (f a)\\<rbrakk>\n    \\<Longrightarrow> b \\<succ> a", "using inv_ordsetmap_strict the_inv_into_f_f[OF inj]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> f ` P; ?b \\<in> f ` P; codomain.greater ?b ?a\\<rbrakk>\n  \\<Longrightarrow> the_inv_into P f ?b \\<succ> the_inv_into P f ?a\n  ?x \\<in> P \\<Longrightarrow> the_inv_into P f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> P; b \\<in> P; codomain.greater (f b) (f a)\\<rbrakk>\n    \\<Longrightarrow> b \\<succ> a", "by fastforce"], ["", "lemma iso_comp:\n  assumes \"OrderingSetIso less_eq' less' less_eq'' less'' Q g\" \"f`P \\<subseteq> Q\"\n  shows   \"OrderingSetIso less_eq less less_eq'' less'' P (g\\<circ>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) less_eq'' less'' P\n     (g \\<circ> f)", "proof (rule OrderingSetMap.isoI)"], ["proof (state)\ngoal (3 subgoals):\n 1. OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) less_eq'' less'' P\n     (g \\<circ> f)\n 2. inj_on (g \\<circ> f) P\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P;\n        less_eq'' ((g \\<circ> f) a) ((g \\<circ> f) b)\\<rbrakk>\n       \\<Longrightarrow> b \\<succeq> a", "from assms"], ["proof (chain)\npicking this:\n  OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) less_eq'' less'' Q g\n  order.greater_eq Q (f ` P)", "show \"OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) less_eq'' less'' P (g \\<circ> f)\""], ["proof (prove)\nusing this:\n  OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) less_eq'' less'' Q g\n  order.greater_eq Q (f ` P)\n\ngoal (1 subgoal):\n 1. OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) less_eq'' less'' P\n     (g \\<circ> f)", "using OrderingSetIso.axioms(1) comp"], ["proof (prove)\nusing this:\n  OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) less_eq'' less'' Q g\n  order.greater_eq Q (f ` P)\n  OrderingSetIso ?less_eq ?less ?less_eq' ?less' ?P ?f \\<Longrightarrow>\n  OrderingSetMap ?less_eq ?less ?less_eq' ?less' ?P ?f\n  \\<lbrakk>OrderingSetMap (\\<^bold>\\<le>*) (\\<^bold><*) ?less_eq'' ?less''\n            ?Q ?g;\n   order.greater_eq ?Q (f ` P)\\<rbrakk>\n  \\<Longrightarrow> OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) ?less_eq''\n                     ?less'' P (?g \\<circ> f)\n\ngoal (1 subgoal):\n 1. OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) less_eq'' less'' P\n     (g \\<circ> f)", "by fast"], ["proof (state)\nthis:\n  OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) less_eq'' less'' P\n   (g \\<circ> f)\n\ngoal (2 subgoals):\n 1. inj_on (g \\<circ> f) P\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P;\n        less_eq'' ((g \\<circ> f) a) ((g \\<circ> f) b)\\<rbrakk>\n       \\<Longrightarrow> b \\<succeq> a", "from assms(2)"], ["proof (chain)\npicking this:\n  order.greater_eq Q (f ` P)", "show \"inj_on (g \\<circ> f) P\""], ["proof (prove)\nusing this:\n  order.greater_eq Q (f ` P)\n\ngoal (1 subgoal):\n 1. inj_on (g \\<circ> f) P", "using OrderingSetIso.inj[OF assms(1)]\n          comp_inj_on[OF inj, OF subset_inj_on]"], ["proof (prove)\nusing this:\n  order.greater_eq Q (f ` P)\n  inj_on g Q\n  \\<lbrakk>inj_on ?g ?B1; order.greater_eq ?B1 (f ` P)\\<rbrakk>\n  \\<Longrightarrow> inj_on (?g \\<circ> f) P\n\ngoal (1 subgoal):\n 1. inj_on (g \\<circ> f) P", "by    fast"], ["proof (state)\nthis:\n  inj_on (g \\<circ> f) P\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P;\n        less_eq'' ((g \\<circ> f) a) ((g \\<circ> f) b)\\<rbrakk>\n       \\<Longrightarrow> b \\<succeq> a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P;\n        less_eq'' ((g \\<circ> f) a) ((g \\<circ> f) b)\\<rbrakk>\n       \\<Longrightarrow> b \\<succeq> a", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> P; b \\<in> P;\n        less_eq'' ((g \\<circ> f) a) ((g \\<circ> f) b)\\<rbrakk>\n       \\<Longrightarrow> b \\<succeq> a", "from assms(2)"], ["proof (chain)\npicking this:\n  order.greater_eq Q (f ` P)", "show \"\\<lbrakk> a\\<in>P; b\\<in>P; less_eq'' ((g\\<circ>f) a) ((g\\<circ>f) b) \\<rbrakk> \\<Longrightarrow> a\\<^bold>\\<le>b\""], ["proof (prove)\nusing this:\n  order.greater_eq Q (f ` P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> P; b \\<in> P;\n     less_eq'' ((g \\<circ> f) a) ((g \\<circ> f) b)\\<rbrakk>\n    \\<Longrightarrow> b \\<succeq> a", "using OrderingSetIso.rev_ordsetmap[OF assms(1)] rev_ordsetmap"], ["proof (prove)\nusing this:\n  order.greater_eq Q (f ` P)\n  \\<lbrakk>?a \\<in> Q; ?b \\<in> Q; less_eq'' (g ?a) (g ?b)\\<rbrakk>\n  \\<Longrightarrow> codomain.greater_eq ?b ?a\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P;\n   codomain.greater_eq (f ?b) (f ?a)\\<rbrakk>\n  \\<Longrightarrow> ?b \\<succeq> ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> P; b \\<in> P;\n     less_eq'' ((g \\<circ> f) a) ((g \\<circ> f) b)\\<rbrakk>\n    \\<Longrightarrow> b \\<succeq> a", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> P; b \\<in> P;\n   less_eq'' ((g \\<circ> f) a) ((g \\<circ> f) b)\\<rbrakk>\n  \\<Longrightarrow> b \\<succeq> a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iso_subset:\n  \"Q\\<subseteq>P \\<Longrightarrow> OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) (\\<^bold>\\<le>*) (\\<^bold><*) Q f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq P Q \\<Longrightarrow>\n    OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) (\\<^bold>\\<le>*) (\\<^bold><*)\n     Q f", "using subset[of Q] subset_inj_on[OF inj] rev_ordsetmap"], ["proof (prove)\nusing this:\n  order.greater_eq P Q \\<Longrightarrow>\n  OrderingSetMap (\\<^bold>\\<le>) (\\<^bold><) (\\<^bold>\\<le>*) (\\<^bold><*) Q\n   f\n  order.greater_eq P ?A \\<Longrightarrow> inj_on f ?A\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P;\n   codomain.greater_eq (f ?b) (f ?a)\\<rbrakk>\n  \\<Longrightarrow> ?b \\<succeq> ?a\n\ngoal (1 subgoal):\n 1. order.greater_eq P Q \\<Longrightarrow>\n    OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) (\\<^bold>\\<le>*) (\\<^bold><*)\n     Q f", "by    (blast intro: OrderingSetMap.isoI)"], ["", "lemma iso_dual:\n  \"OrderingSetIso domain.greater_eq domain.greater\n    codomain.greater_eq codomain.greater P f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetIso (\\<succeq>) (\\<succ>) codomain.greater_eq\n     codomain.greater P f", "by  (\n        rule OrderingSetMap.isoI, rule OrderingSetMap.dual, unfold_locales,\n        rule inj, rule rev_ordsetmap\n      )"], ["", "end"], ["", "(* context OrderingSetIso *)"], ["", "lemma induced_pow_fun_subset_ordering_iso:\n  assumes \"inj_on f A\"\n  shows   \"subset_ordering_iso (Pow A) ((`) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetIso dual_order.greater_eq dual_order.greater\n     dual_order.greater_eq dual_order.greater (Pow A) ((`) f)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> Pow A; b \\<in> Pow A; order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (f ` b) (f ` a)\n 2. inj_on ((`) f) (Pow A)\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> f \\<turnstile> Pow A; b \\<in> f \\<turnstile> Pow A;\n        order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into (Pow A) ((`) f) b)\n                          (the_inv_into (Pow A) ((`) f) a)", "show \"\\<And>a b. a \\<in> Pow A \\<Longrightarrow> b \\<in> Pow A \\<Longrightarrow> a \\<subseteq> b \\<Longrightarrow> f ` a \\<subseteq> f ` b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> Pow A; b \\<in> Pow A; order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (f ` b) (f ` a)", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> Pow A; ?b \\<in> Pow A; order.greater_eq ?b ?a\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (f ` ?b) (f ` ?a)\n\ngoal (2 subgoals):\n 1. inj_on ((`) f) (Pow A)\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> f \\<turnstile> Pow A; b \\<in> f \\<turnstile> Pow A;\n        order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into (Pow A) ((`) f) b)\n                          (the_inv_into (Pow A) ((`) f) a)", "from assms"], ["proof (chain)\npicking this:\n  inj_on f A", "show 2:\"inj_on ((`) f) (Pow A)\""], ["proof (prove)\nusing this:\n  inj_on f A\n\ngoal (1 subgoal):\n 1. inj_on ((`) f) (Pow A)", "using induced_pow_fun_inj_on"], ["proof (prove)\nusing this:\n  inj_on f A\n  inj_on ?f ?A \\<Longrightarrow> inj_on ((`) ?f) (Pow ?A)\n\ngoal (1 subgoal):\n 1. inj_on ((`) f) (Pow A)", "by fast"], ["proof (state)\nthis:\n  inj_on ((`) f) (Pow A)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> f \\<turnstile> Pow A; b \\<in> f \\<turnstile> Pow A;\n        order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into (Pow A) ((`) f) b)\n                          (the_inv_into (Pow A) ((`) f) a)", "show \"\\<And>a b. a \\<in> (`) f ` Pow A \\<Longrightarrow> b \\<in> (`) f ` Pow A \\<Longrightarrow> a \\<subseteq> b\n        \\<Longrightarrow> the_inv_into (Pow A) ((`) f) a \\<subseteq> the_inv_into (Pow A) ((`) f) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> f \\<turnstile> Pow A; b \\<in> f \\<turnstile> Pow A;\n        order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into (Pow A) ((`) f) b)\n                          (the_inv_into (Pow A) ((`) f) a)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> f \\<turnstile> Pow A; b \\<in> f \\<turnstile> Pow A;\n        order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into (Pow A) ((`) f) b)\n                          (the_inv_into (Pow A) ((`) f) a)", "fix Y1 Y2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> f \\<turnstile> Pow A; b \\<in> f \\<turnstile> Pow A;\n        order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into (Pow A) ((`) f) b)\n                          (the_inv_into (Pow A) ((`) f) a)", "assume Y: \"Y1 \\<in> ((`) f) ` Pow A\" \"Y2 \\<in> ((`) f) ` Pow A\" \"Y1 \\<subseteq> Y2\""], ["proof (state)\nthis:\n  Y1 \\<in> f \\<turnstile> Pow A\n  Y2 \\<in> f \\<turnstile> Pow A\n  order.greater_eq Y2 Y1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> f \\<turnstile> Pow A; b \\<in> f \\<turnstile> Pow A;\n        order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into (Pow A) ((`) f) b)\n                          (the_inv_into (Pow A) ((`) f) a)", "from Y(1,2)"], ["proof (chain)\npicking this:\n  Y1 \\<in> f \\<turnstile> Pow A\n  Y2 \\<in> f \\<turnstile> Pow A", "obtain X1 X2 where \"X1\\<subseteq>A\" \"X2\\<subseteq>A\" \"Y1 = f`X1\" \"Y2 = f`X2\""], ["proof (prove)\nusing this:\n  Y1 \\<in> f \\<turnstile> Pow A\n  Y2 \\<in> f \\<turnstile> Pow A\n\ngoal (1 subgoal):\n 1. (\\<And>X1 X2.\n        \\<lbrakk>order.greater_eq A X1; order.greater_eq A X2; Y1 = f ` X1;\n         Y2 = f ` X2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  order.greater_eq A X1\n  order.greater_eq A X2\n  Y1 = f ` X1\n  Y2 = f ` X2\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> f \\<turnstile> Pow A; b \\<in> f \\<turnstile> Pow A;\n        order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into (Pow A) ((`) f) b)\n                          (the_inv_into (Pow A) ((`) f) a)", "with assms Y(3)"], ["proof (chain)\npicking this:\n  inj_on f A\n  order.greater_eq Y2 Y1\n  order.greater_eq A X1\n  order.greater_eq A X2\n  Y1 = f ` X1\n  Y2 = f ` X2", "show  \"the_inv_into (Pow A) ((`) f) Y1 \\<subseteq> the_inv_into (Pow A) ((`) f) Y2\""], ["proof (prove)\nusing this:\n  inj_on f A\n  order.greater_eq Y2 Y1\n  order.greater_eq A X1\n  order.greater_eq A X2\n  Y1 = f ` X1\n  Y2 = f ` X2\n\ngoal (1 subgoal):\n 1. order.greater_eq (the_inv_into (Pow A) ((`) f) Y2)\n     (the_inv_into (Pow A) ((`) f) Y1)", "using inj_onD[OF assms] the_inv_into_f_f[OF 2, of X1]\n            the_inv_into_f_f[OF 2, of X2]"], ["proof (prove)\nusing this:\n  inj_on f A\n  order.greater_eq Y2 Y1\n  order.greater_eq A X1\n  order.greater_eq A X2\n  Y1 = f ` X1\n  Y2 = f ` X2\n  \\<lbrakk>f ?x = f ?y; ?x \\<in> A; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  X1 \\<in> Pow A \\<Longrightarrow>\n  the_inv_into (Pow A) ((`) f) (f ` X1) = X1\n  X2 \\<in> Pow A \\<Longrightarrow>\n  the_inv_into (Pow A) ((`) f) (f ` X2) = X2\n\ngoal (1 subgoal):\n 1. order.greater_eq (the_inv_into (Pow A) ((`) f) Y2)\n     (the_inv_into (Pow A) ((`) f) Y1)", "by    blast"], ["proof (state)\nthis:\n  order.greater_eq (the_inv_into (Pow A) ((`) f) Y2)\n   (the_inv_into (Pow A) ((`) f) Y1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> f \\<turnstile> Pow A; ?b \\<in> f \\<turnstile> Pow A;\n   order.greater_eq ?b ?a\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (the_inv_into (Pow A) ((`) f) ?b)\n                     (the_inv_into (Pow A) ((`) f) ?a)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>More @{const arg_min}\\<close>"], ["", "lemma is_arg_minI:\n  \"\\<lbrakk> P x; \\<And>y. P y \\<Longrightarrow> \\<not> m y < m x \\<rbrakk> \\<Longrightarrow> is_arg_min m P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P x; \\<And>y. P y \\<Longrightarrow> \\<not> m y < m x\\<rbrakk>\n    \\<Longrightarrow> is_arg_min m P x", "by (simp add: is_arg_min_def)"], ["", "lemma is_arg_min_linorderI:\n  \"\\<lbrakk> P x; \\<And>y. P y \\<Longrightarrow> m x \\<le> (m y::_::linorder) \\<rbrakk> \\<Longrightarrow> is_arg_min m P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P x;\n     \\<And>y. P y \\<Longrightarrow> order.greater_eq (m y) (m x)\\<rbrakk>\n    \\<Longrightarrow> is_arg_min m P x", "by (simp add: is_arg_min_linorder)"], ["", "lemma is_arg_min_eq:\n  \"\\<lbrakk> is_arg_min m P x; P z; m z = m x \\<rbrakk> \\<Longrightarrow> is_arg_min m P z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_arg_min m P x; P z; m z = m x\\<rbrakk>\n    \\<Longrightarrow> is_arg_min m P z", "by (metis is_arg_min_def)"], ["", "lemma is_arg_minD1: \"is_arg_min m P x \\<Longrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arg_min m P x \\<Longrightarrow> P x", "unfolding is_arg_min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P x \\<and> (\\<nexists>y. P y \\<and> m y < m x) \\<Longrightarrow> P x", "by fast"], ["", "lemma is_arg_minD2: \"is_arg_min m P x \\<Longrightarrow> P y \\<Longrightarrow> \\<not> m y < m x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_arg_min m P x; P y\\<rbrakk>\n    \\<Longrightarrow> \\<not> m y < m x", "unfolding is_arg_min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P x \\<and> (\\<nexists>y. P y \\<and> m y < m x); P y\\<rbrakk>\n    \\<Longrightarrow> \\<not> m y < m x", "by fast"], ["", "lemma is_arg_min_size: fixes m :: \"'a \\<Rightarrow> 'b::linorder\"\nshows \"is_arg_min m P x \\<Longrightarrow> m x = m (arg_min m P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arg_min m P x \\<Longrightarrow> m x = m (arg_min m P)", "by (metis arg_min_equality is_arg_min_linorder)"], ["", "lemma is_arg_min_size_subprop:\n  fixes   m :: \"'a\\<Rightarrow>'b::linorder\"\n  assumes \"is_arg_min m P x\" \"Q x\" \"\\<And>y. Q y \\<Longrightarrow> P y\"\n  shows   \"m (arg_min m Q) = m (arg_min m P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m (arg_min m Q) = m (arg_min m P)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. m (arg_min m Q) = m (arg_min m P)", "have \"\\<not> is_arg_min m Q x \\<Longrightarrow> \\<not> is_arg_min m P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_arg_min m Q x \\<Longrightarrow> \\<not> is_arg_min m P x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_arg_min m Q x; is_arg_min m P x\\<rbrakk>\n    \\<Longrightarrow> False", "assume x: \"\\<not> is_arg_min m Q x\""], ["proof (state)\nthis:\n  \\<not> is_arg_min m Q x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_arg_min m Q x; is_arg_min m P x\\<rbrakk>\n    \\<Longrightarrow> False", "from assms(2,3)"], ["proof (chain)\npicking this:\n  Q x\n  Q ?y \\<Longrightarrow> P ?y", "show False"], ["proof (prove)\nusing this:\n  Q x\n  Q ?y \\<Longrightarrow> P ?y\n\ngoal (1 subgoal):\n 1. False", "using contrapos_nn[OF x, OF is_arg_minI] is_arg_minD2[OF assms(1)]"], ["proof (prove)\nusing this:\n  Q x\n  Q ?y \\<Longrightarrow> P ?y\n  \\<lbrakk>?P \\<Longrightarrow> Q x;\n   \\<And>y.\n      \\<lbrakk>?P; Q y\\<rbrakk>\n      \\<Longrightarrow> \\<not> order.greater (m x) (m y)\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?P\n  P ?y \\<Longrightarrow> \\<not> order.greater (m x) (m ?y)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_arg_min m Q x \\<Longrightarrow> \\<not> is_arg_min m P x\n\ngoal (1 subgoal):\n 1. m (arg_min m Q) = m (arg_min m P)", "with assms(1)"], ["proof (chain)\npicking this:\n  is_arg_min m P x\n  \\<not> is_arg_min m Q x \\<Longrightarrow> \\<not> is_arg_min m P x", "show ?thesis"], ["proof (prove)\nusing this:\n  is_arg_min m P x\n  \\<not> is_arg_min m Q x \\<Longrightarrow> \\<not> is_arg_min m P x\n\ngoal (1 subgoal):\n 1. m (arg_min m Q) = m (arg_min m P)", "using is_arg_min_size[of m] is_arg_min_size[of m]"], ["proof (prove)\nusing this:\n  is_arg_min m P x\n  \\<not> is_arg_min m Q x \\<Longrightarrow> \\<not> is_arg_min m P x\n  is_arg_min m ?P ?x \\<Longrightarrow> m ?x = m (arg_min m ?P)\n  is_arg_min m ?P ?x \\<Longrightarrow> m ?x = m (arg_min m ?P)\n\ngoal (1 subgoal):\n 1. m (arg_min m Q) = m (arg_min m P)", "by fastforce"], ["proof (state)\nthis:\n  m (arg_min m Q) = m (arg_min m P)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Bottom of a set\\<close>"], ["", "context ordering\nbegin"], ["", "definition has_bottom :: \"'a set \\<Rightarrow> bool\"\n  where \"has_bottom P \\<equiv> \\<exists>z\\<in>P. \\<forall>x\\<in>P. z \\<^bold>\\<le> x\""], ["", "lemma has_bottomI: \"z\\<in>P \\<Longrightarrow> (\\<And>x. x\\<in>P \\<Longrightarrow> z \\<^bold>\\<le> x) \\<Longrightarrow> has_bottom P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<in> P;\n     \\<And>x. x \\<in> P \\<Longrightarrow> x \\<succeq> z\\<rbrakk>\n    \\<Longrightarrow> has_bottom P", "using has_bottom_def"], ["proof (prove)\nusing this:\n  has_bottom ?P \\<equiv> \\<exists>z\\<in>?P. \\<forall>x\\<in>?P. x \\<succeq> z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<in> P;\n     \\<And>x. x \\<in> P \\<Longrightarrow> x \\<succeq> z\\<rbrakk>\n    \\<Longrightarrow> has_bottom P", "by auto"], ["", "lemma has_uniq_bottom: \"has_bottom P \\<Longrightarrow> \\<exists>!z\\<in>P. \\<forall>x\\<in>P. z\\<^bold>\\<le>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_bottom P \\<Longrightarrow>\n    \\<exists>!z. z \\<in> P \\<and> (\\<forall>x\\<in>P. x \\<succeq> z)", "using has_bottom_def antisym"], ["proof (prove)\nusing this:\n  has_bottom ?P \\<equiv> \\<exists>z\\<in>?P. \\<forall>x\\<in>?P. x \\<succeq> z\n  \\<lbrakk>?b \\<succeq> ?a; ?a \\<succeq> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. has_bottom P \\<Longrightarrow>\n    \\<exists>!z. z \\<in> P \\<and> (\\<forall>x\\<in>P. x \\<succeq> z)", "by force"], ["", "definition bottom :: \"'a set \\<Rightarrow> 'a\"\n  where \"bottom P \\<equiv> (THE z. z\\<in>P \\<and> (\\<forall>x\\<in>P. z\\<^bold>\\<le>x))\""], ["", "lemma bottomD:\n  assumes   \"has_bottom P\"\n  shows     \"bottom P \\<in> P\" \"x\\<in>P \\<Longrightarrow> bottom P \\<^bold>\\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bottom P \\<in> P &&& (x \\<in> P \\<Longrightarrow> x \\<succeq> bottom P)", "using     assms has_uniq_bottom theI'[of \"\\<lambda>z. z\\<in>P \\<and> (\\<forall>x\\<in>P. z\\<^bold>\\<le>x)\"]"], ["proof (prove)\nusing this:\n  has_bottom P\n  has_bottom ?P \\<Longrightarrow>\n  \\<exists>!z. z \\<in> ?P \\<and> (\\<forall>x\\<in>?P. x \\<succeq> z)\n  \\<exists>!x.\n     x \\<in> P \\<and> (\\<forall>xa\\<in>P. xa \\<succeq> x) \\<Longrightarrow>\n  (THE x. x \\<in> P \\<and> (\\<forall>xa\\<in>P. xa \\<succeq> x))\n  \\<in> P \\<and>\n  (\\<forall>x\\<in>P.\n      x \\<succeq>\n      (THE x. x \\<in> P \\<and> (\\<forall>xa\\<in>P. xa \\<succeq> x)))\n\ngoal (1 subgoal):\n 1. bottom P \\<in> P &&& (x \\<in> P \\<Longrightarrow> x \\<succeq> bottom P)", "unfolding bottom_def"], ["proof (prove)\nusing this:\n  has_bottom P\n  has_bottom ?P \\<Longrightarrow>\n  \\<exists>!z. z \\<in> ?P \\<and> (\\<forall>x\\<in>?P. x \\<succeq> z)\n  \\<exists>!x.\n     x \\<in> P \\<and> (\\<forall>xa\\<in>P. xa \\<succeq> x) \\<Longrightarrow>\n  (THE x. x \\<in> P \\<and> (\\<forall>xa\\<in>P. xa \\<succeq> x))\n  \\<in> P \\<and>\n  (\\<forall>x\\<in>P.\n      x \\<succeq>\n      (THE x. x \\<in> P \\<and> (\\<forall>xa\\<in>P. xa \\<succeq> x)))\n\ngoal (1 subgoal):\n 1. (THE z. z \\<in> P \\<and> (\\<forall>x\\<in>P. x \\<succeq> z)) \\<in> P &&&\n    (x \\<in> P \\<Longrightarrow>\n     x \\<succeq>\n     (THE z. z \\<in> P \\<and> (\\<forall>x\\<in>P. x \\<succeq> z)))", "by        auto"], ["", "lemma bottomI: \"z\\<in>P \\<Longrightarrow> (\\<And>y. y\\<in>P \\<Longrightarrow> z \\<^bold>\\<le> y) \\<Longrightarrow> z = bottom P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<in> P;\n     \\<And>y. y \\<in> P \\<Longrightarrow> y \\<succeq> z\\<rbrakk>\n    \\<Longrightarrow> z = bottom P", "using     has_bottomI has_uniq_bottom\n            the1_equality[THEN sym, of \"\\<lambda>z. z\\<in>P \\<and> (\\<forall>x\\<in>P. z\\<^bold>\\<le>x)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?z \\<in> ?P;\n   \\<And>x. x \\<in> ?P \\<Longrightarrow> x \\<succeq> ?z\\<rbrakk>\n  \\<Longrightarrow> has_bottom ?P\n  has_bottom ?P \\<Longrightarrow>\n  \\<exists>!z. z \\<in> ?P \\<and> (\\<forall>x\\<in>?P. x \\<succeq> z)\n  \\<lbrakk>\\<exists>!x.\n              x \\<in> P \\<and> (\\<forall>xa\\<in>P. xa \\<succeq> x);\n   ?t \\<in> P \\<and> (\\<forall>x\\<in>P. x \\<succeq> ?t)\\<rbrakk>\n  \\<Longrightarrow> ?t =\n                    (THE x.\n                        x \\<in> P \\<and>\n                        (\\<forall>xa\\<in>P. xa \\<succeq> x))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<in> P;\n     \\<And>y. y \\<in> P \\<Longrightarrow> y \\<succeq> z\\<rbrakk>\n    \\<Longrightarrow> z = bottom P", "unfolding bottom_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?z \\<in> ?P;\n   \\<And>x. x \\<in> ?P \\<Longrightarrow> x \\<succeq> ?z\\<rbrakk>\n  \\<Longrightarrow> has_bottom ?P\n  has_bottom ?P \\<Longrightarrow>\n  \\<exists>!z. z \\<in> ?P \\<and> (\\<forall>x\\<in>?P. x \\<succeq> z)\n  \\<lbrakk>\\<exists>!x.\n              x \\<in> P \\<and> (\\<forall>xa\\<in>P. xa \\<succeq> x);\n   ?t \\<in> P \\<and> (\\<forall>x\\<in>P. x \\<succeq> ?t)\\<rbrakk>\n  \\<Longrightarrow> ?t =\n                    (THE x.\n                        x \\<in> P \\<and>\n                        (\\<forall>xa\\<in>P. xa \\<succeq> x))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<in> P;\n     \\<And>y. y \\<in> P \\<Longrightarrow> y \\<succeq> z\\<rbrakk>\n    \\<Longrightarrow> z =\n                      (THE z.\n                          z \\<in> P \\<and>\n                          (\\<forall>x\\<in>P. x \\<succeq> z))", "by        simp"], ["", "end"], ["", "(* context ordering *)"], ["", "lemma has_bottom_pow: \"order.has_bottom (Pow A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.has_bottom (Pow A)", "by (fast intro: order.has_bottomI)"], ["", "lemma bottom_pow: \"order.bottom (Pow A) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.bottom (Pow A) = {}", "proof (rule order.bottomI[THEN sym])"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<in> Pow A\n 2. \\<And>y. y \\<in> Pow A \\<Longrightarrow> order.greater_eq y {}", "qed auto"], ["", "context OrderingSetMap\nbegin"], ["", "abbreviation \"dombot \\<equiv> domain.bottom P\""], ["", "abbreviation \"codbot \\<equiv> codomain.bottom (f`P)\""], ["", "lemma im_has_bottom: \"domain.has_bottom P \\<Longrightarrow> codomain.has_bottom (f`P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain.has_bottom P \\<Longrightarrow> codomain.has_bottom (f ` P)", "using domain.bottomD ordsetmap"], ["proof (prove)\nusing this:\n  domain.has_bottom ?P \\<Longrightarrow> domain.bottom ?P \\<in> ?P\n  \\<lbrakk>domain.has_bottom ?P; ?x \\<in> ?P\\<rbrakk>\n  \\<Longrightarrow> ?x \\<succeq> domain.bottom ?P\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P; ?b \\<succeq> ?a\\<rbrakk>\n  \\<Longrightarrow> codomain.greater_eq (f ?b) (f ?a)\n\ngoal (1 subgoal):\n 1. domain.has_bottom P \\<Longrightarrow> codomain.has_bottom (f ` P)", "by (fast intro: codomain.has_bottomI)"], ["", "lemma im_bottom: \"domain.has_bottom P \\<Longrightarrow> f dombot = codbot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain.has_bottom P \\<Longrightarrow> f dombot = codbot", "using domain.bottomD ordsetmap"], ["proof (prove)\nusing this:\n  domain.has_bottom ?P \\<Longrightarrow> domain.bottom ?P \\<in> ?P\n  \\<lbrakk>domain.has_bottom ?P; ?x \\<in> ?P\\<rbrakk>\n  \\<Longrightarrow> ?x \\<succeq> domain.bottom ?P\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P; ?b \\<succeq> ?a\\<rbrakk>\n  \\<Longrightarrow> codomain.greater_eq (f ?b) (f ?a)\n\ngoal (1 subgoal):\n 1. domain.has_bottom P \\<Longrightarrow> f dombot = codbot", "by (auto intro: codomain.bottomI)"], ["", "end"], ["", "(* context OrderingSetMap *)"], ["", "lemma (in OrderingSetIso) pullback_has_bottom:\n  assumes \"codomain.has_bottom (f`P)\"\n  shows   \"domain.has_bottom P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain.has_bottom P", "proof (rule domain.has_bottomI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?z \\<in> P\n 2. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<succeq> ?z", "from assms"], ["proof (chain)\npicking this:\n  codomain.has_bottom (f ` P)", "show \"the_inv_into P f codbot \\<in> P\""], ["proof (prove)\nusing this:\n  codomain.has_bottom (f ` P)\n\ngoal (1 subgoal):\n 1. the_inv_into P f codbot \\<in> P", "using codomain.bottomD(1) the_inv_into_into[OF inj]"], ["proof (prove)\nusing this:\n  codomain.has_bottom (f ` P)\n  codomain.has_bottom ?P \\<Longrightarrow> codomain.bottom ?P \\<in> ?P\n  \\<lbrakk>?x \\<in> f ` P; order.greater_eq ?B P\\<rbrakk>\n  \\<Longrightarrow> the_inv_into P f ?x \\<in> ?B\n\ngoal (1 subgoal):\n 1. the_inv_into P f codbot \\<in> P", "by fast"], ["proof (state)\nthis:\n  the_inv_into P f codbot \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<succeq> the_inv_into P f codbot", "from assms"], ["proof (chain)\npicking this:\n  codomain.has_bottom (f ` P)", "show \"\\<And>x. x\\<in>P \\<Longrightarrow> the_inv_into P f codbot \\<^bold>\\<le> x\""], ["proof (prove)\nusing this:\n  codomain.has_bottom (f ` P)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<succeq> the_inv_into P f codbot", "using codomain.bottomD inv_ordsetmap[of codbot] the_inv_into_f_f[OF inj]"], ["proof (prove)\nusing this:\n  codomain.has_bottom (f ` P)\n  codomain.has_bottom ?P \\<Longrightarrow> codomain.bottom ?P \\<in> ?P\n  \\<lbrakk>codomain.has_bottom ?P; ?x \\<in> ?P\\<rbrakk>\n  \\<Longrightarrow> codomain.greater_eq ?x (codomain.bottom ?P)\n  \\<lbrakk>codbot \\<in> f ` P; ?b \\<in> f ` P;\n   codomain.greater_eq ?b codbot\\<rbrakk>\n  \\<Longrightarrow> the_inv_into P f ?b \\<succeq> the_inv_into P f codbot\n  ?x \\<in> P \\<Longrightarrow> the_inv_into P f (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> x \\<succeq> the_inv_into P f codbot", "by    fastforce"], ["proof (state)\nthis:\n  ?x \\<in> P \\<Longrightarrow> ?x \\<succeq> the_inv_into P f codbot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in OrderingSetIso) pullback_bottom:\n  \"\\<lbrakk> domain.has_bottom P; x\\<in>P; f x = codomain.bottom (f`P) \\<rbrakk> \\<Longrightarrow>\n    x = domain.bottom P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>domain.has_bottom P; x \\<in> P; f x = codbot\\<rbrakk>\n    \\<Longrightarrow> x = dombot", "using im_has_bottom codomain.bottomD(2) rev_ordsetmap"], ["proof (prove)\nusing this:\n  domain.has_bottom P \\<Longrightarrow> codomain.has_bottom (f ` P)\n  \\<lbrakk>codomain.has_bottom ?P; ?x \\<in> ?P\\<rbrakk>\n  \\<Longrightarrow> codomain.greater_eq ?x (codomain.bottom ?P)\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P;\n   codomain.greater_eq (f ?b) (f ?a)\\<rbrakk>\n  \\<Longrightarrow> ?b \\<succeq> ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>domain.has_bottom P; x \\<in> P; f x = codbot\\<rbrakk>\n    \\<Longrightarrow> x = dombot", "by    (auto intro: domain.bottomI)"], ["", "subsubsection \\<open>Minimal and pseudominimal elements in sets\\<close>"], ["", "text \\<open>\n  We will call an element of a poset pseudominimal if the only element below it is the bottom of\n  the poset.\n\\<close>"], ["", "context ordering\nbegin"], ["", "definition minimal_in :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  where \"minimal_in P x \\<equiv> x\\<in>P \\<and> (\\<forall>z\\<in>P. \\<not> z \\<^bold>< x)\""], ["", "definition pseudominimal_in :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  where \"pseudominimal_in P x \\<equiv> minimal_in (P - {bottom P}) x\"\n\\<comment> \\<open>only makes sense for @{term \"has_bottom P\"}\\<close>"], ["", "lemma minimal_inD1: \"minimal_in P x \\<Longrightarrow> x\\<in>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_in P x \\<Longrightarrow> x \\<in> P", "using minimal_in_def"], ["proof (prove)\nusing this:\n  minimal_in ?P ?x \\<equiv>\n  ?x \\<in> ?P \\<and> (\\<forall>z\\<in>?P. \\<not> ?x \\<succ> z)\n\ngoal (1 subgoal):\n 1. minimal_in P x \\<Longrightarrow> x \\<in> P", "by fast"], ["", "lemma minimal_inD2: \"minimal_in P x \\<Longrightarrow> z\\<in>P \\<Longrightarrow> \\<not> z \\<^bold>< x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>minimal_in P x; z \\<in> P\\<rbrakk>\n    \\<Longrightarrow> \\<not> x \\<succ> z", "using minimal_in_def"], ["proof (prove)\nusing this:\n  minimal_in ?P ?x \\<equiv>\n  ?x \\<in> ?P \\<and> (\\<forall>z\\<in>?P. \\<not> ?x \\<succ> z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>minimal_in P x; z \\<in> P\\<rbrakk>\n    \\<Longrightarrow> \\<not> x \\<succ> z", "by fast"], ["", "lemma pseudominimal_inD1: \"pseudominimal_in P x \\<Longrightarrow> x\\<in>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudominimal_in P x \\<Longrightarrow> x \\<in> P", "using pseudominimal_in_def minimal_inD1"], ["proof (prove)\nusing this:\n  pseudominimal_in ?P ?x \\<equiv> minimal_in (?P - {bottom ?P}) ?x\n  minimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n\ngoal (1 subgoal):\n 1. pseudominimal_in P x \\<Longrightarrow> x \\<in> P", "by fast"], ["", "lemma pseudominimal_inD2:\n  \"pseudominimal_in P x \\<Longrightarrow> z\\<in>P \\<Longrightarrow> z\\<^bold><x \\<Longrightarrow> z = bottom P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pseudominimal_in P x; z \\<in> P; x \\<succ> z\\<rbrakk>\n    \\<Longrightarrow> z = bottom P", "using pseudominimal_in_def minimal_inD2"], ["proof (prove)\nusing this:\n  pseudominimal_in ?P ?x \\<equiv> minimal_in (?P - {bottom ?P}) ?x\n  \\<lbrakk>minimal_in ?P ?x; ?z \\<in> ?P\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?x \\<succ> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pseudominimal_in P x; z \\<in> P; x \\<succ> z\\<rbrakk>\n    \\<Longrightarrow> z = bottom P", "by fast"], ["", "lemma pseudominimal_inI:\n  assumes   \"x\\<in>P\" \"x \\<noteq> bottom P\" \"\\<And>z. z\\<in>P \\<Longrightarrow> z\\<^bold><x \\<Longrightarrow> z = bottom P\"\n  shows     \"pseudominimal_in P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudominimal_in P x", "using     assms"], ["proof (prove)\nusing this:\n  x \\<in> P\n  x \\<noteq> bottom P\n  \\<lbrakk>?z \\<in> P; x \\<succ> ?z\\<rbrakk> \\<Longrightarrow> ?z = bottom P\n\ngoal (1 subgoal):\n 1. pseudominimal_in P x", "unfolding pseudominimal_in_def minimal_in_def"], ["proof (prove)\nusing this:\n  x \\<in> P\n  x \\<noteq> bottom P\n  \\<lbrakk>?z \\<in> P; x \\<succ> ?z\\<rbrakk> \\<Longrightarrow> ?z = bottom P\n\ngoal (1 subgoal):\n 1. x \\<in> P - {bottom P} \\<and>\n    (\\<forall>z\\<in>P - {bottom P}. \\<not> x \\<succ> z)", "by        fast"], ["", "lemma pseudominimal_ne_bottom: \"pseudominimal_in P x \\<Longrightarrow> x \\<noteq> bottom P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudominimal_in P x \\<Longrightarrow> x \\<noteq> bottom P", "using pseudominimal_in_def minimal_inD1"], ["proof (prove)\nusing this:\n  pseudominimal_in ?P ?x \\<equiv> minimal_in (?P - {bottom ?P}) ?x\n  minimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n\ngoal (1 subgoal):\n 1. pseudominimal_in P x \\<Longrightarrow> x \\<noteq> bottom P", "by fast"], ["", "lemma pseudominimal_comp:\n  \"\\<lbrakk> pseudominimal_in P x; pseudominimal_in P y; x\\<^bold>\\<le>y \\<rbrakk> \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pseudominimal_in P x; pseudominimal_in P y;\n     y \\<succeq> x\\<rbrakk>\n    \\<Longrightarrow> x = y", "using pseudominimal_inD1 pseudominimal_inD2 pseudominimal_ne_bottom\n        strict_iff_order[of x y]"], ["proof (prove)\nusing this:\n  pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n  \\<lbrakk>pseudominimal_in ?P ?x; ?z \\<in> ?P; ?x \\<succ> ?z\\<rbrakk>\n  \\<Longrightarrow> ?z = bottom ?P\n  pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<noteq> bottom ?P\n  (y \\<succ> x) = (y \\<succeq> x \\<and> x \\<noteq> y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pseudominimal_in P x; pseudominimal_in P y;\n     y \\<succeq> x\\<rbrakk>\n    \\<Longrightarrow> x = y", "by    force"], ["", "end"], ["", "(* context ordering *)"], ["", "lemma pseudominimal_in_pow:\n  assumes \"order.pseudominimal_in (Pow A) x\"\n  shows \"\\<exists>a\\<in>A. x = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. x = {a}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. x = {a}", "from assms"], ["proof (chain)\npicking this:\n  order.pseudominimal_in (Pow A) x", "obtain a where \"{a} \\<subseteq> x\""], ["proof (prove)\nusing this:\n  order.pseudominimal_in (Pow A) x\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        order.greater_eq x {a} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using order.pseudominimal_ne_bottom bottom_pow[of A]"], ["proof (prove)\nusing this:\n  order.pseudominimal_in (Pow A) x\n  order.pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<noteq> order.bottom ?P\n  order.bottom (Pow A) = {}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        order.greater_eq x {a} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  order.greater_eq x {a}\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. x = {a}", "with assms"], ["proof (chain)\npicking this:\n  order.pseudominimal_in (Pow A) x\n  order.greater_eq x {a}", "show ?thesis"], ["proof (prove)\nusing this:\n  order.pseudominimal_in (Pow A) x\n  order.greater_eq x {a}\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. x = {a}", "using order.pseudominimal_inD1 order.pseudominimal_inD2[of _ x \"{a}\"]\n          bottom_pow"], ["proof (prove)\nusing this:\n  order.pseudominimal_in (Pow A) x\n  order.greater_eq x {a}\n  order.pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n  \\<lbrakk>order.pseudominimal_in ?P x; {a} \\<in> ?P;\n   order.greater x {a}\\<rbrakk>\n  \\<Longrightarrow> {a} = order.bottom ?P\n  order.bottom (Pow ?A) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. x = {a}", "by    fast"], ["proof (state)\nthis:\n  \\<exists>a\\<in>A. x = {a}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pseudominimal_in_pow_singleton:\n  \"a\\<in>A \\<Longrightarrow> order.pseudominimal_in (Pow A) {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> A \\<Longrightarrow> order.pseudominimal_in (Pow A) {a}", "using singleton_pow bottom_pow"], ["proof (prove)\nusing this:\n  ?a \\<in> ?A \\<Longrightarrow> {?a} \\<in> Pow ?A\n  order.bottom (Pow ?A) = {}\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<Longrightarrow> order.pseudominimal_in (Pow A) {a}", "by (fast intro: order.pseudominimal_inI)"], ["", "lemma no_pseudominimal_in_pow_is_empty:\n  \"(\\<And>x. \\<not> order.pseudominimal_in (Pow A) {x}) \\<Longrightarrow> A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. \\<not> order.pseudominimal_in (Pow A) {x}) \\<Longrightarrow>\n    A = {}", "using pseudominimal_in_pow_singleton"], ["proof (prove)\nusing this:\n  ?a \\<in> ?A \\<Longrightarrow> order.pseudominimal_in (Pow ?A) {?a}\n\ngoal (1 subgoal):\n 1. (\\<And>x. \\<not> order.pseudominimal_in (Pow A) {x}) \\<Longrightarrow>\n    A = {}", "by (fast intro: equals0I)"], ["", "lemma (in OrderingSetIso) pseudominimal_map:\n  \"domain.has_bottom P \\<Longrightarrow> domain.pseudominimal_in P x \\<Longrightarrow>\n    codomain.pseudominimal_in (f`P) (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>domain.has_bottom P; domain.pseudominimal_in P x\\<rbrakk>\n    \\<Longrightarrow> codomain.pseudominimal_in (f ` P) (f x)", "using domain.pseudominimal_inD1 pullback_bottom\n        domain.pseudominimal_ne_bottom rev_ordsetmap_strict\n        domain.pseudominimal_inD2 im_bottom"], ["proof (prove)\nusing this:\n  domain.pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n  \\<lbrakk>domain.has_bottom P; ?x \\<in> P; f ?x = codbot\\<rbrakk>\n  \\<Longrightarrow> ?x = dombot\n  domain.pseudominimal_in ?P ?x \\<Longrightarrow>\n  ?x \\<noteq> domain.bottom ?P\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P; codomain.greater (f ?b) (f ?a)\\<rbrakk>\n  \\<Longrightarrow> ?b \\<succ> ?a\n  \\<lbrakk>domain.pseudominimal_in ?P ?x; ?z \\<in> ?P;\n   ?x \\<succ> ?z\\<rbrakk>\n  \\<Longrightarrow> ?z = domain.bottom ?P\n  domain.has_bottom P \\<Longrightarrow> f dombot = codbot\n\ngoal (1 subgoal):\n 1. \\<lbrakk>domain.has_bottom P; domain.pseudominimal_in P x\\<rbrakk>\n    \\<Longrightarrow> codomain.pseudominimal_in (f ` P) (f x)", "by    (blast intro: codomain.pseudominimal_inI)"], ["", "lemma (in OrderingSetIso) pullback_pseudominimal_in:\n  \"\\<lbrakk> domain.has_bottom P; x\\<in>P; codomain.pseudominimal_in (f`P) (f x) \\<rbrakk> \\<Longrightarrow>\n      domain.pseudominimal_in P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>domain.has_bottom P; x \\<in> P;\n     codomain.pseudominimal_in (f ` P) (f x)\\<rbrakk>\n    \\<Longrightarrow> domain.pseudominimal_in P x", "using im_bottom codomain.pseudominimal_ne_bottom ordsetmap_strict\n        codomain.pseudominimal_inD2 pullback_bottom"], ["proof (prove)\nusing this:\n  domain.has_bottom P \\<Longrightarrow> f dombot = codbot\n  codomain.pseudominimal_in ?P ?x \\<Longrightarrow>\n  ?x \\<noteq> codomain.bottom ?P\n  \\<lbrakk>?a \\<in> P; ?b \\<in> P; ?b \\<succ> ?a\\<rbrakk>\n  \\<Longrightarrow> codomain.greater (f ?b) (f ?a)\n  \\<lbrakk>codomain.pseudominimal_in ?P ?x; ?z \\<in> ?P;\n   codomain.greater ?x ?z\\<rbrakk>\n  \\<Longrightarrow> ?z = codomain.bottom ?P\n  \\<lbrakk>domain.has_bottom P; ?x \\<in> P; f ?x = codbot\\<rbrakk>\n  \\<Longrightarrow> ?x = dombot\n\ngoal (1 subgoal):\n 1. \\<lbrakk>domain.has_bottom P; x \\<in> P;\n     codomain.pseudominimal_in (f ` P) (f x)\\<rbrakk>\n    \\<Longrightarrow> domain.pseudominimal_in P x", "by    (blast intro: domain.pseudominimal_inI)"], ["", "subsubsection \\<open>Set of elements below another\\<close>"], ["", "abbreviation (in ordering) below_in :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> 'a set\" (infix \".\\<^bold>\\<le>\" 70)\n  where \"P.\\<^bold>\\<le>x \\<equiv> {y\\<in>P. y\\<^bold>\\<le>x}\""], ["", "abbreviation (in ord) below_in :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> 'a set\" (infix \".\\<le>\" 70)\n  where \"P.\\<le>x \\<equiv> {y\\<in>P. y\\<le>x}\""], ["", "context ordering\nbegin"], ["", "lemma below_in_refl: \"x\\<in>P \\<Longrightarrow> x \\<in> P.\\<^bold>\\<le>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> P \\<Longrightarrow> x \\<in> P .\\<^bold>\\<le> x", "using refl"], ["proof (prove)\nusing this:\n  ?a \\<succeq> ?a\n\ngoal (1 subgoal):\n 1. x \\<in> P \\<Longrightarrow> x \\<in> P .\\<^bold>\\<le> x", "by fast"], ["", "lemma below_in_singleton: \"x\\<in>P \\<Longrightarrow> P.\\<^bold>\\<le>x \\<subseteq> {y} \\<Longrightarrow> y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> P; order.greater_eq {y} (P .\\<^bold>\\<le> x)\\<rbrakk>\n    \\<Longrightarrow> y = x", "using below_in_refl"], ["proof (prove)\nusing this:\n  ?x \\<in> ?P \\<Longrightarrow> ?x \\<in> ?P .\\<^bold>\\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> P; order.greater_eq {y} (P .\\<^bold>\\<le> x)\\<rbrakk>\n    \\<Longrightarrow> y = x", "by fast"], ["", "lemma bottom_in_below_in: \"has_bottom P \\<Longrightarrow> x\\<in>P \\<Longrightarrow> bottom P \\<in> P.\\<^bold>\\<le>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_bottom P; x \\<in> P\\<rbrakk>\n    \\<Longrightarrow> bottom P \\<in> P .\\<^bold>\\<le> x", "using bottomD"], ["proof (prove)\nusing this:\n  has_bottom ?P \\<Longrightarrow> bottom ?P \\<in> ?P\n  \\<lbrakk>has_bottom ?P; ?x \\<in> ?P\\<rbrakk>\n  \\<Longrightarrow> ?x \\<succeq> bottom ?P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_bottom P; x \\<in> P\\<rbrakk>\n    \\<Longrightarrow> bottom P \\<in> P .\\<^bold>\\<le> x", "by fast"], ["", "lemma below_in_singleton_is_bottom:\n  \"\\<lbrakk> has_bottom P; x\\<in>P; P.\\<^bold>\\<le>x = {x} \\<rbrakk> \\<Longrightarrow> x = bottom P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_bottom P; x \\<in> P; P .\\<^bold>\\<le> x = {x}\\<rbrakk>\n    \\<Longrightarrow> x = bottom P", "using bottom_in_below_in"], ["proof (prove)\nusing this:\n  \\<lbrakk>has_bottom ?P; ?x \\<in> ?P\\<rbrakk>\n  \\<Longrightarrow> bottom ?P \\<in> ?P .\\<^bold>\\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_bottom P; x \\<in> P; P .\\<^bold>\\<le> x = {x}\\<rbrakk>\n    \\<Longrightarrow> x = bottom P", "by fast"], ["", "lemma bottom_below_in:\n  \"has_bottom P \\<Longrightarrow> x\\<in>P \\<Longrightarrow> bottom (P.\\<^bold>\\<le>x) = bottom P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_bottom P; x \\<in> P\\<rbrakk>\n    \\<Longrightarrow> bottom (P .\\<^bold>\\<le> x) = bottom P", "using bottom_in_below_in"], ["proof (prove)\nusing this:\n  \\<lbrakk>has_bottom ?P; ?x \\<in> ?P\\<rbrakk>\n  \\<Longrightarrow> bottom ?P \\<in> ?P .\\<^bold>\\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_bottom P; x \\<in> P\\<rbrakk>\n    \\<Longrightarrow> bottom (P .\\<^bold>\\<le> x) = bottom P", "by (fast intro: bottomI[THEN sym])"], ["", "lemma bottom_below_in_relative:\n  \"\\<lbrakk> has_bottom (P.\\<^bold>\\<le>y); x\\<in>P; x\\<^bold>\\<le>y \\<rbrakk> \\<Longrightarrow> bottom (P.\\<^bold>\\<le>x) = bottom (P.\\<^bold>\\<le>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_bottom (P .\\<^bold>\\<le> y); x \\<in> P;\n     y \\<succeq> x\\<rbrakk>\n    \\<Longrightarrow> bottom (P .\\<^bold>\\<le> x) =\n                      bottom (P .\\<^bold>\\<le> y)", "using bottomD trans"], ["proof (prove)\nusing this:\n  has_bottom ?P \\<Longrightarrow> bottom ?P \\<in> ?P\n  \\<lbrakk>has_bottom ?P; ?x \\<in> ?P\\<rbrakk>\n  \\<Longrightarrow> ?x \\<succeq> bottom ?P\n  \\<lbrakk>?b \\<succeq> ?a; ?c \\<succeq> ?b\\<rbrakk>\n  \\<Longrightarrow> ?c \\<succeq> ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_bottom (P .\\<^bold>\\<le> y); x \\<in> P;\n     y \\<succeq> x\\<rbrakk>\n    \\<Longrightarrow> bottom (P .\\<^bold>\\<le> x) =\n                      bottom (P .\\<^bold>\\<le> y)", "by (blast intro: bottomI[THEN sym])"], ["", "lemma has_bottom_pseudominimal_in_below_inI:\n  assumes \"has_bottom P\" \"x\\<in>P\" \"pseudominimal_in P y\" \"y\\<^bold>\\<le>x\"\n  shows   \"pseudominimal_in (P.\\<^bold>\\<le>x) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudominimal_in (P .\\<^bold>\\<le> x) y", "using   assms(3,4) pseudominimal_inD1[OF assms(3)]\n          pseudominimal_inD2[OF assms(3)]\n          bottom_below_in[OF assms(1,2)] pseudominimal_ne_bottom"], ["proof (prove)\nusing this:\n  pseudominimal_in P y\n  x \\<succeq> y\n  y \\<in> P\n  \\<lbrakk>?z \\<in> P; y \\<succ> ?z\\<rbrakk> \\<Longrightarrow> ?z = bottom P\n  bottom (P .\\<^bold>\\<le> x) = bottom P\n  pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<noteq> bottom ?P\n\ngoal (1 subgoal):\n 1. pseudominimal_in (P .\\<^bold>\\<le> x) y", "by      (force intro: pseudominimal_inI)"], ["", "lemma has_bottom_pseudominimal_in_below_in:\n  assumes \"has_bottom P\" \"x\\<in>P\" \"pseudominimal_in (P.\\<^bold>\\<le>x) y\"\n  shows   \"pseudominimal_in P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudominimal_in P y", "using   pseudominimal_inD1[OF assms(3)]\n          pseudominimal_inD2[OF assms(3)]\n          pseudominimal_ne_bottom[OF assms(3)]\n          bottom_below_in[OF assms(1,2)]\n          strict_implies_order[of _ y] trans[of _ y x]"], ["proof (prove)\nusing this:\n  y \\<in> P .\\<^bold>\\<le> x\n  \\<lbrakk>?z \\<in> P .\\<^bold>\\<le> x; y \\<succ> ?z\\<rbrakk>\n  \\<Longrightarrow> ?z = bottom (P .\\<^bold>\\<le> x)\n  y \\<noteq> bottom (P .\\<^bold>\\<le> x)\n  bottom (P .\\<^bold>\\<le> x) = bottom P\n  y \\<succ> ?a \\<Longrightarrow> y \\<succeq> ?a\n  \\<lbrakk>y \\<succeq> ?a; x \\<succeq> y\\<rbrakk>\n  \\<Longrightarrow> x \\<succeq> ?a\n\ngoal (1 subgoal):\n 1. pseudominimal_in P y", "by      (force intro: pseudominimal_inI)"], ["", "lemma pseudominimal_in_below_in:\n  assumes   \"has_bottom (P.\\<^bold>\\<le>y)\" \"x\\<in>P\" \"x\\<^bold>\\<le>y\" \"pseudominimal_in (P.\\<^bold>\\<le>x) w\"\n  shows     \"pseudominimal_in (P.\\<^bold>\\<le>y) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudominimal_in (P .\\<^bold>\\<le> y) w", "using     assms(3) trans[of w x y] trans[of _ w x] strict_iff_order\n            pseudominimal_inD1[OF assms(4)]\n            pseudominimal_inD2[OF assms(4)]\n            pseudominimal_ne_bottom[OF assms(4)]\n            bottom_below_in_relative[OF assms(1-3)]"], ["proof (prove)\nusing this:\n  y \\<succeq> x\n  \\<lbrakk>x \\<succeq> w; y \\<succeq> x\\<rbrakk>\n  \\<Longrightarrow> y \\<succeq> w\n  \\<lbrakk>w \\<succeq> ?a; x \\<succeq> w\\<rbrakk>\n  \\<Longrightarrow> x \\<succeq> ?a\n  (?b \\<succ> ?a) = (?b \\<succeq> ?a \\<and> ?a \\<noteq> ?b)\n  w \\<in> P .\\<^bold>\\<le> x\n  \\<lbrakk>?z \\<in> P .\\<^bold>\\<le> x; w \\<succ> ?z\\<rbrakk>\n  \\<Longrightarrow> ?z = bottom (P .\\<^bold>\\<le> x)\n  w \\<noteq> bottom (P .\\<^bold>\\<le> x)\n  bottom (P .\\<^bold>\\<le> x) = bottom (P .\\<^bold>\\<le> y)\n\ngoal (1 subgoal):\n 1. pseudominimal_in (P .\\<^bold>\\<le> y) w", "by        (force intro: pseudominimal_inI)"], ["", "lemma collect_pseudominimals_below_in_less_eq_top:\n  assumes \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) (P.\\<^bold>\\<le>x) f\"\n          \"f`(P.\\<^bold>\\<le>x) = Pow A\" \"a \\<subseteq> {y. pseudominimal_in (P.\\<^bold>\\<le>x) y}\"\n  defines \"w \\<equiv> the_inv_into (P.\\<^bold>\\<le>x) f (\\<Union>(f`a))\"\n  shows   \"w \\<^bold>\\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<succeq> w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<succeq> w", "from assms(2,3)"], ["proof (chain)\npicking this:\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a", "have \"(\\<Union>(f`a)) \\<in> f`(P.\\<^bold>\\<le>x)\""], ["proof (prove)\nusing this:\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n\ngoal (1 subgoal):\n 1. \\<Union> (f ` a) \\<in> f ` (P .\\<^bold>\\<le> x)", "using pseudominimal_inD1"], ["proof (prove)\nusing this:\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n  pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n\ngoal (1 subgoal):\n 1. \\<Union> (f ` a) \\<in> f ` (P .\\<^bold>\\<le> x)", "by fastforce"], ["proof (state)\nthis:\n  \\<Union> (f ` a) \\<in> f ` (P .\\<^bold>\\<le> x)\n\ngoal (1 subgoal):\n 1. x \\<succeq> w", "with assms(4)"], ["proof (chain)\npicking this:\n  w \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` a))\n  \\<Union> (f ` a) \\<in> f ` (P .\\<^bold>\\<le> x)", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` a))\n  \\<Union> (f ` a) \\<in> f ` (P .\\<^bold>\\<le> x)\n\ngoal (1 subgoal):\n 1. x \\<succeq> w", "using OrderingSetIso.inj[OF assms(1)] the_inv_into_into[of f \"P.\\<^bold>\\<le>x\"]"], ["proof (prove)\nusing this:\n  w \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` a))\n  \\<Union> (f ` a) \\<in> f ` (P .\\<^bold>\\<le> x)\n  inj_on f (P .\\<^bold>\\<le> x)\n  \\<lbrakk>inj_on f (P .\\<^bold>\\<le> x); ?x \\<in> f ` (P .\\<^bold>\\<le> x);\n   order.greater_eq ?B (P .\\<^bold>\\<le> x)\\<rbrakk>\n  \\<Longrightarrow> the_inv_into (P .\\<^bold>\\<le> x) f ?x \\<in> ?B\n\ngoal (1 subgoal):\n 1. x \\<succeq> w", "by force"], ["proof (state)\nthis:\n  x \\<succeq> w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma collect_pseudominimals_below_in_poset:\n  assumes   \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) (P.\\<^bold>\\<le>x) f\"\n            \"f`(P.\\<^bold>\\<le>x) = Pow A\"\n            \"a \\<subseteq> {y. pseudominimal_in (P.\\<^bold>\\<le>x) y}\"\n  defines   \"w \\<equiv> the_inv_into (P.\\<^bold>\\<le>x) f (\\<Union>(f`a))\"\n  shows     \"w \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> P", "using     assms(2-4) OrderingSetIso.inj[OF assms(1)] pseudominimal_inD1\n            the_inv_into_into[of f \"P.\\<^bold>\\<le>x\" \"\\<Union>(f`a)\"]"], ["proof (prove)\nusing this:\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n  w \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` a))\n  inj_on f (P .\\<^bold>\\<le> x)\n  pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n  \\<lbrakk>inj_on f (P .\\<^bold>\\<le> x);\n   \\<Union> (f ` a) \\<in> f ` (P .\\<^bold>\\<le> x);\n   order.greater_eq ?B (P .\\<^bold>\\<le> x)\\<rbrakk>\n  \\<Longrightarrow> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` a))\n                    \\<in> ?B\n\ngoal (1 subgoal):\n 1. w \\<in> P", "by        force"], ["", "lemma collect_pseudominimals_below_in_eq:\n  assumes \"x\\<in>P\" \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) (P.\\<^bold>\\<le>x) f\"\n          \"f`(P.\\<^bold>\\<le>x) = Pow A\" \"a \\<subseteq> {y. pseudominimal_in (P.\\<^bold>\\<le>x) y}\"\n  defines w: \"w \\<equiv> the_inv_into (P.\\<^bold>\\<le>x) f (\\<Union>(f`a))\"\n  shows   \"a = {y. pseudominimal_in (P.\\<^bold>\\<le>w) y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> w) y} a\n 2. order.greater_eq a {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}", "from assms(3)"], ["proof (chain)\npicking this:\n  f ` (P .\\<^bold>\\<le> x) = Pow A", "have has_bot_ltx: \"has_bottom (P.\\<^bold>\\<le>x)\""], ["proof (prove)\nusing this:\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n\ngoal (1 subgoal):\n 1. has_bottom (P .\\<^bold>\\<le> x)", "using has_bottom_pow OrderingSetIso.pullback_has_bottom[OF assms(2)]"], ["proof (prove)\nusing this:\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.has_bottom (Pow ?A)\n  order.has_bottom (f ` (P .\\<^bold>\\<le> x)) \\<Longrightarrow>\n  has_bottom (P .\\<^bold>\\<le> x)\n\ngoal (1 subgoal):\n 1. has_bottom (P .\\<^bold>\\<le> x)", "by    auto"], ["proof (state)\nthis:\n  has_bottom (P .\\<^bold>\\<le> x)\n\ngoal (2 subgoals):\n 1. order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> w) y} a\n 2. order.greater_eq a {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}", "from assms(3,4)"], ["proof (chain)\npicking this:\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a", "have Un_fa: \"(\\<Union>(f`a)) \\<in> f`(P.\\<^bold>\\<le>x)\""], ["proof (prove)\nusing this:\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n\ngoal (1 subgoal):\n 1. \\<Union> (f ` a) \\<in> f ` (P .\\<^bold>\\<le> x)", "using pseudominimal_inD1"], ["proof (prove)\nusing this:\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n  pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n\ngoal (1 subgoal):\n 1. \\<Union> (f ` a) \\<in> f ` (P .\\<^bold>\\<le> x)", "by fastforce"], ["proof (state)\nthis:\n  \\<Union> (f ` a) \\<in> f ` (P .\\<^bold>\\<le> x)\n\ngoal (2 subgoals):\n 1. order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> w) y} a\n 2. order.greater_eq a {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> P\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> x) f\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n  w \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` a))", "have w_le_x: \"w\\<^bold>\\<le>x\" and w_P: \"w\\<in>P\""], ["proof (prove)\nusing this:\n  x \\<in> P\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> x) f\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n  w \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` a))\n\ngoal (1 subgoal):\n 1. x \\<succeq> w &&& w \\<in> P", "using collect_pseudominimals_below_in_less_eq_top\n          collect_pseudominimals_below_in_poset"], ["proof (prove)\nusing this:\n  x \\<in> P\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> x) f\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n  w \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` a))\n  \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n            dual_order.greater (?P .\\<^bold>\\<le> ?x) ?f;\n   ?f ` (?P .\\<^bold>\\<le> ?x) = Pow ?A;\n   order.greater_eq {y. pseudominimal_in (?P .\\<^bold>\\<le> ?x) y}\n    ?a\\<rbrakk>\n  \\<Longrightarrow> ?x \\<succeq>\n                    the_inv_into (?P .\\<^bold>\\<le> ?x) ?f\n                     (\\<Union> (?f ` ?a))\n  \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n            dual_order.greater (?P .\\<^bold>\\<le> ?x) ?f;\n   ?f ` (?P .\\<^bold>\\<le> ?x) = Pow ?A;\n   order.greater_eq {y. pseudominimal_in (?P .\\<^bold>\\<le> ?x) y}\n    ?a\\<rbrakk>\n  \\<Longrightarrow> the_inv_into (?P .\\<^bold>\\<le> ?x) ?f\n                     (\\<Union> (?f ` ?a))\n                    \\<in> ?P\n\ngoal (1 subgoal):\n 1. x \\<succeq> w &&& w \\<in> P", "by    auto"], ["proof (state)\nthis:\n  x \\<succeq> w\n  w \\<in> P\n\ngoal (2 subgoals):\n 1. order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> w) y} a\n 2. order.greater_eq a {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}", "show \"a \\<subseteq> {y. pseudominimal_in (P.\\<^bold>\\<le>w) y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> w) y} a", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> a \\<Longrightarrow>\n       x \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> a \\<Longrightarrow>\n       x \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}", "assume y: \"y \\<in> a\""], ["proof (state)\nthis:\n  y \\<in> a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> a \\<Longrightarrow>\n       x \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}", "show \"y \\<in> {y. pseudominimal_in (P.\\<^bold>\\<le>w) y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}", "proof (rule CollectI, rule pseudominimal_inI, rule CollectI, rule conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. y \\<in> P\n 2. w \\<succeq> y\n 3. y \\<noteq> bottom (P .\\<^bold>\\<le> w)\n 4. \\<And>z.\n       \\<lbrakk>z \\<in> P .\\<^bold>\\<le> w; y \\<succ> z\\<rbrakk>\n       \\<Longrightarrow> z = bottom (P .\\<^bold>\\<le> w)", "from y assms(4)"], ["proof (chain)\npicking this:\n  y \\<in> a\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a", "have y_le_x: \"y \\<in> P.\\<^bold>\\<le>x\""], ["proof (prove)\nusing this:\n  y \\<in> a\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n\ngoal (1 subgoal):\n 1. y \\<in> P .\\<^bold>\\<le> x", "using pseudominimal_inD1"], ["proof (prove)\nusing this:\n  y \\<in> a\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n  pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n\ngoal (1 subgoal):\n 1. y \\<in> P .\\<^bold>\\<le> x", "by fast"], ["proof (state)\nthis:\n  y \\<in> P .\\<^bold>\\<le> x\n\ngoal (4 subgoals):\n 1. y \\<in> P\n 2. w \\<succeq> y\n 3. y \\<noteq> bottom (P .\\<^bold>\\<le> w)\n 4. \\<And>z.\n       \\<lbrakk>z \\<in> P .\\<^bold>\\<le> w; y \\<succ> z\\<rbrakk>\n       \\<Longrightarrow> z = bottom (P .\\<^bold>\\<le> w)", "thus \"y\\<in>P\""], ["proof (prove)\nusing this:\n  y \\<in> P .\\<^bold>\\<le> x\n\ngoal (1 subgoal):\n 1. y \\<in> P", "by simp"], ["proof (state)\nthis:\n  y \\<in> P\n\ngoal (3 subgoals):\n 1. w \\<succeq> y\n 2. y \\<noteq> bottom (P .\\<^bold>\\<le> w)\n 3. \\<And>z.\n       \\<lbrakk>z \\<in> P .\\<^bold>\\<le> w; y \\<succ> z\\<rbrakk>\n       \\<Longrightarrow> z = bottom (P .\\<^bold>\\<le> w)", "from y w"], ["proof (chain)\npicking this:\n  y \\<in> a\n  w \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` a))", "show \"y \\<^bold>\\<le> w\""], ["proof (prove)\nusing this:\n  y \\<in> a\n  w \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` a))\n\ngoal (1 subgoal):\n 1. w \\<succeq> y", "using y_le_x Un_fa OrderingSetIso.inv_ordsetmap[OF assms(2)]\n              the_inv_into_f_f[OF OrderingSetIso.inj, OF assms(2), of y]"], ["proof (prove)\nusing this:\n  y \\<in> a\n  w \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` a))\n  y \\<in> P .\\<^bold>\\<le> x\n  \\<Union> (f ` a) \\<in> f ` (P .\\<^bold>\\<le> x)\n  \\<lbrakk>?a \\<in> f ` (P .\\<^bold>\\<le> x);\n   ?b \\<in> f ` (P .\\<^bold>\\<le> x); order.greater_eq ?b ?a\\<rbrakk>\n  \\<Longrightarrow> the_inv_into (P .\\<^bold>\\<le> x) f ?b \\<succeq>\n                    the_inv_into (P .\\<^bold>\\<le> x) f ?a\n  y \\<in> P .\\<^bold>\\<le> x \\<Longrightarrow>\n  the_inv_into (P .\\<^bold>\\<le> x) f (f y) = y\n\ngoal (1 subgoal):\n 1. w \\<succeq> y", "by    fastforce"], ["proof (state)\nthis:\n  w \\<succeq> y\n\ngoal (2 subgoals):\n 1. y \\<noteq> bottom (P .\\<^bold>\\<le> w)\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> P .\\<^bold>\\<le> w; y \\<succ> z\\<rbrakk>\n       \\<Longrightarrow> z = bottom (P .\\<^bold>\\<le> w)", "from assms(1) y assms(4)"], ["proof (chain)\npicking this:\n  x \\<in> P\n  y \\<in> a\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a", "show \"y \\<noteq> bottom (P.\\<^bold>\\<le>w)\""], ["proof (prove)\nusing this:\n  x \\<in> P\n  y \\<in> a\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n\ngoal (1 subgoal):\n 1. y \\<noteq> bottom (P .\\<^bold>\\<le> w)", "using w_P w_le_x has_bot_ltx bottom_below_in_relative\n              pseudominimal_ne_bottom"], ["proof (prove)\nusing this:\n  x \\<in> P\n  y \\<in> a\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n  w \\<in> P\n  x \\<succeq> w\n  has_bottom (P .\\<^bold>\\<le> x)\n  \\<lbrakk>has_bottom (?P .\\<^bold>\\<le> ?y); ?x \\<in> ?P;\n   ?y \\<succeq> ?x\\<rbrakk>\n  \\<Longrightarrow> bottom (?P .\\<^bold>\\<le> ?x) =\n                    bottom (?P .\\<^bold>\\<le> ?y)\n  pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<noteq> bottom ?P\n\ngoal (1 subgoal):\n 1. y \\<noteq> bottom (P .\\<^bold>\\<le> w)", "by    fast"], ["proof (state)\nthis:\n  y \\<noteq> bottom (P .\\<^bold>\\<le> w)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> P .\\<^bold>\\<le> w; y \\<succ> z\\<rbrakk>\n       \\<Longrightarrow> z = bottom (P .\\<^bold>\\<le> w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> P .\\<^bold>\\<le> w; y \\<succ> z\\<rbrakk>\n       \\<Longrightarrow> z = bottom (P .\\<^bold>\\<le> w)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> P .\\<^bold>\\<le> w; y \\<succ> z\\<rbrakk>\n       \\<Longrightarrow> z = bottom (P .\\<^bold>\\<le> w)", "assume z: \"z \\<in> P.\\<^bold>\\<le>w\" \"z\\<^bold><y\""], ["proof (state)\nthis:\n  z \\<in> P .\\<^bold>\\<le> w\n  y \\<succ> z\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> P .\\<^bold>\\<le> w; y \\<succ> z\\<rbrakk>\n       \\<Longrightarrow> z = bottom (P .\\<^bold>\\<le> w)", "with y assms(4)"], ["proof (chain)\npicking this:\n  y \\<in> a\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n  z \\<in> P .\\<^bold>\\<le> w\n  y \\<succ> z", "have \"z = bottom (P.\\<^bold>\\<le>x)\""], ["proof (prove)\nusing this:\n  y \\<in> a\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n  z \\<in> P .\\<^bold>\\<le> w\n  y \\<succ> z\n\ngoal (1 subgoal):\n 1. z = bottom (P .\\<^bold>\\<le> x)", "using w_le_x trans pseudominimal_inD2[ of \"P.\\<^bold>\\<le>x\" y z]"], ["proof (prove)\nusing this:\n  y \\<in> a\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n  z \\<in> P .\\<^bold>\\<le> w\n  y \\<succ> z\n  x \\<succeq> w\n  \\<lbrakk>?b \\<succeq> ?a; ?c \\<succeq> ?b\\<rbrakk>\n  \\<Longrightarrow> ?c \\<succeq> ?a\n  \\<lbrakk>pseudominimal_in (P .\\<^bold>\\<le> x) y;\n   z \\<in> P .\\<^bold>\\<le> x; y \\<succ> z\\<rbrakk>\n  \\<Longrightarrow> z = bottom (P .\\<^bold>\\<le> x)\n\ngoal (1 subgoal):\n 1. z = bottom (P .\\<^bold>\\<le> x)", "by fast"], ["proof (state)\nthis:\n  z = bottom (P .\\<^bold>\\<le> x)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> P .\\<^bold>\\<le> w; y \\<succ> z\\<rbrakk>\n       \\<Longrightarrow> z = bottom (P .\\<^bold>\\<le> w)", "moreover"], ["proof (state)\nthis:\n  z = bottom (P .\\<^bold>\\<le> x)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> P .\\<^bold>\\<le> w; y \\<succ> z\\<rbrakk>\n       \\<Longrightarrow> z = bottom (P .\\<^bold>\\<le> w)", "from assms(1)"], ["proof (chain)\npicking this:\n  x \\<in> P", "have \"bottom (P.\\<^bold>\\<le>w) = bottom (P.\\<^bold>\\<le>x)\""], ["proof (prove)\nusing this:\n  x \\<in> P\n\ngoal (1 subgoal):\n 1. bottom (P .\\<^bold>\\<le> w) = bottom (P .\\<^bold>\\<le> x)", "using has_bot_ltx w_P w_le_x bottom_below_in_relative"], ["proof (prove)\nusing this:\n  x \\<in> P\n  has_bottom (P .\\<^bold>\\<le> x)\n  w \\<in> P\n  x \\<succeq> w\n  \\<lbrakk>has_bottom (?P .\\<^bold>\\<le> ?y); ?x \\<in> ?P;\n   ?y \\<succeq> ?x\\<rbrakk>\n  \\<Longrightarrow> bottom (?P .\\<^bold>\\<le> ?x) =\n                    bottom (?P .\\<^bold>\\<le> ?y)\n\ngoal (1 subgoal):\n 1. bottom (P .\\<^bold>\\<le> w) = bottom (P .\\<^bold>\\<le> x)", "by fast"], ["proof (state)\nthis:\n  bottom (P .\\<^bold>\\<le> w) = bottom (P .\\<^bold>\\<le> x)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> P .\\<^bold>\\<le> w; y \\<succ> z\\<rbrakk>\n       \\<Longrightarrow> z = bottom (P .\\<^bold>\\<le> w)", "ultimately"], ["proof (chain)\npicking this:\n  z = bottom (P .\\<^bold>\\<le> x)\n  bottom (P .\\<^bold>\\<le> w) = bottom (P .\\<^bold>\\<le> x)", "show \"z = bottom (P.\\<^bold>\\<le>w)\""], ["proof (prove)\nusing this:\n  z = bottom (P .\\<^bold>\\<le> x)\n  bottom (P .\\<^bold>\\<le> w) = bottom (P .\\<^bold>\\<le> x)\n\ngoal (1 subgoal):\n 1. z = bottom (P .\\<^bold>\\<le> w)", "by simp"], ["proof (state)\nthis:\n  z = bottom (P .\\<^bold>\\<le> w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> w) y} a\n\ngoal (1 subgoal):\n 1. order.greater_eq a {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}", "show \"a \\<supseteq> {y. pseudominimal_in (P.\\<^bold>\\<le>w) y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq a {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w)\n                    y} \\<Longrightarrow>\n       x \\<in> a", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w)\n                    y} \\<Longrightarrow>\n       x \\<in> a", "assume \"v \\<in> {y. pseudominimal_in (P.\\<^bold>\\<le>w) y}\""], ["proof (state)\nthis:\n  v \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w)\n                    y} \\<Longrightarrow>\n       x \\<in> a", "hence \"pseudominimal_in (P.\\<^bold>\\<le>w) v\""], ["proof (prove)\nusing this:\n  v \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}\n\ngoal (1 subgoal):\n 1. pseudominimal_in (P .\\<^bold>\\<le> w) v", "by fast"], ["proof (state)\nthis:\n  pseudominimal_in (P .\\<^bold>\\<le> w) v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w)\n                    y} \\<Longrightarrow>\n       x \\<in> a", "moreover"], ["proof (state)\nthis:\n  pseudominimal_in (P .\\<^bold>\\<le> w) v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w)\n                    y} \\<Longrightarrow>\n       x \\<in> a", "hence v_pm_ltx: \"pseudominimal_in (P.\\<^bold>\\<le>x) v\""], ["proof (prove)\nusing this:\n  pseudominimal_in (P .\\<^bold>\\<le> w) v\n\ngoal (1 subgoal):\n 1. pseudominimal_in (P .\\<^bold>\\<le> x) v", "using has_bot_ltx w_P w_le_x pseudominimal_in_below_in"], ["proof (prove)\nusing this:\n  pseudominimal_in (P .\\<^bold>\\<le> w) v\n  has_bottom (P .\\<^bold>\\<le> x)\n  w \\<in> P\n  x \\<succeq> w\n  \\<lbrakk>has_bottom (?P .\\<^bold>\\<le> ?y); ?x \\<in> ?P; ?y \\<succeq> ?x;\n   pseudominimal_in (?P .\\<^bold>\\<le> ?x) ?w\\<rbrakk>\n  \\<Longrightarrow> pseudominimal_in (?P .\\<^bold>\\<le> ?y) ?w\n\ngoal (1 subgoal):\n 1. pseudominimal_in (P .\\<^bold>\\<le> x) v", "by fast"], ["proof (state)\nthis:\n  pseudominimal_in (P .\\<^bold>\\<le> x) v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w)\n                    y} \\<Longrightarrow>\n       x \\<in> a", "ultimately"], ["proof (chain)\npicking this:\n  pseudominimal_in (P .\\<^bold>\\<le> w) v\n  pseudominimal_in (P .\\<^bold>\\<le> x) v", "have  \"f v \\<le> (\\<Union>(f`a))\""], ["proof (prove)\nusing this:\n  pseudominimal_in (P .\\<^bold>\\<le> w) v\n  pseudominimal_in (P .\\<^bold>\\<le> x) v\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<Union> (f ` a)) (f v)", "using w pseudominimal_inD1[of _ v] pseudominimal_inD1[of _ v] w_le_x w_P\n            OrderingSetIso.ordsetmap[OF assms(2), of v w] Un_fa\n            OrderingSetIso.inj[OF assms(2)]\n            f_the_inv_into_f"], ["proof (prove)\nusing this:\n  pseudominimal_in (P .\\<^bold>\\<le> w) v\n  pseudominimal_in (P .\\<^bold>\\<le> x) v\n  w \\<equiv> the_inv_into (P .\\<^bold>\\<le> x) f (\\<Union> (f ` a))\n  pseudominimal_in ?P v \\<Longrightarrow> v \\<in> ?P\n  pseudominimal_in ?P v \\<Longrightarrow> v \\<in> ?P\n  x \\<succeq> w\n  w \\<in> P\n  \\<lbrakk>v \\<in> P .\\<^bold>\\<le> x; w \\<in> P .\\<^bold>\\<le> x;\n   w \\<succeq> v\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (f w) (f v)\n  \\<Union> (f ` a) \\<in> f ` (P .\\<^bold>\\<le> x)\n  inj_on f (P .\\<^bold>\\<le> x)\n  \\<lbrakk>inj_on ?f ?A; ?y \\<in> ?f ` ?A\\<rbrakk>\n  \\<Longrightarrow> ?f (the_inv_into ?A ?f ?y) = ?y\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<Union> (f ` a)) (f v)", "by    force"], ["proof (state)\nthis:\n  order.greater_eq (\\<Union> (f ` a)) (f v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w)\n                    y} \\<Longrightarrow>\n       x \\<in> a", "with assms(3)"], ["proof (chain)\npicking this:\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq (\\<Union> (f ` a)) (f v)", "obtain y where \"y\\<in>a\" \"f v \\<subseteq> f y\""], ["proof (prove)\nusing this:\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq (\\<Union> (f ` a)) (f v)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> a; order.greater_eq (f y) (f v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using v_pm_ltx has_bot_ltx pseudominimal_in_pow\n            OrderingSetIso.pseudominimal_map[OF assms(2)]"], ["proof (prove)\nusing this:\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  order.greater_eq (\\<Union> (f ` a)) (f v)\n  pseudominimal_in (P .\\<^bold>\\<le> x) v\n  has_bottom (P .\\<^bold>\\<le> x)\n  order.pseudominimal_in (Pow ?A) ?x \\<Longrightarrow>\n  \\<exists>a\\<in>?A. ?x = {a}\n  \\<lbrakk>has_bottom (P .\\<^bold>\\<le> x);\n   pseudominimal_in (P .\\<^bold>\\<le> x) ?x\\<rbrakk>\n  \\<Longrightarrow> order.pseudominimal_in (f ` (P .\\<^bold>\\<le> x)) (f ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> a; order.greater_eq (f y) (f v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    force"], ["proof (state)\nthis:\n  y \\<in> a\n  order.greater_eq (f y) (f v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. pseudominimal_in (P .\\<^bold>\\<le> w)\n                    y} \\<Longrightarrow>\n       x \\<in> a", "with assms(2,4)"], ["proof (chain)\npicking this:\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> x) f\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n  y \\<in> a\n  order.greater_eq (f y) (f v)", "show \"v \\<in> a\""], ["proof (prove)\nusing this:\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> x) f\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n  y \\<in> a\n  order.greater_eq (f y) (f v)\n\ngoal (1 subgoal):\n 1. v \\<in> a", "using v_pm_ltx pseudominimal_inD1 pseudominimal_comp[of _ v y]\n            OrderingSetIso.rev_ordsetmap[OF assms(2), of v y]"], ["proof (prove)\nusing this:\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater (P .\\<^bold>\\<le> x) f\n  order.greater_eq {y. pseudominimal_in (P .\\<^bold>\\<le> x) y} a\n  y \\<in> a\n  order.greater_eq (f y) (f v)\n  pseudominimal_in (P .\\<^bold>\\<le> x) v\n  pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n  \\<lbrakk>pseudominimal_in ?P v; pseudominimal_in ?P y;\n   y \\<succeq> v\\<rbrakk>\n  \\<Longrightarrow> v = y\n  \\<lbrakk>v \\<in> P .\\<^bold>\\<le> x; y \\<in> P .\\<^bold>\\<le> x;\n   order.greater_eq (f y) (f v)\\<rbrakk>\n  \\<Longrightarrow> y \\<succeq> v\n\ngoal (1 subgoal):\n 1. v \\<in> a", "by    fast"], ["proof (state)\nthis:\n  v \\<in> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq a {y. pseudominimal_in (P .\\<^bold>\\<le> w) y}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context ordering *)"], ["", "subsubsection \\<open>Lower bounds\\<close>"], ["", "context ordering\nbegin"], ["", "definition lbound_of :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  where \"lbound_of x y b \\<equiv> b\\<^bold>\\<le>x \\<and> b\\<^bold>\\<le>y\""], ["", "lemma lbound_ofI: \"b\\<^bold>\\<le>x \\<Longrightarrow> b\\<^bold>\\<le>y \\<Longrightarrow> lbound_of x y b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<succeq> b; y \\<succeq> b\\<rbrakk>\n    \\<Longrightarrow> lbound_of x y b", "using lbound_of_def"], ["proof (prove)\nusing this:\n  lbound_of ?x ?y ?b \\<equiv> ?x \\<succeq> ?b \\<and> ?y \\<succeq> ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<succeq> b; y \\<succeq> b\\<rbrakk>\n    \\<Longrightarrow> lbound_of x y b", "by fast"], ["", "lemma lbound_ofD1: \"lbound_of x y b \\<Longrightarrow> b\\<^bold>\\<le>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lbound_of x y b \\<Longrightarrow> x \\<succeq> b", "using lbound_of_def"], ["proof (prove)\nusing this:\n  lbound_of ?x ?y ?b \\<equiv> ?x \\<succeq> ?b \\<and> ?y \\<succeq> ?b\n\ngoal (1 subgoal):\n 1. lbound_of x y b \\<Longrightarrow> x \\<succeq> b", "by fast"], ["", "lemma lbound_ofD2: \"lbound_of x y b \\<Longrightarrow> b\\<^bold>\\<le>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lbound_of x y b \\<Longrightarrow> y \\<succeq> b", "using lbound_of_def"], ["proof (prove)\nusing this:\n  lbound_of ?x ?y ?b \\<equiv> ?x \\<succeq> ?b \\<and> ?y \\<succeq> ?b\n\ngoal (1 subgoal):\n 1. lbound_of x y b \\<Longrightarrow> y \\<succeq> b", "by fast"], ["", "definition glbound_in_of :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  where \"glbound_in_of P x y b \\<equiv>\n          b\\<in>P \\<and> lbound_of x y b \\<and> (\\<forall>a\\<in>P. lbound_of x y a \\<longrightarrow> a\\<^bold>\\<le>b)\""], ["", "lemma glbound_in_ofI:\n  \"\\<lbrakk> b\\<in>P; lbound_of x y b; \\<And>a. a\\<in>P \\<Longrightarrow> lbound_of x y a \\<Longrightarrow> a\\<^bold>\\<le>b \\<rbrakk> \\<Longrightarrow>\n    glbound_in_of P x y b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> P; lbound_of x y b;\n     \\<And>a.\n        \\<lbrakk>a \\<in> P; lbound_of x y a\\<rbrakk>\n        \\<Longrightarrow> b \\<succeq> a\\<rbrakk>\n    \\<Longrightarrow> glbound_in_of P x y b", "using glbound_in_of_def"], ["proof (prove)\nusing this:\n  glbound_in_of ?P ?x ?y ?b \\<equiv>\n  ?b \\<in> ?P \\<and>\n  lbound_of ?x ?y ?b \\<and>\n  (\\<forall>a\\<in>?P. lbound_of ?x ?y a \\<longrightarrow> ?b \\<succeq> a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> P; lbound_of x y b;\n     \\<And>a.\n        \\<lbrakk>a \\<in> P; lbound_of x y a\\<rbrakk>\n        \\<Longrightarrow> b \\<succeq> a\\<rbrakk>\n    \\<Longrightarrow> glbound_in_of P x y b", "by auto"], ["", "lemma glbound_in_ofD_in: \"glbound_in_of P x y b \\<Longrightarrow> b\\<in>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. glbound_in_of P x y b \\<Longrightarrow> b \\<in> P", "using glbound_in_of_def"], ["proof (prove)\nusing this:\n  glbound_in_of ?P ?x ?y ?b \\<equiv>\n  ?b \\<in> ?P \\<and>\n  lbound_of ?x ?y ?b \\<and>\n  (\\<forall>a\\<in>?P. lbound_of ?x ?y a \\<longrightarrow> ?b \\<succeq> a)\n\ngoal (1 subgoal):\n 1. glbound_in_of P x y b \\<Longrightarrow> b \\<in> P", "by fast"], ["", "lemma glbound_in_ofD_lbound: \"glbound_in_of P x y b \\<Longrightarrow> lbound_of x y b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. glbound_in_of P x y b \\<Longrightarrow> lbound_of x y b", "using glbound_in_of_def"], ["proof (prove)\nusing this:\n  glbound_in_of ?P ?x ?y ?b \\<equiv>\n  ?b \\<in> ?P \\<and>\n  lbound_of ?x ?y ?b \\<and>\n  (\\<forall>a\\<in>?P. lbound_of ?x ?y a \\<longrightarrow> ?b \\<succeq> a)\n\ngoal (1 subgoal):\n 1. glbound_in_of P x y b \\<Longrightarrow> lbound_of x y b", "by fast"], ["", "lemma glbound_in_ofD_glbound:\n  \"glbound_in_of P x y b \\<Longrightarrow> a\\<in>P \\<Longrightarrow> lbound_of x y a \\<Longrightarrow> a\\<^bold>\\<le>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>glbound_in_of P x y b; a \\<in> P; lbound_of x y a\\<rbrakk>\n    \\<Longrightarrow> b \\<succeq> a", "using glbound_in_of_def"], ["proof (prove)\nusing this:\n  glbound_in_of ?P ?x ?y ?b \\<equiv>\n  ?b \\<in> ?P \\<and>\n  lbound_of ?x ?y ?b \\<and>\n  (\\<forall>a\\<in>?P. lbound_of ?x ?y a \\<longrightarrow> ?b \\<succeq> a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>glbound_in_of P x y b; a \\<in> P; lbound_of x y a\\<rbrakk>\n    \\<Longrightarrow> b \\<succeq> a", "by fast"], ["", "lemma glbound_in_of_less_eq1: \"glbound_in_of P x y b \\<Longrightarrow> b\\<^bold>\\<le>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. glbound_in_of P x y b \\<Longrightarrow> x \\<succeq> b", "using glbound_in_ofD_lbound lbound_ofD1"], ["proof (prove)\nusing this:\n  glbound_in_of ?P ?x ?y ?b \\<Longrightarrow> lbound_of ?x ?y ?b\n  lbound_of ?x ?y ?b \\<Longrightarrow> ?x \\<succeq> ?b\n\ngoal (1 subgoal):\n 1. glbound_in_of P x y b \\<Longrightarrow> x \\<succeq> b", "by fast"], ["", "lemma glbound_in_of_less_eq2: \"glbound_in_of P x y b \\<Longrightarrow> b\\<^bold>\\<le>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. glbound_in_of P x y b \\<Longrightarrow> y \\<succeq> b", "using glbound_in_ofD_lbound lbound_ofD2"], ["proof (prove)\nusing this:\n  glbound_in_of ?P ?x ?y ?b \\<Longrightarrow> lbound_of ?x ?y ?b\n  lbound_of ?x ?y ?b \\<Longrightarrow> ?y \\<succeq> ?b\n\ngoal (1 subgoal):\n 1. glbound_in_of P x y b \\<Longrightarrow> y \\<succeq> b", "by fast"], ["", "lemma pseudominimal_in_below_in_less_eq_glbound:\n  assumes \"pseudominimal_in (P.\\<^bold>\\<le>x) w\" \"pseudominimal_in (P.\\<^bold>\\<le>y) w\"\n          \"glbound_in_of P x y b\"\n  shows   \"w \\<^bold>\\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<succeq> w", "using assms lbound_ofI glbound_in_ofD_glbound\n        pseudominimal_inD1[of \"P.\\<^bold>\\<le>x\"] pseudominimal_inD1[of \"P.\\<^bold>\\<le>y\"]"], ["proof (prove)\nusing this:\n  pseudominimal_in (P .\\<^bold>\\<le> x) w\n  pseudominimal_in (P .\\<^bold>\\<le> y) w\n  glbound_in_of P x y b\n  \\<lbrakk>?x \\<succeq> ?b; ?y \\<succeq> ?b\\<rbrakk>\n  \\<Longrightarrow> lbound_of ?x ?y ?b\n  \\<lbrakk>glbound_in_of ?P ?x ?y ?b; ?a \\<in> ?P;\n   lbound_of ?x ?y ?a\\<rbrakk>\n  \\<Longrightarrow> ?b \\<succeq> ?a\n  pseudominimal_in (P .\\<^bold>\\<le> x) ?x \\<Longrightarrow>\n  ?x \\<in> P .\\<^bold>\\<le> x\n  pseudominimal_in (P .\\<^bold>\\<le> y) ?x \\<Longrightarrow>\n  ?x \\<in> P .\\<^bold>\\<le> y\n\ngoal (1 subgoal):\n 1. b \\<succeq> w", "by    fast"], ["", "end"], ["", "(* context ordering *)"], ["", "subsubsection \\<open>Simplex-like posets\\<close>"], ["", "text \\<open>Define a poset to be simplex-like if it is isomorphic to the power set of some set.\\<close>"], ["", "context ordering\nbegin"], ["", "definition simplex_like :: \"'a set \\<Rightarrow> bool\"\n  where \"simplex_like P \\<equiv> finite P \\<and>\n          (\\<exists>f A::nat set.\n            OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) P f \\<and> f`P = Pow A\n          )\""], ["", "lemma simplex_likeI:\n  assumes \"finite P\" \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) P f\"\n          \"f`P = Pow (A::nat set)\"\n  shows   \"simplex_like P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simplex_like P", "using assms simplex_like_def"], ["proof (prove)\nusing this:\n  finite P\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater P f\n  f ` P = Pow A\n  simplex_like ?P \\<equiv>\n  finite ?P \\<and>\n  (\\<exists>f A.\n      OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n       dual_order.greater ?P f \\<and>\n      f ` ?P = Pow A)\n\ngoal (1 subgoal):\n 1. simplex_like P", "by auto"], ["", "lemma simplex_likeD_finite: \"simplex_like P \\<Longrightarrow> finite P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simplex_like P \\<Longrightarrow> finite P", "using simplex_like_def"], ["proof (prove)\nusing this:\n  simplex_like ?P \\<equiv>\n  finite ?P \\<and>\n  (\\<exists>f A.\n      OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n       dual_order.greater ?P f \\<and>\n      f ` ?P = Pow A)\n\ngoal (1 subgoal):\n 1. simplex_like P \\<Longrightarrow> finite P", "by simp"], ["", "lemma simplex_likeD_iso:\n  \"simplex_like P \\<Longrightarrow>\n    \\<exists>f A::nat set. OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) P f \\<and> f`P = Pow A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simplex_like P \\<Longrightarrow>\n    \\<exists>f A.\n       OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n        dual_order.greater P f \\<and>\n       f ` P = Pow A", "using simplex_like_def"], ["proof (prove)\nusing this:\n  simplex_like ?P \\<equiv>\n  finite ?P \\<and>\n  (\\<exists>f A.\n      OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n       dual_order.greater ?P f \\<and>\n      f ` ?P = Pow A)\n\ngoal (1 subgoal):\n 1. simplex_like P \\<Longrightarrow>\n    \\<exists>f A.\n       OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n        dual_order.greater P f \\<and>\n       f ` P = Pow A", "by simp"], ["", "lemma simplex_like_has_bottom: \"simplex_like P \\<Longrightarrow> has_bottom P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simplex_like P \\<Longrightarrow> has_bottom P", "using simplex_likeD_iso has_bottom_pow OrderingSetIso.pullback_has_bottom"], ["proof (prove)\nusing this:\n  simplex_like ?P \\<Longrightarrow>\n  \\<exists>f A.\n     OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n      dual_order.greater ?P f \\<and>\n     f ` ?P = Pow A\n  order.has_bottom (Pow ?A)\n  \\<lbrakk>OrderingSetIso ?less_eq ?less ?less_eq' ?less' ?P ?f;\n   ordering.has_bottom ?less_eq' (?f ` ?P)\\<rbrakk>\n  \\<Longrightarrow> ordering.has_bottom ?less_eq ?P\n\ngoal (1 subgoal):\n 1. simplex_like P \\<Longrightarrow> has_bottom P", "by    fastforce"], ["", "lemma simplex_like_no_pseudominimal_imp_singleton:\n  assumes \"simplex_like P\" \"\\<And>x. \\<not> pseudominimal_in P x\"\n  shows \"\\<exists>p. P = {p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. P = {p}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. P = {p}", "obtain f and A::\"nat set\"\n    where fA: \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) P f\" \"f`P = Pow A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f A.\n        \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><)\n                  dual_order.greater_eq dual_order.greater P f;\n         f ` P = Pow A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using simplex_likeD_iso[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<exists>f A.\n     OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n      dual_order.greater P f \\<and>\n     f ` P = Pow A\n\ngoal (1 subgoal):\n 1. (\\<And>f A.\n        \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><)\n                  dual_order.greater_eq dual_order.greater P f;\n         f ` P = Pow A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater P f\n  f ` P = Pow A\n\ngoal (1 subgoal):\n 1. \\<exists>p. P = {p}", "define e where e: \"e \\<equiv> {}:: nat set\""], ["proof (state)\nthis:\n  e \\<equiv> {}\n\ngoal (1 subgoal):\n 1. \\<exists>p. P = {p}", "with fA(2)"], ["proof (chain)\npicking this:\n  f ` P = Pow A\n  e \\<equiv> {}", "have \"e \\<in> f`P\""], ["proof (prove)\nusing this:\n  f ` P = Pow A\n  e \\<equiv> {}\n\ngoal (1 subgoal):\n 1. e \\<in> f ` P", "using Pow_bottom"], ["proof (prove)\nusing this:\n  f ` P = Pow A\n  e \\<equiv> {}\n  {} \\<in> Pow ?B\n\ngoal (1 subgoal):\n 1. e \\<in> f ` P", "by simp"], ["proof (state)\nthis:\n  e \\<in> f ` P\n\ngoal (1 subgoal):\n 1. \\<exists>p. P = {p}", "from this"], ["proof (chain)\npicking this:\n  e \\<in> f ` P", "obtain p where \"p \\<in> P\" \"f p = e\""], ["proof (prove)\nusing this:\n  e \\<in> f ` P\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> P; f p = e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  p \\<in> P\n  f p = e\n\ngoal (1 subgoal):\n 1. \\<exists>p. P = {p}", "have \"\\<And>x. \\<not> order.pseudominimal_in (Pow A) {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> order.pseudominimal_in (Pow A) {x}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. order.pseudominimal_in (Pow A) {x} \\<Longrightarrow> False", "fix x::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. order.pseudominimal_in (Pow A) {x} \\<Longrightarrow> False", "assume \"order.pseudominimal_in (Pow A) {x}\""], ["proof (state)\nthis:\n  order.pseudominimal_in (Pow A) {x}\n\ngoal (1 subgoal):\n 1. \\<And>x. order.pseudominimal_in (Pow A) {x} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  order.pseudominimal_in (Pow A) {x}\n\ngoal (1 subgoal):\n 1. \\<And>x. order.pseudominimal_in (Pow A) {x} \\<Longrightarrow> False", "with fA(2)"], ["proof (chain)\npicking this:\n  f ` P = Pow A\n  order.pseudominimal_in (Pow A) {x}", "have \"{x} \\<in> f`P\""], ["proof (prove)\nusing this:\n  f ` P = Pow A\n  order.pseudominimal_in (Pow A) {x}\n\ngoal (1 subgoal):\n 1. {x} \\<in> f ` P", "using order.pseudominimal_inD1"], ["proof (prove)\nusing this:\n  f ` P = Pow A\n  order.pseudominimal_in (Pow A) {x}\n  order.pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n\ngoal (1 subgoal):\n 1. {x} \\<in> f ` P", "by fastforce"], ["proof (state)\nthis:\n  {x} \\<in> f ` P\n\ngoal (1 subgoal):\n 1. \\<And>x. order.pseudominimal_in (Pow A) {x} \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  order.pseudominimal_in (Pow A) {x}\n  {x} \\<in> f ` P", "show False"], ["proof (prove)\nusing this:\n  order.pseudominimal_in (Pow A) {x}\n  {x} \\<in> f ` P\n\ngoal (1 subgoal):\n 1. False", "using assms fA simplex_like_has_bottom\n            OrderingSetIso.pullback_pseudominimal_in"], ["proof (prove)\nusing this:\n  order.pseudominimal_in (Pow A) {x}\n  {x} \\<in> f ` P\n  simplex_like P\n  \\<not> pseudominimal_in P ?x\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater P f\n  f ` P = Pow A\n  simplex_like ?P \\<Longrightarrow> has_bottom ?P\n  \\<lbrakk>OrderingSetIso ?less_eq ?less ?less_eq' ?less' ?P ?f;\n   ordering.has_bottom ?less_eq ?P; ?x \\<in> ?P;\n   ordering.pseudominimal_in ?less_eq' ?less' (?f ` ?P) (?f ?x)\\<rbrakk>\n  \\<Longrightarrow> ordering.pseudominimal_in ?less_eq ?less ?P ?x\n\ngoal (1 subgoal):\n 1. False", "by    fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> order.pseudominimal_in (Pow A) {?x}\n\ngoal (1 subgoal):\n 1. \\<exists>p. P = {p}", "with e fA(2)"], ["proof (chain)\npicking this:\n  e \\<equiv> {}\n  f ` P = Pow A\n  \\<not> order.pseudominimal_in (Pow A) {?x}", "show ?thesis"], ["proof (prove)\nusing this:\n  e \\<equiv> {}\n  f ` P = Pow A\n  \\<not> order.pseudominimal_in (Pow A) {?x}\n\ngoal (1 subgoal):\n 1. \\<exists>p. P = {p}", "using no_pseudominimal_in_pow_is_empty\n          inj_on_to_singleton[OF OrderingSetIso.inj, OF fA(1)]"], ["proof (prove)\nusing this:\n  e \\<equiv> {}\n  f ` P = Pow A\n  \\<not> order.pseudominimal_in (Pow A) {?x}\n  (\\<And>x. \\<not> order.pseudominimal_in (Pow ?A) {x}) \\<Longrightarrow>\n  ?A = {}\n  f ` P = {?b} \\<Longrightarrow> \\<exists>a. P = {a}\n\ngoal (1 subgoal):\n 1. \\<exists>p. P = {p}", "by    force"], ["proof (state)\nthis:\n  \\<exists>p. P = {p}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simplex_like_no_pseudominimal_in_below_in_imp_singleton:\n  \"\\<lbrakk> x\\<in>P; simplex_like (P.\\<^bold>\\<le>x); \\<And>z. \\<not> pseudominimal_in (P.\\<^bold>\\<le>x) z \\<rbrakk> \\<Longrightarrow>\n    P.\\<^bold>\\<le>x = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> P; simplex_like (P .\\<^bold>\\<le> x);\n     \\<And>z. \\<not> pseudominimal_in (P .\\<^bold>\\<le> x) z\\<rbrakk>\n    \\<Longrightarrow> P .\\<^bold>\\<le> x = {x}", "using simplex_like_no_pseudominimal_imp_singleton below_in_singleton[of x P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>simplex_like ?P; \\<And>x. \\<not> pseudominimal_in ?P x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p. ?P = {p}\n  \\<lbrakk>x \\<in> P; order.greater_eq {?y} (P .\\<^bold>\\<le> x)\\<rbrakk>\n  \\<Longrightarrow> ?y = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> P; simplex_like (P .\\<^bold>\\<le> x);\n     \\<And>z. \\<not> pseudominimal_in (P .\\<^bold>\\<le> x) z\\<rbrakk>\n    \\<Longrightarrow> P .\\<^bold>\\<le> x = {x}", "by    fast"], ["", "lemma pseudo_simplex_like_has_bottom:\n  \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) P f \\<Longrightarrow> f`P = Pow A \\<Longrightarrow>\n    has_bottom P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><)\n              dual_order.greater_eq dual_order.greater P f;\n     f ` P = Pow A\\<rbrakk>\n    \\<Longrightarrow> has_bottom P", "using has_bottom_pow OrderingSetIso.pullback_has_bottom"], ["proof (prove)\nusing this:\n  order.has_bottom (Pow ?A)\n  \\<lbrakk>OrderingSetIso ?less_eq ?less ?less_eq' ?less' ?P ?f;\n   ordering.has_bottom ?less_eq' (?f ` ?P)\\<rbrakk>\n  \\<Longrightarrow> ordering.has_bottom ?less_eq ?P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><)\n              dual_order.greater_eq dual_order.greater P f;\n     f ` P = Pow A\\<rbrakk>\n    \\<Longrightarrow> has_bottom P", "by fastforce"], ["", "lemma pseudo_simplex_like_above_pseudominimal_is_top:\n  assumes \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) P f\" \"f`P = Pow A\" \"t\\<in>P\"\n          \"\\<And>x. pseudominimal_in P x \\<Longrightarrow> x \\<^bold>\\<le> t\"\n  shows   \"f t = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f t = A", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq A (f t)\n 2. order.greater_eq (f t) A", "from assms(2,3)"], ["proof (chain)\npicking this:\n  f ` P = Pow A\n  t \\<in> P", "show \"f t \\<subseteq> A\""], ["proof (prove)\nusing this:\n  f ` P = Pow A\n  t \\<in> P\n\ngoal (1 subgoal):\n 1. order.greater_eq A (f t)", "by fast"], ["proof (state)\nthis:\n  order.greater_eq A (f t)\n\ngoal (1 subgoal):\n 1. order.greater_eq (f t) A", "show \"A \\<subseteq> f t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (f t) A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> f t", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> f t", "assume \"a\\<in>A\""], ["proof (state)\nthis:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> f t", "moreover"], ["proof (state)\nthis:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> f t", "with assms(2)"], ["proof (chain)\npicking this:\n  f ` P = Pow A\n  a \\<in> A", "have \"{a} \\<in> f`P\""], ["proof (prove)\nusing this:\n  f ` P = Pow A\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. {a} \\<in> f ` P", "by simp"], ["proof (state)\nthis:\n  {a} \\<in> f ` P\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x \\<in> f t", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> A\n  {a} \\<in> f ` P", "show \"a \\<in> f t\""], ["proof (prove)\nusing this:\n  a \\<in> A\n  {a} \\<in> f ` P\n\ngoal (1 subgoal):\n 1. a \\<in> f t", "using assms pseudominimal_in_pow_singleton[of a A]\n            pseudo_simplex_like_has_bottom[of P f]\n            OrderingSetIso.pullback_pseudominimal_in[OF assms(1)]\n            OrderingSetIso.ordsetmap[OF assms(1), of _ t]"], ["proof (prove)\nusing this:\n  a \\<in> A\n  {a} \\<in> f ` P\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater P f\n  f ` P = Pow A\n  t \\<in> P\n  pseudominimal_in P ?x \\<Longrightarrow> t \\<succeq> ?x\n  a \\<in> A \\<Longrightarrow> order.pseudominimal_in (Pow A) {a}\n  \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n            dual_order.greater P f;\n   f ` P = Pow ?A\\<rbrakk>\n  \\<Longrightarrow> has_bottom P\n  \\<lbrakk>has_bottom P; ?x \\<in> P;\n   order.pseudominimal_in (f ` P) (f ?x)\\<rbrakk>\n  \\<Longrightarrow> pseudominimal_in P ?x\n  \\<lbrakk>?a \\<in> P; t \\<in> P; t \\<succeq> ?a\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (f t) (f ?a)\n\ngoal (1 subgoal):\n 1. a \\<in> f t", "by    force"], ["proof (state)\nthis:\n  a \\<in> f t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq (f t) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pseudo_simplex_like_below_in_above_pseudominimal_is_top:\n  assumes \"x\\<in>P\" \"OrderingSetIso less_eq less (\\<subseteq>) (\\<subset>) (P.\\<^bold>\\<le>x) f\"\n          \"f`(P.\\<^bold>\\<le>x) = Pow A\" \"t \\<in> P.\\<^bold>\\<le>x\"\n          \"\\<And>y. pseudominimal_in (P.\\<^bold>\\<le>x) y \\<Longrightarrow> y \\<^bold>\\<le> t\"\n  shows   \"t = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = x", "using   assms(1,3-5)\n          pseudo_simplex_like_above_pseudominimal_is_top[OF assms(2)]\n          below_in_refl[of x P] OrderingSetIso.ordsetmap[OF assms(2), of t x]\n          inj_onD[OF OrderingSetIso.inj[OF assms(2)], of t x]"], ["proof (prove)\nusing this:\n  x \\<in> P\n  f ` (P .\\<^bold>\\<le> x) = Pow A\n  t \\<in> P .\\<^bold>\\<le> x\n  pseudominimal_in (P .\\<^bold>\\<le> x) ?y \\<Longrightarrow> t \\<succeq> ?y\n  \\<lbrakk>f ` (P .\\<^bold>\\<le> x) = Pow ?A; ?t \\<in> P .\\<^bold>\\<le> x;\n   \\<And>xa.\n      pseudominimal_in (P .\\<^bold>\\<le> x) xa \\<Longrightarrow>\n      ?t \\<succeq> xa\\<rbrakk>\n  \\<Longrightarrow> f ?t = ?A\n  x \\<in> P \\<Longrightarrow> x \\<in> P .\\<^bold>\\<le> x\n  \\<lbrakk>t \\<in> P .\\<^bold>\\<le> x; x \\<in> P .\\<^bold>\\<le> x;\n   x \\<succeq> t\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (f x) (f t)\n  \\<lbrakk>f t = f x; t \\<in> P .\\<^bold>\\<le> x;\n   x \\<in> P .\\<^bold>\\<le> x\\<rbrakk>\n  \\<Longrightarrow> t = x\n\ngoal (1 subgoal):\n 1. t = x", "by      auto"], ["", "lemma simplex_like_below_in_above_pseudominimal_is_top:\n  assumes \"x\\<in>P\" \"simplex_like (P.\\<^bold>\\<le>x)\" \"t \\<in> P.\\<^bold>\\<le>x\"\n          \"\\<And>y. pseudominimal_in (P.\\<^bold>\\<le>x) y \\<Longrightarrow> y \\<^bold>\\<le> t\"\n  shows   \"t = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = x", "using assms simplex_likeD_iso\n        pseudo_simplex_like_below_in_above_pseudominimal_is_top[of x P _ _ t]"], ["proof (prove)\nusing this:\n  x \\<in> P\n  simplex_like (P .\\<^bold>\\<le> x)\n  t \\<in> P .\\<^bold>\\<le> x\n  pseudominimal_in (P .\\<^bold>\\<le> x) ?y \\<Longrightarrow> t \\<succeq> ?y\n  simplex_like ?P \\<Longrightarrow>\n  \\<exists>f A.\n     OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n      dual_order.greater ?P f \\<and>\n     f ` ?P = Pow A\n  \\<lbrakk>x \\<in> P;\n   OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n    dual_order.greater (P .\\<^bold>\\<le> x) ?f;\n   ?f ` (P .\\<^bold>\\<le> x) = Pow ?A; t \\<in> P .\\<^bold>\\<le> x;\n   \\<And>y.\n      pseudominimal_in (P .\\<^bold>\\<le> x) y \\<Longrightarrow>\n      t \\<succeq> y\\<rbrakk>\n  \\<Longrightarrow> t = x\n\ngoal (1 subgoal):\n 1. t = x", "by    blast"], ["", "end"], ["", "(* context ordering *)"], ["", "lemma (in OrderingSetIso) simplex_like_map:\n  assumes \"domain.simplex_like P\"\n  shows   \"codomain.simplex_like (f`P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomain.simplex_like (f ` P)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. codomain.simplex_like (f ` P)", "obtain g::\"'a \\<Rightarrow> nat set\" and A::\"nat set\"\n    where gA: \"OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) (\\<subseteq>) (\\<subset>) P g\" \"g`P = Pow A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g A.\n        \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><)\n                  dual_order.greater_eq dual_order.greater P g;\n         g ` P = Pow A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using domain.simplex_likeD_iso[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>f A.\n     OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n      dual_order.greater P f \\<and>\n     f ` P = Pow A\n\ngoal (1 subgoal):\n 1. (\\<And>g A.\n        \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><)\n                  dual_order.greater_eq dual_order.greater P g;\n         g ` P = Pow A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater P g\n  g ` P = Pow A\n\ngoal (1 subgoal):\n 1. codomain.simplex_like (f ` P)", "from gA(1) inj"], ["proof (chain)\npicking this:\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater P g\n  inj_on f P", "have  \"OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) (\\<subseteq>) (\\<subset>) (f`P)\n            (g \\<circ> (the_inv_into P f))\""], ["proof (prove)\nusing this:\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater P g\n  inj_on f P\n\ngoal (1 subgoal):\n 1. OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) dual_order.greater_eq\n     dual_order.greater (f ` P) (g \\<circ> the_inv_into P f)", "using OrderingSetIso.iso_comp[OF inv_iso] the_inv_into_onto"], ["proof (prove)\nusing this:\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater P g\n  inj_on f P\n  \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) ?less_eq'' ?less'' ?Q\n            ?g;\n   order.greater_eq ?Q (the_inv_into P f ` f ` P)\\<rbrakk>\n  \\<Longrightarrow> OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) ?less_eq''\n                     ?less'' (f ` P) (?g \\<circ> the_inv_into P f)\n  inj_on ?f ?A \\<Longrightarrow> the_inv_into ?A ?f ` ?f ` ?A = ?A\n\ngoal (1 subgoal):\n 1. OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) dual_order.greater_eq\n     dual_order.greater (f ` P) (g \\<circ> the_inv_into P f)", "by    fast"], ["proof (state)\nthis:\n  OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) dual_order.greater_eq\n   dual_order.greater (f ` P) (g \\<circ> the_inv_into P f)\n\ngoal (1 subgoal):\n 1. codomain.simplex_like (f ` P)", "moreover"], ["proof (state)\nthis:\n  OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) dual_order.greater_eq\n   dual_order.greater (f ` P) (g \\<circ> the_inv_into P f)\n\ngoal (1 subgoal):\n 1. codomain.simplex_like (f ` P)", "from gA(2) inj"], ["proof (chain)\npicking this:\n  g ` P = Pow A\n  inj_on f P", "have \"(g \\<circ> (the_inv_into P f)) ` (f`P) = Pow A\""], ["proof (prove)\nusing this:\n  g ` P = Pow A\n  inj_on f P\n\ngoal (1 subgoal):\n 1. (g \\<circ> the_inv_into P f) ` f ` P = Pow A", "using the_inv_into_onto"], ["proof (prove)\nusing this:\n  g ` P = Pow A\n  inj_on f P\n  inj_on ?f ?A \\<Longrightarrow> the_inv_into ?A ?f ` ?f ` ?A = ?A\n\ngoal (1 subgoal):\n 1. (g \\<circ> the_inv_into P f) ` f ` P = Pow A", "by (auto simp add: image_comp[THEN sym])"], ["proof (state)\nthis:\n  (g \\<circ> the_inv_into P f) ` f ` P = Pow A\n\ngoal (1 subgoal):\n 1. codomain.simplex_like (f ` P)", "moreover"], ["proof (state)\nthis:\n  (g \\<circ> the_inv_into P f) ` f ` P = Pow A\n\ngoal (1 subgoal):\n 1. codomain.simplex_like (f ` P)", "from assms"], ["proof (chain)\npicking this:\n  domain.simplex_like P", "have \"finite (f`P)\""], ["proof (prove)\nusing this:\n  domain.simplex_like P\n\ngoal (1 subgoal):\n 1. finite (f ` P)", "using domain.simplex_likeD_finite"], ["proof (prove)\nusing this:\n  domain.simplex_like P\n  domain.simplex_like ?P \\<Longrightarrow> finite ?P\n\ngoal (1 subgoal):\n 1. finite (f ` P)", "by fast"], ["proof (state)\nthis:\n  finite (f ` P)\n\ngoal (1 subgoal):\n 1. codomain.simplex_like (f ` P)", "ultimately"], ["proof (chain)\npicking this:\n  OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) dual_order.greater_eq\n   dual_order.greater (f ` P) (g \\<circ> the_inv_into P f)\n  (g \\<circ> the_inv_into P f) ` f ` P = Pow A\n  finite (f ` P)", "show ?thesis"], ["proof (prove)\nusing this:\n  OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) dual_order.greater_eq\n   dual_order.greater (f ` P) (g \\<circ> the_inv_into P f)\n  (g \\<circ> the_inv_into P f) ` f ` P = Pow A\n  finite (f ` P)\n\ngoal (1 subgoal):\n 1. codomain.simplex_like (f ` P)", "by (auto intro: codomain.simplex_likeI)"], ["proof (state)\nthis:\n  codomain.simplex_like (f ` P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in OrderingSetIso) pullback_simplex_like:\n  assumes \"finite P\" \"codomain.simplex_like (f`P)\"\n  shows   \"domain.simplex_like P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domain.simplex_like P", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. domain.simplex_like P", "obtain g::\"'b \\<Rightarrow> nat set\" and A::\"nat set\"\n    where gA:  \"OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) (\\<subseteq>) (\\<subset>) (f`P) g\"\n               \"g`(f`P) = Pow A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g A.\n        \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*)\n                  dual_order.greater_eq dual_order.greater (f ` P) g;\n         g ` f ` P = Pow A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using codomain.simplex_likeD_iso[OF assms(2)]"], ["proof (prove)\nusing this:\n  \\<exists>fa A.\n     OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) dual_order.greater_eq\n      dual_order.greater (f ` P) fa \\<and>\n     fa ` f ` P = Pow A\n\ngoal (1 subgoal):\n 1. (\\<And>g A.\n        \\<lbrakk>OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*)\n                  dual_order.greater_eq dual_order.greater (f ` P) g;\n         g ` f ` P = Pow A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  OrderingSetIso (\\<^bold>\\<le>*) (\\<^bold><*) dual_order.greater_eq\n   dual_order.greater (f ` P) g\n  g ` f ` P = Pow A\n\ngoal (1 subgoal):\n 1. domain.simplex_like P", "from assms(1) gA(2)"], ["proof (chain)\npicking this:\n  finite P\n  g ` f ` P = Pow A", "show ?thesis"], ["proof (prove)\nusing this:\n  finite P\n  g ` f ` P = Pow A\n\ngoal (1 subgoal):\n 1. domain.simplex_like P", "using iso_comp[OF gA(1)]"], ["proof (prove)\nusing this:\n  finite P\n  g ` f ` P = Pow A\n  order.greater_eq (f ` P) (f ` P) \\<Longrightarrow>\n  OrderingSetIso (\\<^bold>\\<le>) (\\<^bold><) dual_order.greater_eq\n   dual_order.greater P (g \\<circ> f)\n\ngoal (1 subgoal):\n 1. domain.simplex_like P", "by    (auto intro: domain.simplex_likeI simp add: image_comp)"], ["proof (state)\nthis:\n  domain.simplex_like P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simplex_like_pow:\n  assumes \"finite A\"\n  shows \"order.simplex_like (Pow A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.simplex_like (Pow A)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. order.simplex_like (Pow A)", "from assms"], ["proof (chain)\npicking this:\n  finite A", "obtain f::\"'a\\<Rightarrow>nat\" where \"inj_on f A\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<And>f. inj_on f A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using finite_imp_inj_to_nat_seg[of A]"], ["proof (prove)\nusing this:\n  finite A\n  finite A \\<Longrightarrow>\n  \\<exists>f n. f ` A = {i. order.greater n i} \\<and> inj_on f A\n\ngoal (1 subgoal):\n 1. (\\<And>f. inj_on f A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  inj_on f A\n\ngoal (1 subgoal):\n 1. order.simplex_like (Pow A)", "hence \"subset_ordering_iso (Pow A) ((`) f)\""], ["proof (prove)\nusing this:\n  inj_on f A\n\ngoal (1 subgoal):\n 1. OrderingSetIso dual_order.greater_eq dual_order.greater\n     dual_order.greater_eq dual_order.greater (Pow A) ((`) f)", "using induced_pow_fun_subset_ordering_iso"], ["proof (prove)\nusing this:\n  inj_on f A\n  inj_on ?f ?A \\<Longrightarrow>\n  OrderingSetIso dual_order.greater_eq dual_order.greater\n   dual_order.greater_eq dual_order.greater (Pow ?A) ((`) ?f)\n\ngoal (1 subgoal):\n 1. OrderingSetIso dual_order.greater_eq dual_order.greater\n     dual_order.greater_eq dual_order.greater (Pow A) ((`) f)", "by fast"], ["proof (state)\nthis:\n  OrderingSetIso dual_order.greater_eq dual_order.greater\n   dual_order.greater_eq dual_order.greater (Pow A) ((`) f)\n\ngoal (1 subgoal):\n 1. order.simplex_like (Pow A)", "with assms"], ["proof (chain)\npicking this:\n  finite A\n  OrderingSetIso dual_order.greater_eq dual_order.greater\n   dual_order.greater_eq dual_order.greater (Pow A) ((`) f)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite A\n  OrderingSetIso dual_order.greater_eq dual_order.greater\n   dual_order.greater_eq dual_order.greater (Pow A) ((`) f)\n\ngoal (1 subgoal):\n 1. order.simplex_like (Pow A)", "using induced_pow_fun_surj"], ["proof (prove)\nusing this:\n  finite A\n  OrderingSetIso dual_order.greater_eq dual_order.greater\n   dual_order.greater_eq dual_order.greater (Pow A) ((`) f)\n  ?f \\<turnstile> Pow ?A = Pow (?f ` ?A)\n\ngoal (1 subgoal):\n 1. order.simplex_like (Pow A)", "by (blast intro: order.simplex_likeI)"], ["proof (state)\nthis:\n  order.simplex_like (Pow A)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>The superset ordering\\<close>"], ["", "abbreviation \"supset_has_bottom       \\<equiv> ordering.has_bottom       (\\<supseteq>)\""], ["", "abbreviation \"supset_bottom           \\<equiv> ordering.bottom           (\\<supseteq>)\""], ["", "abbreviation \"supset_lbound_of        \\<equiv> ordering.lbound_of        (\\<supseteq>)\""], ["", "abbreviation \"supset_glbound_in_of    \\<equiv> ordering.glbound_in_of    (\\<supseteq>)\""], ["", "abbreviation \"supset_simplex_like     \\<equiv> ordering.simplex_like     (\\<supseteq>) (\\<supset>)\""], ["", "abbreviation \"supset_pseudominimal_in \\<equiv>\n                ordering.pseudominimal_in (\\<supseteq>) (\\<supset>)\""], ["", "abbreviation supset_below_in :: \"'a set set \\<Rightarrow> 'a set \\<Rightarrow> 'a set set\" (infix \".\\<supseteq>\" 70)\n  where \"P.\\<supseteq>A \\<equiv> ordering.below_in (\\<supseteq>) P A\""], ["", "lemma supset_poset: \"ordering (\\<supseteq>) (\\<supset>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordering order.greater_eq order.greater", ".."], ["", "lemmas supset_bottomI            = ordering.bottomI            [OF supset_poset]"], ["", "lemmas supset_pseudominimal_inI  = ordering.pseudominimal_inI  [OF supset_poset]"], ["", "lemmas supset_pseudominimal_inD1 = ordering.pseudominimal_inD1 [OF supset_poset]"], ["", "lemmas supset_pseudominimal_inD2 = ordering.pseudominimal_inD2 [OF supset_poset]"], ["", "lemmas supset_lbound_ofI         = ordering.lbound_ofI         [OF supset_poset]"], ["", "lemmas supset_lbound_of_def      = ordering.lbound_of_def      [OF supset_poset]"], ["", "lemmas supset_glbound_in_ofI     = ordering.glbound_in_ofI     [OF supset_poset]"], ["", "lemmas supset_pseudominimal_ne_bottom =\n  ordering.pseudominimal_ne_bottom[OF supset_poset]"], ["", "lemmas supset_has_bottom_pseudominimal_in_below_inI =\n  ordering.has_bottom_pseudominimal_in_below_inI[OF supset_poset]"], ["", "lemmas supset_has_bottom_pseudominimal_in_below_in =\n  ordering.has_bottom_pseudominimal_in_below_in[OF supset_poset]"], ["", "lemma OrderingSetIso_pow_complement:\n  \"OrderingSetIso (\\<supseteq>) (\\<supset>) (\\<subseteq>) (\\<subset>) (Pow A) ((-) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetIso order.greater_eq order.greater dual_order.greater_eq\n     dual_order.greater (Pow A) ((-) A)", "using inj_on_minus_set"], ["proof (prove)\nusing this:\n  inj_on ((-) ?A) (Pow ?A)\n\ngoal (1 subgoal):\n 1. OrderingSetIso order.greater_eq order.greater dual_order.greater_eq\n     dual_order.greater (Pow A) ((-) A)", "by (fast intro: OrderingSetIsoI_orders_greater2less)"], ["", "lemma simplex_like_pow_above_in:\n  assumes \"finite A\" \"X\\<subseteq>A\"\n  shows   \"supset_simplex_like ((Pow A).\\<supseteq>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_order.simplex_like (dual_order.below_in (Pow A) X)", "proof (\n  rule OrderingSetIso.pullback_simplex_like, rule OrderingSetIso.iso_subset,\n  rule OrderingSetIso_pow_complement\n)"], ["proof (state)\ngoal (3 subgoals):\n 1. order.greater_eq (Pow ?A7) (dual_order.below_in (Pow A) X)\n 2. finite (dual_order.below_in (Pow A) X)\n 3. order.simplex_like ((-) ?A7 ` dual_order.below_in (Pow A) X)", "from assms(1)"], ["proof (chain)\npicking this:\n  finite A", "show \"finite ((Pow A).\\<supseteq>X)\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite (dual_order.below_in (Pow A) X)", "by simp"], ["proof (state)\nthis:\n  finite (dual_order.below_in (Pow A) X)\n\ngoal (2 subgoals):\n 1. order.greater_eq (Pow ?A7) (dual_order.below_in (Pow A) X)\n 2. order.simplex_like ((-) ?A7 ` dual_order.below_in (Pow A) X)", "from assms(1)"], ["proof (chain)\npicking this:\n  finite A", "have \"finite (Pow (A-X))\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite (Pow (A - X))", "by fast"], ["proof (state)\nthis:\n  finite (Pow (A - X))\n\ngoal (2 subgoals):\n 1. order.greater_eq (Pow ?A7) (dual_order.below_in (Pow A) X)\n 2. order.simplex_like ((-) ?A7 ` dual_order.below_in (Pow A) X)", "moreover"], ["proof (state)\nthis:\n  finite (Pow (A - X))\n\ngoal (2 subgoals):\n 1. order.greater_eq (Pow ?A7) (dual_order.below_in (Pow A) X)\n 2. order.simplex_like ((-) ?A7 ` dual_order.below_in (Pow A) X)", "from assms(2)"], ["proof (chain)\npicking this:\n  order.greater_eq A X", "have \"((-) A) ` ((Pow A).\\<supseteq>X) = Pow (A-X)\""], ["proof (prove)\nusing this:\n  order.greater_eq A X\n\ngoal (1 subgoal):\n 1. (-) A ` dual_order.below_in (Pow A) X = Pow (A - X)", "by auto"], ["proof (state)\nthis:\n  (-) A ` dual_order.below_in (Pow A) X = Pow (A - X)\n\ngoal (2 subgoals):\n 1. order.greater_eq (Pow ?A7) (dual_order.below_in (Pow A) X)\n 2. order.simplex_like ((-) ?A7 ` dual_order.below_in (Pow A) X)", "ultimately"], ["proof (chain)\npicking this:\n  finite (Pow (A - X))\n  (-) A ` dual_order.below_in (Pow A) X = Pow (A - X)", "show  \"ordering.simplex_like (\\<subseteq>) (\\<subset>) ( ((-) A) ` ((Pow A).\\<supseteq>X))\""], ["proof (prove)\nusing this:\n  finite (Pow (A - X))\n  (-) A ` dual_order.below_in (Pow A) X = Pow (A - X)\n\ngoal (1 subgoal):\n 1. order.simplex_like ((-) A ` dual_order.below_in (Pow A) X)", "using simplex_like_pow"], ["proof (prove)\nusing this:\n  finite (Pow (A - X))\n  (-) A ` dual_order.below_in (Pow A) X = Pow (A - X)\n  finite ?A \\<Longrightarrow> order.simplex_like (Pow ?A)\n\ngoal (1 subgoal):\n 1. order.simplex_like ((-) A ` dual_order.below_in (Pow A) X)", "by    fastforce"], ["proof (state)\nthis:\n  order.simplex_like ((-) A ` dual_order.below_in (Pow A) X)\n\ngoal (1 subgoal):\n 1. order.greater_eq (Pow A) (dual_order.below_in (Pow A) X)", "qed fast"], ["", "end"], ["", "(* theory *)"]]}