{"file_name": "/home/qj213/afp-2021-10-22/thys/Buildings/Coxeter.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Buildings", "problem_names": ["lemma no_zero_genset: \"0\\<notin>S\"", "lemma genset_order2_add: \"s\\<in>S \\<Longrightarrow> s + s = 0\"", "lemmas genset_uminus = minus_unique[OF genset_order2_add]", "lemma relfun_S: \"s\\<in>S \\<Longrightarrow> relfun s s = 1\"", "lemma relfun_eq1: \"\\<lbrakk> s\\<in>S; relfun s t = 1 \\<rbrakk> \\<Longrightarrow> t=s\"", "lemma S_relator_list: \"s\\<in>S \\<Longrightarrow> pair_relator_list s s = [s,s]\"", "lemma S_sym: \"T \\<subseteq> S \\<Longrightarrow> uminus ` T \\<subseteq> T\"", "lemmas special_subgroup_eq_sum_list =\n  genby_sym_eq_sum_lists[OF S_sym]", "lemmas genby_S_reduced_word_for_arg_min =\n  reduced_word_for_genby_sym_arg_min[OF S_sym]", "lemmas in_genby_S_reduced_letter_set =\n  in_genby_sym_imp_in_reduced_letter_set[OF S_sym]", "lemma special_cosetsI: \"T\\<in>Pow S \\<Longrightarrow> w\\<in>W \\<Longrightarrow> w +o \\<langle>T\\<rangle> \\<in> \\<P>\"", "lemma special_coset_singleton: \"w\\<in>W \\<Longrightarrow> {w}\\<in>\\<P>\"", "lemma special_coset_nempty: \"X\\<in>\\<P> \\<Longrightarrow> X \\<noteq> {}\"", "lemma special_subgroup_special_coset: \"T\\<in>Pow S \\<Longrightarrow> \\<langle>T\\<rangle> \\<in> \\<P>\"", "lemma special_cosets_lcoset_closed: \"w\\<in>W \\<Longrightarrow> X\\<in>\\<P> \\<Longrightarrow> w +o X \\<in> \\<P>\"", "lemma special_cosets_lcoset_shift: \"w\\<in>W \\<Longrightarrow> ((+o) w) ` \\<P> = \\<P>\"", "lemma special_cosets_has_bottom: \"supset_has_bottom \\<P>\"", "lemma special_cosets_bottom: \"supset_bottom \\<P> = W\"", "lemma S_relator_freeword: \"s\\<in>S \\<Longrightarrow> pair_relator_freeword s s = s[+]s\"", "lemma map_charpair_map_pairtrue_R:\n  \"s\\<in>S \\<Longrightarrow> t\\<in>S \\<Longrightarrow>\n    map (charpair S) (pair_relator_list s t) = map pairtrue (pair_relator_list s t)\"", "lemma relator_freeword:\n  \"s\\<in>S \\<Longrightarrow> t\\<in>S \\<Longrightarrow>\n    pair_relator_freeword s t = relator_freeword (pair_relator_list s t)\"", "lemma relator_freewords: \"Abs_freelist ` R = P'\"", "lemma GroupWithGeneratorsRelators_S_R: \"GroupWithGeneratorsRelators S R\"", "lemmas GroupByPresentation_S_P =\n  GroupWithGeneratorsRelators.GroupByPresentation_S_P[\n    OF GroupWithGeneratorsRelators_S_R\n  ]", "lemmas Q_FreeS = GroupByPresentation.Q_FreeS[OF GroupByPresentation_S_P]", "lemma relator_freeword_Q: \"s\\<in>S \\<Longrightarrow> t\\<in>S \\<Longrightarrow> pair_relator_freeword s t \\<in> Q\"", "lemmas P'_FreeS =\n  GroupWithGeneratorsRelators.P'_FreeS[\n    OF GroupWithGeneratorsRelators_S_R\n  ]", "lemmas GroupByPresentationInducedFun_S_P_id =\n  GroupWithGeneratorsRelators.GroupByPresentationInducedFun_S_P_id[\n    OF GroupWithGeneratorsRelators_S_R\n  ]", "lemma rconj_relator_freeword:\n  \"\\<lbrakk> s\\<in>S; t\\<in>S; proper_signed_list xs; fst ` set xs \\<subseteq> S \\<rbrakk> \\<Longrightarrow>\n    rconjby (Abs_freeword xs) (pair_relator_freeword s t) \\<in> Q\"", "lemma lconjby_Abs_freelist_relator_freeword:\n  \"\\<lbrakk> s\\<in>S; t\\<in>S; xs\\<in>lists S \\<rbrakk> \\<Longrightarrow>\n    lconjby (Abs_freelist xs) (pair_relator_freeword s t) \\<in> Q\"", "lemma Abs_freelist_rev_append_alternating_list_in_Q:\n  assumes \"s\\<in>S\" \"t\\<in>S\"\n  shows \"Abs_freelist (rev (alternating_list n s t) @ alternating_list n s t) \\<in> Q\"", "lemma Abs_freeword_freelist_uminus_add_in_Q:\n  \"proper_signed_list xs \\<Longrightarrow> fst ` set xs \\<subseteq> S \\<Longrightarrow>\n    - Abs_freelistfst xs + Abs_freeword xs \\<in> Q\"", "lemma Q_freelist_freeword':\n  \"\\<lbrakk> proper_signed_list xs; fst ` set xs \\<subseteq> S; Abs_freelistfst xs \\<in> Q \\<rbrakk> \\<Longrightarrow>\n    Abs_freeword xs \\<in> Q\"", "lemma Q_freelist_freeword:\n  \"c \\<in> FreeGroup S \\<Longrightarrow> Abs_freelist (map fst (freeword c)) \\<in> Q \\<Longrightarrow> c \\<in> Q\"", "lemma freeliftid_Abs_freeword_conv_sum_list:\n  \"proper_signed_list xs \\<Longrightarrow> fst ` set xs \\<subseteq> S \\<Longrightarrow>\n    freeliftid (Abs_freeword xs) = sum_list (map fst xs)\"", "lemma sum_list_pair_relator_halflist_flip:\n  \"s\\<in>S \\<Longrightarrow> t\\<in>S \\<Longrightarrow>\n    sum_list (pair_relator_halflist s t) = sum_list (pair_relator_halflist t s)\"", "lemma flip_altsublist_adjacentI:\n  \"ss = as @ (pair_relator_halflist s t) @ bs \\<Longrightarrow>\n    ts = as @ (pair_relator_halflist t s) @ bs \\<Longrightarrow>\n    flip_altsublist_adjacent ss ts\"", "lemma flip_altsublist_adjacent_Cons_grow:\n  assumes \"flip_altsublist_adjacent ss ts\"\n  shows   \"flip_altsublist_adjacent (a#ss) (a#ts)\"", "lemma flip_altsublist_chain_map_Cons_grow:\n  \"flip_altsublist_chain tss \\<Longrightarrow> flip_altsublist_chain (map ((#) t) tss)\"", "lemma flip_altsublist_adjacent_refl:\n  \"ss \\<noteq> [] \\<Longrightarrow> ss\\<in>lists S \\<Longrightarrow> flip_altsublist_adjacent ss ss\"", "lemma flip_altsublist_adjacent_sym:\n  \"flip_altsublist_adjacent ss ts \\<Longrightarrow> flip_altsublist_adjacent ts ss\"", "lemma rev_flip_altsublist_chain:\n  \"flip_altsublist_chain xss \\<Longrightarrow> flip_altsublist_chain (rev xss)\"", "lemma flip_altsublist_adjacent_set:\n  assumes \"ss\\<in>lists S\" \"flip_altsublist_adjacent ss ts\"\n  shows   \"set ts = set ss\"", "lemma flip_altsublist_adjacent_set_ball:\n  \"\\<forall>ss\\<in>lists S. \\<forall>ts. flip_altsublist_adjacent ss ts \\<longrightarrow> set ts = set ss\"", "lemma flip_altsublist_adjacent_lists:\n  \"ss \\<in> lists S \\<Longrightarrow> flip_altsublist_adjacent ss ts \\<Longrightarrow> ts \\<in> lists S\"", "lemma flip_altsublist_adjacent_lists_ball:\n  \"\\<forall>ss\\<in>lists S. \\<forall>ts. flip_altsublist_adjacent ss ts \\<longrightarrow> ts \\<in> lists S\"", "lemma flip_altsublist_chain_lists:\n  \"ss \\<in> lists S \\<Longrightarrow> flip_altsublist_chain (ss#xss@[ts]) \\<Longrightarrow> ts \\<in> lists S\"", "lemmas flip_altsublist_chain_funcong_Cons_snoc =\n  binrelchain_setfuncong_Cons_snoc[OF flip_altsublist_adjacent_lists_ball]", "lemmas flip_altsublist_chain_set =\n  flip_altsublist_chain_funcong_Cons_snoc[\n    OF flip_altsublist_adjacent_set_ball\n  ]", "lemma flip_altsublist_adjacent_length:\n  \"flip_altsublist_adjacent ss ts \\<Longrightarrow> length ts = length ss\"", "lemmas flip_altsublist_chain_length =\n  binrelchain_funcong_Cons_snoc[\n    of flip_altsublist_adjacent length, OF flip_altsublist_adjacent_length, simplified\n  ]", "lemma flip_altsublist_adjacent_sum_list:\n  assumes \"ss \\<in> lists S\" \"flip_altsublist_adjacent ss ts\"\n  shows \"sum_list ts = sum_list ss\"", "lemma flip_altsublist_adjacent_sum_list_ball:\n  \"\\<forall>ss\\<in>lists S. \\<forall>ts. flip_altsublist_adjacent ss ts \\<longrightarrow> sum_list ts = sum_list ss\"", "lemma S_reduced_forI_flip_altsublist_adjacent:\n  \"S_reduced_for w ss \\<Longrightarrow> flip_altsublist_adjacent ss ts \\<Longrightarrow> S_reduced_for w ts\"", "lemma flip_altsublist_adjacent_in_Q':\n  fixes   as bs s t\n  defines xs: \"xs \\<equiv> as @ pair_relator_halflist s t @ bs\"\n  and     ys: \"ys \\<equiv> as @ pair_relator_halflist t s @ bs\"\n  assumes Axs: \"Abs_freelist xs \\<in> Q\"\n  shows \"Abs_freelist ys \\<in> Q\"", "lemma flip_altsublist_adjacent_in_Q:\n  \"Abs_freelist ss \\<in> Q \\<Longrightarrow> flip_altsublist_adjacent ss ts \\<Longrightarrow> Abs_freelist ts \\<in> Q\"", "lemma flip_altsublist_chain_G_in_Q:\n  \"\\<lbrakk> Abs_freelist ss \\<in> Q; flip_altsublist_chain (ss#xss@[ts]) \\<rbrakk> \\<Longrightarrow> Abs_freelist ts \\<in> Q\"", "lemma alternating_S_no_flip:\n  assumes \"s\\<in>S\" \"t\\<in>S\" \"n > 0\" \"n < relfun s t \\<or> relfun s t = 0\"\n  shows   \"sum_list (alternating_list n s t) \\<noteq> sum_list (alternating_list n t s)\"", "lemma exchange_alternating_not_in_alternating:\n  assumes \"n \\<ge> 2\" \"n < relfun s t \\<or> relfun s t = 0\"\n          \"S_reduced_for w (alternating_list n s t @ cs)\"\n          \"alternating_list n s t @ cs = xs@[x]@ys\" \"S_reduced_for w (t#xs@ys)\"\n  shows   \"length xs \\<ge> n\"", "lemmas flip_altsublist_chain_sum_list =\n  flip_altsublist_chain_funcong_Cons_snoc[OF flip_altsublist_adjacent_sum_list_ball]\n\\<comment> \\<open>This lemma represents one direction in the word problem: if a word in generators can be\ntransformed into another by a sequence of manipulations, each of which consists of replacing a\nhalf-relator subword by its reversal, then the two words sum to the same element of @{term W}.\\<close>", "lemma reduced_word_problem_eq_hd_step:\n  assumes step: \"\\<And>y ss ts. \\<lbrakk>\n                  S_length y < S_length w; y\\<noteq>0; S_reduced_for y ss; S_reduced_for y ts\n                \\<rbrakk> \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])\"\n  and     set_up: \"S_reduced_for w (a#ss)\" \"S_reduced_for w (a#ts)\"\n  shows   \"\\<exists>xss. flip_altsublist_chain ((a#ss) # xss @ [a#ts])\"", "lemma lconjseq_reflections: \"ss\\<in>lists S \\<Longrightarrow> set (lconjseq ss) \\<subseteq> \\<H>\"", "lemma deletion':\n  \"ss \\<in> lists S \\<Longrightarrow> \\<not> distinct (lconjseq ss) \\<Longrightarrow>\n    \\<exists>a b as bs cs. ss = as @ [a] @ bs @ [b] @ cs \\<and>\n      sum_list ss = sum_list (as@bs@cs)\"", "lemma S_reduced_imp_distinct_lconjseq':\n  assumes \"ss \\<in> lists S\" \"\\<not> distinct (lconjseq ss)\"\n  shows \"\\<not> S_reduced ss\"", "lemma S_reduced_imp_distinct_lconjseq: \"S_reduced ss \\<Longrightarrow> distinct (lconjseq ss)\"", "lemma permutation_lift_signed_lconjperm_eq_signed_list_lconjaction':\n  \"proper_signed_list xs \\<Longrightarrow> fst ` set xs \\<subseteq> S \\<Longrightarrow>\n    permutation (lift_signed_lconjperm (Abs_freeword xs)) =\n      signed_list_lconjaction (map fst xs)\"", "lemma permutation_lift_signed_lconjperm_eq_signed_list_lconjaction:\n  \"x \\<in> FreeGroup S \\<Longrightarrow>\n    permutation (lift_signed_lconjperm x) =\n      signed_list_lconjaction (map fst (freeword x))\"", "lemma even_count_lconjseq_rev_relator:\n  \"s\\<in>S \\<Longrightarrow> t\\<in>S \\<Longrightarrow> even (count_list (lconjseq (rev (pair_relator_list s t))) x)\"", "lemma GroupByPresentationInducedFun_S_R_signed_lconjaction:\n  \"GroupByPresentationInducedFun S P signed_lconjpermutation\"", "lemma deletion_reduce:\n  \"ss \\<in> lists S \\<Longrightarrow> \\<exists>ts. ts \\<in> ssubseqs ss \\<inter> reduced_words_for S (sum_list ss)\"", "lemma deletion_reduce':\n  \"ss \\<in> lists S \\<Longrightarrow> \\<exists>ts\\<in>reduced_words_for S (sum_list ss). set ts \\<subseteq> set ss\"", "lemma exchange:\n  assumes \"s\\<in>S\" \"S_reduced_for w ss\" \"\\<not> S_reduced (s#ss)\"\n  shows   \"\\<exists>t as bs. ss = as@t#bs \\<and> reduced_word_for S w (s#as@bs)\"", "lemma reduced_head_imp_exchange:\n  assumes \"reduced_word_for S w (s#as)\" \"reduced_word_for S w cs\"\n  shows   \"\\<exists>a ds es. cs = ds@[a]@es \\<and> reduced_word_for S w (s#ds@es)\"", "lemma two_reduced_heads_imp_reduced_alt_step:\n  assumes \"s\\<noteq>t\" \"reduced_word_for S w (t#bs)\" \"n < relfun s t \\<or> relfun s t = 0\"\n          \"reduced_word_for S w (alternating_list n s t @ cs)\"\n  shows   \"\\<exists>ds. reduced_word_for S w (alternating_list (Suc n) t s @ ds)\"", "lemma two_reduced_heads_imp_reduced_alt':\n  assumes \"s\\<noteq>t\" \"reduced_word_for S w (s#as)\" \"reduced_word_for S w (t#bs)\"\n  shows \"n \\<le> relfun s t \\<or> relfun s t = 0 \\<Longrightarrow> (\\<exists>cs.\n          reduced_word_for S w (alternating_list n s t @ cs) \\<or>\n          reduced_word_for S w (alternating_list n t s @ cs)\n        )\"", "lemma two_reduced_heads_imp_reduced_alt:\n  assumes \"s\\<noteq>t\" \"reduced_word_for S w (s#as)\" \"reduced_word_for S w (t#bs)\"\n  shows \"\\<exists>cs. reduced_word_for S w (pair_relator_halflist s t @ cs)\"", "lemma two_reduced_heads_imp_nzero_relfun:\n  assumes \"s\\<noteq>t\" \"reduced_word_for S w (s#as)\" \"reduced_word_for S w (t#bs)\"\n  shows   \"relfun s t \\<noteq> 0\"", "lemma reduced_word_problem_ConsCons_step:\n  assumes \"\\<And>y ss ts. \\<lbrakk> S_length y < S_length w; y\\<noteq>0; reduced_word_for S y ss;\n            reduced_word_for S y ts \\<rbrakk> \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])\"\n          \"reduced_word_for S w (a#as)\" \"reduced_word_for S w (b#bs)\" \"a\\<noteq>b\"\n  shows   \"\\<exists>xss. flip_altsublist_chain ((a#as)#xss@[b#bs])\"", "lemma reduced_word_problem:\n  \"\\<lbrakk> w\\<noteq>0; reduced_word_for S w ss; reduced_word_for S w ts \\<rbrakk> \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain (ss#xss@[ts])\"", "lemma reduced_word_letter_set:\n  assumes \"S_reduced_for w ss\"\n  shows \"reduced_letter_set S w = set ss\"", "lemma special_subgroup_int_S:\n  assumes \"T \\<in> Pow S\"\n  shows   \"\\<langle>T\\<rangle> \\<inter> S = T\"", "lemma special_subgroup_inj: \"inj_on genby (Pow S)\"", "lemma special_subgroup_genby_subset_ordering_iso:\n  \"subset_ordering_iso (Pow S) genby\"", "lemmas special_subgroup_genby_rev_mono\n  = OrderingSetIso.rev_ordsetmap[OF special_subgroup_genby_subset_ordering_iso]", "lemma special_subgroup_word_length:\n  assumes \"T\\<in>Pow S\" \"w\\<in>\\<langle>T\\<rangle>\"\n  shows   \"word_length T w = S_length w\"", "lemma S_subset_reduced_imp_S_reduced:\n  \"T\\<in>Pow S \\<Longrightarrow> reduced_word T ts \\<Longrightarrow> S_reduced ts\"", "lemma smallest_genby: \"T\\<in>Pow S \\<Longrightarrow> w\\<in>\\<langle>T\\<rangle> \\<Longrightarrow> reduced_letter_set S w \\<subseteq> T\"", "lemma special_cosets_below_in:\n  assumes \"w\\<in>W\" \"T \\<in> Pow S\"\n  shows   \"\\<P>.\\<supseteq>(w +o \\<langle>T\\<rangle>) = (\\<Union>R\\<in>(Pow S).\\<supseteq>T. {w +o \\<langle>R\\<rangle>})\"", "lemmas special_coset_inj\n  = comp_inj_on[OF special_subgroup_inj, OF inj_inj_on, OF lcoset_inj_on]", "lemma special_coset_eq_imp_eq_gensets:\n  \"\\<lbrakk> T1\\<in>Pow S; T2\\<in>Pow S; w1 +o \\<langle>T1\\<rangle> = w2 +o \\<langle>T2\\<rangle> \\<rbrakk> \\<Longrightarrow> T1=T2\"", "lemma special_subgroup_special_coset_subset_ordering_iso:\n  \"subset_ordering_iso (genby ` Pow S) ((+o) w)\"", "lemma special_coset_subset_ordering_iso:\n  \"subset_ordering_iso (Pow S) ((+o) w \\<circ> genby)\"", "lemmas special_coset_subset_rev_mono =\n  OrderingSetIso.rev_ordsetmap[OF special_coset_subset_ordering_iso]", "lemma special_coset_below_in_subset_ordering_iso:\n  \"subset_ordering_iso ((Pow S).\\<supseteq>T) ((+o) w \\<circ> genby)\"", "lemma special_coset_below_in_supset_ordering_iso:\n  \"OrderingSetIso (\\<supseteq>) (\\<supset>) (\\<supseteq>) (\\<supset>) ((Pow S).\\<supseteq>T) ((+o) w \\<circ> genby)\"", "lemma special_coset_pseudominimals:\n  assumes \"supset_pseudominimal_in \\<P> X\"\n  shows   \"\\<exists>w s. w\\<in>W \\<and> s\\<in>S \\<and> X = w +o \\<langle>S-{s}\\<rangle>\"", "lemma special_coset_pseudominimal_in_below_in:\n  assumes \"w\\<in>W\" \"T\\<in>Pow S\" \"supset_pseudominimal_in (\\<P>.\\<supseteq>(w +o \\<langle>T\\<rangle>)) X\"\n  shows   \"\\<exists>s\\<in>S-T. X = w +o \\<langle>S-{s}\\<rangle>\"", "lemma exclude_one_is_pseudominimal:\n  assumes \"w\\<in>W\" \"t\\<in>S\"\n  shows   \"supset_pseudominimal_in \\<P> (w +o \\<langle>S-{t}\\<rangle>)\"", "lemma exclude_one_is_pseudominimal_in_below_in:\n  \"\\<lbrakk> w\\<in>W; T\\<in>Pow S; s\\<in>S-T \\<rbrakk> \\<Longrightarrow>\n    supset_pseudominimal_in (\\<P>.\\<supseteq>(w +o \\<langle>T\\<rangle>)) (w +o \\<langle>S-{s}\\<rangle>)\"", "lemma glb_special_subset_coset:\n  assumes   wTT': \"w\\<in> W\" \"T \\<in> Pow S\" \"T' \\<in> Pow S\"\n  defines   U: \"U \\<equiv> T \\<union> T' \\<union> reduced_letter_set S w\"\n  shows     \"supset_glbound_in_of \\<P> \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>) \\<langle>U\\<rangle>\"", "lemma glb_special_subset_coset_ex:\n  assumes   \"w\\<in> W\" \"T \\<in> Pow S\" \"T' \\<in> Pow S\"\n  shows     \"\\<exists>B. supset_glbound_in_of \\<P> \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>) B\"", "lemma special_cosets_have_glbs:\n  assumes \"X\\<in>\\<P>\" \"Y\\<in>\\<P>\"\n  shows   \"\\<exists>B. supset_glbound_in_of \\<P> X Y B\"", "lemma (in PreCoxeterSystem) CoxeterSystemI:\n  assumes \"\\<And>g. g\\<in>G \\<Longrightarrow> induced_id g = 0 \\<Longrightarrow> g=0\"\n  shows   \"CoxeterSystem S\"", "lemma GroupPresentation_S_R: \"GroupPresentation S R\"", "lemmas inv_induced_id_sum_list =\n  GroupPresentation.inv_induced_id_sum_list_S[OF GroupPresentation_S_R]", "lemma induced_signed_lconjperm_inv_induced_id_sum_list:\n  \"ss \\<in> lists S \\<Longrightarrow> induced_signed_lconjperm (inv_induced_id (sum_list ss)) =\n          sum_list (map signed_lconjpermutation ss)\"", "lemma induced_signed_eq_lconjpermutation:\n  \"ss \\<in> lists S \\<Longrightarrow>\n    permutation (induced_signed_lconjperm (inv_induced_id (sum_list ss))) =\n      signed_list_lconjaction ss\"", "lemma flipped_reflections_odd_lconjseq:\n  assumes \"ss\\<in>lists S\"\n  shows   \"flipped_reflections (sum_list ss) = {t\\<in>\\<H>. odd (count_list (lconjseq ss) t)}\"", "lemma flipped_reflections_in_lconjseq:\n  \"ss\\<in>lists S \\<Longrightarrow> flipped_reflections (sum_list ss) \\<subseteq> set (lconjseq ss)\"", "lemma flipped_reflections_distinct_lconjseq_eq_lconjseq:\n  assumes \"ss\\<in>lists S\" \"distinct (lconjseq ss)\"\n  shows   \"flipped_reflections (sum_list ss) = set (lconjseq ss)\"", "lemma flipped_reflections_reduced_eq_lconjseq:\n  \"S_reduced ss \\<Longrightarrow> flipped_reflections (sum_list ss) = set (lconjseq ss)\"", "lemma card_flipped_reflections:\n  assumes \"w\\<in>W\"\n  shows \"card (flipped_reflections w) = S_length w\"", "lemma reducible_by_flipping:\n  \"ss \\<in> lists S \\<Longrightarrow> \\<not> S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs. flip_altsublist_chain (ss # xss @ [as@[t,t]@bs])\"", "lemma freeliftid_kernel':\n  \"ss \\<in> lists S \\<Longrightarrow> sum_list ss = 0 \\<Longrightarrow> Abs_freelist ss \\<in> Q\"", "lemma freeliftid_kernel:\n  assumes \"c \\<in> FreeGroup S\" \"freeliftid c = 0\"\n  shows   \"c\\<in>Q\"", "lemma induced_id_kernel:\n  \"c \\<in> FreeGroup S \\<Longrightarrow> induced_id (\\<lceil>FreeGroup S|c|Q\\<rceil>) = 0 \\<Longrightarrow> c\\<in>Q\"", "theorem CoxeterSystem: \"CoxeterSystem S\"", "lemma not_reduced_word_not_min_gallery:\n  assumes \"ss \\<in> lists S\" \"\\<not> reduced_word S ss\"\n  shows   \"\\<not> min_gallery (map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss))\"", "lemma S_list_not_min_gallery_double_split:\n  assumes \"ss \\<in> lists S\" \"ss\\<noteq>[]\" \"\\<not> min_gallery (map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss))\"\n  shows\n    \"\\<exists>f g as s bs t cs.\n      (f,g)\\<in>foldpairs \\<and>\n      sum_list as `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C> \\<and>\n      sum_list (as@[s]) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C> \\<and>\n      sum_list (as@[s]@bs) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C> \\<and>\n      sum_list (as@[s]@bs@[t]) `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C> \\<and>\n      ss = as@[s]@bs@[t]@cs\"", "lemma fold_end_sum_chain_fg:\n  fixes   f g :: \"'a\\<Rightarrow>'a\"\n  defines \\<s>  : \"\\<s> \\<equiv> induced_automorph f g\"\n  assumes fg :  \"(f,g) \\<in> foldpairs\"\n  and     as :  \"as \\<in> lists S\"\n  and     s  :  \"s\\<in>S\"\n  and     sep:  \"sum_list as `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C>\" \"sum_list (as@[s]) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C>\"\n  shows   \"bs \\<in>lists S \\<Longrightarrow>\n            \\<s> ` sum_list (as@[s]@bs) `\\<rightarrow> C0 = sum_list (as@bs) `\\<rightarrow> C0\"", "lemma fold_end_sum_chain_gf:\n  fixes   f g :: \"'a\\<Rightarrow>'a\"\n  defines \"\\<s> \\<equiv> induced_automorph f g\"\n  assumes fg :  \"(f,g) \\<in> foldpairs\"\n  and     \"as \\<in> lists S\" \"s\\<in>S\" \"bs \\<in>lists S\"\n          \"sum_list as `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C>\"\n          \"sum_list (as@[s]) `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C>\"\n  shows   \"\\<s> ` sum_list (as@[s]@bs) `\\<rightarrow> C0 = sum_list (as@bs) `\\<rightarrow> C0\"", "lemma fold_middle_sum_chain:\n  assumes fg :  \"(f,g) \\<in> foldpairs\"\n  and     S  :  \"as \\<in> lists S\" \"s\\<in>S\" \"bs \\<in> lists S\" \"t\\<in>S\" \"cs \\<in>lists S\"\n  and     sep:  \"sum_list as `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C>\"\n                \"sum_list (as@[s]) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C>\"\n                \"sum_list (as@[s]@bs) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C>\" \"sum_list (as@[s]@bs@[t]) `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C>\"\n  shows   \"sum_list (as@[s]@bs@[t]@cs) `\\<rightarrow> C0 = sum_list (as@bs@cs) `\\<rightarrow> C0\"", "lemma S_list_not_min_gallery_deletion:\n  fixes ss :: \"'a permutation list\"\n  defines w : \"w \\<equiv> sum_list ss\"\n  assumes ss: \"ss\\<in>lists S\" \"ss\\<noteq>[]\" \"\\<not> min_gallery (map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss))\"\n  shows \"\\<exists>a b as bs cs. ss = as@[a]@bs@[b]@cs \\<and> w = sum_list (as@bs@cs)\"", "lemma deletion:\n  \"ss \\<in> lists S \\<Longrightarrow> \\<not> reduced_word S ss \\<Longrightarrow>\n    \\<exists>a b as bs cs. ss = as@[a]@bs@[b]@cs \\<and> sum_list ss = sum_list (as@bs@cs)\"", "lemma PreCoxeterSystemWithDeletion: \"PreCoxeterSystemWithDeletion S\"", "lemma CoxeterSystem: \"CoxeterSystem S\"", "lemma simplex_like_special_cosets:\n  assumes \"X\\<in>\\<P>\"\n  shows \"supset_simplex_like (\\<P>.\\<supseteq>X)\"", "lemma SimplicialComplex_\\<Sigma>: \"SimplicialComplex \\<Sigma>\"", "lemma ComplexLikePoset_special_cosets: \"ComplexLikePoset (\\<supseteq>) (\\<supset>) \\<P>\"", "lemmas smap_def = ordering.poset_simplex_map_def[OF supset_poset, of \\<P>]", "lemma ordsetmap_smap: \"\\<lbrakk> X\\<in>\\<P>; Y\\<in>\\<P>; X\\<supseteq>Y \\<rbrakk> \\<Longrightarrow> smap X \\<subseteq> smap Y\"", "lemma rev_ordsetmap_smap: \"\\<lbrakk> X\\<in>\\<P>; Y\\<in>\\<P>; smap X \\<subseteq> smap Y \\<rbrakk> \\<Longrightarrow> X\\<supseteq>Y\"", "lemma smap_onto_PosetComplex: \"smap ` \\<P> = \\<Sigma>\"", "lemmas simplices_conv_special_cosets = smap_onto_PosetComplex[THEN sym]", "lemma smap_into_PosetComplex: \"X\\<in>\\<P> \\<Longrightarrow> smap X \\<in> \\<Sigma>\"", "lemma smap_pseudominimal:\n  \"w\\<in>W \\<Longrightarrow> s\\<in>S \\<Longrightarrow> smap (w +o \\<langle>S-{s}\\<rangle>) = {w +o \\<langle>S-{s}\\<rangle>}\"", "lemma exclude_one_notin_smap_singleton:\n  \"s\\<in>S \\<Longrightarrow> w +o \\<langle>S-{s}\\<rangle> \\<notin> smap (w +o \\<langle>{s}\\<rangle>)\"", "lemma maxsimp_vertices: \"w\\<in>W \\<Longrightarrow> s\\<in>S \\<Longrightarrow> w +o \\<langle>S-{s}\\<rangle> \\<in> smap {w}\"", "lemma maxsimp_singleton:\n  assumes \"w\\<in>W\"\n  shows   \"SimplicialComplex.maxsimp \\<Sigma> (smap {w})\"", "lemma maxsimp_is_singleton:\n  assumes \"SimplicialComplex.maxsimp \\<Sigma> x\"\n  shows   \"\\<exists>w\\<in>W. smap {w} = x\"", "lemma maxsimp_vertex_conv_special_coset:\n  \"w\\<in>W \\<Longrightarrow> X \\<in> smap {w} \\<Longrightarrow> \\<exists>s\\<in>S. X = w +o \\<langle>S-{s}\\<rangle>\"", "lemma vertices: \"w\\<in>W \\<Longrightarrow> s\\<in>S \\<Longrightarrow> w +o \\<langle>S-{s}\\<rangle> \\<in> \\<Union>\\<Sigma>\"", "lemma smap0_conv_special_subgroups:\n  \"smap 0 = (\\<lambda>s. \\<langle>S - {s}\\<rangle>) ` S\"", "lemma S_bij_betw_chamber0: \"bij_betw (\\<lambda>s. \\<langle>S-{s}\\<rangle>) S (smap 0)\"", "lemma smap_singleton_conv_W_image: \n  \"w\\<in>W \\<Longrightarrow> smap {w} = ((+o) w) ` (smap 0)\"", "lemma W_lcoset_bij_betw_singletons:\n  assumes \"w\\<in>W\"\n  shows   \"bij_betw ((+o) w) (smap 0) (smap {w})\"", "lemma facets:\n  assumes \"w\\<in>W\" \"s\\<in>S\"\n  shows \"smap (w +o \\<langle>{s}\\<rangle>) \\<lhd> smap {w}\"", "lemma facets': \"w\\<in>W \\<Longrightarrow> s\\<in>S \\<Longrightarrow> smap {w,w+s} \\<lhd> smap {w}\"", "lemma adjacent: \"w\\<in>W \\<Longrightarrow> s\\<in>S \\<Longrightarrow> smap {w+s} \\<sim> smap {w}\"", "lemma singleton_adjacent_0: \"s\\<in>S \\<Longrightarrow> smap {s} \\<sim> smap 0\"", "lemmas chamber_singleton                 = maxsimp_singleton", "lemmas chamber_vertex_conv_special_coset = maxsimp_vertex_conv_special_coset", "lemmas chamber_vertices                  = maxsimp_vertices", "lemmas chamber_is_singleton              = maxsimp_is_singleton", "lemmas faces       = SimplicialComplex.faces            [OF SimplicialComplex_\\<Sigma>]", "lemmas gallery_def = SimplicialComplex.maxsimpchain_def [OF SimplicialComplex_\\<Sigma>]", "lemmas gallery_rev = SimplicialComplex.maxsimpchain_rev [OF SimplicialComplex_\\<Sigma>]", "lemmas chamberD_simplex =\n  SimplicialComplex.maxsimpD_simplex[OF SimplicialComplex_\\<Sigma>]", "lemmas gallery_CConsI =\n  SimplicialComplex.maxsimpchain_CConsI[OF SimplicialComplex_\\<Sigma>]", "lemmas gallery_overlap_join =\n  SimplicialComplex.maxsimpchain_overlap_join[OF SimplicialComplex_\\<Sigma>]", "lemma word_gallery_to_0:\n  \"ss \\<noteq> [] \\<Longrightarrow> ss\\<in> lists S \\<Longrightarrow> \\<exists>xs. gallery (smap {sum_list ss} # xs @ [smap 0])\"", "lemma gallery_to_0:\n  assumes \"w\\<in>W\" \"w\\<noteq>0\"\n  shows   \"\\<exists>xs. gallery (smap {w} # xs @ [smap 0])\"", "lemma ChamberComplex_\\<Sigma>: \"ChamberComplex \\<Sigma>\"", "lemma card_chamber: \"chamber x \\<Longrightarrow> card x = card S\"", "lemma vertex_conv_special_coset:\n  \"X\\<in>\\<Union>\\<Sigma> \\<Longrightarrow> \\<exists>w s. w\\<in>W \\<and> s\\<in>S \\<and> X = w +o \\<langle>S-{s}\\<rangle>\"", "lemma CoxeterComplex: \"CoxeterComplex S\"", "lemma S_list_not_min_gallery_not_reduced:\n  assumes \"ss\\<noteq>[]\" \"\\<not> min_gallery (map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss))\"\n  shows \"\\<not> reduced_word S ss\"", "lemma reduced_S_list_min_gallery:\n  \"ss\\<noteq>[] \\<Longrightarrow> reduced_word S ss \\<Longrightarrow> min_gallery (map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss))\"", "lemma fundchamber_vertex_stabilizer1:\n  fixes   t\n  defines v:  \"v \\<equiv> fundantivertex t\"\n  assumes tw: \"t\\<in>S\" \"w\\<in>W\" \"w\\<rightarrow>v = v\"\n  shows   \"w \\<in> \\<langle>S-{t}\\<rangle>\"", "lemma fundchamber_vertex_stabilizer2:\n  assumes s: \"s\\<in>S\"\n  defines v: \"v \\<equiv> fundantivertex s\"\n  shows   \"w \\<in> \\<langle>S-{s}\\<rangle> \\<Longrightarrow> w\\<rightarrow>v = v\"", "lemma label_wrt_special_coset1:\n  assumes \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\" \"w0\\<in>W\" \"s\\<in>S\"\n  defines \"v \\<equiv> fundantivertex s\"\n  shows   \"{w\\<in>W. w \\<rightarrow> \\<phi> (w0\\<rightarrow>v) = w0\\<rightarrow>v} = w0 +o \\<langle>S-{s}\\<rangle>\"", "lemma label_wrt_special_coset1':\n  assumes \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\" \"w0\\<in>W\" \"v\\<in>C0\"\n  defines \"s \\<equiv> fundantipermutation v\"\n  shows   \"{w\\<in>W. w \\<rightarrow> \\<phi> (w0\\<rightarrow>v) = w0\\<rightarrow>v} = w0 +o \\<langle>S-{s}\\<rangle>\"", "lemma label_wrt_special_coset2':\n  assumes \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\" \"w0\\<in>W\" \"v \\<in> w0`\\<rightarrow>C0\"\n  defines \"s \\<equiv> fundantipermutation (\\<phi> v)\"\n  shows   \"{w\\<in>W. w \\<rightarrow> \\<phi> v = v} = w0 +o \\<langle>S-{s}\\<rangle>\"", "lemma label_stab_map_W_fundchamber_image:\n  assumes \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\" \"w0\\<in>W\"\n  defines \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows   \"\\<psi>`(w0`\\<rightarrow>C0) = CoxeterComplex.smap S {w0}\"", "lemma label_stab_map_chamber_map:\n  assumes \\<phi>: \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\"\n  and     C: \"chamber C\"\n  defines \\<psi>: \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows   \"CoxeterComplex.chamber S (\\<psi>`C)\"", "lemma label_stab_map_inj_on_vertices:\n  assumes \\<phi>: \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\"\n  defines \\<psi>: \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows \"inj_on \\<psi> (\\<Union>X)\"", "lemma label_stab_map_surj_on_vertices:\n  assumes \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\"\n  defines \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows   \"\\<psi>`(\\<Union>X) = \\<Union>\\<Sigma>\"", "lemma label_stab_map_bij_betw_vertices:\n  assumes   \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\"\n  defines   \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows     \"bij_betw \\<psi> (\\<Union>X) (\\<Union>\\<Sigma>)\"", "lemma label_stab_map_bij_betw_W_chambers:\n  assumes   \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\" \"w0\\<in>W\"\n  defines   \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows     \"bij_betw \\<psi> (w0`\\<rightarrow>C0) (CoxeterComplex.smap S {w0})\"", "lemma label_stab_map_surj_on_simplices:\n  assumes \\<phi>: \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\"\n  defines \\<psi>: \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows   \"\\<psi> \\<turnstile> X = \\<Sigma>\"", "lemma label_stab_map_iso_to_coxeter_complex:\n  assumes \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\"\n  defines \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows   \"ChamberComplexIsomorphism X \\<Sigma> \\<psi>\"", "lemma ex_iso_to_coxeter_complex':\n  \"\\<exists>\\<psi>. ChamberComplexIsomorphism X (CoxeterComplex.TheComplex S) \\<psi>\"", "lemma ex_iso_to_coxeter_complex:\n  \"\\<exists>S::'a permutation set. CoxeterComplex S \\<and>\n      (\\<exists>\\<psi>. ChamberComplexIsomorphism X (CoxeterComplex.TheComplex S) \\<psi>)\""], "translations": [["", "lemma no_zero_genset: \"0\\<notin>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'w) \\<notin> S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'w) \\<in> S \\<Longrightarrow> False", "assume \"0\\<in>S\""], ["proof (state)\nthis:\n  (0::'w) \\<in> S\n\ngoal (1 subgoal):\n 1. (0::'w) \\<in> S \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (0::'w) \\<in> S\n\ngoal (1 subgoal):\n 1. (0::'w) \\<in> S \\<Longrightarrow> False", "have \"add_order (0::'w) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_order (0::'w) = 1", "using add_order0"], ["proof (prove)\nusing this:\n  add_order (0::?'a) = 1\n\ngoal (1 subgoal):\n 1. add_order (0::'w) = 1", "by fast"], ["proof (state)\nthis:\n  add_order (0::'w) = 1\n\ngoal (1 subgoal):\n 1. (0::'w) \\<in> S \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (0::'w) \\<in> S\n  add_order (0::'w) = 1", "show False"], ["proof (prove)\nusing this:\n  (0::'w) \\<in> S\n  add_order (0::'w) = 1\n\ngoal (1 subgoal):\n 1. False", "using genset_order2"], ["proof (prove)\nusing this:\n  (0::'w) \\<in> S\n  add_order (0::'w) = 1\n  ?s \\<in> S \\<Longrightarrow> add_order ?s = 2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma genset_order2_add: \"s\\<in>S \\<Longrightarrow> s + s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> s + s = (0::'w)", "using add_order[of s]"], ["proof (prove)\nusing this:\n  s +^ add_order s = (0::'w)\n\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> s + s = (0::'w)", "by (simp add: genset_order2 nataction_2)"], ["", "lemmas genset_uminus = minus_unique[OF genset_order2_add]"], ["", "lemma relfun_S: \"s\\<in>S \\<Longrightarrow> relfun s s = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> add_order (s + s) = 1", "using add_order_relator[of s]"], ["proof (prove)\nusing this:\n  add_order (s +^ add_order s) = 1\n\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> add_order (s + s) = 1", "by (auto simp add: genset_order2 nataction_2)"], ["", "lemma relfun_eq1: \"\\<lbrakk> s\\<in>S; relfun s t = 1 \\<rbrakk> \\<Longrightarrow> t=s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; add_order (s + t) = 1\\<rbrakk>\n    \\<Longrightarrow> t = s", "using add_order_add_eq1 genset_uminus"], ["proof (prove)\nusing this:\n  add_order (?s + ?t) = 1 \\<Longrightarrow> ?t = - ?s\n  ?a \\<in> S \\<Longrightarrow> - ?a = ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; add_order (s + t) = 1\\<rbrakk>\n    \\<Longrightarrow> t = s", "by fastforce"], ["", "lemma S_relator_list: \"s\\<in>S \\<Longrightarrow> pair_relator_list s s = [s,s]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> pair_relator_list s s = [s, s]", "using relfun_S alternating_list2"], ["proof (prove)\nusing this:\n  ?s \\<in> S \\<Longrightarrow> add_order (?s + ?s) = 1\n  alternating_list 2 ?s ?t = [?s, ?t]\n\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> pair_relator_list s s = [s, s]", "by simp"], ["", "lemma S_sym: \"T \\<subseteq> S \\<Longrightarrow> uminus ` T \\<subseteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq S T \\<Longrightarrow> order.greater_eq T (uminus ` T)", "using genset_uminus"], ["proof (prove)\nusing this:\n  ?a \\<in> S \\<Longrightarrow> - ?a = ?a\n\ngoal (1 subgoal):\n 1. order.greater_eq S T \\<Longrightarrow> order.greater_eq T (uminus ` T)", "by auto"], ["", "lemmas special_subgroup_eq_sum_list =\n  genby_sym_eq_sum_lists[OF S_sym]"], ["", "lemmas genby_S_reduced_word_for_arg_min =\n  reduced_word_for_genby_sym_arg_min[OF S_sym]"], ["", "lemmas in_genby_S_reduced_letter_set =\n  in_genby_sym_imp_in_reduced_letter_set[OF S_sym]"], ["", "end"], ["", "(* context PreCoxeterSystem *)"], ["", "subsubsection \\<open>Special cosets\\<close>"], ["", "text \\<open>\n  From a Coxeter system we will eventually construct an associated chamber complex. To do so, we\n  will consider the collection of special cosets: left cosets of subgroups generated by subsets of\n  the generating set @{term S}. This collection forms a poset under the supset relation that, under\n  a certain extra assumption, can be used to form a simplicial complex whose poset of simplices\n  is isomorphic to this poset of special cosets.  In the literature, groups generated by subsets of\n  @{term S} are often referred to as parabolic subgroups of @{term W}, and their cosets as parabolic\n  cosets, but following Garrett \\cite{Garrett:Buildings} we have opted for the names special\n  subgroups and special cosets.\n\\<close>"], ["", "context PreCoxeterSystem\nbegin"], ["", "definition special_cosets :: \"'w set set\"\n  where \"special_cosets \\<equiv> (\\<Union>T\\<in>Pow S. (\\<Union>w\\<in>W. { w +o \\<langle>T\\<rangle> }))\""], ["", "abbreviation \"\\<P> \\<equiv> special_cosets\""], ["", "lemma special_cosetsI: \"T\\<in>Pow S \\<Longrightarrow> w\\<in>W \\<Longrightarrow> w +o \\<langle>T\\<rangle> \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<in> Pow S; w \\<in> W\\<rbrakk>\n    \\<Longrightarrow> w +o \\<langle>T\\<rangle> \\<in> \\<P>", "using special_cosets_def"], ["proof (prove)\nusing this:\n  \\<P> \\<equiv>\n  \\<Union>T\\<in>Pow S. \\<Union>w\\<in>W. {w +o \\<langle>T\\<rangle>}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<in> Pow S; w \\<in> W\\<rbrakk>\n    \\<Longrightarrow> w +o \\<langle>T\\<rangle> \\<in> \\<P>", "by auto"], ["", "lemma special_coset_singleton: \"w\\<in>W \\<Longrightarrow> {w}\\<in>\\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> W \\<Longrightarrow> {w} \\<in> \\<P>", "using special_cosetsI genby_lcoset_empty[of w]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?T \\<in> Pow S; ?w \\<in> W\\<rbrakk>\n  \\<Longrightarrow> ?w +o \\<langle>?T\\<rangle> \\<in> \\<P>\n  w +o \\<langle>{}\\<rangle> = {w}\n\ngoal (1 subgoal):\n 1. w \\<in> W \\<Longrightarrow> {w} \\<in> \\<P>", "by fastforce"], ["", "lemma special_coset_nempty: \"X\\<in>\\<P> \\<Longrightarrow> X \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> \\<P> \\<Longrightarrow> X \\<noteq> {}", "using special_cosets_def genby_lcoset_refl"], ["proof (prove)\nusing this:\n  \\<P> \\<equiv>\n  \\<Union>T\\<in>Pow S. \\<Union>w\\<in>W. {w +o \\<langle>T\\<rangle>}\n  ?a \\<in> ?a +o \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. X \\<in> \\<P> \\<Longrightarrow> X \\<noteq> {}", "by fastforce"], ["", "lemma special_subgroup_special_coset: \"T\\<in>Pow S \\<Longrightarrow> \\<langle>T\\<rangle> \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<in> Pow S \\<Longrightarrow> \\<langle>T\\<rangle> \\<in> \\<P>", "using genby_0_closed special_cosetsI[of T]"], ["proof (prove)\nusing this:\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n  \\<lbrakk>T \\<in> Pow S; ?w \\<in> W\\<rbrakk>\n  \\<Longrightarrow> ?w +o \\<langle>T\\<rangle> \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. T \\<in> Pow S \\<Longrightarrow> \\<langle>T\\<rangle> \\<in> \\<P>", "by fastforce"], ["", "lemma special_cosets_lcoset_closed: \"w\\<in>W \\<Longrightarrow> X\\<in>\\<P> \\<Longrightarrow> w +o X \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W; X \\<in> \\<P>\\<rbrakk>\n    \\<Longrightarrow> w +o X \\<in> \\<P>", "using genby_add_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> \\<langle>?S\\<rangle>;\n   ?h \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?g + ?h \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W; X \\<in> \\<P>\\<rbrakk>\n    \\<Longrightarrow> w +o X \\<in> \\<P>", "unfolding special_cosets_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> \\<langle>?S\\<rangle>;\n   ?h \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?g + ?h \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W;\n     X \\<in> (\\<Union>T\\<in>Pow S.\n                 \\<Union>w\\<in>W. {w +o \\<langle>T\\<rangle>})\\<rbrakk>\n    \\<Longrightarrow> w +o X\n                      \\<in> (\\<Union>T\\<in>Pow S.\n                                \\<Union>w\\<in>W. {w +o \\<langle>T\\<rangle>})", "by    (fastforce simp add: set_plus_rearrange2)"], ["", "lemma special_cosets_lcoset_shift: \"w\\<in>W \\<Longrightarrow> ((+o) w) ` \\<P> = \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> W \\<Longrightarrow> (+o) w ` \\<P> = \\<P>", "using special_cosets_lcoset_closed genby_uminus_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w \\<in> W; ?X \\<in> \\<P>\\<rbrakk>\n  \\<Longrightarrow> ?w +o ?X \\<in> \\<P>\n  ?g \\<in> \\<langle>?S\\<rangle> \\<Longrightarrow>\n  - ?g \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. w \\<in> W \\<Longrightarrow> (+o) w ` \\<P> = \\<P>", "by    (force simp add: set_plus_rearrange2)"], ["", "lemma special_cosets_has_bottom: \"supset_has_bottom \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_order.has_bottom \\<P>", "proof (rule ordering.has_bottomI, rule supset_poset)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?z \\<in> \\<P>\n 2. \\<And>x. x \\<in> \\<P> \\<Longrightarrow> order.greater_eq ?z x", "show \"W\\<in>\\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. W \\<in> \\<P>", "using special_subgroup_special_coset"], ["proof (prove)\nusing this:\n  ?T \\<in> Pow S \\<Longrightarrow> \\<langle>?T\\<rangle> \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. W \\<in> \\<P>", "by fast"], ["proof (state)\nthis:\n  W \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<P> \\<Longrightarrow> order.greater_eq W x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<P> \\<Longrightarrow> order.greater_eq W x", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<P> \\<Longrightarrow> order.greater_eq W x", "assume X: \"X\\<in>\\<P>\""], ["proof (state)\nthis:\n  X \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<P> \\<Longrightarrow> order.greater_eq W x", "from this"], ["proof (chain)\npicking this:\n  X \\<in> \\<P>", "obtain w T where wT: \"w\\<in>W\" \"T\\<in>Pow S\" \"X = w +o \\<langle>T\\<rangle>\""], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>w T.\n        \\<lbrakk>w \\<in> W; T \\<in> Pow S;\n         X = w +o \\<langle>T\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using special_cosets_def"], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n  \\<P> \\<equiv>\n  \\<Union>T\\<in>Pow S. \\<Union>w\\<in>W. {w +o \\<langle>T\\<rangle>}\n\ngoal (1 subgoal):\n 1. (\\<And>w T.\n        \\<lbrakk>w \\<in> W; T \\<in> Pow S;\n         X = w +o \\<langle>T\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> W\n  T \\<in> Pow S\n  X = w +o \\<langle>T\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<P> \\<Longrightarrow> order.greater_eq W x", "thus \"X \\<subseteq> W\""], ["proof (prove)\nusing this:\n  w \\<in> W\n  T \\<in> Pow S\n  X = w +o \\<langle>T\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq W X", "using genby_mono[of T] genby_lcoset_closed[of w]"], ["proof (prove)\nusing this:\n  w \\<in> W\n  T \\<in> Pow S\n  X = w +o \\<langle>T\\<rangle>\n  order.greater_eq ?S T \\<Longrightarrow>\n  order.greater_eq \\<langle>?S\\<rangle> \\<langle>T\\<rangle>\n  \\<lbrakk>w \\<in> \\<langle>?S\\<rangle>;\n   order.greater_eq \\<langle>?S\\<rangle> ?A\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq \\<langle>?S\\<rangle> (w +o ?A)\n\ngoal (1 subgoal):\n 1. order.greater_eq W X", "by auto"], ["proof (state)\nthis:\n  order.greater_eq W X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma special_cosets_bottom: \"supset_bottom \\<P> = W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_order.bottom \\<P> = W", "proof (rule supset_bottomI[THEN sym])"], ["proof (state)\ngoal (2 subgoals):\n 1. W \\<in> \\<P>\n 2. \\<And>y. y \\<in> \\<P> \\<Longrightarrow> order.greater_eq W y", "fix X"], ["proof (state)\ngoal (2 subgoals):\n 1. W \\<in> \\<P>\n 2. \\<And>y. y \\<in> \\<P> \\<Longrightarrow> order.greater_eq W y", "assume \"X\\<in>\\<P>\""], ["proof (state)\nthis:\n  X \\<in> \\<P>\n\ngoal (2 subgoals):\n 1. W \\<in> \\<P>\n 2. \\<And>y. y \\<in> \\<P> \\<Longrightarrow> order.greater_eq W y", "from this"], ["proof (chain)\npicking this:\n  X \\<in> \\<P>", "obtain w T where \"w\\<in>W\" \"T\\<in>Pow S\" \"X = w +o \\<langle>T\\<rangle>\""], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>w T.\n        \\<lbrakk>w \\<in> W; T \\<in> Pow S;\n         X = w +o \\<langle>T\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using special_cosets_def"], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n  \\<P> \\<equiv>\n  \\<Union>T\\<in>Pow S. \\<Union>w\\<in>W. {w +o \\<langle>T\\<rangle>}\n\ngoal (1 subgoal):\n 1. (\\<And>w T.\n        \\<lbrakk>w \\<in> W; T \\<in> Pow S;\n         X = w +o \\<langle>T\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> W\n  T \\<in> Pow S\n  X = w +o \\<langle>T\\<rangle>\n\ngoal (2 subgoals):\n 1. W \\<in> \\<P>\n 2. \\<And>y. y \\<in> \\<P> \\<Longrightarrow> order.greater_eq W y", "thus \"X\\<subseteq>W\""], ["proof (prove)\nusing this:\n  w \\<in> W\n  T \\<in> Pow S\n  X = w +o \\<langle>T\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq W X", "using genby_mono[of T S] set_plus_mono[of \"\\<langle>T\\<rangle>\" W] genby_lcoset_el_reduce"], ["proof (prove)\nusing this:\n  w \\<in> W\n  T \\<in> Pow S\n  X = w +o \\<langle>T\\<rangle>\n  order.greater_eq S T \\<Longrightarrow>\n  order.greater_eq W \\<langle>T\\<rangle>\n  order.greater_eq W \\<langle>T\\<rangle> \\<Longrightarrow>\n  order.greater_eq (?a +o W) (?a +o \\<langle>T\\<rangle>)\n  ?a \\<in> \\<langle>?S\\<rangle> \\<Longrightarrow>\n  ?a +o \\<langle>?S\\<rangle> = \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq W X", "by    force"], ["proof (state)\nthis:\n  order.greater_eq W X\n\ngoal (1 subgoal):\n 1. W \\<in> \\<P>", "qed (auto simp add: special_subgroup_special_coset)"], ["", "end"], ["", "(* context PreCoxeterSystem *)"], ["", "subsubsection \\<open>Transfer from the free group over generators\\<close>"], ["", "text \\<open>\n  We form a set of relators and show that it and @{term S} form a\n  @{const GroupWithGeneratorsRelators}. The associated quotient group @{term G} maps surjectively\n  onto @{term W}. In the \\<open>CoxeterSystem\\<close> locale below, this correspondence will be assumed\n  to be injective as well.\n\\<close>"], ["", "context PreCoxeterSystem\nbegin"], ["", "abbreviation R :: \"'w list set\" where \"R \\<equiv> (\\<Union>s\\<in>S. \\<Union>t\\<in>S. {pair_relator_list s t})\""], ["", "abbreviation \"P \\<equiv> map (charpair S) ` R\""], ["", "abbreviation \"P' \\<equiv> GroupWithGeneratorsRelators.P' S R\""], ["", "abbreviation \"Q \\<equiv> GroupWithGeneratorsRelators.Q S R\""], ["", "abbreviation \"G \\<equiv> GroupWithGeneratorsRelators.G S R\""], ["", "abbreviation \"relator_freeword \\<equiv>\n                GroupWithGeneratorsRelators.relator_freeword S\""], ["", "abbreviation pair_relator_freeword :: \"'w \\<Rightarrow> 'w \\<Rightarrow> 'w freeword\"\n  where \"pair_relator_freeword s t \\<equiv> Abs_freelist (pair_relator_list s t)\""], ["", "abbreviation \"freeliftid \\<equiv> freeword_funlift id\""], ["", "abbreviation induced_id :: \"'w freeword set permutation \\<Rightarrow> 'w\"\n  where \"induced_id \\<equiv> GroupWithGeneratorsRelators.induced_id S R\""], ["", "lemma S_relator_freeword: \"s\\<in>S \\<Longrightarrow> pair_relator_freeword s s = s[+]s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> pair_relator_freeword s s = s [+] s", "by (simp add: S_relator_list Abs_freeletter_add)"], ["", "lemma map_charpair_map_pairtrue_R:\n  \"s\\<in>S \\<Longrightarrow> t\\<in>S \\<Longrightarrow>\n    map (charpair S) (pair_relator_list s t) = map pairtrue (pair_relator_list s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map (charpair S) (pair_relator_list s t) =\n                      map pairtrue (pair_relator_list s t)", "using set_alternating_list map_charpair_uniform"], ["proof (prove)\nusing this:\n  order.greater_eq {?s, ?t} (set (alternating_list ?n ?s ?t))\n  ?ss \\<in> lists ?S \\<Longrightarrow>\n  map (charpair ?S) ?ss = map pairtrue ?ss\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S\\<rbrakk>\n    \\<Longrightarrow> map (charpair S) (pair_relator_list s t) =\n                      map pairtrue (pair_relator_list s t)", "by fastforce"], ["", "lemma relator_freeword:\n  \"s\\<in>S \\<Longrightarrow> t\\<in>S \\<Longrightarrow>\n    pair_relator_freeword s t = relator_freeword (pair_relator_list s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S\\<rbrakk>\n    \\<Longrightarrow> pair_relator_freeword s t =\n                      relator_freeword (pair_relator_list s t)", "using set_alternating_list\n        arg_cong[OF map_charpair_map_pairtrue_R, of s t Abs_freeword]"], ["proof (prove)\nusing this:\n  order.greater_eq {?s, ?t} (set (alternating_list ?n ?s ?t))\n  \\<lbrakk>s \\<in> S; t \\<in> S\\<rbrakk>\n  \\<Longrightarrow> relator_freeword (pair_relator_list s t) =\n                    pair_relator_freeword s t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S\\<rbrakk>\n    \\<Longrightarrow> pair_relator_freeword s t =\n                      relator_freeword (pair_relator_list s t)", "by    fastforce"], ["", "lemma relator_freewords: \"Abs_freelist ` R = P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_freelist ` R = Abs_freeword ` map (charpair S) ` R", "using relator_freeword"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s \\<in> S; ?t \\<in> S\\<rbrakk>\n  \\<Longrightarrow> pair_relator_freeword ?s ?t =\n                    relator_freeword (pair_relator_list ?s ?t)\n\ngoal (1 subgoal):\n 1. Abs_freelist ` R = Abs_freeword ` map (charpair S) ` R", "by force"], ["", "lemma GroupWithGeneratorsRelators_S_R: \"GroupWithGeneratorsRelators S R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupWithGeneratorsRelators S R", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>rs.\n       rs \\<in> R \\<Longrightarrow> rs \\<in> lists (S \\<union> uminus ` S)\n 2. \\<And>rs. rs \\<in> R \\<Longrightarrow> sum_list rs = (0::'w)\n 3. \\<And>rs.\n       rs \\<in> R \\<Longrightarrow> proper_signed_list (map (charpair S) rs)", "fix rs"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>rs.\n       rs \\<in> R \\<Longrightarrow> rs \\<in> lists (S \\<union> uminus ` S)\n 2. \\<And>rs. rs \\<in> R \\<Longrightarrow> sum_list rs = (0::'w)\n 3. \\<And>rs.\n       rs \\<in> R \\<Longrightarrow> proper_signed_list (map (charpair S) rs)", "assume rs: \"rs\\<in>R\""], ["proof (state)\nthis:\n  rs \\<in> R\n\ngoal (3 subgoals):\n 1. \\<And>rs.\n       rs \\<in> R \\<Longrightarrow> rs \\<in> lists (S \\<union> uminus ` S)\n 2. \\<And>rs. rs \\<in> R \\<Longrightarrow> sum_list rs = (0::'w)\n 3. \\<And>rs.\n       rs \\<in> R \\<Longrightarrow> proper_signed_list (map (charpair S) rs)", "hence rs': \"rs \\<in> lists S\""], ["proof (prove)\nusing this:\n  rs \\<in> R\n\ngoal (1 subgoal):\n 1. rs \\<in> lists S", "using set_alternating_list"], ["proof (prove)\nusing this:\n  rs \\<in> R\n  order.greater_eq {?s, ?t} (set (alternating_list ?n ?s ?t))\n\ngoal (1 subgoal):\n 1. rs \\<in> lists S", "by fast"], ["proof (state)\nthis:\n  rs \\<in> lists S\n\ngoal (3 subgoals):\n 1. \\<And>rs.\n       rs \\<in> R \\<Longrightarrow> rs \\<in> lists (S \\<union> uminus ` S)\n 2. \\<And>rs. rs \\<in> R \\<Longrightarrow> sum_list rs = (0::'w)\n 3. \\<And>rs.\n       rs \\<in> R \\<Longrightarrow> proper_signed_list (map (charpair S) rs)", "from rs'"], ["proof (chain)\npicking this:\n  rs \\<in> lists S", "show \"rs \\<in> lists (S \\<union> uminus ` S)\""], ["proof (prove)\nusing this:\n  rs \\<in> lists S\n\ngoal (1 subgoal):\n 1. rs \\<in> lists (S \\<union> uminus ` S)", "by fast"], ["proof (state)\nthis:\n  rs \\<in> lists (S \\<union> uminus ` S)\n\ngoal (2 subgoals):\n 1. \\<And>rs. rs \\<in> R \\<Longrightarrow> sum_list rs = (0::'w)\n 2. \\<And>rs.\n       rs \\<in> R \\<Longrightarrow> proper_signed_list (map (charpair S) rs)", "from rs"], ["proof (chain)\npicking this:\n  rs \\<in> R", "show \"sum_list rs = 0\""], ["proof (prove)\nusing this:\n  rs \\<in> R\n\ngoal (1 subgoal):\n 1. sum_list rs = (0::'w)", "using sum_list_pair_relator_list"], ["proof (prove)\nusing this:\n  rs \\<in> R\n  sum_list (pair_relator_list ?s ?t) = (0::?'a)\n\ngoal (1 subgoal):\n 1. sum_list rs = (0::'w)", "by fast"], ["proof (state)\nthis:\n  sum_list rs = (0::'w)\n\ngoal (1 subgoal):\n 1. \\<And>rs.\n       rs \\<in> R \\<Longrightarrow> proper_signed_list (map (charpair S) rs)", "from rs'"], ["proof (chain)\npicking this:\n  rs \\<in> lists S", "show \"proper_signed_list (map (charpair S) rs)\""], ["proof (prove)\nusing this:\n  rs \\<in> lists S\n\ngoal (1 subgoal):\n 1. proper_signed_list (map (charpair S) rs)", "using proper_signed_list_map_uniform_snd\n          arg_cong[of \"map (charpair S) rs\" \"map pairtrue rs\" proper_signed_list]"], ["proof (prove)\nusing this:\n  rs \\<in> lists S\n  proper_signed_list (map (\\<lambda>s. (s, ?b)) ?as)\n  map (charpair S) rs = map pairtrue rs \\<Longrightarrow>\n  proper_signed_list (map (charpair S) rs) =\n  proper_signed_list (map pairtrue rs)\n\ngoal (1 subgoal):\n 1. proper_signed_list (map (charpair S) rs)", "by    fastforce"], ["proof (state)\nthis:\n  proper_signed_list (map (charpair S) rs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas GroupByPresentation_S_P =\n  GroupWithGeneratorsRelators.GroupByPresentation_S_P[\n    OF GroupWithGeneratorsRelators_S_R\n  ]"], ["", "lemmas Q_FreeS = GroupByPresentation.Q_FreeS[OF GroupByPresentation_S_P]"], ["", "lemma relator_freeword_Q: \"s\\<in>S \\<Longrightarrow> t\\<in>S \\<Longrightarrow> pair_relator_freeword s t \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S\\<rbrakk>\n    \\<Longrightarrow> pair_relator_freeword s t\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "using relator_freeword\n        GroupByPresentation.relators[OF GroupByPresentation_S_P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s \\<in> S; ?t \\<in> S\\<rbrakk>\n  \\<Longrightarrow> pair_relator_freeword ?s ?t =\n                    relator_freeword (pair_relator_list ?s ?t)\n  order.greater_eq\n   \\<langle>\\<Union>g\\<in>FreeGroup S.\n               lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n   (Abs_freeword ` map (charpair S) ` R)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S\\<rbrakk>\n    \\<Longrightarrow> pair_relator_freeword s t\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "by    fastforce"], ["", "lemmas P'_FreeS =\n  GroupWithGeneratorsRelators.P'_FreeS[\n    OF GroupWithGeneratorsRelators_S_R\n  ]"], ["", "lemmas GroupByPresentationInducedFun_S_P_id =\n  GroupWithGeneratorsRelators.GroupByPresentationInducedFun_S_P_id[\n    OF GroupWithGeneratorsRelators_S_R\n  ]"], ["", "lemma rconj_relator_freeword:\n  \"\\<lbrakk> s\\<in>S; t\\<in>S; proper_signed_list xs; fst ` set xs \\<subseteq> S \\<rbrakk> \\<Longrightarrow>\n    rconjby (Abs_freeword xs) (pair_relator_freeword s t) \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S; proper_signed_list xs;\n     order.greater_eq S (fst ` set xs)\\<rbrakk>\n    \\<Longrightarrow> rconjby (Abs_freeword xs) (pair_relator_freeword s t)\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "using GroupWithGeneratorsRelators.rconj_relator_freeword[\n          OF GroupWithGeneratorsRelators_S_R\n        ]\n        relator_freeword"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs \\<in> R; proper_signed_list ?xs;\n   order.greater_eq S (fst ` set ?xs)\\<rbrakk>\n  \\<Longrightarrow> rconjby (Abs_freeword ?xs) (relator_freeword ?rs)\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  \\<lbrakk>?s \\<in> S; ?t \\<in> S\\<rbrakk>\n  \\<Longrightarrow> pair_relator_freeword ?s ?t =\n                    relator_freeword (pair_relator_list ?s ?t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S; proper_signed_list xs;\n     order.greater_eq S (fst ` set xs)\\<rbrakk>\n    \\<Longrightarrow> rconjby (Abs_freeword xs) (pair_relator_freeword s t)\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "by    force"], ["", "lemma lconjby_Abs_freelist_relator_freeword:\n  \"\\<lbrakk> s\\<in>S; t\\<in>S; xs\\<in>lists S \\<rbrakk> \\<Longrightarrow>\n    lconjby (Abs_freelist xs) (pair_relator_freeword s t) \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S; xs \\<in> lists S\\<rbrakk>\n    \\<Longrightarrow> lconjby (Abs_freelist xs) (pair_relator_freeword s t)\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "using GroupWithGeneratorsRelators.lconjby_Abs_freelist_relator_freeword[\n          OF GroupWithGeneratorsRelators_S_R\n        ]\n        relator_freeword"], ["proof (prove)\nusing this:\n  \\<lbrakk>?rs \\<in> R; ?xs \\<in> lists S\\<rbrakk>\n  \\<Longrightarrow> lconjby (Abs_freelist ?xs) (relator_freeword ?rs)\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  \\<lbrakk>?s \\<in> S; ?t \\<in> S\\<rbrakk>\n  \\<Longrightarrow> pair_relator_freeword ?s ?t =\n                    relator_freeword (pair_relator_list ?s ?t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S; xs \\<in> lists S\\<rbrakk>\n    \\<Longrightarrow> lconjby (Abs_freelist xs) (pair_relator_freeword s t)\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "by    force"], ["", "lemma Abs_freelist_rev_append_alternating_list_in_Q:\n  assumes \"s\\<in>S\" \"t\\<in>S\"\n  shows \"Abs_freelist (rev (alternating_list n s t) @ alternating_list n s t) \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_freelist (rev (alternating_list n s t) @ alternating_list n s t)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. Abs_freelist (rev (alternating_list 0 s t) @ alternating_list 0 s t)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. \\<And>n.\n       Abs_freelist (rev (alternating_list n s t) @ alternating_list n s t)\n       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword `\n                         map (charpair S) ` R\\<rangle> \\<Longrightarrow>\n       Abs_freelist\n        (rev (alternating_list (Suc n) s t) @ alternating_list (Suc n) s t)\n       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "case (Suc m)"], ["proof (state)\nthis:\n  Abs_freelist (rev (alternating_list m s t) @ alternating_list m s t)\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (2 subgoals):\n 1. Abs_freelist (rev (alternating_list 0 s t) @ alternating_list 0 s t)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. \\<And>n.\n       Abs_freelist (rev (alternating_list n s t) @ alternating_list n s t)\n       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword `\n                         map (charpair S) ` R\\<rangle> \\<Longrightarrow>\n       Abs_freelist\n        (rev (alternating_list (Suc n) s t) @ alternating_list (Suc n) s t)\n       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "define u where \"u = (if even m then s else t)\""], ["proof (state)\nthis:\n  u = (if gcd_nat.greater_eq m 2 then s else t)\n\ngoal (2 subgoals):\n 1. Abs_freelist (rev (alternating_list 0 s t) @ alternating_list 0 s t)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. \\<And>n.\n       Abs_freelist (rev (alternating_list n s t) @ alternating_list n s t)\n       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword `\n                         map (charpair S) ` R\\<rangle> \\<Longrightarrow>\n       Abs_freelist\n        (rev (alternating_list (Suc n) s t) @ alternating_list (Suc n) s t)\n       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "define x where \"x = Abs_freelist (rev (alternating_list m s t) @ alternating_list m s t)\""], ["proof (state)\nthis:\n  x = Abs_freelist (rev (alternating_list m s t) @ alternating_list m s t)\n\ngoal (2 subgoals):\n 1. Abs_freelist (rev (alternating_list 0 s t) @ alternating_list 0 s t)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. \\<And>n.\n       Abs_freelist (rev (alternating_list n s t) @ alternating_list n s t)\n       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword `\n                         map (charpair S) ` R\\<rangle> \\<Longrightarrow>\n       Abs_freelist\n        (rev (alternating_list (Suc n) s t) @ alternating_list (Suc n) s t)\n       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "from u_def x_def assms"], ["proof (chain)\npicking this:\n  u = (if gcd_nat.greater_eq m 2 then s else t)\n  x = Abs_freelist (rev (alternating_list m s t) @ alternating_list m s t)\n  s \\<in> S\n  t \\<in> S", "have\n    \"Abs_freelist (rev (alternating_list (Suc m) s t) @\n      alternating_list (Suc m) s t) =\n        (pair_relator_freeword u u) + rconjby (Abs_freeletter u) x\""], ["proof (prove)\nusing this:\n  u = (if gcd_nat.greater_eq m 2 then s else t)\n  x = Abs_freelist (rev (alternating_list m s t) @ alternating_list m s t)\n  s \\<in> S\n  t \\<in> S\n\ngoal (1 subgoal):\n 1. Abs_freelist\n     (rev (alternating_list (Suc m) s t) @ alternating_list (Suc m) s t) =\n    pair_relator_freeword u u + rconjby (Abs_freeletter u) x", "using Abs_freelist_append[of\n            \"u # rev (alternating_list m s t) @ alternating_list m s t\"\n            \"[u]\"\n          ]\n          Abs_freelist_Cons[of\n            u\n            \"rev (alternating_list m s t) @ alternating_list m s t\"\n          ]"], ["proof (prove)\nusing this:\n  u = (if gcd_nat.greater_eq m 2 then s else t)\n  x = Abs_freelist (rev (alternating_list m s t) @ alternating_list m s t)\n  s \\<in> S\n  t \\<in> S\n  Abs_freelist\n   ((u # rev (alternating_list m s t) @ alternating_list m s t) @ [u]) =\n  Abs_freelist (u # rev (alternating_list m s t) @ alternating_list m s t) +\n  Abs_freelist [u]\n  Abs_freelist (u # rev (alternating_list m s t) @ alternating_list m s t) =\n  Abs_freeletter u +\n  Abs_freelist (rev (alternating_list m s t) @ alternating_list m s t)\n\ngoal (1 subgoal):\n 1. Abs_freelist\n     (rev (alternating_list (Suc m) s t) @ alternating_list (Suc m) s t) =\n    pair_relator_freeword u u + rconjby (Abs_freeletter u) x", "by    (simp add: add.assoc[THEN sym] S_relator_freeword)"], ["proof (state)\nthis:\n  Abs_freelist\n   (rev (alternating_list (Suc m) s t) @ alternating_list (Suc m) s t) =\n  pair_relator_freeword u u + rconjby (Abs_freeletter u) x\n\ngoal (2 subgoals):\n 1. Abs_freelist (rev (alternating_list 0 s t) @ alternating_list 0 s t)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. \\<And>n.\n       Abs_freelist (rev (alternating_list n s t) @ alternating_list n s t)\n       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword `\n                         map (charpair S) ` R\\<rangle> \\<Longrightarrow>\n       Abs_freelist\n        (rev (alternating_list (Suc n) s t) @ alternating_list (Suc n) s t)\n       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "moreover"], ["proof (state)\nthis:\n  Abs_freelist\n   (rev (alternating_list (Suc m) s t) @ alternating_list (Suc m) s t) =\n  pair_relator_freeword u u + rconjby (Abs_freeletter u) x\n\ngoal (2 subgoals):\n 1. Abs_freelist (rev (alternating_list 0 s t) @ alternating_list 0 s t)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. \\<And>n.\n       Abs_freelist (rev (alternating_list n s t) @ alternating_list n s t)\n       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword `\n                         map (charpair S) ` R\\<rangle> \\<Longrightarrow>\n       Abs_freelist\n        (rev (alternating_list (Suc n) s t) @ alternating_list (Suc n) s t)\n       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "from Suc assms u_def x_def"], ["proof (chain)\npicking this:\n  Abs_freelist (rev (alternating_list m s t) @ alternating_list m s t)\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  s \\<in> S\n  t \\<in> S\n  u = (if gcd_nat.greater_eq m 2 then s else t)\n  x = Abs_freelist (rev (alternating_list m s t) @ alternating_list m s t)", "have \"rconjby (Abs_freeletter u) x \\<in> Q\""], ["proof (prove)\nusing this:\n  Abs_freelist (rev (alternating_list m s t) @ alternating_list m s t)\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  s \\<in> S\n  t \\<in> S\n  u = (if gcd_nat.greater_eq m 2 then s else t)\n  x = Abs_freelist (rev (alternating_list m s t) @ alternating_list m s t)\n\ngoal (1 subgoal):\n 1. rconjby (Abs_freeletter u) x\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "using Abs_freeletter_in_FreeGroup_iff[of _ S]\n          FreeGroup_genby_set_lconjby_set_rconjby_closed"], ["proof (prove)\nusing this:\n  Abs_freelist (rev (alternating_list m s t) @ alternating_list m s t)\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  s \\<in> S\n  t \\<in> S\n  u = (if gcd_nat.greater_eq m 2 then s else t)\n  x = Abs_freelist (rev (alternating_list m s t) @ alternating_list m s t)\n  (Abs_freeletter ?s \\<in> FreeGroup S) = (?s \\<in> S)\n  \\<lbrakk>?g \\<in> FreeGroup ?S;\n   ?x \\<in> \\<langle>\\<Union>g\\<in>FreeGroup ?S.\n                        lconjby g ` ?A\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> rconjby ?g ?x\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup ?S.\nlconjby g ` ?A\\<rangle>\n\ngoal (1 subgoal):\n 1. rconjby (Abs_freeletter u) x\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "by    fastforce"], ["proof (state)\nthis:\n  rconjby (Abs_freeletter u) x\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (2 subgoals):\n 1. Abs_freelist (rev (alternating_list 0 s t) @ alternating_list 0 s t)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. \\<And>n.\n       Abs_freelist (rev (alternating_list n s t) @ alternating_list n s t)\n       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword `\n                         map (charpair S) ` R\\<rangle> \\<Longrightarrow>\n       Abs_freelist\n        (rev (alternating_list (Suc n) s t) @ alternating_list (Suc n) s t)\n       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  Abs_freelist\n   (rev (alternating_list (Suc m) s t) @ alternating_list (Suc m) s t) =\n  pair_relator_freeword u u + rconjby (Abs_freeletter u) x\n  rconjby (Abs_freeletter u) x\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  Abs_freelist\n   (rev (alternating_list (Suc m) s t) @ alternating_list (Suc m) s t) =\n  pair_relator_freeword u u + rconjby (Abs_freeletter u) x\n  rconjby (Abs_freeletter u) x\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. Abs_freelist\n     (rev (alternating_list (Suc m) s t) @ alternating_list (Suc m) s t)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "using u_def assms relator_freeword_Q genby_add_closed"], ["proof (prove)\nusing this:\n  Abs_freelist\n   (rev (alternating_list (Suc m) s t) @ alternating_list (Suc m) s t) =\n  pair_relator_freeword u u + rconjby (Abs_freeletter u) x\n  rconjby (Abs_freeletter u) x\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  u = (if gcd_nat.greater_eq m 2 then s else t)\n  s \\<in> S\n  t \\<in> S\n  \\<lbrakk>?s \\<in> S; ?t \\<in> S\\<rbrakk>\n  \\<Longrightarrow> pair_relator_freeword ?s ?t\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  \\<lbrakk>?g \\<in> \\<langle>?S\\<rangle>;\n   ?h \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?g + ?h \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. Abs_freelist\n     (rev (alternating_list (Suc m) s t) @ alternating_list (Suc m) s t)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "by fastforce"], ["proof (state)\nthis:\n  Abs_freelist\n   (rev (alternating_list (Suc m) s t) @ alternating_list (Suc m) s t)\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. Abs_freelist (rev (alternating_list 0 s t) @ alternating_list 0 s t)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "qed (simp add: zero_freeword.abs_eq[THEN sym] genby_0_closed)"], ["", "lemma Abs_freeword_freelist_uminus_add_in_Q:\n  \"proper_signed_list xs \\<Longrightarrow> fst ` set xs \\<subseteq> S \\<Longrightarrow>\n    - Abs_freelistfst xs + Abs_freeword xs \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs;\n     order.greater_eq S (fst ` set xs)\\<rbrakk>\n    \\<Longrightarrow> - Abs_freelistfst xs + Abs_freeword xs\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>proper_signed_list [];\n     order.greater_eq S (fst ` set [])\\<rbrakk>\n    \\<Longrightarrow> - Abs_freelistfst [] + Abs_freeword []\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> - Abs_freelistfst xs + Abs_freeword xs\n                                  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n              lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>;\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> - Abs_freelistfst (a # xs) + Abs_freeword (a # xs)\n                         \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n     lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs)\\<rbrakk>\n  \\<Longrightarrow> - Abs_freelistfst xs + Abs_freeword xs\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  proper_signed_list (x # xs)\n  order.greater_eq S (fst ` set (x # xs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>proper_signed_list [];\n     order.greater_eq S (fst ` set [])\\<rbrakk>\n    \\<Longrightarrow> - Abs_freelistfst [] + Abs_freeword []\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> - Abs_freelistfst xs + Abs_freeword xs\n                                  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n              lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>;\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> - Abs_freelistfst (a # xs) + Abs_freeword (a # xs)\n                         \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n     lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "from Cons(2)"], ["proof (chain)\npicking this:\n  proper_signed_list (x # xs)", "have 1:\n    \"- Abs_freelistfst (x#xs) + Abs_freeword (x#xs) =\n        -Abs_freelistfst xs + -Abs_freeletter (fst x)\n          + Abs_freeword [x] + Abs_freeword xs\""], ["proof (prove)\nusing this:\n  proper_signed_list (x # xs)\n\ngoal (1 subgoal):\n 1. - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n    - Abs_freelistfst xs + - Abs_freeletter (fst x) + Abs_freeword [x] +\n    Abs_freeword xs", "using Abs_freelist_Cons[of \"fst x\" \"map fst xs\"]"], ["proof (prove)\nusing this:\n  proper_signed_list (x # xs)\n  Abs_freelist (fst x # map fst xs) =\n  Abs_freeletter (fst x) + Abs_freelistfst xs\n\ngoal (1 subgoal):\n 1. - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n    - Abs_freelistfst xs + - Abs_freeletter (fst x) + Abs_freeword [x] +\n    Abs_freeword xs", "by (simp add: Abs_freeword_Cons[THEN sym] add.assoc minus_add)"], ["proof (state)\nthis:\n  - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n  - Abs_freelistfst xs + - Abs_freeletter (fst x) + Abs_freeword [x] +\n  Abs_freeword xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>proper_signed_list [];\n     order.greater_eq S (fst ` set [])\\<rbrakk>\n    \\<Longrightarrow> - Abs_freelistfst [] + Abs_freeword []\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> - Abs_freelistfst xs + Abs_freeword xs\n                                  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n              lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>;\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> - Abs_freelistfst (a # xs) + Abs_freeword (a # xs)\n                         \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n     lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "proof (cases \"snd x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. \\<not> snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "case True"], ["proof (state)\nthis:\n  snd x\n\ngoal (2 subgoals):\n 1. snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. \\<not> snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs)\\<rbrakk>\n  \\<Longrightarrow> - Abs_freelistfst xs + Abs_freeword xs\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  proper_signed_list (x # xs)\n  order.greater_eq S (fst ` set (x # xs))\n  snd x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs)\\<rbrakk>\n  \\<Longrightarrow> - Abs_freelistfst xs + Abs_freeword xs\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  proper_signed_list (x # xs)\n  order.greater_eq S (fst ` set (x # xs))\n  snd x\n\ngoal (1 subgoal):\n 1. - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "using 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs)\\<rbrakk>\n  \\<Longrightarrow> - Abs_freelistfst xs + Abs_freeword xs\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  proper_signed_list (x # xs)\n  order.greater_eq S (fst ` set (x # xs))\n  snd x\n  - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n  - Abs_freelistfst xs + - Abs_freeletter (fst x) + Abs_freeword [x] +\n  Abs_freeword xs\n\ngoal (1 subgoal):\n 1. - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "by    (simp add:\n              Abs_freeletter_prod_conv_Abs_freeword\n              binrelchain_Cons_reduce\n            )"], ["proof (state)\nthis:\n  - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "case False"], ["proof (state)\nthis:\n  \\<not> snd x\n\ngoal (1 subgoal):\n 1. \\<not> snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "define s where \"s = fst x\""], ["proof (state)\nthis:\n  s = fst x\n\ngoal (1 subgoal):\n 1. \\<not> snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "with Cons(3)"], ["proof (chain)\npicking this:\n  order.greater_eq S (fst ` set (x # xs))\n  s = fst x", "have s_S: \"s\\<in>S\""], ["proof (prove)\nusing this:\n  order.greater_eq S (fst ` set (x # xs))\n  s = fst x\n\ngoal (1 subgoal):\n 1. s \\<in> S", "by simp"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "define q where \"q = rconjby (Abs_freelistfst xs) (pair_relator_freeword s s)\""], ["proof (state)\nthis:\n  q = rconjby (Abs_freelistfst xs) (pair_relator_freeword s s)\n\ngoal (1 subgoal):\n 1. \\<not> snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "from s_def False Cons(3)"], ["proof (chain)\npicking this:\n  s = fst x\n  \\<not> snd x\n  order.greater_eq S (fst ` set (x # xs))", "have\n      \"- Abs_freelistfst (x#xs) + Abs_freeword (x#xs) =\n        -Abs_freelistfst xs + -pair_relator_freeword s s + Abs_freeword xs\""], ["proof (prove)\nusing this:\n  s = fst x\n  \\<not> snd x\n  order.greater_eq S (fst ` set (x # xs))\n\ngoal (1 subgoal):\n 1. - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n    - Abs_freelistfst xs + - pair_relator_freeword s s + Abs_freeword xs", "using 1 surjective_pairing[of x] S_relator_freeword[of s]\n            uminus_Abs_freeword_singleton[of s False, THEN sym]"], ["proof (prove)\nusing this:\n  s = fst x\n  \\<not> snd x\n  order.greater_eq S (fst ` set (x # xs))\n  - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n  - Abs_freelistfst xs + - Abs_freeletter (fst x) + Abs_freeword [x] +\n  Abs_freeword xs\n  x = (fst x, snd x)\n  s \\<in> S \\<Longrightarrow> pair_relator_freeword s s = s [+] s\n  Abs_freeword [(s, \\<not> False)] = - Abs_freeword [pairfalse s]\n\ngoal (1 subgoal):\n 1. - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n    - Abs_freelistfst xs + - pair_relator_freeword s s + Abs_freeword xs", "by    (simp add: add.assoc)"], ["proof (state)\nthis:\n  - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n  - Abs_freelistfst xs + - pair_relator_freeword s s + Abs_freeword xs\n\ngoal (1 subgoal):\n 1. \\<not> snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "with q_def"], ["proof (chain)\npicking this:\n  q = rconjby (Abs_freelistfst xs) (pair_relator_freeword s s)\n  - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n  - Abs_freelistfst xs + - pair_relator_freeword s s + Abs_freeword xs", "have 2:\n      \"- Abs_freelistfst (x#xs) + Abs_freeword (x#xs) =\n        -q + (-Abs_freelistfst xs + Abs_freeword xs)\""], ["proof (prove)\nusing this:\n  q = rconjby (Abs_freelistfst xs) (pair_relator_freeword s s)\n  - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n  - Abs_freelistfst xs + - pair_relator_freeword s s + Abs_freeword xs\n\ngoal (1 subgoal):\n 1. - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n    - q + (- Abs_freelistfst xs + Abs_freeword xs)", "by (simp add: rconjby_uminus[THEN sym] add.assoc[THEN sym])"], ["proof (state)\nthis:\n  - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n  - q + (- Abs_freelistfst xs + Abs_freeword xs)\n\ngoal (1 subgoal):\n 1. \\<not> snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "moreover"], ["proof (state)\nthis:\n  - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n  - q + (- Abs_freelistfst xs + Abs_freeword xs)\n\ngoal (1 subgoal):\n 1. \\<not> snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "from q_def s_def Cons(3)"], ["proof (chain)\npicking this:\n  q = rconjby (Abs_freelistfst xs) (pair_relator_freeword s s)\n  s = fst x\n  order.greater_eq S (fst ` set (x # xs))", "have \"-q\\<in>Q\""], ["proof (prove)\nusing this:\n  q = rconjby (Abs_freelistfst xs) (pair_relator_freeword s s)\n  s = fst x\n  order.greater_eq S (fst ` set (x # xs))\n\ngoal (1 subgoal):\n 1. - q\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "using proper_signed_list_map_uniform_snd[of True \"map fst xs\"]\n            rconj_relator_freeword genby_uminus_closed"], ["proof (prove)\nusing this:\n  q = rconjby (Abs_freelistfst xs) (pair_relator_freeword s s)\n  s = fst x\n  order.greater_eq S (fst ` set (x # xs))\n  proper_signed_list (map pairtrue (map fst xs))\n  \\<lbrakk>?s \\<in> S; ?t \\<in> S; proper_signed_list ?xs;\n   order.greater_eq S (fst ` set ?xs)\\<rbrakk>\n  \\<Longrightarrow> rconjby (Abs_freeword ?xs) (pair_relator_freeword ?s ?t)\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  ?g \\<in> \\<langle>?S\\<rangle> \\<Longrightarrow>\n  - ?g \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. - q\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "by    fastforce"], ["proof (state)\nthis:\n  - q\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "moreover"], ["proof (state)\nthis:\n  - q\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs)\\<rbrakk>\n  \\<Longrightarrow> - Abs_freelistfst xs + Abs_freeword xs\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  proper_signed_list (x # xs)\n  order.greater_eq S (fst ` set (x # xs))", "have \"-Abs_freelistfst xs + Abs_freeword xs \\<in> Q\""], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs)\\<rbrakk>\n  \\<Longrightarrow> - Abs_freelistfst xs + Abs_freeword xs\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  proper_signed_list (x # xs)\n  order.greater_eq S (fst ` set (x # xs))\n\ngoal (1 subgoal):\n 1. - Abs_freelistfst xs + Abs_freeword xs\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "by (simp add: binrelchain_Cons_reduce)"], ["proof (state)\nthis:\n  - Abs_freelistfst xs + Abs_freeword xs\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> snd x \\<Longrightarrow>\n    - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n  - q + (- Abs_freelistfst xs + Abs_freeword xs)\n  - q\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  - Abs_freelistfst xs + Abs_freeword xs\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n  - q + (- Abs_freelistfst xs + Abs_freeword xs)\n  - q\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  - Abs_freelistfst xs + Abs_freeword xs\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "using genby_add_closed"], ["proof (prove)\nusing this:\n  - Abs_freelistfst (x # xs) + Abs_freeword (x # xs) =\n  - q + (- Abs_freelistfst xs + Abs_freeword xs)\n  - q\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  - Abs_freelistfst xs + Abs_freeword xs\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  \\<lbrakk>?g \\<in> \\<langle>?S\\<rangle>;\n   ?h \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?g + ?h \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "by simp"], ["proof (state)\nthis:\n  - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - Abs_freelistfst (x # xs) + Abs_freeword (x # xs)\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list [];\n     order.greater_eq S (fst ` set [])\\<rbrakk>\n    \\<Longrightarrow> - Abs_freelistfst [] + Abs_freeword []\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "qed (simp add: zero_freeword.abs_eq[THEN sym] genby_0_closed)"], ["", "lemma Q_freelist_freeword':\n  \"\\<lbrakk> proper_signed_list xs; fst ` set xs \\<subseteq> S; Abs_freelistfst xs \\<in> Q \\<rbrakk> \\<Longrightarrow>\n    Abs_freeword xs \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs);\n     Abs_freelistfst xs\n     \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Abs_freeword xs\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "using Abs_freeword_freelist_uminus_add_in_Q genby_add_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list ?xs;\n   order.greater_eq S (fst ` set ?xs)\\<rbrakk>\n  \\<Longrightarrow> - Abs_freelistfst ?xs + Abs_freeword ?xs\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  \\<lbrakk>?g \\<in> \\<langle>?S\\<rangle>;\n   ?h \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?g + ?h \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs);\n     Abs_freelistfst xs\n     \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Abs_freeword xs\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "by    fastforce"], ["", "lemma Q_freelist_freeword:\n  \"c \\<in> FreeGroup S \\<Longrightarrow> Abs_freelist (map fst (freeword c)) \\<in> Q \\<Longrightarrow> c \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<in> FreeGroup S;\n     Abs_freelistfst (freeword c)\n     \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> c \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "using freeword FreeGroupD Q_freelist_freeword' freeword_inverse[of c]"], ["proof (prove)\nusing this:\n  freeword ?x \\<in> {as. proper_signed_list as}\n  ?x \\<in> FreeGroup ?S \\<Longrightarrow>\n  order.greater_eq ?S (fst ` set (freeword ?x))\n  \\<lbrakk>proper_signed_list ?xs; order.greater_eq S (fst ` set ?xs);\n   Abs_freelistfst ?xs\n   \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> Abs_freeword ?xs\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  Abs_freeword (freeword c) = c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<in> FreeGroup S;\n     Abs_freelistfst (freeword c)\n     \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> c \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "by     fastforce"], ["", "text \\<open>\n  Here we show that the lift of the identity map to the free group on @{term S} is really just\n  summation.\n\\<close>"], ["", "lemma freeliftid_Abs_freeword_conv_sum_list:\n  \"proper_signed_list xs \\<Longrightarrow> fst ` set xs \\<subseteq> S \\<Longrightarrow>\n    freeliftid (Abs_freeword xs) = sum_list (map fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs;\n     order.greater_eq S (fst ` set xs)\\<rbrakk>\n    \\<Longrightarrow> freeword_funlift id (Abs_freeword xs) =\n                      sum_list (map fst xs)", "using freeword_funlift_Abs_freeword[of xs id] genset_uminus\n        sum_list_map_cong[of xs \"apply_sign id\" fst]"], ["proof (prove)\nusing this:\n  proper_signed_list xs \\<Longrightarrow>\n  freeword_funlift id (Abs_freeword xs) = sum_list (map (apply_sign id) xs)\n  ?a \\<in> S \\<Longrightarrow> - ?a = ?a\n  (\\<And>x.\n      x \\<in> set xs \\<Longrightarrow>\n      apply_sign id x = fst x) \\<Longrightarrow>\n  sum_list (map (apply_sign id) xs) = sum_list (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs;\n     order.greater_eq S (fst ` set xs)\\<rbrakk>\n    \\<Longrightarrow> freeword_funlift id (Abs_freeword xs) =\n                      sum_list (map fst xs)", "by    fastforce"], ["", "end"], ["", "(* context PreCoxeterSystem *)"], ["", "subsubsection \\<open>Words in generators containing alternating subwords\\<close>"], ["", "text \\<open>\n  Besides cancelling subwords equal to relators, the primary algebraic manipulation in seeking to\n  reduce a word in generators in a Coxeter system is to reverse the order of alternating subwords\n  of half the length of the associated relator, in order to create adjacent repeated letters that\n  can be cancelled. Here we detail the mechanics of such manipulations.\n\\<close>"], ["", "context PreCoxeterSystem\nbegin"], ["", "lemma sum_list_pair_relator_halflist_flip:\n  \"s\\<in>S \\<Longrightarrow> t\\<in>S \\<Longrightarrow>\n    sum_list (pair_relator_halflist s t) = sum_list (pair_relator_halflist t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S\\<rbrakk>\n    \\<Longrightarrow> sum_list (pair_relator_halflist s t) =\n                      sum_list (pair_relator_halflist t s)", "using add_order[of \"s+t\"] genset_order2_add\n        alternating_order2_even_cancel_right[of s t \"2*(relfun s t)\"]"], ["proof (prove)\nusing this:\n  (s + t) +^ add_order (s + t) = (0::'w)\n  ?s \\<in> S \\<Longrightarrow> ?s + ?s = (0::'w)\n  \\<lbrakk>s + s = (0::'w); t + t = (0::'w);\n   gcd_nat.greater_eq (2 * add_order (s + t)) 2;\n   order.greater_eq (2 * add_order (s + t)) ?m\\<rbrakk>\n  \\<Longrightarrow> sum_list\n                     (pair_relator_list s t @ alternating_list ?m t s) =\n                    sum_list\n                     (alternating_list (2 * add_order (s + t) - ?m) s t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S\\<rbrakk>\n    \\<Longrightarrow> sum_list (pair_relator_halflist s t) =\n                      sum_list (pair_relator_halflist t s)", "by    (simp add: alternating_sum_list_conv_nataction add_order_add_sym)"], ["", "definition flip_altsublist_adjacent :: \"'w list \\<Rightarrow> 'w list \\<Rightarrow> bool\"\n  where \"flip_altsublist_adjacent ss ts\n          \\<equiv> \\<exists>s t as bs. ss = as @ (pair_relator_halflist s t) @ bs \\<and>\n              ts = as @ (pair_relator_halflist t s) @ bs\""], ["", "abbreviation \"flip_altsublist_chain \\<equiv> binrelchain flip_altsublist_adjacent\""], ["", "lemma flip_altsublist_adjacentI:\n  \"ss = as @ (pair_relator_halflist s t) @ bs \\<Longrightarrow>\n    ts = as @ (pair_relator_halflist t s) @ bs \\<Longrightarrow>\n    flip_altsublist_adjacent ss ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ss = as @ pair_relator_halflist s t @ bs;\n     ts = as @ pair_relator_halflist t s @ bs\\<rbrakk>\n    \\<Longrightarrow> flip_altsublist_adjacent ss ts", "using flip_altsublist_adjacent_def"], ["proof (prove)\nusing this:\n  flip_altsublist_adjacent ?ss ?ts \\<equiv>\n  \\<exists>s t as bs.\n     ?ss = as @ pair_relator_halflist s t @ bs \\<and>\n     ?ts = as @ pair_relator_halflist t s @ bs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ss = as @ pair_relator_halflist s t @ bs;\n     ts = as @ pair_relator_halflist t s @ bs\\<rbrakk>\n    \\<Longrightarrow> flip_altsublist_adjacent ss ts", "by fast"], ["", "lemma flip_altsublist_adjacent_Cons_grow:\n  assumes \"flip_altsublist_adjacent ss ts\"\n  shows   \"flip_altsublist_adjacent (a#ss) (a#ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip_altsublist_adjacent (a # ss) (a # ts)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. flip_altsublist_adjacent (a # ss) (a # ts)", "from assms"], ["proof (chain)\npicking this:\n  flip_altsublist_adjacent ss ts", "obtain s t as bs\n    where ssts: \"ss = as @ (pair_relator_halflist s t) @ bs\" \n                \"ts = as @ (pair_relator_halflist t s) @ bs\""], ["proof (prove)\nusing this:\n  flip_altsublist_adjacent ss ts\n\ngoal (1 subgoal):\n 1. (\\<And>as s t bs.\n        \\<lbrakk>ss = as @ pair_relator_halflist s t @ bs;\n         ts = as @ pair_relator_halflist t s @ bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using flip_altsublist_adjacent_def"], ["proof (prove)\nusing this:\n  flip_altsublist_adjacent ss ts\n  flip_altsublist_adjacent ?ss ?ts \\<equiv>\n  \\<exists>s t as bs.\n     ?ss = as @ pair_relator_halflist s t @ bs \\<and>\n     ?ts = as @ pair_relator_halflist t s @ bs\n\ngoal (1 subgoal):\n 1. (\\<And>as s t bs.\n        \\<lbrakk>ss = as @ pair_relator_halflist s t @ bs;\n         ts = as @ pair_relator_halflist t s @ bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs\n\ngoal (1 subgoal):\n 1. flip_altsublist_adjacent (a # ss) (a # ts)", "from ssts"], ["proof (chain)\npicking this:\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs", "have\n    \"a#ss = (a#as) @ (pair_relator_halflist s t) @ bs\"\n    \"a#ts = (a#as) @ (pair_relator_halflist t s) @ bs\""], ["proof (prove)\nusing this:\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs\n\ngoal (1 subgoal):\n 1. a # ss = (a # as) @ pair_relator_halflist s t @ bs &&&\n    a # ts = (a # as) @ pair_relator_halflist t s @ bs", "by auto"], ["proof (state)\nthis:\n  a # ss = (a # as) @ pair_relator_halflist s t @ bs\n  a # ts = (a # as) @ pair_relator_halflist t s @ bs\n\ngoal (1 subgoal):\n 1. flip_altsublist_adjacent (a # ss) (a # ts)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a # ss = (a # as) @ pair_relator_halflist s t @ bs\n  a # ts = (a # as) @ pair_relator_halflist t s @ bs\n\ngoal (1 subgoal):\n 1. flip_altsublist_adjacent (a # ss) (a # ts)", "by (fast intro: flip_altsublist_adjacentI)"], ["proof (state)\nthis:\n  flip_altsublist_adjacent (a # ss) (a # ts)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flip_altsublist_chain_map_Cons_grow:\n  \"flip_altsublist_chain tss \\<Longrightarrow> flip_altsublist_chain (map ((#) t) tss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip_altsublist_chain tss \\<Longrightarrow>\n    flip_altsublist_chain (map ((#) t) tss)", "by  (induct tss rule: list_induct_CCons)\n      (auto simp add:\n        binrelchain_Cons_reduce[of flip_altsublist_adjacent]\n        flip_altsublist_adjacent_Cons_grow\n      )"], ["", "lemma flip_altsublist_adjacent_refl:\n  \"ss \\<noteq> [] \\<Longrightarrow> ss\\<in>lists S \\<Longrightarrow> flip_altsublist_adjacent ss ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<noteq> []; ss \\<in> lists S\\<rbrakk>\n    \\<Longrightarrow> flip_altsublist_adjacent ss ss", "proof (induct ss rule: list_nonempty_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       [x] \\<in> lists S \\<Longrightarrow> flip_altsublist_adjacent [x] [x]\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow> flip_altsublist_adjacent xs xs;\n        x # xs \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> flip_altsublist_adjacent (x # xs) (x # xs)", "case (single s)"], ["proof (state)\nthis:\n  [s] \\<in> lists S\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       [x] \\<in> lists S \\<Longrightarrow> flip_altsublist_adjacent [x] [x]\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow> flip_altsublist_adjacent xs xs;\n        x # xs \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> flip_altsublist_adjacent (x # xs) (x # xs)", "hence \"[s] = [] @ pair_relator_halflist s s @ []\""], ["proof (prove)\nusing this:\n  [s] \\<in> lists S\n\ngoal (1 subgoal):\n 1. [s] = [] @ pair_relator_halflist s s @ []", "using relfun_S"], ["proof (prove)\nusing this:\n  [s] \\<in> lists S\n  ?s \\<in> S \\<Longrightarrow> add_order (?s + ?s) = 1\n\ngoal (1 subgoal):\n 1. [s] = [] @ pair_relator_halflist s s @ []", "by simp"], ["proof (state)\nthis:\n  [s] = [] @ pair_relator_halflist s s @ []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       [x] \\<in> lists S \\<Longrightarrow> flip_altsublist_adjacent [x] [x]\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow> flip_altsublist_adjacent xs xs;\n        x # xs \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> flip_altsublist_adjacent (x # xs) (x # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  [s] = [] @ pair_relator_halflist s s @ []\n\ngoal (1 subgoal):\n 1. flip_altsublist_adjacent [s] [s]", "by (fast intro: flip_altsublist_adjacentI)"], ["proof (state)\nthis:\n  flip_altsublist_adjacent [s] [s]\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow> flip_altsublist_adjacent xs xs;\n        x # xs \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> flip_altsublist_adjacent (x # xs) (x # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow> flip_altsublist_adjacent xs xs;\n        x # xs \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> flip_altsublist_adjacent (x # xs) (x # xs)", "case cons"], ["proof (state)\nthis:\n  xs_ \\<noteq> []\n  xs_ \\<in> lists S \\<Longrightarrow> flip_altsublist_adjacent xs_ xs_\n  x_ # xs_ \\<in> lists S\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow> flip_altsublist_adjacent xs xs;\n        x # xs \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> flip_altsublist_adjacent (x # xs) (x # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  xs_ \\<noteq> []\n  xs_ \\<in> lists S \\<Longrightarrow> flip_altsublist_adjacent xs_ xs_\n  x_ # xs_ \\<in> lists S\n\ngoal (1 subgoal):\n 1. flip_altsublist_adjacent (x_ # xs_) (x_ # xs_)", "using flip_altsublist_adjacent_Cons_grow"], ["proof (prove)\nusing this:\n  xs_ \\<noteq> []\n  xs_ \\<in> lists S \\<Longrightarrow> flip_altsublist_adjacent xs_ xs_\n  x_ # xs_ \\<in> lists S\n  flip_altsublist_adjacent ?ss ?ts \\<Longrightarrow>\n  flip_altsublist_adjacent (?a # ?ss) (?a # ?ts)\n\ngoal (1 subgoal):\n 1. flip_altsublist_adjacent (x_ # xs_) (x_ # xs_)", "by simp"], ["proof (state)\nthis:\n  flip_altsublist_adjacent (x_ # xs_) (x_ # xs_)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flip_altsublist_adjacent_sym:\n  \"flip_altsublist_adjacent ss ts \\<Longrightarrow> flip_altsublist_adjacent ts ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip_altsublist_adjacent ss ts \\<Longrightarrow>\n    flip_altsublist_adjacent ts ss", "using flip_altsublist_adjacent_def flip_altsublist_adjacentI"], ["proof (prove)\nusing this:\n  flip_altsublist_adjacent ?ss ?ts \\<equiv>\n  \\<exists>s t as bs.\n     ?ss = as @ pair_relator_halflist s t @ bs \\<and>\n     ?ts = as @ pair_relator_halflist t s @ bs\n  \\<lbrakk>?ss = ?as @ pair_relator_halflist ?s ?t @ ?bs;\n   ?ts = ?as @ pair_relator_halflist ?t ?s @ ?bs\\<rbrakk>\n  \\<Longrightarrow> flip_altsublist_adjacent ?ss ?ts\n\ngoal (1 subgoal):\n 1. flip_altsublist_adjacent ss ts \\<Longrightarrow>\n    flip_altsublist_adjacent ts ss", "by auto"], ["", "lemma rev_flip_altsublist_chain:\n  \"flip_altsublist_chain xss \\<Longrightarrow> flip_altsublist_chain (rev xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip_altsublist_chain xss \\<Longrightarrow>\n    flip_altsublist_chain (rev xss)", "using flip_altsublist_adjacent_sym binrelchain_snoc[of flip_altsublist_adjacent]"], ["proof (prove)\nusing this:\n  flip_altsublist_adjacent ?ss ?ts \\<Longrightarrow>\n  flip_altsublist_adjacent ?ts ?ss\n  \\<lbrakk>flip_altsublist_chain (?xs @ [?x]);\n   flip_altsublist_adjacent ?x ?y\\<rbrakk>\n  \\<Longrightarrow> flip_altsublist_chain (?xs @ [?x, ?y])\n\ngoal (1 subgoal):\n 1. flip_altsublist_chain xss \\<Longrightarrow>\n    flip_altsublist_chain (rev xss)", "by    (induct xss rule: list_induct_CCons) auto"], ["", "lemma flip_altsublist_adjacent_set:\n  assumes \"ss\\<in>lists S\" \"flip_altsublist_adjacent ss ts\"\n  shows   \"set ts = set ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ts = set ss", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. set ts = set ss", "from assms"], ["proof (chain)\npicking this:\n  ss \\<in> lists S\n  flip_altsublist_adjacent ss ts", "obtain s t as bs where ssts:  \n    \"ss = as @ (pair_relator_halflist s t) @ bs\"\n    \"ts = as @ (pair_relator_halflist t s) @ bs\""], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  flip_altsublist_adjacent ss ts\n\ngoal (1 subgoal):\n 1. (\\<And>as s t bs.\n        \\<lbrakk>ss = as @ pair_relator_halflist s t @ bs;\n         ts = as @ pair_relator_halflist t s @ bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using flip_altsublist_adjacent_def"], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  flip_altsublist_adjacent ss ts\n  flip_altsublist_adjacent ?ss ?ts \\<equiv>\n  \\<exists>s t as bs.\n     ?ss = as @ pair_relator_halflist s t @ bs \\<and>\n     ?ts = as @ pair_relator_halflist t s @ bs\n\ngoal (1 subgoal):\n 1. (\\<And>as s t bs.\n        \\<lbrakk>ss = as @ pair_relator_halflist s t @ bs;\n         ts = as @ pair_relator_halflist t s @ bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs\n\ngoal (1 subgoal):\n 1. set ts = set ss", "with assms(1)"], ["proof (chain)\npicking this:\n  ss \\<in> lists S\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs", "show ?thesis"], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs\n\ngoal (1 subgoal):\n 1. set ts = set ss", "using set_alternating_list2[of \"relfun s t\" s t]\n          set_alternating_list2[of \"relfun t s\" t s]\n          add_order_add_sym[of t s] relfun_eq1"], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs\n  order.greater_eq (add_order (s + t)) 2 \\<Longrightarrow>\n  set (pair_relator_halflist s t) = {s, t}\n  order.greater_eq (add_order (t + s)) 2 \\<Longrightarrow>\n  set (pair_relator_halflist t s) = {t, s}\n  add_order (t + s) = add_order (s + t)\n  \\<lbrakk>?s \\<in> S; add_order (?s + ?t) = 1\\<rbrakk>\n  \\<Longrightarrow> ?t = ?s\n\ngoal (1 subgoal):\n 1. set ts = set ss", "by    (cases \"relfun s t\" rule: nat_cases_2Suc) auto"], ["proof (state)\nthis:\n  set ts = set ss\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flip_altsublist_adjacent_set_ball:\n  \"\\<forall>ss\\<in>lists S. \\<forall>ts. flip_altsublist_adjacent ss ts \\<longrightarrow> set ts = set ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ss\\<in>lists S.\n       \\<forall>ts.\n          flip_altsublist_adjacent ss ts \\<longrightarrow> set ts = set ss", "using flip_altsublist_adjacent_set"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ss \\<in> lists S; flip_altsublist_adjacent ?ss ?ts\\<rbrakk>\n  \\<Longrightarrow> set ?ts = set ?ss\n\ngoal (1 subgoal):\n 1. \\<forall>ss\\<in>lists S.\n       \\<forall>ts.\n          flip_altsublist_adjacent ss ts \\<longrightarrow> set ts = set ss", "by fast"], ["", "lemma flip_altsublist_adjacent_lists:\n  \"ss \\<in> lists S \\<Longrightarrow> flip_altsublist_adjacent ss ts \\<Longrightarrow> ts \\<in> lists S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<in> lists S; flip_altsublist_adjacent ss ts\\<rbrakk>\n    \\<Longrightarrow> ts \\<in> lists S", "using flip_altsublist_adjacent_set"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ss \\<in> lists S; flip_altsublist_adjacent ?ss ?ts\\<rbrakk>\n  \\<Longrightarrow> set ?ts = set ?ss\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<in> lists S; flip_altsublist_adjacent ss ts\\<rbrakk>\n    \\<Longrightarrow> ts \\<in> lists S", "by fast"], ["", "lemma flip_altsublist_adjacent_lists_ball:\n  \"\\<forall>ss\\<in>lists S. \\<forall>ts. flip_altsublist_adjacent ss ts \\<longrightarrow> ts \\<in> lists S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ss\\<in>lists S.\n       \\<forall>ts.\n          flip_altsublist_adjacent ss ts \\<longrightarrow> ts \\<in> lists S", "using flip_altsublist_adjacent_lists"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ss \\<in> lists S; flip_altsublist_adjacent ?ss ?ts\\<rbrakk>\n  \\<Longrightarrow> ?ts \\<in> lists S\n\ngoal (1 subgoal):\n 1. \\<forall>ss\\<in>lists S.\n       \\<forall>ts.\n          flip_altsublist_adjacent ss ts \\<longrightarrow> ts \\<in> lists S", "by fast"], ["", "lemma flip_altsublist_chain_lists:\n  \"ss \\<in> lists S \\<Longrightarrow> flip_altsublist_chain (ss#xss@[ts]) \\<Longrightarrow> ts \\<in> lists S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<in> lists S;\n     flip_altsublist_chain (ss # xss @ [ts])\\<rbrakk>\n    \\<Longrightarrow> ts \\<in> lists S", "using flip_altsublist_adjacent_lists\n        binrelchain_propcong_Cons_snoc[of\n          \"\\<lambda>ss. ss\\<in>lists S\" flip_altsublist_adjacent ss xss ts\n        ]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ss \\<in> lists S; flip_altsublist_adjacent ?ss ?ts\\<rbrakk>\n  \\<Longrightarrow> ?ts \\<in> lists S\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>x \\<in> lists S;\n               flip_altsublist_adjacent x y\\<rbrakk>\n              \\<Longrightarrow> y \\<in> lists S;\n   ss \\<in> lists S; flip_altsublist_chain (ss # xss @ [ts])\\<rbrakk>\n  \\<Longrightarrow> ts \\<in> lists S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<in> lists S;\n     flip_altsublist_chain (ss # xss @ [ts])\\<rbrakk>\n    \\<Longrightarrow> ts \\<in> lists S", "by    fast"], ["", "lemmas flip_altsublist_chain_funcong_Cons_snoc =\n  binrelchain_setfuncong_Cons_snoc[OF flip_altsublist_adjacent_lists_ball]"], ["", "lemmas flip_altsublist_chain_set =\n  flip_altsublist_chain_funcong_Cons_snoc[\n    OF flip_altsublist_adjacent_set_ball\n  ]"], ["", "lemma flip_altsublist_adjacent_length:\n  \"flip_altsublist_adjacent ss ts \\<Longrightarrow> length ts = length ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip_altsublist_adjacent ss ts \\<Longrightarrow> length ts = length ss", "unfolding flip_altsublist_adjacent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s t as bs.\n       ss = as @ pair_relator_halflist s t @ bs \\<and>\n       ts = as @ pair_relator_halflist t s @ bs \\<Longrightarrow>\n    length ts = length ss", "by        (auto simp add: add_order_add_sym length_alternating_list)"], ["", "lemmas flip_altsublist_chain_length =\n  binrelchain_funcong_Cons_snoc[\n    of flip_altsublist_adjacent length, OF flip_altsublist_adjacent_length, simplified\n  ]"], ["", "lemma flip_altsublist_adjacent_sum_list:\n  assumes \"ss \\<in> lists S\" \"flip_altsublist_adjacent ss ts\"\n  shows \"sum_list ts = sum_list ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list ts = sum_list ss", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list ts = sum_list ss", "from assms(2)"], ["proof (chain)\npicking this:\n  flip_altsublist_adjacent ss ts", "obtain s t as bs where stasbs:\n    \"ss = as @ (pair_relator_halflist s t) @ bs\"\n    \"ts = as @ (pair_relator_halflist t s) @ bs\""], ["proof (prove)\nusing this:\n  flip_altsublist_adjacent ss ts\n\ngoal (1 subgoal):\n 1. (\\<And>as s t bs.\n        \\<lbrakk>ss = as @ pair_relator_halflist s t @ bs;\n         ts = as @ pair_relator_halflist t s @ bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using flip_altsublist_adjacent_def"], ["proof (prove)\nusing this:\n  flip_altsublist_adjacent ss ts\n  flip_altsublist_adjacent ?ss ?ts \\<equiv>\n  \\<exists>s t as bs.\n     ?ss = as @ pair_relator_halflist s t @ bs \\<and>\n     ?ts = as @ pair_relator_halflist t s @ bs\n\ngoal (1 subgoal):\n 1. (\\<And>as s t bs.\n        \\<lbrakk>ss = as @ pair_relator_halflist s t @ bs;\n         ts = as @ pair_relator_halflist t s @ bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs\n\ngoal (1 subgoal):\n 1. sum_list ts = sum_list ss", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list ts = sum_list ss", "proof (cases \"relfun s t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. add_order (s + t) = 0 \\<Longrightarrow> sum_list ts = sum_list ss\n 2. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       sum_list ts = sum_list ss", "case 0"], ["proof (state)\nthis:\n  add_order (s + t) = 0\n\ngoal (2 subgoals):\n 1. add_order (s + t) = 0 \\<Longrightarrow> sum_list ts = sum_list ss\n 2. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       sum_list ts = sum_list ss", "thus ?thesis"], ["proof (prove)\nusing this:\n  add_order (s + t) = 0\n\ngoal (1 subgoal):\n 1. sum_list ts = sum_list ss", "using stasbs"], ["proof (prove)\nusing this:\n  add_order (s + t) = 0\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs\n\ngoal (1 subgoal):\n 1. sum_list ts = sum_list ss", "by (simp add: add_order_add_sym)"], ["proof (state)\nthis:\n  sum_list ts = sum_list ss\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       sum_list ts = sum_list ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       sum_list ts = sum_list ss", "case Suc"], ["proof (state)\nthis:\n  add_order (s + t) = Suc nat_\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       sum_list ts = sum_list ss", "with assms stasbs"], ["proof (chain)\npicking this:\n  ss \\<in> lists S\n  flip_altsublist_adjacent ss ts\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs\n  add_order (s + t) = Suc nat_", "have \"s\\<in>S\" \"t\\<in>S\""], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  flip_altsublist_adjacent ss ts\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs\n  add_order (s + t) = Suc nat_\n\ngoal (1 subgoal):\n 1. s \\<in> S &&& t \\<in> S", "using set_alternating_list1[of \"add_order (s+t)\" s t]\n            set_alternating_list1[of \"add_order (t+s)\" t s]\n            add_order_add_sym[of t]\n            flip_altsublist_adjacent_lists[of ss ts]"], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  flip_altsublist_adjacent ss ts\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs\n  add_order (s + t) = Suc nat_\n  order.greater_eq (add_order (s + t)) 1 \\<Longrightarrow>\n  s \\<in> set (pair_relator_halflist s t)\n  order.greater_eq (add_order (t + s)) 1 \\<Longrightarrow>\n  t \\<in> set (pair_relator_halflist t s)\n  add_order (t + ?s) = add_order (?s + t)\n  \\<lbrakk>ss \\<in> lists S; flip_altsublist_adjacent ss ts\\<rbrakk>\n  \\<Longrightarrow> ts \\<in> lists S\n\ngoal (1 subgoal):\n 1. s \\<in> S &&& t \\<in> S", "by    auto"], ["proof (state)\nthis:\n  s \\<in> S\n  t \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       sum_list ts = sum_list ss", "with stasbs"], ["proof (chain)\npicking this:\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs\n  s \\<in> S\n  t \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs\n  s \\<in> S\n  t \\<in> S\n\ngoal (1 subgoal):\n 1. sum_list ts = sum_list ss", "using sum_list_pair_relator_halflist_flip"], ["proof (prove)\nusing this:\n  ss = as @ pair_relator_halflist s t @ bs\n  ts = as @ pair_relator_halflist t s @ bs\n  s \\<in> S\n  t \\<in> S\n  \\<lbrakk>?s \\<in> S; ?t \\<in> S\\<rbrakk>\n  \\<Longrightarrow> sum_list (pair_relator_halflist ?s ?t) =\n                    sum_list (pair_relator_halflist ?t ?s)\n\ngoal (1 subgoal):\n 1. sum_list ts = sum_list ss", "by simp"], ["proof (state)\nthis:\n  sum_list ts = sum_list ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list ts = sum_list ss\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flip_altsublist_adjacent_sum_list_ball:\n  \"\\<forall>ss\\<in>lists S. \\<forall>ts. flip_altsublist_adjacent ss ts \\<longrightarrow> sum_list ts = sum_list ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ss\\<in>lists S.\n       \\<forall>ts.\n          flip_altsublist_adjacent ss ts \\<longrightarrow>\n          sum_list ts = sum_list ss", "using flip_altsublist_adjacent_sum_list"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ss \\<in> lists S; flip_altsublist_adjacent ?ss ?ts\\<rbrakk>\n  \\<Longrightarrow> sum_list ?ts = sum_list ?ss\n\ngoal (1 subgoal):\n 1. \\<forall>ss\\<in>lists S.\n       \\<forall>ts.\n          flip_altsublist_adjacent ss ts \\<longrightarrow>\n          sum_list ts = sum_list ss", "by fast"], ["", "lemma S_reduced_forI_flip_altsublist_adjacent:\n  \"S_reduced_for w ss \\<Longrightarrow> flip_altsublist_adjacent ss ts \\<Longrightarrow> S_reduced_for w ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S_reduced_for w ss; flip_altsublist_adjacent ss ts\\<rbrakk>\n    \\<Longrightarrow> S_reduced_for w ts", "using reduced_word_for_lists[of S] reduced_word_for_sum_list\n        flip_altsublist_adjacent_lists flip_altsublist_adjacent_sum_list\n        flip_altsublist_adjacent_length"], ["proof (prove)\nusing this:\n  S_reduced_for ?a ?as \\<Longrightarrow> ?as \\<in> lists S\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> sum_list ?as = ?a\n  \\<lbrakk>?ss \\<in> lists S; flip_altsublist_adjacent ?ss ?ts\\<rbrakk>\n  \\<Longrightarrow> ?ts \\<in> lists S\n  \\<lbrakk>?ss \\<in> lists S; flip_altsublist_adjacent ?ss ?ts\\<rbrakk>\n  \\<Longrightarrow> sum_list ?ts = sum_list ?ss\n  flip_altsublist_adjacent ?ss ?ts \\<Longrightarrow> length ?ts = length ?ss\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S_reduced_for w ss; flip_altsublist_adjacent ss ts\\<rbrakk>\n    \\<Longrightarrow> S_reduced_for w ts", "by    (fastforce intro: reduced_word_forI_compare)"], ["", "lemma flip_altsublist_adjacent_in_Q':\n  fixes   as bs s t\n  defines xs: \"xs \\<equiv> as @ pair_relator_halflist s t @ bs\"\n  and     ys: \"ys \\<equiv> as @ pair_relator_halflist t s @ bs\"\n  assumes Axs: \"Abs_freelist xs \\<in> Q\"\n  shows \"Abs_freelist ys \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "define X Y A B half_st half2_st half_ts\n    where \"X = Abs_freelist xs\"\n      and \"Y = Abs_freelist ys\"\n      and \"A = Abs_freelist as\"\n      and \"B = Abs_freelist bs\"\n      and \"half_st = Abs_freelist (pair_relator_halflist s t)\"\n      and \"half2_st = Abs_freelist (pair_relator_halflist2 s t)\"\n      and \"half_ts = Abs_freelist (pair_relator_halflist t s)\""], ["proof (state)\nthis:\n  X = Abs_freelist xs\n  Y = Abs_freelist ys\n  A = Abs_freelist as\n  B = Abs_freelist bs\n  half_st = Abs_freelist (pair_relator_halflist s t)\n  half2_st =\n  Abs_freelist\n   (if gcd_nat.greater_eq (add_order (s + t)) 2\n    then pair_relator_halflist s t else pair_relator_halflist t s)\n  half_ts = Abs_freelist (pair_relator_halflist t s)\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "define z where \"z = -half2_st + B\""], ["proof (state)\nthis:\n  z = - half2_st + B\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "define w1 w2 where \"w1 = rconjby z (pair_relator_freeword s t)\"\n    and \"w2 = Abs_freelist (rev (pair_relator_halflist t s) @ pair_relator_halflist t s)\""], ["proof (state)\nthis:\n  w1 = rconjby z (pair_relator_freeword s t)\n  w2 =\n  Abs_freelist (rev (pair_relator_halflist t s) @ pair_relator_halflist t s)\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "define w3 where \"w3 = rconjby B w2\""], ["proof (state)\nthis:\n  w3 = rconjby B w2\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "from w1_def z_def"], ["proof (chain)\npicking this:\n  w1 = rconjby z (pair_relator_freeword s t)\n  z = - half2_st + B", "have  w1': \"w1 = rconjby B (lconjby half2_st (pair_relator_freeword s t))\""], ["proof (prove)\nusing this:\n  w1 = rconjby z (pair_relator_freeword s t)\n  z = - half2_st + B\n\ngoal (1 subgoal):\n 1. w1 = rconjby B (lconjby half2_st (pair_relator_freeword s t))", "by    (simp add: rconjby_add)"], ["proof (state)\nthis:\n  w1 = rconjby B (lconjby half2_st (pair_relator_freeword s t))\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "hence \"-w1 = rconjby B (lconjby half2_st (-pair_relator_freeword s t))\""], ["proof (prove)\nusing this:\n  w1 = rconjby B (lconjby half2_st (pair_relator_freeword s t))\n\ngoal (1 subgoal):\n 1. - w1 = rconjby B (lconjby half2_st (- pair_relator_freeword s t))", "using lconjby_uminus[of \"half2_st\"]"], ["proof (prove)\nusing this:\n  w1 = rconjby B (lconjby half2_st (pair_relator_freeword s t))\n  lconjby half2_st (- ?y) = - lconjby half2_st ?y\n\ngoal (1 subgoal):\n 1. - w1 = rconjby B (lconjby half2_st (- pair_relator_freeword s t))", "by (simp add: rconjby_uminus[THEN sym])"], ["proof (state)\nthis:\n  - w1 = rconjby B (lconjby half2_st (- pair_relator_freeword s t))\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "moreover"], ["proof (state)\nthis:\n  - w1 = rconjby B (lconjby half2_st (- pair_relator_freeword s t))\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "from X_def xs A_def half_st_def B_def"], ["proof (chain)\npicking this:\n  X = Abs_freelist xs\n  xs \\<equiv> as @ pair_relator_halflist s t @ bs\n  A = Abs_freelist as\n  half_st = Abs_freelist (pair_relator_halflist s t)\n  B = Abs_freelist bs", "have \"X = A + B + rconjby B half_st\""], ["proof (prove)\nusing this:\n  X = Abs_freelist xs\n  xs \\<equiv> as @ pair_relator_halflist s t @ bs\n  A = Abs_freelist as\n  half_st = Abs_freelist (pair_relator_halflist s t)\n  B = Abs_freelist bs\n\ngoal (1 subgoal):\n 1. X = A + B + rconjby B half_st", "by  (simp add:\n          Abs_freelist_append_append[THEN sym] add.assoc[THEN sym]\n        )"], ["proof (state)\nthis:\n  X = A + B + rconjby B half_st\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  - w1 = rconjby B (lconjby half2_st (- pair_relator_freeword s t))\n  X = A + B + rconjby B half_st", "have\n    \"X + -w1 = A + B +\n      ( rconjby B (half_st + (half2_st + -pair_relator_freeword s t - half2_st)) )\""], ["proof (prove)\nusing this:\n  - w1 = rconjby B (lconjby half2_st (- pair_relator_freeword s t))\n  X = A + B + rconjby B half_st\n\ngoal (1 subgoal):\n 1. X + - w1 =\n    A + B +\n    rconjby B (half_st + lconjby half2_st (- pair_relator_freeword s t))", "by (simp add: add.assoc add_rconjby)"], ["proof (state)\nthis:\n  X + - w1 =\n  A + B +\n  rconjby B (half_st + lconjby half2_st (- pair_relator_freeword s t))\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "moreover"], ["proof (state)\nthis:\n  X + - w1 =\n  A + B +\n  rconjby B (half_st + lconjby half2_st (- pair_relator_freeword s t))\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "from w2_def half2_st_def half_ts_def"], ["proof (chain)\npicking this:\n  w2 =\n  Abs_freelist (rev (pair_relator_halflist t s) @ pair_relator_halflist t s)\n  half2_st =\n  Abs_freelist\n   (if gcd_nat.greater_eq (add_order (s + t)) 2\n    then pair_relator_halflist s t else pair_relator_halflist t s)\n  half_ts = Abs_freelist (pair_relator_halflist t s)", "have \"w2 = half2_st + half_ts\""], ["proof (prove)\nusing this:\n  w2 =\n  Abs_freelist (rev (pair_relator_halflist t s) @ pair_relator_halflist t s)\n  half2_st =\n  Abs_freelist\n   (if gcd_nat.greater_eq (add_order (s + t)) 2\n    then pair_relator_halflist s t else pair_relator_halflist t s)\n  half_ts = Abs_freelist (pair_relator_halflist t s)\n\ngoal (1 subgoal):\n 1. w2 = half2_st + half_ts", "by  (simp add:\n          Abs_freelist_append[THEN sym]\n          pair_relator_halflist2_conv_rev_pair_relator_halflist\n        )"], ["proof (state)\nthis:\n  w2 = half2_st + half_ts\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  X + - w1 =\n  A + B +\n  rconjby B (half_st + lconjby half2_st (- pair_relator_freeword s t))\n  w2 = half2_st + half_ts", "have\n    \"X + -w1 + w3 = A + B + (rconjby B (-half2_st + (half2_st + half_ts)))\""], ["proof (prove)\nusing this:\n  X + - w1 =\n  A + B +\n  rconjby B (half_st + lconjby half2_st (- pair_relator_freeword s t))\n  w2 = half2_st + half_ts\n\ngoal (1 subgoal):\n 1. X + - w1 + w3 = A + B + rconjby B (- half2_st + (half2_st + half_ts))", "using half_st_def half2_st_def w3_def add_assoc4[\n            of half_st half2_st \"-pair_relator_freeword s t\" \"-half2_st\"\n          ]"], ["proof (prove)\nusing this:\n  X + - w1 =\n  A + B +\n  rconjby B (half_st + lconjby half2_st (- pair_relator_freeword s t))\n  w2 = half2_st + half_ts\n  half_st = Abs_freelist (pair_relator_halflist s t)\n  half2_st =\n  Abs_freelist\n   (if gcd_nat.greater_eq (add_order (s + t)) 2\n    then pair_relator_halflist s t else pair_relator_halflist t s)\n  w3 = rconjby B w2\n  half_st + half2_st + - pair_relator_freeword s t + - half2_st =\n  half_st + (half2_st + - pair_relator_freeword s t + - half2_st)\n\ngoal (1 subgoal):\n 1. X + - w1 + w3 = A + B + rconjby B (- half2_st + (half2_st + half_ts))", "by    (simp add:\n            Abs_freelist_append[THEN sym] pair_relator_halflist_append\n            add.assoc add_rconjby\n          )"], ["proof (state)\nthis:\n  X + - w1 + w3 = A + B + rconjby B (- half2_st + (half2_st + half_ts))\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "hence Y': \"Y = X - w1 + w3\""], ["proof (prove)\nusing this:\n  X + - w1 + w3 = A + B + rconjby B (- half2_st + (half2_st + half_ts))\n\ngoal (1 subgoal):\n 1. Y = X - w1 + w3", "using A_def half_ts_def B_def ys Y_def"], ["proof (prove)\nusing this:\n  X + - w1 + w3 = A + B + rconjby B (- half2_st + (half2_st + half_ts))\n  A = Abs_freelist as\n  half_ts = Abs_freelist (pair_relator_halflist t s)\n  B = Abs_freelist bs\n  ys \\<equiv> as @ pair_relator_halflist t s @ bs\n  Y = Abs_freelist ys\n\ngoal (1 subgoal):\n 1. Y = X - w1 + w3", "by    (simp add:\n            add.assoc[THEN sym]\n            Abs_freelist_append_append[THEN sym]\n          )"], ["proof (state)\nthis:\n  Y = X - w1 + w3\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "from Axs"], ["proof (chain)\npicking this:\n  Abs_freelist xs\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "have xs_S: \"xs \\<in> lists S\""], ["proof (prove)\nusing this:\n  Abs_freelist xs\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. xs \\<in> lists S", "using Q_FreeS FreeGroupD_transfer'"], ["proof (prove)\nusing this:\n  Abs_freelist xs\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  order.greater_eq (FreeGroup S)\n   \\<langle>\\<Union>h\\<in>FreeGroup S.\n               lconjby h ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  Abs_freelist ?xs \\<in> FreeGroup ?S \\<Longrightarrow> ?xs \\<in> lists ?S\n\ngoal (1 subgoal):\n 1. xs \\<in> lists S", "by fast"], ["proof (state)\nthis:\n  xs \\<in> lists S\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "have \"w1\\<in>Q \\<and> w3\\<in>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle> \\<and>\n    w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "proof (cases \"relfun s t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. add_order (s + t) = 0 \\<Longrightarrow>\n    w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle> \\<and>\n    w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword `\n                            map (charpair S) ` R\\<rangle> \\<and>\n       w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword ` map (charpair S) ` R\\<rangle>", "case 0"], ["proof (state)\nthis:\n  add_order (s + t) = 0\n\ngoal (2 subgoals):\n 1. add_order (s + t) = 0 \\<Longrightarrow>\n    w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle> \\<and>\n    w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword `\n                            map (charpair S) ` R\\<rangle> \\<and>\n       w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword ` map (charpair S) ` R\\<rangle>", "with w1_def w2_def w3_def"], ["proof (chain)\npicking this:\n  w1 = rconjby z (pair_relator_freeword s t)\n  w2 =\n  Abs_freelist (rev (pair_relator_halflist t s) @ pair_relator_halflist t s)\n  w3 = rconjby B w2\n  add_order (s + t) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  w1 = rconjby z (pair_relator_freeword s t)\n  w2 =\n  Abs_freelist (rev (pair_relator_halflist t s) @ pair_relator_halflist t s)\n  w3 = rconjby B w2\n  add_order (s + t) = 0\n\ngoal (1 subgoal):\n 1. w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle> \\<and>\n    w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "using genby_0_closed"], ["proof (prove)\nusing this:\n  w1 = rconjby z (pair_relator_freeword s t)\n  w2 =\n  Abs_freelist (rev (pair_relator_halflist t s) @ pair_relator_halflist t s)\n  w3 = rconjby B w2\n  add_order (s + t) = 0\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle> \\<and>\n    w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "by  (auto simp add:\n            zero_freeword.abs_eq[THEN sym]\n            add_order_add_sym\n          )"], ["proof (state)\nthis:\n  w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle> \\<and>\n  w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword `\n                            map (charpair S) ` R\\<rangle> \\<and>\n       w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword ` map (charpair S) ` R\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword `\n                            map (charpair S) ` R\\<rangle> \\<and>\n       w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword ` map (charpair S) ` R\\<rangle>", "case (Suc m)"], ["proof (state)\nthis:\n  add_order (s + t) = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword `\n                            map (charpair S) ` R\\<rangle> \\<and>\n       w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword ` map (charpair S) ` R\\<rangle>", "have m: \"add_order (s+t) = Suc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_order (s + t) = Suc m", "by fact"], ["proof (state)\nthis:\n  add_order (s + t) = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword `\n                            map (charpair S) ` R\\<rangle> \\<and>\n       w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword ` map (charpair S) ` R\\<rangle>", "have st: \"{s,t} \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq S {s, t}", "proof (cases m)"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> order.greater_eq S {s, t}\n 2. \\<And>nat. m = Suc nat \\<Longrightarrow> order.greater_eq S {s, t}", "case 0"], ["proof (state)\nthis:\n  m = 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> order.greater_eq S {s, t}\n 2. \\<And>nat. m = Suc nat \\<Longrightarrow> order.greater_eq S {s, t}", "with m xs xs_S"], ["proof (chain)\npicking this:\n  add_order (s + t) = Suc m\n  xs \\<equiv> as @ pair_relator_halflist s t @ bs\n  xs \\<in> lists S\n  m = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  add_order (s + t) = Suc m\n  xs \\<equiv> as @ pair_relator_halflist s t @ bs\n  xs \\<in> lists S\n  m = 0\n\ngoal (1 subgoal):\n 1. order.greater_eq S {s, t}", "using set_alternating_list1 relfun_eq1"], ["proof (prove)\nusing this:\n  add_order (s + t) = Suc m\n  xs \\<equiv> as @ pair_relator_halflist s t @ bs\n  xs \\<in> lists S\n  m = 0\n  order.greater_eq ?n 1 \\<Longrightarrow>\n  ?s \\<in> set (alternating_list ?n ?s ?t)\n  \\<lbrakk>?s \\<in> S; add_order (?s + ?t) = 1\\<rbrakk>\n  \\<Longrightarrow> ?t = ?s\n\ngoal (1 subgoal):\n 1. order.greater_eq S {s, t}", "by force"], ["proof (state)\nthis:\n  order.greater_eq S {s, t}\n\ngoal (1 subgoal):\n 1. \\<And>nat. m = Suc nat \\<Longrightarrow> order.greater_eq S {s, t}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. m = Suc nat \\<Longrightarrow> order.greater_eq S {s, t}", "case Suc"], ["proof (state)\nthis:\n  m = Suc nat_\n\ngoal (1 subgoal):\n 1. \\<And>nat. m = Suc nat \\<Longrightarrow> order.greater_eq S {s, t}", "with m xs xs_S"], ["proof (chain)\npicking this:\n  add_order (s + t) = Suc m\n  xs \\<equiv> as @ pair_relator_halflist s t @ bs\n  xs \\<in> lists S\n  m = Suc nat_", "show ?thesis"], ["proof (prove)\nusing this:\n  add_order (s + t) = Suc m\n  xs \\<equiv> as @ pair_relator_halflist s t @ bs\n  xs \\<in> lists S\n  m = Suc nat_\n\ngoal (1 subgoal):\n 1. order.greater_eq S {s, t}", "using set_alternating_list2[of \"add_order (s+t)\" s t]"], ["proof (prove)\nusing this:\n  add_order (s + t) = Suc m\n  xs \\<equiv> as @ pair_relator_halflist s t @ bs\n  xs \\<in> lists S\n  m = Suc nat_\n  order.greater_eq (add_order (s + t)) 2 \\<Longrightarrow>\n  set (pair_relator_halflist s t) = {s, t}\n\ngoal (1 subgoal):\n 1. order.greater_eq S {s, t}", "by fastforce"], ["proof (state)\nthis:\n  order.greater_eq S {s, t}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq S {s, t}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword `\n                            map (charpair S) ` R\\<rangle> \\<and>\n       w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword ` map (charpair S) ` R\\<rangle>", "from xs xs_S B_def"], ["proof (chain)\npicking this:\n  xs \\<equiv> as @ pair_relator_halflist s t @ bs\n  xs \\<in> lists S\n  B = Abs_freelist bs", "have B_S: \"B \\<in> FreeGroup S\""], ["proof (prove)\nusing this:\n  xs \\<equiv> as @ pair_relator_halflist s t @ bs\n  xs \\<in> lists S\n  B = Abs_freelist bs\n\ngoal (1 subgoal):\n 1. B \\<in> FreeGroup S", "using Abs_freelist_in_FreeGroup[of bs S]"], ["proof (prove)\nusing this:\n  xs \\<equiv> as @ pair_relator_halflist s t @ bs\n  xs \\<in> lists S\n  B = Abs_freelist bs\n  bs \\<in> lists S \\<Longrightarrow> Abs_freelist bs \\<in> FreeGroup S\n\ngoal (1 subgoal):\n 1. B \\<in> FreeGroup S", "by simp"], ["proof (state)\nthis:\n  B \\<in> FreeGroup S\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword `\n                            map (charpair S) ` R\\<rangle> \\<and>\n       w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword ` map (charpair S) ` R\\<rangle>", "moreover"], ["proof (state)\nthis:\n  B \\<in> FreeGroup S\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword `\n                            map (charpair S) ` R\\<rangle> \\<and>\n       w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword ` map (charpair S) ` R\\<rangle>", "from w2_def"], ["proof (chain)\npicking this:\n  w2 =\n  Abs_freelist (rev (pair_relator_halflist t s) @ pair_relator_halflist t s)", "have \"w2\\<in>Q\""], ["proof (prove)\nusing this:\n  w2 =\n  Abs_freelist (rev (pair_relator_halflist t s) @ pair_relator_halflist t s)\n\ngoal (1 subgoal):\n 1. w2 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "using st Abs_freelist_rev_append_alternating_list_in_Q[of t s \"add_order (t+s)\"]"], ["proof (prove)\nusing this:\n  w2 =\n  Abs_freelist (rev (pair_relator_halflist t s) @ pair_relator_halflist t s)\n  order.greater_eq S {s, t}\n  \\<lbrakk>t \\<in> S; s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> Abs_freelist\n                     (rev (pair_relator_halflist t s) @\n                      pair_relator_halflist t s)\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. w2 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "by    fast"], ["proof (state)\nthis:\n  w2 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword `\n                            map (charpair S) ` R\\<rangle> \\<and>\n       w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword ` map (charpair S) ` R\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  B \\<in> FreeGroup S\n  w2 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>", "have \"w3 \\<in> Q\""], ["proof (prove)\nusing this:\n  B \\<in> FreeGroup S\n  w2 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "using w3_def FreeGroup_genby_set_lconjby_set_rconjby_closed"], ["proof (prove)\nusing this:\n  B \\<in> FreeGroup S\n  w2 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n  w3 = rconjby B w2\n  \\<lbrakk>?g \\<in> FreeGroup ?S;\n   ?x \\<in> \\<langle>\\<Union>g\\<in>FreeGroup ?S.\n                        lconjby g ` ?A\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> rconjby ?g ?x\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup ?S.\nlconjby g ` ?A\\<rangle>\n\ngoal (1 subgoal):\n 1. w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "by fast"], ["proof (state)\nthis:\n  w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword `\n                            map (charpair S) ` R\\<rangle> \\<and>\n       w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword ` map (charpair S) ` R\\<rangle>", "moreover"], ["proof (state)\nthis:\n  w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword `\n                            map (charpair S) ` R\\<rangle> \\<and>\n       w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword ` map (charpair S) ` R\\<rangle>", "from half2_st_def"], ["proof (chain)\npicking this:\n  half2_st =\n  Abs_freelist\n   (if gcd_nat.greater_eq (add_order (s + t)) 2\n    then pair_relator_halflist s t else pair_relator_halflist t s)", "have \"w1 \\<in> Q\""], ["proof (prove)\nusing this:\n  half2_st =\n  Abs_freelist\n   (if gcd_nat.greater_eq (add_order (s + t)) 2\n    then pair_relator_halflist s t else pair_relator_halflist t s)\n\ngoal (1 subgoal):\n 1. w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "using w1' st B_S alternating_list_in_lists[of s S] alternating_list_in_lists[of t S]\n            lconjby_Abs_freelist_relator_freeword[of s t]"], ["proof (prove)\nusing this:\n  half2_st =\n  Abs_freelist\n   (if gcd_nat.greater_eq (add_order (s + t)) 2\n    then pair_relator_halflist s t else pair_relator_halflist t s)\n  w1 = rconjby B (lconjby half2_st (pair_relator_freeword s t))\n  order.greater_eq S {s, t}\n  B \\<in> FreeGroup S\n  \\<lbrakk>s \\<in> S; ?b \\<in> S\\<rbrakk>\n  \\<Longrightarrow> alternating_list ?n s ?b \\<in> lists S\n  \\<lbrakk>t \\<in> S; ?b \\<in> S\\<rbrakk>\n  \\<Longrightarrow> alternating_list ?n t ?b \\<in> lists S\n  \\<lbrakk>s \\<in> S; t \\<in> S; ?xs \\<in> lists S\\<rbrakk>\n  \\<Longrightarrow> lconjby (Abs_freelist ?xs) (pair_relator_freeword s t)\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "by    (force intro: FreeGroup_genby_set_lconjby_set_rconjby_closed)"], ["proof (state)\nthis:\n  w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       add_order (s + t) = Suc nat \\<Longrightarrow>\n       w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword `\n                            map (charpair S) ` R\\<rangle> \\<and>\n       w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                            lconjby g `\n                            Abs_freeword ` map (charpair S) ` R\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n  w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n  w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle> \\<and>\n    w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                         lconjby g `\n                         Abs_freeword ` map (charpair S) ` R\\<rangle>", "by fast"], ["proof (state)\nthis:\n  w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle> \\<and>\n  w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle> \\<and>\n  w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "with X_def Y_def Axs"], ["proof (chain)\npicking this:\n  X = Abs_freelist xs\n  Y = Abs_freelist ys\n  Abs_freelist xs\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle> \\<and>\n  w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  X = Abs_freelist xs\n  Y = Abs_freelist ys\n  Abs_freelist xs\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle> \\<and>\n  w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "using Y' genby_diff_closed[of X] genby_add_closed[of \"X-w1\" _ w3]"], ["proof (prove)\nusing this:\n  X = Abs_freelist xs\n  Y = Abs_freelist ys\n  Abs_freelist xs\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  w1 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle> \\<and>\n  w3 \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n  Y = X - w1 + w3\n  \\<lbrakk>X \\<in> \\<langle>?S\\<rangle>;\n   ?w' \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> X - ?w' \\<in> \\<langle>?S\\<rangle>\n  \\<lbrakk>X - w1 \\<in> \\<langle>?S\\<rangle>;\n   w3 \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> X - w1 + w3 \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. Abs_freelist ys\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "by simp"], ["proof (state)\nthis:\n  Abs_freelist ys\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flip_altsublist_adjacent_in_Q:\n  \"Abs_freelist ss \\<in> Q \\<Longrightarrow> flip_altsublist_adjacent ss ts \\<Longrightarrow> Abs_freelist ts \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Abs_freelist ss\n             \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                               lconjby g `\n                               Abs_freeword ` map (charpair S) ` R\\<rangle>;\n     flip_altsublist_adjacent ss ts\\<rbrakk>\n    \\<Longrightarrow> Abs_freelist ts\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "using flip_altsublist_adjacent_def flip_altsublist_adjacent_in_Q'"], ["proof (prove)\nusing this:\n  flip_altsublist_adjacent ?ss ?ts \\<equiv>\n  \\<exists>s t as bs.\n     ?ss = as @ pair_relator_halflist s t @ bs \\<and>\n     ?ts = as @ pair_relator_halflist t s @ bs\n  Abs_freelist (?as @ pair_relator_halflist ?s ?t @ ?bs)\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g `\n                    Abs_freeword `\n                    map (charpair S) ` R\\<rangle> \\<Longrightarrow>\n  Abs_freelist (?as @ pair_relator_halflist ?t ?s @ ?bs)\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Abs_freelist ss\n             \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                               lconjby g `\n                               Abs_freeword ` map (charpair S) ` R\\<rangle>;\n     flip_altsublist_adjacent ss ts\\<rbrakk>\n    \\<Longrightarrow> Abs_freelist ts\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "by auto"], ["", "lemma flip_altsublist_chain_G_in_Q:\n  \"\\<lbrakk> Abs_freelist ss \\<in> Q; flip_altsublist_chain (ss#xss@[ts]) \\<rbrakk> \\<Longrightarrow> Abs_freelist ts \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Abs_freelist ss\n             \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                               lconjby g `\n                               Abs_freeword ` map (charpair S) ` R\\<rangle>;\n     flip_altsublist_chain (ss # xss @ [ts])\\<rbrakk>\n    \\<Longrightarrow> Abs_freelist ts\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "using flip_altsublist_adjacent_in_Q\n        binrelchain_propcong_Cons_snoc[of\n          \"\\<lambda>ss. Abs_freelist ss \\<in> Q\"\n          flip_altsublist_adjacent\n        ]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Abs_freelist ?ss\n           \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                             lconjby g `\n                             Abs_freeword ` map (charpair S) ` R\\<rangle>;\n   flip_altsublist_adjacent ?ss ?ts\\<rbrakk>\n  \\<Longrightarrow> Abs_freelist ?ts\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>Abs_freelist x\n                       \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>;\n               flip_altsublist_adjacent x y\\<rbrakk>\n              \\<Longrightarrow> Abs_freelist y\n                                \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n            lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>;\n   Abs_freelist ?x\n   \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>;\n   flip_altsublist_chain (?x # ?xs @ [?y])\\<rbrakk>\n  \\<Longrightarrow> Abs_freelist ?y\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Abs_freelist ss\n             \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                               lconjby g `\n                               Abs_freeword ` map (charpair S) ` R\\<rangle>;\n     flip_altsublist_chain (ss # xss @ [ts])\\<rbrakk>\n    \\<Longrightarrow> Abs_freelist ts\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "by    fast"], ["", "lemma alternating_S_no_flip:\n  assumes \"s\\<in>S\" \"t\\<in>S\" \"n > 0\" \"n < relfun s t \\<or> relfun s t = 0\"\n  shows   \"sum_list (alternating_list n s t) \\<noteq> sum_list (alternating_list n t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (alternating_list n s t) \\<noteq>\n    sum_list (alternating_list n t s)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list (alternating_list n s t) =\n    sum_list (alternating_list n t s) \\<Longrightarrow>\n    False", "assume \"sum_list (alternating_list n s t) = sum_list (alternating_list n t s)\""], ["proof (state)\nthis:\n  sum_list (alternating_list n s t) = sum_list (alternating_list n t s)\n\ngoal (1 subgoal):\n 1. sum_list (alternating_list n s t) =\n    sum_list (alternating_list n t s) \\<Longrightarrow>\n    False", "hence \"sum_list (alternating_list n s t) + - sum_list (alternating_list n t s) = 0\""], ["proof (prove)\nusing this:\n  sum_list (alternating_list n s t) = sum_list (alternating_list n t s)\n\ngoal (1 subgoal):\n 1. sum_list (alternating_list n s t) +\n    - sum_list (alternating_list n t s) =\n    (0::'w)", "by simp"], ["proof (state)\nthis:\n  sum_list (alternating_list n s t) + - sum_list (alternating_list n t s) =\n  (0::'w)\n\ngoal (1 subgoal):\n 1. sum_list (alternating_list n s t) =\n    sum_list (alternating_list n t s) \\<Longrightarrow>\n    False", "with assms(1,2)"], ["proof (chain)\npicking this:\n  s \\<in> S\n  t \\<in> S\n  sum_list (alternating_list n s t) + - sum_list (alternating_list n t s) =\n  (0::'w)", "have \"sum_list (alternating_list (2*n) s t) = 0\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  t \\<in> S\n  sum_list (alternating_list n s t) + - sum_list (alternating_list n t s) =\n  (0::'w)\n\ngoal (1 subgoal):\n 1. sum_list (alternating_list (2 * n) s t) = (0::'w)", "by  (cases \"even n\")\n        (auto simp add:\n          genset_order2_add uminus_sum_list_alternating_order2\n          sum_list.append[THEN sym]\n          alternating_list_append mult_2\n        )"], ["proof (state)\nthis:\n  sum_list (alternating_list (2 * n) s t) = (0::'w)\n\ngoal (1 subgoal):\n 1. sum_list (alternating_list n s t) =\n    sum_list (alternating_list n t s) \\<Longrightarrow>\n    False", "with assms(3,4) less_add_order_eq_0_contra add_order_eq0"], ["proof (chain)\npicking this:\n  order.greater n 0\n  order.greater (add_order (s + t)) n \\<or> add_order (s + t) = 0\n  \\<lbrakk>order.greater ?k 0; order.greater (add_order ?a) ?k\\<rbrakk>\n  \\<Longrightarrow> ?a +^ ?k \\<noteq> (0::?'a)\n  \\<lbrakk>add_order ?a = 0; order.greater ?n 0\\<rbrakk>\n  \\<Longrightarrow> ?a +^ ?n \\<noteq> (0::?'a)\n  sum_list (alternating_list (2 * n) s t) = (0::'w)", "show False"], ["proof (prove)\nusing this:\n  order.greater n 0\n  order.greater (add_order (s + t)) n \\<or> add_order (s + t) = 0\n  \\<lbrakk>order.greater ?k 0; order.greater (add_order ?a) ?k\\<rbrakk>\n  \\<Longrightarrow> ?a +^ ?k \\<noteq> (0::?'a)\n  \\<lbrakk>add_order ?a = 0; order.greater ?n 0\\<rbrakk>\n  \\<Longrightarrow> ?a +^ ?n \\<noteq> (0::?'a)\n  sum_list (alternating_list (2 * n) s t) = (0::'w)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: alternating_sum_list_conv_nataction)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exchange_alternating_not_in_alternating:\n  assumes \"n \\<ge> 2\" \"n < relfun s t \\<or> relfun s t = 0\"\n          \"S_reduced_for w (alternating_list n s t @ cs)\"\n          \"alternating_list n s t @ cs = xs@[x]@ys\" \"S_reduced_for w (t#xs@ys)\"\n  shows   \"length xs \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (length xs) n", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. order.greater_eq (length xs) n", "from assms(1)"], ["proof (chain)\npicking this:\n  order.greater_eq n 2", "obtain m k where n: \"n = Suc m\" and m: \"m = Suc k\""], ["proof (prove)\nusing this:\n  order.greater_eq n 2\n\ngoal (1 subgoal):\n 1. (\\<And>m k.\n        \\<lbrakk>n = Suc m; m = Suc k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using gr0_implies_Suc"], ["proof (prove)\nusing this:\n  order.greater_eq n 2\n  order.greater ?n 0 \\<Longrightarrow> \\<exists>m. ?n = Suc m\n\ngoal (1 subgoal):\n 1. (\\<And>m k.\n        \\<lbrakk>n = Suc m; m = Suc k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  n = Suc m\n  m = Suc k\n\ngoal (1 subgoal):\n 1. order.greater_eq (length xs) n", "define altnst altnts altmts altkst\n    where \"altnst = alternating_list n s t\"\n    and \"altnts = alternating_list n t s\"\n    and \"altmts = alternating_list m t s\"\n    and \"altkst = alternating_list k s t\""], ["proof (state)\nthis:\n  altnst = alternating_list n s t\n  altnts = alternating_list n t s\n  altmts = alternating_list m t s\n  altkst = alternating_list k s t\n\ngoal (1 subgoal):\n 1. order.greater_eq (length xs) n", "from altnst_def altmts_def n"], ["proof (chain)\npicking this:\n  altnst = alternating_list n s t\n  altmts = alternating_list m t s\n  n = Suc m", "have altnmst: \"altnst = s # altmts\""], ["proof (prove)\nusing this:\n  altnst = alternating_list n s t\n  altmts = alternating_list m t s\n  n = Suc m\n\ngoal (1 subgoal):\n 1. altnst = s # altmts", "using alternating_list_Suc_Cons[of m]"], ["proof (prove)\nusing this:\n  altnst = alternating_list n s t\n  altmts = alternating_list m t s\n  n = Suc m\n  alternating_list (Suc m) ?s ?t = ?s # alternating_list m ?t ?s\n\ngoal (1 subgoal):\n 1. altnst = s # altmts", "by fastforce"], ["proof (state)\nthis:\n  altnst = s # altmts\n\ngoal (1 subgoal):\n 1. order.greater_eq (length xs) n", "with assms(3) altnst_def"], ["proof (chain)\npicking this:\n  S_reduced_for w (alternating_list n s t @ cs)\n  altnst = alternating_list n s t\n  altnst = s # altmts", "have s_S: \"s\\<in>S\""], ["proof (prove)\nusing this:\n  S_reduced_for w (alternating_list n s t @ cs)\n  altnst = alternating_list n s t\n  altnst = s # altmts\n\ngoal (1 subgoal):\n 1. s \\<in> S", "using reduced_word_for_lists"], ["proof (prove)\nusing this:\n  S_reduced_for w (alternating_list n s t @ cs)\n  altnst = alternating_list n s t\n  altnst = s # altmts\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. s \\<in> S", "by fastforce"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. order.greater_eq (length xs) n", "from assms(5)"], ["proof (chain)\npicking this:\n  S_reduced_for w (t # xs @ ys)", "have t_S: \"t\\<in>S\""], ["proof (prove)\nusing this:\n  S_reduced_for w (t # xs @ ys)\n\ngoal (1 subgoal):\n 1. t \\<in> S", "using reduced_word_for_lists"], ["proof (prove)\nusing this:\n  S_reduced_for w (t # xs @ ys)\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. t \\<in> S", "by fastforce"], ["proof (state)\nthis:\n  t \\<in> S\n\ngoal (1 subgoal):\n 1. order.greater_eq (length xs) n", "from m altnmst altmts_def altkst_def"], ["proof (chain)\npicking this:\n  m = Suc k\n  altnst = s # altmts\n  altmts = alternating_list m t s\n  altkst = alternating_list k s t", "have altnkst: \"altnst = s # t # altkst\""], ["proof (prove)\nusing this:\n  m = Suc k\n  altnst = s # altmts\n  altmts = alternating_list m t s\n  altkst = alternating_list k s t\n\ngoal (1 subgoal):\n 1. altnst = s # t # altkst", "using alternating_list_Suc_Cons"], ["proof (prove)\nusing this:\n  m = Suc k\n  altnst = s # altmts\n  altmts = alternating_list m t s\n  altkst = alternating_list k s t\n  alternating_list (Suc ?k) ?s ?t = ?s # alternating_list ?k ?t ?s\n\ngoal (1 subgoal):\n 1. altnst = s # t # altkst", "by fastforce"], ["proof (state)\nthis:\n  altnst = s # t # altkst\n\ngoal (1 subgoal):\n 1. order.greater_eq (length xs) n", "have \"\\<not> length xs < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> order.greater n (length xs)", "proof (cases \"Suc (length xs) = n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc (length xs) = n \\<Longrightarrow> \\<not> order.greater n (length xs)\n 2. Suc (length xs) \\<noteq> n \\<Longrightarrow>\n    \\<not> order.greater n (length xs)", "case True"], ["proof (state)\nthis:\n  Suc (length xs) = n\n\ngoal (2 subgoals):\n 1. Suc (length xs) = n \\<Longrightarrow> \\<not> order.greater n (length xs)\n 2. Suc (length xs) \\<noteq> n \\<Longrightarrow>\n    \\<not> order.greater n (length xs)", "with assms(4,5) n altnts_def"], ["proof (chain)\npicking this:\n  alternating_list n s t @ cs = xs @ [x] @ ys\n  S_reduced_for w (t # xs @ ys)\n  n = Suc m\n  altnts = alternating_list n t s\n  Suc (length xs) = n", "have flip: \"S_reduced_for w (altnts @ cs)\""], ["proof (prove)\nusing this:\n  alternating_list n s t @ cs = xs @ [x] @ ys\n  S_reduced_for w (t # xs @ ys)\n  n = Suc m\n  altnts = alternating_list n t s\n  Suc (length xs) = n\n\ngoal (1 subgoal):\n 1. S_reduced_for w (altnts @ cs)", "using length_alternating_list[of n s t]\n            same_length_eq_append[of altnts \"xs@[x]\" cs ys]\n            alternating_list_Suc_Cons[of m t s]"], ["proof (prove)\nusing this:\n  alternating_list n s t @ cs = xs @ [x] @ ys\n  S_reduced_for w (t # xs @ ys)\n  n = Suc m\n  altnts = alternating_list n t s\n  Suc (length xs) = n\n  length (alternating_list n s t) = n\n  \\<lbrakk>length altnts = length (xs @ [x]);\n   altnts @ cs = (xs @ [x]) @ ys\\<rbrakk>\n  \\<Longrightarrow> altnts = xs @ [x]\n  alternating_list (Suc m) t s = t # alternating_list m s t\n\ngoal (1 subgoal):\n 1. S_reduced_for w (altnts @ cs)", "by    auto"], ["proof (state)\nthis:\n  S_reduced_for w (altnts @ cs)\n\ngoal (2 subgoals):\n 1. Suc (length xs) = n \\<Longrightarrow> \\<not> order.greater n (length xs)\n 2. Suc (length xs) \\<noteq> n \\<Longrightarrow>\n    \\<not> order.greater n (length xs)", "from altnst_def"], ["proof (chain)\npicking this:\n  altnst = alternating_list n s t", "have \"sum_list altnst = sum_list altnts\""], ["proof (prove)\nusing this:\n  altnst = alternating_list n s t\n\ngoal (1 subgoal):\n 1. sum_list altnst = sum_list altnts", "using reduced_word_for_sum_list[OF assms(3)]\n            reduced_word_for_sum_list[OF flip]"], ["proof (prove)\nusing this:\n  altnst = alternating_list n s t\n  sum_list (alternating_list n s t @ cs) = w\n  sum_list (altnts @ cs) = w\n\ngoal (1 subgoal):\n 1. sum_list altnst = sum_list altnts", "by    auto"], ["proof (state)\nthis:\n  sum_list altnst = sum_list altnts\n\ngoal (2 subgoals):\n 1. Suc (length xs) = n \\<Longrightarrow> \\<not> order.greater n (length xs)\n 2. Suc (length xs) \\<noteq> n \\<Longrightarrow>\n    \\<not> order.greater n (length xs)", "with n assms(2) altnst_def altnts_def"], ["proof (chain)\npicking this:\n  n = Suc m\n  order.greater (add_order (s + t)) n \\<or> add_order (s + t) = 0\n  altnst = alternating_list n s t\n  altnts = alternating_list n t s\n  sum_list altnst = sum_list altnts", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Suc m\n  order.greater (add_order (s + t)) n \\<or> add_order (s + t) = 0\n  altnst = alternating_list n s t\n  altnts = alternating_list n t s\n  sum_list altnst = sum_list altnts\n\ngoal (1 subgoal):\n 1. \\<not> order.greater n (length xs)", "using alternating_S_no_flip[OF s_S t_S]"], ["proof (prove)\nusing this:\n  n = Suc m\n  order.greater (add_order (s + t)) n \\<or> add_order (s + t) = 0\n  altnst = alternating_list n s t\n  altnts = alternating_list n t s\n  sum_list altnst = sum_list altnts\n  \\<lbrakk>order.greater ?n 0;\n   order.greater (add_order (s + t)) ?n \\<or> add_order (s + t) = 0\\<rbrakk>\n  \\<Longrightarrow> sum_list (alternating_list ?n s t) \\<noteq>\n                    sum_list (alternating_list ?n t s)\n\ngoal (1 subgoal):\n 1. \\<not> order.greater n (length xs)", "by fast"], ["proof (state)\nthis:\n  \\<not> order.greater n (length xs)\n\ngoal (1 subgoal):\n 1. Suc (length xs) \\<noteq> n \\<Longrightarrow>\n    \\<not> order.greater n (length xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (length xs) \\<noteq> n \\<Longrightarrow>\n    \\<not> order.greater n (length xs)", "case False"], ["proof (state)\nthis:\n  Suc (length xs) \\<noteq> n\n\ngoal (1 subgoal):\n 1. Suc (length xs) \\<noteq> n \\<Longrightarrow>\n    \\<not> order.greater n (length xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> order.greater n (length xs)", "proof (cases xs ys rule: two_lists_cases_snoc_Cons)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ysa.\n       \\<lbrakk>xs = []; ys = ysa\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)\n 2. \\<And>xsa.\n       \\<lbrakk>xs = xsa; ys = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)\n 3. \\<And>xsa x y ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = y # ysa\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)", "case Nil1"], ["proof (state)\nthis:\n  xs = []\n  ys = ys_\n\ngoal (3 subgoals):\n 1. \\<And>ysa.\n       \\<lbrakk>xs = []; ys = ysa\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)\n 2. \\<And>xsa.\n       \\<lbrakk>xs = xsa; ys = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)\n 3. \\<And>xsa x y ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = y # ysa\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)", "from Nil1(1) assms(4) altnkst altnst_def"], ["proof (chain)\npicking this:\n  xs = []\n  alternating_list n s t @ cs = xs @ [x] @ ys\n  altnst = s # t # altkst\n  altnst = alternating_list n s t", "have \"ys = t # altkst @ cs\""], ["proof (prove)\nusing this:\n  xs = []\n  alternating_list n s t @ cs = xs @ [x] @ ys\n  altnst = s # t # altkst\n  altnst = alternating_list n s t\n\ngoal (1 subgoal):\n 1. ys = t # altkst @ cs", "by auto"], ["proof (state)\nthis:\n  ys = t # altkst @ cs\n\ngoal (3 subgoals):\n 1. \\<And>ysa.\n       \\<lbrakk>xs = []; ys = ysa\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)\n 2. \\<And>xsa.\n       \\<lbrakk>xs = xsa; ys = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)\n 3. \\<And>xsa x y ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = y # ysa\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)", "with Nil1(1) assms(5)"], ["proof (chain)\npicking this:\n  xs = []\n  S_reduced_for w (t # xs @ ys)\n  ys = t # altkst @ cs", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n  S_reduced_for w (t # xs @ ys)\n  ys = t # altkst @ cs\n\ngoal (1 subgoal):\n 1. \\<not> order.greater n (length xs)", "using t_S genset_order2_add[of t]\n              contains_order2_nreduced[of t S \"[]\" \"altkst@cs\"]\n              reduced_word_for_imp_reduced_word"], ["proof (prove)\nusing this:\n  xs = []\n  S_reduced_for w (t # xs @ ys)\n  ys = t # altkst @ cs\n  t \\<in> S\n  t \\<in> S \\<Longrightarrow> t + t = (0::'w)\n  t + t = (0::'w) \\<Longrightarrow>\n  \\<not> S_reduced ([] @ [t, t] @ altkst @ cs)\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> reduced_word ?A ?as\n\ngoal (1 subgoal):\n 1. \\<not> order.greater n (length xs)", "by    force"], ["proof (state)\nthis:\n  \\<not> order.greater n (length xs)\n\ngoal (2 subgoals):\n 1. \\<And>xsa.\n       \\<lbrakk>xs = xsa; ys = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)\n 2. \\<And>xsa x y ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = y # ysa\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xsa.\n       \\<lbrakk>xs = xsa; ys = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)\n 2. \\<And>xsa x y ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = y # ysa\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)", "case Nil2"], ["proof (state)\nthis:\n  xs = xs_\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<And>xsa.\n       \\<lbrakk>xs = xsa; ys = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)\n 2. \\<And>xsa x y ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = y # ysa\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)", "with assms(4) altnst_def False"], ["proof (chain)\npicking this:\n  alternating_list n s t @ cs = xs @ [x] @ ys\n  altnst = alternating_list n s t\n  Suc (length xs) \\<noteq> n\n  xs = xs_\n  ys = []", "show ?thesis"], ["proof (prove)\nusing this:\n  alternating_list n s t @ cs = xs @ [x] @ ys\n  altnst = alternating_list n s t\n  Suc (length xs) \\<noteq> n\n  xs = xs_\n  ys = []\n\ngoal (1 subgoal):\n 1. \\<not> order.greater n (length xs)", "using length_append[of altnst cs]"], ["proof (prove)\nusing this:\n  alternating_list n s t @ cs = xs @ [x] @ ys\n  altnst = alternating_list n s t\n  Suc (length xs) \\<noteq> n\n  xs = xs_\n  ys = []\n  length (altnst @ cs) = length altnst + length cs\n\ngoal (1 subgoal):\n 1. \\<not> order.greater n (length xs)", "by    (fastforce simp add: length_alternating_list)"], ["proof (state)\nthis:\n  \\<not> order.greater n (length xs)\n\ngoal (1 subgoal):\n 1. \\<And>xsa x y ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = y # ysa\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xsa x y ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = y # ysa\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)", "case (snoc_Cons us u z zs)"], ["proof (state)\nthis:\n  xs = us @ [u]\n  ys = z # zs\n\ngoal (1 subgoal):\n 1. \\<And>xsa x y ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = y # ysa\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)", "with assms(4,5) altnst_def"], ["proof (chain)\npicking this:\n  alternating_list n s t @ cs = xs @ [x] @ ys\n  S_reduced_for w (t # xs @ ys)\n  altnst = alternating_list n s t\n  xs = us @ [u]\n  ys = z # zs", "have  1: \"altnst @ cs = us@[u,x,z]@zs\" \"S_reduced_for w (t#us@[u,z]@zs)\""], ["proof (prove)\nusing this:\n  alternating_list n s t @ cs = xs @ [x] @ ys\n  S_reduced_for w (t # xs @ ys)\n  altnst = alternating_list n s t\n  xs = us @ [u]\n  ys = z # zs\n\ngoal (1 subgoal):\n 1. altnst @ cs = us @ [u, x, z] @ zs &&&\n    S_reduced_for w (t # us @ [u, z] @ zs)", "by    auto"], ["proof (state)\nthis:\n  altnst @ cs = us @ [u, x, z] @ zs\n  S_reduced_for w (t # us @ [u, z] @ zs)\n\ngoal (1 subgoal):\n 1. \\<And>xsa x y ysa.\n       \\<lbrakk>xs = xsa @ [x]; ys = y # ysa\\<rbrakk>\n       \\<Longrightarrow> \\<not> order.greater n (length xs)", "from 1(1) snoc_Cons(1) False altnst_def"], ["proof (chain)\npicking this:\n  altnst @ cs = us @ [u, x, z] @ zs\n  xs = us @ [u]\n  Suc (length xs) \\<noteq> n\n  altnst = alternating_list n s t", "show ?thesis"], ["proof (prove)\nusing this:\n  altnst @ cs = us @ [u, x, z] @ zs\n  xs = us @ [u]\n  Suc (length xs) \\<noteq> n\n  altnst = alternating_list n s t\n\ngoal (1 subgoal):\n 1. \\<not> order.greater n (length xs)", "using take_append[of n altnst cs] take_append[of n \"us@[u,x,z]\" zs]\n              set_alternating_list[of n s t]\n              alternating_list_alternates[of n s t us u]\n              reduced_word_for_imp_reduced_word[OF 1(2)]\n              s_S t_S genset_order2_add \n              contains_order2_nreduced[of u S \"t#us\"]"], ["proof (prove)\nusing this:\n  altnst @ cs = us @ [u, x, z] @ zs\n  xs = us @ [u]\n  Suc (length xs) \\<noteq> n\n  altnst = alternating_list n s t\n  take n (altnst @ cs) = take n altnst @ take (n - length altnst) cs\n  take n ((us @ [u, x, z]) @ zs) =\n  take n (us @ [u, x, z]) @ take (n - length (us @ [u, x, z])) zs\n  order.greater_eq {s, t} (set (alternating_list n s t))\n  alternating_list n s t = us @ [u, ?b, ?c] @ ?bs \\<Longrightarrow> u = ?c\n  S_reduced (t # us @ [u, z] @ zs)\n  s \\<in> S\n  t \\<in> S\n  ?s \\<in> S \\<Longrightarrow> ?s + ?s = (0::'w)\n  u + u = (0::'w) \\<Longrightarrow>\n  \\<not> S_reduced ((t # us) @ [u, u] @ ?bs)\n\ngoal (1 subgoal):\n 1. \\<not> order.greater n (length xs)", "by    (force simp add: length_alternating_list)"], ["proof (state)\nthis:\n  \\<not> order.greater n (length xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> order.greater n (length xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> order.greater n (length xs)\n\ngoal (1 subgoal):\n 1. order.greater_eq (length xs) n", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> order.greater n (length xs)\n\ngoal (1 subgoal):\n 1. order.greater_eq (length xs) n", "by fastforce"], ["proof (state)\nthis:\n  order.greater_eq (length xs) n\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context PreCoxeterSystem *)"], ["", "subsubsection \\<open>Preliminary facts on the word problem\\<close>"], ["", "text \\<open>\n  The word problem seeks criteria for determining whether two words over the generator set represent\n  the same element in @{term W}. Here we establish one direction of the word problem, as well as a\n  preliminary step toward the other direction.\n\\<close>"], ["", "context PreCoxeterSystem\nbegin"], ["", "lemmas flip_altsublist_chain_sum_list =\n  flip_altsublist_chain_funcong_Cons_snoc[OF flip_altsublist_adjacent_sum_list_ball]\n\\<comment> \\<open>This lemma represents one direction in the word problem: if a word in generators can be\ntransformed into another by a sequence of manipulations, each of which consists of replacing a\nhalf-relator subword by its reversal, then the two words sum to the same element of @{term W}.\\<close>"], ["", "lemma reduced_word_problem_eq_hd_step:\n  assumes step: \"\\<And>y ss ts. \\<lbrakk>\n                  S_length y < S_length w; y\\<noteq>0; S_reduced_for y ss; S_reduced_for y ts\n                \\<rbrakk> \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])\"\n  and     set_up: \"S_reduced_for w (a#ss)\" \"S_reduced_for w (a#ts)\"\n  shows   \"\\<exists>xss. flip_altsublist_chain ((a#ss) # xss @ [a#ts])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "proof (cases \"ss=ts\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ss = ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])\n 2. ss \\<noteq> ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "case True"], ["proof (state)\nthis:\n  ss = ts\n\ngoal (2 subgoals):\n 1. ss = ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])\n 2. ss \\<noteq> ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "with set_up(1)"], ["proof (chain)\npicking this:\n  S_reduced_for w (a # ss)\n  ss = ts", "have \"flip_altsublist_chain ((a#ss) # [] @ [a#ts])\""], ["proof (prove)\nusing this:\n  S_reduced_for w (a # ss)\n  ss = ts\n\ngoal (1 subgoal):\n 1. flip_altsublist_chain ((a # ss) # [] @ [a # ts])", "using reduced_word_for_lists flip_altsublist_adjacent_refl"], ["proof (prove)\nusing this:\n  S_reduced_for w (a # ss)\n  ss = ts\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n  \\<lbrakk>?ss \\<noteq> []; ?ss \\<in> lists S\\<rbrakk>\n  \\<Longrightarrow> flip_altsublist_adjacent ?ss ?ss\n\ngoal (1 subgoal):\n 1. flip_altsublist_chain ((a # ss) # [] @ [a # ts])", "by fastforce"], ["proof (state)\nthis:\n  flip_altsublist_chain ((a # ss) # [] @ [a # ts])\n\ngoal (2 subgoals):\n 1. ss = ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])\n 2. ss \\<noteq> ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "thus ?thesis"], ["proof (prove)\nusing this:\n  flip_altsublist_chain ((a # ss) # [] @ [a # ts])\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "by fast"], ["proof (state)\nthis:\n  \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])\n\ngoal (1 subgoal):\n 1. ss \\<noteq> ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ss \\<noteq> ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "case False"], ["proof (state)\nthis:\n  ss \\<noteq> ts\n\ngoal (1 subgoal):\n 1. ss \\<noteq> ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "define y where \"y = sum_list ss\""], ["proof (state)\nthis:\n  y = sum_list ss\n\ngoal (1 subgoal):\n 1. ss \\<noteq> ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "with set_up(1)"], ["proof (chain)\npicking this:\n  S_reduced_for w (a # ss)\n  y = sum_list ss", "have ss: \"S_reduced_for y ss\""], ["proof (prove)\nusing this:\n  S_reduced_for w (a # ss)\n  y = sum_list ss\n\ngoal (1 subgoal):\n 1. S_reduced_for y ss", "using reduced_word_for_imp_reduced_word reduced_word_Cons_reduce"], ["proof (prove)\nusing this:\n  S_reduced_for w (a # ss)\n  y = sum_list ss\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> reduced_word ?A ?as\n  reduced_word ?A (?a # ?as) \\<Longrightarrow> reduced_word ?A ?as\n\ngoal (1 subgoal):\n 1. S_reduced_for y ss", "by fast"], ["proof (state)\nthis:\n  S_reduced_for y ss\n\ngoal (1 subgoal):\n 1. ss \\<noteq> ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "moreover"], ["proof (state)\nthis:\n  S_reduced_for y ss\n\ngoal (1 subgoal):\n 1. ss \\<noteq> ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "from y_def ss"], ["proof (chain)\npicking this:\n  y = sum_list ss\n  S_reduced_for y ss", "have ts: \"S_reduced_for y ts\""], ["proof (prove)\nusing this:\n  y = sum_list ss\n  S_reduced_for y ss\n\ngoal (1 subgoal):\n 1. S_reduced_for y ts", "using reduced_word_for_sum_list[OF set_up(1)]\n          reduced_word_for_sum_list[OF set_up(2)]\n          reduced_word_for_eq_length[OF set_up(1) set_up(2)]\n          reduced_word_for_lists[OF set_up(2)]"], ["proof (prove)\nusing this:\n  y = sum_list ss\n  S_reduced_for y ss\n  sum_list (a # ss) = w\n  sum_list (a # ts) = w\n  length (a # ss) = length (a # ts)\n  a # ts \\<in> lists S\n\ngoal (1 subgoal):\n 1. S_reduced_for y ts", "by    (auto intro: reduced_word_forI_compare)"], ["proof (state)\nthis:\n  S_reduced_for y ts\n\ngoal (1 subgoal):\n 1. ss \\<noteq> ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "moreover"], ["proof (state)\nthis:\n  S_reduced_for y ts\n\ngoal (1 subgoal):\n 1. ss \\<noteq> ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "from ss set_up(1)"], ["proof (chain)\npicking this:\n  S_reduced_for y ss\n  S_reduced_for w (a # ss)", "have \"S_length y < S_length w\""], ["proof (prove)\nusing this:\n  S_reduced_for y ss\n  S_reduced_for w (a # ss)\n\ngoal (1 subgoal):\n 1. order.greater (S_length w) (S_length y)", "using reduced_word_for_length reduced_word_for_length"], ["proof (prove)\nusing this:\n  S_reduced_for y ss\n  S_reduced_for w (a # ss)\n  reduced_word_for ?A ?a ?as \\<Longrightarrow>\n  length ?as = word_length ?A ?a\n  reduced_word_for ?A ?a ?as \\<Longrightarrow>\n  length ?as = word_length ?A ?a\n\ngoal (1 subgoal):\n 1. order.greater (S_length w) (S_length y)", "by fastforce"], ["proof (state)\nthis:\n  order.greater (S_length w) (S_length y)\n\ngoal (1 subgoal):\n 1. ss \\<noteq> ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "moreover"], ["proof (state)\nthis:\n  order.greater (S_length w) (S_length y)\n\ngoal (1 subgoal):\n 1. ss \\<noteq> ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "from False"], ["proof (chain)\npicking this:\n  ss \\<noteq> ts", "have \"y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  ss \\<noteq> ts\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'w)", "using ss ts reduced_word_for_0_imp_nil reduced_word_for_0_imp_nil"], ["proof (prove)\nusing this:\n  ss \\<noteq> ts\n  S_reduced_for y ss\n  S_reduced_for y ts\n  reduced_word_for ?A (0::?'a) ?as \\<Longrightarrow> ?as = []\n  reduced_word_for ?A (0::?'a) ?as \\<Longrightarrow> ?as = []\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'w)", "by fastforce"], ["proof (state)\nthis:\n  y \\<noteq> (0::'w)\n\ngoal (1 subgoal):\n 1. ss \\<noteq> ts \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "ultimately"], ["proof (chain)\npicking this:\n  S_reduced_for y ss\n  S_reduced_for y ts\n  order.greater (S_length w) (S_length y)\n  y \\<noteq> (0::'w)", "show ?thesis"], ["proof (prove)\nusing this:\n  S_reduced_for y ss\n  S_reduced_for y ts\n  order.greater (S_length w) (S_length y)\n  y \\<noteq> (0::'w)\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "using step flip_altsublist_chain_map_Cons_grow"], ["proof (prove)\nusing this:\n  S_reduced_for y ss\n  S_reduced_for y ts\n  order.greater (S_length w) (S_length y)\n  y \\<noteq> (0::'w)\n  \\<lbrakk>order.greater (S_length w) (S_length ?y); ?y \\<noteq> (0::'w);\n   S_reduced_for ?y ?ss; S_reduced_for ?y ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n  flip_altsublist_chain ?tss \\<Longrightarrow>\n  flip_altsublist_chain (map ((#) ?t) ?tss)\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>xss. flip_altsublist_chain ((a # ss) # xss @ [a # ts])\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context PreCoxeterSystem *)"], ["", "subsubsection \\<open>Preliminary facts related to the deletion condition\\<close>"], ["", "text \\<open>\n  The deletion condition states that in a Coxeter system, every non-reduced word in the generating\n  set can be shortened to an equivalent word by deleting some particular pair of letters. This\n  condition is both necessary and sufficient for a group generated by elements of order two to be a\n  Coxeter system. Here we establish some facts related to the deletion condition that are true in\n  any group generated by elements of order two.\n\\<close>"], ["", "context PreCoxeterSystem\nbegin"], ["", "abbreviation \"\\<H> \\<equiv> (\\<Union>w\\<in>W. lconjby w ` S)\" \\<comment> \\<open>the set of reflections\\<close>"], ["", "abbreviation \"lift_signed_lconjperm \\<equiv> freeword_funlift signed_lconjpermutation\""], ["", "lemma lconjseq_reflections: \"ss\\<in>lists S \\<Longrightarrow> set (lconjseq ss) \\<subseteq> \\<H>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    order.greater_eq (\\<Union>w\\<in>W. lconjby w ` S) (set (lconjseq ss))", "using special_subgroup_eq_sum_list[of S]"], ["proof (prove)\nusing this:\n  order.greater_eq S S \\<Longrightarrow>\n  W = (\\<Union>ss\\<in>lists S. {sum_list ss})\n\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    order.greater_eq (\\<Union>w\\<in>W. lconjby w ` S) (set (lconjseq ss))", "by    (induct ss rule: rev_induct) (auto simp add: lconjseq_snoc)"], ["", "lemma deletion':\n  \"ss \\<in> lists S \\<Longrightarrow> \\<not> distinct (lconjseq ss) \\<Longrightarrow>\n    \\<exists>a b as bs cs. ss = as @ [a] @ bs @ [b] @ cs \\<and>\n      sum_list ss = sum_list (as@bs@cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<in> lists S; \\<not> distinct (lconjseq ss)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b as bs cs.\n                         ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                         sum_list ss = sum_list (as @ bs @ cs)", "proof (induct ss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> lists S; \\<not> distinct (lconjseq [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b as bs cs.\n                         [] = as @ [a] @ bs @ [b] @ cs \\<and>\n                         sum_list [] = sum_list (as @ bs @ cs)\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>ss \\<in> lists S;\n                 \\<not> distinct (lconjseq ss)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>a b as bs cs.\n                                     ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                                     sum_list ss = sum_list (as @ bs @ cs);\n        a # ss \\<in> lists S; \\<not> distinct (lconjseq (a # ss))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa b as bs cs.\n                            a # ss = as @ [aa] @ bs @ [b] @ cs \\<and>\n                            sum_list (a # ss) = sum_list (as @ bs @ cs)", "case (Cons s ss)"], ["proof (state)\nthis:\n  \\<lbrakk>ss \\<in> lists S; \\<not> distinct (lconjseq ss)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a b as bs cs.\n                       ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                       sum_list ss = sum_list (as @ bs @ cs)\n  s # ss \\<in> lists S\n  \\<not> distinct (lconjseq (s # ss))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> lists S; \\<not> distinct (lconjseq [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b as bs cs.\n                         [] = as @ [a] @ bs @ [b] @ cs \\<and>\n                         sum_list [] = sum_list (as @ bs @ cs)\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>ss \\<in> lists S;\n                 \\<not> distinct (lconjseq ss)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>a b as bs cs.\n                                     ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                                     sum_list ss = sum_list (as @ bs @ cs);\n        a # ss \\<in> lists S; \\<not> distinct (lconjseq (a # ss))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa b as bs cs.\n                            a # ss = as @ [aa] @ bs @ [b] @ cs \\<and>\n                            sum_list (a # ss) = sum_list (as @ bs @ cs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b as bs cs.\n       s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n       sum_list (s # ss) = sum_list (as @ bs @ cs)", "proof (cases \"distinct (lconjseq ss)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (lconjseq ss) \\<Longrightarrow>\n    \\<exists>a b as bs cs.\n       s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n       sum_list (s # ss) = sum_list (as @ bs @ cs)\n 2. \\<not> distinct (lconjseq ss) \\<Longrightarrow>\n    \\<exists>a b as bs cs.\n       s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n       sum_list (s # ss) = sum_list (as @ bs @ cs)", "case True"], ["proof (state)\nthis:\n  distinct (lconjseq ss)\n\ngoal (2 subgoals):\n 1. distinct (lconjseq ss) \\<Longrightarrow>\n    \\<exists>a b as bs cs.\n       s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n       sum_list (s # ss) = sum_list (as @ bs @ cs)\n 2. \\<not> distinct (lconjseq ss) \\<Longrightarrow>\n    \\<exists>a b as bs cs.\n       s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n       sum_list (s # ss) = sum_list (as @ bs @ cs)", "with Cons(2,3)"], ["proof (chain)\npicking this:\n  s # ss \\<in> lists S\n  \\<not> distinct (lconjseq (s # ss))\n  distinct (lconjseq ss)", "show ?thesis"], ["proof (prove)\nusing this:\n  s # ss \\<in> lists S\n  \\<not> distinct (lconjseq (s # ss))\n  distinct (lconjseq ss)\n\ngoal (1 subgoal):\n 1. \\<exists>a b as bs cs.\n       s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n       sum_list (s # ss) = sum_list (as @ bs @ cs)", "using subset_inj_on[OF lconjby_inj, of \"set (lconjseq ss)\" s]\n            distinct_map[of \"lconjby s\"]\n            genset_order2_add order2_hd_in_lconjseq_deletion[of s ss]"], ["proof (prove)\nusing this:\n  s # ss \\<in> lists S\n  \\<not> distinct (lconjseq (s # ss))\n  distinct (lconjseq ss)\n  order.greater_eq UNIV (set (lconjseq ss)) \\<Longrightarrow>\n  inj_on (lconjby s) (set (lconjseq ss))\n  distinct (map (lconjby s) ?xs) =\n  (distinct ?xs \\<and> inj_on (lconjby s) (set ?xs))\n  ?s \\<in> S \\<Longrightarrow> ?s + ?s = (0::'w)\n  \\<lbrakk>s + s = (0::'w); s \\<in> set (lconjseq ss)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as b bs.\n                       ss = as @ [b] @ bs \\<and>\n                       sum_list (s # ss) = sum_list (as @ bs)\n\ngoal (1 subgoal):\n 1. \\<exists>a b as bs cs.\n       s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n       sum_list (s # ss) = sum_list (as @ bs @ cs)", "by    (force simp add: algebra_simps)"], ["proof (state)\nthis:\n  \\<exists>a b as bs cs.\n     s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n     sum_list (s # ss) = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (lconjseq ss) \\<Longrightarrow>\n    \\<exists>a b as bs cs.\n       s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n       sum_list (s # ss) = sum_list (as @ bs @ cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (lconjseq ss) \\<Longrightarrow>\n    \\<exists>a b as bs cs.\n       s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n       sum_list (s # ss) = sum_list (as @ bs @ cs)", "case False"], ["proof (state)\nthis:\n  \\<not> distinct (lconjseq ss)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (lconjseq ss) \\<Longrightarrow>\n    \\<exists>a b as bs cs.\n       s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n       sum_list (s # ss) = sum_list (as @ bs @ cs)", "with Cons(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>ss \\<in> lists S; \\<not> distinct (lconjseq ss)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a b as bs cs.\n                       ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                       sum_list ss = sum_list (as @ bs @ cs)\n  s # ss \\<in> lists S\n  \\<not> distinct (lconjseq ss)", "obtain a b as bs cs where\n      \"s#ss = (s#as) @ [a] @ bs @ [b] @ cs\"\n      \"sum_list (s#ss) = sum_list ((s#as) @ bs @ cs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ss \\<in> lists S; \\<not> distinct (lconjseq ss)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a b as bs cs.\n                       ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                       sum_list ss = sum_list (as @ bs @ cs)\n  s # ss \\<in> lists S\n  \\<not> distinct (lconjseq ss)\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs b cs.\n        \\<lbrakk>s # ss = (s # as) @ [a] @ bs @ [b] @ cs;\n         sum_list (s # ss) = sum_list ((s # as) @ bs @ cs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  s # ss = (s # as) @ [a] @ bs @ [b] @ cs\n  sum_list (s # ss) = sum_list ((s # as) @ bs @ cs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (lconjseq ss) \\<Longrightarrow>\n    \\<exists>a b as bs cs.\n       s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n       sum_list (s # ss) = sum_list (as @ bs @ cs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  s # ss = (s # as) @ [a] @ bs @ [b] @ cs\n  sum_list (s # ss) = sum_list ((s # as) @ bs @ cs)\n\ngoal (1 subgoal):\n 1. \\<exists>a b as bs cs.\n       s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n       sum_list (s # ss) = sum_list (as @ bs @ cs)", "by fast"], ["proof (state)\nthis:\n  \\<exists>a b as bs cs.\n     s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n     sum_list (s # ss) = sum_list (as @ bs @ cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a b as bs cs.\n     s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n     sum_list (s # ss) = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[] \\<in> lists S; \\<not> distinct (lconjseq [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b as bs cs.\n                         [] = as @ [a] @ bs @ [b] @ cs \\<and>\n                         sum_list [] = sum_list (as @ bs @ cs)", "qed simp"], ["", "lemma S_reduced_imp_distinct_lconjseq':\n  assumes \"ss \\<in> lists S\" \"\\<not> distinct (lconjseq ss)\"\n  shows \"\\<not> S_reduced ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> S_reduced ss", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. S_reduced ss \\<Longrightarrow> False", "assume ss: \"S_reduced ss\""], ["proof (state)\nthis:\n  S_reduced ss\n\ngoal (1 subgoal):\n 1. S_reduced ss \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  ss \\<in> lists S\n  \\<not> distinct (lconjseq ss)", "obtain as a bs b cs\n    where decomp: \"ss = as @ [a] @ bs @ [b] @ cs\"\n                  \"sum_list ss = sum_list (as@bs@cs)\""], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  \\<not> distinct (lconjseq ss)\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs b cs.\n        \\<lbrakk>ss = as @ [a] @ bs @ [b] @ cs;\n         sum_list ss = sum_list (as @ bs @ cs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using deletion'[of ss]"], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  \\<not> distinct (lconjseq ss)\n  \\<lbrakk>ss \\<in> lists S; \\<not> distinct (lconjseq ss)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a b as bs cs.\n                       ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                       sum_list ss = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs b cs.\n        \\<lbrakk>ss = as @ [a] @ bs @ [b] @ cs;\n         sum_list ss = sum_list (as @ bs @ cs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  ss = as @ [a] @ bs @ [b] @ cs\n  sum_list ss = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. S_reduced ss \\<Longrightarrow> False", "from ss decomp assms(1)"], ["proof (chain)\npicking this:\n  S_reduced ss\n  ss = as @ [a] @ bs @ [b] @ cs\n  sum_list ss = sum_list (as @ bs @ cs)\n  ss \\<in> lists S", "show False"], ["proof (prove)\nusing this:\n  S_reduced ss\n  ss = as @ [a] @ bs @ [b] @ cs\n  sum_list ss = sum_list (as @ bs @ cs)\n  ss \\<in> lists S\n\ngoal (1 subgoal):\n 1. False", "using reduced_word_for_minimal[of S _ ss \"as@bs@cs\"]"], ["proof (prove)\nusing this:\n  S_reduced ss\n  ss = as @ [a] @ bs @ [b] @ cs\n  sum_list ss = sum_list (as @ bs @ cs)\n  ss \\<in> lists S\n  \\<lbrakk>S_reduced_for ?a ss; as @ bs @ cs \\<in> lists S;\n   sum_list (as @ bs @ cs) = ?a\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length (as @ bs @ cs)) (length ss)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma S_reduced_imp_distinct_lconjseq: \"S_reduced ss \\<Longrightarrow> distinct (lconjseq ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S_reduced ss \\<Longrightarrow> distinct (lconjseq ss)", "using reduced_word_for_lists S_reduced_imp_distinct_lconjseq'"], ["proof (prove)\nusing this:\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n  \\<lbrakk>?ss \\<in> lists S; \\<not> distinct (lconjseq ?ss)\\<rbrakk>\n  \\<Longrightarrow> \\<not> S_reduced ?ss\n\ngoal (1 subgoal):\n 1. S_reduced ss \\<Longrightarrow> distinct (lconjseq ss)", "by fast"], ["", "lemma permutation_lift_signed_lconjperm_eq_signed_list_lconjaction':\n  \"proper_signed_list xs \\<Longrightarrow> fst ` set xs \\<subseteq> S \\<Longrightarrow>\n    permutation (lift_signed_lconjperm (Abs_freeword xs)) =\n      signed_list_lconjaction (map fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proper_signed_list xs;\n     order.greater_eq S (fst ` set xs)\\<rbrakk>\n    \\<Longrightarrow> (\\<rightarrow>)\n                       (freeword_funlift signed_lconjpermutation\n                         (Abs_freeword xs)) =\n                      signed_list_lconjaction (map fst xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>proper_signed_list [];\n     order.greater_eq S (fst ` set [])\\<rbrakk>\n    \\<Longrightarrow> (\\<rightarrow>)\n                       (freeword_funlift signed_lconjpermutation\n                         (Abs_freeword [])) =\n                      signed_list_lconjaction (map fst [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> (\\<rightarrow>)\n                                   (freeword_funlift signed_lconjpermutation\n                                     (Abs_freeword xs)) =\n                                  signed_list_lconjaction (map fst xs);\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (freeword_funlift signed_lconjpermutation\n                            (Abs_freeword (a # xs))) =\n                         signed_list_lconjaction (map fst (a # xs))", "case Nil"], ["proof (state)\nthis:\n  proper_signed_list []\n  order.greater_eq S (fst ` set [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>proper_signed_list [];\n     order.greater_eq S (fst ` set [])\\<rbrakk>\n    \\<Longrightarrow> (\\<rightarrow>)\n                       (freeword_funlift signed_lconjpermutation\n                         (Abs_freeword [])) =\n                      signed_list_lconjaction (map fst [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> (\\<rightarrow>)\n                                   (freeword_funlift signed_lconjpermutation\n                                     (Abs_freeword xs)) =\n                                  signed_list_lconjaction (map fst xs);\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (freeword_funlift signed_lconjpermutation\n                            (Abs_freeword (a # xs))) =\n                         signed_list_lconjaction (map fst (a # xs))", "have \"Abs_freeword ([]::'w signed list) = (0::'w freeword)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_freeword [] = 0", "using zero_freeword.abs_eq"], ["proof (prove)\nusing this:\n  0 = Abs_freeword []\n\ngoal (1 subgoal):\n 1. Abs_freeword [] = 0", "by simp"], ["proof (state)\nthis:\n  Abs_freeword [] = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>proper_signed_list [];\n     order.greater_eq S (fst ` set [])\\<rbrakk>\n    \\<Longrightarrow> (\\<rightarrow>)\n                       (freeword_funlift signed_lconjpermutation\n                         (Abs_freeword [])) =\n                      signed_list_lconjaction (map fst [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> (\\<rightarrow>)\n                                   (freeword_funlift signed_lconjpermutation\n                                     (Abs_freeword xs)) =\n                                  signed_list_lconjaction (map fst xs);\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (freeword_funlift signed_lconjpermutation\n                            (Abs_freeword (a # xs))) =\n                         signed_list_lconjaction (map fst (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  Abs_freeword [] = 0\n\ngoal (1 subgoal):\n 1. (\\<rightarrow>)\n     (freeword_funlift signed_lconjpermutation (Abs_freeword [])) =\n    signed_list_lconjaction (map fst [])", "by (simp add: zero_permutation.rep_eq freeword_funlift_0)"], ["proof (state)\nthis:\n  (\\<rightarrow>)\n   (freeword_funlift signed_lconjpermutation (Abs_freeword [])) =\n  signed_list_lconjaction (map fst [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> (\\<rightarrow>)\n                                   (freeword_funlift signed_lconjpermutation\n                                     (Abs_freeword xs)) =\n                                  signed_list_lconjaction (map fst xs);\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (freeword_funlift signed_lconjpermutation\n                            (Abs_freeword (a # xs))) =\n                         signed_list_lconjaction (map fst (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> (\\<rightarrow>)\n                                   (freeword_funlift signed_lconjpermutation\n                                     (Abs_freeword xs)) =\n                                  signed_list_lconjaction (map fst xs);\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (freeword_funlift signed_lconjpermutation\n                            (Abs_freeword (a # xs))) =\n                         signed_list_lconjaction (map fst (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs)\\<rbrakk>\n  \\<Longrightarrow> (\\<rightarrow>)\n                     (freeword_funlift signed_lconjpermutation\n                       (Abs_freeword xs)) =\n                    signed_list_lconjaction (map fst xs)\n  proper_signed_list (x # xs)\n  order.greater_eq S (fst ` set (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> (\\<rightarrow>)\n                                   (freeword_funlift signed_lconjpermutation\n                                     (Abs_freeword xs)) =\n                                  signed_list_lconjaction (map fst xs);\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (freeword_funlift signed_lconjpermutation\n                            (Abs_freeword (a # xs))) =\n                         signed_list_lconjaction (map fst (a # xs))", "obtain s b where x: \"x=(s,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s b. x = (s, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (s, b)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>proper_signed_list xs;\n                 order.greater_eq S (fst ` set xs)\\<rbrakk>\n                \\<Longrightarrow> (\\<rightarrow>)\n                                   (freeword_funlift signed_lconjpermutation\n                                     (Abs_freeword xs)) =\n                                  signed_list_lconjaction (map fst xs);\n        proper_signed_list (a # xs);\n        order.greater_eq S (fst ` set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (freeword_funlift signed_lconjpermutation\n                            (Abs_freeword (a # xs))) =\n                         signed_list_lconjaction (map fst (a # xs))", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs)\\<rbrakk>\n  \\<Longrightarrow> (\\<rightarrow>)\n                     (freeword_funlift signed_lconjpermutation\n                       (Abs_freeword xs)) =\n                    signed_list_lconjaction (map fst xs)\n  proper_signed_list (x # xs)\n  order.greater_eq S (fst ` set (x # xs))\n  x = (s, b)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs)\\<rbrakk>\n  \\<Longrightarrow> (\\<rightarrow>)\n                     (freeword_funlift signed_lconjpermutation\n                       (Abs_freeword xs)) =\n                    signed_list_lconjaction (map fst xs)\n  proper_signed_list (x # xs)\n  order.greater_eq S (fst ` set (x # xs))\n  x = (s, b)\n\ngoal (1 subgoal):\n 1. (\\<rightarrow>)\n     (freeword_funlift signed_lconjpermutation (Abs_freeword (x # xs))) =\n    signed_list_lconjaction (map fst (x # xs))", "using Abs_freeword_Cons[of x xs]\n          binrelchain_Cons_reduce[of nflipped_signed x xs]\n          bij_signed_lconjaction[of s] genset_order2_add[of s]"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper_signed_list xs; order.greater_eq S (fst ` set xs)\\<rbrakk>\n  \\<Longrightarrow> (\\<rightarrow>)\n                     (freeword_funlift signed_lconjpermutation\n                       (Abs_freeword xs)) =\n                    signed_list_lconjaction (map fst xs)\n  proper_signed_list (x # xs)\n  order.greater_eq S (fst ` set (x # xs))\n  x = (s, b)\n  proper_signed_list (x # xs) \\<Longrightarrow>\n  Abs_freeword (x # xs) = Abs_freeword [x] + Abs_freeword xs\n  proper_signed_list (x # xs) \\<Longrightarrow> proper_signed_list xs\n  bij (signed_lconjaction s)\n  s \\<in> S \\<Longrightarrow> s + s = (0::'w)\n\ngoal (1 subgoal):\n 1. (\\<rightarrow>)\n     (freeword_funlift signed_lconjpermutation (Abs_freeword (x # xs))) =\n    signed_list_lconjaction (map fst (x # xs))", "by    (cases b)\n          (auto simp add:\n            plus_permutation.rep_eq freeword_funlift_add\n            freeword_funlift_Abs_freeletter\n            Abs_permutation_inverse uminus_permutation.rep_eq\n            the_inv_signed_lconjaction_by_order2\n            freeword_funlift_uminus_Abs_freeletter\n          )"], ["proof (state)\nthis:\n  (\\<rightarrow>)\n   (freeword_funlift signed_lconjpermutation (Abs_freeword (x # xs))) =\n  signed_list_lconjaction (map fst (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutation_lift_signed_lconjperm_eq_signed_list_lconjaction:\n  \"x \\<in> FreeGroup S \\<Longrightarrow>\n    permutation (lift_signed_lconjperm x) =\n      signed_list_lconjaction (map fst (freeword x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> FreeGroup S \\<Longrightarrow>\n    (\\<rightarrow>) (freeword_funlift signed_lconjpermutation x) =\n    signed_list_lconjaction (map fst (freeword x))", "using freeword FreeGroup_def[of S] freeword_inverse[of x]\n        permutation_lift_signed_lconjperm_eq_signed_list_lconjaction'"], ["proof (prove)\nusing this:\n  freeword ?x \\<in> {as. proper_signed_list as}\n  FreeGroup S \\<equiv> {x. order.greater_eq S (fst ` set (freeword x))}\n  Abs_freeword (freeword x) = x\n  \\<lbrakk>proper_signed_list ?xs;\n   order.greater_eq S (fst ` set ?xs)\\<rbrakk>\n  \\<Longrightarrow> (\\<rightarrow>)\n                     (freeword_funlift signed_lconjpermutation\n                       (Abs_freeword ?xs)) =\n                    signed_list_lconjaction (map fst ?xs)\n\ngoal (1 subgoal):\n 1. x \\<in> FreeGroup S \\<Longrightarrow>\n    (\\<rightarrow>) (freeword_funlift signed_lconjpermutation x) =\n    signed_list_lconjaction (map fst (freeword x))", "by    force"], ["", "lemma even_count_lconjseq_rev_relator:\n  \"s\\<in>S \\<Longrightarrow> t\\<in>S \\<Longrightarrow> even (count_list (lconjseq (rev (pair_relator_list s t))) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S\\<rbrakk>\n    \\<Longrightarrow> gcd_nat.greater_eq\n                       (count_list (lconjseq (rev (pair_relator_list s t)))\n                         x)\n                       2", "using even_count_lconjseq_alternating_order2[of t]"], ["proof (prove)\nusing this:\n  \\<lbrakk>t + t = (0::'w); ?t + ?t = (0::'w);\n   (t + ?t) +^ ?k = (0::'w)\\<rbrakk>\n  \\<Longrightarrow> gcd_nat.greater_eq\n                     (count_list (lconjseq (alternating_list (2 * ?k) t ?t))\n                       ?x)\n                     2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S\\<rbrakk>\n    \\<Longrightarrow> gcd_nat.greater_eq\n                       (count_list (lconjseq (rev (pair_relator_list s t)))\n                         x)\n                       2", "by    (simp add: genset_order2_add add_order rev_pair_relator_list)"], ["", "lemma GroupByPresentationInducedFun_S_R_signed_lconjaction:\n  \"GroupByPresentationInducedFun S P signed_lconjpermutation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupByPresentationInducedFun S (map (charpair S) ` R)\n     signed_lconjpermutation", "proof (intro_locales, rule GroupByPresentation_S_P, unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> map (charpair S) ` R \\<Longrightarrow>\n       freeword_funlift signed_lconjpermutation (Abs_freeword ps) = 0", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> map (charpair S) ` R \\<Longrightarrow>\n       freeword_funlift signed_lconjpermutation (Abs_freeword ps) = 0", "assume ps: \"ps\\<in>P\""], ["proof (state)\nthis:\n  ps \\<in> map (charpair S) ` R\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> map (charpair S) ` R \\<Longrightarrow>\n       freeword_funlift signed_lconjpermutation (Abs_freeword ps) = 0", "define r where \"r = Abs_freeword ps\""], ["proof (state)\nthis:\n  r = Abs_freeword ps\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> map (charpair S) ` R \\<Longrightarrow>\n       freeword_funlift signed_lconjpermutation (Abs_freeword ps) = 0", "with ps"], ["proof (chain)\npicking this:\n  ps \\<in> map (charpair S) ` R\n  r = Abs_freeword ps", "have r: \"r\\<in>P'\""], ["proof (prove)\nusing this:\n  ps \\<in> map (charpair S) ` R\n  r = Abs_freeword ps\n\ngoal (1 subgoal):\n 1. r \\<in> Abs_freeword ` map (charpair S) ` R", "by fast"], ["proof (state)\nthis:\n  r \\<in> Abs_freeword ` map (charpair S) ` R\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> map (charpair S) ` R \\<Longrightarrow>\n       freeword_funlift signed_lconjpermutation (Abs_freeword ps) = 0", "then"], ["proof (chain)\npicking this:\n  r \\<in> Abs_freeword ` map (charpair S) ` R", "obtain s t where st: \"s\\<in>S\" \"t\\<in>S\" \"r = pair_relator_freeword s t\""], ["proof (prove)\nusing this:\n  r \\<in> Abs_freeword ` map (charpair S) ` R\n\ngoal (1 subgoal):\n 1. (\\<And>s t.\n        \\<lbrakk>s \\<in> S; t \\<in> S;\n         r = pair_relator_freeword s t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using relator_freewords"], ["proof (prove)\nusing this:\n  r \\<in> Abs_freeword ` map (charpair S) ` R\n  Abs_freelist ` R = Abs_freeword ` map (charpair S) ` R\n\ngoal (1 subgoal):\n 1. (\\<And>s t.\n        \\<lbrakk>s \\<in> S; t \\<in> S;\n         r = pair_relator_freeword s t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  s \\<in> S\n  t \\<in> S\n  r = pair_relator_freeword s t\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> map (charpair S) ` R \\<Longrightarrow>\n       freeword_funlift signed_lconjpermutation (Abs_freeword ps) = 0", "from r st(3)"], ["proof (chain)\npicking this:\n  r \\<in> Abs_freeword ` map (charpair S) ` R\n  r = pair_relator_freeword s t", "have 1: \"permutation (lift_signed_lconjperm r) =\n              signed_list_lconjaction (pair_relator_list s t)\""], ["proof (prove)\nusing this:\n  r \\<in> Abs_freeword ` map (charpair S) ` R\n  r = pair_relator_freeword s t\n\ngoal (1 subgoal):\n 1. (\\<rightarrow>) (freeword_funlift signed_lconjpermutation r) =\n    signed_list_lconjaction (pair_relator_list s t)", "using P'_FreeS\n          permutation_lift_signed_lconjperm_eq_signed_list_lconjaction\n          Abs_freelist_inverse[of \"pair_relator_list s t\"]\n          map_fst_map_const_snd[of True \"pair_relator_list s t\"]"], ["proof (prove)\nusing this:\n  r \\<in> Abs_freeword ` map (charpair S) ` R\n  r = pair_relator_freeword s t\n  order.greater_eq (FreeGroup S) (Abs_freeword ` map (charpair S) ` R)\n  ?x \\<in> FreeGroup S \\<Longrightarrow>\n  (\\<rightarrow>) (freeword_funlift signed_lconjpermutation ?x) =\n  signed_list_lconjaction (map fst (freeword ?x))\n  freeword (pair_relator_freeword s t) =\n  map pairtrue (pair_relator_list s t)\n  map fst (map pairtrue (pair_relator_list s t)) = pair_relator_list s t\n\ngoal (1 subgoal):\n 1. (\\<rightarrow>) (freeword_funlift signed_lconjpermutation r) =\n    signed_list_lconjaction (pair_relator_list s t)", "by    force"], ["proof (state)\nthis:\n  (\\<rightarrow>) (freeword_funlift signed_lconjpermutation r) =\n  signed_list_lconjaction (pair_relator_list s t)\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> map (charpair S) ` R \\<Longrightarrow>\n       freeword_funlift signed_lconjpermutation (Abs_freeword ps) = 0", "have \"permutation (lift_signed_lconjperm r) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<rightarrow>) (freeword_funlift signed_lconjpermutation r) = id", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       freeword_funlift signed_lconjpermutation r \\<rightarrow> x = id x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       freeword_funlift signed_lconjpermutation r \\<rightarrow> x = id x", "show \"lift_signed_lconjperm r \\<rightarrow> x = id x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeword_funlift signed_lconjpermutation r \\<rightarrow> x = id x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (freeword_funlift signed_lconjpermutation r \\<rightarrow> x) =\n    fst (id x)\n 2. snd (freeword_funlift signed_lconjpermutation r \\<rightarrow> x) =\n    snd (id x)", "show \"snd (freeword_funlift signed_lconjpermutation r \\<rightarrow> x) = snd (id x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (freeword_funlift signed_lconjpermutation r \\<rightarrow> x) =\n    snd (id x)", "using 1 st(1,2) even_count_lconjseq_rev_relator genset_order2_add\n              set_alternating_list[of \"2*relfun s t\" s t]\n              signed_list_lconjaction_snd[of \"pair_relator_list s t\" x]"], ["proof (prove)\nusing this:\n  (\\<rightarrow>) (freeword_funlift signed_lconjpermutation r) =\n  signed_list_lconjaction (pair_relator_list s t)\n  s \\<in> S\n  t \\<in> S\n  \\<lbrakk>?s \\<in> S; ?t \\<in> S\\<rbrakk>\n  \\<Longrightarrow> gcd_nat.greater_eq\n                     (count_list (lconjseq (rev (pair_relator_list ?s ?t)))\n                       ?x)\n                     2\n  ?s \\<in> S \\<Longrightarrow> ?s + ?s = (0::'w)\n  order.greater_eq {s, t} (set (pair_relator_list s t))\n  \\<forall>s\\<in>set (pair_relator_list s t).\n     s + s = (0::'w) \\<Longrightarrow>\n  snd (signed_list_lconjaction (pair_relator_list s t) x) =\n  (if gcd_nat.greater_eq\n       (count_list (lconjseq (rev (pair_relator_list s t))) (fst x)) 2\n   then snd x else \\<not> snd x)\n\ngoal (1 subgoal):\n 1. snd (freeword_funlift signed_lconjpermutation r \\<rightarrow> x) =\n    snd (id x)", "by    fastforce"], ["proof (state)\nthis:\n  snd (freeword_funlift signed_lconjpermutation r \\<rightarrow> x) =\n  snd (id x)\n\ngoal (1 subgoal):\n 1. fst (freeword_funlift signed_lconjpermutation r \\<rightarrow> x) =\n    fst (id x)", "qed (simp add: 1 signed_list_lconjaction_fst sum_list_pair_relator_list)"], ["proof (state)\nthis:\n  freeword_funlift signed_lconjpermutation r \\<rightarrow> x = id x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<rightarrow>) (freeword_funlift signed_lconjpermutation r) = id\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> map (charpair S) ` R \\<Longrightarrow>\n       freeword_funlift signed_lconjpermutation (Abs_freeword ps) = 0", "moreover"], ["proof (state)\nthis:\n  (\\<rightarrow>) (freeword_funlift signed_lconjpermutation r) = id\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> map (charpair S) ` R \\<Longrightarrow>\n       freeword_funlift signed_lconjpermutation (Abs_freeword ps) = 0", "have  \"permutation (0::'w signed permutation) = (id::'w signed \\<Rightarrow> 'w signed)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<rightarrow>) 0 = id", "using zero_permutation.rep_eq"], ["proof (prove)\nusing this:\n  (\\<rightarrow>) 0 = id\n\ngoal (1 subgoal):\n 1. (\\<rightarrow>) 0 = id", "by    fast"], ["proof (state)\nthis:\n  (\\<rightarrow>) 0 = id\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       ps \\<in> map (charpair S) ` R \\<Longrightarrow>\n       freeword_funlift signed_lconjpermutation (Abs_freeword ps) = 0", "ultimately"], ["proof (chain)\npicking this:\n  (\\<rightarrow>) (freeword_funlift signed_lconjpermutation r) = id\n  (\\<rightarrow>) 0 = id", "show \"lift_signed_lconjperm r = 0\""], ["proof (prove)\nusing this:\n  (\\<rightarrow>) (freeword_funlift signed_lconjpermutation r) = id\n  (\\<rightarrow>) 0 = id\n\ngoal (1 subgoal):\n 1. freeword_funlift signed_lconjpermutation r = 0", "using permutation_inject"], ["proof (prove)\nusing this:\n  (\\<rightarrow>) (freeword_funlift signed_lconjpermutation r) = id\n  (\\<rightarrow>) 0 = id\n  ((\\<rightarrow>) ?x = (\\<rightarrow>) ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. freeword_funlift signed_lconjpermutation r = 0", "by fastforce"], ["proof (state)\nthis:\n  freeword_funlift signed_lconjpermutation r = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context PreCoxeterSystem *)"], ["", "subsection \\<open>Coxeter-like systems with deletion\\<close>"], ["", "text \\<open>\n  Here we add the so-called deletion condition as an assumption, and explore its consequences.\n\\<close>"], ["", "subsubsection \\<open>Locale definition\\<close>"], ["", "locale PreCoxeterSystemWithDeletion = PreCoxeterSystem S\n  for S :: \"'w::group_add set\"\n+ assumes deletion:\n  \"ss \\<in> lists S \\<Longrightarrow> \\<not> reduced_word S ss \\<Longrightarrow>\n    \\<exists>a b as bs cs. ss = as @ [a] @ bs @ [b] @ cs \\<and>\n      sum_list ss = sum_list (as@bs@cs)\""], ["", "subsubsection \\<open>Consequences of the deletion condition\\<close>"], ["", "context PreCoxeterSystemWithDeletion\nbegin"], ["", "lemma deletion_reduce:\n  \"ss \\<in> lists S \\<Longrightarrow> \\<exists>ts. ts \\<in> ssubseqs ss \\<inter> reduced_words_for S (sum_list ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    \\<exists>ts.\n       ts \\<in> ssubseqs ss \\<inter> reduced_words_for S (sum_list ss)", "proof (cases \"S_reduced ss\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ss \\<in> lists S; S_reduced ss\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ts.\n                         ts \\<in> ssubseqs ss \\<inter>\n                                  reduced_words_for S (sum_list ss)\n 2. \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ts.\n                         ts \\<in> ssubseqs ss \\<inter>\n                                  reduced_words_for S (sum_list ss)", "case True"], ["proof (state)\nthis:\n  S_reduced ss\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ss \\<in> lists S; S_reduced ss\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ts.\n                         ts \\<in> ssubseqs ss \\<inter>\n                                  reduced_words_for S (sum_list ss)\n 2. \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ts.\n                         ts \\<in> ssubseqs ss \\<inter>\n                                  reduced_words_for S (sum_list ss)", "thus  \"ss \\<in> lists S \\<Longrightarrow>\n          \\<exists>ts. ts \\<in> ssubseqs ss \\<inter> reduced_words_for S (sum_list ss)\""], ["proof (prove)\nusing this:\n  S_reduced ss\n\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    \\<exists>ts.\n       ts \\<in> ssubseqs ss \\<inter> reduced_words_for S (sum_list ss)", "by  (force simp add: ssubseqs_refl)"], ["proof (state)\nthis:\n  ss \\<in> lists S \\<Longrightarrow>\n  \\<exists>ts.\n     ts \\<in> ssubseqs ss \\<inter> reduced_words_for S (sum_list ss)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ts.\n                         ts \\<in> ssubseqs ss \\<inter>\n                                  reduced_words_for S (sum_list ss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ts.\n                         ts \\<in> ssubseqs ss \\<inter>\n                                  reduced_words_for S (sum_list ss)", "case False"], ["proof (state)\nthis:\n  \\<not> S_reduced ss\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ts.\n                         ts \\<in> ssubseqs ss \\<inter>\n                                  reduced_words_for S (sum_list ss)", "have \"ss \\<in> lists S \\<Longrightarrow> \\<not> S_reduced ss \\<Longrightarrow>\n        \\<exists>ts. ts \\<in> ssubseqs ss \\<inter> reduced_words_for S (sum_list ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ts.\n                         ts \\<in> ssubseqs ss \\<inter>\n                                  reduced_words_for S (sum_list ss)", "proof (induct ss rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   ys \\<in> lists S \\<longrightarrow>\n                   \\<not> S_reduced ys \\<longrightarrow>\n                   (\\<exists>ts.\n                       ts \\<in> ssubseqs ys \\<inter>\n                                reduced_words_for S (sum_list ys));\n        xs \\<in> lists S; \\<not> S_reduced xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts.\n                            ts \\<in> ssubseqs xs \\<inter>\n                                     reduced_words_for S (sum_list xs)", "fix xs::\"'w list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   ys \\<in> lists S \\<longrightarrow>\n                   \\<not> S_reduced ys \\<longrightarrow>\n                   (\\<exists>ts.\n                       ts \\<in> ssubseqs ys \\<inter>\n                                reduced_words_for S (sum_list ys));\n        xs \\<in> lists S; \\<not> S_reduced xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts.\n                            ts \\<in> ssubseqs xs \\<inter>\n                                     reduced_words_for S (sum_list xs)", "assume xs:\n      \"\\<forall>ys. length ys < length xs \\<longrightarrow> ys \\<in> lists S \\<longrightarrow> \\<not> S_reduced ys\n        \\<longrightarrow> (\\<exists>ts. ts \\<in> ssubseqs ys \\<inter> reduced_words_for S (sum_list ys))\"\n      \"xs \\<in> lists S\" \"\\<not> S_reduced xs\""], ["proof (state)\nthis:\n  \\<forall>ys.\n     order.greater (length xs) (length ys) \\<longrightarrow>\n     ys \\<in> lists S \\<longrightarrow>\n     \\<not> S_reduced ys \\<longrightarrow>\n     (\\<exists>ts.\n         ts \\<in> ssubseqs ys \\<inter> reduced_words_for S (sum_list ys))\n  xs \\<in> lists S\n  \\<not> S_reduced xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   ys \\<in> lists S \\<longrightarrow>\n                   \\<not> S_reduced ys \\<longrightarrow>\n                   (\\<exists>ts.\n                       ts \\<in> ssubseqs ys \\<inter>\n                                reduced_words_for S (sum_list ys));\n        xs \\<in> lists S; \\<not> S_reduced xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts.\n                            ts \\<in> ssubseqs xs \\<inter>\n                                     reduced_words_for S (sum_list xs)", "from xs(2,3)"], ["proof (chain)\npicking this:\n  xs \\<in> lists S\n  \\<not> S_reduced xs", "obtain as a bs b cs\n      where asbscs: \"xs = as@[a]@bs@[b]@cs\" \"sum_list xs = sum_list (as@bs@cs)\""], ["proof (prove)\nusing this:\n  xs \\<in> lists S\n  \\<not> S_reduced xs\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs b cs.\n        \\<lbrakk>xs = as @ [a] @ bs @ [b] @ cs;\n         sum_list xs = sum_list (as @ bs @ cs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using deletion[of xs]"], ["proof (prove)\nusing this:\n  xs \\<in> lists S\n  \\<not> S_reduced xs\n  \\<lbrakk>xs \\<in> lists S; \\<not> S_reduced xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a b as bs cs.\n                       xs = as @ [a] @ bs @ [b] @ cs \\<and>\n                       sum_list xs = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs b cs.\n        \\<lbrakk>xs = as @ [a] @ bs @ [b] @ cs;\n         sum_list xs = sum_list (as @ bs @ cs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  xs = as @ [a] @ bs @ [b] @ cs\n  sum_list xs = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   ys \\<in> lists S \\<longrightarrow>\n                   \\<not> S_reduced ys \\<longrightarrow>\n                   (\\<exists>ts.\n                       ts \\<in> ssubseqs ys \\<inter>\n                                reduced_words_for S (sum_list ys));\n        xs \\<in> lists S; \\<not> S_reduced xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts.\n                            ts \\<in> ssubseqs xs \\<inter>\n                                     reduced_words_for S (sum_list xs)", "show \"\\<exists>ts. ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)", "proof (cases \"S_reduced (as@bs@cs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. S_reduced (as @ bs @ cs) \\<Longrightarrow>\n    \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)\n 2. \\<not> S_reduced (as @ bs @ cs) \\<Longrightarrow>\n    \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)", "case True"], ["proof (state)\nthis:\n  S_reduced (as @ bs @ cs)\n\ngoal (2 subgoals):\n 1. S_reduced (as @ bs @ cs) \\<Longrightarrow>\n    \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)\n 2. \\<not> S_reduced (as @ bs @ cs) \\<Longrightarrow>\n    \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)", "with asbscs xs(2)"], ["proof (chain)\npicking this:\n  xs = as @ [a] @ bs @ [b] @ cs\n  sum_list xs = sum_list (as @ bs @ cs)\n  xs \\<in> lists S\n  S_reduced (as @ bs @ cs)", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = as @ [a] @ bs @ [b] @ cs\n  sum_list xs = sum_list (as @ bs @ cs)\n  xs \\<in> lists S\n  S_reduced (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)", "using delete2_ssubseqs"], ["proof (prove)\nusing this:\n  xs = as @ [a] @ bs @ [b] @ cs\n  sum_list xs = sum_list (as @ bs @ cs)\n  xs \\<in> lists S\n  S_reduced (as @ bs @ cs)\n  ?as @ ?bs @ ?cs \\<in> ssubseqs (?as @ [?a] @ ?bs @ [?b] @ ?cs)\n\ngoal (1 subgoal):\n 1. \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ts.\n     ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<not> S_reduced (as @ bs @ cs) \\<Longrightarrow>\n    \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> S_reduced (as @ bs @ cs) \\<Longrightarrow>\n    \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)", "case False"], ["proof (state)\nthis:\n  \\<not> S_reduced (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. \\<not> S_reduced (as @ bs @ cs) \\<Longrightarrow>\n    \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)", "moreover"], ["proof (state)\nthis:\n  \\<not> S_reduced (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. \\<not> S_reduced (as @ bs @ cs) \\<Longrightarrow>\n    \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)", "from asbscs(1) xs(2)"], ["proof (chain)\npicking this:\n  xs = as @ [a] @ bs @ [b] @ cs\n  xs \\<in> lists S", "have  \"length (as@bs@cs) < length xs\" \"as@bs@cs \\<in> lists S\""], ["proof (prove)\nusing this:\n  xs = as @ [a] @ bs @ [b] @ cs\n  xs \\<in> lists S\n\ngoal (1 subgoal):\n 1. order.greater (length xs) (length (as @ bs @ cs)) &&&\n    as @ bs @ cs \\<in> lists S", "by    auto"], ["proof (state)\nthis:\n  order.greater (length xs) (length (as @ bs @ cs))\n  as @ bs @ cs \\<in> lists S\n\ngoal (1 subgoal):\n 1. \\<not> S_reduced (as @ bs @ cs) \\<Longrightarrow>\n    \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> S_reduced (as @ bs @ cs)\n  order.greater (length xs) (length (as @ bs @ cs))\n  as @ bs @ cs \\<in> lists S", "obtain ts\n        where ts: \"ts \\<in> ssubseqs (as@bs@cs) \\<inter>\n                    reduced_words_for S (sum_list (as@bs@cs))\""], ["proof (prove)\nusing this:\n  \\<not> S_reduced (as @ bs @ cs)\n  order.greater (length xs) (length (as @ bs @ cs))\n  as @ bs @ cs \\<in> lists S\n\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        ts \\<in> ssubseqs (as @ bs @ cs) \\<inter>\n                 reduced_words_for S\n                  (sum_list (as @ bs @ cs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using xs(1,2) asbscs(1)"], ["proof (prove)\nusing this:\n  \\<not> S_reduced (as @ bs @ cs)\n  order.greater (length xs) (length (as @ bs @ cs))\n  as @ bs @ cs \\<in> lists S\n  \\<forall>ys.\n     order.greater (length xs) (length ys) \\<longrightarrow>\n     ys \\<in> lists S \\<longrightarrow>\n     \\<not> S_reduced ys \\<longrightarrow>\n     (\\<exists>ts.\n         ts \\<in> ssubseqs ys \\<inter> reduced_words_for S (sum_list ys))\n  xs \\<in> lists S\n  xs = as @ [a] @ bs @ [b] @ cs\n\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        ts \\<in> ssubseqs (as @ bs @ cs) \\<inter>\n                 reduced_words_for S\n                  (sum_list (as @ bs @ cs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  ts \\<in> ssubseqs (as @ bs @ cs) \\<inter>\n           reduced_words_for S (sum_list (as @ bs @ cs))\n\ngoal (1 subgoal):\n 1. \\<not> S_reduced (as @ bs @ cs) \\<Longrightarrow>\n    \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)", "with asbscs"], ["proof (chain)\npicking this:\n  xs = as @ [a] @ bs @ [b] @ cs\n  sum_list xs = sum_list (as @ bs @ cs)\n  ts \\<in> ssubseqs (as @ bs @ cs) \\<inter>\n           reduced_words_for S (sum_list (as @ bs @ cs))", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = as @ [a] @ bs @ [b] @ cs\n  sum_list xs = sum_list (as @ bs @ cs)\n  ts \\<in> ssubseqs (as @ bs @ cs) \\<inter>\n           reduced_words_for S (sum_list (as @ bs @ cs))\n\ngoal (1 subgoal):\n 1. \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)", "using delete2_ssubseqs[of as bs cs a b] ssubseqs_subset"], ["proof (prove)\nusing this:\n  xs = as @ [a] @ bs @ [b] @ cs\n  sum_list xs = sum_list (as @ bs @ cs)\n  ts \\<in> ssubseqs (as @ bs @ cs) \\<inter>\n           reduced_words_for S (sum_list (as @ bs @ cs))\n  as @ bs @ cs \\<in> ssubseqs (as @ [a] @ bs @ [b] @ cs)\n  ?as \\<in> ssubseqs ?bs \\<Longrightarrow>\n  order.greater_eq (ssubseqs ?bs) (ssubseqs ?as)\n\ngoal (1 subgoal):\n 1. \\<exists>ts.\n       ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)", "by auto"], ["proof (state)\nthis:\n  \\<exists>ts.\n     ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ts.\n     ts \\<in> ssubseqs xs \\<inter> reduced_words_for S (sum_list xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts.\n                       ts \\<in> ssubseqs ss \\<inter>\n                                reduced_words_for S (sum_list ss)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ts.\n                         ts \\<in> ssubseqs ss \\<inter>\n                                  reduced_words_for S (sum_list ss)", "with False"], ["proof (chain)\npicking this:\n  \\<not> S_reduced ss\n  \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts.\n                       ts \\<in> ssubseqs ss \\<inter>\n                                reduced_words_for S (sum_list ss)", "show  \"ss \\<in> lists S \\<Longrightarrow>\n            \\<exists>ts. ts \\<in> ssubseqs ss \\<inter> reduced_words_for S (sum_list ss)\""], ["proof (prove)\nusing this:\n  \\<not> S_reduced ss\n  \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ts.\n                       ts \\<in> ssubseqs ss \\<inter>\n                                reduced_words_for S (sum_list ss)\n\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    \\<exists>ts.\n       ts \\<in> ssubseqs ss \\<inter> reduced_words_for S (sum_list ss)", "by    fast"], ["proof (state)\nthis:\n  ss \\<in> lists S \\<Longrightarrow>\n  \\<exists>ts.\n     ts \\<in> ssubseqs ss \\<inter> reduced_words_for S (sum_list ss)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deletion_reduce':\n  \"ss \\<in> lists S \\<Longrightarrow> \\<exists>ts\\<in>reduced_words_for S (sum_list ss). set ts \\<subseteq> set ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    \\<exists>ts\\<in>reduced_words_for S (sum_list ss).\n       order.greater_eq (set ss) (set ts)", "using deletion_reduce[of ss] subseqs_powset[of ss]"], ["proof (prove)\nusing this:\n  ss \\<in> lists S \\<Longrightarrow>\n  \\<exists>ts.\n     ts \\<in> ssubseqs ss \\<inter> reduced_words_for S (sum_list ss)\n  set ` ssubseqs ss = Pow (set ss)\n\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    \\<exists>ts\\<in>reduced_words_for S (sum_list ss).\n       order.greater_eq (set ss) (set ts)", "by auto"], ["", "end"], ["", "(* context PreCoxeterSystemWithDeletion *)"], ["", "subsubsection \\<open>The exchange condition\\<close>"], ["", "text \\<open>\n  The exchange condition states that, given a reduced word in the generators, if prepending a\n  letter to the word does not remain reduced, then the new word can be shortened to a word\n  equivalent to the original one by deleting some letter other than the prepended one. Thus, one\n  able to exchange some letter for the addition of a desired letter at the beginning of a word,\n  without changing the elemented represented.\n\\<close>"], ["", "context PreCoxeterSystemWithDeletion\nbegin"], ["", "lemma exchange:\n  assumes \"s\\<in>S\" \"S_reduced_for w ss\" \"\\<not> S_reduced (s#ss)\"\n  shows   \"\\<exists>t as bs. ss = as@t#bs \\<and> reduced_word_for S w (s#as@bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "from assms(2)"], ["proof (chain)\npicking this:\n  S_reduced_for w ss", "have ss_lists: \"ss \\<in> lists S\""], ["proof (prove)\nusing this:\n  S_reduced_for w ss\n\ngoal (1 subgoal):\n 1. ss \\<in> lists S", "using reduced_word_for_lists"], ["proof (prove)\nusing this:\n  S_reduced_for w ss\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. ss \\<in> lists S", "by fast"], ["proof (state)\nthis:\n  ss \\<in> lists S\n\ngoal (1 subgoal):\n 1. \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "with assms(1)"], ["proof (chain)\npicking this:\n  s \\<in> S\n  ss \\<in> lists S", "have \"s#ss \\<in> lists S\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  ss \\<in> lists S\n\ngoal (1 subgoal):\n 1. s # ss \\<in> lists S", "by simp"], ["proof (state)\nthis:\n  s # ss \\<in> lists S\n\ngoal (1 subgoal):\n 1. \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "with assms(3)"], ["proof (chain)\npicking this:\n  \\<not> S_reduced (s # ss)\n  s # ss \\<in> lists S", "obtain a b as bs cs\n    where del:  \"s#ss = as @ [a] @ bs @ [b] @ cs\"\n                \"sum_list (s#ss) = sum_list (as@bs@cs)\""], ["proof (prove)\nusing this:\n  \\<not> S_reduced (s # ss)\n  s # ss \\<in> lists S\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs b cs.\n        \\<lbrakk>s # ss = as @ [a] @ bs @ [b] @ cs;\n         sum_list (s # ss) = sum_list (as @ bs @ cs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using deletion[of \"s#ss\"]"], ["proof (prove)\nusing this:\n  \\<not> S_reduced (s # ss)\n  s # ss \\<in> lists S\n  \\<lbrakk>s # ss \\<in> lists S; \\<not> S_reduced (s # ss)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a b as bs cs.\n                       s # ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                       sum_list (s # ss) = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs b cs.\n        \\<lbrakk>s # ss = as @ [a] @ bs @ [b] @ cs;\n         sum_list (s # ss) = sum_list (as @ bs @ cs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fastforce"], ["proof (state)\nthis:\n  s # ss = as @ [a] @ bs @ [b] @ cs\n  sum_list (s # ss) = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "proof (cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>t as bs.\n          ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>t as bs.\n          ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "with assms(1,2) del"], ["proof (chain)\npicking this:\n  s \\<in> S\n  S_reduced_for w ss\n  s # ss = as @ [a] @ bs @ [b] @ cs\n  sum_list (s # ss) = sum_list (as @ bs @ cs)\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> S\n  S_reduced_for w ss\n  s # ss = as @ [a] @ bs @ [b] @ cs\n  sum_list (s # ss) = sum_list (as @ bs @ cs)\n  as = []\n\ngoal (1 subgoal):\n 1. \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "using reduced_word_for_sum_list add.assoc[of s s w] genset_order2_add ss_lists"], ["proof (prove)\nusing this:\n  s \\<in> S\n  S_reduced_for w ss\n  s # ss = as @ [a] @ bs @ [b] @ cs\n  sum_list (s # ss) = sum_list (as @ bs @ cs)\n  as = []\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> sum_list ?as = ?a\n  s + s + w = s + (s + w)\n  ?s \\<in> S \\<Longrightarrow> ?s + ?s = (0::'w)\n  ss \\<in> lists S\n\ngoal (1 subgoal):\n 1. \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "by    (fastforce intro: reduced_word_forI_compare)"], ["proof (state)\nthis:\n  \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>t as bs.\n          ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>t as bs.\n          ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "case (Cons d ds)"], ["proof (state)\nthis:\n  as = d # ds\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<exists>t as bs.\n          ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "with del assms(2)"], ["proof (chain)\npicking this:\n  s # ss = as @ [a] @ bs @ [b] @ cs\n  sum_list (s # ss) = sum_list (as @ bs @ cs)\n  S_reduced_for w ss\n  as = d # ds", "show ?thesis"], ["proof (prove)\nusing this:\n  s # ss = as @ [a] @ bs @ [b] @ cs\n  sum_list (s # ss) = sum_list (as @ bs @ cs)\n  S_reduced_for w ss\n  as = d # ds\n\ngoal (1 subgoal):\n 1. \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "using ss_lists reduced_word_for_imp_reduced_word\n            reduced_word_for_minimal[of S \"sum_list ss\" ss \"ds@bs@cs\"]"], ["proof (prove)\nusing this:\n  s # ss = as @ [a] @ bs @ [b] @ cs\n  sum_list (s # ss) = sum_list (as @ bs @ cs)\n  S_reduced_for w ss\n  as = d # ds\n  ss \\<in> lists S\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> reduced_word ?A ?as\n  \\<lbrakk>S_reduced ss; ds @ bs @ cs \\<in> lists S;\n   sum_list (ds @ bs @ cs) = sum_list ss\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length (ds @ bs @ cs)) (length ss)\n\ngoal (1 subgoal):\n 1. \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)", "by    fastforce"], ["proof (state)\nthis:\n  \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t as bs. ss = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduced_head_imp_exchange:\n  assumes \"reduced_word_for S w (s#as)\" \"reduced_word_for S w cs\"\n  shows   \"\\<exists>a ds es. cs = ds@[a]@es \\<and> reduced_word_for S w (s#ds@es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a ds es.\n       cs = ds @ [a] @ es \\<and> S_reduced_for w (s # ds @ es)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a ds es.\n       cs = ds @ [a] @ es \\<and> S_reduced_for w (s # ds @ es)", "from assms(1)"], ["proof (chain)\npicking this:\n  S_reduced_for w (s # as)", "have s_S: \"s\\<in>S\""], ["proof (prove)\nusing this:\n  S_reduced_for w (s # as)\n\ngoal (1 subgoal):\n 1. s \\<in> S", "using reduced_word_for_lists"], ["proof (prove)\nusing this:\n  S_reduced_for w (s # as)\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. s \\<in> S", "by fastforce"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>a ds es.\n       cs = ds @ [a] @ es \\<and> S_reduced_for w (s # ds @ es)", "moreover"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>a ds es.\n       cs = ds @ [a] @ es \\<and> S_reduced_for w (s # ds @ es)", "have \"\\<not> S_reduced (s#cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> S_reduced (s # cs)", "proof (rule not_reduced_word_for)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?bs \\<in> lists S\n 2. sum_list ?bs = sum_list (s # cs)\n 3. order.greater (length (s # cs)) (length ?bs)", "show \"as \\<in> lists S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<in> lists S", "using reduced_word_for_lists[OF assms(1)]"], ["proof (prove)\nusing this:\n  s # as \\<in> lists S\n\ngoal (1 subgoal):\n 1. as \\<in> lists S", "by simp"], ["proof (state)\nthis:\n  as \\<in> lists S\n\ngoal (2 subgoals):\n 1. sum_list as = sum_list (s # cs)\n 2. order.greater (length (s # cs)) (length as)", "from assms(1,2)"], ["proof (chain)\npicking this:\n  S_reduced_for w (s # as)\n  S_reduced_for w cs", "show \"sum_list as = sum_list (s#cs)\""], ["proof (prove)\nusing this:\n  S_reduced_for w (s # as)\n  S_reduced_for w cs\n\ngoal (1 subgoal):\n 1. sum_list as = sum_list (s # cs)", "using s_S reduced_word_for_sum_list[of S w] add.assoc[of s s] genset_order2_add"], ["proof (prove)\nusing this:\n  S_reduced_for w (s # as)\n  S_reduced_for w cs\n  s \\<in> S\n  S_reduced_for w ?as \\<Longrightarrow> sum_list ?as = w\n  s + s + ?c = s + (s + ?c)\n  ?s \\<in> S \\<Longrightarrow> ?s + ?s = (0::'w)\n\ngoal (1 subgoal):\n 1. sum_list as = sum_list (s # cs)", "by    fastforce"], ["proof (state)\nthis:\n  sum_list as = sum_list (s # cs)\n\ngoal (1 subgoal):\n 1. order.greater (length (s # cs)) (length as)", "from assms(1,2)"], ["proof (chain)\npicking this:\n  S_reduced_for w (s # as)\n  S_reduced_for w cs", "show \"length as < length (s#cs)\""], ["proof (prove)\nusing this:\n  S_reduced_for w (s # as)\n  S_reduced_for w cs\n\ngoal (1 subgoal):\n 1. order.greater (length (s # cs)) (length as)", "using reduced_word_for_length[of S w]"], ["proof (prove)\nusing this:\n  S_reduced_for w (s # as)\n  S_reduced_for w cs\n  S_reduced_for w ?as \\<Longrightarrow> length ?as = S_length w\n\ngoal (1 subgoal):\n 1. order.greater (length (s # cs)) (length as)", "by fastforce"], ["proof (state)\nthis:\n  order.greater (length (s # cs)) (length as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> S_reduced (s # cs)\n\ngoal (1 subgoal):\n 1. \\<exists>a ds es.\n       cs = ds @ [a] @ es \\<and> S_reduced_for w (s # ds @ es)", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> S\n  \\<not> S_reduced (s # cs)", "obtain a ds es\n    where \"cs = ds@[a]@es\" \"reduced_word_for S w (s#ds@es)\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  \\<not> S_reduced (s # cs)\n\ngoal (1 subgoal):\n 1. (\\<And>ds a es.\n        \\<lbrakk>cs = ds @ [a] @ es; S_reduced_for w (s # ds @ es)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) exchange[of s w cs]"], ["proof (prove)\nusing this:\n  s \\<in> S\n  \\<not> S_reduced (s # cs)\n  S_reduced_for w cs\n  \\<lbrakk>s \\<in> S; S_reduced_for w cs; \\<not> S_reduced (s # cs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t as bs.\n                       cs = as @ t # bs \\<and> S_reduced_for w (s # as @ bs)\n\ngoal (1 subgoal):\n 1. (\\<And>ds a es.\n        \\<lbrakk>cs = ds @ [a] @ es; S_reduced_for w (s # ds @ es)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  cs = ds @ [a] @ es\n  S_reduced_for w (s # ds @ es)\n\ngoal (1 subgoal):\n 1. \\<exists>a ds es.\n       cs = ds @ [a] @ es \\<and> S_reduced_for w (s # ds @ es)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs = ds @ [a] @ es\n  S_reduced_for w (s # ds @ es)\n\ngoal (1 subgoal):\n 1. \\<exists>a ds es.\n       cs = ds @ [a] @ es \\<and> S_reduced_for w (s # ds @ es)", "by fast"], ["proof (state)\nthis:\n  \\<exists>a ds es. cs = ds @ [a] @ es \\<and> S_reduced_for w (s # ds @ es)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context PreCoxeterSystemWithDeletion *)"], ["", "subsubsection \\<open>More on words in generators containing alternating subwords\\<close>"], ["", "text \\<open>\n  Here we explore more of the mechanics of manipulating words over @{term S} that contain\n  alternating subwords, in preparation of the word problem.\n\\<close>"], ["", "context PreCoxeterSystemWithDeletion\nbegin"], ["", "lemma two_reduced_heads_imp_reduced_alt_step:\n  assumes \"s\\<noteq>t\" \"reduced_word_for S w (t#bs)\" \"n < relfun s t \\<or> relfun s t = 0\"\n          \"reduced_word_for S w (alternating_list n s t @ cs)\"\n  shows   \"\\<exists>ds. reduced_word_for S w (alternating_list (Suc n) t s @ ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "define altnst where \"altnst = alternating_list n s t\""], ["proof (state)\nthis:\n  altnst = alternating_list n s t\n\ngoal (1 subgoal):\n 1. \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "with assms(2,4)"], ["proof (chain)\npicking this:\n  S_reduced_for w (t # bs)\n  S_reduced_for w (alternating_list n s t @ cs)\n  altnst = alternating_list n s t", "obtain x xs ys \n    where xxsys: \"altnst @ cs = xs@[x]@ys\" \"reduced_word_for S w (t#xs@ys)\""], ["proof (prove)\nusing this:\n  S_reduced_for w (t # bs)\n  S_reduced_for w (alternating_list n s t @ cs)\n  altnst = alternating_list n s t\n\ngoal (1 subgoal):\n 1. (\\<And>xs x ys.\n        \\<lbrakk>altnst @ cs = xs @ [x] @ ys;\n         S_reduced_for w (t # xs @ ys)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using reduced_head_imp_exchange"], ["proof (prove)\nusing this:\n  S_reduced_for w (t # bs)\n  S_reduced_for w (alternating_list n s t @ cs)\n  altnst = alternating_list n s t\n  \\<lbrakk>S_reduced_for ?w (?s # ?as); S_reduced_for ?w ?cs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a ds es.\n                       ?cs = ds @ [a] @ es \\<and>\n                       S_reduced_for ?w (?s # ds @ es)\n\ngoal (1 subgoal):\n 1. (\\<And>xs x ys.\n        \\<lbrakk>altnst @ cs = xs @ [x] @ ys;\n         S_reduced_for w (t # xs @ ys)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  altnst @ cs = xs @ [x] @ ys\n  S_reduced_for w (t # xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "proof (cases n rule: nat_cases_2Suc)"], ["proof (state)\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)\n 2. n = 1 \\<Longrightarrow>\n    \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)\n 3. \\<And>m.\n       n = Suc (Suc m) \\<Longrightarrow>\n       \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (3 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)\n 2. n = 1 \\<Longrightarrow>\n    \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)\n 3. \\<And>m.\n       n = Suc (Suc m) \\<Longrightarrow>\n       \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "with xxsys(2)"], ["proof (chain)\npicking this:\n  S_reduced_for w (t # xs @ ys)\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  S_reduced_for w (t # xs @ ys)\n  n = 0\n\ngoal (1 subgoal):\n 1. \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "by auto"], ["proof (state)\nthis:\n  \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)\n 2. \\<And>m.\n       n = Suc (Suc m) \\<Longrightarrow>\n       \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)\n 2. \\<And>m.\n       n = Suc (Suc m) \\<Longrightarrow>\n       \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "case 1"], ["proof (state)\nthis:\n  n = 1\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)\n 2. \\<And>m.\n       n = Suc (Suc m) \\<Longrightarrow>\n       \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "with assms(1,4) xxsys altnst_def"], ["proof (chain)\npicking this:\n  s \\<noteq> t\n  S_reduced_for w (alternating_list n s t @ cs)\n  altnst @ cs = xs @ [x] @ ys\n  S_reduced_for w (t # xs @ ys)\n  altnst = alternating_list n s t\n  n = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<noteq> t\n  S_reduced_for w (alternating_list n s t @ cs)\n  altnst @ cs = xs @ [x] @ ys\n  S_reduced_for w (t # xs @ ys)\n  altnst = alternating_list n s t\n  n = 1\n\ngoal (1 subgoal):\n 1. \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "using reduced_word_for_sum_list[of S w \"s#cs\"]\n            reduced_word_for_sum_list[of S w \"t#cs\"]"], ["proof (prove)\nusing this:\n  s \\<noteq> t\n  S_reduced_for w (alternating_list n s t @ cs)\n  altnst @ cs = xs @ [x] @ ys\n  S_reduced_for w (t # xs @ ys)\n  altnst = alternating_list n s t\n  n = 1\n  S_reduced_for w (s # cs) \\<Longrightarrow> sum_list (s # cs) = w\n  S_reduced_for w (t # cs) \\<Longrightarrow> sum_list (t # cs) = w\n\ngoal (1 subgoal):\n 1. \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "by    (cases xs) auto"], ["proof (state)\nthis:\n  \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       n = Suc (Suc m) \\<Longrightarrow>\n       \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       n = Suc (Suc m) \\<Longrightarrow>\n       \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "case (SucSuc k)"], ["proof (state)\nthis:\n  n = Suc (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       n = Suc (Suc m) \\<Longrightarrow>\n       \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "with assms(3,4) xxsys altnst_def"], ["proof (chain)\npicking this:\n  order.greater (add_order (s + t)) n \\<or> add_order (s + t) = 0\n  S_reduced_for w (alternating_list n s t @ cs)\n  altnst @ cs = xs @ [x] @ ys\n  S_reduced_for w (t # xs @ ys)\n  altnst = alternating_list n s t\n  n = Suc (Suc k)", "have \"length xs \\<ge> n\""], ["proof (prove)\nusing this:\n  order.greater (add_order (s + t)) n \\<or> add_order (s + t) = 0\n  S_reduced_for w (alternating_list n s t @ cs)\n  altnst @ cs = xs @ [x] @ ys\n  S_reduced_for w (t # xs @ ys)\n  altnst = alternating_list n s t\n  n = Suc (Suc k)\n\ngoal (1 subgoal):\n 1. order.greater_eq (length xs) n", "using exchange_alternating_not_in_alternating"], ["proof (prove)\nusing this:\n  order.greater (add_order (s + t)) n \\<or> add_order (s + t) = 0\n  S_reduced_for w (alternating_list n s t @ cs)\n  altnst @ cs = xs @ [x] @ ys\n  S_reduced_for w (t # xs @ ys)\n  altnst = alternating_list n s t\n  n = Suc (Suc k)\n  \\<lbrakk>order.greater_eq ?n 2;\n   order.greater (add_order (?s + ?t)) ?n \\<or> add_order (?s + ?t) = 0;\n   S_reduced_for ?w (alternating_list ?n ?s ?t @ ?cs);\n   alternating_list ?n ?s ?t @ ?cs = ?xs @ [?x] @ ?ys;\n   S_reduced_for ?w (?t # ?xs @ ?ys)\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length ?xs) ?n\n\ngoal (1 subgoal):\n 1. order.greater_eq (length xs) n", "by simp"], ["proof (state)\nthis:\n  order.greater_eq (length xs) n\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       n = Suc (Suc m) \\<Longrightarrow>\n       \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "moreover"], ["proof (state)\nthis:\n  order.greater_eq (length xs) n\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       n = Suc (Suc m) \\<Longrightarrow>\n       \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "define ds where \"ds = take (length xs - n) cs\""], ["proof (state)\nthis:\n  ds = take (length xs - n) cs\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       n = Suc (Suc m) \\<Longrightarrow>\n       \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "ultimately"], ["proof (chain)\npicking this:\n  order.greater_eq (length xs) n\n  ds = take (length xs - n) cs", "have \"t#xs@ys = alternating_list (Suc n) t s @ ds @ ys\""], ["proof (prove)\nusing this:\n  order.greater_eq (length xs) n\n  ds = take (length xs - n) cs\n\ngoal (1 subgoal):\n 1. t # xs @ ys = alternating_list (Suc n) t s @ ds @ ys", "using xxsys(1) altnst_def take_append[of \"length xs\" altnst cs]\n            alternating_list_Suc_Cons[of n t]"], ["proof (prove)\nusing this:\n  order.greater_eq (length xs) n\n  ds = take (length xs - n) cs\n  altnst @ cs = xs @ [x] @ ys\n  altnst = alternating_list n s t\n  take (length xs) (altnst @ cs) =\n  take (length xs) altnst @ take (length xs - length altnst) cs\n  alternating_list (Suc n) t ?t = t # alternating_list n ?t t\n\ngoal (1 subgoal):\n 1. t # xs @ ys = alternating_list (Suc n) t s @ ds @ ys", "by    (fastforce simp add: length_alternating_list)"], ["proof (state)\nthis:\n  t # xs @ ys = alternating_list (Suc n) t s @ ds @ ys\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       n = Suc (Suc m) \\<Longrightarrow>\n       \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "with xxsys(2)"], ["proof (chain)\npicking this:\n  S_reduced_for w (t # xs @ ys)\n  t # xs @ ys = alternating_list (Suc n) t s @ ds @ ys", "show ?thesis"], ["proof (prove)\nusing this:\n  S_reduced_for w (t # xs @ ys)\n  t # xs @ ys = alternating_list (Suc n) t s @ ds @ ys\n\ngoal (1 subgoal):\n 1. \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)", "by auto"], ["proof (state)\nthis:\n  \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ds. S_reduced_for w (alternating_list (Suc n) t s @ ds)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma two_reduced_heads_imp_reduced_alt':\n  assumes \"s\\<noteq>t\" \"reduced_word_for S w (s#as)\" \"reduced_word_for S w (t#bs)\"\n  shows \"n \\<le> relfun s t \\<or> relfun s t = 0 \\<Longrightarrow> (\\<exists>cs.\n          reduced_word_for S w (alternating_list n s t @ cs) \\<or>\n          reduced_word_for S w (alternating_list n t s @ cs)\n        )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (add_order (s + t)) n \\<or>\n    add_order (s + t) = 0 \\<Longrightarrow>\n    \\<exists>cs.\n       S_reduced_for w (alternating_list n s t @ cs) \\<or>\n       S_reduced_for w (alternating_list n t s @ cs)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq (add_order (s + t)) 0 \\<or>\n    add_order (s + t) = 0 \\<Longrightarrow>\n    \\<exists>cs.\n       S_reduced_for w (alternating_list 0 s t @ cs) \\<or>\n       S_reduced_for w (alternating_list 0 t s @ cs)\n 2. \\<And>n.\n       \\<lbrakk>order.greater_eq (add_order (s + t)) n \\<or>\n                add_order (s + t) = 0 \\<Longrightarrow>\n                \\<exists>cs.\n                   S_reduced_for w (alternating_list n s t @ cs) \\<or>\n                   S_reduced_for w (alternating_list n t s @ cs);\n        order.greater_eq (add_order (s + t)) (Suc n) \\<or>\n        add_order (s + t) = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs.\n                            S_reduced_for w\n                             (alternating_list (Suc n) s t @ cs) \\<or>\n                            S_reduced_for w\n                             (alternating_list (Suc n) t s @ cs)", "case 0"], ["proof (state)\nthis:\n  order.greater_eq (add_order (s + t)) 0 \\<or> add_order (s + t) = 0\n\ngoal (2 subgoals):\n 1. order.greater_eq (add_order (s + t)) 0 \\<or>\n    add_order (s + t) = 0 \\<Longrightarrow>\n    \\<exists>cs.\n       S_reduced_for w (alternating_list 0 s t @ cs) \\<or>\n       S_reduced_for w (alternating_list 0 t s @ cs)\n 2. \\<And>n.\n       \\<lbrakk>order.greater_eq (add_order (s + t)) n \\<or>\n                add_order (s + t) = 0 \\<Longrightarrow>\n                \\<exists>cs.\n                   S_reduced_for w (alternating_list n s t @ cs) \\<or>\n                   S_reduced_for w (alternating_list n t s @ cs);\n        order.greater_eq (add_order (s + t)) (Suc n) \\<or>\n        add_order (s + t) = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs.\n                            S_reduced_for w\n                             (alternating_list (Suc n) s t @ cs) \\<or>\n                            S_reduced_for w\n                             (alternating_list (Suc n) t s @ cs)", "from assms(2)"], ["proof (chain)\npicking this:\n  S_reduced_for w (s # as)", "show ?case"], ["proof (prove)\nusing this:\n  S_reduced_for w (s # as)\n\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       S_reduced_for w (alternating_list 0 s t @ cs) \\<or>\n       S_reduced_for w (alternating_list 0 t s @ cs)", "by auto"], ["proof (state)\nthis:\n  \\<exists>cs.\n     S_reduced_for w (alternating_list 0 s t @ cs) \\<or>\n     S_reduced_for w (alternating_list 0 t s @ cs)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>order.greater_eq (add_order (s + t)) n \\<or>\n                add_order (s + t) = 0 \\<Longrightarrow>\n                \\<exists>cs.\n                   S_reduced_for w (alternating_list n s t @ cs) \\<or>\n                   S_reduced_for w (alternating_list n t s @ cs);\n        order.greater_eq (add_order (s + t)) (Suc n) \\<or>\n        add_order (s + t) = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs.\n                            S_reduced_for w\n                             (alternating_list (Suc n) s t @ cs) \\<or>\n                            S_reduced_for w\n                             (alternating_list (Suc n) t s @ cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>order.greater_eq (add_order (s + t)) n \\<or>\n                add_order (s + t) = 0 \\<Longrightarrow>\n                \\<exists>cs.\n                   S_reduced_for w (alternating_list n s t @ cs) \\<or>\n                   S_reduced_for w (alternating_list n t s @ cs);\n        order.greater_eq (add_order (s + t)) (Suc n) \\<or>\n        add_order (s + t) = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs.\n                            S_reduced_for w\n                             (alternating_list (Suc n) s t @ cs) \\<or>\n                            S_reduced_for w\n                             (alternating_list (Suc n) t s @ cs)", "case (Suc m)"], ["proof (state)\nthis:\n  order.greater_eq (add_order (s + t)) m \\<or>\n  add_order (s + t) = 0 \\<Longrightarrow>\n  \\<exists>cs.\n     S_reduced_for w (alternating_list m s t @ cs) \\<or>\n     S_reduced_for w (alternating_list m t s @ cs)\n  order.greater_eq (add_order (s + t)) (Suc m) \\<or> add_order (s + t) = 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>order.greater_eq (add_order (s + t)) n \\<or>\n                add_order (s + t) = 0 \\<Longrightarrow>\n                \\<exists>cs.\n                   S_reduced_for w (alternating_list n s t @ cs) \\<or>\n                   S_reduced_for w (alternating_list n t s @ cs);\n        order.greater_eq (add_order (s + t)) (Suc n) \\<or>\n        add_order (s + t) = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs.\n                            S_reduced_for w\n                             (alternating_list (Suc n) s t @ cs) \\<or>\n                            S_reduced_for w\n                             (alternating_list (Suc n) t s @ cs)", "thus ?case"], ["proof (prove)\nusing this:\n  order.greater_eq (add_order (s + t)) m \\<or>\n  add_order (s + t) = 0 \\<Longrightarrow>\n  \\<exists>cs.\n     S_reduced_for w (alternating_list m s t @ cs) \\<or>\n     S_reduced_for w (alternating_list m t s @ cs)\n  order.greater_eq (add_order (s + t)) (Suc m) \\<or> add_order (s + t) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       S_reduced_for w (alternating_list (Suc m) s t @ cs) \\<or>\n       S_reduced_for w (alternating_list (Suc m) t s @ cs)", "using add_order_add_sym[of s t]\n          two_reduced_heads_imp_reduced_alt_step[\n            OF assms(1)[THEN not_sym] assms(2), of m\n          ]\n          two_reduced_heads_imp_reduced_alt_step[OF assms(1,3), of m]"], ["proof (prove)\nusing this:\n  order.greater_eq (add_order (s + t)) m \\<or>\n  add_order (s + t) = 0 \\<Longrightarrow>\n  \\<exists>cs.\n     S_reduced_for w (alternating_list m s t @ cs) \\<or>\n     S_reduced_for w (alternating_list m t s @ cs)\n  order.greater_eq (add_order (s + t)) (Suc m) \\<or> add_order (s + t) = 0\n  add_order (s + t) = add_order (t + s)\n  \\<lbrakk>order.greater (add_order (t + s)) m \\<or> add_order (t + s) = 0;\n   S_reduced_for w (alternating_list m t s @ ?cs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds.\n                       S_reduced_for w (alternating_list (Suc m) s t @ ds)\n  \\<lbrakk>order.greater (add_order (s + t)) m \\<or> add_order (s + t) = 0;\n   S_reduced_for w (alternating_list m s t @ ?cs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ds.\n                       S_reduced_for w (alternating_list (Suc m) t s @ ds)\n\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       S_reduced_for w (alternating_list (Suc m) s t @ cs) \\<or>\n       S_reduced_for w (alternating_list (Suc m) t s @ cs)", "by    fastforce"], ["proof (state)\nthis:\n  \\<exists>cs.\n     S_reduced_for w (alternating_list (Suc m) s t @ cs) \\<or>\n     S_reduced_for w (alternating_list (Suc m) t s @ cs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma two_reduced_heads_imp_reduced_alt:\n  assumes \"s\\<noteq>t\" \"reduced_word_for S w (s#as)\" \"reduced_word_for S w (t#bs)\"\n  shows \"\\<exists>cs. reduced_word_for S w (pair_relator_halflist s t @ cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cs. S_reduced_for w (pair_relator_halflist s t @ cs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cs. S_reduced_for w (pair_relator_halflist s t @ cs)", "define altst altts\n    where \"altst = pair_relator_halflist s t\"\n      and \"altts = pair_relator_halflist t s\""], ["proof (state)\nthis:\n  altst = pair_relator_halflist s t\n  altts = pair_relator_halflist t s\n\ngoal (1 subgoal):\n 1. \\<exists>cs. S_reduced_for w (pair_relator_halflist s t @ cs)", "then"], ["proof (chain)\npicking this:\n  altst = pair_relator_halflist s t\n  altts = pair_relator_halflist t s", "obtain cs\n    where cs: \"reduced_word_for S w (altst @ cs) \\<or>\n                reduced_word_for S w (altts @ cs)\""], ["proof (prove)\nusing this:\n  altst = pair_relator_halflist s t\n  altts = pair_relator_halflist t s\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        S_reduced_for w (altst @ cs) \\<or>\n        S_reduced_for w (altts @ cs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using add_order_add_sym[of t] two_reduced_heads_imp_reduced_alt'[OF assms]"], ["proof (prove)\nusing this:\n  altst = pair_relator_halflist s t\n  altts = pair_relator_halflist t s\n  add_order (t + ?s) = add_order (?s + t)\n  order.greater_eq (add_order (s + t)) ?n \\<or>\n  add_order (s + t) = 0 \\<Longrightarrow>\n  \\<exists>cs.\n     S_reduced_for w (alternating_list ?n s t @ cs) \\<or>\n     S_reduced_for w (alternating_list ?n t s @ cs)\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        S_reduced_for w (altst @ cs) \\<or>\n        S_reduced_for w (altts @ cs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  S_reduced_for w (altst @ cs) \\<or> S_reduced_for w (altts @ cs)\n\ngoal (1 subgoal):\n 1. \\<exists>cs. S_reduced_for w (pair_relator_halflist s t @ cs)", "moreover"], ["proof (state)\nthis:\n  S_reduced_for w (altst @ cs) \\<or> S_reduced_for w (altts @ cs)\n\ngoal (1 subgoal):\n 1. \\<exists>cs. S_reduced_for w (pair_relator_halflist s t @ cs)", "from altst_def altts_def"], ["proof (chain)\npicking this:\n  altst = pair_relator_halflist s t\n  altts = pair_relator_halflist t s", "have  \"reduced_word_for S w (altts @ cs) \\<Longrightarrow> reduced_word_for S w (altst @ cs)\""], ["proof (prove)\nusing this:\n  altst = pair_relator_halflist s t\n  altts = pair_relator_halflist t s\n\ngoal (1 subgoal):\n 1. S_reduced_for w (altts @ cs) \\<Longrightarrow>\n    S_reduced_for w (altst @ cs)", "using reduced_word_for_lists[OF assms(2)] reduced_word_for_lists[OF assms(3)]\n          flip_altsublist_adjacent_def"], ["proof (prove)\nusing this:\n  altst = pair_relator_halflist s t\n  altts = pair_relator_halflist t s\n  s # as \\<in> lists S\n  t # bs \\<in> lists S\n  flip_altsublist_adjacent ?ss ?ts \\<equiv>\n  \\<exists>s t as bs.\n     ?ss = as @ pair_relator_halflist s t @ bs \\<and>\n     ?ts = as @ pair_relator_halflist t s @ bs\n\ngoal (1 subgoal):\n 1. S_reduced_for w (altts @ cs) \\<Longrightarrow>\n    S_reduced_for w (altst @ cs)", "by (force intro: S_reduced_forI_flip_altsublist_adjacent\n        simp add: add_order_add_sym)"], ["proof (state)\nthis:\n  S_reduced_for w (altts @ cs) \\<Longrightarrow>\n  S_reduced_for w (altst @ cs)\n\ngoal (1 subgoal):\n 1. \\<exists>cs. S_reduced_for w (pair_relator_halflist s t @ cs)", "ultimately"], ["proof (chain)\npicking this:\n  S_reduced_for w (altst @ cs) \\<or> S_reduced_for w (altts @ cs)\n  S_reduced_for w (altts @ cs) \\<Longrightarrow>\n  S_reduced_for w (altst @ cs)", "show \"\\<exists>cs. reduced_word_for S w (altst @ cs)\""], ["proof (prove)\nusing this:\n  S_reduced_for w (altst @ cs) \\<or> S_reduced_for w (altts @ cs)\n  S_reduced_for w (altts @ cs) \\<Longrightarrow>\n  S_reduced_for w (altst @ cs)\n\ngoal (1 subgoal):\n 1. \\<exists>cs. S_reduced_for w (altst @ cs)", "by fast"], ["proof (state)\nthis:\n  \\<exists>cs. S_reduced_for w (altst @ cs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma two_reduced_heads_imp_nzero_relfun:\n  assumes \"s\\<noteq>t\" \"reduced_word_for S w (s#as)\" \"reduced_word_for S w (t#bs)\"\n  shows   \"relfun s t \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_order (s + t) \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. add_order (s + t) = 0 \\<Longrightarrow> False", "assume 1: \"relfun s t = 0\""], ["proof (state)\nthis:\n  add_order (s + t) = 0\n\ngoal (1 subgoal):\n 1. add_order (s + t) = 0 \\<Longrightarrow> False", "define altst altts\n    where \"altst = alternating_list (Suc (S_length w)) s t\"\n      and \"altts = alternating_list (Suc (S_length w)) t s\""], ["proof (state)\nthis:\n  altst = alternating_list (Suc (S_length w)) s t\n  altts = alternating_list (Suc (S_length w)) t s\n\ngoal (1 subgoal):\n 1. add_order (s + t) = 0 \\<Longrightarrow> False", "with 1"], ["proof (chain)\npicking this:\n  add_order (s + t) = 0\n  altst = alternating_list (Suc (S_length w)) s t\n  altts = alternating_list (Suc (S_length w)) t s", "obtain cs\n    where \"reduced_word_for S w (altst @ cs) \\<or>\n            reduced_word_for S w (altts @ cs)\""], ["proof (prove)\nusing this:\n  add_order (s + t) = 0\n  altst = alternating_list (Suc (S_length w)) s t\n  altts = alternating_list (Suc (S_length w)) t s\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        S_reduced_for w (altst @ cs) \\<or>\n        S_reduced_for w (altts @ cs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using two_reduced_heads_imp_reduced_alt'[OF assms]"], ["proof (prove)\nusing this:\n  add_order (s + t) = 0\n  altst = alternating_list (Suc (S_length w)) s t\n  altts = alternating_list (Suc (S_length w)) t s\n  order.greater_eq (add_order (s + t)) ?n \\<or>\n  add_order (s + t) = 0 \\<Longrightarrow>\n  \\<exists>cs.\n     S_reduced_for w (alternating_list ?n s t @ cs) \\<or>\n     S_reduced_for w (alternating_list ?n t s @ cs)\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        S_reduced_for w (altst @ cs) \\<or>\n        S_reduced_for w (altts @ cs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  S_reduced_for w (altst @ cs) \\<or> S_reduced_for w (altts @ cs)\n\ngoal (1 subgoal):\n 1. add_order (s + t) = 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  S_reduced_for w (altst @ cs) \\<or> S_reduced_for w (altts @ cs)\n\ngoal (1 subgoal):\n 1. add_order (s + t) = 0 \\<Longrightarrow> False", "from altst_def altts_def"], ["proof (chain)\npicking this:\n  altst = alternating_list (Suc (S_length w)) s t\n  altts = alternating_list (Suc (S_length w)) t s", "have  \"length (altst @ cs) > S_length w\"\n          \"length (altts @ cs) > S_length w\""], ["proof (prove)\nusing this:\n  altst = alternating_list (Suc (S_length w)) s t\n  altts = alternating_list (Suc (S_length w)) t s\n\ngoal (1 subgoal):\n 1. order.greater (length (altst @ cs)) (S_length w) &&&\n    order.greater (length (altts @ cs)) (S_length w)", "using length_alternating_list[of _ s] length_alternating_list[of _ t]"], ["proof (prove)\nusing this:\n  altst = alternating_list (Suc (S_length w)) s t\n  altts = alternating_list (Suc (S_length w)) t s\n  length (alternating_list ?n s ?t) = ?n\n  length (alternating_list ?n t ?t) = ?n\n\ngoal (1 subgoal):\n 1. order.greater (length (altst @ cs)) (S_length w) &&&\n    order.greater (length (altts @ cs)) (S_length w)", "by    auto"], ["proof (state)\nthis:\n  order.greater (length (altst @ cs)) (S_length w)\n  order.greater (length (altts @ cs)) (S_length w)\n\ngoal (1 subgoal):\n 1. add_order (s + t) = 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  S_reduced_for w (altst @ cs) \\<or> S_reduced_for w (altts @ cs)\n  order.greater (length (altst @ cs)) (S_length w)\n  order.greater (length (altts @ cs)) (S_length w)", "show False"], ["proof (prove)\nusing this:\n  S_reduced_for w (altst @ cs) \\<or> S_reduced_for w (altts @ cs)\n  order.greater (length (altst @ cs)) (S_length w)\n  order.greater (length (altts @ cs)) (S_length w)\n\ngoal (1 subgoal):\n 1. False", "using reduced_word_for_length"], ["proof (prove)\nusing this:\n  S_reduced_for w (altst @ cs) \\<or> S_reduced_for w (altts @ cs)\n  order.greater (length (altst @ cs)) (S_length w)\n  order.greater (length (altts @ cs)) (S_length w)\n  reduced_word_for ?A ?a ?as \\<Longrightarrow>\n  length ?as = word_length ?A ?a\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context PreCoxeterSystemWithDeletion *)"], ["", "subsubsection \\<open>The word problem\\<close>"], ["", "text \\<open>Here we establish the other direction of the word problem for reduced words.\\<close>"], ["", "context PreCoxeterSystemWithDeletion\nbegin"], ["", "lemma reduced_word_problem_ConsCons_step:\n  assumes \"\\<And>y ss ts. \\<lbrakk> S_length y < S_length w; y\\<noteq>0; reduced_word_for S y ss;\n            reduced_word_for S y ts \\<rbrakk> \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])\"\n          \"reduced_word_for S w (a#as)\" \"reduced_word_for S w (b#bs)\" \"a\\<noteq>b\"\n  shows   \"\\<exists>xss. flip_altsublist_chain ((a#as)#xss@[b#bs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "from assms(2-4)"], ["proof (chain)\npicking this:\n  S_reduced_for w (a # as)\n  S_reduced_for w (b # bs)\n  a \\<noteq> b", "obtain cs\n    where cs: \"reduced_word_for S w (pair_relator_halflist a b @ cs)\""], ["proof (prove)\nusing this:\n  S_reduced_for w (a # as)\n  S_reduced_for w (b # bs)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        S_reduced_for w (pair_relator_halflist a b @ cs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using two_reduced_heads_imp_reduced_alt"], ["proof (prove)\nusing this:\n  S_reduced_for w (a # as)\n  S_reduced_for w (b # bs)\n  a \\<noteq> b\n  \\<lbrakk>?s \\<noteq> ?t; S_reduced_for ?w (?s # ?as);\n   S_reduced_for ?w (?t # ?bs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs.\n                       S_reduced_for ?w (pair_relator_halflist ?s ?t @ cs)\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        S_reduced_for w (pair_relator_halflist a b @ cs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  S_reduced_for w (pair_relator_halflist a b @ cs)\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "define rs us where \"rs = pair_relator_halflist a b @ cs\"\n    and \"us = pair_relator_halflist b a @ cs\""], ["proof (state)\nthis:\n  rs = pair_relator_halflist a b @ cs\n  us = pair_relator_halflist b a @ cs\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "from assms(2,3)"], ["proof (chain)\npicking this:\n  S_reduced_for w (a # as)\n  S_reduced_for w (b # bs)", "have a_S: \"a\\<in>S\" and b_S: \"b\\<in>S\""], ["proof (prove)\nusing this:\n  S_reduced_for w (a # as)\n  S_reduced_for w (b # bs)\n\ngoal (1 subgoal):\n 1. a \\<in> S &&& b \\<in> S", "using reduced_word_for_lists[of S _ \"a#as\"] reduced_word_for_lists[of S _ \"b#bs\"]"], ["proof (prove)\nusing this:\n  S_reduced_for w (a # as)\n  S_reduced_for w (b # bs)\n  S_reduced_for ?a (a # as) \\<Longrightarrow> a # as \\<in> lists S\n  S_reduced_for ?a (b # bs) \\<Longrightarrow> b # bs \\<in> lists S\n\ngoal (1 subgoal):\n 1. a \\<in> S &&& b \\<in> S", "by    auto"], ["proof (state)\nthis:\n  a \\<in> S\n  b \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "with rs_def us_def"], ["proof (chain)\npicking this:\n  rs = pair_relator_halflist a b @ cs\n  us = pair_relator_halflist b a @ cs\n  a \\<in> S\n  b \\<in> S", "have midlink: \"flip_altsublist_adjacent rs us\""], ["proof (prove)\nusing this:\n  rs = pair_relator_halflist a b @ cs\n  us = pair_relator_halflist b a @ cs\n  a \\<in> S\n  b \\<in> S\n\ngoal (1 subgoal):\n 1. flip_altsublist_adjacent rs us", "using add_order_add_sym[of b a] flip_altsublist_adjacent_def"], ["proof (prove)\nusing this:\n  rs = pair_relator_halflist a b @ cs\n  us = pair_relator_halflist b a @ cs\n  a \\<in> S\n  b \\<in> S\n  add_order (b + a) = add_order (a + b)\n  flip_altsublist_adjacent ?ss ?ts \\<equiv>\n  \\<exists>s t as bs.\n     ?ss = as @ pair_relator_halflist s t @ bs \\<and>\n     ?ts = as @ pair_relator_halflist t s @ bs\n\ngoal (1 subgoal):\n 1. flip_altsublist_adjacent rs us", "by fastforce"], ["proof (state)\nthis:\n  flip_altsublist_adjacent rs us\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "from assms(2-4)"], ["proof (chain)\npicking this:\n  S_reduced_for w (a # as)\n  S_reduced_for w (b # bs)\n  a \\<noteq> b", "have \"relfun a b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  S_reduced_for w (a # as)\n  S_reduced_for w (b # bs)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. add_order (a + b) \\<noteq> 0", "using two_reduced_heads_imp_nzero_relfun"], ["proof (prove)\nusing this:\n  S_reduced_for w (a # as)\n  S_reduced_for w (b # bs)\n  a \\<noteq> b\n  \\<lbrakk>?s \\<noteq> ?t; S_reduced_for ?w (?s # ?as);\n   S_reduced_for ?w (?t # ?bs)\\<rbrakk>\n  \\<Longrightarrow> add_order (?s + ?t) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. add_order (a + b) \\<noteq> 0", "by fast"], ["proof (state)\nthis:\n  add_order (a + b) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "from this"], ["proof (chain)\npicking this:\n  add_order (a + b) \\<noteq> 0", "obtain k where k: \"relfun a b = Suc k\""], ["proof (prove)\nusing this:\n  add_order (a + b) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        add_order (a + b) = Suc k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using not0_implies_Suc"], ["proof (prove)\nusing this:\n  add_order (a + b) \\<noteq> 0\n  ?n \\<noteq> 0 \\<Longrightarrow> \\<exists>m. ?n = Suc m\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        add_order (a + b) = Suc k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  add_order (a + b) = Suc k\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "define qs vs\n    where \"qs = alternating_list k b a @ cs\"\n      and \"vs = alternating_list k a b @ cs\""], ["proof (state)\nthis:\n  qs = alternating_list k b a @ cs\n  vs = alternating_list k a b @ cs\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "with k rs_def us_def"], ["proof (chain)\npicking this:\n  add_order (a + b) = Suc k\n  rs = pair_relator_halflist a b @ cs\n  us = pair_relator_halflist b a @ cs\n  qs = alternating_list k b a @ cs\n  vs = alternating_list k a b @ cs", "have rs': \"rs = a # qs\" and us': \"us = b # vs\""], ["proof (prove)\nusing this:\n  add_order (a + b) = Suc k\n  rs = pair_relator_halflist a b @ cs\n  us = pair_relator_halflist b a @ cs\n  qs = alternating_list k b a @ cs\n  vs = alternating_list k a b @ cs\n\ngoal (1 subgoal):\n 1. rs = a # qs &&& us = b # vs", "using add_order_add_sym[of b a] alternating_list_Suc_Cons[of k]"], ["proof (prove)\nusing this:\n  add_order (a + b) = Suc k\n  rs = pair_relator_halflist a b @ cs\n  us = pair_relator_halflist b a @ cs\n  qs = alternating_list k b a @ cs\n  vs = alternating_list k a b @ cs\n  add_order (b + a) = add_order (a + b)\n  alternating_list (Suc k) ?s ?t = ?s # alternating_list k ?t ?s\n\ngoal (1 subgoal):\n 1. rs = a # qs &&& us = b # vs", "by auto"], ["proof (state)\nthis:\n  rs = a # qs\n  us = b # vs\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "from assms(1,2) cs rs_def rs'"], ["proof (chain)\npicking this:\n  \\<lbrakk>order.greater (S_length w) (S_length ?y); ?y \\<noteq> (0::'w);\n   S_reduced_for ?y ?ss; S_reduced_for ?y ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n  S_reduced_for w (a # as)\n  S_reduced_for w (pair_relator_halflist a b @ cs)\n  rs = pair_relator_halflist a b @ cs\n  rs = a # qs", "have  startlink: \"as \\<noteq> qs \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain ((a#as) # xss @ [rs])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater (S_length w) (S_length ?y); ?y \\<noteq> (0::'w);\n   S_reduced_for ?y ?ss; S_reduced_for ?y ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n  S_reduced_for w (a # as)\n  S_reduced_for w (pair_relator_halflist a b @ cs)\n  rs = pair_relator_halflist a b @ cs\n  rs = a # qs\n\ngoal (1 subgoal):\n 1. as \\<noteq> qs \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [rs])", "using reduced_word_problem_eq_hd_step"], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater (S_length w) (S_length ?y); ?y \\<noteq> (0::'w);\n   S_reduced_for ?y ?ss; S_reduced_for ?y ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n  S_reduced_for w (a # as)\n  S_reduced_for w (pair_relator_halflist a b @ cs)\n  rs = pair_relator_halflist a b @ cs\n  rs = a # qs\n  \\<lbrakk>\\<And>y ss ts.\n              \\<lbrakk>order.greater (S_length ?w) (S_length y);\n               y \\<noteq> (0::'w); S_reduced_for y ss;\n               S_reduced_for y ts\\<rbrakk>\n              \\<Longrightarrow> \\<exists>xss.\n                                   flip_altsublist_chain (ss # xss @ [ts]);\n   S_reduced_for ?w (?a # ?ss); S_reduced_for ?w (?a # ?ts)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss.\n                       flip_altsublist_chain ((?a # ?ss) # xss @ [?a # ?ts])\n\ngoal (1 subgoal):\n 1. as \\<noteq> qs \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [rs])", "by    fastforce"], ["proof (state)\nthis:\n  as \\<noteq> qs \\<Longrightarrow>\n  \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [rs])\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "from assms(1,3) rs_def cs us'"], ["proof (chain)\npicking this:\n  \\<lbrakk>order.greater (S_length w) (S_length ?y); ?y \\<noteq> (0::'w);\n   S_reduced_for ?y ?ss; S_reduced_for ?y ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n  S_reduced_for w (b # bs)\n  rs = pair_relator_halflist a b @ cs\n  S_reduced_for w (pair_relator_halflist a b @ cs)\n  us = b # vs", "have  endlink: \"bs \\<noteq> vs \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (us # xss @ [b#bs])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater (S_length w) (S_length ?y); ?y \\<noteq> (0::'w);\n   S_reduced_for ?y ?ss; S_reduced_for ?y ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n  S_reduced_for w (b # bs)\n  rs = pair_relator_halflist a b @ cs\n  S_reduced_for w (pair_relator_halflist a b @ cs)\n  us = b # vs\n\ngoal (1 subgoal):\n 1. bs \\<noteq> vs \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain (us # xss @ [b # bs])", "using midlink flip_altsublist_adjacent_sym\n          S_reduced_forI_flip_altsublist_adjacent[of w rs]\n          reduced_word_problem_eq_hd_step[of w]"], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater (S_length w) (S_length ?y); ?y \\<noteq> (0::'w);\n   S_reduced_for ?y ?ss; S_reduced_for ?y ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n  S_reduced_for w (b # bs)\n  rs = pair_relator_halflist a b @ cs\n  S_reduced_for w (pair_relator_halflist a b @ cs)\n  us = b # vs\n  flip_altsublist_adjacent rs us\n  flip_altsublist_adjacent ?ss ?ts \\<Longrightarrow>\n  flip_altsublist_adjacent ?ts ?ss\n  \\<lbrakk>S_reduced_for w rs; flip_altsublist_adjacent rs ?ts\\<rbrakk>\n  \\<Longrightarrow> S_reduced_for w ?ts\n  \\<lbrakk>\\<And>y ss ts.\n              \\<lbrakk>order.greater (S_length w) (S_length y);\n               y \\<noteq> (0::'w); S_reduced_for y ss;\n               S_reduced_for y ts\\<rbrakk>\n              \\<Longrightarrow> \\<exists>xss.\n                                   flip_altsublist_chain (ss # xss @ [ts]);\n   S_reduced_for w (?a # ?ss); S_reduced_for w (?a # ?ts)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss.\n                       flip_altsublist_chain ((?a # ?ss) # xss @ [?a # ?ts])\n\ngoal (1 subgoal):\n 1. bs \\<noteq> vs \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain (us # xss @ [b # bs])", "by    auto"], ["proof (state)\nthis:\n  bs \\<noteq> vs \\<Longrightarrow>\n  \\<exists>xss. flip_altsublist_chain (us # xss @ [b # bs])\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "proof (cases \"as = qs\" \"bs = vs\" rule: two_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>as = qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 2. \\<lbrakk>as = qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 3. \\<lbrakk>as \\<noteq> qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 4. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "case both"], ["proof (state)\nthis:\n  as = qs\n  bs = vs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>as = qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 2. \\<lbrakk>as = qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 3. \\<lbrakk>as \\<noteq> qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 4. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "with rs' us'"], ["proof (chain)\npicking this:\n  rs = a # qs\n  us = b # vs\n  as = qs\n  bs = vs", "have \"flip_altsublist_chain ((a#as) # [] @ [b#bs])\""], ["proof (prove)\nusing this:\n  rs = a # qs\n  us = b # vs\n  as = qs\n  bs = vs\n\ngoal (1 subgoal):\n 1. flip_altsublist_chain ((a # as) # [] @ [b # bs])", "using midlink"], ["proof (prove)\nusing this:\n  rs = a # qs\n  us = b # vs\n  as = qs\n  bs = vs\n  flip_altsublist_adjacent rs us\n\ngoal (1 subgoal):\n 1. flip_altsublist_chain ((a # as) # [] @ [b # bs])", "by simp"], ["proof (state)\nthis:\n  flip_altsublist_chain ((a # as) # [] @ [b # bs])\n\ngoal (4 subgoals):\n 1. \\<lbrakk>as = qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 2. \\<lbrakk>as = qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 3. \\<lbrakk>as \\<noteq> qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 4. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "thus ?thesis"], ["proof (prove)\nusing this:\n  flip_altsublist_chain ((a # as) # [] @ [b # bs])\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "by fast"], ["proof (state)\nthis:\n  \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])\n\ngoal (3 subgoals):\n 1. \\<lbrakk>as = qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 2. \\<lbrakk>as \\<noteq> qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 3. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>as = qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 2. \\<lbrakk>as \\<noteq> qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 3. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "case one"], ["proof (state)\nthis:\n  as = qs\n  bs \\<noteq> vs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>as = qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 2. \\<lbrakk>as \\<noteq> qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 3. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "with rs'"], ["proof (chain)\npicking this:\n  rs = a # qs\n  as = qs\n  bs \\<noteq> vs", "obtain xss\n      where \"flip_altsublist_chain ((a#as) # (us # xss) @ [b#bs])\""], ["proof (prove)\nusing this:\n  rs = a # qs\n  as = qs\n  bs \\<noteq> vs\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        flip_altsublist_chain\n         ((a # as) # (us # xss) @ [b # bs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using endlink midlink"], ["proof (prove)\nusing this:\n  rs = a # qs\n  as = qs\n  bs \\<noteq> vs\n  bs \\<noteq> vs \\<Longrightarrow>\n  \\<exists>xss. flip_altsublist_chain (us # xss @ [b # bs])\n  flip_altsublist_adjacent rs us\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        flip_altsublist_chain\n         ((a # as) # (us # xss) @ [b # bs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  flip_altsublist_chain ((a # as) # (us # xss) @ [b # bs])\n\ngoal (3 subgoals):\n 1. \\<lbrakk>as = qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 2. \\<lbrakk>as \\<noteq> qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 3. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "thus ?thesis"], ["proof (prove)\nusing this:\n  flip_altsublist_chain ((a # as) # (us # xss) @ [b # bs])\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "by fast"], ["proof (state)\nthis:\n  \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>as \\<noteq> qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 2. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>as \\<noteq> qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 2. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "case other"], ["proof (state)\nthis:\n  as \\<noteq> qs\n  bs = vs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>as \\<noteq> qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 2. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "from other(1)"], ["proof (chain)\npicking this:\n  as \\<noteq> qs", "obtain xss where \"flip_altsublist_chain ((a#as) # xss @ [rs])\""], ["proof (prove)\nusing this:\n  as \\<noteq> qs\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        flip_altsublist_chain ((a # as) # xss @ [rs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using startlink"], ["proof (prove)\nusing this:\n  as \\<noteq> qs\n  as \\<noteq> qs \\<Longrightarrow>\n  \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [rs])\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        flip_altsublist_chain ((a # as) # xss @ [rs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  flip_altsublist_chain ((a # as) # xss @ [rs])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>as \\<noteq> qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 2. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "with other(2) us' startlink"], ["proof (chain)\npicking this:\n  bs = vs\n  us = b # vs\n  as \\<noteq> qs \\<Longrightarrow>\n  \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [rs])\n  flip_altsublist_chain ((a # as) # xss @ [rs])", "have  \"flip_altsublist_chain ((a#as) # (xss@[rs]) @ [b#bs])\""], ["proof (prove)\nusing this:\n  bs = vs\n  us = b # vs\n  as \\<noteq> qs \\<Longrightarrow>\n  \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [rs])\n  flip_altsublist_chain ((a # as) # xss @ [rs])\n\ngoal (1 subgoal):\n 1. flip_altsublist_chain ((a # as) # (xss @ [rs]) @ [b # bs])", "using midlink binrelchain_snoc[of flip_altsublist_adjacent \"(a#as)#xss\"]"], ["proof (prove)\nusing this:\n  bs = vs\n  us = b # vs\n  as \\<noteq> qs \\<Longrightarrow>\n  \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [rs])\n  flip_altsublist_chain ((a # as) # xss @ [rs])\n  flip_altsublist_adjacent rs us\n  \\<lbrakk>flip_altsublist_chain (((a # as) # xss) @ [?x]);\n   flip_altsublist_adjacent ?x ?y\\<rbrakk>\n  \\<Longrightarrow> flip_altsublist_chain (((a # as) # xss) @ [?x, ?y])\n\ngoal (1 subgoal):\n 1. flip_altsublist_chain ((a # as) # (xss @ [rs]) @ [b # bs])", "by    simp"], ["proof (state)\nthis:\n  flip_altsublist_chain ((a # as) # (xss @ [rs]) @ [b # bs])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>as \\<noteq> qs; bs = vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])\n 2. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "thus ?thesis"], ["proof (prove)\nusing this:\n  flip_altsublist_chain ((a # as) # (xss @ [rs]) @ [b # bs])\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "by fast"], ["proof (state)\nthis:\n  \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "case neither"], ["proof (state)\nthis:\n  as \\<noteq> qs\n  bs \\<noteq> vs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "from neither(1)"], ["proof (chain)\npicking this:\n  as \\<noteq> qs", "obtain xss\n      where \"flip_altsublist_chain ((a#as) # xss @ [rs])\""], ["proof (prove)\nusing this:\n  as \\<noteq> qs\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        flip_altsublist_chain ((a # as) # xss @ [rs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using startlink"], ["proof (prove)\nusing this:\n  as \\<noteq> qs\n  as \\<noteq> qs \\<Longrightarrow>\n  \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [rs])\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        flip_altsublist_chain ((a # as) # xss @ [rs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  flip_altsublist_chain ((a # as) # xss @ [rs])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "with neither(2)"], ["proof (chain)\npicking this:\n  bs \\<noteq> vs\n  flip_altsublist_chain ((a # as) # xss @ [rs])", "obtain yss\n      where \"flip_altsublist_chain ((a#as) # (xss @ [rs,us] @ yss) @ [b#bs])\""], ["proof (prove)\nusing this:\n  bs \\<noteq> vs\n  flip_altsublist_chain ((a # as) # xss @ [rs])\n\ngoal (1 subgoal):\n 1. (\\<And>yss.\n        flip_altsublist_chain\n         ((a # as) # (xss @ [rs, us] @ yss) @ [b # bs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using startlink midlink endlink\n            binrelchain_join[of flip_altsublist_adjacent \"(a#as)#xss\"]"], ["proof (prove)\nusing this:\n  bs \\<noteq> vs\n  flip_altsublist_chain ((a # as) # xss @ [rs])\n  as \\<noteq> qs \\<Longrightarrow>\n  \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [rs])\n  flip_altsublist_adjacent rs us\n  bs \\<noteq> vs \\<Longrightarrow>\n  \\<exists>xss. flip_altsublist_chain (us # xss @ [b # bs])\n  \\<lbrakk>flip_altsublist_chain (((a # as) # xss) @ [?x]);\n   flip_altsublist_chain (?y # ?ys); flip_altsublist_adjacent ?x ?y\\<rbrakk>\n  \\<Longrightarrow> flip_altsublist_chain (((a # as) # xss) @ ?x # ?y # ?ys)\n\ngoal (1 subgoal):\n 1. (\\<And>yss.\n        flip_altsublist_chain\n         ((a # as) # (xss @ [rs, us] @ yss) @ [b # bs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  flip_altsublist_chain ((a # as) # (xss @ [rs, us] @ yss) @ [b # bs])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>as \\<noteq> qs; bs \\<noteq> vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss.\n                         flip_altsublist_chain ((a # as) # xss @ [b # bs])", "thus ?thesis"], ["proof (prove)\nusing this:\n  flip_altsublist_chain ((a # as) # (xss @ [rs, us] @ yss) @ [b # bs])\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])", "by fast"], ["proof (state)\nthis:\n  \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xss. flip_altsublist_chain ((a # as) # xss @ [b # bs])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduced_word_problem:\n  \"\\<lbrakk> w\\<noteq>0; reduced_word_for S w ss; reduced_word_for S w ts \\<rbrakk> \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain (ss#xss@[ts])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> (0::'w); S_reduced_for w ss;\n     S_reduced_for w ts\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "proof (induct w arbitrary: ss ts rule: measure_induct_rule[of \"S_length\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ss ts.\n       \\<lbrakk>\\<And>y ss ts.\n                   \\<lbrakk>order.greater (S_length x) (S_length y);\n                    y \\<noteq> (0::'w); S_reduced_for y ss;\n                    S_reduced_for y ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xss.\n  flip_altsublist_chain (ss # xss @ [ts]);\n        x \\<noteq> (0::'w); S_reduced_for x ss; S_reduced_for x ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])", "case (less w)"], ["proof (state)\nthis:\n  \\<lbrakk>order.greater (S_length w) (S_length ?y); ?y \\<noteq> (0::'w);\n   S_reduced_for ?y ?ss; S_reduced_for ?y ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n  w \\<noteq> (0::'w)\n  S_reduced_for w ss\n  S_reduced_for w ts\n\ngoal (1 subgoal):\n 1. \\<And>x ss ts.\n       \\<lbrakk>\\<And>y ss ts.\n                   \\<lbrakk>order.greater (S_length x) (S_length y);\n                    y \\<noteq> (0::'w); S_reduced_for y ss;\n                    S_reduced_for y ts\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xss.\n  flip_altsublist_chain (ss # xss @ [ts]);\n        x \\<noteq> (0::'w); S_reduced_for x ss; S_reduced_for x ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "proof (cases ss ts rule: two_lists_cases_Cons_Cons)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>ss = []; ts = ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])\n 2. \\<And>xs.\n       \\<lbrakk>ss = xs; ts = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])\n 3. \\<And>x xs y ys.\n       \\<lbrakk>ss = x # xs; ts = y # ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])", "case Nil1"], ["proof (state)\nthis:\n  ss = []\n  ts = ys_\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>ss = []; ts = ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])\n 2. \\<And>xs.\n       \\<lbrakk>ss = xs; ts = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])\n 3. \\<And>x xs y ys.\n       \\<lbrakk>ss = x # xs; ts = y # ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])", "from Nil1(1) less(2,3)"], ["proof (chain)\npicking this:\n  ss = []\n  w \\<noteq> (0::'w)\n  S_reduced_for w ss", "show ?thesis"], ["proof (prove)\nusing this:\n  ss = []\n  w \\<noteq> (0::'w)\n  S_reduced_for w ss\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "using reduced_word_for_sum_list"], ["proof (prove)\nusing this:\n  ss = []\n  w \\<noteq> (0::'w)\n  S_reduced_for w ss\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> sum_list ?as = ?a\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>ss = xs; ts = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>ss = x # xs; ts = y # ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>ss = xs; ts = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>ss = x # xs; ts = y # ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])", "case Nil2"], ["proof (state)\nthis:\n  ss = xs_\n  ts = []\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>ss = xs; ts = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>ss = x # xs; ts = y # ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])", "from Nil2(2) less(2,4)"], ["proof (chain)\npicking this:\n  ts = []\n  w \\<noteq> (0::'w)\n  S_reduced_for w ts", "show ?thesis"], ["proof (prove)\nusing this:\n  ts = []\n  w \\<noteq> (0::'w)\n  S_reduced_for w ts\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "using reduced_word_for_sum_list"], ["proof (prove)\nusing this:\n  ts = []\n  w \\<noteq> (0::'w)\n  S_reduced_for w ts\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> sum_list ?as = ?a\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>ss = x # xs; ts = y # ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>ss = x # xs; ts = y # ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])", "case (ConsCons a as b bs)"], ["proof (state)\nthis:\n  ss = a # as\n  ts = b # bs\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>ss = x # xs; ts = y # ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss.\n                            flip_altsublist_chain (ss # xss @ [ts])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "proof (cases \"a=b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])\n 2. a \\<noteq> b \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "case True"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])\n 2. a \\<noteq> b \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "with less ConsCons"], ["proof (chain)\npicking this:\n  \\<lbrakk>order.greater (S_length w) (S_length ?y); ?y \\<noteq> (0::'w);\n   S_reduced_for ?y ?ss; S_reduced_for ?y ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n  w \\<noteq> (0::'w)\n  S_reduced_for w ss\n  S_reduced_for w ts\n  ss = a # as\n  ts = b # bs\n  a = b", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater (S_length w) (S_length ?y); ?y \\<noteq> (0::'w);\n   S_reduced_for ?y ?ss; S_reduced_for ?y ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n  w \\<noteq> (0::'w)\n  S_reduced_for w ss\n  S_reduced_for w ts\n  ss = a # as\n  ts = b # bs\n  a = b\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "using reduced_word_problem_eq_hd_step[of w]"], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater (S_length w) (S_length ?y); ?y \\<noteq> (0::'w);\n   S_reduced_for ?y ?ss; S_reduced_for ?y ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n  w \\<noteq> (0::'w)\n  S_reduced_for w ss\n  S_reduced_for w ts\n  ss = a # as\n  ts = b # bs\n  a = b\n  \\<lbrakk>\\<And>y ss ts.\n              \\<lbrakk>order.greater (S_length w) (S_length y);\n               y \\<noteq> (0::'w); S_reduced_for y ss;\n               S_reduced_for y ts\\<rbrakk>\n              \\<Longrightarrow> \\<exists>xss.\n                                   flip_altsublist_chain (ss # xss @ [ts]);\n   S_reduced_for w (?a # ?ss); S_reduced_for w (?a # ?ts)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss.\n                       flip_altsublist_chain ((?a # ?ss) # xss @ [?a # ?ts])\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "by auto"], ["proof (state)\nthis:\n  \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "case False"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "with less ConsCons"], ["proof (chain)\npicking this:\n  \\<lbrakk>order.greater (S_length w) (S_length ?y); ?y \\<noteq> (0::'w);\n   S_reduced_for ?y ?ss; S_reduced_for ?y ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n  w \\<noteq> (0::'w)\n  S_reduced_for w ss\n  S_reduced_for w ts\n  ss = a # as\n  ts = b # bs\n  a \\<noteq> b", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater (S_length w) (S_length ?y); ?y \\<noteq> (0::'w);\n   S_reduced_for ?y ?ss; S_reduced_for ?y ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n  w \\<noteq> (0::'w)\n  S_reduced_for w ss\n  S_reduced_for w ts\n  ss = a # as\n  ts = b # bs\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "using reduced_word_problem_ConsCons_step[of w]"], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater (S_length w) (S_length ?y); ?y \\<noteq> (0::'w);\n   S_reduced_for ?y ?ss; S_reduced_for ?y ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n  w \\<noteq> (0::'w)\n  S_reduced_for w ss\n  S_reduced_for w ts\n  ss = a # as\n  ts = b # bs\n  a \\<noteq> b\n  \\<lbrakk>\\<And>y ss ts.\n              \\<lbrakk>order.greater (S_length w) (S_length y);\n               y \\<noteq> (0::'w); S_reduced_for y ss;\n               S_reduced_for y ts\\<rbrakk>\n              \\<Longrightarrow> \\<exists>xss.\n                                   flip_altsublist_chain (ss # xss @ [ts]);\n   S_reduced_for w (?a # ?as); S_reduced_for w (?b # ?bs);\n   ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss.\n                       flip_altsublist_chain ((?a # ?as) # xss @ [?b # ?bs])\n\ngoal (1 subgoal):\n 1. \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])", "by simp"], ["proof (state)\nthis:\n  \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xss. flip_altsublist_chain (ss # xss @ [ts])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduced_word_letter_set:\n  assumes \"S_reduced_for w ss\"\n  shows \"reduced_letter_set S w = set ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_letter_set S w = set ss", "proof (cases \"w=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = (0::'w) \\<Longrightarrow> reduced_letter_set S w = set ss\n 2. w \\<noteq> (0::'w) \\<Longrightarrow> reduced_letter_set S w = set ss", "case True"], ["proof (state)\nthis:\n  w = (0::'w)\n\ngoal (2 subgoals):\n 1. w = (0::'w) \\<Longrightarrow> reduced_letter_set S w = set ss\n 2. w \\<noteq> (0::'w) \\<Longrightarrow> reduced_letter_set S w = set ss", "with assms"], ["proof (chain)\npicking this:\n  S_reduced_for w ss\n  w = (0::'w)", "show ?thesis"], ["proof (prove)\nusing this:\n  S_reduced_for w ss\n  w = (0::'w)\n\ngoal (1 subgoal):\n 1. reduced_letter_set S w = set ss", "using reduced_word_for_0_imp_nil[of S ss] reduced_letter_set_0"], ["proof (prove)\nusing this:\n  S_reduced_for w ss\n  w = (0::'w)\n  S_reduced_for (0::'w) ss \\<Longrightarrow> ss = []\n  reduced_letter_set ?A (0::?'a) = {}\n\ngoal (1 subgoal):\n 1. reduced_letter_set S w = set ss", "by simp"], ["proof (state)\nthis:\n  reduced_letter_set S w = set ss\n\ngoal (1 subgoal):\n 1. w \\<noteq> (0::'w) \\<Longrightarrow> reduced_letter_set S w = set ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> (0::'w) \\<Longrightarrow> reduced_letter_set S w = set ss", "case False"], ["proof (state)\nthis:\n  w \\<noteq> (0::'w)\n\ngoal (1 subgoal):\n 1. w \\<noteq> (0::'w) \\<Longrightarrow> reduced_letter_set S w = set ss", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_letter_set S w = set ss", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq (set ss) (reduced_letter_set S w)\n 2. order.greater_eq (reduced_letter_set S w) (set ss)", "from assms"], ["proof (chain)\npicking this:\n  S_reduced_for w ss", "show \"set ss \\<subseteq> reduced_letter_set S w\""], ["proof (prove)\nusing this:\n  S_reduced_for w ss\n\ngoal (1 subgoal):\n 1. order.greater_eq (reduced_letter_set S w) (set ss)", "by fast"], ["proof (state)\nthis:\n  order.greater_eq (reduced_letter_set S w) (set ss)\n\ngoal (1 subgoal):\n 1. order.greater_eq (set ss) (reduced_letter_set S w)", "show \"reduced_letter_set S w \\<subseteq> set ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (set ss) (reduced_letter_set S w)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> reduced_letter_set S w \\<Longrightarrow> x \\<in> set ss", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> reduced_letter_set S w \\<Longrightarrow> x \\<in> set ss", "assume \"x \\<in> reduced_letter_set S w\""], ["proof (state)\nthis:\n  x \\<in> reduced_letter_set S w\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> reduced_letter_set S w \\<Longrightarrow> x \\<in> set ss", "from this"], ["proof (chain)\npicking this:\n  x \\<in> reduced_letter_set S w", "obtain ts where \"reduced_word_for S w ts\" \"x \\<in> set ts\""], ["proof (prove)\nusing this:\n  x \\<in> reduced_letter_set S w\n\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        \\<lbrakk>S_reduced_for w ts; x \\<in> set ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  S_reduced_for w ts\n  x \\<in> set ts\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> reduced_letter_set S w \\<Longrightarrow> x \\<in> set ss", "with False assms"], ["proof (chain)\npicking this:\n  w \\<noteq> (0::'w)\n  S_reduced_for w ss\n  S_reduced_for w ts\n  x \\<in> set ts", "show \"x \\<in> set ss\""], ["proof (prove)\nusing this:\n  w \\<noteq> (0::'w)\n  S_reduced_for w ss\n  S_reduced_for w ts\n  x \\<in> set ts\n\ngoal (1 subgoal):\n 1. x \\<in> set ss", "using reduced_word_for_lists[of S _ ss] reduced_word_problem[of w ss]\n              flip_altsublist_chain_set"], ["proof (prove)\nusing this:\n  w \\<noteq> (0::'w)\n  S_reduced_for w ss\n  S_reduced_for w ts\n  x \\<in> set ts\n  S_reduced_for ?a ss \\<Longrightarrow> ss \\<in> lists S\n  \\<lbrakk>w \\<noteq> (0::'w); S_reduced_for w ss;\n   S_reduced_for w ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (ss # xss @ [?ts])\n  \\<lbrakk>?x \\<in> lists S;\n   flip_altsublist_chain (?x # ?zs @ [?y])\\<rbrakk>\n  \\<Longrightarrow> set ?y = set ?x\n\ngoal (1 subgoal):\n 1. x \\<in> set ss", "by    force"], ["proof (state)\nthis:\n  x \\<in> set ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq (set ss) (reduced_letter_set S w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reduced_letter_set S w = set ss\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context PreCoxeterSystemWithDeletion *)"], ["", "subsubsection \\<open>Special subgroups and cosets\\<close>"], ["", "text \\<open>\n  Recall that special subgroups are those generated by subsets of the generating set @{term S}.\n  Here we show that the presence of the deletion condition guarantees that the collection of\n  special subgroups and their left cosets forms a poset under reverse inclusion that satisfies the\n  necessary properties to ensure that the poset of simplices in the associated simplicial complex\n  is isomorphic to this poset of special cosets.\n\\<close>"], ["", "context PreCoxeterSystemWithDeletion\nbegin"], ["", "lemma special_subgroup_int_S:\n  assumes \"T \\<in> Pow S\"\n  shows   \"\\<langle>T\\<rangle> \\<inter> S = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>T\\<rangle> \\<inter> S = T", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq T (\\<langle>T\\<rangle> \\<inter> S)\n 2. order.greater_eq (\\<langle>T\\<rangle> \\<inter> S) T", "show \"\\<langle>T\\<rangle> \\<inter> S \\<subseteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq T (\\<langle>T\\<rangle> \\<inter> S)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>T\\<rangle> \\<inter> S \\<Longrightarrow> x \\<in> T", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>T\\<rangle> \\<inter> S \\<Longrightarrow> x \\<in> T", "assume t: \"t \\<in> \\<langle>T\\<rangle> \\<inter> S\""], ["proof (state)\nthis:\n  t \\<in> \\<langle>T\\<rangle> \\<inter> S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>T\\<rangle> \\<inter> S \\<Longrightarrow> x \\<in> T", "with assms"], ["proof (chain)\npicking this:\n  T \\<in> Pow S\n  t \\<in> \\<langle>T\\<rangle> \\<inter> S", "obtain ts where ts: \"ts \\<in> lists T\" \"t = sum_list ts\""], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  t \\<in> \\<langle>T\\<rangle> \\<inter> S\n\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        \\<lbrakk>ts \\<in> lists T; t = sum_list ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using special_subgroup_eq_sum_list[of T]"], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  t \\<in> \\<langle>T\\<rangle> \\<inter> S\n  order.greater_eq S T \\<Longrightarrow>\n  \\<langle>T\\<rangle> = (\\<Union>ss\\<in>lists T. {sum_list ss})\n\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        \\<lbrakk>ts \\<in> lists T; t = sum_list ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  ts \\<in> lists T\n  t = sum_list ts\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>T\\<rangle> \\<inter> S \\<Longrightarrow> x \\<in> T", "with assms"], ["proof (chain)\npicking this:\n  T \\<in> Pow S\n  ts \\<in> lists T\n  t = sum_list ts", "obtain us\n      where us: \"reduced_word_for S (sum_list ts) us\" \"set us \\<subseteq> set ts\""], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  ts \\<in> lists T\n  t = sum_list ts\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>S_reduced_for (sum_list ts) us;\n         order.greater_eq (set ts) (set us)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using deletion_reduce'[of ts]"], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  ts \\<in> lists T\n  t = sum_list ts\n  ts \\<in> lists S \\<Longrightarrow>\n  \\<exists>tsa\\<in>reduced_words_for S (sum_list ts).\n     order.greater_eq (set ts) (set tsa)\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>S_reduced_for (sum_list ts) us;\n         order.greater_eq (set ts) (set us)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  S_reduced_for (sum_list ts) us\n  order.greater_eq (set ts) (set us)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>T\\<rangle> \\<inter> S \\<Longrightarrow> x \\<in> T", "with no_zero_genset ts(2) t"], ["proof (chain)\npicking this:\n  (0::'w) \\<notin> S\n  t = sum_list ts\n  t \\<in> \\<langle>T\\<rangle> \\<inter> S\n  S_reduced_for (sum_list ts) us\n  order.greater_eq (set ts) (set us)", "have \"length us = 1\""], ["proof (prove)\nusing this:\n  (0::'w) \\<notin> S\n  t = sum_list ts\n  t \\<in> \\<langle>T\\<rangle> \\<inter> S\n  S_reduced_for (sum_list ts) us\n  order.greater_eq (set ts) (set us)\n\ngoal (1 subgoal):\n 1. length us = 1", "using reduced_word_for_lists[of S _ us] reduced_word_for_sum_list[of S _ us]\n            reduced_word_for_imp_reduced_word[of S _ us] el_reduced[of S]"], ["proof (prove)\nusing this:\n  (0::'w) \\<notin> S\n  t = sum_list ts\n  t \\<in> \\<langle>T\\<rangle> \\<inter> S\n  S_reduced_for (sum_list ts) us\n  order.greater_eq (set ts) (set us)\n  S_reduced_for ?a us \\<Longrightarrow> us \\<in> lists S\n  S_reduced_for ?a us \\<Longrightarrow> sum_list us = ?a\n  S_reduced_for ?a us \\<Longrightarrow> S_reduced us\n  \\<lbrakk>(0::'w) \\<notin> S; ?as \\<in> lists S; sum_list ?as \\<in> S;\n   S_reduced ?as\\<rbrakk>\n  \\<Longrightarrow> length ?as = 1\n\ngoal (1 subgoal):\n 1. length us = 1", "by    auto"], ["proof (state)\nthis:\n  length us = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>T\\<rangle> \\<inter> S \\<Longrightarrow> x \\<in> T", "with us ts"], ["proof (chain)\npicking this:\n  S_reduced_for (sum_list ts) us\n  order.greater_eq (set ts) (set us)\n  ts \\<in> lists T\n  t = sum_list ts\n  length us = 1", "show \"t\\<in>T\""], ["proof (prove)\nusing this:\n  S_reduced_for (sum_list ts) us\n  order.greater_eq (set ts) (set us)\n  ts \\<in> lists T\n  t = sum_list ts\n  length us = 1\n\ngoal (1 subgoal):\n 1. t \\<in> T", "using reduced_word_for_sum_list[of S _ us]"], ["proof (prove)\nusing this:\n  S_reduced_for (sum_list ts) us\n  order.greater_eq (set ts) (set us)\n  ts \\<in> lists T\n  t = sum_list ts\n  length us = 1\n  S_reduced_for ?a us \\<Longrightarrow> sum_list us = ?a\n\ngoal (1 subgoal):\n 1. t \\<in> T", "by (cases us) auto"], ["proof (state)\nthis:\n  t \\<in> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq T (\\<langle>T\\<rangle> \\<inter> S)\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<langle>T\\<rangle> \\<inter> S) T", "from assms"], ["proof (chain)\npicking this:\n  T \\<in> Pow S", "show \"T \\<subseteq> \\<langle>T\\<rangle> \\<inter> S\""], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<langle>T\\<rangle> \\<inter> S) T", "using genby_genset_subset"], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  order.greater_eq \\<langle>?S\\<rangle> ?S\n\ngoal (1 subgoal):\n 1. order.greater_eq (\\<langle>T\\<rangle> \\<inter> S) T", "by fast"], ["proof (state)\nthis:\n  order.greater_eq (\\<langle>T\\<rangle> \\<inter> S) T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma special_subgroup_inj: \"inj_on genby (Pow S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on genby (Pow S)", "using special_subgroup_int_S inj_on_inverseI[of _ \"\\<lambda>W. W\\<inter>S\"]"], ["proof (prove)\nusing this:\n  ?T \\<in> Pow S \\<Longrightarrow> \\<langle>?T\\<rangle> \\<inter> S = ?T\n  (\\<And>x.\n      x \\<in> ?A \\<Longrightarrow> ?f x \\<inter> S = x) \\<Longrightarrow>\n  inj_on ?f ?A\n\ngoal (1 subgoal):\n 1. inj_on genby (Pow S)", "by fastforce"], ["", "lemma special_subgroup_genby_subset_ordering_iso:\n  \"subset_ordering_iso (Pow S) genby\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetIso dual_order.greater_eq dual_order.greater\n     dual_order.greater_eq dual_order.greater (Pow S) genby", "proof (unfold_locales, rule genby_mono, simp, rule special_subgroup_inj)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> genby ` Pow S; b \\<in> genby ` Pow S;\n        order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into (Pow S) genby b)\n                          (the_inv_into (Pow S) genby a)", "fix X Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> genby ` Pow S; b \\<in> genby ` Pow S;\n        order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into (Pow S) genby b)\n                          (the_inv_into (Pow S) genby a)", "assume XY: \"X \\<in> genby ` Pow S\" \"Y \\<in> genby ` Pow S\" \"X\\<subseteq>Y\""], ["proof (state)\nthis:\n  X \\<in> genby ` Pow S\n  Y \\<in> genby ` Pow S\n  order.greater_eq Y X\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> genby ` Pow S; b \\<in> genby ` Pow S;\n        order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into (Pow S) genby b)\n                          (the_inv_into (Pow S) genby a)", "from XY(1,2)"], ["proof (chain)\npicking this:\n  X \\<in> genby ` Pow S\n  Y \\<in> genby ` Pow S", "obtain TX TY\n    where \"TX\\<in>Pow S\" \"X = \\<langle>TX\\<rangle>\" \"TY\\<in>Pow S\" \"Y = \\<langle>TY\\<rangle>\""], ["proof (prove)\nusing this:\n  X \\<in> genby ` Pow S\n  Y \\<in> genby ` Pow S\n\ngoal (1 subgoal):\n 1. (\\<And>TX TY.\n        \\<lbrakk>TX \\<in> Pow S; X = \\<langle>TX\\<rangle>; TY \\<in> Pow S;\n         Y = \\<langle>TY\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  TX \\<in> Pow S\n  X = \\<langle>TX\\<rangle>\n  TY \\<in> Pow S\n  Y = \\<langle>TY\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> genby ` Pow S; b \\<in> genby ` Pow S;\n        order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into (Pow S) genby b)\n                          (the_inv_into (Pow S) genby a)", "hence \"the_inv_into (Pow S) genby X = X\\<inter>S\"\n        \"the_inv_into (Pow S) genby Y = Y\\<inter>S\""], ["proof (prove)\nusing this:\n  TX \\<in> Pow S\n  X = \\<langle>TX\\<rangle>\n  TY \\<in> Pow S\n  Y = \\<langle>TY\\<rangle>\n\ngoal (1 subgoal):\n 1. the_inv_into (Pow S) genby X = X \\<inter> S &&&\n    the_inv_into (Pow S) genby Y = Y \\<inter> S", "using the_inv_into_f_f[OF special_subgroup_inj] special_subgroup_int_S"], ["proof (prove)\nusing this:\n  TX \\<in> Pow S\n  X = \\<langle>TX\\<rangle>\n  TY \\<in> Pow S\n  Y = \\<langle>TY\\<rangle>\n  ?x \\<in> Pow S \\<Longrightarrow>\n  the_inv_into (Pow S) genby \\<langle>?x\\<rangle> = ?x\n  ?T \\<in> Pow S \\<Longrightarrow> \\<langle>?T\\<rangle> \\<inter> S = ?T\n\ngoal (1 subgoal):\n 1. the_inv_into (Pow S) genby X = X \\<inter> S &&&\n    the_inv_into (Pow S) genby Y = Y \\<inter> S", "by    auto"], ["proof (state)\nthis:\n  the_inv_into (Pow S) genby X = X \\<inter> S\n  the_inv_into (Pow S) genby Y = Y \\<inter> S\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> genby ` Pow S; b \\<in> genby ` Pow S;\n        order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (the_inv_into (Pow S) genby b)\n                          (the_inv_into (Pow S) genby a)", "with XY(3)"], ["proof (chain)\npicking this:\n  order.greater_eq Y X\n  the_inv_into (Pow S) genby X = X \\<inter> S\n  the_inv_into (Pow S) genby Y = Y \\<inter> S", "show  \"the_inv_into (Pow S) genby X \\<subseteq> the_inv_into (Pow S) genby Y\""], ["proof (prove)\nusing this:\n  order.greater_eq Y X\n  the_inv_into (Pow S) genby X = X \\<inter> S\n  the_inv_into (Pow S) genby Y = Y \\<inter> S\n\ngoal (1 subgoal):\n 1. order.greater_eq (the_inv_into (Pow S) genby Y)\n     (the_inv_into (Pow S) genby X)", "by    auto"], ["proof (state)\nthis:\n  order.greater_eq (the_inv_into (Pow S) genby Y)\n   (the_inv_into (Pow S) genby X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas special_subgroup_genby_rev_mono\n  = OrderingSetIso.rev_ordsetmap[OF special_subgroup_genby_subset_ordering_iso]"], ["", "lemma special_subgroup_word_length:\n  assumes \"T\\<in>Pow S\" \"w\\<in>\\<langle>T\\<rangle>\"\n  shows   \"word_length T w = S_length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_length T w = S_length w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. word_length T w = S_length w", "from assms"], ["proof (chain)\npicking this:\n  T \\<in> Pow S\n  w \\<in> \\<langle>T\\<rangle>", "obtain ts where ts: \"ts \\<in> lists T\" \"w = sum_list ts\""], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  w \\<in> \\<langle>T\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        \\<lbrakk>ts \\<in> lists T; w = sum_list ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using special_subgroup_eq_sum_list"], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  w \\<in> \\<langle>T\\<rangle>\n  order.greater_eq S ?S \\<Longrightarrow>\n  \\<langle>?S\\<rangle> = (\\<Union>ss\\<in>lists ?S. {sum_list ss})\n\ngoal (1 subgoal):\n 1. (\\<And>ts.\n        \\<lbrakk>ts \\<in> lists T; w = sum_list ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ts \\<in> lists T\n  w = sum_list ts\n\ngoal (1 subgoal):\n 1. word_length T w = S_length w", "with assms(1)"], ["proof (chain)\npicking this:\n  T \\<in> Pow S\n  ts \\<in> lists T\n  w = sum_list ts", "obtain us where \"us \\<in> ssubseqs ts\" \"S_reduced_for w us\""], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  ts \\<in> lists T\n  w = sum_list ts\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>us \\<in> ssubseqs ts; S_reduced_for w us\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using deletion_reduce[of ts]"], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  ts \\<in> lists T\n  w = sum_list ts\n  ts \\<in> lists S \\<Longrightarrow>\n  \\<exists>tsa.\n     tsa \\<in> ssubseqs ts \\<inter> reduced_words_for S (sum_list ts)\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        \\<lbrakk>us \\<in> ssubseqs ts; S_reduced_for w us\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  us \\<in> ssubseqs ts\n  S_reduced_for w us\n\ngoal (1 subgoal):\n 1. word_length T w = S_length w", "with assms(1) ts(1)"], ["proof (chain)\npicking this:\n  T \\<in> Pow S\n  ts \\<in> lists T\n  us \\<in> ssubseqs ts\n  S_reduced_for w us", "show ?thesis"], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  ts \\<in> lists T\n  us \\<in> ssubseqs ts\n  S_reduced_for w us\n\ngoal (1 subgoal):\n 1. word_length T w = S_length w", "using     ssubseqs_lists[of ts] reduced_word_for_sum_list\n              is_arg_min_size_subprop[of length \"word_for S w\" us \"word_for T w\"]"], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  ts \\<in> lists T\n  us \\<in> ssubseqs ts\n  S_reduced_for w us\n  \\<lbrakk>ts \\<in> lists ?A; ?bs \\<in> ssubseqs ts\\<rbrakk>\n  \\<Longrightarrow> ?bs \\<in> lists ?A\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> sum_list ?as = ?a\n  \\<lbrakk>is_arg_min length (word_for S w) us; word_for T w us;\n   \\<And>y. word_for T w y \\<Longrightarrow> word_for S w y\\<rbrakk>\n  \\<Longrightarrow> length (arg_min length (word_for T w)) =\n                    length (arg_min length (word_for S w))\n\ngoal (1 subgoal):\n 1. word_length T w = S_length w", "unfolding reduced_word_for_def word_length_def"], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  ts \\<in> lists T\n  us \\<in> ssubseqs ts\n  is_arg_min length (word_for S w) us\n  \\<lbrakk>ts \\<in> lists ?A; ?bs \\<in> ssubseqs ts\\<rbrakk>\n  \\<Longrightarrow> ?bs \\<in> lists ?A\n  is_arg_min length (word_for ?A ?a) ?as \\<Longrightarrow> sum_list ?as = ?a\n  \\<lbrakk>is_arg_min length (word_for S w) us; word_for T w us;\n   \\<And>y. word_for T w y \\<Longrightarrow> word_for S w y\\<rbrakk>\n  \\<Longrightarrow> length (arg_min length (word_for T w)) =\n                    length (arg_min length (word_for S w))\n\ngoal (1 subgoal):\n 1. length (arg_min length (word_for T w)) =\n    length (arg_min length (word_for S w))", "by        fast"], ["proof (state)\nthis:\n  word_length T w = S_length w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma S_subset_reduced_imp_S_reduced:\n  \"T\\<in>Pow S \\<Longrightarrow> reduced_word T ts \\<Longrightarrow> S_reduced ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<in> Pow S; reduced_word T ts\\<rbrakk>\n    \\<Longrightarrow> S_reduced ts", "using reduced_word_for_lists reduced_word_for_lists[of T _ ts]\n        reduced_word_for_length[of T \"sum_list ts\" ts] special_subgroup_eq_sum_list[of T]\n        special_subgroup_word_length[of T \"sum_list ts\"]"], ["proof (prove)\nusing this:\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n  reduced_word_for T ?a ts \\<Longrightarrow> ts \\<in> lists T\n  reduced_word T ts \\<Longrightarrow>\n  length ts = word_length T (sum_list ts)\n  order.greater_eq S T \\<Longrightarrow>\n  \\<langle>T\\<rangle> = (\\<Union>ss\\<in>lists T. {sum_list ss})\n  \\<lbrakk>T \\<in> Pow S; sum_list ts \\<in> \\<langle>T\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> word_length T (sum_list ts) = S_length (sum_list ts)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<in> Pow S; reduced_word T ts\\<rbrakk>\n    \\<Longrightarrow> S_reduced ts", "by    (fastforce intro: reduced_word_forI_length)"], ["", "lemma smallest_genby: \"T\\<in>Pow S \\<Longrightarrow> w\\<in>\\<langle>T\\<rangle> \\<Longrightarrow> reduced_letter_set S w \\<subseteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<in> Pow S; w \\<in> \\<langle>T\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq T (reduced_letter_set S w)", "using genby_S_reduced_word_for_arg_min[of T]\n        reduced_word_for_imp_reduced_word[of T w]\n        S_subset_reduced_imp_S_reduced[of T \"arg_min length (word_for T w)\"]\n        reduced_word_for_sum_list[of T] reduced_word_for_lists reduced_word_letter_set"], ["proof (prove)\nusing this:\n  \\<lbrakk>order.greater_eq S T; ?a \\<in> \\<langle>T\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> reduced_word_for T ?a (arg_min length (word_for T ?a))\n  reduced_word_for T w ?as \\<Longrightarrow> reduced_word T ?as\n  \\<lbrakk>T \\<in> Pow S;\n   reduced_word T (arg_min length (word_for T w))\\<rbrakk>\n  \\<Longrightarrow> S_reduced (arg_min length (word_for T w))\n  reduced_word_for T ?a ?as \\<Longrightarrow> sum_list ?as = ?a\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n  S_reduced_for ?w ?ss \\<Longrightarrow> reduced_letter_set S ?w = set ?ss\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T \\<in> Pow S; w \\<in> \\<langle>T\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq T (reduced_letter_set S w)", "by    fastforce"], ["", "lemma special_cosets_below_in:\n  assumes \"w\\<in>W\" \"T \\<in> Pow S\"\n  shows   \"\\<P>.\\<supseteq>(w +o \\<langle>T\\<rangle>) = (\\<Union>R\\<in>(Pow S).\\<supseteq>T. {w +o \\<langle>R\\<rangle>})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>) =\n    (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n        {w +o \\<langle>R\\<rangle>})", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> dual_order.below_in \\<P>\n                (w +o \\<langle>T\\<rangle>) \\<Longrightarrow>\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>})\n 2. \\<And>x.\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>}) \\<Longrightarrow>\n       x \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)", "fix A"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> dual_order.below_in \\<P>\n                (w +o \\<langle>T\\<rangle>) \\<Longrightarrow>\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>})\n 2. \\<And>x.\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>}) \\<Longrightarrow>\n       x \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)", "assume \"A \\<in> \\<P>.\\<supseteq>(w +o \\<langle>T\\<rangle>)\""], ["proof (state)\nthis:\n  A \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> dual_order.below_in \\<P>\n                (w +o \\<langle>T\\<rangle>) \\<Longrightarrow>\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>})\n 2. \\<And>x.\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>}) \\<Longrightarrow>\n       x \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)", "hence A: \"A\\<in>\\<P>\" \"A \\<supseteq> (w +o \\<langle>T\\<rangle>)\""], ["proof (prove)\nusing this:\n  A \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)\n\ngoal (1 subgoal):\n 1. A \\<in> \\<P> &&& order.greater_eq A (w +o \\<langle>T\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  A \\<in> \\<P>\n  order.greater_eq A (w +o \\<langle>T\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> dual_order.below_in \\<P>\n                (w +o \\<langle>T\\<rangle>) \\<Longrightarrow>\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>})\n 2. \\<And>x.\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>}) \\<Longrightarrow>\n       x \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)", "from A(1)"], ["proof (chain)\npicking this:\n  A \\<in> \\<P>", "obtain R w' where \"R\\<in>Pow S\" \"A = w' +o \\<langle>R\\<rangle>\""], ["proof (prove)\nusing this:\n  A \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>R w'.\n        \\<lbrakk>R \\<in> Pow S; A = w' +o \\<langle>R\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using special_cosets_def"], ["proof (prove)\nusing this:\n  A \\<in> \\<P>\n  \\<P> \\<equiv>\n  \\<Union>T\\<in>Pow S. \\<Union>w\\<in>W. {w +o \\<langle>T\\<rangle>}\n\ngoal (1 subgoal):\n 1. (\\<And>R w'.\n        \\<lbrakk>R \\<in> Pow S; A = w' +o \\<langle>R\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R \\<in> Pow S\n  A = w' +o \\<langle>R\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> dual_order.below_in \\<P>\n                (w +o \\<langle>T\\<rangle>) \\<Longrightarrow>\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>})\n 2. \\<And>x.\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>}) \\<Longrightarrow>\n       x \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)", "with A(2) assms(2)"], ["proof (chain)\npicking this:\n  order.greater_eq A (w +o \\<langle>T\\<rangle>)\n  T \\<in> Pow S\n  R \\<in> Pow S\n  A = w' +o \\<langle>R\\<rangle>", "show \"A \\<in> (\\<Union>R\\<in>(Pow S).\\<supseteq>T. {w +o \\<langle>R\\<rangle>})\""], ["proof (prove)\nusing this:\n  order.greater_eq A (w +o \\<langle>T\\<rangle>)\n  T \\<in> Pow S\n  R \\<in> Pow S\n  A = w' +o \\<langle>R\\<rangle>\n\ngoal (1 subgoal):\n 1. A \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                {w +o \\<langle>R\\<rangle>})", "using genby_lcoset_subgroup_imp_eq_reps[of w T w' R]\n          lcoset_eq_reps_subset[of w \"\\<langle>T\\<rangle>\"]\n          special_subgroup_genby_rev_mono[of T R]"], ["proof (prove)\nusing this:\n  order.greater_eq A (w +o \\<langle>T\\<rangle>)\n  T \\<in> Pow S\n  R \\<in> Pow S\n  A = w' +o \\<langle>R\\<rangle>\n  order.greater_eq (w' +o \\<langle>R\\<rangle>)\n   (w +o \\<langle>T\\<rangle>) \\<Longrightarrow>\n  w' +o \\<langle>R\\<rangle> = w +o \\<langle>R\\<rangle>\n  order.greater_eq (w +o ?B) (w +o \\<langle>T\\<rangle>) \\<Longrightarrow>\n  order.greater_eq ?B \\<langle>T\\<rangle>\n  \\<lbrakk>T \\<in> Pow S; R \\<in> Pow S;\n   order.greater_eq \\<langle>R\\<rangle> \\<langle>T\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq R T\n\ngoal (1 subgoal):\n 1. A \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                {w +o \\<langle>R\\<rangle>})", "by    auto"], ["proof (state)\nthis:\n  A \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n              {w +o \\<langle>R\\<rangle>})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>}) \\<Longrightarrow>\n       x \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>}) \\<Longrightarrow>\n       x \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)", "fix B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>}) \\<Longrightarrow>\n       x \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)", "assume \"B \\<in> (\\<Union>R\\<in>(Pow S).\\<supseteq>T. {w +o \\<langle>R\\<rangle>})\""], ["proof (state)\nthis:\n  B \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n              {w +o \\<langle>R\\<rangle>})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>}) \\<Longrightarrow>\n       x \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)", "from this"], ["proof (chain)\npicking this:\n  B \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n              {w +o \\<langle>R\\<rangle>})", "obtain R where R: \" R \\<in> (Pow S).\\<supseteq>T\" \"B = w +o \\<langle>R\\<rangle>\""], ["proof (prove)\nusing this:\n  B \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n              {w +o \\<langle>R\\<rangle>})\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>R \\<in> dual_order.below_in (Pow S) T;\n         B = w +o \\<langle>R\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R \\<in> dual_order.below_in (Pow S) T\n  B = w +o \\<langle>R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>}) \\<Longrightarrow>\n       x \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)", "moreover"], ["proof (state)\nthis:\n  R \\<in> dual_order.below_in (Pow S) T\n  B = w +o \\<langle>R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>}) \\<Longrightarrow>\n       x \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)", "hence \"B \\<supseteq> w +o \\<langle>T\\<rangle>\""], ["proof (prove)\nusing this:\n  R \\<in> dual_order.below_in (Pow S) T\n  B = w +o \\<langle>R\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq B (w +o \\<langle>T\\<rangle>)", "using genby_mono elt_set_plus_def[of w]"], ["proof (prove)\nusing this:\n  R \\<in> dual_order.below_in (Pow S) T\n  B = w +o \\<langle>R\\<rangle>\n  order.greater_eq ?S ?T \\<Longrightarrow>\n  order.greater_eq \\<langle>?S\\<rangle> \\<langle>?T\\<rangle>\n  w +o ?B = {c. \\<exists>b\\<in>?B. c = w + b}\n\ngoal (1 subgoal):\n 1. order.greater_eq B (w +o \\<langle>T\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  order.greater_eq B (w +o \\<langle>T\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) T.\n                   {w +o \\<langle>R\\<rangle>}) \\<Longrightarrow>\n       x \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)", "ultimately"], ["proof (chain)\npicking this:\n  R \\<in> dual_order.below_in (Pow S) T\n  B = w +o \\<langle>R\\<rangle>\n  order.greater_eq B (w +o \\<langle>T\\<rangle>)", "show \"B \\<in> special_cosets .\\<supseteq> (w +o \\<langle>T\\<rangle>)\""], ["proof (prove)\nusing this:\n  R \\<in> dual_order.below_in (Pow S) T\n  B = w +o \\<langle>R\\<rangle>\n  order.greater_eq B (w +o \\<langle>T\\<rangle>)\n\ngoal (1 subgoal):\n 1. B \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)", "using assms(1) special_cosetsI"], ["proof (prove)\nusing this:\n  R \\<in> dual_order.below_in (Pow S) T\n  B = w +o \\<langle>R\\<rangle>\n  order.greater_eq B (w +o \\<langle>T\\<rangle>)\n  w \\<in> W\n  \\<lbrakk>?T \\<in> Pow S; ?w \\<in> W\\<rbrakk>\n  \\<Longrightarrow> ?w +o \\<langle>?T\\<rangle> \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. B \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  B \\<in> dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas special_coset_inj\n  = comp_inj_on[OF special_subgroup_inj, OF inj_inj_on, OF lcoset_inj_on]"], ["", "lemma special_coset_eq_imp_eq_gensets:\n  \"\\<lbrakk> T1\\<in>Pow S; T2\\<in>Pow S; w1 +o \\<langle>T1\\<rangle> = w2 +o \\<langle>T2\\<rangle> \\<rbrakk> \\<Longrightarrow> T1=T2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>T1 \\<in> Pow S; T2 \\<in> Pow S;\n     w1 +o \\<langle>T1\\<rangle> = w2 +o \\<langle>T2\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> T1 = T2", "using set_plus_rearrange2[of \"-w1\" w1 \"\\<langle>T1\\<rangle>\"]\n        set_plus_rearrange2[of \"-w1\" w2 \"\\<langle>T2\\<rangle>\"]\n        genby_lcoset_subgroup_imp_eq_reps[of 0 T1 \"-w1+w2\" T2]\n        inj_onD[OF special_subgroup_inj]"], ["proof (prove)\nusing this:\n  - w1 +o (w1 +o \\<langle>T1\\<rangle>) = (- w1 + w1) +o \\<langle>T1\\<rangle>\n  - w1 +o (w2 +o \\<langle>T2\\<rangle>) = (- w1 + w2) +o \\<langle>T2\\<rangle>\n  order.greater_eq ((- w1 + w2) +o \\<langle>T2\\<rangle>)\n   ((0::'w) +o \\<langle>T1\\<rangle>) \\<Longrightarrow>\n  (- w1 + w2) +o \\<langle>T2\\<rangle> = (0::'w) +o \\<langle>T2\\<rangle>\n  \\<lbrakk>\\<langle>?x\\<rangle> = \\<langle>?y\\<rangle>; ?x \\<in> Pow S;\n   ?y \\<in> Pow S\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T1 \\<in> Pow S; T2 \\<in> Pow S;\n     w1 +o \\<langle>T1\\<rangle> = w2 +o \\<langle>T2\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> T1 = T2", "by    force"], ["", "lemma special_subgroup_special_coset_subset_ordering_iso:\n  \"subset_ordering_iso (genby ` Pow S) ((+o) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetIso dual_order.greater_eq dual_order.greater\n     dual_order.greater_eq dual_order.greater (genby ` Pow S) ((+o) w)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> genby ` Pow S; b \\<in> genby ` Pow S;\n        order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq (w +o b) (w +o a)\n 2. inj_on ((+o) w) (genby ` Pow S)\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> (+o) w ` genby ` Pow S;\n        b \\<in> (+o) w ` genby ` Pow S; order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq\n                          (the_inv_into (genby ` Pow S) ((+o) w) b)\n                          (the_inv_into (genby ` Pow S) ((+o) w) a)", "show \"\\<And>a b. a \\<subseteq> b \\<Longrightarrow> w +o a \\<subseteq> w +o b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       order.greater_eq b a \\<Longrightarrow>\n       order.greater_eq (w +o b) (w +o a)", "using elt_set_plus_def"], ["proof (prove)\nusing this:\n  ?a +o ?B = {c. \\<exists>b\\<in>?B. c = ?a + b}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       order.greater_eq b a \\<Longrightarrow>\n       order.greater_eq (w +o b) (w +o a)", "by auto"], ["proof (state)\nthis:\n  order.greater_eq ?b ?a \\<Longrightarrow>\n  order.greater_eq (w +o ?b) (w +o ?a)\n\ngoal (2 subgoals):\n 1. inj_on ((+o) w) (genby ` Pow S)\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> (+o) w ` genby ` Pow S;\n        b \\<in> (+o) w ` genby ` Pow S; order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq\n                          (the_inv_into (genby ` Pow S) ((+o) w) b)\n                          (the_inv_into (genby ` Pow S) ((+o) w) a)", "show 2: \"inj_on ((+o) w) (genby ` Pow S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((+o) w) (genby ` Pow S)", "using lcoset_inj_on inj_inj_on"], ["proof (prove)\nusing this:\n  inj ((+o) ?a)\n  inj ?f \\<Longrightarrow> inj_on ?f ?A\n\ngoal (1 subgoal):\n 1. inj_on ((+o) w) (genby ` Pow S)", "by fast"], ["proof (state)\nthis:\n  inj_on ((+o) w) (genby ` Pow S)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> (+o) w ` genby ` Pow S;\n        b \\<in> (+o) w ` genby ` Pow S; order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq\n                          (the_inv_into (genby ` Pow S) ((+o) w) b)\n                          (the_inv_into (genby ` Pow S) ((+o) w) a)", "show  \"\\<And>a b. a \\<in> (+o) w ` genby ` Pow S \\<Longrightarrow>\n          b \\<in> (+o) w ` genby ` Pow S \\<Longrightarrow>\n          a \\<subseteq> b \\<Longrightarrow>\n          the_inv_into (genby ` Pow S) ((+o) w) a \\<subseteq>\n            the_inv_into (genby ` Pow S) ((+o) w) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> (+o) w ` genby ` Pow S;\n        b \\<in> (+o) w ` genby ` Pow S; order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq\n                          (the_inv_into (genby ` Pow S) ((+o) w) b)\n                          (the_inv_into (genby ` Pow S) ((+o) w) a)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> (+o) w ` genby ` Pow S;\n        b \\<in> (+o) w ` genby ` Pow S; order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq\n                          (the_inv_into (genby ` Pow S) ((+o) w) b)\n                          (the_inv_into (genby ` Pow S) ((+o) w) a)", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> (+o) w ` genby ` Pow S;\n        b \\<in> (+o) w ` genby ` Pow S; order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq\n                          (the_inv_into (genby ` Pow S) ((+o) w) b)\n                          (the_inv_into (genby ` Pow S) ((+o) w) a)", "assume ab : \"a \\<in> (+o) w ` genby ` Pow S\" \"b \\<in> (+o) w ` genby ` Pow S\"\n      and  a_b: \"a\\<subseteq>b\""], ["proof (state)\nthis:\n  a \\<in> (+o) w ` genby ` Pow S\n  b \\<in> (+o) w ` genby ` Pow S\n  order.greater_eq b a\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> (+o) w ` genby ` Pow S;\n        b \\<in> (+o) w ` genby ` Pow S; order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq\n                          (the_inv_into (genby ` Pow S) ((+o) w) b)\n                          (the_inv_into (genby ` Pow S) ((+o) w) a)", "from ab"], ["proof (chain)\npicking this:\n  a \\<in> (+o) w ` genby ` Pow S\n  b \\<in> (+o) w ` genby ` Pow S", "obtain Ta Tb\n      where \"Ta\\<in>Pow S\" \"a = w +o \\<langle>Ta\\<rangle>\" \"Tb\\<in>Pow S\" \"b = w +o \\<langle>Tb\\<rangle>\""], ["proof (prove)\nusing this:\n  a \\<in> (+o) w ` genby ` Pow S\n  b \\<in> (+o) w ` genby ` Pow S\n\ngoal (1 subgoal):\n 1. (\\<And>Ta Tb.\n        \\<lbrakk>Ta \\<in> Pow S; a = w +o \\<langle>Ta\\<rangle>;\n         Tb \\<in> Pow S; b = w +o \\<langle>Tb\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  Ta \\<in> Pow S\n  a = w +o \\<langle>Ta\\<rangle>\n  Tb \\<in> Pow S\n  b = w +o \\<langle>Tb\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> (+o) w ` genby ` Pow S;\n        b \\<in> (+o) w ` genby ` Pow S; order.greater_eq b a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq\n                          (the_inv_into (genby ` Pow S) ((+o) w) b)\n                          (the_inv_into (genby ` Pow S) ((+o) w) a)", "with a_b"], ["proof (chain)\npicking this:\n  order.greater_eq b a\n  Ta \\<in> Pow S\n  a = w +o \\<langle>Ta\\<rangle>\n  Tb \\<in> Pow S\n  b = w +o \\<langle>Tb\\<rangle>", "show  \"the_inv_into (genby ` Pow S) ((+o) w) a \\<subseteq>\n              the_inv_into (genby ` Pow S) ((+o) w) b\""], ["proof (prove)\nusing this:\n  order.greater_eq b a\n  Ta \\<in> Pow S\n  a = w +o \\<langle>Ta\\<rangle>\n  Tb \\<in> Pow S\n  b = w +o \\<langle>Tb\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq (the_inv_into (genby ` Pow S) ((+o) w) b)\n     (the_inv_into (genby ` Pow S) ((+o) w) a)", "using the_inv_into_f_eq[OF 2] lcoset_eq_reps_subset[of w \"\\<langle>Ta\\<rangle>\" \"\\<langle>Tb\\<rangle>\"]"], ["proof (prove)\nusing this:\n  order.greater_eq b a\n  Ta \\<in> Pow S\n  a = w +o \\<langle>Ta\\<rangle>\n  Tb \\<in> Pow S\n  b = w +o \\<langle>Tb\\<rangle>\n  \\<lbrakk>w +o ?x = ?y; ?x \\<in> genby ` Pow S\\<rbrakk>\n  \\<Longrightarrow> the_inv_into (genby ` Pow S) ((+o) w) ?y = ?x\n  order.greater_eq (w +o \\<langle>Tb\\<rangle>)\n   (w +o \\<langle>Ta\\<rangle>) \\<Longrightarrow>\n  order.greater_eq \\<langle>Tb\\<rangle> \\<langle>Ta\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq (the_inv_into (genby ` Pow S) ((+o) w) b)\n     (the_inv_into (genby ` Pow S) ((+o) w) a)", "by    simp"], ["proof (state)\nthis:\n  order.greater_eq (the_inv_into (genby ` Pow S) ((+o) w) b)\n   (the_inv_into (genby ` Pow S) ((+o) w) a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> (+o) w ` genby ` Pow S; ?b \\<in> (+o) w ` genby ` Pow S;\n   order.greater_eq ?b ?a\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq\n                     (the_inv_into (genby ` Pow S) ((+o) w) ?b)\n                     (the_inv_into (genby ` Pow S) ((+o) w) ?a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma special_coset_subset_ordering_iso:\n  \"subset_ordering_iso (Pow S) ((+o) w \\<circ> genby)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetIso dual_order.greater_eq dual_order.greater\n     dual_order.greater_eq dual_order.greater (Pow S) ((+o) w \\<circ> genby)", "using special_subgroup_genby_subset_ordering_iso\n        special_subgroup_special_coset_subset_ordering_iso"], ["proof (prove)\nusing this:\n  OrderingSetIso dual_order.greater_eq dual_order.greater\n   dual_order.greater_eq dual_order.greater (Pow S) genby\n  OrderingSetIso dual_order.greater_eq dual_order.greater\n   dual_order.greater_eq dual_order.greater (genby ` Pow S) ((+o) ?w)\n\ngoal (1 subgoal):\n 1. OrderingSetIso dual_order.greater_eq dual_order.greater\n     dual_order.greater_eq dual_order.greater (Pow S) ((+o) w \\<circ> genby)", "by    (fast intro: OrderingSetIso.iso_comp)"], ["", "lemmas special_coset_subset_rev_mono =\n  OrderingSetIso.rev_ordsetmap[OF special_coset_subset_ordering_iso]"], ["", "lemma special_coset_below_in_subset_ordering_iso:\n  \"subset_ordering_iso ((Pow S).\\<supseteq>T) ((+o) w \\<circ> genby)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetIso dual_order.greater_eq dual_order.greater\n     dual_order.greater_eq dual_order.greater\n     (dual_order.below_in (Pow S) T) ((+o) w \\<circ> genby)", "using special_coset_subset_ordering_iso"], ["proof (prove)\nusing this:\n  OrderingSetIso dual_order.greater_eq dual_order.greater\n   dual_order.greater_eq dual_order.greater (Pow S) ((+o) ?w \\<circ> genby)\n\ngoal (1 subgoal):\n 1. OrderingSetIso dual_order.greater_eq dual_order.greater\n     dual_order.greater_eq dual_order.greater\n     (dual_order.below_in (Pow S) T) ((+o) w \\<circ> genby)", "by (auto intro: OrderingSetIso.iso_subset)"], ["", "lemma special_coset_below_in_supset_ordering_iso:\n  \"OrderingSetIso (\\<supseteq>) (\\<supset>) (\\<supseteq>) (\\<supset>) ((Pow S).\\<supseteq>T) ((+o) w \\<circ> genby)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrderingSetIso order.greater_eq order.greater order.greater_eq\n     order.greater (dual_order.below_in (Pow S) T) ((+o) w \\<circ> genby)", "using special_coset_below_in_subset_ordering_iso OrderingSetIso.iso_dual"], ["proof (prove)\nusing this:\n  OrderingSetIso dual_order.greater_eq dual_order.greater\n   dual_order.greater_eq dual_order.greater (dual_order.below_in (Pow S) ?T)\n   ((+o) ?w \\<circ> genby)\n  OrderingSetIso ?less_eq ?less ?less_eq' ?less' ?P ?f \\<Longrightarrow>\n  OrderingSetIso (\\<lambda>a b. ?less_eq b a) (\\<lambda>a b. ?less b a)\n   (\\<lambda>a b. ?less_eq' b a) (\\<lambda>a b. ?less' b a) ?P ?f\n\ngoal (1 subgoal):\n 1. OrderingSetIso order.greater_eq order.greater order.greater_eq\n     order.greater (dual_order.below_in (Pow S) T) ((+o) w \\<circ> genby)", "by fast"], ["", "lemma special_coset_pseudominimals:\n  assumes \"supset_pseudominimal_in \\<P> X\"\n  shows   \"\\<exists>w s. w\\<in>W \\<and> s\\<in>S \\<and> X = w +o \\<langle>S-{s}\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "from assms"], ["proof (chain)\npicking this:\n  dual_order.pseudominimal_in \\<P> X", "have \"X\\<in>\\<P>\""], ["proof (prove)\nusing this:\n  dual_order.pseudominimal_in \\<P> X\n\ngoal (1 subgoal):\n 1. X \\<in> \\<P>", "using supset_pseudominimal_inD1"], ["proof (prove)\nusing this:\n  dual_order.pseudominimal_in \\<P> X\n  dual_order.pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n\ngoal (1 subgoal):\n 1. X \\<in> \\<P>", "by fast"], ["proof (state)\nthis:\n  X \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "from this"], ["proof (chain)\npicking this:\n  X \\<in> \\<P>", "obtain w T where wT: \"w\\<in>W\" \"T\\<in>Pow S\" \"X = w +o \\<langle>T\\<rangle>\""], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>w T.\n        \\<lbrakk>w \\<in> W; T \\<in> Pow S;\n         X = w +o \\<langle>T\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using special_cosets_def"], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n  \\<P> \\<equiv>\n  \\<Union>T\\<in>Pow S. \\<Union>w\\<in>W. {w +o \\<langle>T\\<rangle>}\n\ngoal (1 subgoal):\n 1. (\\<And>w T.\n        \\<lbrakk>w \\<in> W; T \\<in> Pow S;\n         X = w +o \\<langle>T\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> W\n  T \\<in> Pow S\n  X = w +o \\<langle>T\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "proof (cases \"T=S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. T = S \\<Longrightarrow>\n    \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>\n 2. T \\<noteq> S \\<Longrightarrow>\n    \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "case True"], ["proof (state)\nthis:\n  T = S\n\ngoal (2 subgoals):\n 1. T = S \\<Longrightarrow>\n    \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>\n 2. T \\<noteq> S \\<Longrightarrow>\n    \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "with wT(1,3) assms"], ["proof (chain)\npicking this:\n  w \\<in> W\n  X = w +o \\<langle>T\\<rangle>\n  dual_order.pseudominimal_in \\<P> X\n  T = S", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<in> W\n  X = w +o \\<langle>T\\<rangle>\n  dual_order.pseudominimal_in \\<P> X\n  T = S\n\ngoal (1 subgoal):\n 1. \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "using genby_lcoset_el_reduce supset_pseudominimal_ne_bottom\n            special_cosets_bottom"], ["proof (prove)\nusing this:\n  w \\<in> W\n  X = w +o \\<langle>T\\<rangle>\n  dual_order.pseudominimal_in \\<P> X\n  T = S\n  ?a \\<in> \\<langle>?S\\<rangle> \\<Longrightarrow>\n  ?a +o \\<langle>?S\\<rangle> = \\<langle>?S\\<rangle>\n  dual_order.pseudominimal_in ?P ?x \\<Longrightarrow>\n  ?x \\<noteq> dual_order.bottom ?P\n  dual_order.bottom \\<P> = W\n\ngoal (1 subgoal):\n 1. \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "by    fast"], ["proof (state)\nthis:\n  \\<exists>w s.\n     w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. T \\<noteq> S \\<Longrightarrow>\n    \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. T \\<noteq> S \\<Longrightarrow>\n    \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "case False"], ["proof (state)\nthis:\n  T \\<noteq> S\n\ngoal (1 subgoal):\n 1. T \\<noteq> S \\<Longrightarrow>\n    \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "with wT(2)"], ["proof (chain)\npicking this:\n  T \\<in> Pow S\n  T \\<noteq> S", "obtain s where s: \"s\\<in>S\" \"T \\<subseteq> S-{s}\""], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  T \\<noteq> S\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> S; order.greater_eq (S - {s}) T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  s \\<in> S\n  order.greater_eq (S - {s}) T\n\ngoal (1 subgoal):\n 1. T \\<noteq> S \\<Longrightarrow>\n    \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "from s(2) wT(1,3) assms"], ["proof (chain)\npicking this:\n  order.greater_eq (S - {s}) T\n  w \\<in> W\n  X = w +o \\<langle>T\\<rangle>\n  dual_order.pseudominimal_in \\<P> X", "have \"X \\<subseteq> w +o \\<langle>S-{s}\\<rangle>\""], ["proof (prove)\nusing this:\n  order.greater_eq (S - {s}) T\n  w \\<in> W\n  X = w +o \\<langle>T\\<rangle>\n  dual_order.pseudominimal_in \\<P> X\n\ngoal (1 subgoal):\n 1. order.greater_eq (w +o \\<langle>S - {s}\\<rangle>) X", "using genby_mono"], ["proof (prove)\nusing this:\n  order.greater_eq (S - {s}) T\n  w \\<in> W\n  X = w +o \\<langle>T\\<rangle>\n  dual_order.pseudominimal_in \\<P> X\n  order.greater_eq ?S ?T \\<Longrightarrow>\n  order.greater_eq \\<langle>?S\\<rangle> \\<langle>?T\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq (w +o \\<langle>S - {s}\\<rangle>) X", "by auto"], ["proof (state)\nthis:\n  order.greater_eq (w +o \\<langle>S - {s}\\<rangle>) X\n\ngoal (1 subgoal):\n 1. T \\<noteq> S \\<Longrightarrow>\n    \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "moreover"], ["proof (state)\nthis:\n  order.greater_eq (w +o \\<langle>S - {s}\\<rangle>) X\n\ngoal (1 subgoal):\n 1. T \\<noteq> S \\<Longrightarrow>\n    \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "from assms wT(1) s(1)"], ["proof (chain)\npicking this:\n  dual_order.pseudominimal_in \\<P> X\n  w \\<in> W\n  s \\<in> S", "have \"\\<not> X \\<subset> w +o \\<langle>S-{s}\\<rangle>\""], ["proof (prove)\nusing this:\n  dual_order.pseudominimal_in \\<P> X\n  w \\<in> W\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> order.greater (w +o \\<langle>S - {s}\\<rangle>) X", "using special_cosetsI[of _ w]\n            supset_pseudominimal_inD2[of \\<P> X \"w +o \\<langle>S-{s}\\<rangle>\"]\n            lcoset_eq_reps[of w _ \"\\<langle>S\\<rangle>\"]\n            inj_onD[OF special_subgroup_inj, of \"S-{s}\" S]"], ["proof (prove)\nusing this:\n  dual_order.pseudominimal_in \\<P> X\n  w \\<in> W\n  s \\<in> S\n  \\<lbrakk>?T \\<in> Pow S; w \\<in> W\\<rbrakk>\n  \\<Longrightarrow> w +o \\<langle>?T\\<rangle> \\<in> \\<P>\n  \\<lbrakk>dual_order.pseudominimal_in \\<P> X;\n   w +o \\<langle>S - {s}\\<rangle> \\<in> \\<P>;\n   order.greater (w +o \\<langle>S - {s}\\<rangle>) X\\<rbrakk>\n  \\<Longrightarrow> w +o \\<langle>S - {s}\\<rangle> = dual_order.bottom \\<P>\n  w +o ?A = w +o W \\<Longrightarrow> ?A = W\n  \\<lbrakk>\\<langle>S - {s}\\<rangle> = W; S - {s} \\<in> Pow S;\n   S \\<in> Pow S\\<rbrakk>\n  \\<Longrightarrow> S - {s} = S\n\ngoal (1 subgoal):\n 1. \\<not> order.greater (w +o \\<langle>S - {s}\\<rangle>) X", "by    (auto simp add: special_cosets_bottom genby_lcoset_el_reduce)"], ["proof (state)\nthis:\n  \\<not> order.greater (w +o \\<langle>S - {s}\\<rangle>) X\n\ngoal (1 subgoal):\n 1. T \\<noteq> S \\<Longrightarrow>\n    \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  order.greater_eq (w +o \\<langle>S - {s}\\<rangle>) X\n  \\<not> order.greater (w +o \\<langle>S - {s}\\<rangle>) X", "show ?thesis"], ["proof (prove)\nusing this:\n  order.greater_eq (w +o \\<langle>S - {s}\\<rangle>) X\n  \\<not> order.greater (w +o \\<langle>S - {s}\\<rangle>) X\n\ngoal (1 subgoal):\n 1. \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "using wT(1) s(1)"], ["proof (prove)\nusing this:\n  order.greater_eq (w +o \\<langle>S - {s}\\<rangle>) X\n  \\<not> order.greater (w +o \\<langle>S - {s}\\<rangle>) X\n  w \\<in> W\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "by fast"], ["proof (state)\nthis:\n  \\<exists>w s.\n     w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w s.\n     w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma special_coset_pseudominimal_in_below_in:\n  assumes \"w\\<in>W\" \"T\\<in>Pow S\" \"supset_pseudominimal_in (\\<P>.\\<supseteq>(w +o \\<langle>T\\<rangle>)) X\"\n  shows   \"\\<exists>s\\<in>S-T. X = w +o \\<langle>S-{s}\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>S - T. X = w +o \\<langle>S - {s}\\<rangle>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>S - T. X = w +o \\<langle>S - {s}\\<rangle>", "from assms"], ["proof (chain)\npicking this:\n  w \\<in> W\n  T \\<in> Pow S\n  dual_order.pseudominimal_in\n   (dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)) X", "obtain v s where vs: \"v\\<in>W\" \"s\\<in>S\" \"X = v +o \\<langle>S-{s}\\<rangle>\""], ["proof (prove)\nusing this:\n  w \\<in> W\n  T \\<in> Pow S\n  dual_order.pseudominimal_in\n   (dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)) X\n\ngoal (1 subgoal):\n 1. (\\<And>v s.\n        \\<lbrakk>v \\<in> W; s \\<in> S;\n         X = v +o \\<langle>S - {s}\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using special_cosets_has_bottom special_cosetsI[of T w]\n          supset_has_bottom_pseudominimal_in_below_in\n          special_coset_pseudominimals"], ["proof (prove)\nusing this:\n  w \\<in> W\n  T \\<in> Pow S\n  dual_order.pseudominimal_in\n   (dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)) X\n  dual_order.has_bottom \\<P>\n  \\<lbrakk>T \\<in> Pow S; w \\<in> W\\<rbrakk>\n  \\<Longrightarrow> w +o \\<langle>T\\<rangle> \\<in> \\<P>\n  \\<lbrakk>dual_order.has_bottom ?P; ?x \\<in> ?P;\n   dual_order.pseudominimal_in (dual_order.below_in ?P ?x) ?y\\<rbrakk>\n  \\<Longrightarrow> dual_order.pseudominimal_in ?P ?y\n  dual_order.pseudominimal_in \\<P> ?X \\<Longrightarrow>\n  \\<exists>w s.\n     w \\<in> W \\<and> s \\<in> S \\<and> ?X = w +o \\<langle>S - {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>v s.\n        \\<lbrakk>v \\<in> W; s \\<in> S;\n         X = v +o \\<langle>S - {s}\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    force"], ["proof (state)\nthis:\n  v \\<in> W\n  s \\<in> S\n  X = v +o \\<langle>S - {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>S - T. X = w +o \\<langle>S - {s}\\<rangle>", "from assms(3)"], ["proof (chain)\npicking this:\n  dual_order.pseudominimal_in\n   (dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)) X", "have X: \"X \\<supseteq> w +o \\<langle>T\\<rangle>\""], ["proof (prove)\nusing this:\n  dual_order.pseudominimal_in\n   (dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)) X\n\ngoal (1 subgoal):\n 1. order.greater_eq X (w +o \\<langle>T\\<rangle>)", "using supset_pseudominimal_inD1"], ["proof (prove)\nusing this:\n  dual_order.pseudominimal_in\n   (dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)) X\n  dual_order.pseudominimal_in ?P ?x \\<Longrightarrow> ?x \\<in> ?P\n\ngoal (1 subgoal):\n 1. order.greater_eq X (w +o \\<langle>T\\<rangle>)", "by fast"], ["proof (state)\nthis:\n  order.greater_eq X (w +o \\<langle>T\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>S - T. X = w +o \\<langle>S - {s}\\<rangle>", "with vs(3)"], ["proof (chain)\npicking this:\n  X = v +o \\<langle>S - {s}\\<rangle>\n  order.greater_eq X (w +o \\<langle>T\\<rangle>)", "have 1: \"X = w +o \\<langle>S-{s}\\<rangle>\""], ["proof (prove)\nusing this:\n  X = v +o \\<langle>S - {s}\\<rangle>\n  order.greater_eq X (w +o \\<langle>T\\<rangle>)\n\ngoal (1 subgoal):\n 1. X = w +o \\<langle>S - {s}\\<rangle>", "using genby_lcoset_subgroup_imp_eq_reps[of w T v \"S-{s}\"]"], ["proof (prove)\nusing this:\n  X = v +o \\<langle>S - {s}\\<rangle>\n  order.greater_eq X (w +o \\<langle>T\\<rangle>)\n  order.greater_eq (v +o \\<langle>S - {s}\\<rangle>)\n   (w +o \\<langle>T\\<rangle>) \\<Longrightarrow>\n  v +o \\<langle>S - {s}\\<rangle> = w +o \\<langle>S - {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. X = w +o \\<langle>S - {s}\\<rangle>", "by fast"], ["proof (state)\nthis:\n  X = w +o \\<langle>S - {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>S - T. X = w +o \\<langle>S - {s}\\<rangle>", "with X assms"], ["proof (chain)\npicking this:\n  order.greater_eq X (w +o \\<langle>T\\<rangle>)\n  w \\<in> W\n  T \\<in> Pow S\n  dual_order.pseudominimal_in\n   (dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)) X\n  X = w +o \\<langle>S - {s}\\<rangle>", "have \"T \\<subseteq> S-{s}\""], ["proof (prove)\nusing this:\n  order.greater_eq X (w +o \\<langle>T\\<rangle>)\n  w \\<in> W\n  T \\<in> Pow S\n  dual_order.pseudominimal_in\n   (dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)) X\n  X = w +o \\<langle>S - {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq (S - {s}) T", "using special_cosetsI special_coset_subset_rev_mono[of T \"S-{s}\"]"], ["proof (prove)\nusing this:\n  order.greater_eq X (w +o \\<langle>T\\<rangle>)\n  w \\<in> W\n  T \\<in> Pow S\n  dual_order.pseudominimal_in\n   (dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>)) X\n  X = w +o \\<langle>S - {s}\\<rangle>\n  \\<lbrakk>?T \\<in> Pow S; ?w \\<in> W\\<rbrakk>\n  \\<Longrightarrow> ?w +o \\<langle>?T\\<rangle> \\<in> \\<P>\n  \\<lbrakk>T \\<in> Pow S; S - {s} \\<in> Pow S;\n   order.greater_eq (((+o) ?w \\<circ> genby) (S - {s}))\n    (((+o) ?w \\<circ> genby) T)\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (S - {s}) T\n\ngoal (1 subgoal):\n 1. order.greater_eq (S - {s}) T", "by    fastforce"], ["proof (state)\nthis:\n  order.greater_eq (S - {s}) T\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>S - T. X = w +o \\<langle>S - {s}\\<rangle>", "with vs(2)"], ["proof (chain)\npicking this:\n  s \\<in> S\n  order.greater_eq (S - {s}) T", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> S\n  order.greater_eq (S - {s}) T\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>S - T. X = w +o \\<langle>S - {s}\\<rangle>", "using 1"], ["proof (prove)\nusing this:\n  s \\<in> S\n  order.greater_eq (S - {s}) T\n  X = w +o \\<langle>S - {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>S - T. X = w +o \\<langle>S - {s}\\<rangle>", "by fast"], ["proof (state)\nthis:\n  \\<exists>s\\<in>S - T. X = w +o \\<langle>S - {s}\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exclude_one_is_pseudominimal:\n  assumes \"w\\<in>W\" \"t\\<in>S\"\n  shows   \"supset_pseudominimal_in \\<P> (w +o \\<langle>S-{t}\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_order.pseudominimal_in \\<P> (w +o \\<langle>S - {t}\\<rangle>)", "proof (rule supset_pseudominimal_inI, rule special_cosetsI)"], ["proof (state)\ngoal (4 subgoals):\n 1. S - {t} \\<in> Pow S\n 2. w \\<in> W\n 3. w +o \\<langle>S - {t}\\<rangle> \\<noteq> dual_order.bottom \\<P>\n 4. \\<And>z.\n       \\<lbrakk>z \\<in> \\<P>;\n        order.greater z (w +o \\<langle>S - {t}\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.bottom \\<P>", "show \"w \\<in> W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> W", "by fact"], ["proof (state)\nthis:\n  w \\<in> W\n\ngoal (3 subgoals):\n 1. S - {t} \\<in> Pow S\n 2. w +o \\<langle>S - {t}\\<rangle> \\<noteq> dual_order.bottom \\<P>\n 3. \\<And>z.\n       \\<lbrakk>z \\<in> \\<P>;\n        order.greater z (w +o \\<langle>S - {t}\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.bottom \\<P>", "from assms"], ["proof (chain)\npicking this:\n  w \\<in> W\n  t \\<in> S", "have \"w +o \\<langle>S - {t}\\<rangle> \\<noteq> W\""], ["proof (prove)\nusing this:\n  w \\<in> W\n  t \\<in> S\n\ngoal (1 subgoal):\n 1. w +o \\<langle>S - {t}\\<rangle> \\<noteq> W", "using genby_lcoset_el_reduce[of w] lcoset_eq_reps[of w _ W] \n          inj_onD[OF special_subgroup_inj, of \"S-{t}\" S]"], ["proof (prove)\nusing this:\n  w \\<in> W\n  t \\<in> S\n  w \\<in> \\<langle>?S\\<rangle> \\<Longrightarrow>\n  w +o \\<langle>?S\\<rangle> = \\<langle>?S\\<rangle>\n  w +o ?A = w +o W \\<Longrightarrow> ?A = W\n  \\<lbrakk>\\<langle>S - {t}\\<rangle> = W; S - {t} \\<in> Pow S;\n   S \\<in> Pow S\\<rbrakk>\n  \\<Longrightarrow> S - {t} = S\n\ngoal (1 subgoal):\n 1. w +o \\<langle>S - {t}\\<rangle> \\<noteq> W", "by    auto"], ["proof (state)\nthis:\n  w +o \\<langle>S - {t}\\<rangle> \\<noteq> W\n\ngoal (3 subgoals):\n 1. S - {t} \\<in> Pow S\n 2. w +o \\<langle>S - {t}\\<rangle> \\<noteq> dual_order.bottom \\<P>\n 3. \\<And>z.\n       \\<lbrakk>z \\<in> \\<P>;\n        order.greater z (w +o \\<langle>S - {t}\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.bottom \\<P>", "thus \"w +o \\<langle>S - {t}\\<rangle> \\<noteq> supset_bottom \\<P>\""], ["proof (prove)\nusing this:\n  w +o \\<langle>S - {t}\\<rangle> \\<noteq> W\n\ngoal (1 subgoal):\n 1. w +o \\<langle>S - {t}\\<rangle> \\<noteq> dual_order.bottom \\<P>", "using special_cosets_bottom"], ["proof (prove)\nusing this:\n  w +o \\<langle>S - {t}\\<rangle> \\<noteq> W\n  dual_order.bottom \\<P> = W\n\ngoal (1 subgoal):\n 1. w +o \\<langle>S - {t}\\<rangle> \\<noteq> dual_order.bottom \\<P>", "by fast"], ["proof (state)\nthis:\n  w +o \\<langle>S - {t}\\<rangle> \\<noteq> dual_order.bottom \\<P>\n\ngoal (2 subgoals):\n 1. S - {t} \\<in> Pow S\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> \\<P>;\n        order.greater z (w +o \\<langle>S - {t}\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.bottom \\<P>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. S - {t} \\<in> Pow S\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> \\<P>;\n        order.greater z (w +o \\<langle>S - {t}\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.bottom \\<P>", "fix X"], ["proof (state)\ngoal (2 subgoals):\n 1. S - {t} \\<in> Pow S\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> \\<P>;\n        order.greater z (w +o \\<langle>S - {t}\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.bottom \\<P>", "assume X: \"X\\<in>\\<P>\" \"w +o \\<langle>S - {t}\\<rangle> \\<subset> X\""], ["proof (state)\nthis:\n  X \\<in> \\<P>\n  order.greater X (w +o \\<langle>S - {t}\\<rangle>)\n\ngoal (2 subgoals):\n 1. S - {t} \\<in> Pow S\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> \\<P>;\n        order.greater z (w +o \\<langle>S - {t}\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.bottom \\<P>", "with assms(1)"], ["proof (chain)\npicking this:\n  w \\<in> W\n  X \\<in> \\<P>\n  order.greater X (w +o \\<langle>S - {t}\\<rangle>)", "have \"X \\<in> (\\<Union>R\\<in>(Pow S).\\<supseteq>(S-{t}). {w +o \\<langle>R\\<rangle>})\""], ["proof (prove)\nusing this:\n  w \\<in> W\n  X \\<in> \\<P>\n  order.greater X (w +o \\<langle>S - {t}\\<rangle>)\n\ngoal (1 subgoal):\n 1. X \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) (S - {t}).\n                {w +o \\<langle>R\\<rangle>})", "using subst[OF special_cosets_below_in, of w \"S-{t}\" \"\\<lambda>A. X\\<in>A\"]"], ["proof (prove)\nusing this:\n  w \\<in> W\n  X \\<in> \\<P>\n  order.greater X (w +o \\<langle>S - {t}\\<rangle>)\n  \\<lbrakk>w \\<in> W; S - {t} \\<in> Pow S;\n   X \\<in> dual_order.below_in \\<P>\n            (w +o \\<langle>S - {t}\\<rangle>)\\<rbrakk>\n  \\<Longrightarrow> X \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S)\n      (S - {t}).\n                                {w +o \\<langle>R\\<rangle>})\n\ngoal (1 subgoal):\n 1. X \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) (S - {t}).\n                {w +o \\<langle>R\\<rangle>})", "by fast"], ["proof (state)\nthis:\n  X \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) (S - {t}).\n              {w +o \\<langle>R\\<rangle>})\n\ngoal (2 subgoals):\n 1. S - {t} \\<in> Pow S\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> \\<P>;\n        order.greater z (w +o \\<langle>S - {t}\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.bottom \\<P>", "from this"], ["proof (chain)\npicking this:\n  X \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) (S - {t}).\n              {w +o \\<langle>R\\<rangle>})", "obtain R where R: \"R \\<in> (Pow S).\\<supseteq>(S-{t})\" \"X = w +o \\<langle>R\\<rangle>\""], ["proof (prove)\nusing this:\n  X \\<in> (\\<Union>R\\<in>dual_order.below_in (Pow S) (S - {t}).\n              {w +o \\<langle>R\\<rangle>})\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>R \\<in> dual_order.below_in (Pow S) (S - {t});\n         X = w +o \\<langle>R\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R \\<in> dual_order.below_in (Pow S) (S - {t})\n  X = w +o \\<langle>R\\<rangle>\n\ngoal (2 subgoals):\n 1. S - {t} \\<in> Pow S\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> \\<P>;\n        order.greater z (w +o \\<langle>S - {t}\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.bottom \\<P>", "from R(2) X(2)"], ["proof (chain)\npicking this:\n  X = w +o \\<langle>R\\<rangle>\n  order.greater X (w +o \\<langle>S - {t}\\<rangle>)", "have \"R \\<noteq> S-{t}\""], ["proof (prove)\nusing this:\n  X = w +o \\<langle>R\\<rangle>\n  order.greater X (w +o \\<langle>S - {t}\\<rangle>)\n\ngoal (1 subgoal):\n 1. R \\<noteq> S - {t}", "by fast"], ["proof (state)\nthis:\n  R \\<noteq> S - {t}\n\ngoal (2 subgoals):\n 1. S - {t} \\<in> Pow S\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> \\<P>;\n        order.greater z (w +o \\<langle>S - {t}\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.bottom \\<P>", "with R(1)"], ["proof (chain)\npicking this:\n  R \\<in> dual_order.below_in (Pow S) (S - {t})\n  R \\<noteq> S - {t}", "have \"R=S\""], ["proof (prove)\nusing this:\n  R \\<in> dual_order.below_in (Pow S) (S - {t})\n  R \\<noteq> S - {t}\n\ngoal (1 subgoal):\n 1. R = S", "by auto"], ["proof (state)\nthis:\n  R = S\n\ngoal (2 subgoals):\n 1. S - {t} \\<in> Pow S\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> \\<P>;\n        order.greater z (w +o \\<langle>S - {t}\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.bottom \\<P>", "with assms(1) R(2)"], ["proof (chain)\npicking this:\n  w \\<in> W\n  X = w +o \\<langle>R\\<rangle>\n  R = S", "show \"X = supset_bottom \\<P>\""], ["proof (prove)\nusing this:\n  w \\<in> W\n  X = w +o \\<langle>R\\<rangle>\n  R = S\n\ngoal (1 subgoal):\n 1. X = dual_order.bottom \\<P>", "using genby_lcoset_el_reduce special_cosets_bottom"], ["proof (prove)\nusing this:\n  w \\<in> W\n  X = w +o \\<langle>R\\<rangle>\n  R = S\n  ?a \\<in> \\<langle>?S\\<rangle> \\<Longrightarrow>\n  ?a +o \\<langle>?S\\<rangle> = \\<langle>?S\\<rangle>\n  dual_order.bottom \\<P> = W\n\ngoal (1 subgoal):\n 1. X = dual_order.bottom \\<P>", "by fast"], ["proof (state)\nthis:\n  X = dual_order.bottom \\<P>\n\ngoal (1 subgoal):\n 1. S - {t} \\<in> Pow S", "qed fast"], ["", "lemma exclude_one_is_pseudominimal_in_below_in:\n  \"\\<lbrakk> w\\<in>W; T\\<in>Pow S; s\\<in>S-T \\<rbrakk> \\<Longrightarrow>\n    supset_pseudominimal_in (\\<P>.\\<supseteq>(w +o \\<langle>T\\<rangle>)) (w +o \\<langle>S-{s}\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W; T \\<in> Pow S; s \\<in> S - T\\<rbrakk>\n    \\<Longrightarrow> dual_order.pseudominimal_in\n                       (dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>))\n                       (w +o \\<langle>S - {s}\\<rangle>)", "using special_cosets_has_bottom special_cosetsI\n        exclude_one_is_pseudominimal[of w s]\n        genby_mono[of T \"S-{s}\"]\n        supset_has_bottom_pseudominimal_in_below_inI[\n          of \\<P> \"w +o \\<langle>T\\<rangle>\" \"w +o \\<langle>S-{s}\\<rangle>\"\n        ]"], ["proof (prove)\nusing this:\n  dual_order.has_bottom \\<P>\n  \\<lbrakk>?T \\<in> Pow S; ?w \\<in> W\\<rbrakk>\n  \\<Longrightarrow> ?w +o \\<langle>?T\\<rangle> \\<in> \\<P>\n  \\<lbrakk>w \\<in> W; s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> dual_order.pseudominimal_in \\<P>\n                     (w +o \\<langle>S - {s}\\<rangle>)\n  order.greater_eq (S - {s}) T \\<Longrightarrow>\n  order.greater_eq \\<langle>S - {s}\\<rangle> \\<langle>T\\<rangle>\n  \\<lbrakk>dual_order.has_bottom \\<P>; w +o \\<langle>T\\<rangle> \\<in> \\<P>;\n   dual_order.pseudominimal_in \\<P> (w +o \\<langle>S - {s}\\<rangle>);\n   order.greater_eq (w +o \\<langle>S - {s}\\<rangle>)\n    (w +o \\<langle>T\\<rangle>)\\<rbrakk>\n  \\<Longrightarrow> dual_order.pseudominimal_in\n                     (dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>))\n                     (w +o \\<langle>S - {s}\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W; T \\<in> Pow S; s \\<in> S - T\\<rbrakk>\n    \\<Longrightarrow> dual_order.pseudominimal_in\n                       (dual_order.below_in \\<P> (w +o \\<langle>T\\<rangle>))\n                       (w +o \\<langle>S - {s}\\<rangle>)", "by    auto"], ["", "lemma glb_special_subset_coset:\n  assumes   wTT': \"w\\<in> W\" \"T \\<in> Pow S\" \"T' \\<in> Pow S\"\n  defines   U: \"U \\<equiv> T \\<union> T' \\<union> reduced_letter_set S w\"\n  shows     \"supset_glbound_in_of \\<P> \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>) \\<langle>U\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_order.glbound_in_of \\<P> \\<langle>T\\<rangle>\n     (w +o \\<langle>T'\\<rangle>) \\<langle>U\\<rangle>", "proof (rule supset_glbound_in_ofI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<langle>U\\<rangle> \\<in> \\<P>\n 2. dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n     \\<langle>U\\<rangle>\n 3. \\<And>a.\n       \\<lbrakk>a \\<in> \\<P>;\n        dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n         a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq a \\<langle>U\\<rangle>", "from wTT'(2,3) U"], ["proof (chain)\npicking this:\n  T \\<in> Pow S\n  T' \\<in> Pow S\n  U \\<equiv> T \\<union> T' \\<union> reduced_letter_set S w", "show \"\\<langle>U\\<rangle> \\<in> \\<P>\""], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  T' \\<in> Pow S\n  U \\<equiv> T \\<union> T' \\<union> reduced_letter_set S w\n\ngoal (1 subgoal):\n 1. \\<langle>U\\<rangle> \\<in> \\<P>", "using reduced_letter_set_subset[of S] special_subgroup_special_coset"], ["proof (prove)\nusing this:\n  T \\<in> Pow S\n  T' \\<in> Pow S\n  U \\<equiv> T \\<union> T' \\<union> reduced_letter_set S w\n  order.greater_eq S (reduced_letter_set S ?a)\n  ?T \\<in> Pow S \\<Longrightarrow> \\<langle>?T\\<rangle> \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. \\<langle>U\\<rangle> \\<in> \\<P>", "by simp"], ["proof (state)\nthis:\n  \\<langle>U\\<rangle> \\<in> \\<P>\n\ngoal (2 subgoals):\n 1. dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n     \\<langle>U\\<rangle>\n 2. \\<And>a.\n       \\<lbrakk>a \\<in> \\<P>;\n        dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n         a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq a \\<langle>U\\<rangle>", "show \"supset_lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>) \\<langle>U\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n     \\<langle>U\\<rangle>", "proof (rule supset_lbound_ofI)"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq \\<langle>U\\<rangle> \\<langle>T\\<rangle>\n 2. order.greater_eq \\<langle>U\\<rangle> (w +o \\<langle>T'\\<rangle>)", "from U"], ["proof (chain)\npicking this:\n  U \\<equiv> T \\<union> T' \\<union> reduced_letter_set S w", "show \"\\<langle>T\\<rangle> \\<subseteq> \\<langle>U\\<rangle>\""], ["proof (prove)\nusing this:\n  U \\<equiv> T \\<union> T' \\<union> reduced_letter_set S w\n\ngoal (1 subgoal):\n 1. order.greater_eq \\<langle>U\\<rangle> \\<langle>T\\<rangle>", "using genby_mono[of T U]"], ["proof (prove)\nusing this:\n  U \\<equiv> T \\<union> T' \\<union> reduced_letter_set S w\n  order.greater_eq U T \\<Longrightarrow>\n  order.greater_eq \\<langle>U\\<rangle> \\<langle>T\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq \\<langle>U\\<rangle> \\<langle>T\\<rangle>", "by fast"], ["proof (state)\nthis:\n  order.greater_eq \\<langle>U\\<rangle> \\<langle>T\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq \\<langle>U\\<rangle> (w +o \\<langle>T'\\<rangle>)", "show \"w +o \\<langle>T'\\<rangle> \\<subseteq> \\<langle>U\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq \\<langle>U\\<rangle> (w +o \\<langle>T'\\<rangle>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> w +o \\<langle>T'\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>U\\<rangle>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> w +o \\<langle>T'\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>U\\<rangle>", "assume \"x \\<in> w +o \\<langle>T'\\<rangle>\""], ["proof (state)\nthis:\n  x \\<in> w +o \\<langle>T'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> w +o \\<langle>T'\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>U\\<rangle>", "with wTT'(3)"], ["proof (chain)\npicking this:\n  T' \\<in> Pow S\n  x \\<in> w +o \\<langle>T'\\<rangle>", "obtain y where y: \"y \\<in> \\<langle>T'\\<rangle>\" \"x = w + y\""], ["proof (prove)\nusing this:\n  T' \\<in> Pow S\n  x \\<in> w +o \\<langle>T'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> \\<langle>T'\\<rangle>; x = w + y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using elt_set_plus_def[of w]"], ["proof (prove)\nusing this:\n  T' \\<in> Pow S\n  x \\<in> w +o \\<langle>T'\\<rangle>\n  w +o ?B = {c. \\<exists>b\\<in>?B. c = w + b}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> \\<langle>T'\\<rangle>; x = w + y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> \\<langle>T'\\<rangle>\n  x = w + y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> w +o \\<langle>T'\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>U\\<rangle>", "with wTT'(1) U"], ["proof (chain)\npicking this:\n  w \\<in> W\n  U \\<equiv> T \\<union> T' \\<union> reduced_letter_set S w\n  y \\<in> \\<langle>T'\\<rangle>\n  x = w + y", "show \"x \\<in> \\<langle>U\\<rangle>\""], ["proof (prove)\nusing this:\n  w \\<in> W\n  U \\<equiv> T \\<union> T' \\<union> reduced_letter_set S w\n  y \\<in> \\<langle>T'\\<rangle>\n  x = w + y\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>U\\<rangle>", "using in_genby_S_reduced_letter_set genby_mono[of _ U]\n              genby_mono[of T' U] genby_add_closed[of w U y]"], ["proof (prove)\nusing this:\n  w \\<in> W\n  U \\<equiv> T \\<union> T' \\<union> reduced_letter_set S w\n  y \\<in> \\<langle>T'\\<rangle>\n  x = w + y\n  \\<lbrakk>order.greater_eq S ?A; ?a \\<in> \\<langle>?A\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> \\<langle>reduced_letter_set ?A ?a\\<rangle>\n  order.greater_eq U ?T \\<Longrightarrow>\n  order.greater_eq \\<langle>U\\<rangle> \\<langle>?T\\<rangle>\n  order.greater_eq U T' \\<Longrightarrow>\n  order.greater_eq \\<langle>U\\<rangle> \\<langle>T'\\<rangle>\n  \\<lbrakk>w \\<in> \\<langle>U\\<rangle>; y \\<in> \\<langle>U\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> w + y \\<in> \\<langle>U\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>U\\<rangle>", "by    auto"], ["proof (state)\nthis:\n  x \\<in> \\<langle>U\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq \\<langle>U\\<rangle> (w +o \\<langle>T'\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n   \\<langle>U\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> \\<P>;\n        dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n         a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq a \\<langle>U\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> \\<P>;\n        dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n         a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq a \\<langle>U\\<rangle>", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> \\<P>;\n        dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n         a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq a \\<langle>U\\<rangle>", "assume X: \"X\\<in>\\<P>\" \"supset_lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>) X\""], ["proof (state)\nthis:\n  X \\<in> \\<P>\n  dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>) X\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> \\<P>;\n        dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n         a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq a \\<langle>U\\<rangle>", "from X(1)"], ["proof (chain)\npicking this:\n  X \\<in> \\<P>", "obtain v R where vR: \"R\\<in>Pow S\" \"X = v +o \\<langle>R\\<rangle>\""], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>R v.\n        \\<lbrakk>R \\<in> Pow S; X = v +o \\<langle>R\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using special_cosets_def"], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n  \\<P> \\<equiv>\n  \\<Union>T\\<in>Pow S. \\<Union>w\\<in>W. {w +o \\<langle>T\\<rangle>}\n\ngoal (1 subgoal):\n 1. (\\<And>R v.\n        \\<lbrakk>R \\<in> Pow S; X = v +o \\<langle>R\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R \\<in> Pow S\n  X = v +o \\<langle>R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> \\<P>;\n        dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n         a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq a \\<langle>U\\<rangle>", "from X(2)"], ["proof (chain)\npicking this:\n  dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>) X", "have X': \"X \\<supseteq> \\<langle>T\\<rangle>\" \"X \\<supseteq> w +o \\<langle>T'\\<rangle>\""], ["proof (prove)\nusing this:\n  dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>) X\n\ngoal (1 subgoal):\n 1. order.greater_eq X \\<langle>T\\<rangle> &&&\n    order.greater_eq X (w +o \\<langle>T'\\<rangle>)", "using supset_lbound_of_def[of _ _ X]"], ["proof (prove)\nusing this:\n  dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>) X\n  dual_order.lbound_of ?x ?y X \\<equiv>\n  order.greater_eq X ?x \\<and> order.greater_eq X ?y\n\ngoal (1 subgoal):\n 1. order.greater_eq X \\<langle>T\\<rangle> &&&\n    order.greater_eq X (w +o \\<langle>T'\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  order.greater_eq X \\<langle>T\\<rangle>\n  order.greater_eq X (w +o \\<langle>T'\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> \\<P>;\n        dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n         a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq a \\<langle>U\\<rangle>", "from X'(1) vR(2)"], ["proof (chain)\npicking this:\n  order.greater_eq X \\<langle>T\\<rangle>\n  X = v +o \\<langle>R\\<rangle>", "have R: \"X = \\<langle>R\\<rangle>\""], ["proof (prove)\nusing this:\n  order.greater_eq X \\<langle>T\\<rangle>\n  X = v +o \\<langle>R\\<rangle>\n\ngoal (1 subgoal):\n 1. X = \\<langle>R\\<rangle>", "using genby_0_closed genby_lcoset_el_reduce0"], ["proof (prove)\nusing this:\n  order.greater_eq X \\<langle>T\\<rangle>\n  X = v +o \\<langle>R\\<rangle>\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n  (0::?'g) \\<in> ?a +o \\<langle>?S\\<rangle> \\<Longrightarrow>\n  ?a +o \\<langle>?S\\<rangle> = \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. X = \\<langle>R\\<rangle>", "by fast"], ["proof (state)\nthis:\n  X = \\<langle>R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> \\<P>;\n        dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n         a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq a \\<langle>U\\<rangle>", "with X'(2)"], ["proof (chain)\npicking this:\n  order.greater_eq X (w +o \\<langle>T'\\<rangle>)\n  X = \\<langle>R\\<rangle>", "have w: \"w\\<in>\\<langle>R\\<rangle>\""], ["proof (prove)\nusing this:\n  order.greater_eq X (w +o \\<langle>T'\\<rangle>)\n  X = \\<langle>R\\<rangle>\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>R\\<rangle>", "using genby_0_closed lcoset_refl"], ["proof (prove)\nusing this:\n  order.greater_eq X (w +o \\<langle>T'\\<rangle>)\n  X = \\<langle>R\\<rangle>\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n  (0::?'a) \\<in> ?A \\<Longrightarrow> ?a \\<in> ?a +o ?A\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>R\\<rangle>", "by fast"], ["proof (state)\nthis:\n  w \\<in> \\<langle>R\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> \\<P>;\n        dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n         a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq a \\<langle>U\\<rangle>", "have \"T' \\<subseteq> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq R T'", "proof (\n    rule special_subgroup_genby_rev_mono, rule wTT'(3), rule vR(1), rule subsetI\n  )"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>T'\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>R\\<rangle>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>T'\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>R\\<rangle>", "assume \"x \\<in> \\<langle>T'\\<rangle>\""], ["proof (state)\nthis:\n  x \\<in> \\<langle>T'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<langle>T'\\<rangle> \\<Longrightarrow>\n       x \\<in> \\<langle>R\\<rangle>", "with X'(2) R"], ["proof (chain)\npicking this:\n  order.greater_eq X (w +o \\<langle>T'\\<rangle>)\n  X = \\<langle>R\\<rangle>\n  x \\<in> \\<langle>T'\\<rangle>", "show \"x \\<in> \\<langle>R\\<rangle>\""], ["proof (prove)\nusing this:\n  order.greater_eq X (w +o \\<langle>T'\\<rangle>)\n  X = \\<langle>R\\<rangle>\n  x \\<in> \\<langle>T'\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>R\\<rangle>", "using elt_set_plus_def[of w \"\\<langle>T'\\<rangle>\"] w genby_uminus_add_closed[of \"w\" R \"w+x\"]"], ["proof (prove)\nusing this:\n  order.greater_eq X (w +o \\<langle>T'\\<rangle>)\n  X = \\<langle>R\\<rangle>\n  x \\<in> \\<langle>T'\\<rangle>\n  w +o \\<langle>T'\\<rangle> =\n  {c. \\<exists>b\\<in>\\<langle>T'\\<rangle>. c = w + b}\n  w \\<in> \\<langle>R\\<rangle>\n  \\<lbrakk>w \\<in> \\<langle>R\\<rangle>;\n   w + x \\<in> \\<langle>R\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> - w + (w + x) \\<in> \\<langle>R\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>R\\<rangle>", "by    auto"], ["proof (state)\nthis:\n  x \\<in> \\<langle>R\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq R T'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> \\<P>;\n        dual_order.lbound_of \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>)\n         a\\<rbrakk>\n       \\<Longrightarrow> order.greater_eq a \\<langle>U\\<rangle>", "with X'(1) wTT'(2) vR(1)"], ["proof (chain)\npicking this:\n  order.greater_eq X \\<langle>T\\<rangle>\n  T \\<in> Pow S\n  R \\<in> Pow S\n  order.greater_eq R T'", "show \"\\<langle>U\\<rangle>\\<subseteq>X\""], ["proof (prove)\nusing this:\n  order.greater_eq X \\<langle>T\\<rangle>\n  T \\<in> Pow S\n  R \\<in> Pow S\n  order.greater_eq R T'\n\ngoal (1 subgoal):\n 1. order.greater_eq X \\<langle>U\\<rangle>", "using special_subgroup_genby_rev_mono[of T R] w smallest_genby U R\n          genby_mono[of _ R]"], ["proof (prove)\nusing this:\n  order.greater_eq X \\<langle>T\\<rangle>\n  T \\<in> Pow S\n  R \\<in> Pow S\n  order.greater_eq R T'\n  \\<lbrakk>T \\<in> Pow S; R \\<in> Pow S;\n   order.greater_eq \\<langle>R\\<rangle> \\<langle>T\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq R T\n  w \\<in> \\<langle>R\\<rangle>\n  \\<lbrakk>?T \\<in> Pow S; ?w \\<in> \\<langle>?T\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq ?T (reduced_letter_set S ?w)\n  U \\<equiv> T \\<union> T' \\<union> reduced_letter_set S w\n  X = \\<langle>R\\<rangle>\n  order.greater_eq R ?T \\<Longrightarrow>\n  order.greater_eq \\<langle>R\\<rangle> \\<langle>?T\\<rangle>\n\ngoal (1 subgoal):\n 1. order.greater_eq X \\<langle>U\\<rangle>", "by    simp"], ["proof (state)\nthis:\n  order.greater_eq X \\<langle>U\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma glb_special_subset_coset_ex:\n  assumes   \"w\\<in> W\" \"T \\<in> Pow S\" \"T' \\<in> Pow S\"\n  shows     \"\\<exists>B. supset_glbound_in_of \\<P> \\<langle>T\\<rangle> (w +o \\<langle>T'\\<rangle>) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B.\n       dual_order.glbound_in_of \\<P> \\<langle>T\\<rangle>\n        (w +o \\<langle>T'\\<rangle>) B", "using     glb_special_subset_coset[OF assms]"], ["proof (prove)\nusing this:\n  dual_order.glbound_in_of \\<P> \\<langle>T\\<rangle>\n   (w +o \\<langle>T'\\<rangle>)\n   \\<langle>T \\<union> T' \\<union> reduced_letter_set S w\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       dual_order.glbound_in_of \\<P> \\<langle>T\\<rangle>\n        (w +o \\<langle>T'\\<rangle>) B", "by        fast"], ["", "lemma special_cosets_have_glbs:\n  assumes \"X\\<in>\\<P>\" \"Y\\<in>\\<P>\"\n  shows   \"\\<exists>B. supset_glbound_in_of \\<P> X Y B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B. dual_order.glbound_in_of \\<P> X Y B", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>B. dual_order.glbound_in_of \\<P> X Y B", "from assms"], ["proof (chain)\npicking this:\n  X \\<in> \\<P>\n  Y \\<in> \\<P>", "obtain wx Tx wy Ty\n    where X: \"wx \\<in> W\" \"Tx \\<in> Pow S\" \"X = wx +o \\<langle>Tx\\<rangle>\"\n    and   Y: \"wy \\<in> W\" \"Ty \\<in> Pow S\" \"Y = wy +o \\<langle>Ty\\<rangle>\""], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n  Y \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>wx Tx wy Ty.\n        \\<lbrakk>wx \\<in> W; Tx \\<in> Pow S; X = wx +o \\<langle>Tx\\<rangle>;\n         wy \\<in> W; Ty \\<in> Pow S; Y = wy +o \\<langle>Ty\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using special_cosets_def"], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n  Y \\<in> \\<P>\n  \\<P> \\<equiv>\n  \\<Union>T\\<in>Pow S. \\<Union>w\\<in>W. {w +o \\<langle>T\\<rangle>}\n\ngoal (1 subgoal):\n 1. (\\<And>wx Tx wy Ty.\n        \\<lbrakk>wx \\<in> W; Tx \\<in> Pow S; X = wx +o \\<langle>Tx\\<rangle>;\n         wy \\<in> W; Ty \\<in> Pow S; Y = wy +o \\<langle>Ty\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  wx \\<in> W\n  Tx \\<in> Pow S\n  X = wx +o \\<langle>Tx\\<rangle>\n  wy \\<in> W\n  Ty \\<in> Pow S\n  Y = wy +o \\<langle>Ty\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>B. dual_order.glbound_in_of \\<P> X Y B", "from X(1,2) Y(1,2)"], ["proof (chain)\npicking this:\n  wx \\<in> W\n  Tx \\<in> Pow S\n  wy \\<in> W\n  Ty \\<in> Pow S", "obtain A\n    where A: \"supset_glbound_in_of \\<P> \\<langle>Tx\\<rangle> ((-wx+wy) +o \\<langle>Ty\\<rangle>) A\""], ["proof (prove)\nusing this:\n  wx \\<in> W\n  Tx \\<in> Pow S\n  wy \\<in> W\n  Ty \\<in> Pow S\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        dual_order.glbound_in_of \\<P> \\<langle>Tx\\<rangle>\n         ((- wx + wy) +o \\<langle>Ty\\<rangle>) A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using genby_uminus_add_closed[of wx] glb_special_subset_coset_ex"], ["proof (prove)\nusing this:\n  wx \\<in> W\n  Tx \\<in> Pow S\n  wy \\<in> W\n  Ty \\<in> Pow S\n  \\<lbrakk>wx \\<in> \\<langle>?S\\<rangle>;\n   ?h \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> - wx + ?h \\<in> \\<langle>?S\\<rangle>\n  \\<lbrakk>?w \\<in> W; ?T \\<in> Pow S; ?T' \\<in> Pow S\\<rbrakk>\n  \\<Longrightarrow> \\<exists>B.\n                       dual_order.glbound_in_of \\<P> \\<langle>?T\\<rangle>\n                        (?w +o \\<langle>?T'\\<rangle>) B\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        dual_order.glbound_in_of \\<P> \\<langle>Tx\\<rangle>\n         ((- wx + wy) +o \\<langle>Ty\\<rangle>) A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  dual_order.glbound_in_of \\<P> \\<langle>Tx\\<rangle>\n   ((- wx + wy) +o \\<langle>Ty\\<rangle>) A\n\ngoal (1 subgoal):\n 1. \\<exists>B. dual_order.glbound_in_of \\<P> X Y B", "from X(1,3) Y(3)"], ["proof (chain)\npicking this:\n  wx \\<in> W\n  X = wx +o \\<langle>Tx\\<rangle>\n  Y = wy +o \\<langle>Ty\\<rangle>", "have \"supset_glbound_in_of \\<P> X Y (wx +o A)\""], ["proof (prove)\nusing this:\n  wx \\<in> W\n  X = wx +o \\<langle>Tx\\<rangle>\n  Y = wy +o \\<langle>Ty\\<rangle>\n\ngoal (1 subgoal):\n 1. dual_order.glbound_in_of \\<P> X Y (wx +o A)", "using supset_glbound_in_of_lcoset_shift[OF A, of wx]"], ["proof (prove)\nusing this:\n  wx \\<in> W\n  X = wx +o \\<langle>Tx\\<rangle>\n  Y = wy +o \\<langle>Ty\\<rangle>\n  dual_order.glbound_in_of ((+o) wx ` \\<P>) (wx +o \\<langle>Tx\\<rangle>)\n   (wx +o ((- wx + wy) +o \\<langle>Ty\\<rangle>)) (wx +o A)\n\ngoal (1 subgoal):\n 1. dual_order.glbound_in_of \\<P> X Y (wx +o A)", "by    (auto simp add: set_plus_rearrange2 special_cosets_lcoset_shift)"], ["proof (state)\nthis:\n  dual_order.glbound_in_of \\<P> X Y (wx +o A)\n\ngoal (1 subgoal):\n 1. \\<exists>B. dual_order.glbound_in_of \\<P> X Y B", "thus ?thesis"], ["proof (prove)\nusing this:\n  dual_order.glbound_in_of \\<P> X Y (wx +o A)\n\ngoal (1 subgoal):\n 1. \\<exists>B. dual_order.glbound_in_of \\<P> X Y B", "by fast"], ["proof (state)\nthis:\n  \\<exists>B. dual_order.glbound_in_of \\<P> X Y B\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context PreCoxeterSystemWithDeletion *)"], ["", "subsection \\<open>Coxeter systems\\<close>"], ["", "subsubsection \\<open>Locale definition and transfer from the associated free group\\<close>"], ["", "text \\<open>\n  Now we consider groups generated by elements of order two with an additional assumption to ensure\n  that the natural correspondence between the group @{term W} and the group presentation on the\n  generating set @{term S} and its relations is bijective. Below, such groups will be shown to\n  satisfy the deletion condition.\n\\<close>"], ["", "locale CoxeterSystem = PreCoxeterSystem S\n  for S      :: \"'w::group_add set\"\n+ assumes induced_id_inj: \"inj_on induced_id G\""], ["", "lemma (in PreCoxeterSystem) CoxeterSystemI:\n  assumes \"\\<And>g. g\\<in>G \\<Longrightarrow> induced_id g = 0 \\<Longrightarrow> g=0\"\n  shows   \"CoxeterSystem S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CoxeterSystem S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>?g \\<in> Group.quotient_group (FreeGroup S)\n                     \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                 lconjby g `\n                                 Abs_freeword `\n                                 map (charpair S) ` R\\<rangle>;\n   GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id\n    ?g =\n   (0::'w)\\<rbrakk>\n  \\<Longrightarrow> ?g = 0", "have \"GroupIso G induced_id\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> Group.quotient_group (FreeGroup S)\n                     \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                 lconjby g `\n                                 Abs_freeword `\n                                 map (charpair S) ` R\\<rangle>;\n   GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id\n    ?g =\n   (0::'w)\\<rbrakk>\n  \\<Longrightarrow> ?g = 0\n\ngoal (1 subgoal):\n 1. GroupIso\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)", "using GroupWithGeneratorsRelators_S_R\n          GroupWithGeneratorsRelators.induced_id_hom_surj(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> Group.quotient_group (FreeGroup S)\n                     \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                 lconjby g `\n                                 Abs_freeword `\n                                 map (charpair S) ` R\\<rangle>;\n   GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id\n    ?g =\n   (0::'w)\\<rbrakk>\n  \\<Longrightarrow> ?g = 0\n  GroupWithGeneratorsRelators S R\n  GroupWithGeneratorsRelators ?S ?R \\<Longrightarrow>\n  GroupHom\n   (Group.quotient_group (FreeGroup ?S)\n     \\<langle>\\<Union>g\\<in>FreeGroup ?S.\n                 lconjby g ` Abs_freeword ` map (charpair ?S) ` ?R\\<rangle>)\n   (GroupByPresentationInducedFun.induced_hom ?S (map (charpair ?S) ` ?R)\n     id)\n\ngoal (1 subgoal):\n 1. GroupIso\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)", "by    (fast intro: GroupHom.isoI)"], ["proof (state)\nthis:\n  GroupIso\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S.\n                 lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n\ngoal (1 subgoal):\n 1. inj_on\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)", "thus \"inj_on induced_id G\""], ["proof (prove)\nusing this:\n  GroupIso\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S.\n                 lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n\ngoal (1 subgoal):\n 1. inj_on\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)", "using GroupIso.inj_on"], ["proof (prove)\nusing this:\n  GroupIso\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S.\n                 lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n  GroupIso ?G ?T \\<Longrightarrow> inj_on ?T ?G\n\ngoal (1 subgoal):\n 1. inj_on\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)", "by fast"], ["proof (state)\nthis:\n  inj_on\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n   (Group.quotient_group (FreeGroup S)\n     \\<langle>\\<Union>g\\<in>FreeGroup S.\n                 lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["", "context CoxeterSystem\nbegin"], ["", "abbreviation \"inv_induced_id \\<equiv> GroupPresentation.inv_induced_id S R\""], ["", "lemma GroupPresentation_S_R: \"GroupPresentation S R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GroupPresentation S R", "by  (\n        intro_locales, rule GroupWithGeneratorsRelators_S_R,\n        unfold_locales, rule induced_id_inj\n      )"], ["", "lemmas inv_induced_id_sum_list =\n  GroupPresentation.inv_induced_id_sum_list_S[OF GroupPresentation_S_R]"], ["", "end"], ["", "(* context CoxeterSystem *)"], ["", "subsubsection \\<open>The deletion condition is necessary\\<close>"], ["", "text \\<open>\n  Call an element of @{term W} a reflection if it is a conjugate of a generating element (and so\n  is also of order two). Here we use the action of words over @{term S} on such reflections to show\n  that Coxeter systems satisfy the deletion condition.\n\\<close>"], ["", "context CoxeterSystem\nbegin"], ["", "abbreviation \"induced_signed_lconjperm \\<equiv>\n  GroupByPresentationInducedFun.induced_hom S P signed_lconjpermutation\""], ["", "definition flipped_reflections :: \"'w \\<Rightarrow> 'w set\"\n  where \"flipped_reflections w \\<equiv>\n          {t\\<in>\\<H>. induced_signed_lconjperm (inv_induced_id (-w)) \\<rightarrow>\n            (t,True) = (rconjby w t, False)}\""], ["", "lemma induced_signed_lconjperm_inv_induced_id_sum_list:\n  \"ss \\<in> lists S \\<Longrightarrow> induced_signed_lconjperm (inv_induced_id (sum_list ss)) =\n          sum_list (map signed_lconjpermutation ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list ss)) =\n    sum_list (map signed_lconjpermutation ss)", "by  (simp add:\n        inv_induced_id_sum_list Abs_freelist_in_FreeGroup\n        GroupByPresentationInducedFun.induced_hom_Abs_freelist_conv_sum_list[\n          OF GroupByPresentationInducedFun_S_R_signed_lconjaction\n        ]\n      )"], ["", "lemma induced_signed_eq_lconjpermutation:\n  \"ss \\<in> lists S \\<Longrightarrow>\n    permutation (induced_signed_lconjperm (inv_induced_id (sum_list ss))) =\n      signed_list_lconjaction ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    (\\<rightarrow>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n       signed_lconjpermutation\n       (the_inv_into\n         (Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>)\n         (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n           id)\n         (sum_list ss))) =\n    signed_list_lconjaction ss", "proof (induct ss)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> lists S \\<Longrightarrow>\n    (\\<rightarrow>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n       signed_lconjpermutation\n       (the_inv_into\n         (Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>)\n         (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n           id)\n         (sum_list []))) =\n    signed_list_lconjaction []\n 2. \\<And>a ss.\n       \\<lbrakk>ss \\<in> lists S \\<Longrightarrow>\n                (\\<rightarrow>)\n                 (GroupByPresentationInducedFun.induced_hom S\n                   (map (charpair S) ` R) signed_lconjpermutation\n                   (the_inv_into\n                     (Group.quotient_group (FreeGroup S)\n                       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                   lconjby g `\n                                   Abs_freeword `\n                                   map (charpair S) ` R\\<rangle>)\n                     (GroupByPresentationInducedFun.induced_hom S\n                       (map (charpair S) ` R) id)\n                     (sum_list ss))) =\n                signed_list_lconjaction ss;\n        a # ss \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (GroupByPresentationInducedFun.induced_hom S\n                            (map (charpair S) ` R) signed_lconjpermutation\n                            (the_inv_into\n                              (Group.quotient_group (FreeGroup S)\n                                \\<langle>\\<Union>g\\<in>FreeGroup S.\n      lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n                              (GroupByPresentationInducedFun.induced_hom S\n                                (map (charpair S) ` R) id)\n                              (sum_list (a # ss)))) =\n                         signed_list_lconjaction (a # ss)", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> lists S\n\ngoal (2 subgoals):\n 1. [] \\<in> lists S \\<Longrightarrow>\n    (\\<rightarrow>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n       signed_lconjpermutation\n       (the_inv_into\n         (Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>)\n         (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n           id)\n         (sum_list []))) =\n    signed_list_lconjaction []\n 2. \\<And>a ss.\n       \\<lbrakk>ss \\<in> lists S \\<Longrightarrow>\n                (\\<rightarrow>)\n                 (GroupByPresentationInducedFun.induced_hom S\n                   (map (charpair S) ` R) signed_lconjpermutation\n                   (the_inv_into\n                     (Group.quotient_group (FreeGroup S)\n                       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                   lconjby g `\n                                   Abs_freeword `\n                                   map (charpair S) ` R\\<rangle>)\n                     (GroupByPresentationInducedFun.induced_hom S\n                       (map (charpair S) ` R) id)\n                     (sum_list ss))) =\n                signed_list_lconjaction ss;\n        a # ss \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (GroupByPresentationInducedFun.induced_hom S\n                            (map (charpair S) ` R) signed_lconjpermutation\n                            (the_inv_into\n                              (Group.quotient_group (FreeGroup S)\n                                \\<langle>\\<Union>g\\<in>FreeGroup S.\n      lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n                              (GroupByPresentationInducedFun.induced_hom S\n                                (map (charpair S) ` R) id)\n                              (sum_list (a # ss)))) =\n                         signed_list_lconjaction (a # ss)", "have \"permutation (induced_signed_lconjperm (inv_induced_id (sum_list []))) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<rightarrow>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n       signed_lconjpermutation\n       (the_inv_into\n         (Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>)\n         (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n           id)\n         (sum_list []))) =\n    id", "using induced_signed_lconjperm_inv_induced_id_sum_list[of \"[]\"]\n          zero_permutation.rep_eq"], ["proof (prove)\nusing this:\n  [] \\<in> lists S \\<Longrightarrow>\n  GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n   signed_lconjpermutation\n   (the_inv_into\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n     (sum_list [])) =\n  sum_list (map signed_lconjpermutation [])\n  (\\<rightarrow>) 0 = id\n\ngoal (1 subgoal):\n 1. (\\<rightarrow>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n       signed_lconjpermutation\n       (the_inv_into\n         (Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>)\n         (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n           id)\n         (sum_list []))) =\n    id", "by    simp"], ["proof (state)\nthis:\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list []))) =\n  id\n\ngoal (2 subgoals):\n 1. [] \\<in> lists S \\<Longrightarrow>\n    (\\<rightarrow>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n       signed_lconjpermutation\n       (the_inv_into\n         (Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>)\n         (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n           id)\n         (sum_list []))) =\n    signed_list_lconjaction []\n 2. \\<And>a ss.\n       \\<lbrakk>ss \\<in> lists S \\<Longrightarrow>\n                (\\<rightarrow>)\n                 (GroupByPresentationInducedFun.induced_hom S\n                   (map (charpair S) ` R) signed_lconjpermutation\n                   (the_inv_into\n                     (Group.quotient_group (FreeGroup S)\n                       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                   lconjby g `\n                                   Abs_freeword `\n                                   map (charpair S) ` R\\<rangle>)\n                     (GroupByPresentationInducedFun.induced_hom S\n                       (map (charpair S) ` R) id)\n                     (sum_list ss))) =\n                signed_list_lconjaction ss;\n        a # ss \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (GroupByPresentationInducedFun.induced_hom S\n                            (map (charpair S) ` R) signed_lconjpermutation\n                            (the_inv_into\n                              (Group.quotient_group (FreeGroup S)\n                                \\<langle>\\<Union>g\\<in>FreeGroup S.\n      lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n                              (GroupByPresentationInducedFun.induced_hom S\n                                (map (charpair S) ` R) id)\n                              (sum_list (a # ss)))) =\n                         signed_list_lconjaction (a # ss)", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list []))) =\n  id\n\ngoal (1 subgoal):\n 1. (\\<rightarrow>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n       signed_lconjpermutation\n       (the_inv_into\n         (Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>)\n         (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n           id)\n         (sum_list []))) =\n    signed_list_lconjaction []", "by fastforce"], ["proof (state)\nthis:\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list []))) =\n  signed_list_lconjaction []\n\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>ss \\<in> lists S \\<Longrightarrow>\n                (\\<rightarrow>)\n                 (GroupByPresentationInducedFun.induced_hom S\n                   (map (charpair S) ` R) signed_lconjpermutation\n                   (the_inv_into\n                     (Group.quotient_group (FreeGroup S)\n                       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                   lconjby g `\n                                   Abs_freeword `\n                                   map (charpair S) ` R\\<rangle>)\n                     (GroupByPresentationInducedFun.induced_hom S\n                       (map (charpair S) ` R) id)\n                     (sum_list ss))) =\n                signed_list_lconjaction ss;\n        a # ss \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (GroupByPresentationInducedFun.induced_hom S\n                            (map (charpair S) ` R) signed_lconjpermutation\n                            (the_inv_into\n                              (Group.quotient_group (FreeGroup S)\n                                \\<langle>\\<Union>g\\<in>FreeGroup S.\n      lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n                              (GroupByPresentationInducedFun.induced_hom S\n                                (map (charpair S) ` R) id)\n                              (sum_list (a # ss)))) =\n                         signed_list_lconjaction (a # ss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>ss \\<in> lists S \\<Longrightarrow>\n                (\\<rightarrow>)\n                 (GroupByPresentationInducedFun.induced_hom S\n                   (map (charpair S) ` R) signed_lconjpermutation\n                   (the_inv_into\n                     (Group.quotient_group (FreeGroup S)\n                       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                   lconjby g `\n                                   Abs_freeword `\n                                   map (charpair S) ` R\\<rangle>)\n                     (GroupByPresentationInducedFun.induced_hom S\n                       (map (charpair S) ` R) id)\n                     (sum_list ss))) =\n                signed_list_lconjaction ss;\n        a # ss \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (GroupByPresentationInducedFun.induced_hom S\n                            (map (charpair S) ` R) signed_lconjpermutation\n                            (the_inv_into\n                              (Group.quotient_group (FreeGroup S)\n                                \\<langle>\\<Union>g\\<in>FreeGroup S.\n      lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n                              (GroupByPresentationInducedFun.induced_hom S\n                                (map (charpair S) ` R) id)\n                              (sum_list (a # ss)))) =\n                         signed_list_lconjaction (a # ss)", "case (Cons s ss)"], ["proof (state)\nthis:\n  ss \\<in> lists S \\<Longrightarrow>\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list ss))) =\n  signed_list_lconjaction ss\n  s # ss \\<in> lists S\n\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>ss \\<in> lists S \\<Longrightarrow>\n                (\\<rightarrow>)\n                 (GroupByPresentationInducedFun.induced_hom S\n                   (map (charpair S) ` R) signed_lconjpermutation\n                   (the_inv_into\n                     (Group.quotient_group (FreeGroup S)\n                       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                   lconjby g `\n                                   Abs_freeword `\n                                   map (charpair S) ` R\\<rangle>)\n                     (GroupByPresentationInducedFun.induced_hom S\n                       (map (charpair S) ` R) id)\n                     (sum_list ss))) =\n                signed_list_lconjaction ss;\n        a # ss \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (GroupByPresentationInducedFun.induced_hom S\n                            (map (charpair S) ` R) signed_lconjpermutation\n                            (the_inv_into\n                              (Group.quotient_group (FreeGroup S)\n                                \\<langle>\\<Union>g\\<in>FreeGroup S.\n      lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n                              (GroupByPresentationInducedFun.induced_hom S\n                                (map (charpair S) ` R) id)\n                              (sum_list (a # ss)))) =\n                         signed_list_lconjaction (a # ss)", "from Cons(2)"], ["proof (chain)\npicking this:\n  s # ss \\<in> lists S", "have \"induced_signed_lconjperm (inv_induced_id (sum_list (s#ss))) =\n            signed_lconjpermutation s + sum_list (map signed_lconjpermutation ss)\""], ["proof (prove)\nusing this:\n  s # ss \\<in> lists S\n\ngoal (1 subgoal):\n 1. GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list (s # ss))) =\n    signed_lconjpermutation s + sum_list (map signed_lconjpermutation ss)", "using induced_signed_lconjperm_inv_induced_id_sum_list[of \"s#ss\"]"], ["proof (prove)\nusing this:\n  s # ss \\<in> lists S\n  s # ss \\<in> lists S \\<Longrightarrow>\n  GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n   signed_lconjpermutation\n   (the_inv_into\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n     (sum_list (s # ss))) =\n  sum_list (map signed_lconjpermutation (s # ss))\n\ngoal (1 subgoal):\n 1. GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list (s # ss))) =\n    signed_lconjpermutation s + sum_list (map signed_lconjpermutation ss)", "by    simp"], ["proof (state)\nthis:\n  GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n   signed_lconjpermutation\n   (the_inv_into\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n     (sum_list (s # ss))) =\n  signed_lconjpermutation s + sum_list (map signed_lconjpermutation ss)\n\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>ss \\<in> lists S \\<Longrightarrow>\n                (\\<rightarrow>)\n                 (GroupByPresentationInducedFun.induced_hom S\n                   (map (charpair S) ` R) signed_lconjpermutation\n                   (the_inv_into\n                     (Group.quotient_group (FreeGroup S)\n                       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                   lconjby g `\n                                   Abs_freeword `\n                                   map (charpair S) ` R\\<rangle>)\n                     (GroupByPresentationInducedFun.induced_hom S\n                       (map (charpair S) ` R) id)\n                     (sum_list ss))) =\n                signed_list_lconjaction ss;\n        a # ss \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (GroupByPresentationInducedFun.induced_hom S\n                            (map (charpair S) ` R) signed_lconjpermutation\n                            (the_inv_into\n                              (Group.quotient_group (FreeGroup S)\n                                \\<langle>\\<Union>g\\<in>FreeGroup S.\n      lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n                              (GroupByPresentationInducedFun.induced_hom S\n                                (map (charpair S) ` R) id)\n                              (sum_list (a # ss)))) =\n                         signed_list_lconjaction (a # ss)", "with Cons(2)"], ["proof (chain)\npicking this:\n  s # ss \\<in> lists S\n  GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n   signed_lconjpermutation\n   (the_inv_into\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n     (sum_list (s # ss))) =\n  signed_lconjpermutation s + sum_list (map signed_lconjpermutation ss)", "have\n    \"permutation (induced_signed_lconjperm (inv_induced_id (sum_list (s#ss)))) =\n      permutation (signed_lconjpermutation s) \\<circ>\n        permutation (induced_signed_lconjperm (inv_induced_id (sum_list ss)))\""], ["proof (prove)\nusing this:\n  s # ss \\<in> lists S\n  GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n   signed_lconjpermutation\n   (the_inv_into\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n     (sum_list (s # ss))) =\n  signed_lconjpermutation s + sum_list (map signed_lconjpermutation ss)\n\ngoal (1 subgoal):\n 1. (\\<rightarrow>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n       signed_lconjpermutation\n       (the_inv_into\n         (Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>)\n         (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n           id)\n         (sum_list (s # ss)))) =\n    (\\<rightarrow>) (signed_lconjpermutation s) \\<circ>\n    (\\<rightarrow>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n       signed_lconjpermutation\n       (the_inv_into\n         (Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>)\n         (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n           id)\n         (sum_list ss)))", "using plus_permutation.rep_eq induced_signed_lconjperm_inv_induced_id_sum_list"], ["proof (prove)\nusing this:\n  s # ss \\<in> lists S\n  GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n   signed_lconjpermutation\n   (the_inv_into\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n     (sum_list (s # ss))) =\n  signed_lconjpermutation s + sum_list (map signed_lconjpermutation ss)\n  (\\<rightarrow>) (?x + ?xa) =\n  (\\<rightarrow>) ?x \\<circ> (\\<rightarrow>) ?xa\n  ?ss \\<in> lists S \\<Longrightarrow>\n  GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n   signed_lconjpermutation\n   (the_inv_into\n     (Group.quotient_group (FreeGroup S)\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id)\n     (sum_list ?ss)) =\n  sum_list (map signed_lconjpermutation ?ss)\n\ngoal (1 subgoal):\n 1. (\\<rightarrow>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n       signed_lconjpermutation\n       (the_inv_into\n         (Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>)\n         (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n           id)\n         (sum_list (s # ss)))) =\n    (\\<rightarrow>) (signed_lconjpermutation s) \\<circ>\n    (\\<rightarrow>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n       signed_lconjpermutation\n       (the_inv_into\n         (Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>)\n         (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n           id)\n         (sum_list ss)))", "by    simp"], ["proof (state)\nthis:\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list (s # ss)))) =\n  (\\<rightarrow>) (signed_lconjpermutation s) \\<circ>\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list ss)))\n\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>ss \\<in> lists S \\<Longrightarrow>\n                (\\<rightarrow>)\n                 (GroupByPresentationInducedFun.induced_hom S\n                   (map (charpair S) ` R) signed_lconjpermutation\n                   (the_inv_into\n                     (Group.quotient_group (FreeGroup S)\n                       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                   lconjby g `\n                                   Abs_freeword `\n                                   map (charpair S) ` R\\<rangle>)\n                     (GroupByPresentationInducedFun.induced_hom S\n                       (map (charpair S) ` R) id)\n                     (sum_list ss))) =\n                signed_list_lconjaction ss;\n        a # ss \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> (\\<rightarrow>)\n                          (GroupByPresentationInducedFun.induced_hom S\n                            (map (charpair S) ` R) signed_lconjpermutation\n                            (the_inv_into\n                              (Group.quotient_group (FreeGroup S)\n                                \\<langle>\\<Union>g\\<in>FreeGroup S.\n      lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n                              (GroupByPresentationInducedFun.induced_hom S\n                                (map (charpair S) ` R) id)\n                              (sum_list (a # ss)))) =\n                         signed_list_lconjaction (a # ss)", "with Cons"], ["proof (chain)\npicking this:\n  ss \\<in> lists S \\<Longrightarrow>\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list ss))) =\n  signed_list_lconjaction ss\n  s # ss \\<in> lists S\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list (s # ss)))) =\n  (\\<rightarrow>) (signed_lconjpermutation s) \\<circ>\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list ss)))", "show ?case"], ["proof (prove)\nusing this:\n  ss \\<in> lists S \\<Longrightarrow>\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list ss))) =\n  signed_list_lconjaction ss\n  s # ss \\<in> lists S\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list (s # ss)))) =\n  (\\<rightarrow>) (signed_lconjpermutation s) \\<circ>\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list ss)))\n\ngoal (1 subgoal):\n 1. (\\<rightarrow>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n       signed_lconjpermutation\n       (the_inv_into\n         (Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>)\n         (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n           id)\n         (sum_list (s # ss)))) =\n    signed_list_lconjaction (s # ss)", "using bij_signed_lconjaction[of s] Abs_permutation_inverse"], ["proof (prove)\nusing this:\n  ss \\<in> lists S \\<Longrightarrow>\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list ss))) =\n  signed_list_lconjaction ss\n  s # ss \\<in> lists S\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list (s # ss)))) =\n  (\\<rightarrow>) (signed_lconjpermutation s) \\<circ>\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list ss)))\n  bij (signed_lconjaction s)\n  ?y \\<in> {f. bij f} \\<Longrightarrow>\n  (\\<rightarrow>) (Abs_permutation ?y) = ?y\n\ngoal (1 subgoal):\n 1. (\\<rightarrow>)\n     (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n       signed_lconjpermutation\n       (the_inv_into\n         (Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>)\n         (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n           id)\n         (sum_list (s # ss)))) =\n    signed_list_lconjaction (s # ss)", "by fastforce"], ["proof (state)\nthis:\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list (s # ss)))) =\n  signed_list_lconjaction (s # ss)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flipped_reflections_odd_lconjseq:\n  assumes \"ss\\<in>lists S\"\n  shows   \"flipped_reflections (sum_list ss) = {t\\<in>\\<H>. odd (count_list (lconjseq ss) t)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flipped_reflections (sum_list ss) =\n    {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n     \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> flipped_reflections (sum_list ss) \\<Longrightarrow>\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}\n 2. \\<And>x.\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t)\n                        2} \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> flipped_reflections (sum_list ss) \\<Longrightarrow>\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}\n 2. \\<And>x.\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t)\n                        2} \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "assume \"t \\<in> flipped_reflections (sum_list ss)\""], ["proof (state)\nthis:\n  t \\<in> flipped_reflections (sum_list ss)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> flipped_reflections (sum_list ss) \\<Longrightarrow>\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}\n 2. \\<And>x.\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t)\n                        2} \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "moreover"], ["proof (state)\nthis:\n  t \\<in> flipped_reflections (sum_list ss)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> flipped_reflections (sum_list ss) \\<Longrightarrow>\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}\n 2. \\<And>x.\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t)\n                        2} \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "with assms"], ["proof (chain)\npicking this:\n  ss \\<in> lists S\n  t \\<in> flipped_reflections (sum_list ss)", "have  \"snd (signed_list_lconjaction (rev ss) (t,True)) = False\""], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  t \\<in> flipped_reflections (sum_list ss)\n\ngoal (1 subgoal):\n 1. snd (signed_list_lconjaction (rev ss) (pairtrue t)) = False", "using flipped_reflections_def genset_order2_add uminus_sum_list_order2\n          induced_signed_eq_lconjpermutation[of \"rev ss\"]"], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  t \\<in> flipped_reflections (sum_list ss)\n  flipped_reflections ?w \\<equiv>\n  {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n   GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n    signed_lconjpermutation\n    (the_inv_into\n      (Group.quotient_group (FreeGroup S)\n        \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g `\n                    Abs_freeword ` map (charpair S) ` R\\<rangle>)\n      (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n        id)\n      (- ?w)) \\<rightarrow>\n   pairtrue t =\n   pairfalse (rconjby ?w t)}\n  ?s \\<in> S \\<Longrightarrow> ?s + ?s = (0::'w)\n  \\<forall>s\\<in>set ?ss. s + s = (0::?'a) \\<Longrightarrow>\n  - sum_list ?ss = sum_list (rev ?ss)\n  rev ss \\<in> lists S \\<Longrightarrow>\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list (rev ss)))) =\n  signed_list_lconjaction (rev ss)\n\ngoal (1 subgoal):\n 1. snd (signed_list_lconjaction (rev ss) (pairtrue t)) = False", "by    force"], ["proof (state)\nthis:\n  snd (signed_list_lconjaction (rev ss) (pairtrue t)) = False\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> flipped_reflections (sum_list ss) \\<Longrightarrow>\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}\n 2. \\<And>x.\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t)\n                        2} \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "ultimately"], ["proof (chain)\npicking this:\n  t \\<in> flipped_reflections (sum_list ss)\n  snd (signed_list_lconjaction (rev ss) (pairtrue t)) = False", "show \"t \\<in> {t\\<in>\\<H>. odd (count_list (lconjseq ss) t)}\""], ["proof (prove)\nusing this:\n  t \\<in> flipped_reflections (sum_list ss)\n  snd (signed_list_lconjaction (rev ss) (pairtrue t)) = False\n\ngoal (1 subgoal):\n 1. t \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n             \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}", "using assms flipped_reflections_def genset_order2_add\n          signed_list_lconjaction_snd[of \"rev ss\"]"], ["proof (prove)\nusing this:\n  t \\<in> flipped_reflections (sum_list ss)\n  snd (signed_list_lconjaction (rev ss) (pairtrue t)) = False\n  ss \\<in> lists S\n  flipped_reflections ?w \\<equiv>\n  {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n   GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n    signed_lconjpermutation\n    (the_inv_into\n      (Group.quotient_group (FreeGroup S)\n        \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g `\n                    Abs_freeword ` map (charpair S) ` R\\<rangle>)\n      (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n        id)\n      (- ?w)) \\<rightarrow>\n   pairtrue t =\n   pairfalse (rconjby ?w t)}\n  ?s \\<in> S \\<Longrightarrow> ?s + ?s = (0::'w)\n  \\<forall>s\\<in>set (rev ss). s + s = (0::'w) \\<Longrightarrow>\n  snd (signed_list_lconjaction (rev ss) ?x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev (rev ss))) (fst ?x)) 2\n   then snd ?x else \\<not> snd ?x)\n\ngoal (1 subgoal):\n 1. t \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n             \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}", "by    auto"], ["proof (state)\nthis:\n  t \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n           \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t)\n                        2} \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t)\n                        2} \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t)\n                        2} \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "assume t: \"t \\<in> {t\\<in>\\<H>. odd (count_list (lconjseq ss) t)}\""], ["proof (state)\nthis:\n  t \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n           \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t)\n                        2} \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "with assms"], ["proof (chain)\npicking this:\n  ss \\<in> lists S\n  t \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n           \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}", "have  \"signed_list_lconjaction (rev ss) (t,True) =\n            (rconjby (sum_list ss) t, False)\""], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  t \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n           \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}\n\ngoal (1 subgoal):\n 1. signed_list_lconjaction (rev ss) (pairtrue t) =\n    pairfalse (rconjby (sum_list ss) t)", "using genset_order2_add signed_list_lconjaction_snd[of \"rev ss\"]\n          signed_list_lconjaction_fst[of \"rev ss\"]\n          uminus_sum_list_order2[of ss, THEN sym]"], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  t \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n           \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}\n  ?s \\<in> S \\<Longrightarrow> ?s + ?s = (0::'w)\n  \\<forall>s\\<in>set (rev ss). s + s = (0::'w) \\<Longrightarrow>\n  snd (signed_list_lconjaction (rev ss) ?x) =\n  (if gcd_nat.greater_eq (count_list (lconjseq (rev (rev ss))) (fst ?x)) 2\n   then snd ?x else \\<not> snd ?x)\n  fst (signed_list_lconjaction (rev ss) ?x) =\n  lconjby (sum_list (rev ss)) (fst ?x)\n  \\<forall>s\\<in>set ss. s + s = (0::'w) \\<Longrightarrow>\n  sum_list (rev ss) = - sum_list ss\n\ngoal (1 subgoal):\n 1. signed_list_lconjaction (rev ss) (pairtrue t) =\n    pairfalse (rconjby (sum_list ss) t)", "by    (auto intro: prod_eqI)"], ["proof (state)\nthis:\n  signed_list_lconjaction (rev ss) (pairtrue t) =\n  pairfalse (rconjby (sum_list ss) t)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n                \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t)\n                        2} \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "with t assms"], ["proof (chain)\npicking this:\n  t \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n           \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}\n  ss \\<in> lists S\n  signed_list_lconjaction (rev ss) (pairtrue t) =\n  pairfalse (rconjby (sum_list ss) t)", "show \"t \\<in> flipped_reflections (sum_list ss)\""], ["proof (prove)\nusing this:\n  t \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n           \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}\n  ss \\<in> lists S\n  signed_list_lconjaction (rev ss) (pairtrue t) =\n  pairfalse (rconjby (sum_list ss) t)\n\ngoal (1 subgoal):\n 1. t \\<in> flipped_reflections (sum_list ss)", "using induced_signed_eq_lconjpermutation[of \"rev ss\"] genset_order2_add\n          uminus_sum_list_order2 flipped_reflections_def"], ["proof (prove)\nusing this:\n  t \\<in> {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n           \\<not> gcd_nat.greater_eq (count_list (lconjseq ss) t) 2}\n  ss \\<in> lists S\n  signed_list_lconjaction (rev ss) (pairtrue t) =\n  pairfalse (rconjby (sum_list ss) t)\n  rev ss \\<in> lists S \\<Longrightarrow>\n  (\\<rightarrow>)\n   (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n     signed_lconjpermutation\n     (the_inv_into\n       (Group.quotient_group (FreeGroup S)\n         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>)\n       (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id)\n       (sum_list (rev ss)))) =\n  signed_list_lconjaction (rev ss)\n  ?s \\<in> S \\<Longrightarrow> ?s + ?s = (0::'w)\n  \\<forall>s\\<in>set ?ss. s + s = (0::?'a) \\<Longrightarrow>\n  - sum_list ?ss = sum_list (rev ?ss)\n  flipped_reflections ?w \\<equiv>\n  {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n   GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n    signed_lconjpermutation\n    (the_inv_into\n      (Group.quotient_group (FreeGroup S)\n        \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g `\n                    Abs_freeword ` map (charpair S) ` R\\<rangle>)\n      (GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n        id)\n      (- ?w)) \\<rightarrow>\n   pairtrue t =\n   pairfalse (rconjby ?w t)}\n\ngoal (1 subgoal):\n 1. t \\<in> flipped_reflections (sum_list ss)", "by    fastforce"], ["proof (state)\nthis:\n  t \\<in> flipped_reflections (sum_list ss)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flipped_reflections_in_lconjseq:\n  \"ss\\<in>lists S \\<Longrightarrow> flipped_reflections (sum_list ss) \\<subseteq> set (lconjseq ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    order.greater_eq (set (lconjseq ss)) (flipped_reflections (sum_list ss))", "using flipped_reflections_odd_lconjseq odd_n0 count_notin[of _ \"lconjseq ss\"]"], ["proof (prove)\nusing this:\n  ?ss \\<in> lists S \\<Longrightarrow>\n  flipped_reflections (sum_list ?ss) =\n  {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n   \\<not> gcd_nat.greater_eq (count_list (lconjseq ?ss) t) 2}\n  odd ?m \\<Longrightarrow> ?m \\<noteq> (0::?'b)\n  ?x \\<notin> set (lconjseq ss) \\<Longrightarrow>\n  count_list (lconjseq ss) ?x = 0\n\ngoal (1 subgoal):\n 1. ss \\<in> lists S \\<Longrightarrow>\n    order.greater_eq (set (lconjseq ss)) (flipped_reflections (sum_list ss))", "by    fastforce"], ["", "lemma flipped_reflections_distinct_lconjseq_eq_lconjseq:\n  assumes \"ss\\<in>lists S\" \"distinct (lconjseq ss)\"\n  shows   \"flipped_reflections (sum_list ss) = set (lconjseq ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flipped_reflections (sum_list ss) = set (lconjseq ss)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq (set (lconjseq ss)) (flipped_reflections (sum_list ss))\n 2. order.greater_eq (flipped_reflections (sum_list ss)) (set (lconjseq ss))", "from assms(1)"], ["proof (chain)\npicking this:\n  ss \\<in> lists S", "show \"flipped_reflections (sum_list ss) \\<subseteq> set (lconjseq ss)\""], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n\ngoal (1 subgoal):\n 1. order.greater_eq (set (lconjseq ss)) (flipped_reflections (sum_list ss))", "using flipped_reflections_in_lconjseq"], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  ?ss \\<in> lists S \\<Longrightarrow>\n  order.greater_eq (set (lconjseq ?ss)) (flipped_reflections (sum_list ?ss))\n\ngoal (1 subgoal):\n 1. order.greater_eq (set (lconjseq ss)) (flipped_reflections (sum_list ss))", "by fast"], ["proof (state)\nthis:\n  order.greater_eq (set (lconjseq ss)) (flipped_reflections (sum_list ss))\n\ngoal (1 subgoal):\n 1. order.greater_eq (flipped_reflections (sum_list ss)) (set (lconjseq ss))", "show \"flipped_reflections (sum_list ss) \\<supseteq> set (lconjseq ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq (flipped_reflections (sum_list ss)) (set (lconjseq ss))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (lconjseq ss) \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (lconjseq ss) \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "assume \"t \\<in> set (lconjseq ss)\""], ["proof (state)\nthis:\n  t \\<in> set (lconjseq ss)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (lconjseq ss) \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "moreover"], ["proof (state)\nthis:\n  t \\<in> set (lconjseq ss)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (lconjseq ss) \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "with assms(2)"], ["proof (chain)\npicking this:\n  distinct (lconjseq ss)\n  t \\<in> set (lconjseq ss)", "have \"count_list (lconjseq ss) t = 1\""], ["proof (prove)\nusing this:\n  distinct (lconjseq ss)\n  t \\<in> set (lconjseq ss)\n\ngoal (1 subgoal):\n 1. count_list (lconjseq ss) t = 1", "by (simp add: distinct_count_list)"], ["proof (state)\nthis:\n  count_list (lconjseq ss) t = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (lconjseq ss) \\<Longrightarrow>\n       x \\<in> flipped_reflections (sum_list ss)", "ultimately"], ["proof (chain)\npicking this:\n  t \\<in> set (lconjseq ss)\n  count_list (lconjseq ss) t = 1", "show \"t \\<in> flipped_reflections (sum_list ss)\""], ["proof (prove)\nusing this:\n  t \\<in> set (lconjseq ss)\n  count_list (lconjseq ss) t = 1\n\ngoal (1 subgoal):\n 1. t \\<in> flipped_reflections (sum_list ss)", "using assms(1) flipped_reflections_odd_lconjseq lconjseq_reflections"], ["proof (prove)\nusing this:\n  t \\<in> set (lconjseq ss)\n  count_list (lconjseq ss) t = 1\n  ss \\<in> lists S\n  ?ss \\<in> lists S \\<Longrightarrow>\n  flipped_reflections (sum_list ?ss) =\n  {t \\<in> \\<Union>w\\<in>W. lconjby w ` S.\n   \\<not> gcd_nat.greater_eq (count_list (lconjseq ?ss) t) 2}\n  ?ss \\<in> lists S \\<Longrightarrow>\n  order.greater_eq (\\<Union>w\\<in>W. lconjby w ` S) (set (lconjseq ?ss))\n\ngoal (1 subgoal):\n 1. t \\<in> flipped_reflections (sum_list ss)", "by    fastforce"], ["proof (state)\nthis:\n  t \\<in> flipped_reflections (sum_list ss)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq (flipped_reflections (sum_list ss)) (set (lconjseq ss))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flipped_reflections_reduced_eq_lconjseq:\n  \"S_reduced ss \\<Longrightarrow> flipped_reflections (sum_list ss) = set (lconjseq ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S_reduced ss \\<Longrightarrow>\n    flipped_reflections (sum_list ss) = set (lconjseq ss)", "using reduced_word_for_lists[of S] S_reduced_imp_distinct_lconjseq\n        flipped_reflections_distinct_lconjseq_eq_lconjseq"], ["proof (prove)\nusing this:\n  S_reduced_for ?a ?as \\<Longrightarrow> ?as \\<in> lists S\n  S_reduced ?ss \\<Longrightarrow> distinct (lconjseq ?ss)\n  \\<lbrakk>?ss \\<in> lists S; distinct (lconjseq ?ss)\\<rbrakk>\n  \\<Longrightarrow> flipped_reflections (sum_list ?ss) = set (lconjseq ?ss)\n\ngoal (1 subgoal):\n 1. S_reduced ss \\<Longrightarrow>\n    flipped_reflections (sum_list ss) = set (lconjseq ss)", "by    fast"], ["", "lemma card_flipped_reflections:\n  assumes \"w\\<in>W\"\n  shows \"card (flipped_reflections w) = S_length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (flipped_reflections w) = S_length w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. card (flipped_reflections w) = S_length w", "define ss where \"ss = arg_min length (word_for S w)\""], ["proof (state)\nthis:\n  ss = arg_min length (word_for S w)\n\ngoal (1 subgoal):\n 1. card (flipped_reflections w) = S_length w", "with assms"], ["proof (chain)\npicking this:\n  w \\<in> W\n  ss = arg_min length (word_for S w)", "have \"S_reduced_for w ss\""], ["proof (prove)\nusing this:\n  w \\<in> W\n  ss = arg_min length (word_for S w)\n\ngoal (1 subgoal):\n 1. S_reduced_for w ss", "using genby_S_reduced_word_for_arg_min"], ["proof (prove)\nusing this:\n  w \\<in> W\n  ss = arg_min length (word_for S w)\n  \\<lbrakk>order.greater_eq S ?A; ?a \\<in> \\<langle>?A\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> reduced_word_for ?A ?a (arg_min length (word_for ?A ?a))\n\ngoal (1 subgoal):\n 1. S_reduced_for w ss", "by simp"], ["proof (state)\nthis:\n  S_reduced_for w ss\n\ngoal (1 subgoal):\n 1. card (flipped_reflections w) = S_length w", "thus ?thesis"], ["proof (prove)\nusing this:\n  S_reduced_for w ss\n\ngoal (1 subgoal):\n 1. card (flipped_reflections w) = S_length w", "using reduced_word_for_sum_list flipped_reflections_reduced_eq_lconjseq\n          S_reduced_imp_distinct_lconjseq distinct_card length_lconjseq[of ss]\n          reduced_word_for_length"], ["proof (prove)\nusing this:\n  S_reduced_for w ss\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> sum_list ?as = ?a\n  S_reduced ?ss \\<Longrightarrow>\n  flipped_reflections (sum_list ?ss) = set (lconjseq ?ss)\n  S_reduced ?ss \\<Longrightarrow> distinct (lconjseq ?ss)\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n  length (lconjseq ss) = length ss\n  reduced_word_for ?A ?a ?as \\<Longrightarrow>\n  length ?as = word_length ?A ?a\n\ngoal (1 subgoal):\n 1. card (flipped_reflections w) = S_length w", "by    fastforce"], ["proof (state)\nthis:\n  card (flipped_reflections w) = S_length w\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context CoxeterSystem *)"], ["", "sublocale CoxeterSystem < PreCoxeterSystemWithDeletion"], ["proof (prove)\ngoal (1 subgoal):\n 1. PreCoxeterSystemWithDeletion S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ss.\n       \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b as bs cs.\n                            ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                            sum_list ss = sum_list (as @ bs @ cs)", "fix ss"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ss.\n       \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b as bs cs.\n                            ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                            sum_list ss = sum_list (as @ bs @ cs)", "assume ss: \"ss \\<in> lists S\" \"\\<not> S_reduced ss\""], ["proof (state)\nthis:\n  ss \\<in> lists S\n  \\<not> S_reduced ss\n\ngoal (1 subgoal):\n 1. \\<And>ss.\n       \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b as bs cs.\n                            ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                            sum_list ss = sum_list (as @ bs @ cs)", "define w where \"w = sum_list ss\""], ["proof (state)\nthis:\n  w = sum_list ss\n\ngoal (1 subgoal):\n 1. \\<And>ss.\n       \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b as bs cs.\n                            ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                            sum_list ss = sum_list (as @ bs @ cs)", "with ss(1)"], ["proof (chain)\npicking this:\n  ss \\<in> lists S\n  w = sum_list ss", "have  \"distinct (lconjseq ss) \\<Longrightarrow> card (flipped_reflections w) = length ss\""], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  w = sum_list ss\n\ngoal (1 subgoal):\n 1. distinct (lconjseq ss) \\<Longrightarrow>\n    card (flipped_reflections w) = length ss", "by    (simp add:\n            flipped_reflections_distinct_lconjseq_eq_lconjseq distinct_card\n            length_lconjseq)"], ["proof (state)\nthis:\n  distinct (lconjseq ss) \\<Longrightarrow>\n  card (flipped_reflections w) = length ss\n\ngoal (1 subgoal):\n 1. \\<And>ss.\n       \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b as bs cs.\n                            ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                            sum_list ss = sum_list (as @ bs @ cs)", "moreover"], ["proof (state)\nthis:\n  distinct (lconjseq ss) \\<Longrightarrow>\n  card (flipped_reflections w) = length ss\n\ngoal (1 subgoal):\n 1. \\<And>ss.\n       \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b as bs cs.\n                            ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                            sum_list ss = sum_list (as @ bs @ cs)", "from w_def ss"], ["proof (chain)\npicking this:\n  w = sum_list ss\n  ss \\<in> lists S\n  \\<not> S_reduced ss", "have \"length ss > S_length w\""], ["proof (prove)\nusing this:\n  w = sum_list ss\n  ss \\<in> lists S\n  \\<not> S_reduced ss\n\ngoal (1 subgoal):\n 1. order.greater (length ss) (S_length w)", "using word_length_lt"], ["proof (prove)\nusing this:\n  w = sum_list ss\n  ss \\<in> lists S\n  \\<not> S_reduced ss\n  \\<lbrakk>?as \\<in> lists ?A; sum_list ?as = ?a;\n   \\<not> reduced_word_for ?A ?a ?as\\<rbrakk>\n  \\<Longrightarrow> order.greater (length ?as) (word_length ?A ?a)\n\ngoal (1 subgoal):\n 1. order.greater (length ss) (S_length w)", "by fast"], ["proof (state)\nthis:\n  order.greater (length ss) (S_length w)\n\ngoal (1 subgoal):\n 1. \\<And>ss.\n       \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b as bs cs.\n                            ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                            sum_list ss = sum_list (as @ bs @ cs)", "moreover"], ["proof (state)\nthis:\n  order.greater (length ss) (S_length w)\n\ngoal (1 subgoal):\n 1. \\<And>ss.\n       \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b as bs cs.\n                            ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                            sum_list ss = sum_list (as @ bs @ cs)", "from w_def ss(1)"], ["proof (chain)\npicking this:\n  w = sum_list ss\n  ss \\<in> lists S", "have \"card (flipped_reflections w) = S_length w\""], ["proof (prove)\nusing this:\n  w = sum_list ss\n  ss \\<in> lists S\n\ngoal (1 subgoal):\n 1. card (flipped_reflections w) = S_length w", "using special_subgroup_eq_sum_list card_flipped_reflections"], ["proof (prove)\nusing this:\n  w = sum_list ss\n  ss \\<in> lists S\n  order.greater_eq S ?S \\<Longrightarrow>\n  \\<langle>?S\\<rangle> = (\\<Union>ss\\<in>lists ?S. {sum_list ss})\n  ?w \\<in> W \\<Longrightarrow> card (flipped_reflections ?w) = S_length ?w\n\ngoal (1 subgoal):\n 1. card (flipped_reflections w) = S_length w", "by fast"], ["proof (state)\nthis:\n  card (flipped_reflections w) = S_length w\n\ngoal (1 subgoal):\n 1. \\<And>ss.\n       \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b as bs cs.\n                            ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                            sum_list ss = sum_list (as @ bs @ cs)", "ultimately"], ["proof (chain)\npicking this:\n  distinct (lconjseq ss) \\<Longrightarrow>\n  card (flipped_reflections w) = length ss\n  order.greater (length ss) (S_length w)\n  card (flipped_reflections w) = S_length w", "have \"\\<not> distinct (lconjseq ss)\""], ["proof (prove)\nusing this:\n  distinct (lconjseq ss) \\<Longrightarrow>\n  card (flipped_reflections w) = length ss\n  order.greater (length ss) (S_length w)\n  card (flipped_reflections w) = S_length w\n\ngoal (1 subgoal):\n 1. \\<not> distinct (lconjseq ss)", "by auto"], ["proof (state)\nthis:\n  \\<not> distinct (lconjseq ss)\n\ngoal (1 subgoal):\n 1. \\<And>ss.\n       \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b as bs cs.\n                            ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                            sum_list ss = sum_list (as @ bs @ cs)", "with w_def ss"], ["proof (chain)\npicking this:\n  w = sum_list ss\n  ss \\<in> lists S\n  \\<not> S_reduced ss\n  \\<not> distinct (lconjseq ss)", "show  \"\\<exists>a b as bs cs. ss = as @ [a] @ bs @ [b] @ cs \\<and>\n            sum_list ss = sum_list (as @ bs @ cs)\""], ["proof (prove)\nusing this:\n  w = sum_list ss\n  ss \\<in> lists S\n  \\<not> S_reduced ss\n  \\<not> distinct (lconjseq ss)\n\ngoal (1 subgoal):\n 1. \\<exists>a b as bs cs.\n       ss = as @ [a] @ bs @ [b] @ cs \\<and>\n       sum_list ss = sum_list (as @ bs @ cs)", "using deletion'"], ["proof (prove)\nusing this:\n  w = sum_list ss\n  ss \\<in> lists S\n  \\<not> S_reduced ss\n  \\<not> distinct (lconjseq ss)\n  \\<lbrakk>?ss \\<in> lists S; \\<not> distinct (lconjseq ?ss)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a b as bs cs.\n                       ?ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                       sum_list ?ss = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. \\<exists>a b as bs cs.\n       ss = as @ [a] @ bs @ [b] @ cs \\<and>\n       sum_list ss = sum_list (as @ bs @ cs)", "by    fast"], ["proof (state)\nthis:\n  \\<exists>a b as bs cs.\n     ss = as @ [a] @ bs @ [b] @ cs \\<and>\n     sum_list ss = sum_list (as @ bs @ cs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>The deletion condition is sufficient\\<close>"], ["", "text \\<open>\n  Now we come full circle and show that a pair consisting of a group and a generating set of\n  order-two elements that satisfies the deletion condition affords a presentation that makes it a\n  Coxeter system.\n\\<close>"], ["", "context PreCoxeterSystemWithDeletion\nbegin"], ["", "lemma reducible_by_flipping:\n  \"ss \\<in> lists S \\<Longrightarrow> \\<not> S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs. flip_altsublist_chain (ss # xss @ [as@[t,t]@bs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss as t bs.\n                         flip_altsublist_chain\n                          (ss # xss @ [as @ [t, t] @ bs])", "proof (induct ss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> lists S; \\<not> S_reduced []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss as t bs.\n                         flip_altsublist_chain\n                          ([] # xss @ [as @ [t, t] @ bs])\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xss as t bs.\n                                     flip_altsublist_chain\n(ss # xss @ [as @ [t, t] @ bs]);\n        a # ss \\<in> lists S; \\<not> S_reduced (a # ss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss as t bs.\n                            flip_altsublist_chain\n                             ((a # ss) # xss @ [as @ [t, t] @ bs])", "case (Cons s ss)"], ["proof (state)\nthis:\n  \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss as t bs.\n                       flip_altsublist_chain (ss # xss @ [as @ [t, t] @ bs])\n  s # ss \\<in> lists S\n  \\<not> S_reduced (s # ss)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> lists S; \\<not> S_reduced []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss as t bs.\n                         flip_altsublist_chain\n                          ([] # xss @ [as @ [t, t] @ bs])\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xss as t bs.\n                                     flip_altsublist_chain\n(ss # xss @ [as @ [t, t] @ bs]);\n        a # ss \\<in> lists S; \\<not> S_reduced (a # ss)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xss as t bs.\n                            flip_altsublist_chain\n                             ((a # ss) # xss @ [as @ [t, t] @ bs])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "proof (cases \"S_reduced ss\")"], ["proof (state)\ngoal (2 subgoals):\n 1. S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])\n 2. \\<not> S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "case True"], ["proof (state)\nthis:\n  S_reduced ss\n\ngoal (2 subgoals):\n 1. S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])\n 2. \\<not> S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "define w where \"w = sum_list ss\""], ["proof (state)\nthis:\n  w = sum_list ss\n\ngoal (2 subgoals):\n 1. S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])\n 2. \\<not> S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "with True"], ["proof (chain)\npicking this:\n  S_reduced ss\n  w = sum_list ss", "have ss_red_w: \"reduced_word_for S w ss\""], ["proof (prove)\nusing this:\n  S_reduced ss\n  w = sum_list ss\n\ngoal (1 subgoal):\n 1. S_reduced_for w ss", "by fast"], ["proof (state)\nthis:\n  S_reduced_for w ss\n\ngoal (2 subgoals):\n 1. S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])\n 2. \\<not> S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "moreover"], ["proof (state)\nthis:\n  S_reduced_for w ss\n\ngoal (2 subgoals):\n 1. S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])\n 2. \\<not> S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "from Cons(2)"], ["proof (chain)\npicking this:\n  s # ss \\<in> lists S", "have \"s\\<in>S\""], ["proof (prove)\nusing this:\n  s # ss \\<in> lists S\n\ngoal (1 subgoal):\n 1. s \\<in> S", "by simp"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (2 subgoals):\n 1. S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])\n 2. \\<not> S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "ultimately"], ["proof (chain)\npicking this:\n  S_reduced_for w ss\n  s \\<in> S", "obtain as bs where asbs: \"reduced_word_for S w (s#as@bs)\""], ["proof (prove)\nusing this:\n  S_reduced_for w ss\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        S_reduced_for w (s # as @ bs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Cons(3) exchange"], ["proof (prove)\nusing this:\n  S_reduced_for w ss\n  s \\<in> S\n  \\<not> S_reduced (s # ss)\n  \\<lbrakk>?s \\<in> S; S_reduced_for ?w ?ss;\n   \\<not> S_reduced (?s # ?ss)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t as bs.\n                       ?ss = as @ t # bs \\<and>\n                       S_reduced_for ?w (?s # as @ bs)\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        S_reduced_for w (s # as @ bs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  S_reduced_for w (s # as @ bs)\n\ngoal (2 subgoals):\n 1. S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])\n 2. \\<not> S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "proof (cases \"w=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = (0::'w) \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])\n 2. w \\<noteq> (0::'w) \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "case True"], ["proof (state)\nthis:\n  w = (0::'w)\n\ngoal (2 subgoals):\n 1. w = (0::'w) \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])\n 2. w \\<noteq> (0::'w) \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "with asbs"], ["proof (chain)\npicking this:\n  S_reduced_for w (s # as @ bs)\n  w = (0::'w)", "show ?thesis"], ["proof (prove)\nusing this:\n  S_reduced_for w (s # as @ bs)\n  w = (0::'w)\n\ngoal (1 subgoal):\n 1. \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "using reduced_word_for_0_imp_nil"], ["proof (prove)\nusing this:\n  S_reduced_for w (s # as @ bs)\n  w = (0::'w)\n  reduced_word_for ?A (0::?'a) ?as \\<Longrightarrow> ?as = []\n\ngoal (1 subgoal):\n 1. \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "by fast"], ["proof (state)\nthis:\n  \\<exists>xss as t bs.\n     flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])\n\ngoal (1 subgoal):\n 1. w \\<noteq> (0::'w) \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> (0::'w) \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "case False"], ["proof (state)\nthis:\n  w \\<noteq> (0::'w)\n\ngoal (1 subgoal):\n 1. w \\<noteq> (0::'w) \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "from this"], ["proof (chain)\npicking this:\n  w \\<noteq> (0::'w)", "obtain xss where \"flip_altsublist_chain (ss # xss @ [s#as@bs])\""], ["proof (prove)\nusing this:\n  w \\<noteq> (0::'w)\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        flip_altsublist_chain (ss # xss @ [s # as @ bs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ss_red_w asbs reduced_word_problem"], ["proof (prove)\nusing this:\n  w \\<noteq> (0::'w)\n  S_reduced_for w ss\n  S_reduced_for w (s # as @ bs)\n  \\<lbrakk>?w \\<noteq> (0::'w); S_reduced_for ?w ?ss;\n   S_reduced_for ?w ?ts\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss. flip_altsublist_chain (?ss # xss @ [?ts])\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        flip_altsublist_chain (ss # xss @ [s # as @ bs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  flip_altsublist_chain (ss # xss @ [s # as @ bs])\n\ngoal (1 subgoal):\n 1. w \\<noteq> (0::'w) \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "hence \"flip_altsublist_chain (\n              (s#ss) # map ((#) s) xss @ [[]@[s,s]@(as@bs)]\n            )\""], ["proof (prove)\nusing this:\n  flip_altsublist_chain (ss # xss @ [s # as @ bs])\n\ngoal (1 subgoal):\n 1. flip_altsublist_chain\n     ((s # ss) # map ((#) s) xss @ [[] @ [s, s] @ as @ bs])", "using flip_altsublist_chain_map_Cons_grow"], ["proof (prove)\nusing this:\n  flip_altsublist_chain (ss # xss @ [s # as @ bs])\n  flip_altsublist_chain ?tss \\<Longrightarrow>\n  flip_altsublist_chain (map ((#) ?t) ?tss)\n\ngoal (1 subgoal):\n 1. flip_altsublist_chain\n     ((s # ss) # map ((#) s) xss @ [[] @ [s, s] @ as @ bs])", "by fastforce"], ["proof (state)\nthis:\n  flip_altsublist_chain\n   ((s # ss) # map ((#) s) xss @ [[] @ [s, s] @ as @ bs])\n\ngoal (1 subgoal):\n 1. w \\<noteq> (0::'w) \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "thus ?thesis"], ["proof (prove)\nusing this:\n  flip_altsublist_chain\n   ((s # ss) # map ((#) s) xss @ [[] @ [s, s] @ as @ bs])\n\ngoal (1 subgoal):\n 1. \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "by fast"], ["proof (state)\nthis:\n  \\<exists>xss as t bs.\n     flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xss as t bs.\n     flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])\n\ngoal (1 subgoal):\n 1. \\<not> S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "case False"], ["proof (state)\nthis:\n  \\<not> S_reduced ss\n\ngoal (1 subgoal):\n 1. \\<not> S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "with Cons(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss as t bs.\n                       flip_altsublist_chain (ss # xss @ [as @ [t, t] @ bs])\n  s # ss \\<in> lists S\n  \\<not> S_reduced ss", "obtain xss as t bs\n      where \"flip_altsublist_chain (\n              (s#ss) # map ((#) s) xss @ [(s#as)@[t,t]@bs]\n            )\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss as t bs.\n                       flip_altsublist_chain (ss # xss @ [as @ [t, t] @ bs])\n  s # ss \\<in> lists S\n  \\<not> S_reduced ss\n\ngoal (1 subgoal):\n 1. (\\<And>xss as t bs.\n        flip_altsublist_chain\n         ((s # ss) #\n          map ((#) s) xss @ [(s # as) @ [t, t] @ bs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using flip_altsublist_chain_map_Cons_grow"], ["proof (prove)\nusing this:\n  \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss as t bs.\n                       flip_altsublist_chain (ss # xss @ [as @ [t, t] @ bs])\n  s # ss \\<in> lists S\n  \\<not> S_reduced ss\n  flip_altsublist_chain ?tss \\<Longrightarrow>\n  flip_altsublist_chain (map ((#) ?t) ?tss)\n\ngoal (1 subgoal):\n 1. (\\<And>xss as t bs.\n        flip_altsublist_chain\n         ((s # ss) #\n          map ((#) s) xss @ [(s # as) @ [t, t] @ bs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by    fastforce"], ["proof (state)\nthis:\n  flip_altsublist_chain\n   ((s # ss) # map ((#) s) xss @ [(s # as) @ [t, t] @ bs])\n\ngoal (1 subgoal):\n 1. \\<not> S_reduced ss \\<Longrightarrow>\n    \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "thus ?thesis"], ["proof (prove)\nusing this:\n  flip_altsublist_chain\n   ((s # ss) # map ((#) s) xss @ [(s # as) @ [t, t] @ bs])\n\ngoal (1 subgoal):\n 1. \\<exists>xss as t bs.\n       flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])", "by fast"], ["proof (state)\nthis:\n  \\<exists>xss as t bs.\n     flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xss as t bs.\n     flip_altsublist_chain ((s # ss) # xss @ [as @ [t, t] @ bs])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[] \\<in> lists S; \\<not> S_reduced []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xss as t bs.\n                         flip_altsublist_chain\n                          ([] # xss @ [as @ [t, t] @ bs])", "qed (simp add: nil_reduced_word_for_0)"], ["", "lemma freeliftid_kernel':\n  \"ss \\<in> lists S \\<Longrightarrow> sum_list ss = 0 \\<Longrightarrow> Abs_freelist ss \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<in> lists S; sum_list ss = (0::'w)\\<rbrakk>\n    \\<Longrightarrow> Abs_freelist ss\n                      \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n  lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "proof (induct ss rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   ys \\<in> lists S \\<longrightarrow>\n                   sum_list ys = (0::'w) \\<longrightarrow>\n                   Abs_freelist ys\n                   \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                     lconjby g `\n                                     Abs_freeword `\n                                     map (charpair S) ` R\\<rangle>;\n        xs \\<in> lists S; sum_list xs = (0::'w)\\<rbrakk>\n       \\<Longrightarrow> Abs_freelist xs\n                         \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n     lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "fix ss"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   ys \\<in> lists S \\<longrightarrow>\n                   sum_list ys = (0::'w) \\<longrightarrow>\n                   Abs_freelist ys\n                   \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                     lconjby g `\n                                     Abs_freeword `\n                                     map (charpair S) ` R\\<rangle>;\n        xs \\<in> lists S; sum_list xs = (0::'w)\\<rbrakk>\n       \\<Longrightarrow> Abs_freelist xs\n                         \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n     lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "assume step: \"\\<forall>ts. length ts < length ss \\<longrightarrow> ts \\<in> lists S \\<longrightarrow>\n                sum_list ts = 0 \\<longrightarrow> Abs_freelist ts \\<in> Q\"\n  and set_up: \"ss \\<in> lists S\" \"sum_list ss = 0\""], ["proof (state)\nthis:\n  \\<forall>ts.\n     order.greater (length ss) (length ts) \\<longrightarrow>\n     ts \\<in> lists S \\<longrightarrow>\n     sum_list ts = (0::'w) \\<longrightarrow>\n     Abs_freelist ts\n     \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n  ss \\<in> lists S\n  sum_list ss = (0::'w)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   order.greater (length xs) (length ys) \\<longrightarrow>\n                   ys \\<in> lists S \\<longrightarrow>\n                   sum_list ys = (0::'w) \\<longrightarrow>\n                   Abs_freelist ys\n                   \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                     lconjby g `\n                                     Abs_freeword `\n                                     map (charpair S) ` R\\<rangle>;\n        xs \\<in> lists S; sum_list xs = (0::'w)\\<rbrakk>\n       \\<Longrightarrow> Abs_freelist xs\n                         \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n     lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "show \"Abs_freelist ss \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "proof (cases \"ss=[]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ss = [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "case True"], ["proof (state)\nthis:\n  ss = []\n\ngoal (2 subgoals):\n 1. ss = [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>\n 2. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  ss = []\n\ngoal (1 subgoal):\n 1. Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "using genby_0_closed[of \"\\<Union>w\\<in>FreeGroup S. lconjby w ` P'\"]"], ["proof (prove)\nusing this:\n  ss = []\n  0 \\<in> \\<langle>\\<Union>w\\<in>FreeGroup S.\n                      lconjby w `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "by    (auto simp add: zero_freeword.abs_eq)"], ["proof (state)\nthis:\n  Abs_freelist ss\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "case False"], ["proof (state)\nthis:\n  ss \\<noteq> []\n\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "with set_up"], ["proof (chain)\npicking this:\n  ss \\<in> lists S\n  sum_list ss = (0::'w)\n  ss \\<noteq> []", "obtain xss as t bs\n      where xss: \"flip_altsublist_chain (ss # xss @ [as@[t,t]@bs])\""], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  sum_list ss = (0::'w)\n  ss \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>xss as t bs.\n        flip_altsublist_chain\n         (ss # xss @ [as @ [t, t] @ bs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using sum_list_zero_nreduced reducible_by_flipping[of ss]"], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  sum_list ss = (0::'w)\n  ss \\<noteq> []\n  \\<lbrakk>?as \\<noteq> []; sum_list ?as = (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> \\<not> reduced_word ?A ?as\n  \\<lbrakk>ss \\<in> lists S; \\<not> S_reduced ss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xss as t bs.\n                       flip_altsublist_chain (ss # xss @ [as @ [t, t] @ bs])\n\ngoal (1 subgoal):\n 1. (\\<And>xss as t bs.\n        flip_altsublist_chain\n         (ss # xss @ [as @ [t, t] @ bs]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  flip_altsublist_chain (ss # xss @ [as @ [t, t] @ bs])\n\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "with set_up"], ["proof (chain)\npicking this:\n  ss \\<in> lists S\n  sum_list ss = (0::'w)\n  flip_altsublist_chain (ss # xss @ [as @ [t, t] @ bs])", "have  astbs:  \"length (as@[t,t]@bs) = length ss\"\n                    \"as@[t,t]@bs \\<in> lists S\"\n                    \"sum_list (as@[t,t]@bs) = 0\""], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  sum_list ss = (0::'w)\n  flip_altsublist_chain (ss # xss @ [as @ [t, t] @ bs])\n\ngoal (1 subgoal):\n 1. length (as @ [t, t] @ bs) = length ss &&&\n    as @ [t, t] @ bs \\<in> lists S &&& sum_list (as @ [t, t] @ bs) = (0::'w)", "using flip_altsublist_chain_length[of ss xss \"as@[t,t]@bs\"]\n            flip_altsublist_chain_sum_list[of ss xss \"as@[t,t]@bs\"]\n            flip_altsublist_chain_lists[of ss xss \"as@[t,t]@bs\"]"], ["proof (prove)\nusing this:\n  ss \\<in> lists S\n  sum_list ss = (0::'w)\n  flip_altsublist_chain (ss # xss @ [as @ [t, t] @ bs])\n  flip_altsublist_chain (ss # xss @ [as @ [t, t] @ bs]) \\<Longrightarrow>\n  length (as @ [t, t] @ bs) = length ss\n  \\<lbrakk>ss \\<in> lists S;\n   flip_altsublist_chain (ss # xss @ [as @ [t, t] @ bs])\\<rbrakk>\n  \\<Longrightarrow> sum_list (as @ [t, t] @ bs) = sum_list ss\n  \\<lbrakk>ss \\<in> lists S;\n   flip_altsublist_chain (ss # xss @ [as @ [t, t] @ bs])\\<rbrakk>\n  \\<Longrightarrow> as @ [t, t] @ bs \\<in> lists S\n\ngoal (1 subgoal):\n 1. length (as @ [t, t] @ bs) = length ss &&&\n    as @ [t, t] @ bs \\<in> lists S &&& sum_list (as @ [t, t] @ bs) = (0::'w)", "by    auto"], ["proof (state)\nthis:\n  length (as @ [t, t] @ bs) = length ss\n  as @ [t, t] @ bs \\<in> lists S\n  sum_list (as @ [t, t] @ bs) = (0::'w)\n\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "have listsS: \"as \\<in> lists S\" \"t\\<in>S\" \"bs\\<in>lists S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<in> lists S &&& t \\<in> S &&& bs \\<in> lists S", "using astbs(2)"], ["proof (prove)\nusing this:\n  as @ [t, t] @ bs \\<in> lists S\n\ngoal (1 subgoal):\n 1. as \\<in> lists S &&& t \\<in> S &&& bs \\<in> lists S", "by auto"], ["proof (state)\nthis:\n  as \\<in> lists S\n  t \\<in> S\n  bs \\<in> lists S\n\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "have \"sum_list as + (t + t + sum_list bs) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list as + (t + t + sum_list bs) = (0::'w)", "using astbs(3)"], ["proof (prove)\nusing this:\n  sum_list (as @ [t, t] @ bs) = (0::'w)\n\ngoal (1 subgoal):\n 1. sum_list as + (t + t + sum_list bs) = (0::'w)", "by (simp add: add.assoc)"], ["proof (state)\nthis:\n  sum_list as + (t + t + sum_list bs) = (0::'w)\n\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "hence \"sum_list (as@bs) = 0\""], ["proof (prove)\nusing this:\n  sum_list as + (t + t + sum_list bs) = (0::'w)\n\ngoal (1 subgoal):\n 1. sum_list (as @ bs) = (0::'w)", "using listsS(2)"], ["proof (prove)\nusing this:\n  sum_list as + (t + t + sum_list bs) = (0::'w)\n  t \\<in> S\n\ngoal (1 subgoal):\n 1. sum_list (as @ bs) = (0::'w)", "by (simp add: genset_order2_add)"], ["proof (state)\nthis:\n  sum_list (as @ bs) = (0::'w)\n\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "moreover"], ["proof (state)\nthis:\n  sum_list (as @ bs) = (0::'w)\n\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "have \"length (as@bs) < length ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater (length ss) (length (as @ bs))", "using astbs(1)"], ["proof (prove)\nusing this:\n  length (as @ [t, t] @ bs) = length ss\n\ngoal (1 subgoal):\n 1. order.greater (length ss) (length (as @ bs))", "by simp"], ["proof (state)\nthis:\n  order.greater (length ss) (length (as @ bs))\n\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "moreover"], ["proof (state)\nthis:\n  order.greater (length ss) (length (as @ bs))\n\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "have \"as@bs \\<in> lists S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as @ bs \\<in> lists S", "using listsS(1,3)"], ["proof (prove)\nusing this:\n  as \\<in> lists S\n  bs \\<in> lists S\n\ngoal (1 subgoal):\n 1. as @ bs \\<in> lists S", "by simp"], ["proof (state)\nthis:\n  as @ bs \\<in> lists S\n\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  sum_list (as @ bs) = (0::'w)\n  order.greater (length ss) (length (as @ bs))\n  as @ bs \\<in> lists S", "have \"Abs_freelist (as@bs) \\<in> Q\""], ["proof (prove)\nusing this:\n  sum_list (as @ bs) = (0::'w)\n  order.greater (length ss) (length (as @ bs))\n  as @ bs \\<in> lists S\n\ngoal (1 subgoal):\n 1. Abs_freelist (as @ bs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "using step"], ["proof (prove)\nusing this:\n  sum_list (as @ bs) = (0::'w)\n  order.greater (length ss) (length (as @ bs))\n  as @ bs \\<in> lists S\n  \\<forall>ts.\n     order.greater (length ss) (length ts) \\<longrightarrow>\n     ts \\<in> lists S \\<longrightarrow>\n     sum_list ts = (0::'w) \\<longrightarrow>\n     Abs_freelist ts\n     \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. Abs_freelist (as @ bs)\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "by fast"], ["proof (state)\nthis:\n  Abs_freelist (as @ bs)\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "hence \"Abs_freelist as + pair_relator_freeword t t +\n            (- Abs_freelist as + (Abs_freelist as + Abs_freelist bs)) \\<in> Q\""], ["proof (prove)\nusing this:\n  Abs_freelist (as @ bs)\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. Abs_freelist as + pair_relator_freeword t t +\n    (- Abs_freelist as + (Abs_freelist as + Abs_freelist bs))\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "using listsS(1,2) lconjby_Abs_freelist_relator_freeword[of t t as]\n            genby_add_closed"], ["proof (prove)\nusing this:\n  Abs_freelist (as @ bs)\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  as \\<in> lists S\n  t \\<in> S\n  \\<lbrakk>t \\<in> S; t \\<in> S; as \\<in> lists S\\<rbrakk>\n  \\<Longrightarrow> lconjby (Abs_freelist as) (pair_relator_freeword t t)\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  \\<lbrakk>?g \\<in> \\<langle>?S\\<rangle>;\n   ?h \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?g + ?h \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. Abs_freelist as + pair_relator_freeword t t +\n    (- Abs_freelist as + (Abs_freelist as + Abs_freelist bs))\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "by    (simp add: Abs_freelist_append[THEN sym] add.assoc[THEN sym])"], ["proof (state)\nthis:\n  Abs_freelist as + pair_relator_freeword t t +\n  (- Abs_freelist as + (Abs_freelist as + Abs_freelist bs))\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "hence \"Abs_freelist as + Abs_freelist [t,t] + Abs_freelist bs \\<in> Q\""], ["proof (prove)\nusing this:\n  Abs_freelist as + pair_relator_freeword t t +\n  (- Abs_freelist as + (Abs_freelist as + Abs_freelist bs))\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. Abs_freelist as + Abs_freelist [t, t] + Abs_freelist bs\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "using listsS(2)"], ["proof (prove)\nusing this:\n  Abs_freelist as + pair_relator_freeword t t +\n  (- Abs_freelist as + (Abs_freelist as + Abs_freelist bs))\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  t \\<in> S\n\ngoal (1 subgoal):\n 1. Abs_freelist as + Abs_freelist [t, t] + Abs_freelist bs\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "by (simp add: S_relator_freeword Abs_freeletter_add)"], ["proof (state)\nthis:\n  Abs_freelist as + Abs_freelist [t, t] + Abs_freelist bs\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. ss \\<noteq> [] \\<Longrightarrow>\n    Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  Abs_freelist as + Abs_freelist [t, t] + Abs_freelist bs\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "using Abs_freelist_append_append[of as \"[t,t]\" bs]\n            rev_flip_altsublist_chain[OF xss]\n            flip_altsublist_chain_G_in_Q[of \"as@[t,t]@bs\" \"rev xss\" ss]"], ["proof (prove)\nusing this:\n  Abs_freelist as + Abs_freelist [t, t] + Abs_freelist bs\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  Abs_freelist (as @ [t, t] @ bs) =\n  Abs_freelist as + Abs_freelist [t, t] + Abs_freelist bs\n  flip_altsublist_chain (rev (ss # xss @ [as @ [t, t] @ bs]))\n  \\<lbrakk>Abs_freelist (as @ [t, t] @ bs)\n           \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                             lconjby g `\n                             Abs_freeword ` map (charpair S) ` R\\<rangle>;\n   flip_altsublist_chain ((as @ [t, t] @ bs) # rev xss @ [ss])\\<rbrakk>\n  \\<Longrightarrow> Abs_freelist ss\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. Abs_freelist ss\n    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>", "by    simp"], ["proof (state)\nthis:\n  Abs_freelist ss\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Abs_freelist ss\n  \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freeliftid_kernel:\n  assumes \"c \\<in> FreeGroup S\" \"freeliftid c = 0\"\n  shows   \"c\\<in>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                        lconjby g `\n                        Abs_freeword ` map (charpair S) ` R\\<rangle>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                        lconjby g `\n                        Abs_freeword ` map (charpair S) ` R\\<rangle>", "from assms(2)"], ["proof (chain)\npicking this:\n  freeword_funlift id c = (0::'w)", "have \"freeliftid (Abs_freeword (freeword c)) = 0\""], ["proof (prove)\nusing this:\n  freeword_funlift id c = (0::'w)\n\ngoal (1 subgoal):\n 1. freeword_funlift id (Abs_freeword (freeword c)) = (0::'w)", "by (simp add: freeword_inverse)"], ["proof (state)\nthis:\n  freeword_funlift id (Abs_freeword (freeword c)) = (0::'w)\n\ngoal (1 subgoal):\n 1. c \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                        lconjby g `\n                        Abs_freeword ` map (charpair S) ` R\\<rangle>", "with assms(1)"], ["proof (chain)\npicking this:\n  c \\<in> FreeGroup S\n  freeword_funlift id (Abs_freeword (freeword c)) = (0::'w)", "have \"sum_list (map fst (freeword c)) = 0\""], ["proof (prove)\nusing this:\n  c \\<in> FreeGroup S\n  freeword_funlift id (Abs_freeword (freeword c)) = (0::'w)\n\ngoal (1 subgoal):\n 1. sum_list (map fst (freeword c)) = (0::'w)", "using FreeGroup_def freeword freeliftid_Abs_freeword_conv_sum_list"], ["proof (prove)\nusing this:\n  c \\<in> FreeGroup S\n  freeword_funlift id (Abs_freeword (freeword c)) = (0::'w)\n  FreeGroup ?S \\<equiv> {x. order.greater_eq ?S (fst ` set (freeword x))}\n  freeword ?x \\<in> {as. proper_signed_list as}\n  \\<lbrakk>proper_signed_list ?xs;\n   order.greater_eq S (fst ` set ?xs)\\<rbrakk>\n  \\<Longrightarrow> freeword_funlift id (Abs_freeword ?xs) =\n                    sum_list (map fst ?xs)\n\ngoal (1 subgoal):\n 1. sum_list (map fst (freeword c)) = (0::'w)", "by fastforce"], ["proof (state)\nthis:\n  sum_list (map fst (freeword c)) = (0::'w)\n\ngoal (1 subgoal):\n 1. c \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                        lconjby g `\n                        Abs_freeword ` map (charpair S) ` R\\<rangle>", "with assms(1)"], ["proof (chain)\npicking this:\n  c \\<in> FreeGroup S\n  sum_list (map fst (freeword c)) = (0::'w)", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<in> FreeGroup S\n  sum_list (map fst (freeword c)) = (0::'w)\n\ngoal (1 subgoal):\n 1. c \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                        lconjby g `\n                        Abs_freeword ` map (charpair S) ` R\\<rangle>", "using FreeGroup_def freeliftid_kernel'[of \"map fst (freeword c)\"]\n          Q_freelist_freeword"], ["proof (prove)\nusing this:\n  c \\<in> FreeGroup S\n  sum_list (map fst (freeword c)) = (0::'w)\n  FreeGroup ?S \\<equiv> {x. order.greater_eq ?S (fst ` set (freeword x))}\n  \\<lbrakk>map fst (freeword c) \\<in> lists S;\n   sum_list (map fst (freeword c)) = (0::'w)\\<rbrakk>\n  \\<Longrightarrow> Abs_freelistfst (freeword c)\n                    \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\nlconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  \\<lbrakk>?c \\<in> FreeGroup S;\n   Abs_freelistfst (freeword ?c)\n   \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                     lconjby g `\n                     Abs_freeword ` map (charpair S) ` R\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. c \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                        lconjby g `\n                        Abs_freeword ` map (charpair S) ` R\\<rangle>", "by    fastforce"], ["proof (state)\nthis:\n  c \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma induced_id_kernel:\n  \"c \\<in> FreeGroup S \\<Longrightarrow> induced_id (\\<lceil>FreeGroup S|c|Q\\<rceil>) = 0 \\<Longrightarrow> c\\<in>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<in> FreeGroup S;\n     GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id\n      (BinOpSetGroup.Abs_G_perm\n        (FreeGroup S //\n         Restr\n          (lcoset_rel\n            \\<langle>\\<Union>g\\<in>FreeGroup S.\n                        lconjby g `\n                        Abs_freeword ` map (charpair S) ` R\\<rangle>)\n          (FreeGroup S))\n        (+)\n        (Restr\n          (lcoset_rel\n            \\<langle>\\<Union>g\\<in>FreeGroup S.\n                        lconjby g `\n                        Abs_freeword ` map (charpair S) ` R\\<rangle>)\n          (FreeGroup S) ``\n         {c})) =\n     (0::'w)\\<rbrakk>\n    \\<Longrightarrow> c \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n    lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>", "by  (simp add:\n        freeliftid_kernel\n        GroupByPresentationInducedFun.induced_hom_equality[\n          OF GroupByPresentationInducedFun_S_P_id\n        ]\n      )"], ["", "theorem CoxeterSystem: \"CoxeterSystem S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CoxeterSystem S", "proof (rule CoxeterSystemI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>g \\<in> Group.quotient_group (FreeGroup S)\n                         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                     lconjby g `\n                                     Abs_freeword `\n                                     map (charpair S) ` R\\<rangle>;\n        GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id g =\n        (0::'w)\\<rbrakk>\n       \\<Longrightarrow> g = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>g \\<in> Group.quotient_group (FreeGroup S)\n                         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                     lconjby g `\n                                     Abs_freeword `\n                                     map (charpair S) ` R\\<rangle>;\n        GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id g =\n        (0::'w)\\<rbrakk>\n       \\<Longrightarrow> g = 0", "assume x: \"x\\<in>G\" \"induced_id x = 0\""], ["proof (state)\nthis:\n  x \\<in> Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n  GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id x =\n  (0::'w)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>g \\<in> Group.quotient_group (FreeGroup S)\n                         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                     lconjby g `\n                                     Abs_freeword `\n                                     map (charpair S) ` R\\<rangle>;\n        GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id g =\n        (0::'w)\\<rbrakk>\n       \\<Longrightarrow> g = 0", "from x(1)"], ["proof (chain)\npicking this:\n  x \\<in> Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>", "obtain c where \"c \\<in> FreeGroup S\" \"x = (\\<lceil>FreeGroup S|c|Q\\<rceil>)\""], ["proof (prove)\nusing this:\n  x \\<in> Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> FreeGroup S;\n         x =\n         BinOpSetGroup.Abs_G_perm\n          (FreeGroup S //\n           Restr\n            (lcoset_rel\n              \\<langle>\\<Union>g\\<in>FreeGroup S.\n                          lconjby g `\n                          Abs_freeword ` map (charpair S) ` R\\<rangle>)\n            (FreeGroup S))\n          (+)\n          (Restr\n            (lcoset_rel\n              \\<langle>\\<Union>g\\<in>FreeGroup S.\n                          lconjby g `\n                          Abs_freeword ` map (charpair S) ` R\\<rangle>)\n            (FreeGroup S) ``\n           {c})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Group.quotient_group_UN FreeGroup_Group"], ["proof (prove)\nusing this:\n  x \\<in> Group.quotient_group (FreeGroup S)\n           \\<langle>\\<Union>g\\<in>FreeGroup S.\n                       lconjby g `\n                       Abs_freeword ` map (charpair S) ` R\\<rangle>\n  Group ?G \\<Longrightarrow>\n  Group.quotient_group ?G ?H =\n  (\\<lambda>g.\n      BinOpSetGroup.Abs_G_perm (?G // Restr (lcoset_rel ?H) ?G) (+)\n       (Restr (lcoset_rel ?H) ?G `` {g})) `\n  ?G\n  Group (FreeGroup ?S)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> FreeGroup S;\n         x =\n         BinOpSetGroup.Abs_G_perm\n          (FreeGroup S //\n           Restr\n            (lcoset_rel\n              \\<langle>\\<Union>g\\<in>FreeGroup S.\n                          lconjby g `\n                          Abs_freeword ` map (charpair S) ` R\\<rangle>)\n            (FreeGroup S))\n          (+)\n          (Restr\n            (lcoset_rel\n              \\<langle>\\<Union>g\\<in>FreeGroup S.\n                          lconjby g `\n                          Abs_freeword ` map (charpair S) ` R\\<rangle>)\n            (FreeGroup S) ``\n           {c})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  c \\<in> FreeGroup S\n  x =\n  BinOpSetGroup.Abs_G_perm\n   (FreeGroup S //\n    Restr\n     (lcoset_rel\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (FreeGroup S))\n   (+)\n   (Restr\n     (lcoset_rel\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (FreeGroup S) ``\n    {c})\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>g \\<in> Group.quotient_group (FreeGroup S)\n                         \\<langle>\\<Union>g\\<in>FreeGroup S.\n                                     lconjby g `\n                                     Abs_freeword `\n                                     map (charpair S) ` R\\<rangle>;\n        GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R)\n         id g =\n        (0::'w)\\<rbrakk>\n       \\<Longrightarrow> g = 0", "with x(2)"], ["proof (chain)\npicking this:\n  GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id x =\n  (0::'w)\n  c \\<in> FreeGroup S\n  x =\n  BinOpSetGroup.Abs_G_perm\n   (FreeGroup S //\n    Restr\n     (lcoset_rel\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (FreeGroup S))\n   (+)\n   (Restr\n     (lcoset_rel\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (FreeGroup S) ``\n    {c})", "show \"x=0\""], ["proof (prove)\nusing this:\n  GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id x =\n  (0::'w)\n  c \\<in> FreeGroup S\n  x =\n  BinOpSetGroup.Abs_G_perm\n   (FreeGroup S //\n    Restr\n     (lcoset_rel\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (FreeGroup S))\n   (+)\n   (Restr\n     (lcoset_rel\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (FreeGroup S) ``\n    {c})\n\ngoal (1 subgoal):\n 1. x = 0", "using induced_id_kernel\n          Group.quotient_identity_rule[OF FreeGroup_Group]\n          GroupByPresentation.Q_subgroup_FreeS[OF GroupByPresentation_S_P]\n          GroupByPresentation.normal_Q[OF GroupByPresentation_S_P]"], ["proof (prove)\nusing this:\n  GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id x =\n  (0::'w)\n  c \\<in> FreeGroup S\n  x =\n  BinOpSetGroup.Abs_G_perm\n   (FreeGroup S //\n    Restr\n     (lcoset_rel\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (FreeGroup S))\n   (+)\n   (Restr\n     (lcoset_rel\n       \\<langle>\\<Union>g\\<in>FreeGroup S.\n                   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>)\n     (FreeGroup S) ``\n    {c})\n  \\<lbrakk>?c \\<in> FreeGroup S;\n   GroupByPresentationInducedFun.induced_hom S (map (charpair S) ` R) id\n    (BinOpSetGroup.Abs_G_perm\n      (FreeGroup S //\n       Restr\n        (lcoset_rel\n          \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>)\n        (FreeGroup S))\n      (+)\n      (Restr\n        (lcoset_rel\n          \\<langle>\\<Union>g\\<in>FreeGroup S.\n                      lconjby g `\n                      Abs_freeword ` map (charpair S) ` R\\<rangle>)\n        (FreeGroup S) ``\n       {?c})) =\n   (0::'w)\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> \\<langle>\\<Union>g\\<in>FreeGroup S.\n   lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  \\<lbrakk>Group ?H \\<and> order.greater_eq (FreeGroup ?S1) ?H;\n   Group.normal (FreeGroup ?S1) ?H; ?h \\<in> ?H\\<rbrakk>\n  \\<Longrightarrow> BinOpSetGroup.Abs_G_perm\n                     (FreeGroup ?S1 //\n                      Restr (lcoset_rel ?H) (FreeGroup ?S1))\n                     (+) (Restr (lcoset_rel ?H) (FreeGroup ?S1) `` {?h}) =\n                    0\n  Group\n   \\<langle>\\<Union>h\\<in>FreeGroup S.\n               lconjby h `\n               Abs_freeword ` map (charpair S) ` R\\<rangle> \\<and>\n  order.greater_eq (FreeGroup S)\n   \\<langle>\\<Union>h\\<in>FreeGroup S.\n               lconjby h ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n  Group.normal (FreeGroup S)\n   \\<langle>\\<Union>g\\<in>FreeGroup S.\n               lconjby g ` Abs_freeword ` map (charpair S) ` R\\<rangle>\n\ngoal (1 subgoal):\n 1. x = 0", "by    auto"], ["proof (state)\nthis:\n  x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context PreCoxeterSystemWithDeletion *)"], ["", "subsubsection \\<open>The Coxeter system associated to a thin chamber complex with many foldings\\<close>"], ["", "text \\<open>\n  We now show that the fundamental automorphisms in a thin chamber complex with many foldings\n  satisfy the deletion condition, and hence form a Coxeter system.\n\\<close>"], ["", "context ThinChamberComplexManyFoldings\nbegin"], ["", "lemma not_reduced_word_not_min_gallery:\n  assumes \"ss \\<in> lists S\" \"\\<not> reduced_word S ss\"\n  shows   \"\\<not> min_gallery (map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "proof (cases ss rule: list_cases_Cons_snoc)"], ["proof (state)\ngoal (3 subgoals):\n 1. ss = [] \\<Longrightarrow>\n    \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 2. \\<And>x.\n       ss = [x] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 3. \\<And>x ys y.\n       ss = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "case Nil"], ["proof (state)\nthis:\n  ss = []\n\ngoal (3 subgoals):\n 1. ss = [] \\<Longrightarrow>\n    \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 2. \\<And>x.\n       ss = [x] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 3. \\<And>x ys y.\n       ss = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "with assms(2)"], ["proof (chain)\npicking this:\n  \\<not> reduced_word\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) ss\n  ss = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> reduced_word\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) ss\n  ss = []\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "using nil_reduced_word_for_0"], ["proof (prove)\nusing this:\n  \\<not> reduced_word\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) ss\n  ss = []\n  reduced_word_for ?A (0::?'a) []\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "by auto"], ["proof (state)\nthis:\n  \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ss = [x] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 2. \\<And>x ys y.\n       ss = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ss = [x] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 2. \\<And>x ys y.\n       ss = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "case (Single s)"], ["proof (state)\nthis:\n  ss = [s]\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ss = [x] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 2. \\<And>x ys y.\n       ss = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "with assms"], ["proof (chain)\npicking this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<not> reduced_word\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) ss\n  ss = [s]", "show ?thesis"], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<not> reduced_word\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) ss\n  ss = [s]\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "using zero_notin_S reduced_word_singleton[of s S]"], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<not> reduced_word\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) ss\n  ss = [s]\n  0 \\<notin> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g});\n   s \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> reduced_word\n                     (\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g})\n                     [s]\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "by fastforce"], ["proof (state)\nthis:\n  \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       ss = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       ss = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "case (Cons_snoc s ts t)"], ["proof (state)\nthis:\n  ss = s # ts @ [t]\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       ss = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "have ss: \"ss = s#ts@[t]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss = s # ts @ [t]", "by fact"], ["proof (state)\nthis:\n  ss = s # ts @ [t]\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       ss = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "define Ms where \"Ms = map (\\<lambda>w. w`\\<rightarrow>C0) (map ((+) s) (sums ts))\""], ["proof (state)\nthis:\n  Ms = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) s) (sums ts))\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       ss = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "with ss"], ["proof (chain)\npicking this:\n  ss = s # ts @ [t]\n  Ms = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) s) (sums ts))", "have  C0_ms_ss_C0: \"map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss) =\n                          C0 # Ms @ [sum_list ss `\\<rightarrow> C0]\""], ["proof (prove)\nusing this:\n  ss = s # ts @ [t]\n  Ms = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) s) (sums ts))\n\ngoal (1 subgoal):\n 1. map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss) =\n    C0 # Ms @ [sum_list ss `\\<rightarrow> C0]", "by    (simp add: sums_snoc zero_permutation.rep_eq)"], ["proof (state)\nthis:\n  map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss) =\n  C0 # Ms @ [sum_list ss `\\<rightarrow> C0]\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       ss = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "define rs where \"rs = arg_min length (word_for S (sum_list ss))\""], ["proof (state)\nthis:\n  rs =\n  arg_min length\n   (word_for (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (sum_list ss))\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       ss = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "with assms(1)"], ["proof (chain)\npicking this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  rs =\n  arg_min length\n   (word_for (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (sum_list ss))", "have rs: \"rs \\<in> lists S\" \"sum_list rs = sum_list ss\""], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  rs =\n  arg_min length\n   (word_for (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (sum_list ss))\n\ngoal (1 subgoal):\n 1. rs \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) &&&\n    sum_list rs = sum_list ss", "using arg_min_natI[of \"\\<lambda>rs. word_for S (sum_list ss) rs\" ss length]"], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  rs =\n  arg_min length\n   (word_for (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (sum_list ss))\n  word_for (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   (sum_list ss) ss \\<Longrightarrow>\n  word_for (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   (sum_list ss)\n   (arg_min length\n     (word_for\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n       (sum_list ss)))\n\ngoal (1 subgoal):\n 1. rs \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) &&&\n    sum_list rs = sum_list ss", "by auto"], ["proof (state)\nthis:\n  rs \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  sum_list rs = sum_list ss\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       ss = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "proof (cases rs rule: list_cases_Cons_snoc)"], ["proof (state)\ngoal (3 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 2. \\<And>x.\n       rs = [x] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 3. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "case Nil"], ["proof (state)\nthis:\n  rs = []\n\ngoal (3 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 2. \\<And>x.\n       rs = [x] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 3. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "hence \"sum_list ss `\\<rightarrow> C0 = C0\""], ["proof (prove)\nusing this:\n  rs = []\n\ngoal (1 subgoal):\n 1. sum_list ss `\\<rightarrow> C0 = C0", "using rs(2)"], ["proof (prove)\nusing this:\n  rs = []\n  sum_list rs = sum_list ss\n\ngoal (1 subgoal):\n 1. sum_list ss `\\<rightarrow> C0 = C0", "by (fastforce simp add: zero_permutation.rep_eq)"], ["proof (state)\nthis:\n  sum_list ss `\\<rightarrow> C0 = C0\n\ngoal (3 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 2. \\<And>x.\n       rs = [x] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 3. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "with C0_ms_ss_C0"], ["proof (chain)\npicking this:\n  map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss) =\n  C0 # Ms @ [sum_list ss `\\<rightarrow> C0]\n  sum_list ss `\\<rightarrow> C0 = C0", "show ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss) =\n  C0 # Ms @ [sum_list ss `\\<rightarrow> C0]\n  sum_list ss `\\<rightarrow> C0 = C0\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "by simp"], ["proof (state)\nthis:\n  \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       rs = [x] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 2. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       rs = [x] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 2. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "case (Single r)"], ["proof (state)\nthis:\n  rs = [r]\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       rs = [x] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 2. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "from Single"], ["proof (chain)\npicking this:\n  rs = [r]", "have \"min_gallery [C0,r`\\<rightarrow>C0]\""], ["proof (prove)\nusing this:\n  rs = [r]\n\ngoal (1 subgoal):\n 1. min_gallery [C0, r `\\<rightarrow> C0]", "using rs(1) fundchamber fundchamber_S_chamber fundchamber_S_adjacent\n            fundchamber_S_image_neq_fundchamber"], ["proof (prove)\nusing this:\n  rs = [r]\n  rs \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  chamber C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  chamber (?s `\\<rightarrow> C0)\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<sim> ?s `\\<rightarrow> C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  ?s `\\<rightarrow> C0 \\<noteq> C0\n\ngoal (1 subgoal):\n 1. min_gallery [C0, r `\\<rightarrow> C0]", "by    (fastforce intro: min_gallery_adj)"], ["proof (state)\nthis:\n  min_gallery [C0, r `\\<rightarrow> C0]\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       rs = [x] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n 2. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "with Single C0_ms_ss_C0 Ms_def"], ["proof (chain)\npicking this:\n  rs = [r]\n  map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss) =\n  C0 # Ms @ [sum_list ss `\\<rightarrow> C0]\n  Ms = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) s) (sums ts))\n  min_gallery [C0, r `\\<rightarrow> C0]", "show ?thesis"], ["proof (prove)\nusing this:\n  rs = [r]\n  map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss) =\n  C0 # Ms @ [sum_list ss `\\<rightarrow> C0]\n  Ms = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) s) (sums ts))\n  min_gallery [C0, r `\\<rightarrow> C0]\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "using rs(2) min_galleryD_min_betw[of C0 Ms \"sum_list ss `\\<rightarrow> C0\" \"[]\"]\n            min_galleryD_gallery"], ["proof (prove)\nusing this:\n  rs = [r]\n  map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss) =\n  C0 # Ms @ [sum_list ss `\\<rightarrow> C0]\n  Ms = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) s) (sums ts))\n  min_gallery [C0, r `\\<rightarrow> C0]\n  sum_list rs = sum_list ss\n  \\<lbrakk>min_gallery (C0 # Ms @ [sum_list ss `\\<rightarrow> C0]);\n   gallery (C0 # [] @ [sum_list ss `\\<rightarrow> C0])\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (length []) (length Ms)\n  min_gallery ?xs \\<Longrightarrow> gallery ?xs\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "by    (fastforce simp add: length_sums)"], ["proof (state)\nthis:\n  \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "case (Cons_snoc p qs q)"], ["proof (state)\nthis:\n  rs = p # qs @ [q]\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "define Ns where \"Ns = map (\\<lambda>w. w`\\<rightarrow>C0) (map ((+) p) (sums qs))\""], ["proof (state)\nthis:\n  Ns = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) p) (sums qs))\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "from assms rs_def"], ["proof (chain)\npicking this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<not> reduced_word\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) ss\n  rs =\n  arg_min length\n   (word_for (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (sum_list ss))", "have \"length rs < length ss\""], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<not> reduced_word\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) ss\n  rs =\n  arg_min length\n   (word_for (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (sum_list ss))\n\ngoal (1 subgoal):\n 1. order.greater (length ss) (length rs)", "using word_length_lt[of ss S]\n            reduced_word_for_length reduced_word_for_arg_min[of ss S]"], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<not> reduced_word\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) ss\n  rs =\n  arg_min length\n   (word_for (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     (sum_list ss))\n  \\<lbrakk>ss \\<in> lists\n                     (\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g});\n   sum_list ss = ?a;\n   \\<not> reduced_word_for\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n           ?a ss\\<rbrakk>\n  \\<Longrightarrow> order.greater (length ss)\n                     (word_length\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g})\n                       ?a)\n  reduced_word_for ?A ?a ?as \\<Longrightarrow>\n  length ?as = word_length ?A ?a\n  \\<lbrakk>ss \\<in> lists\n                     (\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g});\n   sum_list ss = ?a\\<rbrakk>\n  \\<Longrightarrow> reduced_word_for\n                     (\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g})\n                     ?a (arg_min length\n                          (word_for\n                            (\\<Union>(f, g)\\<in>fundfoldpairs.\n                                {Abs_induced_automorph f g})\n                            ?a))\n\ngoal (1 subgoal):\n 1. order.greater (length ss) (length rs)", "by    force"], ["proof (state)\nthis:\n  order.greater (length ss) (length rs)\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "with Cons_snoc ss Ms_def Ns_def"], ["proof (chain)\npicking this:\n  rs = p # qs @ [q]\n  ss = s # ts @ [t]\n  Ms = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) s) (sums ts))\n  Ns = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) p) (sums qs))\n  order.greater (length ss) (length rs)", "have \"length Ns < length Ms\""], ["proof (prove)\nusing this:\n  rs = p # qs @ [q]\n  ss = s # ts @ [t]\n  Ms = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) s) (sums ts))\n  Ns = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) p) (sums qs))\n  order.greater (length ss) (length rs)\n\ngoal (1 subgoal):\n 1. order.greater (length Ms) (length Ns)", "by (simp add: length_sums)"], ["proof (state)\nthis:\n  order.greater (length Ms) (length Ns)\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "moreover"], ["proof (state)\nthis:\n  order.greater (length Ms) (length Ns)\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "from Ns_def Cons_snoc"], ["proof (chain)\npicking this:\n  Ns = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) p) (sums qs))\n  rs = p # qs @ [q]", "have  \"gallery (C0 # Ns @ [sum_list ss `\\<rightarrow> C0])\""], ["proof (prove)\nusing this:\n  Ns = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) p) (sums qs))\n  rs = p # qs @ [q]\n\ngoal (1 subgoal):\n 1. gallery (C0 # Ns @ [sum_list ss `\\<rightarrow> C0])", "using rs S_list_image_gallery[of rs]"], ["proof (prove)\nusing this:\n  Ns = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) p) (sums qs))\n  rs = p # qs @ [q]\n  rs \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  sum_list rs = sum_list ss\n  rs \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n  gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums rs))\n\ngoal (1 subgoal):\n 1. gallery (C0 # Ns @ [sum_list ss `\\<rightarrow> C0])", "by    (auto simp add: sums_snoc zero_permutation.rep_eq)"], ["proof (state)\nthis:\n  gallery (C0 # Ns @ [sum_list ss `\\<rightarrow> C0])\n\ngoal (1 subgoal):\n 1. \\<And>x ys y.\n       rs = x # ys @ [y] \\<Longrightarrow>\n       \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "ultimately"], ["proof (chain)\npicking this:\n  order.greater (length Ms) (length Ns)\n  gallery (C0 # Ns @ [sum_list ss `\\<rightarrow> C0])", "show ?thesis"], ["proof (prove)\nusing this:\n  order.greater (length Ms) (length Ns)\n  gallery (C0 # Ns @ [sum_list ss `\\<rightarrow> C0])\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "using C0_ms_ss_C0 not_min_galleryI_betw"], ["proof (prove)\nusing this:\n  order.greater (length Ms) (length Ns)\n  gallery (C0 # Ns @ [sum_list ss `\\<rightarrow> C0])\n  map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss) =\n  C0 # Ms @ [sum_list ss `\\<rightarrow> C0]\n  \\<lbrakk>gallery (?x # ?ys @ [?y]);\n   order.greater (length ?xs) (length ?ys)\\<rbrakk>\n  \\<Longrightarrow> \\<not> min_gallery (?x # ?xs @ [?y])\n\ngoal (1 subgoal):\n 1. \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "by auto"], ["proof (state)\nthis:\n  \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma S_list_not_min_gallery_double_split:\n  assumes \"ss \\<in> lists S\" \"ss\\<noteq>[]\" \"\\<not> min_gallery (map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss))\"\n  shows\n    \"\\<exists>f g as s bs t cs.\n      (f,g)\\<in>foldpairs \\<and>\n      sum_list as `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C> \\<and>\n      sum_list (as@[s]) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C> \\<and>\n      sum_list (as@[s]@bs) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C> \\<and>\n      sum_list (as@[s]@bs@[t]) `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C> \\<and>\n      ss = as@[s]@bs@[t]@cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "define Cs where \"Cs = map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss)\""], ["proof (state)\nthis:\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n\ngoal (1 subgoal):\n 1. \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "moreover"], ["proof (state)\nthis:\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n\ngoal (1 subgoal):\n 1. \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "from assms(1) Cs_def"], ["proof (chain)\npicking this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)", "have \"gallery Cs\""], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n\ngoal (1 subgoal):\n 1. gallery Cs", "using S_list_image_gallery"], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  ?ss\n  \\<in> lists\n         (\\<Union>(f, g)\\<in>fundfoldpairs.\n             {Abs_induced_automorph f g}) \\<Longrightarrow>\n  gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ?ss))\n\ngoal (1 subgoal):\n 1. gallery Cs", "by fastforce"], ["proof (state)\nthis:\n  gallery Cs\n\ngoal (1 subgoal):\n 1. \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "moreover"], ["proof (state)\nthis:\n  gallery Cs\n\ngoal (1 subgoal):\n 1. \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "from assms(1) Cs_def"], ["proof (chain)\npicking this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)", "have \"{} \\<notin> set (wall_crossings Cs)\""], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n\ngoal (1 subgoal):\n 1. {} \\<notin> set (wall_crossings Cs)", "using S_list_image_crosses_walls"], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  ?ss\n  \\<in> lists\n         (\\<Union>(f, g)\\<in>fundfoldpairs.\n             {Abs_induced_automorph f g}) \\<Longrightarrow>\n  {} \\<notin> set (wall_crossings\n                    (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ?ss)))\n\ngoal (1 subgoal):\n 1. {} \\<notin> set (wall_crossings Cs)", "by fastforce"], ["proof (state)\nthis:\n  {} \\<notin> set (wall_crossings Cs)\n\ngoal (1 subgoal):\n 1. \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "ultimately"], ["proof (chain)\npicking this:\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  gallery Cs\n  {} \\<notin> set (wall_crossings Cs)", "obtain f g As A B Bs E F Fs\n    where   fg          : \"(f,g)\\<in>foldpairs\"\n    and     sep         : \"A\\<in>f\\<turnstile>\\<C>\" \"B\\<in>g\\<turnstile>\\<C>\" \"E\\<in>g\\<turnstile>\\<C>\" \"F\\<in>f\\<turnstile>\\<C>\"\n    and     decomp_cases:\n      \"Cs = As@[A,B,F]@Fs \\<or> Cs = As@[A,B]@Bs@[E,F]@Fs\""], ["proof (prove)\nusing this:\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  gallery Cs\n  {} \\<notin> set (wall_crossings Cs)\n\ngoal (1 subgoal):\n 1. (\\<And>f g A B E F As Fs Bs.\n        \\<lbrakk>(f, g) \\<in> foldpairs; A \\<in> f \\<turnstile> \\<C>;\n         B \\<in> g \\<turnstile> \\<C>; E \\<in> g \\<turnstile> \\<C>;\n         F \\<in> f \\<turnstile> \\<C>;\n         Cs = As @ [A, B, F] @ Fs \\<or>\n         Cs = As @ [A, B] @ Bs @ [E, F] @ Fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using   assms(3) not_min_gallery_double_split[of Cs]"], ["proof (prove)\nusing this:\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  gallery Cs\n  {} \\<notin> set (wall_crossings Cs)\n  \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n  \\<lbrakk>gallery Cs; \\<not> min_gallery Cs;\n   {} \\<notin> set (wall_crossings Cs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f g As A B Bs E F Fs.\n                       (f, g) \\<in> foldpairs \\<and>\n                       A \\<in> f \\<turnstile> \\<C> \\<and>\n                       B \\<in> g \\<turnstile> \\<C> \\<and>\n                       E \\<in> g \\<turnstile> \\<C> \\<and>\n                       F \\<in> f \\<turnstile> \\<C> \\<and>\n                       (Cs = As @ [A, B, F] @ Fs \\<or>\n                        Cs = As @ [A, B] @ Bs @ [E, F] @ Fs)\n\ngoal (1 subgoal):\n 1. (\\<And>f g A B E F As Fs Bs.\n        \\<lbrakk>(f, g) \\<in> foldpairs; A \\<in> f \\<turnstile> \\<C>;\n         B \\<in> g \\<turnstile> \\<C>; E \\<in> g \\<turnstile> \\<C>;\n         F \\<in> f \\<turnstile> \\<C>;\n         Cs = As @ [A, B, F] @ Fs \\<or>\n         Cs = As @ [A, B] @ Bs @ [E, F] @ Fs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by      blast"], ["proof (state)\nthis:\n  (f, g) \\<in> foldpairs\n  A \\<in> f \\<turnstile> \\<C>\n  B \\<in> g \\<turnstile> \\<C>\n  E \\<in> g \\<turnstile> \\<C>\n  F \\<in> f \\<turnstile> \\<C>\n  Cs = As @ [A, B, F] @ Fs \\<or> Cs = As @ [A, B] @ Bs @ [E, F] @ Fs\n\ngoal (1 subgoal):\n 1. \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "proof (cases \"Cs = As@[A,B,F]@Fs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Cs = As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs\n 2. Cs \\<noteq> As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "case True"], ["proof (state)\nthis:\n  Cs = As @ [A, B, F] @ Fs\n\ngoal (2 subgoals):\n 1. Cs = As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs\n 2. Cs \\<noteq> As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "define bs :: \"'a permutation list\" where \"bs = []\""], ["proof (state)\nthis:\n  bs = []\n\ngoal (2 subgoals):\n 1. Cs = As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs\n 2. Cs \\<noteq> As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "from True Cs_def"], ["proof (chain)\npicking this:\n  Cs = As @ [A, B, F] @ Fs\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)", "obtain as s t cs where\n      \"ss = as@[s,t]@cs\" \"A = sum_list as `\\<rightarrow> C0\" \"B = sum_list (as@[s]) `\\<rightarrow> C0\"\n      \"F = sum_list (as@[s,t]) `\\<rightarrow> C0\""], ["proof (prove)\nusing this:\n  Cs = As @ [A, B, F] @ Fs\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n\ngoal (1 subgoal):\n 1. (\\<And>as s t cs.\n        \\<lbrakk>ss = as @ [s, t] @ cs; A = sum_list as `\\<rightarrow> C0;\n         B = sum_list (as @ [s]) `\\<rightarrow> C0;\n         F = sum_list (as @ [s, t]) `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using pullback_sums_map_middle3[of \"\\<lambda>w. w`\\<rightarrow>C0\" ss As A B F Fs]"], ["proof (prove)\nusing this:\n  Cs = As @ [A, B, F] @ Fs\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss) =\n  As @ [A, B, F] @ Fs \\<Longrightarrow>\n  \\<exists>as a b bs.\n     ss = as @ [a, b] @ bs \\<and>\n     A = sum_list as `\\<rightarrow> C0 \\<and>\n     B = sum_list (as @ [a]) `\\<rightarrow> C0 \\<and>\n     F = sum_list (as @ [a, b]) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (\\<And>as s t cs.\n        \\<lbrakk>ss = as @ [s, t] @ cs; A = sum_list as `\\<rightarrow> C0;\n         B = sum_list (as @ [s]) `\\<rightarrow> C0;\n         F = sum_list (as @ [s, t]) `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  ss = as @ [s, t] @ cs\n  A = sum_list as `\\<rightarrow> C0\n  B = sum_list (as @ [s]) `\\<rightarrow> C0\n  F = sum_list (as @ [s, t]) `\\<rightarrow> C0\n\ngoal (2 subgoals):\n 1. Cs = As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs\n 2. Cs \\<noteq> As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "with sep(1,2,4) bs_def"], ["proof (chain)\npicking this:\n  A \\<in> f \\<turnstile> \\<C>\n  B \\<in> g \\<turnstile> \\<C>\n  F \\<in> f \\<turnstile> \\<C>\n  bs = []\n  ss = as @ [s, t] @ cs\n  A = sum_list as `\\<rightarrow> C0\n  B = sum_list (as @ [s]) `\\<rightarrow> C0\n  F = sum_list (as @ [s, t]) `\\<rightarrow> C0", "have\n      \"sum_list as `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C>\" \"sum_list (as@[s]) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C>\"\n      \"sum_list (as@[s]@bs) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C>\" \"sum_list (as@[s]@bs@[t]) `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C>\"\n      \"ss = as@[s]@bs@[t]@cs\""], ["proof (prove)\nusing this:\n  A \\<in> f \\<turnstile> \\<C>\n  B \\<in> g \\<turnstile> \\<C>\n  F \\<in> f \\<turnstile> \\<C>\n  bs = []\n  ss = as @ [s, t] @ cs\n  A = sum_list as `\\<rightarrow> C0\n  B = sum_list (as @ [s]) `\\<rightarrow> C0\n  F = sum_list (as @ [s, t]) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> &&&\n     sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>) &&&\n    sum_list (as @ [s] @ bs) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C> &&&\n    sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n    \\<in> f \\<turnstile> \\<C> &&&\n    ss = as @ [s] @ bs @ [t] @ cs", "by auto"], ["proof (state)\nthis:\n  sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  ss = as @ [s] @ bs @ [t] @ cs\n\ngoal (2 subgoals):\n 1. Cs = As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs\n 2. Cs \\<noteq> As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "with fg"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs\n  sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  ss = as @ [s] @ bs @ [t] @ cs", "show ?thesis"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  ss = as @ [s] @ bs @ [t] @ cs\n\ngoal (1 subgoal):\n 1. \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "by blast"], ["proof (state)\nthis:\n  \\<exists>f g as s bs t cs.\n     (f, g) \\<in> foldpairs \\<and>\n     sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n     sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C> \\<and>\n     sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n     \\<in> g \\<turnstile> \\<C> \\<and>\n     sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n     \\<in> f \\<turnstile> \\<C> \\<and>\n     ss = as @ [s] @ bs @ [t] @ cs\n\ngoal (1 subgoal):\n 1. Cs \\<noteq> As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Cs \\<noteq> As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "case False"], ["proof (state)\nthis:\n  Cs \\<noteq> As @ [A, B, F] @ Fs\n\ngoal (1 subgoal):\n 1. Cs \\<noteq> As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "with Cs_def decomp_cases"], ["proof (chain)\npicking this:\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  Cs = As @ [A, B, F] @ Fs \\<or> Cs = As @ [A, B] @ Bs @ [E, F] @ Fs\n  Cs \\<noteq> As @ [A, B, F] @ Fs", "obtain as s bs t cs where\n      \"ss = as@[s]@bs@[t]@cs\" \"A = sum_list as `\\<rightarrow> C0\" \"B = sum_list (as@[s]) `\\<rightarrow> C0\"\n      \"E = sum_list (as@[s]@bs) `\\<rightarrow> C0\" \"F = sum_list (as@[s]@bs@[t]) `\\<rightarrow> C0\""], ["proof (prove)\nusing this:\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  Cs = As @ [A, B, F] @ Fs \\<or> Cs = As @ [A, B] @ Bs @ [E, F] @ Fs\n  Cs \\<noteq> As @ [A, B, F] @ Fs\n\ngoal (1 subgoal):\n 1. (\\<And>as s bs t cs.\n        \\<lbrakk>ss = as @ [s] @ bs @ [t] @ cs;\n         A = sum_list as `\\<rightarrow> C0;\n         B = sum_list (as @ [s]) `\\<rightarrow> C0;\n         E = sum_list (as @ [s] @ bs) `\\<rightarrow> C0;\n         F = sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using pullback_sums_map_double_middle2[\n              of \"\\<lambda>w. w`\\<rightarrow>C0\" ss As A B Bs E F Fs\n            ]"], ["proof (prove)\nusing this:\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n  Cs = As @ [A, B, F] @ Fs \\<or> Cs = As @ [A, B] @ Bs @ [E, F] @ Fs\n  Cs \\<noteq> As @ [A, B, F] @ Fs\n  map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss) =\n  As @ [A, B] @ Bs @ [E, F] @ Fs \\<Longrightarrow>\n  \\<exists>as a bs b cs.\n     ss = as @ [a] @ bs @ [b] @ cs \\<and>\n     A = sum_list as `\\<rightarrow> C0 \\<and>\n     B = sum_list (as @ [a]) `\\<rightarrow> C0 \\<and>\n     E = sum_list (as @ [a] @ bs) `\\<rightarrow> C0 \\<and>\n     F = sum_list (as @ [a] @ bs @ [b]) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (\\<And>as s bs t cs.\n        \\<lbrakk>ss = as @ [s] @ bs @ [t] @ cs;\n         A = sum_list as `\\<rightarrow> C0;\n         B = sum_list (as @ [s]) `\\<rightarrow> C0;\n         E = sum_list (as @ [s] @ bs) `\\<rightarrow> C0;\n         F = sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  ss = as @ [s] @ bs @ [t] @ cs\n  A = sum_list as `\\<rightarrow> C0\n  B = sum_list (as @ [s]) `\\<rightarrow> C0\n  E = sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n  F = sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. Cs \\<noteq> As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "with sep"], ["proof (chain)\npicking this:\n  A \\<in> f \\<turnstile> \\<C>\n  B \\<in> g \\<turnstile> \\<C>\n  E \\<in> g \\<turnstile> \\<C>\n  F \\<in> f \\<turnstile> \\<C>\n  ss = as @ [s] @ bs @ [t] @ cs\n  A = sum_list as `\\<rightarrow> C0\n  B = sum_list (as @ [s]) `\\<rightarrow> C0\n  E = sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n  F = sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0", "have\n      \"sum_list as `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C>\" \"sum_list (as@[s]) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C>\" \n      \"sum_list (as@[s]@bs) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C>\" \"sum_list (as@[s]@bs@[t]) `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C>\" \n      \"ss = as@[s]@bs@[t]@cs\""], ["proof (prove)\nusing this:\n  A \\<in> f \\<turnstile> \\<C>\n  B \\<in> g \\<turnstile> \\<C>\n  E \\<in> g \\<turnstile> \\<C>\n  F \\<in> f \\<turnstile> \\<C>\n  ss = as @ [s] @ bs @ [t] @ cs\n  A = sum_list as `\\<rightarrow> C0\n  B = sum_list (as @ [s]) `\\<rightarrow> C0\n  E = sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n  F = sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> &&&\n     sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>) &&&\n    sum_list (as @ [s] @ bs) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C> &&&\n    sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n    \\<in> f \\<turnstile> \\<C> &&&\n    ss = as @ [s] @ bs @ [t] @ cs", "by auto"], ["proof (state)\nthis:\n  sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  ss = as @ [s] @ bs @ [t] @ cs\n\ngoal (1 subgoal):\n 1. Cs \\<noteq> As @ [A, B, F] @ Fs \\<Longrightarrow>\n    \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "with fg"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs\n  sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  ss = as @ [s] @ bs @ [t] @ cs", "show ?thesis"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  ss = as @ [s] @ bs @ [t] @ cs\n\ngoal (1 subgoal):\n 1. \\<exists>f g as s bs t cs.\n       (f, g) \\<in> foldpairs \\<and>\n       sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s]) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n       \\<in> g \\<turnstile> \\<C> \\<and>\n       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n       \\<in> f \\<turnstile> \\<C> \\<and>\n       ss = as @ [s] @ bs @ [t] @ cs", "by blast"], ["proof (state)\nthis:\n  \\<exists>f g as s bs t cs.\n     (f, g) \\<in> foldpairs \\<and>\n     sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n     sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C> \\<and>\n     sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n     \\<in> g \\<turnstile> \\<C> \\<and>\n     sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n     \\<in> f \\<turnstile> \\<C> \\<and>\n     ss = as @ [s] @ bs @ [t] @ cs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f g as s bs t cs.\n     (f, g) \\<in> foldpairs \\<and>\n     sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C> \\<and>\n     sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C> \\<and>\n     sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n     \\<in> g \\<turnstile> \\<C> \\<and>\n     sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n     \\<in> f \\<turnstile> \\<C> \\<and>\n     ss = as @ [s] @ bs @ [t] @ cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_end_sum_chain_fg:\n  fixes   f g :: \"'a\\<Rightarrow>'a\"\n  defines \\<s>  : \"\\<s> \\<equiv> induced_automorph f g\"\n  assumes fg :  \"(f,g) \\<in> foldpairs\"\n  and     as :  \"as \\<in> lists S\"\n  and     s  :  \"s\\<in>S\"\n  and     sep:  \"sum_list as `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C>\" \"sum_list (as@[s]) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C>\"\n  shows   \"bs \\<in>lists S \\<Longrightarrow>\n            \\<s> ` sum_list (as@[s]@bs) `\\<rightarrow> C0 = sum_list (as@bs) `\\<rightarrow> C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n    sum_list (as @ bs) `\\<rightarrow> C0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. bs \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n    sum_list (as @ bs) `\\<rightarrow> C0", "from fg"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs", "obtain C where C: \"OpposedThinChamberComplexFoldings X f g C\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        OpposedThinChamberComplexFoldings X f g C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using foldpairs_def"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        OpposedThinChamberComplexFoldings X f g C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g C\n\ngoal (1 subgoal):\n 1. bs \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n    sum_list (as @ bs) `\\<rightarrow> C0", "show \"bs \\<in>lists S \\<Longrightarrow> \\<s> ` sum_list (as@[s]@bs) `\\<rightarrow> C0 = sum_list (as@bs) `\\<rightarrow> C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n    sum_list (as @ bs) `\\<rightarrow> C0", "proof (induct bs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<s> ` sum_list (as @ [s] @ []) `\\<rightarrow> C0 =\n    sum_list (as @ []) `\\<rightarrow> C0\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "case Nil"], ["proof (state)\nthis:\n  [] \\<in> lists\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n\ngoal (2 subgoals):\n 1. [] \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<s> ` sum_list (as @ [s] @ []) `\\<rightarrow> C0 =\n    sum_list (as @ []) `\\<rightarrow> C0\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "from \\<s> as s sep C"], ["proof (chain)\npicking this:\n  \\<s> \\<equiv> induced_automorph f g\n  as \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  OpposedThinChamberComplexFoldings X f g C", "show ?case"], ["proof (prove)\nusing this:\n  \\<s> \\<equiv> induced_automorph f g\n  as \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  OpposedThinChamberComplexFoldings X f g C\n\ngoal (1 subgoal):\n 1. \\<s> ` sum_list (as @ [s] @ []) `\\<rightarrow> C0 =\n    sum_list (as @ []) `\\<rightarrow> C0", "using sum_list_S_in_W[of as] sum_list_append[of as \"[s]\"]\n            fundchamber_WS_image_adjacent"], ["proof (prove)\nusing this:\n  \\<s> \\<equiv> induced_automorph f g\n  as \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  OpposedThinChamberComplexFoldings X f g C\n  as \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n  sum_list as\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  sum_list (as @ [s]) = sum_list as + sum_list [s]\n  \\<lbrakk>?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                {Abs_induced_automorph f g}\\<rangle>;\n   ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g})\\<rbrakk>\n  \\<Longrightarrow> ?w `\\<rightarrow> C0 \\<sim> (?w + ?s) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<s> ` sum_list (as @ [s] @ []) `\\<rightarrow> C0 =\n    sum_list (as @ []) `\\<rightarrow> C0", "by    (auto simp add:\n              OpposedThinChamberComplexFoldings.indaut_adj_halfchsys_im_fg\n            )"], ["proof (state)\nthis:\n  \\<s> ` sum_list (as @ [s] @ []) `\\<rightarrow> C0 =\n  sum_list (as @ []) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "case (snoc b bs)"], ["proof (state)\nthis:\n  bs \\<in> lists\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of\n                (f, g) \\<Rightarrow>\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n  \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n  sum_list (as @ bs) `\\<rightarrow> C0\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "define bC0 B where \"bC0 = b`\\<rightarrow>C0\" and \"B = sum_list (as@bs) `\\<rightarrow> C0\""], ["proof (state)\nthis:\n  bC0 = b `\\<rightarrow> C0\n  B = sum_list (as @ bs) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "define y where \"y = C0\\<inter>bC0\""], ["proof (state)\nthis:\n  y = C0 \\<inter> bC0\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "define z z'\n      where \"z = \\<s> ` sum_list (as@[s]@bs) `\\<rightarrow> y\"\n        and \"z' = sum_list (as@bs) `\\<rightarrow> y\""], ["proof (state)\nthis:\n  z = \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> y\n  z' = sum_list (as @ bs) `\\<rightarrow> y\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "from snoc B_def"], ["proof (chain)\npicking this:\n  bs \\<in> lists\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of\n                (f, g) \\<Rightarrow>\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n  \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n  sum_list (as @ bs) `\\<rightarrow> C0\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  B = sum_list (as @ bs) `\\<rightarrow> C0", "have B': \"\\<s> ` sum_list (as@[s]@bs) `\\<rightarrow> C0 = B\""], ["proof (prove)\nusing this:\n  bs \\<in> lists\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of\n                (f, g) \\<Rightarrow>\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n  \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n  sum_list (as @ bs) `\\<rightarrow> C0\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  B = sum_list (as @ bs) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 = B", "by simp"], ["proof (state)\nthis:\n  \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 = B\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "obtain \\<phi> where \\<phi>: \"label_wrt C0 \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        label_wrt C0 \\<phi> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_label_map"], ["proof (prove)\nusing this:\n  \\<exists>\\<phi>. label_wrt C0 \\<phi>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        label_wrt C0 \\<phi> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  label_wrt C0 \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "from bC0_def y_def snoc(2)"], ["proof (chain)\npicking this:\n  bC0 = b `\\<rightarrow> C0\n  y = C0 \\<inter> bC0\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})", "obtain u where u: \"bC0 = insert u y\""], ["proof (prove)\nusing this:\n  bC0 = b `\\<rightarrow> C0\n  y = C0 \\<inter> bC0\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. (\\<And>u. bC0 = insert u y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using fundchamber_S_adjacent[of b] adjacent_sym\n            fundchamber_S_image_neq_fundchamber\n            adjacent_int_decomp[of bC0 C0]"], ["proof (prove)\nusing this:\n  bC0 = b `\\<rightarrow> C0\n  y = C0 \\<inter> bC0\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  b \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<sim> b `\\<rightarrow> C0\n  ?x \\<sim> ?y \\<Longrightarrow> ?y \\<sim> ?x\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  ?s `\\<rightarrow> C0 \\<noteq> C0\n  \\<lbrakk>bC0 \\<sim> C0; bC0 \\<noteq> C0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v.\n                       v \\<notin> C0 \\<and> bC0 = insert v (bC0 \\<inter> C0)\n\ngoal (1 subgoal):\n 1. (\\<And>u. bC0 = insert u y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    (auto simp add: Int_commute)"], ["proof (state)\nthis:\n  bC0 = insert u y\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "define v v'\n      where \"v = \\<s> (sum_list (as@[s]@bs) \\<rightarrow> u)\"\n        and \"v' = sum_list (as@bs) \\<rightarrow> u\""], ["proof (state)\nthis:\n  v = \\<s> (sum_list (as @ [s] @ bs) \\<rightarrow> u)\n  v' = sum_list (as @ bs) \\<rightarrow> u\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "from bC0_def u v_def z_def v'_def z'_def"], ["proof (chain)\npicking this:\n  bC0 = b `\\<rightarrow> C0\n  bC0 = insert u y\n  v = \\<s> (sum_list (as @ [s] @ bs) \\<rightarrow> u)\n  z = \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> y\n  v' = sum_list (as @ bs) \\<rightarrow> u\n  z' = sum_list (as @ bs) `\\<rightarrow> y", "have  ins_vz : \"\\<s> ` sum_list (as@[s]@bs@[b]) `\\<rightarrow> C0 = insert v z\"\n      and   ins_vz': \"sum_list (as@bs@[b]) `\\<rightarrow> C0 = insert v' z'\""], ["proof (prove)\nusing this:\n  bC0 = b `\\<rightarrow> C0\n  bC0 = insert u y\n  v = \\<s> (sum_list (as @ [s] @ bs) \\<rightarrow> u)\n  z = \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> y\n  v' = sum_list (as @ bs) \\<rightarrow> u\n  z' = sum_list (as @ bs) `\\<rightarrow> y\n\ngoal (1 subgoal):\n 1. \\<s> ` sum_list (as @ [s] @ bs @ [b]) `\\<rightarrow> C0 = insert v z &&&\n    sum_list (as @ bs @ [b]) `\\<rightarrow> C0 = insert v' z'", "using image_insert[of \"permutation (sum_list (as@[s]@bs))\" u y, THEN sym]\n            image_insert[\n              of \\<s> \"sum_list (as@[s]@bs)\\<rightarrow>u\" \"sum_list (as@[s]@bs)`\\<rightarrow>y\",\n              THEN sym]\n            image_insert[of \"permutation (sum_list (as@bs))\" u y, THEN sym]"], ["proof (prove)\nusing this:\n  bC0 = b `\\<rightarrow> C0\n  bC0 = insert u y\n  v = \\<s> (sum_list (as @ [s] @ bs) \\<rightarrow> u)\n  z = \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> y\n  v' = sum_list (as @ bs) \\<rightarrow> u\n  z' = sum_list (as @ bs) `\\<rightarrow> y\n  insert (sum_list (as @ [s] @ bs) \\<rightarrow> u)\n   (sum_list (as @ [s] @ bs) `\\<rightarrow> y) =\n  sum_list (as @ [s] @ bs) `\\<rightarrow> insert u y\n  insert (\\<s> (sum_list (as @ [s] @ bs) \\<rightarrow> u))\n   (\\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> y) =\n  \\<s> `\n  insert (sum_list (as @ [s] @ bs) \\<rightarrow> u)\n   (sum_list (as @ [s] @ bs) `\\<rightarrow> y)\n  insert (sum_list (as @ bs) \\<rightarrow> u)\n   (sum_list (as @ bs) `\\<rightarrow> y) =\n  sum_list (as @ bs) `\\<rightarrow> insert u y\n\ngoal (1 subgoal):\n 1. \\<s> ` sum_list (as @ [s] @ bs @ [b]) `\\<rightarrow> C0 = insert v z &&&\n    sum_list (as @ bs @ [b]) `\\<rightarrow> C0 = insert v' z'", "by    (auto simp add: plus_permutation.rep_eq image_comp)"], ["proof (state)\nthis:\n  \\<s> ` sum_list (as @ [s] @ bs @ [b]) `\\<rightarrow> C0 = insert v z\n  sum_list (as @ bs @ [b]) `\\<rightarrow> C0 = insert v' z'\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "from as s snoc(2)"], ["proof (chain)\npicking this:\n  as \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})", "have sums:\n      \"sum_list (as@[s]@bs) \\<in> W\" \"sum_list (as@bs) \\<in> W\"\n      \"sum_list (as@[s]@bs@[b]) \\<in> W\" \"sum_list (as@bs@[b]) \\<in> W\""], ["proof (prove)\nusing this:\n  as \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. (sum_list (as @ [s] @ bs)\n     \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle> &&&\n     sum_list (as @ bs)\n     \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>) &&&\n    sum_list (as @ [s] @ bs @ [b])\n    \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle> &&&\n    sum_list (as @ bs @ [b])\n    \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>", "using sum_list_S_in_W[of \"as@[s]@bs\"] sum_list_S_in_W[of \"as@bs\"]\n            sum_list_S_in_W[of \"as@[s]@bs@[b]\"] sum_list_S_in_W[of \"as@bs@[b]\"]"], ["proof (prove)\nusing this:\n  as \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  as @ [s] @ bs\n  \\<in> lists\n         (\\<Union>(f, g)\\<in>fundfoldpairs.\n             {Abs_induced_automorph f g}) \\<Longrightarrow>\n  sum_list (as @ [s] @ bs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  as @ bs\n  \\<in> lists\n         (\\<Union>(f, g)\\<in>fundfoldpairs.\n             {Abs_induced_automorph f g}) \\<Longrightarrow>\n  sum_list (as @ bs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  as @ [s] @ bs @ [b]\n  \\<in> lists\n         (\\<Union>(f, g)\\<in>fundfoldpairs.\n             {Abs_induced_automorph f g}) \\<Longrightarrow>\n  sum_list (as @ [s] @ bs @ [b])\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  as @ bs @ [b]\n  \\<in> lists\n         (\\<Union>(f, g)\\<in>fundfoldpairs.\n             {Abs_induced_automorph f g}) \\<Longrightarrow>\n  sum_list (as @ bs @ [b])\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n\ngoal (1 subgoal):\n 1. (sum_list (as @ [s] @ bs)\n     \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle> &&&\n     sum_list (as @ bs)\n     \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>) &&&\n    sum_list (as @ [s] @ bs @ [b])\n    \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle> &&&\n    sum_list (as @ bs @ [b])\n    \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>", "by    auto"], ["proof (state)\nthis:\n  sum_list (as @ [s] @ bs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  sum_list (as @ bs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  sum_list (as @ [s] @ bs @ [b])\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  sum_list (as @ bs @ [b])\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "from u bC0_def snoc(2)"], ["proof (chain)\npicking this:\n  bC0 = insert u y\n  bC0 = b `\\<rightarrow> C0\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})", "have u: \"u\\<in>\\<Union>X\""], ["proof (prove)\nusing this:\n  bC0 = insert u y\n  bC0 = b `\\<rightarrow> C0\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. u \\<in> \\<Union> X", "using fundchamber_S_chamber[of b] chamberD_simplex[of bC0]"], ["proof (prove)\nusing this:\n  bC0 = insert u y\n  bC0 = b `\\<rightarrow> C0\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  b \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  chamber (b `\\<rightarrow> C0)\n  chamber bC0 \\<Longrightarrow> bC0 \\<in> X\n\ngoal (1 subgoal):\n 1. u \\<in> \\<Union> X", "by auto"], ["proof (state)\nthis:\n  u \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "moreover"], ["proof (state)\nthis:\n  u \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "from as s snoc(2) u"], ["proof (chain)\npicking this:\n  as \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  u \\<in> \\<Union> X", "have \"sum_list (as@[s]@bs) \\<rightarrow> u \\<in> \\<Union>X\""], ["proof (prove)\nusing this:\n  as \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  u \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. sum_list (as @ [s] @ bs) \\<rightarrow> u \\<in> \\<Union> X", "using sums(1)\n            ChamberComplexEndomorphism.vertex_map[OF W_endomorphism]"], ["proof (prove)\nusing this:\n  as \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  u \\<in> \\<Union> X\n  sum_list (as @ [s] @ bs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  \\<lbrakk>?w1\n           \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g}\\<rangle>;\n   ?x \\<in> \\<Union> X\\<rbrakk>\n  \\<Longrightarrow> ?w1 \\<rightarrow> ?x \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. sum_list (as @ [s] @ bs) \\<rightarrow> u \\<in> \\<Union> X", "by    fastforce"], ["proof (state)\nthis:\n  sum_list (as @ [s] @ bs) \\<rightarrow> u \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> \\<Union> X\n  sum_list (as @ [s] @ bs) \\<rightarrow> u \\<in> \\<Union> X", "have \"\\<phi> v = \\<phi> v'\""], ["proof (prove)\nusing this:\n  u \\<in> \\<Union> X\n  sum_list (as @ [s] @ bs) \\<rightarrow> u \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. \\<phi> v = \\<phi> v'", "using \\<s> v_def v'_def sums(1,2) W_respects_labels[OF \\<phi>, of \"sum_list (as@[s]@bs)\" u]\n            W_respects_labels[OF \\<phi>, of \"sum_list (as@bs)\" u]\n            OpposedThinChamberComplexFoldings.indaut_resplabels[\n              OF C \\<phi>\n            ]"], ["proof (prove)\nusing this:\n  u \\<in> \\<Union> X\n  sum_list (as @ [s] @ bs) \\<rightarrow> u \\<in> \\<Union> X\n  \\<s> \\<equiv> induced_automorph f g\n  v = \\<s> (sum_list (as @ [s] @ bs) \\<rightarrow> u)\n  v' = sum_list (as @ bs) \\<rightarrow> u\n  sum_list (as @ [s] @ bs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  sum_list (as @ bs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  \\<lbrakk>sum_list (as @ [s] @ bs)\n           \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g}\\<rangle>;\n   u \\<in> \\<Union> X\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (sum_list (as @ [s] @ bs) \\<rightarrow> u) =\n                    \\<phi> u\n  \\<lbrakk>sum_list (as @ bs)\n           \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g}\\<rangle>;\n   u \\<in> \\<Union> X\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (sum_list (as @ bs) \\<rightarrow> u) = \\<phi> u\n  ?v \\<in> \\<Union> X \\<Longrightarrow>\n  \\<phi> (induced_automorph f g ?v) = \\<phi> ?v\n\ngoal (1 subgoal):\n 1. \\<phi> v = \\<phi> v'", "by    simp"], ["proof (state)\nthis:\n  \\<phi> v = \\<phi> v'\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "moreover"], ["proof (state)\nthis:\n  \\<phi> v = \\<phi> v'\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "from \\<s>"], ["proof (chain)\npicking this:\n  \\<s> \\<equiv> induced_automorph f g", "have \"chamber (insert v z)\" \"chamber (insert v' z')\""], ["proof (prove)\nusing this:\n  \\<s> \\<equiv> induced_automorph f g\n\ngoal (1 subgoal):\n 1. chamber (insert v z) &&& chamber (insert v' z')", "using sums(3,4)\n            fundchamber_W_image_chamber[of \"sum_list (as@[s]@bs@[b])\"]\n            OpposedThinChamberComplexFoldings.indaut_chmap[\n              OF C\n            ]\n            fundchamber_W_image_chamber[of \"sum_list (as@bs@[b])\"]"], ["proof (prove)\nusing this:\n  \\<s> \\<equiv> induced_automorph f g\n  sum_list (as @ [s] @ bs @ [b])\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  sum_list (as @ bs @ [b])\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  sum_list (as @ [s] @ bs @ [b])\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle> \\<Longrightarrow>\n  chamber (sum_list (as @ [s] @ bs @ [b]) `\\<rightarrow> C0)\n  chamber ?C \\<Longrightarrow> chamber (induced_automorph f g ` ?C)\n  sum_list (as @ bs @ [b])\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle> \\<Longrightarrow>\n  chamber (sum_list (as @ bs @ [b]) `\\<rightarrow> C0)\n\ngoal (1 subgoal):\n 1. chamber (insert v z) &&& chamber (insert v' z')", "by    (auto simp add: ins_vz[THEN sym] ins_vz'[THEN sym])"], ["proof (state)\nthis:\n  chamber (insert v z)\n  chamber (insert v' z')\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "moreover"], ["proof (state)\nthis:\n  chamber (insert v z)\n  chamber (insert v' z')\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "from y_def z_def z'_def bC0_def B_def snoc(2) \\<s>"], ["proof (chain)\npicking this:\n  y = C0 \\<inter> bC0\n  z = \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> y\n  z' = sum_list (as @ bs) `\\<rightarrow> y\n  bC0 = b `\\<rightarrow> C0\n  B = sum_list (as @ bs) `\\<rightarrow> C0\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  \\<s> \\<equiv> induced_automorph f g", "have \"z\\<lhd>B\" \"z'\\<lhd>B\""], ["proof (prove)\nusing this:\n  y = C0 \\<inter> bC0\n  z = \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> y\n  z' = sum_list (as @ bs) `\\<rightarrow> y\n  bC0 = b `\\<rightarrow> C0\n  B = sum_list (as @ bs) `\\<rightarrow> C0\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  \\<s> \\<equiv> induced_automorph f g\n\ngoal (1 subgoal):\n 1. z \\<lhd> B &&& z' \\<lhd> B", "using B' sums(1,2) fundchamber_S_adjacent[of b]\n            fundchamber_S_image_neq_fundchamber[of b]\n            adjacent_int_facet1[of C0]\n            W_endomorphism[of \"sum_list (as@bs)\"]\n            W_endomorphism[of \"sum_list (as@[s]@bs)\"]\n            fundchamber fundchamber_W_image_chamber[of \"sum_list (as@[s]@bs)\"]\n            ChamberComplexEndomorphism.facet_map[of X]\n            OpposedThinChamberComplexFoldings.indaut_morph[\n              OF C\n            ]\n            ChamberComplexEndomorphism.facet_map[\n              of X \\<s> \"sum_list (as@[s]@bs) `\\<rightarrow> C0\"\n            ]"], ["proof (prove)\nusing this:\n  y = C0 \\<inter> bC0\n  z = \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> y\n  z' = sum_list (as @ bs) `\\<rightarrow> y\n  bC0 = b `\\<rightarrow> C0\n  B = sum_list (as @ bs) `\\<rightarrow> C0\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  \\<s> \\<equiv> induced_automorph f g\n  \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 = B\n  sum_list (as @ [s] @ bs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  sum_list (as @ bs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  b \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<sim> b `\\<rightarrow> C0\n  b \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  b `\\<rightarrow> C0 \\<noteq> C0\n  \\<lbrakk>C0 \\<sim> ?y; C0 \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> C0 \\<inter> ?y \\<lhd> C0\n  sum_list (as @ bs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle> \\<Longrightarrow>\n  ChamberComplexEndomorphism X ((\\<rightarrow>) (sum_list (as @ bs)))\n  sum_list (as @ [s] @ bs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle> \\<Longrightarrow>\n  ChamberComplexEndomorphism X ((\\<rightarrow>) (sum_list (as @ [s] @ bs)))\n  chamber C0\n  sum_list (as @ [s] @ bs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle> \\<Longrightarrow>\n  chamber (sum_list (as @ [s] @ bs) `\\<rightarrow> C0)\n  \\<lbrakk>ChamberComplexEndomorphism X ?f; chamber ?C;\n   ?z \\<lhd> ?C\\<rbrakk>\n  \\<Longrightarrow> ?f ` ?z \\<lhd> ?f ` ?C\n  ChamberComplexEndomorphism X (induced_automorph f g)\n  \\<lbrakk>ChamberComplexEndomorphism X \\<s>;\n   chamber (sum_list (as @ [s] @ bs) `\\<rightarrow> C0);\n   ?z \\<lhd> sum_list (as @ [s] @ bs) `\\<rightarrow> C0\\<rbrakk>\n  \\<Longrightarrow> \\<s> ` ?z \\<lhd>\n                    \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. z \\<lhd> B &&& z' \\<lhd> B", "by    auto"], ["proof (state)\nthis:\n  z \\<lhd> B\n  z' \\<lhd> B\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "moreover"], ["proof (state)\nthis:\n  z \\<lhd> B\n  z' \\<lhd> B\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "from snoc(2) B_def \\<s>"], ["proof (chain)\npicking this:\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  B = sum_list (as @ bs) `\\<rightarrow> C0\n  \\<s> \\<equiv> induced_automorph f g", "have \"insert v z \\<noteq> B\" \"insert v' z' \\<noteq> B\""], ["proof (prove)\nusing this:\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  B = sum_list (as @ bs) `\\<rightarrow> C0\n  \\<s> \\<equiv> induced_automorph f g\n\ngoal (1 subgoal):\n 1. insert v z \\<noteq> B &&& insert v' z' \\<noteq> B", "using sum_list_append[of \"as@[s]@bs\" \"[b]\"] sum_list_append[of \"as@bs\" \"[b]\"]\n            fundchamber_next_WS_image_neq[of b \"sum_list (as@[s]@bs)\"]\n            fundchamber_next_WS_image_neq[of b \"sum_list (as@bs)\"]\n            OpposedThinChamberComplexFoldings.indaut_aut[\n              OF C\n            ]\n            ChamberComplexAutomorphism.bij bij_is_inj B'\n            inj_eq_image[\n              of \\<s> \"sum_list (as@[s]@bs@[b]) `\\<rightarrow> C0\" \"sum_list (as@[s]@bs) `\\<rightarrow> C0\"\n            ]"], ["proof (prove)\nusing this:\n  bs @ [b]\n  \\<in> lists\n         (\\<Union>a\\<in>fundfoldpairs.\n             case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n  B = sum_list (as @ bs) `\\<rightarrow> C0\n  \\<s> \\<equiv> induced_automorph f g\n  sum_list ((as @ [s] @ bs) @ [b]) = sum_list (as @ [s] @ bs) + sum_list [b]\n  sum_list ((as @ bs) @ [b]) = sum_list (as @ bs) + sum_list [b]\n  b \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  (sum_list (as @ [s] @ bs) + b) `\\<rightarrow> C0 \\<noteq>\n  sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n  b \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  (sum_list (as @ bs) + b) `\\<rightarrow> C0 \\<noteq>\n  sum_list (as @ bs) `\\<rightarrow> C0\n  ChamberComplexAutomorphism X (induced_automorph f g)\n  ChamberComplexAutomorphism ?X ?f \\<Longrightarrow> bij ?f\n  bij ?f \\<Longrightarrow> inj ?f\n  \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 = B\n  \\<lbrakk>inj \\<s>;\n   \\<s> ` sum_list (as @ [s] @ bs @ [b]) `\\<rightarrow> C0 =\n   \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0\\<rbrakk>\n  \\<Longrightarrow> sum_list (as @ [s] @ bs @ [b]) `\\<rightarrow> C0 =\n                    sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. insert v z \\<noteq> B &&& insert v' z' \\<noteq> B", "by    (auto simp add: ins_vz[THEN sym] ins_vz'[THEN sym])"], ["proof (state)\nthis:\n  insert v z \\<noteq> B\n  insert v' z' \\<noteq> B\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<in> lists\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) \\<Longrightarrow>\n                \\<s> ` sum_list (as @ [s] @ xs) `\\<rightarrow> C0 =\n                sum_list (as @ xs) `\\<rightarrow> C0;\n        xs @ [x]\n        \\<in> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\\<rbrakk>\n       \\<Longrightarrow> \\<s> `\n                         sum_list (as @ [s] @ xs @ [x]) `\\<rightarrow> C0 =\n                         sum_list (as @ xs @ [x]) `\\<rightarrow> C0", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi> v = \\<phi> v'\n  chamber (insert v z)\n  chamber (insert v' z')\n  z \\<lhd> B\n  z' \\<lhd> B\n  insert v z \\<noteq> B\n  insert v' z' \\<noteq> B", "show ?case"], ["proof (prove)\nusing this:\n  \\<phi> v = \\<phi> v'\n  chamber (insert v z)\n  chamber (insert v' z')\n  z \\<lhd> B\n  z' \\<lhd> B\n  insert v z \\<noteq> B\n  insert v' z' \\<noteq> B\n\ngoal (1 subgoal):\n 1. \\<s> ` sum_list (as @ [s] @ bs @ [b]) `\\<rightarrow> C0 =\n    sum_list (as @ bs @ [b]) `\\<rightarrow> C0", "using B_def sums(2) fundchamber_W_image_chamber[of \"sum_list (as@bs)\"]\n            label_wrt_eq_on_adjacent_vertex[OF \\<phi>, of v v' B z z']"], ["proof (prove)\nusing this:\n  \\<phi> v = \\<phi> v'\n  chamber (insert v z)\n  chamber (insert v' z')\n  z \\<lhd> B\n  z' \\<lhd> B\n  insert v z \\<noteq> B\n  insert v' z' \\<noteq> B\n  B = sum_list (as @ bs) `\\<rightarrow> C0\n  sum_list (as @ bs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n  sum_list (as @ bs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle> \\<Longrightarrow>\n  chamber (sum_list (as @ bs) `\\<rightarrow> C0)\n  \\<lbrakk>\\<phi> v = \\<phi> v'; chamber B; chamber (insert v z);\n   chamber (insert v' z'); z \\<lhd> B; z' \\<lhd> B; insert v z \\<noteq> B;\n   insert v' z' \\<noteq> B\\<rbrakk>\n  \\<Longrightarrow> insert v z = insert v' z'\n\ngoal (1 subgoal):\n 1. \\<s> ` sum_list (as @ [s] @ bs @ [b]) `\\<rightarrow> C0 =\n    sum_list (as @ bs @ [b]) `\\<rightarrow> C0", "by    (auto simp add: ins_vz[THEN sym] ins_vz'[THEN sym])"], ["proof (state)\nthis:\n  \\<s> ` sum_list (as @ [s] @ bs @ [b]) `\\<rightarrow> C0 =\n  sum_list (as @ bs @ [b]) `\\<rightarrow> C0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bs \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n  \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n  sum_list (as @ bs) `\\<rightarrow> C0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_end_sum_chain_gf:\n  fixes   f g :: \"'a\\<Rightarrow>'a\"\n  defines \"\\<s> \\<equiv> induced_automorph f g\"\n  assumes fg :  \"(f,g) \\<in> foldpairs\"\n  and     \"as \\<in> lists S\" \"s\\<in>S\" \"bs \\<in>lists S\"\n          \"sum_list as `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C>\"\n          \"sum_list (as@[s]) `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C>\"\n  shows   \"\\<s> ` sum_list (as@[s]@bs) `\\<rightarrow> C0 = sum_list (as@bs) `\\<rightarrow> C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n    sum_list (as @ bs) `\\<rightarrow> C0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n    sum_list (as @ bs) `\\<rightarrow> C0", "from fg"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs", "obtain C where C: \"OpposedThinChamberComplexFoldings X f g C\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        OpposedThinChamberComplexFoldings X f g C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using foldpairs_def"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        OpposedThinChamberComplexFoldings X f g C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g C\n\ngoal (1 subgoal):\n 1. \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n    sum_list (as @ bs) `\\<rightarrow> C0", "from assms"], ["proof (chain)\npicking this:\n  \\<s> \\<equiv> induced_automorph f g\n  (f, g) \\<in> foldpairs\n  as \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  bs \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  sum_list as `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<s> \\<equiv> induced_automorph f g\n  (f, g) \\<in> foldpairs\n  as \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  bs \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  sum_list as `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n    sum_list (as @ bs) `\\<rightarrow> C0", "using foldpairs_sym fold_end_sum_chain_fg[of g f as s bs]\n          OpposedThinChamberComplexFoldings.induced_automorphism_sym[OF C]"], ["proof (prove)\nusing this:\n  \\<s> \\<equiv> induced_automorph f g\n  (f, g) \\<in> foldpairs\n  as \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  bs \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  sum_list as `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  (?f, ?g) \\<in> foldpairs \\<Longrightarrow> (?g, ?f) \\<in> foldpairs\n  \\<lbrakk>(g, f) \\<in> foldpairs;\n   as \\<in> lists\n             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g});\n   s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   sum_list as `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>;\n   sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>;\n   bs \\<in> lists\n             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g})\\<rbrakk>\n  \\<Longrightarrow> induced_automorph g f `\n                    sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n                    sum_list (as @ bs) `\\<rightarrow> C0\n  induced_automorph g f = induced_automorph f g\n\ngoal (1 subgoal):\n 1. \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n    sum_list (as @ bs) `\\<rightarrow> C0", "by    simp"], ["proof (state)\nthis:\n  \\<s> ` sum_list (as @ [s] @ bs) `\\<rightarrow> C0 =\n  sum_list (as @ bs) `\\<rightarrow> C0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_middle_sum_chain:\n  assumes fg :  \"(f,g) \\<in> foldpairs\"\n  and     S  :  \"as \\<in> lists S\" \"s\\<in>S\" \"bs \\<in> lists S\" \"t\\<in>S\" \"cs \\<in>lists S\"\n  and     sep:  \"sum_list as `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C>\"\n                \"sum_list (as@[s]) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C>\"\n                \"sum_list (as@[s]@bs) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C>\" \"sum_list (as@[s]@bs@[t]) `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C>\"\n  shows   \"sum_list (as@[s]@bs@[t]@cs) `\\<rightarrow> C0 = sum_list (as@bs@cs) `\\<rightarrow> C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (as @ [s] @ bs @ [t] @ cs) `\\<rightarrow> C0 =\n    sum_list (as @ bs @ cs) `\\<rightarrow> C0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list (as @ [s] @ bs @ [t] @ cs) `\\<rightarrow> C0 =\n    sum_list (as @ bs @ cs) `\\<rightarrow> C0", "define \\<s> where \"\\<s> = induced_automorph f g\""], ["proof (state)\nthis:\n  \\<s> = induced_automorph f g\n\ngoal (1 subgoal):\n 1. sum_list (as @ [s] @ bs @ [t] @ cs) `\\<rightarrow> C0 =\n    sum_list (as @ bs @ cs) `\\<rightarrow> C0", "from fg"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs", "obtain C\n    where \"OpposedThinChamberComplexFoldings X f g C\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        OpposedThinChamberComplexFoldings X f g C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using foldpairs_def"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  foldpairs \\<equiv>\n  {(f, g). \\<exists>C. OpposedThinChamberComplexFoldings X f g C}\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        OpposedThinChamberComplexFoldings X f g C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g C\n\ngoal (1 subgoal):\n 1. sum_list (as @ [s] @ bs @ [t] @ cs) `\\<rightarrow> C0 =\n    sum_list (as @ bs @ cs) `\\<rightarrow> C0", "then"], ["proof (chain)\npicking this:\n  OpposedThinChamberComplexFoldings X f g C", "have \"id ` sum_list (as@[s]@bs@[t]@cs) `\\<rightarrow> C0 = sum_list (as@bs@cs) `\\<rightarrow> C0\""], ["proof (prove)\nusing this:\n  OpposedThinChamberComplexFoldings X f g C\n\ngoal (1 subgoal):\n 1. id ` sum_list (as @ [s] @ bs @ [t] @ cs) `\\<rightarrow> C0 =\n    sum_list (as @ bs @ cs) `\\<rightarrow> C0", "using \\<s>_def fg S sep fold_end_sum_chain_gf[of f g \"as@[s]@bs\" t cs]\n          fold_end_sum_chain_fg[of f g as s \"bs@cs\"]"], ["proof (prove)\nusing this:\n  OpposedThinChamberComplexFoldings X f g C\n  \\<s> = induced_automorph f g\n  (f, g) \\<in> foldpairs\n  as \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  bs \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  cs \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  \\<lbrakk>(f, g) \\<in> foldpairs;\n   as @ [s] @ bs\n   \\<in> lists\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   cs \\<in> lists\n             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g});\n   sum_list (as @ [s] @ bs) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>;\n   sum_list ((as @ [s] @ bs) @ [t]) `\\<rightarrow> C0\n   \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> induced_automorph f g `\n                    sum_list ((as @ [s] @ bs) @ [t] @ cs) `\\<rightarrow>\n                    C0 =\n                    sum_list ((as @ [s] @ bs) @ cs) `\\<rightarrow> C0\n  \\<lbrakk>(f, g) \\<in> foldpairs;\n   as \\<in> lists\n             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g});\n   s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>;\n   sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>;\n   bs @ cs\n   \\<in> lists\n          (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g})\\<rbrakk>\n  \\<Longrightarrow> induced_automorph f g `\n                    sum_list (as @ [s] @ bs @ cs) `\\<rightarrow> C0 =\n                    sum_list (as @ bs @ cs) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. id ` sum_list (as @ [s] @ bs @ [t] @ cs) `\\<rightarrow> C0 =\n    sum_list (as @ bs @ cs) `\\<rightarrow> C0", "by    (simp add:\n            image_comp[THEN sym]\n            OpposedThinChamberComplexFoldings.indaut_order2[\n              THEN sym]\n          )"], ["proof (state)\nthis:\n  id ` sum_list (as @ [s] @ bs @ [t] @ cs) `\\<rightarrow> C0 =\n  sum_list (as @ bs @ cs) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. sum_list (as @ [s] @ bs @ [t] @ cs) `\\<rightarrow> C0 =\n    sum_list (as @ bs @ cs) `\\<rightarrow> C0", "thus ?thesis"], ["proof (prove)\nusing this:\n  id ` sum_list (as @ [s] @ bs @ [t] @ cs) `\\<rightarrow> C0 =\n  sum_list (as @ bs @ cs) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. sum_list (as @ [s] @ bs @ [t] @ cs) `\\<rightarrow> C0 =\n    sum_list (as @ bs @ cs) `\\<rightarrow> C0", "by simp"], ["proof (state)\nthis:\n  sum_list (as @ [s] @ bs @ [t] @ cs) `\\<rightarrow> C0 =\n  sum_list (as @ bs @ cs) `\\<rightarrow> C0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma S_list_not_min_gallery_deletion:\n  fixes ss :: \"'a permutation list\"\n  defines w : \"w \\<equiv> sum_list ss\"\n  assumes ss: \"ss\\<in>lists S\" \"ss\\<noteq>[]\" \"\\<not> min_gallery (map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss))\"\n  shows \"\\<exists>a b as bs cs. ss = as@[a]@bs@[b]@cs \\<and> w = sum_list (as@bs@cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b as bs cs.\n       ss = as @ [a] @ bs @ [b] @ cs \\<and> w = sum_list (as @ bs @ cs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a b as bs cs.\n       ss = as @ [a] @ bs @ [b] @ cs \\<and> w = sum_list (as @ bs @ cs)", "from w ss(1)"], ["proof (chain)\npicking this:\n  w \\<equiv> sum_list ss\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "have w_W: \"w\\<in>W\""], ["proof (prove)\nusing this:\n  w \\<equiv> sum_list ss\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}\\<rangle>", "using sum_list_S_in_W"], ["proof (prove)\nusing this:\n  w \\<equiv> sum_list ss\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ?ss\n  \\<in> lists\n         (\\<Union>(f, g)\\<in>fundfoldpairs.\n             {Abs_induced_automorph f g}) \\<Longrightarrow>\n  sum_list ?ss\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}\\<rangle>", "by fast"], ["proof (state)\nthis:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>a b as bs cs.\n       ss = as @ [a] @ bs @ [b] @ cs \\<and> w = sum_list (as @ bs @ cs)", "define Cs where \"Cs = map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss)\""], ["proof (state)\nthis:\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss)\n\ngoal (1 subgoal):\n 1. \\<exists>a b as bs cs.\n       ss = as @ [a] @ bs @ [b] @ cs \\<and> w = sum_list (as @ bs @ cs)", "from ss"], ["proof (chain)\npicking this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss \\<noteq> []\n  \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "obtain f g as s bs t cs\n    where fg    : \"(f,g)\\<in>foldpairs\"\n    and   sep   : \"sum_list as `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C>\"\n                  \"sum_list (as@[s]) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C>\"\n                  \"sum_list (as@[s]@bs) `\\<rightarrow> C0 \\<in> g\\<turnstile>\\<C>\"\n                  \"sum_list (as@[s]@bs@[t]) `\\<rightarrow> C0 \\<in> f\\<turnstile>\\<C>\"\n    and   decomp: \"ss = as@[s]@bs@[t]@cs\""], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss \\<noteq> []\n  \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n\ngoal (1 subgoal):\n 1. (\\<And>f g as s bs t cs.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>;\n         sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>;\n         sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n         \\<in> g \\<turnstile> \\<C>;\n         sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n         \\<in> f \\<turnstile> \\<C>;\n         ss = as @ [s] @ bs @ [t] @ cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using S_list_not_min_gallery_double_split[of ss]"], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss \\<noteq> []\n  \\<not> min_gallery (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\n  \\<lbrakk>ss \\<in> lists\n                     (\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g});\n   ss \\<noteq> [];\n   \\<not> min_gallery\n           (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f g as s bs t cs.\n                       (f, g) \\<in> foldpairs \\<and>\n                       sum_list as `\\<rightarrow> C0\n                       \\<in> f \\<turnstile> \\<C> \\<and>\n                       sum_list (as @ [s]) `\\<rightarrow> C0\n                       \\<in> g \\<turnstile> \\<C> \\<and>\n                       sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n                       \\<in> g \\<turnstile> \\<C> \\<and>\n                       sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n                       \\<in> f \\<turnstile> \\<C> \\<and>\n                       ss = as @ [s] @ bs @ [t] @ cs\n\ngoal (1 subgoal):\n 1. (\\<And>f g as s bs t cs.\n        \\<lbrakk>(f, g) \\<in> foldpairs;\n         sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>;\n         sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>;\n         sum_list (as @ [s] @ bs) `\\<rightarrow> C0\n         \\<in> g \\<turnstile> \\<C>;\n         sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0\n         \\<in> f \\<turnstile> \\<C>;\n         ss = as @ [s] @ bs @ [t] @ cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    blast"], ["proof (state)\nthis:\n  (f, g) \\<in> foldpairs\n  sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  ss = as @ [s] @ bs @ [t] @ cs\n\ngoal (1 subgoal):\n 1. \\<exists>a b as bs cs.\n       ss = as @ [a] @ bs @ [b] @ cs \\<and> w = sum_list (as @ bs @ cs)", "from fg sep decomp w ss(1)"], ["proof (chain)\npicking this:\n  (f, g) \\<in> foldpairs\n  sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  ss = as @ [s] @ bs @ [t] @ cs\n  w \\<equiv> sum_list ss\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "have  \"w`\\<rightarrow>C0 = sum_list (as@bs@cs) `\\<rightarrow> C0\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  ss = as @ [s] @ bs @ [t] @ cs\n  w \\<equiv> sum_list ss\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. w `\\<rightarrow> C0 = sum_list (as @ bs @ cs) `\\<rightarrow> C0", "using fold_middle_sum_chain"], ["proof (prove)\nusing this:\n  (f, g) \\<in> foldpairs\n  sum_list as `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  sum_list (as @ [s]) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs) `\\<rightarrow> C0 \\<in> g \\<turnstile> \\<C>\n  sum_list (as @ [s] @ bs @ [t]) `\\<rightarrow> C0 \\<in> f \\<turnstile> \\<C>\n  ss = as @ [s] @ bs @ [t] @ cs\n  w \\<equiv> sum_list ss\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<lbrakk>(?f, ?g) \\<in> foldpairs;\n   ?as\n   \\<in> lists\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   ?bs\n   \\<in> lists\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   ?t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   ?cs\n   \\<in> lists\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g});\n   sum_list ?as `\\<rightarrow> C0 \\<in> ?f \\<turnstile> \\<C>;\n   sum_list (?as @ [?s]) `\\<rightarrow> C0 \\<in> ?g \\<turnstile> \\<C>;\n   sum_list (?as @ [?s] @ ?bs) `\\<rightarrow> C0 \\<in> ?g \\<turnstile> \\<C>;\n   sum_list (?as @ [?s] @ ?bs @ [?t]) `\\<rightarrow> C0\n   \\<in> ?f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> sum_list (?as @ [?s] @ ?bs @ [?t] @ ?cs) `\\<rightarrow>\n                    C0 =\n                    sum_list (?as @ ?bs @ ?cs) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. w `\\<rightarrow> C0 = sum_list (as @ bs @ cs) `\\<rightarrow> C0", "by    auto"], ["proof (state)\nthis:\n  w `\\<rightarrow> C0 = sum_list (as @ bs @ cs) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<exists>a b as bs cs.\n       ss = as @ [a] @ bs @ [b] @ cs \\<and> w = sum_list (as @ bs @ cs)", "with ss(1) decomp"], ["proof (chain)\npicking this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss = as @ [s] @ bs @ [t] @ cs\n  w `\\<rightarrow> C0 = sum_list (as @ bs @ cs) `\\<rightarrow> C0", "have \"w = sum_list (as@bs@cs)\""], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss = as @ [s] @ bs @ [t] @ cs\n  w `\\<rightarrow> C0 = sum_list (as @ bs @ cs) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. w = sum_list (as @ bs @ cs)", "using w_W sum_list_S_in_W[of \"as@bs@cs\"]"], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss = as @ [s] @ bs @ [t] @ cs\n  w `\\<rightarrow> C0 = sum_list (as @ bs @ cs) `\\<rightarrow> C0\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  as @ bs @ cs\n  \\<in> lists\n         (\\<Union>(f, g)\\<in>fundfoldpairs.\n             {Abs_induced_automorph f g}) \\<Longrightarrow>\n  sum_list (as @ bs @ cs)\n  \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}\\<rangle>\n\ngoal (1 subgoal):\n 1. w = sum_list (as @ bs @ cs)", "by    (auto intro: inj_onD fundchamber_W_image_inj_on)"], ["proof (state)\nthis:\n  w = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. \\<exists>a b as bs cs.\n       ss = as @ [a] @ bs @ [b] @ cs \\<and> w = sum_list (as @ bs @ cs)", "with decomp"], ["proof (chain)\npicking this:\n  ss = as @ [s] @ bs @ [t] @ cs\n  w = sum_list (as @ bs @ cs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ss = as @ [s] @ bs @ [t] @ cs\n  w = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. \\<exists>a b as bs cs.\n       ss = as @ [a] @ bs @ [b] @ cs \\<and> w = sum_list (as @ bs @ cs)", "by fast"], ["proof (state)\nthis:\n  \\<exists>a b as bs cs.\n     ss = as @ [a] @ bs @ [b] @ cs \\<and> w = sum_list (as @ bs @ cs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deletion:\n  \"ss \\<in> lists S \\<Longrightarrow> \\<not> reduced_word S ss \\<Longrightarrow>\n    \\<exists>a b as bs cs. ss = as@[a]@bs@[b]@cs \\<and> sum_list ss = sum_list (as@bs@cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g});\n     \\<not> reduced_word\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n             ss\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b as bs cs.\n                         ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                         sum_list ss = sum_list (as @ bs @ cs)", "using nil_reduced_word_for_0[of S] not_reduced_word_not_min_gallery\n        S_list_not_min_gallery_deletion"], ["proof (prove)\nusing this:\n  reduced_word_for\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) 0 []\n  \\<lbrakk>?ss\n           \\<in> lists\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g});\n   \\<not> reduced_word\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n           ?ss\\<rbrakk>\n  \\<Longrightarrow> \\<not> min_gallery\n                            (map (\\<lambda>w. w `\\<rightarrow> C0)\n                              (sums ?ss))\n  \\<lbrakk>?ss\n           \\<in> lists\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g});\n   ?ss \\<noteq> [];\n   \\<not> min_gallery\n           (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ?ss))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a b as bs cs.\n                       ?ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                       sum_list ?ss = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<in> lists\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g});\n     \\<not> reduced_word\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n             ss\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b as bs cs.\n                         ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                         sum_list ss = sum_list (as @ bs @ cs)", "by    fastforce"], ["", "lemma PreCoxeterSystemWithDeletion: \"PreCoxeterSystemWithDeletion S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PreCoxeterSystemWithDeletion\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "using S_add_order2 deletion"], ["proof (prove)\nusing this:\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  add_order ?s = 2\n  \\<lbrakk>?ss\n           \\<in> lists\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g});\n   \\<not> reduced_word\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n           ?ss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a b as bs cs.\n                       ?ss = as @ [a] @ bs @ [b] @ cs \\<and>\n                       sum_list ?ss = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. PreCoxeterSystemWithDeletion\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "by unfold_locales simp"], ["", "lemma CoxeterSystem: \"CoxeterSystem S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CoxeterSystem\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "using PreCoxeterSystemWithDeletion\n        PreCoxeterSystemWithDeletion.CoxeterSystem"], ["proof (prove)\nusing this:\n  PreCoxeterSystemWithDeletion\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  PreCoxeterSystemWithDeletion ?S \\<Longrightarrow> CoxeterSystem ?S\n\ngoal (1 subgoal):\n 1. CoxeterSystem\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "by    fast"], ["", "end"], ["", "(* context ThinChamberComplexManyFoldings *)"], ["", "subsection \\<open>Coxeter complexes\\<close>"], ["", "subsubsection \\<open>Locale and complex definitions\\<close>"], ["", "text \\<open>\n  Now we add in the assumption that the generating set is finite, and construct the associated\n  Coxeter complex from the poset of special cosets.\n\\<close>"], ["", "locale CoxeterComplex = CoxeterSystem S\n  for S :: \"'w::group_add set\"\n+ assumes finite_genset: \"finite S\"\nbegin"], ["", "definition TheComplex :: \"'w set set set\"\n  where \"TheComplex \\<equiv> ordering.PosetComplex (\\<supseteq>) (\\<supset>) \\<P>\""], ["", "abbreviation \"\\<Sigma> \\<equiv> TheComplex\""], ["", "end"], ["", "(* context CoxeterComplex *)"], ["", "subsubsection \\<open>As a simplicial complex\\<close>"], ["", "text \\<open>\n  Here we record the fact that the Coxeter complex associated to a Coxeter system is a simplicial\n  complex, and note that the poset of special cosets is complex-like. This last fact allows us to\n  reason about the complex by reasoning about the poset, via the poset isomorphism\n  @{const ComplexLikePoset.smap}.\n\\<close>"], ["", "context CoxeterComplex\nbegin"], ["", "lemma simplex_like_special_cosets:\n  assumes \"X\\<in>\\<P>\"\n  shows \"supset_simplex_like (\\<P>.\\<supseteq>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_order.simplex_like (dual_order.below_in \\<P> X)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. dual_order.simplex_like (dual_order.below_in \\<P> X)", "have image_eq_UN: \"\\<And>f A. f ` A = (\\<Union>x\\<in>A. {f x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f A. f ` A = (\\<Union>x\\<in>A. {f x})", "by blast"], ["proof (state)\nthis:\n  ?f ` ?A = (\\<Union>x\\<in>?A. {?f x})\n\ngoal (1 subgoal):\n 1. dual_order.simplex_like (dual_order.below_in \\<P> X)", "from assms"], ["proof (chain)\npicking this:\n  X \\<in> \\<P>", "obtain w T where \"w\\<in>W\" \"T \\<in> Pow S\" \"X = w +o \\<langle>T\\<rangle>\""], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>w T.\n        \\<lbrakk>w \\<in> W; T \\<in> Pow S;\n         X = w +o \\<langle>T\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using special_cosets_def"], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n  \\<P> \\<equiv>\n  \\<Union>T\\<in>Pow S. \\<Union>w\\<in>W. {w +o \\<langle>T\\<rangle>}\n\ngoal (1 subgoal):\n 1. (\\<And>w T.\n        \\<lbrakk>w \\<in> W; T \\<in> Pow S;\n         X = w +o \\<langle>T\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> W\n  T \\<in> Pow S\n  X = w +o \\<langle>T\\<rangle>\n\ngoal (1 subgoal):\n 1. dual_order.simplex_like (dual_order.below_in \\<P> X)", "thus ?thesis"], ["proof (prove)\nusing this:\n  w \\<in> W\n  T \\<in> Pow S\n  X = w +o \\<langle>T\\<rangle>\n\ngoal (1 subgoal):\n 1. dual_order.simplex_like (dual_order.below_in \\<P> X)", "using image_eq_UN[where f= \"(+o) w \\<circ> genby\"]\n          finite_genset simplex_like_pow_above_in\n          OrderingSetIso.simplex_like_map[\n            OF special_coset_below_in_supset_ordering_iso, of T w\n          ]\n          special_cosets_below_in"], ["proof (prove)\nusing this:\n  w \\<in> W\n  T \\<in> Pow S\n  X = w +o \\<langle>T\\<rangle>\n  ((+o) w \\<circ> genby) ` ?A =\n  (\\<Union>x\\<in>?A. {((+o) w \\<circ> genby) x})\n  finite S\n  \\<lbrakk>finite ?A; order.greater_eq ?A ?X\\<rbrakk>\n  \\<Longrightarrow> dual_order.simplex_like\n                     (dual_order.below_in (Pow ?A) ?X)\n  dual_order.simplex_like (dual_order.below_in (Pow S) T) \\<Longrightarrow>\n  dual_order.simplex_like\n   (((+o) w \\<circ> genby) ` dual_order.below_in (Pow S) T)\n  \\<lbrakk>?w \\<in> W; ?T \\<in> Pow S\\<rbrakk>\n  \\<Longrightarrow> dual_order.below_in \\<P> (?w +o \\<langle>?T\\<rangle>) =\n                    (\\<Union>R\\<in>dual_order.below_in (Pow S) ?T.\n                        {?w +o \\<langle>R\\<rangle>})\n\ngoal (1 subgoal):\n 1. dual_order.simplex_like (dual_order.below_in \\<P> X)", "by    force"], ["proof (state)\nthis:\n  dual_order.simplex_like (dual_order.below_in \\<P> X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SimplicialComplex_\\<Sigma>: \"SimplicialComplex \\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplex \\<Sigma>", "unfolding TheComplex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplex (dual_order.PosetComplex \\<P>)", "proof (rule ordering.poset_is_SimplicialComplex)"], ["proof (state)\ngoal (2 subgoals):\n 1. ordering order.greater_eq order.greater\n 2. \\<forall>x\\<in>\\<P>.\n       dual_order.simplex_like (dual_order.below_in \\<P> x)", "show \"ordering (\\<supseteq>) (\\<supset>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordering order.greater_eq order.greater", ".."], ["proof (state)\nthis:\n  ordering order.greater_eq order.greater\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<P>.\n       dual_order.simplex_like (dual_order.below_in \\<P> x)", "show \"\\<forall>X\\<in>\\<P>. supset_simplex_like (\\<P>.\\<supseteq>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>\\<P>.\n       dual_order.simplex_like (dual_order.below_in \\<P> X)", "using simplex_like_special_cosets"], ["proof (prove)\nusing this:\n  ?X \\<in> \\<P> \\<Longrightarrow>\n  dual_order.simplex_like (dual_order.below_in \\<P> ?X)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>\\<P>.\n       dual_order.simplex_like (dual_order.below_in \\<P> X)", "by fast"], ["proof (state)\nthis:\n  \\<forall>X\\<in>\\<P>. dual_order.simplex_like (dual_order.below_in \\<P> X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ComplexLikePoset_special_cosets: \"ComplexLikePoset (\\<supseteq>) (\\<supset>) \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ComplexLikePoset order.greater_eq order.greater \\<P>", "using simplex_like_special_cosets special_cosets_has_bottom special_cosets_have_glbs"], ["proof (prove)\nusing this:\n  ?X \\<in> \\<P> \\<Longrightarrow>\n  dual_order.simplex_like (dual_order.below_in \\<P> ?X)\n  dual_order.has_bottom \\<P>\n  \\<lbrakk>?X \\<in> \\<P>; ?Y \\<in> \\<P>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>B. dual_order.glbound_in_of \\<P> ?X ?Y B\n\ngoal (1 subgoal):\n 1. ComplexLikePoset order.greater_eq order.greater \\<P>", "by    unfold_locales"], ["", "abbreviation \"smap \\<equiv> ordering.poset_simplex_map (\\<supseteq>) (\\<supset>) \\<P>\""], ["", "lemmas smap_def = ordering.poset_simplex_map_def[OF supset_poset, of \\<P>]"], ["", "lemma ordsetmap_smap: \"\\<lbrakk> X\\<in>\\<P>; Y\\<in>\\<P>; X\\<supseteq>Y \\<rbrakk> \\<Longrightarrow> smap X \\<subseteq> smap Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> \\<P>; Y \\<in> \\<P>; order.greater_eq X Y\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq (dual_order.poset_simplex_map \\<P> Y)\n                       (dual_order.poset_simplex_map \\<P> X)", "using ComplexLikePoset.ordsetmap_smap[OF ComplexLikePoset_special_cosets]\n        smap_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> \\<P>; ?b \\<in> \\<P>; order.greater_eq ?a ?b\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (dual_order.poset_simplex_map \\<P> ?b)\n                     (dual_order.poset_simplex_map \\<P> ?a)\n  dual_order.poset_simplex_map \\<P> ?x =\n  {y. dual_order.pseudominimal_in (dual_order.below_in \\<P> ?x) y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> \\<P>; Y \\<in> \\<P>; order.greater_eq X Y\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq (dual_order.poset_simplex_map \\<P> Y)\n                       (dual_order.poset_simplex_map \\<P> X)", "by    simp"], ["", "lemma rev_ordsetmap_smap: \"\\<lbrakk> X\\<in>\\<P>; Y\\<in>\\<P>; smap X \\<subseteq> smap Y \\<rbrakk> \\<Longrightarrow> X\\<supseteq>Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> \\<P>; Y \\<in> \\<P>;\n     order.greater_eq (dual_order.poset_simplex_map \\<P> Y)\n      (dual_order.poset_simplex_map \\<P> X)\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq X Y", "using ComplexLikePoset.rev_ordsetmap_smap[\n          OF ComplexLikePoset_special_cosets\n        ]\n        smap_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> \\<P>; ?b \\<in> \\<P>;\n   order.greater_eq (dual_order.poset_simplex_map \\<P> ?b)\n    (dual_order.poset_simplex_map \\<P> ?a)\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq ?a ?b\n  dual_order.poset_simplex_map \\<P> ?x =\n  {y. dual_order.pseudominimal_in (dual_order.below_in \\<P> ?x) y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> \\<P>; Y \\<in> \\<P>;\n     order.greater_eq (dual_order.poset_simplex_map \\<P> Y)\n      (dual_order.poset_simplex_map \\<P> X)\\<rbrakk>\n    \\<Longrightarrow> order.greater_eq X Y", "by    simp"], ["", "lemma smap_onto_PosetComplex: \"smap ` \\<P> = \\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_order.poset_simplex_map \\<P> ` \\<P> = \\<Sigma>", "using ComplexLikePoset.smap_onto_PosetComplex[\n          OF ComplexLikePoset_special_cosets\n        ]\n        smap_def TheComplex_def"], ["proof (prove)\nusing this:\n  dual_order.poset_simplex_map \\<P> ` \\<P> = dual_order.PosetComplex \\<P>\n  dual_order.poset_simplex_map \\<P> ?x =\n  {y. dual_order.pseudominimal_in (dual_order.below_in \\<P> ?x) y}\n  \\<Sigma> \\<equiv> dual_order.PosetComplex \\<P>\n\ngoal (1 subgoal):\n 1. dual_order.poset_simplex_map \\<P> ` \\<P> = \\<Sigma>", "by    simp"], ["", "lemmas simplices_conv_special_cosets = smap_onto_PosetComplex[THEN sym]"], ["", "lemma smap_into_PosetComplex: \"X\\<in>\\<P> \\<Longrightarrow> smap X \\<in> \\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> \\<P> \\<Longrightarrow>\n    dual_order.poset_simplex_map \\<P> X \\<in> \\<Sigma>", "using smap_onto_PosetComplex"], ["proof (prove)\nusing this:\n  dual_order.poset_simplex_map \\<P> ` \\<P> = \\<Sigma>\n\ngoal (1 subgoal):\n 1. X \\<in> \\<P> \\<Longrightarrow>\n    dual_order.poset_simplex_map \\<P> X \\<in> \\<Sigma>", "by fast"], ["", "lemma smap_pseudominimal:\n  \"w\\<in>W \\<Longrightarrow> s\\<in>S \\<Longrightarrow> smap (w +o \\<langle>S-{s}\\<rangle>) = {w +o \\<langle>S-{s}\\<rangle>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W; s \\<in> S\\<rbrakk>\n    \\<Longrightarrow> dual_order.poset_simplex_map \\<P>\n                       (w +o \\<langle>S - {s}\\<rangle>) =\n                      {w +o \\<langle>S - {s}\\<rangle>}", "using smap_def[of \"w +o \\<langle>S-{s}\\<rangle>\"]\n        special_coset_pseudominimal_in_below_in[of w \"S-{s}\"]\n        exclude_one_is_pseudominimal_in_below_in[of w \"S-{s}\"]"], ["proof (prove)\nusing this:\n  dual_order.poset_simplex_map \\<P> (w +o \\<langle>S - {s}\\<rangle>) =\n  {y. dual_order.pseudominimal_in\n       (dual_order.below_in \\<P> (w +o \\<langle>S - {s}\\<rangle>)) y}\n  \\<lbrakk>w \\<in> W; S - {s} \\<in> Pow S;\n   dual_order.pseudominimal_in\n    (dual_order.below_in \\<P> (w +o \\<langle>S - {s}\\<rangle>)) ?X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s\\<in>S - (S - {s}).\n                       ?X = w +o \\<langle>S - {s}\\<rangle>\n  \\<lbrakk>w \\<in> W; S - {s} \\<in> Pow S; ?s \\<in> S - (S - {s})\\<rbrakk>\n  \\<Longrightarrow> dual_order.pseudominimal_in\n                     (dual_order.below_in \\<P>\n                       (w +o \\<langle>S - {s}\\<rangle>))\n                     (w +o \\<langle>S - {?s}\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W; s \\<in> S\\<rbrakk>\n    \\<Longrightarrow> dual_order.poset_simplex_map \\<P>\n                       (w +o \\<langle>S - {s}\\<rangle>) =\n                      {w +o \\<langle>S - {s}\\<rangle>}", "by    auto"], ["", "lemma exclude_one_notin_smap_singleton:\n  \"s\\<in>S \\<Longrightarrow> w +o \\<langle>S-{s}\\<rangle> \\<notin> smap (w +o \\<langle>{s}\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow>\n    w +o \\<langle>S - {s}\\<rangle>\n    \\<notin> dual_order.poset_simplex_map \\<P> (w +o \\<langle>{s}\\<rangle>)", "using smap_def[of \"w +o \\<langle>{s}\\<rangle>\"]\n        supset_pseudominimal_inD1[of \"\\<P>.\\<supseteq>(w +o \\<langle>{s}\\<rangle>)\" \"w +o \\<langle>S-{s}\\<rangle>\"]\n        special_coset_subset_rev_mono[of \"{s}\" \"S-{s}\"]"], ["proof (prove)\nusing this:\n  dual_order.poset_simplex_map \\<P> (w +o \\<langle>{s}\\<rangle>) =\n  {y. dual_order.pseudominimal_in\n       (dual_order.below_in \\<P> (w +o \\<langle>{s}\\<rangle>)) y}\n  dual_order.pseudominimal_in\n   (dual_order.below_in \\<P> (w +o \\<langle>{s}\\<rangle>))\n   (w +o \\<langle>S - {s}\\<rangle>) \\<Longrightarrow>\n  w +o \\<langle>S - {s}\\<rangle>\n  \\<in> dual_order.below_in \\<P> (w +o \\<langle>{s}\\<rangle>)\n  \\<lbrakk>{s} \\<in> Pow S; S - {s} \\<in> Pow S;\n   order.greater_eq (((+o) ?w \\<circ> genby) (S - {s}))\n    (((+o) ?w \\<circ> genby) {s})\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (S - {s}) {s}\n\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow>\n    w +o \\<langle>S - {s}\\<rangle>\n    \\<notin> dual_order.poset_simplex_map \\<P> (w +o \\<langle>{s}\\<rangle>)", "by    auto"], ["", "lemma maxsimp_vertices: \"w\\<in>W \\<Longrightarrow> s\\<in>S \\<Longrightarrow> w +o \\<langle>S-{s}\\<rangle> \\<in> smap {w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W; s \\<in> S\\<rbrakk>\n    \\<Longrightarrow> w +o \\<langle>S - {s}\\<rangle>\n                      \\<in> dual_order.poset_simplex_map \\<P> {w}", "using special_cosetsI[of \"S-{s}\"] special_coset_singleton\n        ordsetmap_smap[of \"w +o \\<langle>S-{s}\\<rangle>\"] smap_pseudominimal"], ["proof (prove)\nusing this:\n  \\<lbrakk>S - {s} \\<in> Pow S; ?w \\<in> W\\<rbrakk>\n  \\<Longrightarrow> ?w +o \\<langle>S - {s}\\<rangle> \\<in> \\<P>\n  ?w \\<in> W \\<Longrightarrow> {?w} \\<in> \\<P>\n  \\<lbrakk>w +o \\<langle>S - {s}\\<rangle> \\<in> \\<P>; ?Y \\<in> \\<P>;\n   order.greater_eq (w +o \\<langle>S - {s}\\<rangle>) ?Y\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (dual_order.poset_simplex_map \\<P> ?Y)\n                     (dual_order.poset_simplex_map \\<P>\n                       (w +o \\<langle>S - {s}\\<rangle>))\n  \\<lbrakk>?w \\<in> W; ?s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> dual_order.poset_simplex_map \\<P>\n                     (?w +o \\<langle>S - {?s}\\<rangle>) =\n                    {?w +o \\<langle>S - {?s}\\<rangle>}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W; s \\<in> S\\<rbrakk>\n    \\<Longrightarrow> w +o \\<langle>S - {s}\\<rangle>\n                      \\<in> dual_order.poset_simplex_map \\<P> {w}", "by (simp add: genby_lcoset_refl)"], ["", "lemma maxsimp_singleton:\n  assumes \"w\\<in>W\"\n  shows   \"SimplicialComplex.maxsimp \\<Sigma> (smap {w})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp \\<Sigma>\n     (dual_order.poset_simplex_map \\<P> {w})", "proof (rule SimplicialComplex.maxsimpI, rule SimplicialComplex_\\<Sigma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. dual_order.poset_simplex_map \\<P> {w} \\<in> \\<Sigma>\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> \\<Sigma>;\n        order.greater_eq z (dual_order.poset_simplex_map \\<P> {w})\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.poset_simplex_map \\<P> {w}", "from assms"], ["proof (chain)\npicking this:\n  w \\<in> W", "show \"smap {w} \\<in> \\<Sigma>\""], ["proof (prove)\nusing this:\n  w \\<in> W\n\ngoal (1 subgoal):\n 1. dual_order.poset_simplex_map \\<P> {w} \\<in> \\<Sigma>", "using special_coset_singleton smap_into_PosetComplex"], ["proof (prove)\nusing this:\n  w \\<in> W\n  ?w \\<in> W \\<Longrightarrow> {?w} \\<in> \\<P>\n  ?X \\<in> \\<P> \\<Longrightarrow>\n  dual_order.poset_simplex_map \\<P> ?X \\<in> \\<Sigma>\n\ngoal (1 subgoal):\n 1. dual_order.poset_simplex_map \\<P> {w} \\<in> \\<Sigma>", "by fast"], ["proof (state)\nthis:\n  dual_order.poset_simplex_map \\<P> {w} \\<in> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> \\<Sigma>;\n        order.greater_eq z (dual_order.poset_simplex_map \\<P> {w})\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.poset_simplex_map \\<P> {w}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> \\<Sigma>;\n        order.greater_eq z (dual_order.poset_simplex_map \\<P> {w})\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.poset_simplex_map \\<P> {w}", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> \\<Sigma>;\n        order.greater_eq z (dual_order.poset_simplex_map \\<P> {w})\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.poset_simplex_map \\<P> {w}", "assume z: \"z\\<in>\\<Sigma>\" \"smap {w} \\<subseteq> z\""], ["proof (state)\nthis:\n  z \\<in> \\<Sigma>\n  order.greater_eq z (dual_order.poset_simplex_map \\<P> {w})\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> \\<Sigma>;\n        order.greater_eq z (dual_order.poset_simplex_map \\<P> {w})\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.poset_simplex_map \\<P> {w}", "from z(1)"], ["proof (chain)\npicking this:\n  z \\<in> \\<Sigma>", "obtain X where X: \"X\\<in>\\<P>\" \"z = smap X\""], ["proof (prove)\nusing this:\n  z \\<in> \\<Sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> \\<P>;\n         z = dual_order.poset_simplex_map \\<P> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using simplices_conv_special_cosets"], ["proof (prove)\nusing this:\n  z \\<in> \\<Sigma>\n  \\<Sigma> = dual_order.poset_simplex_map \\<P> ` \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> \\<P>;\n         z = dual_order.poset_simplex_map \\<P> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  X \\<in> \\<P>\n  z = dual_order.poset_simplex_map \\<P> X\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> \\<Sigma>;\n        order.greater_eq z (dual_order.poset_simplex_map \\<P> {w})\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.poset_simplex_map \\<P> {w}", "with assms z(2)"], ["proof (chain)\npicking this:\n  w \\<in> W\n  order.greater_eq z (dual_order.poset_simplex_map \\<P> {w})\n  X \\<in> \\<P>\n  z = dual_order.poset_simplex_map \\<P> X", "have \"X = {w}\""], ["proof (prove)\nusing this:\n  w \\<in> W\n  order.greater_eq z (dual_order.poset_simplex_map \\<P> {w})\n  X \\<in> \\<P>\n  z = dual_order.poset_simplex_map \\<P> X\n\ngoal (1 subgoal):\n 1. X = {w}", "using special_coset_singleton rev_ordsetmap_smap special_coset_nempty"], ["proof (prove)\nusing this:\n  w \\<in> W\n  order.greater_eq z (dual_order.poset_simplex_map \\<P> {w})\n  X \\<in> \\<P>\n  z = dual_order.poset_simplex_map \\<P> X\n  ?w \\<in> W \\<Longrightarrow> {?w} \\<in> \\<P>\n  \\<lbrakk>?X \\<in> \\<P>; ?Y \\<in> \\<P>;\n   order.greater_eq (dual_order.poset_simplex_map \\<P> ?Y)\n    (dual_order.poset_simplex_map \\<P> ?X)\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq ?X ?Y\n  ?X \\<in> \\<P> \\<Longrightarrow> ?X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X = {w}", "by fast"], ["proof (state)\nthis:\n  X = {w}\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>z \\<in> \\<Sigma>;\n        order.greater_eq z (dual_order.poset_simplex_map \\<P> {w})\\<rbrakk>\n       \\<Longrightarrow> z = dual_order.poset_simplex_map \\<P> {w}", "with X(2)"], ["proof (chain)\npicking this:\n  z = dual_order.poset_simplex_map \\<P> X\n  X = {w}", "show \"z = smap {w}\""], ["proof (prove)\nusing this:\n  z = dual_order.poset_simplex_map \\<P> X\n  X = {w}\n\ngoal (1 subgoal):\n 1. z = dual_order.poset_simplex_map \\<P> {w}", "by fast"], ["proof (state)\nthis:\n  z = dual_order.poset_simplex_map \\<P> {w}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maxsimp_is_singleton:\n  assumes \"SimplicialComplex.maxsimp \\<Sigma> x\"\n  shows   \"\\<exists>w\\<in>W. smap {w} = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>W. dual_order.poset_simplex_map \\<P> {w} = x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>W. dual_order.poset_simplex_map \\<P> {w} = x", "from assms"], ["proof (chain)\npicking this:\n  SimplicialComplex.maxsimp \\<Sigma> x", "obtain X where X: \"X\\<in>\\<P>\" \"smap X = x\""], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp \\<Sigma> x\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> \\<P>;\n         dual_order.poset_simplex_map \\<P> X = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using SimplicialComplex.maxsimpD_simplex[OF SimplicialComplex_\\<Sigma>]\n          simplices_conv_special_cosets"], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp \\<Sigma> x\n  SimplicialComplex.maxsimp \\<Sigma> ?x \\<Longrightarrow> ?x \\<in> \\<Sigma>\n  \\<Sigma> = dual_order.poset_simplex_map \\<P> ` \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> \\<P>;\n         dual_order.poset_simplex_map \\<P> X = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  X \\<in> \\<P>\n  dual_order.poset_simplex_map \\<P> X = x\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>W. dual_order.poset_simplex_map \\<P> {w} = x", "from X(1)"], ["proof (chain)\npicking this:\n  X \\<in> \\<P>", "obtain w T where wT: \"w\\<in>W\" \"T\\<in>Pow S\" \"X = w +o \\<langle>T\\<rangle>\""], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>w T.\n        \\<lbrakk>w \\<in> W; T \\<in> Pow S;\n         X = w +o \\<langle>T\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using special_cosets_def"], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n  \\<P> \\<equiv>\n  \\<Union>T\\<in>Pow S. \\<Union>w\\<in>W. {w +o \\<langle>T\\<rangle>}\n\ngoal (1 subgoal):\n 1. (\\<And>w T.\n        \\<lbrakk>w \\<in> W; T \\<in> Pow S;\n         X = w +o \\<langle>T\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> W\n  T \\<in> Pow S\n  X = w +o \\<langle>T\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>W. dual_order.poset_simplex_map \\<P> {w} = x", "from wT(1)"], ["proof (chain)\npicking this:\n  w \\<in> W", "have \"{w}\\<in>\\<P>\""], ["proof (prove)\nusing this:\n  w \\<in> W\n\ngoal (1 subgoal):\n 1. {w} \\<in> \\<P>", "using special_coset_singleton"], ["proof (prove)\nusing this:\n  w \\<in> W\n  ?w \\<in> W \\<Longrightarrow> {?w} \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. {w} \\<in> \\<P>", "by fast"], ["proof (state)\nthis:\n  {w} \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>W. dual_order.poset_simplex_map \\<P> {w} = x", "moreover"], ["proof (state)\nthis:\n  {w} \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>W. dual_order.poset_simplex_map \\<P> {w} = x", "with X wT(3)"], ["proof (chain)\npicking this:\n  X \\<in> \\<P>\n  dual_order.poset_simplex_map \\<P> X = x\n  X = w +o \\<langle>T\\<rangle>\n  {w} \\<in> \\<P>", "have \"x \\<subseteq> smap {w}\""], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n  dual_order.poset_simplex_map \\<P> X = x\n  X = w +o \\<langle>T\\<rangle>\n  {w} \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. order.greater_eq (dual_order.poset_simplex_map \\<P> {w}) x", "using genby_lcoset_refl ordsetmap_smap"], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n  dual_order.poset_simplex_map \\<P> X = x\n  X = w +o \\<langle>T\\<rangle>\n  {w} \\<in> \\<P>\n  ?a \\<in> ?a +o \\<langle>?S\\<rangle>\n  \\<lbrakk>?X \\<in> \\<P>; ?Y \\<in> \\<P>; order.greater_eq ?X ?Y\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (dual_order.poset_simplex_map \\<P> ?Y)\n                     (dual_order.poset_simplex_map \\<P> ?X)\n\ngoal (1 subgoal):\n 1. order.greater_eq (dual_order.poset_simplex_map \\<P> {w}) x", "by fast"], ["proof (state)\nthis:\n  order.greater_eq (dual_order.poset_simplex_map \\<P> {w}) x\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>W. dual_order.poset_simplex_map \\<P> {w} = x", "ultimately"], ["proof (chain)\npicking this:\n  {w} \\<in> \\<P>\n  order.greater_eq (dual_order.poset_simplex_map \\<P> {w}) x", "show ?thesis"], ["proof (prove)\nusing this:\n  {w} \\<in> \\<P>\n  order.greater_eq (dual_order.poset_simplex_map \\<P> {w}) x\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>W. dual_order.poset_simplex_map \\<P> {w} = x", "using assms wT(1) smap_into_PosetComplex\n          SimplicialComplex.maxsimpD_maximal[OF SimplicialComplex_\\<Sigma>]"], ["proof (prove)\nusing this:\n  {w} \\<in> \\<P>\n  order.greater_eq (dual_order.poset_simplex_map \\<P> {w}) x\n  SimplicialComplex.maxsimp \\<Sigma> x\n  w \\<in> W\n  ?X \\<in> \\<P> \\<Longrightarrow>\n  dual_order.poset_simplex_map \\<P> ?X \\<in> \\<Sigma>\n  \\<lbrakk>SimplicialComplex.maxsimp \\<Sigma> ?x; ?z \\<in> \\<Sigma>;\n   order.greater_eq ?z ?x\\<rbrakk>\n  \\<Longrightarrow> ?z = ?x\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>W. dual_order.poset_simplex_map \\<P> {w} = x", "by    fast"], ["proof (state)\nthis:\n  \\<exists>w\\<in>W. dual_order.poset_simplex_map \\<P> {w} = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma maxsimp_vertex_conv_special_coset:\n  \"w\\<in>W \\<Longrightarrow> X \\<in> smap {w} \\<Longrightarrow> \\<exists>s\\<in>S. X = w +o \\<langle>S-{s}\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W;\n     X \\<in> dual_order.poset_simplex_map \\<P> {w}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<in>S. X = w +o \\<langle>S - {s}\\<rangle>", "using smap_def special_coset_pseudominimal_in_below_in[of w \"{}\"]"], ["proof (prove)\nusing this:\n  dual_order.poset_simplex_map \\<P> ?x =\n  {y. dual_order.pseudominimal_in (dual_order.below_in \\<P> ?x) y}\n  \\<lbrakk>w \\<in> W; {} \\<in> Pow S;\n   dual_order.pseudominimal_in\n    (dual_order.below_in \\<P> (w +o \\<langle>{}\\<rangle>)) ?X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s\\<in>S - {}.\n                       ?X = w +o \\<langle>S - {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W;\n     X \\<in> dual_order.poset_simplex_map \\<P> {w}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<in>S. X = w +o \\<langle>S - {s}\\<rangle>", "by    (simp add: genby_lcoset_empty)"], ["", "lemma vertices: \"w\\<in>W \\<Longrightarrow> s\\<in>S \\<Longrightarrow> w +o \\<langle>S-{s}\\<rangle> \\<in> \\<Union>\\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W; s \\<in> S\\<rbrakk>\n    \\<Longrightarrow> w +o \\<langle>S - {s}\\<rangle> \\<in> \\<Union> \\<Sigma>", "using maxsimp_singleton SimplicialComplex.maxsimpD_simplex[OF SimplicialComplex_\\<Sigma>]\n        maxsimp_vertices"], ["proof (prove)\nusing this:\n  ?w \\<in> W \\<Longrightarrow>\n  SimplicialComplex.maxsimp \\<Sigma>\n   (dual_order.poset_simplex_map \\<P> {?w})\n  SimplicialComplex.maxsimp \\<Sigma> ?x \\<Longrightarrow> ?x \\<in> \\<Sigma>\n  \\<lbrakk>?w \\<in> W; ?s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> ?w +o \\<langle>S - {?s}\\<rangle>\n                    \\<in> dual_order.poset_simplex_map \\<P> {?w}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W; s \\<in> S\\<rbrakk>\n    \\<Longrightarrow> w +o \\<langle>S - {s}\\<rangle> \\<in> \\<Union> \\<Sigma>", "by    fast"], ["", "lemma smap0_conv_special_subgroups:\n  \"smap 0 = (\\<lambda>s. \\<langle>S - {s}\\<rangle>) ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_order.poset_simplex_map \\<P> 0 =\n    (\\<lambda>s. \\<langle>S - {s}\\<rangle>) ` S", "using genby_0_closed maxsimp_vertices maxsimp_vertex_conv_special_coset"], ["proof (prove)\nusing this:\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n  \\<lbrakk>?w \\<in> W; ?s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> ?w +o \\<langle>S - {?s}\\<rangle>\n                    \\<in> dual_order.poset_simplex_map \\<P> {?w}\n  \\<lbrakk>?w \\<in> W;\n   ?X \\<in> dual_order.poset_simplex_map \\<P> {?w}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s\\<in>S. ?X = ?w +o \\<langle>S - {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. dual_order.poset_simplex_map \\<P> 0 =\n    (\\<lambda>s. \\<langle>S - {s}\\<rangle>) ` S", "by    force"], ["", "lemma S_bij_betw_chamber0: \"bij_betw (\\<lambda>s. \\<langle>S-{s}\\<rangle>) S (smap 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>s. \\<langle>S - {s}\\<rangle>) S\n     (dual_order.poset_simplex_map \\<P> 0)", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>s. \\<langle>S - {s}\\<rangle>) S \\<and>\n    (\\<lambda>s. \\<langle>S - {s}\\<rangle>) ` S =\n    dual_order.poset_simplex_map \\<P> 0", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>s. \\<langle>S - {s}\\<rangle>) S\n 2. (\\<lambda>s. \\<langle>S - {s}\\<rangle>) ` S =\n    dual_order.poset_simplex_map \\<P> 0", "show \"inj_on (\\<lambda>s. \\<langle>S-{s}\\<rangle>) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>s. \\<langle>S - {s}\\<rangle>) S", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S;\n        \\<langle>S - {x}\\<rangle> = \\<langle>S - {y}\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix s t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> S; y \\<in> S;\n        \\<langle>S - {x}\\<rangle> = \\<langle>S - {y}\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"\\<lbrakk> s\\<in>S; t\\<in>S; \\<langle>S-{s}\\<rangle> = \\<langle>S-{t}\\<rangle> \\<rbrakk> \\<Longrightarrow> s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S;\n     \\<langle>S - {s}\\<rangle> = \\<langle>S - {t}\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> s = t", "using inj_onD[OF special_subgroup_inj, of \"S-{s}\" \"S-{t}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>S - {s}\\<rangle> = \\<langle>S - {t}\\<rangle>;\n   S - {s} \\<in> Pow S; S - {t} \\<in> Pow S\\<rbrakk>\n  \\<Longrightarrow> S - {s} = S - {t}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S; t \\<in> S;\n     \\<langle>S - {s}\\<rangle> = \\<langle>S - {t}\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> s = t", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>s \\<in> S; t \\<in> S;\n   \\<langle>S - {s}\\<rangle> = \\<langle>S - {t}\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> s = t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (\\<lambda>s. \\<langle>S - {s}\\<rangle>) S\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. \\<langle>S - {s}\\<rangle>) ` S =\n    dual_order.poset_simplex_map \\<P> 0", "qed (rule smap0_conv_special_subgroups[THEN sym])"], ["", "lemma smap_singleton_conv_W_image: \n  \"w\\<in>W \\<Longrightarrow> smap {w} = ((+o) w) ` (smap 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> W \\<Longrightarrow>\n    dual_order.poset_simplex_map \\<P> {w} =\n    (+o) w ` dual_order.poset_simplex_map \\<P> 0", "using genby_0_closed[of S] maxsimp_vertices[of 0] maxsimp_vertices[of w]\n        maxsimp_vertex_conv_special_coset"], ["proof (prove)\nusing this:\n  (0::'w) \\<in> W\n  \\<lbrakk>(0::'w) \\<in> W; ?s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> (0::'w) +o \\<langle>S - {?s}\\<rangle>\n                    \\<in> dual_order.poset_simplex_map \\<P> {0::'w}\n  \\<lbrakk>w \\<in> W; ?s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> w +o \\<langle>S - {?s}\\<rangle>\n                    \\<in> dual_order.poset_simplex_map \\<P> {w}\n  \\<lbrakk>?w \\<in> W;\n   ?X \\<in> dual_order.poset_simplex_map \\<P> {?w}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s\\<in>S. ?X = ?w +o \\<langle>S - {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. w \\<in> W \\<Longrightarrow>\n    dual_order.poset_simplex_map \\<P> {w} =\n    (+o) w ` dual_order.poset_simplex_map \\<P> 0", "by    force"], ["", "lemma W_lcoset_bij_betw_singletons:\n  assumes \"w\\<in>W\"\n  shows   \"bij_betw ((+o) w) (smap 0) (smap {w})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw ((+o) w) (dual_order.poset_simplex_map \\<P> 0)\n     (dual_order.poset_simplex_map \\<P> {w})", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((+o) w) (dual_order.poset_simplex_map \\<P> 0) \\<and>\n    (+o) w ` dual_order.poset_simplex_map \\<P> 0 =\n    dual_order.poset_simplex_map \\<P> {w}", "proof (rule conjI, rule inj_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> dual_order.poset_simplex_map \\<P> 0;\n        y \\<in> dual_order.poset_simplex_map \\<P> 0;\n        w +o x = w +o y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (+o) w ` dual_order.poset_simplex_map \\<P> 0 =\n    dual_order.poset_simplex_map \\<P> {w}", "fix X Y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> dual_order.poset_simplex_map \\<P> 0;\n        y \\<in> dual_order.poset_simplex_map \\<P> 0;\n        w +o x = w +o y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (+o) w ` dual_order.poset_simplex_map \\<P> 0 =\n    dual_order.poset_simplex_map \\<P> {w}", "assume XY: \"X \\<in> smap 0\" \"Y \\<in> smap 0\" \"w +o X = w +o Y\""], ["proof (state)\nthis:\n  X \\<in> dual_order.poset_simplex_map \\<P> 0\n  Y \\<in> dual_order.poset_simplex_map \\<P> 0\n  w +o X = w +o Y\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> dual_order.poset_simplex_map \\<P> 0;\n        y \\<in> dual_order.poset_simplex_map \\<P> 0;\n        w +o x = w +o y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (+o) w ` dual_order.poset_simplex_map \\<P> 0 =\n    dual_order.poset_simplex_map \\<P> {w}", "from XY(1,2)"], ["proof (chain)\npicking this:\n  X \\<in> dual_order.poset_simplex_map \\<P> 0\n  Y \\<in> dual_order.poset_simplex_map \\<P> 0", "obtain sx sy where \"X = \\<langle>S-{sx}\\<rangle>\" \"Y = \\<langle>S-{sy}\\<rangle>\""], ["proof (prove)\nusing this:\n  X \\<in> dual_order.poset_simplex_map \\<P> 0\n  Y \\<in> dual_order.poset_simplex_map \\<P> 0\n\ngoal (1 subgoal):\n 1. (\\<And>sx sy.\n        \\<lbrakk>X = \\<langle>S - {sx}\\<rangle>;\n         Y = \\<langle>S - {sy}\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using maxsimp_vertex_conv_special_coset[of 0 X]\n          maxsimp_vertex_conv_special_coset[of 0 Y] genby_0_closed[of S]"], ["proof (prove)\nusing this:\n  X \\<in> dual_order.poset_simplex_map \\<P> 0\n  Y \\<in> dual_order.poset_simplex_map \\<P> 0\n  \\<lbrakk>(0::'w) \\<in> W;\n   X \\<in> dual_order.poset_simplex_map \\<P> {0::'w}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s\\<in>S.\n                       X = (0::'w) +o \\<langle>S - {s}\\<rangle>\n  \\<lbrakk>(0::'w) \\<in> W;\n   Y \\<in> dual_order.poset_simplex_map \\<P> {0::'w}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s\\<in>S.\n                       Y = (0::'w) +o \\<langle>S - {s}\\<rangle>\n  (0::'w) \\<in> W\n\ngoal (1 subgoal):\n 1. (\\<And>sx sy.\n        \\<lbrakk>X = \\<langle>S - {sx}\\<rangle>;\n         Y = \\<langle>S - {sy}\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  X = \\<langle>S - {sx}\\<rangle>\n  Y = \\<langle>S - {sy}\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> dual_order.poset_simplex_map \\<P> 0;\n        y \\<in> dual_order.poset_simplex_map \\<P> 0;\n        w +o x = w +o y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (+o) w ` dual_order.poset_simplex_map \\<P> 0 =\n    dual_order.poset_simplex_map \\<P> {w}", "with XY(3)"], ["proof (chain)\npicking this:\n  w +o X = w +o Y\n  X = \\<langle>S - {sx}\\<rangle>\n  Y = \\<langle>S - {sy}\\<rangle>", "show \"X=Y\""], ["proof (prove)\nusing this:\n  w +o X = w +o Y\n  X = \\<langle>S - {sx}\\<rangle>\n  Y = \\<langle>S - {sy}\\<rangle>\n\ngoal (1 subgoal):\n 1. X = Y", "using inj_onD[OF special_coset_inj, of w \"S-{sx}\" \"S-{sy}\"]"], ["proof (prove)\nusing this:\n  w +o X = w +o Y\n  X = \\<langle>S - {sx}\\<rangle>\n  Y = \\<langle>S - {sy}\\<rangle>\n  \\<lbrakk>((+o) w \\<circ> genby) (S - {sx}) =\n           ((+o) w \\<circ> genby) (S - {sy});\n   S - {sx} \\<in> Pow S; S - {sy} \\<in> Pow S\\<rbrakk>\n  \\<Longrightarrow> S - {sx} = S - {sy}\n\ngoal (1 subgoal):\n 1. X = Y", "by force"], ["proof (state)\nthis:\n  X = Y\n\ngoal (1 subgoal):\n 1. (+o) w ` dual_order.poset_simplex_map \\<P> 0 =\n    dual_order.poset_simplex_map \\<P> {w}", "qed (rule smap_singleton_conv_W_image[THEN sym], rule assms)"], ["", "lemma facets:\n  assumes \"w\\<in>W\" \"s\\<in>S\"\n  shows \"smap (w +o \\<langle>{s}\\<rangle>) \\<lhd> smap {w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_order.poset_simplex_map \\<P> (w +o \\<langle>{s}\\<rangle>) \\<lhd>\n    dual_order.poset_simplex_map \\<P> {w}", "proof (\n  rule facetrelI, rule exclude_one_notin_smap_singleton, rule assms(2),\n  rule order_antisym\n)"], ["proof (state)\ngoal (2 subgoals):\n 1. order.greater_eq\n     (insert (w +o \\<langle>S - {s}\\<rangle>)\n       (dual_order.poset_simplex_map \\<P> (w +o \\<langle>{s}\\<rangle>)))\n     (dual_order.poset_simplex_map \\<P> {w})\n 2. order.greater_eq (dual_order.poset_simplex_map \\<P> {w})\n     (insert (w +o \\<langle>S - {s}\\<rangle>)\n       (dual_order.poset_simplex_map \\<P> (w +o \\<langle>{s}\\<rangle>)))", "show \"smap {w} \\<subseteq> insert (w +o \\<langle>S - {s}\\<rangle>) (smap (w +o \\<langle>{s}\\<rangle>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order.greater_eq\n     (insert (w +o \\<langle>S - {s}\\<rangle>)\n       (dual_order.poset_simplex_map \\<P> (w +o \\<langle>{s}\\<rangle>)))\n     (dual_order.poset_simplex_map \\<P> {w})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dual_order.poset_simplex_map \\<P> {w} \\<Longrightarrow>\n       x \\<in> insert (w +o \\<langle>S - {s}\\<rangle>)\n                (dual_order.poset_simplex_map \\<P>\n                  (w +o \\<langle>{s}\\<rangle>))", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dual_order.poset_simplex_map \\<P> {w} \\<Longrightarrow>\n       x \\<in> insert (w +o \\<langle>S - {s}\\<rangle>)\n                (dual_order.poset_simplex_map \\<P>\n                  (w +o \\<langle>{s}\\<rangle>))", "assume \"X \\<in> smap {w}\""], ["proof (state)\nthis:\n  X \\<in> dual_order.poset_simplex_map \\<P> {w}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dual_order.poset_simplex_map \\<P> {w} \\<Longrightarrow>\n       x \\<in> insert (w +o \\<langle>S - {s}\\<rangle>)\n                (dual_order.poset_simplex_map \\<P>\n                  (w +o \\<langle>{s}\\<rangle>))", "with assms(1)"], ["proof (chain)\npicking this:\n  w \\<in> W\n  X \\<in> dual_order.poset_simplex_map \\<P> {w}", "obtain t where \"t\\<in>S\" \"X = w +o \\<langle>S-{t}\\<rangle>\""], ["proof (prove)\nusing this:\n  w \\<in> W\n  X \\<in> dual_order.poset_simplex_map \\<P> {w}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> S; X = w +o \\<langle>S - {t}\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using maxsimp_vertex_conv_special_coset"], ["proof (prove)\nusing this:\n  w \\<in> W\n  X \\<in> dual_order.poset_simplex_map \\<P> {w}\n  \\<lbrakk>?w \\<in> W;\n   ?X \\<in> dual_order.poset_simplex_map \\<P> {?w}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s\\<in>S. ?X = ?w +o \\<langle>S - {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> S; X = w +o \\<langle>S - {t}\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  t \\<in> S\n  X = w +o \\<langle>S - {t}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dual_order.poset_simplex_map \\<P> {w} \\<Longrightarrow>\n       x \\<in> insert (w +o \\<langle>S - {s}\\<rangle>)\n                (dual_order.poset_simplex_map \\<P>\n                  (w +o \\<langle>{s}\\<rangle>))", "with assms"], ["proof (chain)\npicking this:\n  w \\<in> W\n  s \\<in> S\n  t \\<in> S\n  X = w +o \\<langle>S - {t}\\<rangle>", "show \"X\\<in> insert (w +o \\<langle>S - {s}\\<rangle>) (smap (w +o \\<langle>{s}\\<rangle>))\""], ["proof (prove)\nusing this:\n  w \\<in> W\n  s \\<in> S\n  t \\<in> S\n  X = w +o \\<langle>S - {t}\\<rangle>\n\ngoal (1 subgoal):\n 1. X \\<in> insert (w +o \\<langle>S - {s}\\<rangle>)\n             (dual_order.poset_simplex_map \\<P>\n               (w +o \\<langle>{s}\\<rangle>))", "using exclude_one_is_pseudominimal_in_below_in smap_def"], ["proof (prove)\nusing this:\n  w \\<in> W\n  s \\<in> S\n  t \\<in> S\n  X = w +o \\<langle>S - {t}\\<rangle>\n  \\<lbrakk>?w \\<in> W; ?T \\<in> Pow S; ?s \\<in> S - ?T\\<rbrakk>\n  \\<Longrightarrow> dual_order.pseudominimal_in\n                     (dual_order.below_in \\<P> (?w +o \\<langle>?T\\<rangle>))\n                     (?w +o \\<langle>S - {?s}\\<rangle>)\n  dual_order.poset_simplex_map \\<P> ?x =\n  {y. dual_order.pseudominimal_in (dual_order.below_in \\<P> ?x) y}\n\ngoal (1 subgoal):\n 1. X \\<in> insert (w +o \\<langle>S - {s}\\<rangle>)\n             (dual_order.poset_simplex_map \\<P>\n               (w +o \\<langle>{s}\\<rangle>))", "by    (cases \"t=s\") auto"], ["proof (state)\nthis:\n  X \\<in> insert (w +o \\<langle>S - {s}\\<rangle>)\n           (dual_order.poset_simplex_map \\<P> (w +o \\<langle>{s}\\<rangle>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order.greater_eq\n   (insert (w +o \\<langle>S - {s}\\<rangle>)\n     (dual_order.poset_simplex_map \\<P> (w +o \\<langle>{s}\\<rangle>)))\n   (dual_order.poset_simplex_map \\<P> {w})\n\ngoal (1 subgoal):\n 1. order.greater_eq (dual_order.poset_simplex_map \\<P> {w})\n     (insert (w +o \\<langle>S - {s}\\<rangle>)\n       (dual_order.poset_simplex_map \\<P> (w +o \\<langle>{s}\\<rangle>)))", "from assms"], ["proof (chain)\npicking this:\n  w \\<in> W\n  s \\<in> S", "show \"smap {w} \\<supseteq> insert (w +o \\<langle>S - {s}\\<rangle>) (smap (w +o \\<langle>{s}\\<rangle>))\""], ["proof (prove)\nusing this:\n  w \\<in> W\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. order.greater_eq (dual_order.poset_simplex_map \\<P> {w})\n     (insert (w +o \\<langle>S - {s}\\<rangle>)\n       (dual_order.poset_simplex_map \\<P> (w +o \\<langle>{s}\\<rangle>)))", "using genby_lcoset_refl special_cosetsI[of \"{s}\"] special_coset_singleton\n          ordsetmap_smap maxsimp_vertices"], ["proof (prove)\nusing this:\n  w \\<in> W\n  s \\<in> S\n  ?a \\<in> ?a +o \\<langle>?S\\<rangle>\n  \\<lbrakk>{s} \\<in> Pow S; ?w \\<in> W\\<rbrakk>\n  \\<Longrightarrow> ?w +o \\<langle>{s}\\<rangle> \\<in> \\<P>\n  ?w \\<in> W \\<Longrightarrow> {?w} \\<in> \\<P>\n  \\<lbrakk>?X \\<in> \\<P>; ?Y \\<in> \\<P>; order.greater_eq ?X ?Y\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (dual_order.poset_simplex_map \\<P> ?Y)\n                     (dual_order.poset_simplex_map \\<P> ?X)\n  \\<lbrakk>?w \\<in> W; ?s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> ?w +o \\<langle>S - {?s}\\<rangle>\n                    \\<in> dual_order.poset_simplex_map \\<P> {?w}\n\ngoal (1 subgoal):\n 1. order.greater_eq (dual_order.poset_simplex_map \\<P> {w})\n     (insert (w +o \\<langle>S - {s}\\<rangle>)\n       (dual_order.poset_simplex_map \\<P> (w +o \\<langle>{s}\\<rangle>)))", "by    fast"], ["proof (state)\nthis:\n  order.greater_eq (dual_order.poset_simplex_map \\<P> {w})\n   (insert (w +o \\<langle>S - {s}\\<rangle>)\n     (dual_order.poset_simplex_map \\<P> (w +o \\<langle>{s}\\<rangle>)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma facets': \"w\\<in>W \\<Longrightarrow> s\\<in>S \\<Longrightarrow> smap {w,w+s} \\<lhd> smap {w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W; s \\<in> S\\<rbrakk>\n    \\<Longrightarrow> dual_order.poset_simplex_map \\<P> {w, w + s} \\<lhd>\n                      dual_order.poset_simplex_map \\<P> {w}", "using facets"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w \\<in> W; ?s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> dual_order.poset_simplex_map \\<P>\n                     (?w +o \\<langle>{?s}\\<rangle>) \\<lhd>\n                    dual_order.poset_simplex_map \\<P> {?w}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W; s \\<in> S\\<rbrakk>\n    \\<Longrightarrow> dual_order.poset_simplex_map \\<P> {w, w + s} \\<lhd>\n                      dual_order.poset_simplex_map \\<P> {w}", "by (simp add: genset_order2_add genby_lcoset_order2)"], ["", "lemma adjacent: \"w\\<in>W \\<Longrightarrow> s\\<in>S \\<Longrightarrow> smap {w+s} \\<sim> smap {w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W; s \\<in> S\\<rbrakk>\n    \\<Longrightarrow> dual_order.poset_simplex_map \\<P> {w + s} \\<sim>\n                      dual_order.poset_simplex_map \\<P> {w}", "using facets'[of w s] genby_genset_closed genby_add_closed[of w S]\n        facets'[of \"w+s\" s]"], ["proof (prove)\nusing this:\n  \\<lbrakk>w \\<in> W; s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> dual_order.poset_simplex_map \\<P> {w, w + s} \\<lhd>\n                    dual_order.poset_simplex_map \\<P> {w}\n  ?s \\<in> ?S \\<Longrightarrow> ?s \\<in> \\<langle>?S\\<rangle>\n  \\<lbrakk>w \\<in> W; ?h \\<in> W\\<rbrakk> \\<Longrightarrow> w + ?h \\<in> W\n  \\<lbrakk>w + s \\<in> W; s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> dual_order.poset_simplex_map \\<P>\n                     {w + s, w + s + s} \\<lhd>\n                    dual_order.poset_simplex_map \\<P> {w + s}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<in> W; s \\<in> S\\<rbrakk>\n    \\<Longrightarrow> dual_order.poset_simplex_map \\<P> {w + s} \\<sim>\n                      dual_order.poset_simplex_map \\<P> {w}", "by    (\n          auto intro: adjacentI\n          simp add: genset_order2_add add.assoc insert_commute\n        )"], ["", "lemma singleton_adjacent_0: \"s\\<in>S \\<Longrightarrow> smap {s} \\<sim> smap 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow>\n    dual_order.poset_simplex_map \\<P> {s} \\<sim>\n    dual_order.poset_simplex_map \\<P> 0", "using genby_genset_closed genby_0_closed facets'[of 0] facets'[of s]"], ["proof (prove)\nusing this:\n  ?s \\<in> ?S \\<Longrightarrow> ?s \\<in> \\<langle>?S\\<rangle>\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n  \\<lbrakk>(0::'w) \\<in> W; ?s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> dual_order.poset_simplex_map \\<P>\n                     {0::'w, (0::'w) + ?s} \\<lhd>\n                    dual_order.poset_simplex_map \\<P> {0::'w}\n  \\<lbrakk>s \\<in> W; ?s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> dual_order.poset_simplex_map \\<P> {s, s + ?s} \\<lhd>\n                    dual_order.poset_simplex_map \\<P> {s}\n\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow>\n    dual_order.poset_simplex_map \\<P> {s} \\<sim>\n    dual_order.poset_simplex_map \\<P> 0", "by    (fastforce intro: adjacentI simp add: genset_order2_add insert_commute)"], ["", "end"], ["", "(* context CoxeterComplex *)"], ["", "subsubsection \\<open>As a chamber complex\\<close>"], ["", "text \\<open>Now we verify that a Coxeter complex is a chamber complex.\\<close>"], ["", "context CoxeterComplex\nbegin"], ["", "abbreviation \"chamber \\<equiv> SimplicialComplex.maxsimp \\<Sigma>\""], ["", "abbreviation \"gallery \\<equiv> SimplicialComplex.maxsimpchain \\<Sigma>\""], ["", "lemmas chamber_singleton                 = maxsimp_singleton"], ["", "lemmas chamber_vertex_conv_special_coset = maxsimp_vertex_conv_special_coset"], ["", "lemmas chamber_vertices                  = maxsimp_vertices"], ["", "lemmas chamber_is_singleton              = maxsimp_is_singleton"], ["", "lemmas faces       = SimplicialComplex.faces            [OF SimplicialComplex_\\<Sigma>]"], ["", "lemmas gallery_def = SimplicialComplex.maxsimpchain_def [OF SimplicialComplex_\\<Sigma>]"], ["", "lemmas gallery_rev = SimplicialComplex.maxsimpchain_rev [OF SimplicialComplex_\\<Sigma>]"], ["", "lemmas chamberD_simplex =\n  SimplicialComplex.maxsimpD_simplex[OF SimplicialComplex_\\<Sigma>]"], ["", "lemmas gallery_CConsI =\n  SimplicialComplex.maxsimpchain_CConsI[OF SimplicialComplex_\\<Sigma>]"], ["", "lemmas gallery_overlap_join =\n  SimplicialComplex.maxsimpchain_overlap_join[OF SimplicialComplex_\\<Sigma>]"], ["", "lemma word_gallery_to_0:\n  \"ss \\<noteq> [] \\<Longrightarrow> ss\\<in> lists S \\<Longrightarrow> \\<exists>xs. gallery (smap {sum_list ss} # xs @ [smap 0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<noteq> []; ss \\<in> lists S\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         gallery\n                          (dual_order.poset_simplex_map \\<P> {sum_list ss} #\n                           xs @ [dual_order.poset_simplex_map \\<P> 0])", "proof (induct ss rule: rev_nonempty_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       [x] \\<in> lists S \\<Longrightarrow>\n       \\<exists>xs.\n          gallery\n           (dual_order.poset_simplex_map \\<P> {sum_list [x]} #\n            xs @ [dual_order.poset_simplex_map \\<P> 0])\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow>\n        \\<exists>xsa.\n           gallery\n            (dual_order.poset_simplex_map \\<P> {sum_list xs} #\n             xsa @ [dual_order.poset_simplex_map \\<P> 0]);\n        xs @ [x] \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            gallery\n                             (dual_order.poset_simplex_map \\<P>\n                               {sum_list (xs @ [x])} #\n                              xsa @ [dual_order.poset_simplex_map \\<P> 0])", "case (single s)"], ["proof (state)\nthis:\n  [s] \\<in> lists S\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       [x] \\<in> lists S \\<Longrightarrow>\n       \\<exists>xs.\n          gallery\n           (dual_order.poset_simplex_map \\<P> {sum_list [x]} #\n            xs @ [dual_order.poset_simplex_map \\<P> 0])\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow>\n        \\<exists>xsa.\n           gallery\n            (dual_order.poset_simplex_map \\<P> {sum_list xs} #\n             xsa @ [dual_order.poset_simplex_map \\<P> 0]);\n        xs @ [x] \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            gallery\n                             (dual_order.poset_simplex_map \\<P>\n                               {sum_list (xs @ [x])} #\n                              xsa @ [dual_order.poset_simplex_map \\<P> 0])", "hence \"gallery (smap {sum_list [s]} # [] @ [smap 0])\""], ["proof (prove)\nusing this:\n  [s] \\<in> lists S\n\ngoal (1 subgoal):\n 1. gallery\n     (dual_order.poset_simplex_map \\<P> {sum_list [s]} #\n      [] @ [dual_order.poset_simplex_map \\<P> 0])", "using genby_genset_closed genby_0_closed chamber_singleton\n          singleton_adjacent_0 gallery_def"], ["proof (prove)\nusing this:\n  [s] \\<in> lists S\n  ?s \\<in> ?S \\<Longrightarrow> ?s \\<in> \\<langle>?S\\<rangle>\n  (0::?'a) \\<in> \\<langle>?S\\<rangle>\n  ?w \\<in> W \\<Longrightarrow>\n  chamber (dual_order.poset_simplex_map \\<P> {?w})\n  ?s \\<in> S \\<Longrightarrow>\n  dual_order.poset_simplex_map \\<P> {?s} \\<sim>\n  dual_order.poset_simplex_map \\<P> 0\n  gallery ?xs \\<equiv> Ball (set ?xs) chamber \\<and> adjacentchain ?xs\n\ngoal (1 subgoal):\n 1. gallery\n     (dual_order.poset_simplex_map \\<P> {sum_list [s]} #\n      [] @ [dual_order.poset_simplex_map \\<P> 0])", "by    auto"], ["proof (state)\nthis:\n  gallery\n   (dual_order.poset_simplex_map \\<P> {sum_list [s]} #\n    [] @ [dual_order.poset_simplex_map \\<P> 0])\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       [x] \\<in> lists S \\<Longrightarrow>\n       \\<exists>xs.\n          gallery\n           (dual_order.poset_simplex_map \\<P> {sum_list [x]} #\n            xs @ [dual_order.poset_simplex_map \\<P> 0])\n 2. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow>\n        \\<exists>xsa.\n           gallery\n            (dual_order.poset_simplex_map \\<P> {sum_list xs} #\n             xsa @ [dual_order.poset_simplex_map \\<P> 0]);\n        xs @ [x] \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            gallery\n                             (dual_order.poset_simplex_map \\<P>\n                               {sum_list (xs @ [x])} #\n                              xsa @ [dual_order.poset_simplex_map \\<P> 0])", "thus ?case"], ["proof (prove)\nusing this:\n  gallery\n   (dual_order.poset_simplex_map \\<P> {sum_list [s]} #\n    [] @ [dual_order.poset_simplex_map \\<P> 0])\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       gallery\n        (dual_order.poset_simplex_map \\<P> {sum_list [s]} #\n         xs @ [dual_order.poset_simplex_map \\<P> 0])", "by fast"], ["proof (state)\nthis:\n  \\<exists>xs.\n     gallery\n      (dual_order.poset_simplex_map \\<P> {sum_list [s]} #\n       xs @ [dual_order.poset_simplex_map \\<P> 0])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow>\n        \\<exists>xsa.\n           gallery\n            (dual_order.poset_simplex_map \\<P> {sum_list xs} #\n             xsa @ [dual_order.poset_simplex_map \\<P> 0]);\n        xs @ [x] \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            gallery\n                             (dual_order.poset_simplex_map \\<P>\n                               {sum_list (xs @ [x])} #\n                              xsa @ [dual_order.poset_simplex_map \\<P> 0])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow>\n        \\<exists>xsa.\n           gallery\n            (dual_order.poset_simplex_map \\<P> {sum_list xs} #\n             xsa @ [dual_order.poset_simplex_map \\<P> 0]);\n        xs @ [x] \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            gallery\n                             (dual_order.poset_simplex_map \\<P>\n                               {sum_list (xs @ [x])} #\n                              xsa @ [dual_order.poset_simplex_map \\<P> 0])", "case (snoc s ss)"], ["proof (state)\nthis:\n  ss \\<noteq> []\n  ss \\<in> lists S \\<Longrightarrow>\n  \\<exists>xs.\n     gallery\n      (dual_order.poset_simplex_map \\<P> {sum_list ss} #\n       xs @ [dual_order.poset_simplex_map \\<P> 0])\n  ss @ [s] \\<in> lists S\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow>\n        \\<exists>xsa.\n           gallery\n            (dual_order.poset_simplex_map \\<P> {sum_list xs} #\n             xsa @ [dual_order.poset_simplex_map \\<P> 0]);\n        xs @ [x] \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            gallery\n                             (dual_order.poset_simplex_map \\<P>\n                               {sum_list (xs @ [x])} #\n                              xsa @ [dual_order.poset_simplex_map \\<P> 0])", "from snoc(2,3)"], ["proof (chain)\npicking this:\n  ss \\<in> lists S \\<Longrightarrow>\n  \\<exists>xs.\n     gallery\n      (dual_order.poset_simplex_map \\<P> {sum_list ss} #\n       xs @ [dual_order.poset_simplex_map \\<P> 0])\n  ss @ [s] \\<in> lists S", "obtain xs where \"gallery (smap {sum_list ss} # xs @ [smap 0])\""], ["proof (prove)\nusing this:\n  ss \\<in> lists S \\<Longrightarrow>\n  \\<exists>xs.\n     gallery\n      (dual_order.poset_simplex_map \\<P> {sum_list ss} #\n       xs @ [dual_order.poset_simplex_map \\<P> 0])\n  ss @ [s] \\<in> lists S\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        gallery\n         (dual_order.poset_simplex_map \\<P> {sum_list ss} #\n          xs @ [dual_order.poset_simplex_map \\<P> 0]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  gallery\n   (dual_order.poset_simplex_map \\<P> {sum_list ss} #\n    xs @ [dual_order.poset_simplex_map \\<P> 0])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow>\n        \\<exists>xsa.\n           gallery\n            (dual_order.poset_simplex_map \\<P> {sum_list xs} #\n             xsa @ [dual_order.poset_simplex_map \\<P> 0]);\n        xs @ [x] \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            gallery\n                             (dual_order.poset_simplex_map \\<P>\n                               {sum_list (xs @ [x])} #\n                              xsa @ [dual_order.poset_simplex_map \\<P> 0])", "moreover"], ["proof (state)\nthis:\n  gallery\n   (dual_order.poset_simplex_map \\<P> {sum_list ss} #\n    xs @ [dual_order.poset_simplex_map \\<P> 0])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow>\n        \\<exists>xsa.\n           gallery\n            (dual_order.poset_simplex_map \\<P> {sum_list xs} #\n             xsa @ [dual_order.poset_simplex_map \\<P> 0]);\n        xs @ [x] \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            gallery\n                             (dual_order.poset_simplex_map \\<P>\n                               {sum_list (xs @ [x])} #\n                              xsa @ [dual_order.poset_simplex_map \\<P> 0])", "from snoc(3)"], ["proof (chain)\npicking this:\n  ss @ [s] \\<in> lists S", "have \"chamber (smap {sum_list (ss@[s])})\""], ["proof (prove)\nusing this:\n  ss @ [s] \\<in> lists S\n\ngoal (1 subgoal):\n 1. chamber (dual_order.poset_simplex_map \\<P> {sum_list (ss @ [s])})", "using special_subgroup_eq_sum_list chamber_singleton"], ["proof (prove)\nusing this:\n  ss @ [s] \\<in> lists S\n  order.greater_eq S ?S \\<Longrightarrow>\n  \\<langle>?S\\<rangle> = (\\<Union>ss\\<in>lists ?S. {sum_list ss})\n  ?w \\<in> W \\<Longrightarrow>\n  chamber (dual_order.poset_simplex_map \\<P> {?w})\n\ngoal (1 subgoal):\n 1. chamber (dual_order.poset_simplex_map \\<P> {sum_list (ss @ [s])})", "by fast"], ["proof (state)\nthis:\n  chamber (dual_order.poset_simplex_map \\<P> {sum_list (ss @ [s])})\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow>\n        \\<exists>xsa.\n           gallery\n            (dual_order.poset_simplex_map \\<P> {sum_list xs} #\n             xsa @ [dual_order.poset_simplex_map \\<P> 0]);\n        xs @ [x] \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            gallery\n                             (dual_order.poset_simplex_map \\<P>\n                               {sum_list (xs @ [x])} #\n                              xsa @ [dual_order.poset_simplex_map \\<P> 0])", "ultimately"], ["proof (chain)\npicking this:\n  gallery\n   (dual_order.poset_simplex_map \\<P> {sum_list ss} #\n    xs @ [dual_order.poset_simplex_map \\<P> 0])\n  chamber (dual_order.poset_simplex_map \\<P> {sum_list (ss @ [s])})", "have  \"gallery (smap {sum_list (ss@[s])} #\n              (smap {sum_list ss} # xs) @ [smap 0])\""], ["proof (prove)\nusing this:\n  gallery\n   (dual_order.poset_simplex_map \\<P> {sum_list ss} #\n    xs @ [dual_order.poset_simplex_map \\<P> 0])\n  chamber (dual_order.poset_simplex_map \\<P> {sum_list (ss @ [s])})\n\ngoal (1 subgoal):\n 1. gallery\n     (dual_order.poset_simplex_map \\<P> {sum_list (ss @ [s])} #\n      (dual_order.poset_simplex_map \\<P> {sum_list ss} # xs) @\n      [dual_order.poset_simplex_map \\<P> 0])", "using snoc(3) special_subgroup_eq_sum_list adjacent[of \"sum_list ss\" s]"], ["proof (prove)\nusing this:\n  gallery\n   (dual_order.poset_simplex_map \\<P> {sum_list ss} #\n    xs @ [dual_order.poset_simplex_map \\<P> 0])\n  chamber (dual_order.poset_simplex_map \\<P> {sum_list (ss @ [s])})\n  ss @ [s] \\<in> lists S\n  order.greater_eq S ?S \\<Longrightarrow>\n  \\<langle>?S\\<rangle> = (\\<Union>ss\\<in>lists ?S. {sum_list ss})\n  \\<lbrakk>sum_list ss \\<in> W; s \\<in> S\\<rbrakk>\n  \\<Longrightarrow> dual_order.poset_simplex_map \\<P>\n                     {sum_list ss + s} \\<sim>\n                    dual_order.poset_simplex_map \\<P> {sum_list ss}\n\ngoal (1 subgoal):\n 1. gallery\n     (dual_order.poset_simplex_map \\<P> {sum_list (ss @ [s])} #\n      (dual_order.poset_simplex_map \\<P> {sum_list ss} # xs) @\n      [dual_order.poset_simplex_map \\<P> 0])", "by    (auto intro: gallery_CConsI)"], ["proof (state)\nthis:\n  gallery\n   (dual_order.poset_simplex_map \\<P> {sum_list (ss @ [s])} #\n    (dual_order.poset_simplex_map \\<P> {sum_list ss} # xs) @\n    [dual_order.poset_simplex_map \\<P> 0])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>xs \\<noteq> [];\n        xs \\<in> lists S \\<Longrightarrow>\n        \\<exists>xsa.\n           gallery\n            (dual_order.poset_simplex_map \\<P> {sum_list xs} #\n             xsa @ [dual_order.poset_simplex_map \\<P> 0]);\n        xs @ [x] \\<in> lists S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            gallery\n                             (dual_order.poset_simplex_map \\<P>\n                               {sum_list (xs @ [x])} #\n                              xsa @ [dual_order.poset_simplex_map \\<P> 0])", "thus ?case"], ["proof (prove)\nusing this:\n  gallery\n   (dual_order.poset_simplex_map \\<P> {sum_list (ss @ [s])} #\n    (dual_order.poset_simplex_map \\<P> {sum_list ss} # xs) @\n    [dual_order.poset_simplex_map \\<P> 0])\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       gallery\n        (dual_order.poset_simplex_map \\<P> {sum_list (ss @ [s])} #\n         xs @ [dual_order.poset_simplex_map \\<P> 0])", "by fast"], ["proof (state)\nthis:\n  \\<exists>xs.\n     gallery\n      (dual_order.poset_simplex_map \\<P> {sum_list (ss @ [s])} #\n       xs @ [dual_order.poset_simplex_map \\<P> 0])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gallery_to_0:\n  assumes \"w\\<in>W\" \"w\\<noteq>0\"\n  shows   \"\\<exists>xs. gallery (smap {w} # xs @ [smap 0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       gallery\n        (dual_order.poset_simplex_map \\<P> {w} #\n         xs @ [dual_order.poset_simplex_map \\<P> 0])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       gallery\n        (dual_order.poset_simplex_map \\<P> {w} #\n         xs @ [dual_order.poset_simplex_map \\<P> 0])", "from assms(1)"], ["proof (chain)\npicking this:\n  w \\<in> W", "obtain ss where ss: \"ss\\<in>lists S\" \"w = sum_list ss\""], ["proof (prove)\nusing this:\n  w \\<in> W\n\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>ss \\<in> lists S; w = sum_list ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using special_subgroup_eq_sum_list"], ["proof (prove)\nusing this:\n  w \\<in> W\n  order.greater_eq S ?S \\<Longrightarrow>\n  \\<langle>?S\\<rangle> = (\\<Union>ss\\<in>lists ?S. {sum_list ss})\n\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>ss \\<in> lists S; w = sum_list ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ss \\<in> lists S\n  w = sum_list ss\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       gallery\n        (dual_order.poset_simplex_map \\<P> {w} #\n         xs @ [dual_order.poset_simplex_map \\<P> 0])", "with assms(2)"], ["proof (chain)\npicking this:\n  w \\<noteq> (0::'w)\n  ss \\<in> lists S\n  w = sum_list ss", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<noteq> (0::'w)\n  ss \\<in> lists S\n  w = sum_list ss\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       gallery\n        (dual_order.poset_simplex_map \\<P> {w} #\n         xs @ [dual_order.poset_simplex_map \\<P> 0])", "using word_gallery_to_0[of ss]"], ["proof (prove)\nusing this:\n  w \\<noteq> (0::'w)\n  ss \\<in> lists S\n  w = sum_list ss\n  \\<lbrakk>ss \\<noteq> []; ss \\<in> lists S\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       gallery\n                        (dual_order.poset_simplex_map \\<P> {sum_list ss} #\n                         xs @ [dual_order.poset_simplex_map \\<P> 0])\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       gallery\n        (dual_order.poset_simplex_map \\<P> {w} #\n         xs @ [dual_order.poset_simplex_map \\<P> 0])", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>xs.\n     gallery\n      (dual_order.poset_simplex_map \\<P> {w} #\n       xs @ [dual_order.poset_simplex_map \\<P> 0])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ChamberComplex_\\<Sigma>: \"ChamberComplex \\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplex \\<Sigma>", "proof (intro_locales, rule SimplicialComplex_\\<Sigma>, unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> \\<Sigma> \\<Longrightarrow>\n       \\<exists>x. chamber x \\<and> order.greater_eq x y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; chamber x; chamber y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. gallery (x # xs @ [y])", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> \\<Sigma> \\<Longrightarrow>\n       \\<exists>x. chamber x \\<and> order.greater_eq x y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; chamber x; chamber y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. gallery (x # xs @ [y])", "assume \"y\\<in>\\<Sigma>\""], ["proof (state)\nthis:\n  y \\<in> \\<Sigma>\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> \\<Sigma> \\<Longrightarrow>\n       \\<exists>x. chamber x \\<and> order.greater_eq x y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; chamber x; chamber y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. gallery (x # xs @ [y])", "from this"], ["proof (chain)\npicking this:\n  y \\<in> \\<Sigma>", "obtain X where X: \"X\\<in>\\<P>\" \"y = smap X\""], ["proof (prove)\nusing this:\n  y \\<in> \\<Sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> \\<P>;\n         y = dual_order.poset_simplex_map \\<P> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using simplices_conv_special_cosets"], ["proof (prove)\nusing this:\n  y \\<in> \\<Sigma>\n  \\<Sigma> = dual_order.poset_simplex_map \\<P> ` \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> \\<P>;\n         y = dual_order.poset_simplex_map \\<P> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  X \\<in> \\<P>\n  y = dual_order.poset_simplex_map \\<P> X\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> \\<Sigma> \\<Longrightarrow>\n       \\<exists>x. chamber x \\<and> order.greater_eq x y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; chamber x; chamber y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. gallery (x # xs @ [y])", "from X(1)"], ["proof (chain)\npicking this:\n  X \\<in> \\<P>", "obtain w T where \"w\\<in>W\" \"X = w +o \\<langle>T\\<rangle>\""], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>w T.\n        \\<lbrakk>w \\<in> W; X = w +o \\<langle>T\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using special_cosets_def"], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n  \\<P> \\<equiv>\n  \\<Union>T\\<in>Pow S. \\<Union>w\\<in>W. {w +o \\<langle>T\\<rangle>}\n\ngoal (1 subgoal):\n 1. (\\<And>w T.\n        \\<lbrakk>w \\<in> W; X = w +o \\<langle>T\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> W\n  X = w +o \\<langle>T\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> \\<Sigma> \\<Longrightarrow>\n       \\<exists>x. chamber x \\<and> order.greater_eq x y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; chamber x; chamber y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. gallery (x # xs @ [y])", "with X"], ["proof (chain)\npicking this:\n  X \\<in> \\<P>\n  y = dual_order.poset_simplex_map \\<P> X\n  w \\<in> W\n  X = w +o \\<langle>T\\<rangle>", "show \"\\<exists>x. chamber x \\<and> y \\<subseteq> x\""], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n  y = dual_order.poset_simplex_map \\<P> X\n  w \\<in> W\n  X = w +o \\<langle>T\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>x. chamber x \\<and> order.greater_eq x y", "using genby_lcoset_refl special_coset_singleton ordsetmap_smap\n          chamber_singleton"], ["proof (prove)\nusing this:\n  X \\<in> \\<P>\n  y = dual_order.poset_simplex_map \\<P> X\n  w \\<in> W\n  X = w +o \\<langle>T\\<rangle>\n  ?a \\<in> ?a +o \\<langle>?S\\<rangle>\n  ?w \\<in> W \\<Longrightarrow> {?w} \\<in> \\<P>\n  \\<lbrakk>?X \\<in> \\<P>; ?Y \\<in> \\<P>; order.greater_eq ?X ?Y\\<rbrakk>\n  \\<Longrightarrow> order.greater_eq (dual_order.poset_simplex_map \\<P> ?Y)\n                     (dual_order.poset_simplex_map \\<P> ?X)\n  ?w \\<in> W \\<Longrightarrow>\n  chamber (dual_order.poset_simplex_map \\<P> {?w})\n\ngoal (1 subgoal):\n 1. \\<exists>x. chamber x \\<and> order.greater_eq x y", "by    fastforce"], ["proof (state)\nthis:\n  \\<exists>x. chamber x \\<and> order.greater_eq x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; chamber x; chamber y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. gallery (x # xs @ [y])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; chamber x; chamber y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. gallery (x # xs @ [y])", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; chamber x; chamber y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. gallery (x # xs @ [y])", "assume xy: \"x\\<noteq>y\" \"chamber x\" \"chamber y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n  chamber x\n  chamber y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; chamber x; chamber y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. gallery (x # xs @ [y])", "from xy(2,3)"], ["proof (chain)\npicking this:\n  chamber x\n  chamber y", "obtain w w'\n    where ww': \"w\\<in>W\" \"x = smap {w}\" \"w'\\<in>W\" \"y = smap {w'}\""], ["proof (prove)\nusing this:\n  chamber x\n  chamber y\n\ngoal (1 subgoal):\n 1. (\\<And>w w'.\n        \\<lbrakk>w \\<in> W; x = dual_order.poset_simplex_map \\<P> {w};\n         w' \\<in> W; y = dual_order.poset_simplex_map \\<P> {w'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using chamber_is_singleton"], ["proof (prove)\nusing this:\n  chamber x\n  chamber y\n  chamber ?x \\<Longrightarrow>\n  \\<exists>w\\<in>W. dual_order.poset_simplex_map \\<P> {w} = ?x\n\ngoal (1 subgoal):\n 1. (\\<And>w w'.\n        \\<lbrakk>w \\<in> W; x = dual_order.poset_simplex_map \\<P> {w};\n         w' \\<in> W; y = dual_order.poset_simplex_map \\<P> {w'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    blast"], ["proof (state)\nthis:\n  w \\<in> W\n  x = dual_order.poset_simplex_map \\<P> {w}\n  w' \\<in> W\n  y = dual_order.poset_simplex_map \\<P> {w'}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; chamber x; chamber y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs. gallery (x # xs @ [y])", "show \"\\<exists>zs. gallery (x # zs @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>zs. gallery (x # zs @ [y])", "proof (cases \"w=0\" \"w'=0\" rule: two_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>w = (0::'w); w' = (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 2. \\<lbrakk>w = (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> (0::'w); w' = (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 4. \\<lbrakk>w \\<noteq> (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])", "case both"], ["proof (state)\nthis:\n  w = (0::'w)\n  w' = (0::'w)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>w = (0::'w); w' = (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 2. \\<lbrakk>w = (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> (0::'w); w' = (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 4. \\<lbrakk>w \\<noteq> (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])", "with xy(1) ww'(2,4)"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  x = dual_order.poset_simplex_map \\<P> {w}\n  y = dual_order.poset_simplex_map \\<P> {w'}\n  w = (0::'w)\n  w' = (0::'w)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x = dual_order.poset_simplex_map \\<P> {w}\n  y = dual_order.poset_simplex_map \\<P> {w'}\n  w = (0::'w)\n  w' = (0::'w)\n\ngoal (1 subgoal):\n 1. \\<exists>zs. gallery (x # zs @ [y])", "by fast"], ["proof (state)\nthis:\n  \\<exists>zs. gallery (x # zs @ [y])\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> (0::'w); w' = (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>w = (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> (0::'w); w' = (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])", "case one"], ["proof (state)\nthis:\n  w = (0::'w)\n  w' \\<noteq> (0::'w)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>w = (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> (0::'w); w' = (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 3. \\<lbrakk>w \\<noteq> (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])", "with ww'(2-4)"], ["proof (chain)\npicking this:\n  x = dual_order.poset_simplex_map \\<P> {w}\n  w' \\<in> W\n  y = dual_order.poset_simplex_map \\<P> {w'}\n  w = (0::'w)\n  w' \\<noteq> (0::'w)", "show ?thesis"], ["proof (prove)\nusing this:\n  x = dual_order.poset_simplex_map \\<P> {w}\n  w' \\<in> W\n  y = dual_order.poset_simplex_map \\<P> {w'}\n  w = (0::'w)\n  w' \\<noteq> (0::'w)\n\ngoal (1 subgoal):\n 1. \\<exists>zs. gallery (x # zs @ [y])", "using gallery_to_0 gallery_rev"], ["proof (prove)\nusing this:\n  x = dual_order.poset_simplex_map \\<P> {w}\n  w' \\<in> W\n  y = dual_order.poset_simplex_map \\<P> {w'}\n  w = (0::'w)\n  w' \\<noteq> (0::'w)\n  \\<lbrakk>?w \\<in> W; ?w \\<noteq> (0::'w)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       gallery\n                        (dual_order.poset_simplex_map \\<P> {?w} #\n                         xs @ [dual_order.poset_simplex_map \\<P> 0])\n  gallery ?xs \\<Longrightarrow> gallery (rev ?xs)\n\ngoal (1 subgoal):\n 1. \\<exists>zs. gallery (x # zs @ [y])", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>zs. gallery (x # zs @ [y])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<noteq> (0::'w); w' = (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<noteq> (0::'w); w' = (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])", "case other"], ["proof (state)\nthis:\n  w \\<noteq> (0::'w)\n  w' = (0::'w)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<noteq> (0::'w); w' = (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])\n 2. \\<lbrakk>w \\<noteq> (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])", "with ww'(1,2,4)"], ["proof (chain)\npicking this:\n  w \\<in> W\n  x = dual_order.poset_simplex_map \\<P> {w}\n  y = dual_order.poset_simplex_map \\<P> {w'}\n  w \\<noteq> (0::'w)\n  w' = (0::'w)", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<in> W\n  x = dual_order.poset_simplex_map \\<P> {w}\n  y = dual_order.poset_simplex_map \\<P> {w'}\n  w \\<noteq> (0::'w)\n  w' = (0::'w)\n\ngoal (1 subgoal):\n 1. \\<exists>zs. gallery (x # zs @ [y])", "using gallery_to_0"], ["proof (prove)\nusing this:\n  w \\<in> W\n  x = dual_order.poset_simplex_map \\<P> {w}\n  y = dual_order.poset_simplex_map \\<P> {w'}\n  w \\<noteq> (0::'w)\n  w' = (0::'w)\n  \\<lbrakk>?w \\<in> W; ?w \\<noteq> (0::'w)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       gallery\n                        (dual_order.poset_simplex_map \\<P> {?w} #\n                         xs @ [dual_order.poset_simplex_map \\<P> 0])\n\ngoal (1 subgoal):\n 1. \\<exists>zs. gallery (x # zs @ [y])", "by auto"], ["proof (state)\nthis:\n  \\<exists>zs. gallery (x # zs @ [y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])", "case neither"], ["proof (state)\nthis:\n  w \\<noteq> (0::'w)\n  w' \\<noteq> (0::'w)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])", "from this ww'"], ["proof (chain)\npicking this:\n  w \\<noteq> (0::'w)\n  w' \\<noteq> (0::'w)\n  w \\<in> W\n  x = dual_order.poset_simplex_map \\<P> {w}\n  w' \\<in> W\n  y = dual_order.poset_simplex_map \\<P> {w'}", "obtain xs ys\n      where \"gallery (x # xs @ [smap 0])\" \"gallery (smap 0 # ys @ [y])\""], ["proof (prove)\nusing this:\n  w \\<noteq> (0::'w)\n  w' \\<noteq> (0::'w)\n  w \\<in> W\n  x = dual_order.poset_simplex_map \\<P> {w}\n  w' \\<in> W\n  y = dual_order.poset_simplex_map \\<P> {w'}\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>gallery (x # xs @ [dual_order.poset_simplex_map \\<P> 0]);\n         gallery (dual_order.poset_simplex_map \\<P> 0 # ys @ [y])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using gallery_to_0 gallery_rev"], ["proof (prove)\nusing this:\n  w \\<noteq> (0::'w)\n  w' \\<noteq> (0::'w)\n  w \\<in> W\n  x = dual_order.poset_simplex_map \\<P> {w}\n  w' \\<in> W\n  y = dual_order.poset_simplex_map \\<P> {w'}\n  \\<lbrakk>?w \\<in> W; ?w \\<noteq> (0::'w)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       gallery\n                        (dual_order.poset_simplex_map \\<P> {?w} #\n                         xs @ [dual_order.poset_simplex_map \\<P> 0])\n  gallery ?xs \\<Longrightarrow> gallery (rev ?xs)\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>gallery (x # xs @ [dual_order.poset_simplex_map \\<P> 0]);\n         gallery (dual_order.poset_simplex_map \\<P> 0 # ys @ [y])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    force"], ["proof (state)\nthis:\n  gallery (x # xs @ [dual_order.poset_simplex_map \\<P> 0])\n  gallery (dual_order.poset_simplex_map \\<P> 0 # ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])", "hence \"gallery (x # (xs @ smap 0 # ys) @ [y])\""], ["proof (prove)\nusing this:\n  gallery (x # xs @ [dual_order.poset_simplex_map \\<P> 0])\n  gallery (dual_order.poset_simplex_map \\<P> 0 # ys @ [y])\n\ngoal (1 subgoal):\n 1. gallery (x # (xs @ dual_order.poset_simplex_map \\<P> 0 # ys) @ [y])", "using gallery_overlap_join[of \"x#xs\"]"], ["proof (prove)\nusing this:\n  gallery (x # xs @ [dual_order.poset_simplex_map \\<P> 0])\n  gallery (dual_order.poset_simplex_map \\<P> 0 # ys @ [y])\n  \\<lbrakk>gallery ((x # xs) @ [?w]); gallery (?w # ?ys)\\<rbrakk>\n  \\<Longrightarrow> gallery ((x # xs) @ ?w # ?ys)\n\ngoal (1 subgoal):\n 1. gallery (x # (xs @ dual_order.poset_simplex_map \\<P> 0 # ys) @ [y])", "by simp"], ["proof (state)\nthis:\n  gallery (x # (xs @ dual_order.poset_simplex_map \\<P> 0 # ys) @ [y])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> (0::'w); w' \\<noteq> (0::'w)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. gallery (x # zs @ [y])", "thus ?thesis"], ["proof (prove)\nusing this:\n  gallery (x # (xs @ dual_order.poset_simplex_map \\<P> 0 # ys) @ [y])\n\ngoal (1 subgoal):\n 1. \\<exists>zs. gallery (x # zs @ [y])", "by fast"], ["proof (state)\nthis:\n  \\<exists>zs. gallery (x # zs @ [y])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>zs. gallery (x # zs @ [y])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_chamber: \"chamber x \\<Longrightarrow> card x = card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chamber x \\<Longrightarrow> card x = card S", "using bij_betw_same_card[OF S_bij_betw_chamber0] chamber_singleton\n        genby_0_closed[of S]\n        ChamberComplex.chamber_card[OF ChamberComplex_\\<Sigma>, of \"smap 0\"]"], ["proof (prove)\nusing this:\n  card S = card (dual_order.poset_simplex_map \\<P> 0)\n  ?w \\<in> W \\<Longrightarrow>\n  chamber (dual_order.poset_simplex_map \\<P> {?w})\n  (0::'w) \\<in> W\n  \\<lbrakk>chamber (dual_order.poset_simplex_map \\<P> 0);\n   chamber ?D\\<rbrakk>\n  \\<Longrightarrow> card (dual_order.poset_simplex_map \\<P> 0) = card ?D\n\ngoal (1 subgoal):\n 1. chamber x \\<Longrightarrow> card x = card S", "by    simp"], ["", "lemma vertex_conv_special_coset:\n  \"X\\<in>\\<Union>\\<Sigma> \\<Longrightarrow> \\<exists>w s. w\\<in>W \\<and> s\\<in>S \\<and> X = w +o \\<langle>S-{s}\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> \\<Union> \\<Sigma> \\<Longrightarrow>\n    \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "using ChamberComplex.simplex_in_max[OF ChamberComplex_\\<Sigma>] chamber_is_singleton\n        chamber_vertex_conv_special_coset"], ["proof (prove)\nusing this:\n  ?y \\<in> \\<Sigma> \\<Longrightarrow>\n  \\<exists>x. chamber x \\<and> order.greater_eq x ?y\n  chamber ?x \\<Longrightarrow>\n  \\<exists>w\\<in>W. dual_order.poset_simplex_map \\<P> {w} = ?x\n  \\<lbrakk>?w \\<in> W;\n   ?X \\<in> dual_order.poset_simplex_map \\<P> {?w}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s\\<in>S. ?X = ?w +o \\<langle>S - {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. X \\<in> \\<Union> \\<Sigma> \\<Longrightarrow>\n    \\<exists>w s.\n       w \\<in> W \\<and> s \\<in> S \\<and> X = w +o \\<langle>S - {s}\\<rangle>", "by    fast"], ["", "end"], ["", "(* context CoxeterComplex *)"], ["", "subsubsection \\<open>The Coxeter complex associated to a thin chamber complex with many foldings\\<close>"], ["", "text \\<open>\n  Having previously verified that the fundamental automorphisms in a thin chamber complex with many\n  foldings form a Coxeter system, we now record the existence of a chamber complex isomorphism onto\n  the associated Coxeter complex.\n\\<close>"], ["", "context ThinChamberComplexManyFoldings\nbegin"], ["", "lemma CoxeterComplex: \"CoxeterComplex S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CoxeterComplex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "by  (\n        rule CoxeterComplex.intro, rule CoxeterSystem, unfold_locales,\n        rule finite_S\n      )"], ["", "abbreviation \"\\<Sigma> \\<equiv> CoxeterComplex.TheComplex S\""], ["", "lemma S_list_not_min_gallery_not_reduced:\n  assumes \"ss\\<noteq>[]\" \"\\<not> min_gallery (map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss))\"\n  shows \"\\<not> reduced_word S ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss", "proof (cases \"ss\\<in>lists S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ss \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<not> reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss\n 2. ss \\<notin> lists\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<not> reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss", "case True"], ["proof (state)\nthis:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (2 subgoals):\n 1. ss \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<not> reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss\n 2. ss \\<notin> lists\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<not> reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss", "obtain a b as bs cs\n    where \"ss = as@[a]@bs@[b]@cs\" \"sum_list ss = sum_list (as@bs@cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as a bs b cs.\n        \\<lbrakk>ss = as @ [a] @ bs @ [b] @ cs;\n         sum_list ss = sum_list (as @ bs @ cs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using S_list_not_min_gallery_deletion [OF True assms]"], ["proof (prove)\nusing this:\n  \\<exists>a b as bs cs.\n     ss = as @ [a] @ bs @ [b] @ cs \\<and>\n     sum_list ss = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. (\\<And>as a bs b cs.\n        \\<lbrakk>ss = as @ [a] @ bs @ [b] @ cs;\n         sum_list ss = sum_list (as @ bs @ cs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ss = as @ [a] @ bs @ [b] @ cs\n  sum_list ss = sum_list (as @ bs @ cs)\n\ngoal (2 subgoals):\n 1. ss \\<in> lists\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<not> reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss\n 2. ss \\<notin> lists\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<not> reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss", "with True"], ["proof (chain)\npicking this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss = as @ [a] @ bs @ [b] @ cs\n  sum_list ss = sum_list (as @ bs @ cs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss = as @ [a] @ bs @ [b] @ cs\n  sum_list ss = sum_list (as @ bs @ cs)\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss", "using not_reduced_word_for[of \"as@bs@cs\"]"], ["proof (prove)\nusing this:\n  ss \\<in> lists\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ss = as @ [a] @ bs @ [b] @ cs\n  sum_list ss = sum_list (as @ bs @ cs)\n  \\<lbrakk>as @ bs @ cs \\<in> lists ?A; sum_list (as @ bs @ cs) = ?a;\n   order.greater (length ?as) (length (as @ bs @ cs))\\<rbrakk>\n  \\<Longrightarrow> \\<not> reduced_word_for ?A ?a ?as\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss", "by auto"], ["proof (state)\nthis:\n  \\<not> reduced_word\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) ss\n\ngoal (1 subgoal):\n 1. ss \\<notin> lists\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<not> reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ss \\<notin> lists\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<not> reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss", "case False"], ["proof (state)\nthis:\n  ss \\<notin> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. ss \\<notin> lists\n                 (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}) \\<Longrightarrow>\n    \\<not> reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss", "thus ?thesis"], ["proof (prove)\nusing this:\n  ss \\<notin> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss", "using reduced_word_for_lists"], ["proof (prove)\nusing this:\n  ss \\<notin> lists\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. \\<not> reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss", "by fast"], ["proof (state)\nthis:\n  \\<not> reduced_word\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) ss\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduced_S_list_min_gallery:\n  \"ss\\<noteq>[] \\<Longrightarrow> reduced_word S ss \\<Longrightarrow> min_gallery (map (\\<lambda>w. w`\\<rightarrow>C0) (sums ss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<noteq> [];\n     reduced_word\n      (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n      ss\\<rbrakk>\n    \\<Longrightarrow> min_gallery\n                       (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "using S_list_not_min_gallery_not_reduced"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ss \\<noteq> [];\n   \\<not> min_gallery\n           (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ?ss))\\<rbrakk>\n  \\<Longrightarrow> \\<not> reduced_word\n                            (\\<Union>(f, g)\\<in>fundfoldpairs.\n                                {Abs_induced_automorph f g})\n                            ?ss\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ss \\<noteq> [];\n     reduced_word\n      (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n      ss\\<rbrakk>\n    \\<Longrightarrow> min_gallery\n                       (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ss))", "by fast"], ["", "lemma fundchamber_vertex_stabilizer1:\n  fixes   t\n  defines v:  \"v \\<equiv> fundantivertex t\"\n  assumes tw: \"t\\<in>S\" \"w\\<in>W\" \"w\\<rightarrow>v = v\"\n  shows   \"w \\<in> \\<langle>S-{t}\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}) -\n                     {t}\\<rangle>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}) -\n                     {t}\\<rangle>", "from v tw(1)"], ["proof (chain)\npicking this:\n  v \\<equiv> fundantivertex t\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "have v_C0: \"v\\<in>C0\""], ["proof (prove)\nusing this:\n  v \\<equiv> fundantivertex t\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. v \\<in> C0", "using fundantivertex"], ["proof (prove)\nusing this:\n  v \\<equiv> fundantivertex t\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  fundantivertex ?s \\<in> C0 - ?s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. v \\<in> C0", "by simp"], ["proof (state)\nthis:\n  v \\<in> C0\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}) -\n                     {t}\\<rangle>", "define ss where \"ss = arg_min length (word_for S w)\""], ["proof (state)\nthis:\n  ss =\n  arg_min length\n   (word_for (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     w)\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}) -\n                     {t}\\<rangle>", "moreover"], ["proof (state)\nthis:\n  ss =\n  arg_min length\n   (word_for (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     w)\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}) -\n                     {t}\\<rangle>", "have \"reduced_word S ss \\<Longrightarrow> sum_list ss \\<rightarrow> v = v \\<Longrightarrow> sum_list ss \\<in> \\<langle>S-{t}\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              ss;\n     sum_list ss \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list ss\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>", "proof (induct ss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>reduced_word\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          ss;\n                 sum_list ss \\<rightarrow> v = v\\<rbrakk>\n                \\<Longrightarrow> sum_list ss\n                                  \\<in> \\<langle>(\\<Union>(f,\n               g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {t}\\<rangle>;\n        reduced_word\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (a # ss);\n        sum_list (a # ss) \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss)\n                         \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n      {Abs_induced_automorph f g}) -\n  {t}\\<rangle>", "case (Cons s ss)"], ["proof (state)\nthis:\n  \\<lbrakk>reduced_word\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n            ss;\n   sum_list ss \\<rightarrow> v = v\\<rbrakk>\n  \\<Longrightarrow> sum_list ss\n                    \\<in> \\<langle>(\\<Union>a\\<in>fundfoldpairs.\n case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g}) -\n                                   {t}\\<rangle>\n  reduced_word\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (s # ss)\n  sum_list (s # ss) \\<rightarrow> v = v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>reduced_word\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          ss;\n                 sum_list ss \\<rightarrow> v = v\\<rbrakk>\n                \\<Longrightarrow> sum_list ss\n                                  \\<in> \\<langle>(\\<Union>(f,\n               g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {t}\\<rangle>;\n        reduced_word\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (a # ss);\n        sum_list (a # ss) \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss)\n                         \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n      {Abs_induced_automorph f g}) -\n  {t}\\<rangle>", "from Cons(2)"], ["proof (chain)\npicking this:\n  reduced_word\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (s # ss)", "have s_S: \"s\\<in>S\""], ["proof (prove)\nusing this:\n  reduced_word\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (s # ss)\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "using reduced_word_for_lists"], ["proof (prove)\nusing this:\n  reduced_word\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (s # ss)\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> ?as \\<in> lists ?A\n\ngoal (1 subgoal):\n 1. s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "by fastforce"], ["proof (state)\nthis:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>reduced_word\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          ss;\n                 sum_list ss \\<rightarrow> v = v\\<rbrakk>\n                \\<Longrightarrow> sum_list ss\n                                  \\<in> \\<langle>(\\<Union>(f,\n               g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {t}\\<rangle>;\n        reduced_word\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (a # ss);\n        sum_list (a # ss) \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss)\n                         \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n      {Abs_induced_automorph f g}) -\n  {t}\\<rangle>", "from this"], ["proof (chain)\npicking this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "obtain f g\n      where fg: \"(f,g)\\<in>fundfoldpairs\" \"s = Abs_induced_automorph f g\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>(f, g) \\<in> fundfoldpairs;\n         s = Abs_induced_automorph f g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    auto"], ["proof (state)\nthis:\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>reduced_word\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          ss;\n                 sum_list ss \\<rightarrow> v = v\\<rbrakk>\n                \\<Longrightarrow> sum_list ss\n                                  \\<in> \\<langle>(\\<Union>(f,\n               g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {t}\\<rangle>;\n        reduced_word\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (a # ss);\n        sum_list (a # ss) \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss)\n                         \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n      {Abs_induced_automorph f g}) -\n  {t}\\<rangle>", "from fg(1)"], ["proof (chain)\npicking this:\n  (f, g) \\<in> fundfoldpairs", "have opp_fg: \"OpposedThinChamberComplexFoldings X f g C0\""], ["proof (prove)\nusing this:\n  (f, g) \\<in> fundfoldpairs\n\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings X f g C0", "using fundfoldpairs_def"], ["proof (prove)\nusing this:\n  (f, g) \\<in> fundfoldpairs\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n\ngoal (1 subgoal):\n 1. OpposedThinChamberComplexFoldings X f g C0", "by auto"], ["proof (state)\nthis:\n  OpposedThinChamberComplexFoldings X f g C0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>reduced_word\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          ss;\n                 sum_list ss \\<rightarrow> v = v\\<rbrakk>\n                \\<Longrightarrow> sum_list ss\n                                  \\<in> \\<langle>(\\<Union>(f,\n               g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {t}\\<rangle>;\n        reduced_word\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (a # ss);\n        sum_list (a # ss) \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss)\n                         \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n      {Abs_induced_automorph f g}) -\n  {t}\\<rangle>", "define Cs where \"Cs = map (\\<lambda>w. w`\\<rightarrow>C0) (sums (s#ss))\""], ["proof (state)\nthis:\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums (s # ss))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>reduced_word\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          ss;\n                 sum_list ss \\<rightarrow> v = v\\<rbrakk>\n                \\<Longrightarrow> sum_list ss\n                                  \\<in> \\<langle>(\\<Union>(f,\n               g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {t}\\<rangle>;\n        reduced_word\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (a # ss);\n        sum_list (a # ss) \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss)\n                         \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n      {Abs_induced_automorph f g}) -\n  {t}\\<rangle>", "with Cons(2)"], ["proof (chain)\npicking this:\n  reduced_word\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (s # ss)\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums (s # ss))", "have minCs: \"min_gallery Cs\""], ["proof (prove)\nusing this:\n  reduced_word\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (s # ss)\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums (s # ss))\n\ngoal (1 subgoal):\n 1. min_gallery Cs", "using reduced_S_list_min_gallery"], ["proof (prove)\nusing this:\n  reduced_word\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (s # ss)\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums (s # ss))\n  \\<lbrakk>?ss \\<noteq> [];\n   reduced_word\n    (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n    ?ss\\<rbrakk>\n  \\<Longrightarrow> min_gallery\n                     (map (\\<lambda>w. w `\\<rightarrow> C0) (sums ?ss))\n\ngoal (1 subgoal):\n 1. min_gallery Cs", "by fast"], ["proof (state)\nthis:\n  min_gallery Cs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>reduced_word\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          ss;\n                 sum_list ss \\<rightarrow> v = v\\<rbrakk>\n                \\<Longrightarrow> sum_list ss\n                                  \\<in> \\<langle>(\\<Union>(f,\n               g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {t}\\<rangle>;\n        reduced_word\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (a # ss);\n        sum_list (a # ss) \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss)\n                         \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n      {Abs_induced_automorph f g}) -\n  {t}\\<rangle>", "have sv: \"s\\<rightarrow>v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<rightarrow> v = v", "proof (cases ss rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ss = [] \\<Longrightarrow> s \\<rightarrow> v = v\n 2. \\<And>ys y. ss = ys @ [y] \\<Longrightarrow> s \\<rightarrow> v = v", "case Nil"], ["proof (state)\nthis:\n  ss = []\n\ngoal (2 subgoals):\n 1. ss = [] \\<Longrightarrow> s \\<rightarrow> v = v\n 2. \\<And>ys y. ss = ys @ [y] \\<Longrightarrow> s \\<rightarrow> v = v", "with Cons(3)"], ["proof (chain)\npicking this:\n  sum_list (s # ss) \\<rightarrow> v = v\n  ss = []", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (s # ss) \\<rightarrow> v = v\n  ss = []\n\ngoal (1 subgoal):\n 1. s \\<rightarrow> v = v", "by simp"], ["proof (state)\nthis:\n  s \\<rightarrow> v = v\n\ngoal (1 subgoal):\n 1. \\<And>ys y. ss = ys @ [y] \\<Longrightarrow> s \\<rightarrow> v = v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y. ss = ys @ [y] \\<Longrightarrow> s \\<rightarrow> v = v", "case (snoc ts t)"], ["proof (state)\nthis:\n  ss = ts @ [t]\n\ngoal (1 subgoal):\n 1. \\<And>ys y. ss = ys @ [y] \\<Longrightarrow> s \\<rightarrow> v = v", "define Ms Cn\n        where \"Ms = map (\\<lambda>w. w`\\<rightarrow>C0) (map ((+) s) (sums ts))\"\n          and \"Cn = sum_list (s#ss) `\\<rightarrow> C0\""], ["proof (state)\nthis:\n  Ms = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) s) (sums ts))\n  Cn = sum_list (s # ss) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>ys y. ss = ys @ [y] \\<Longrightarrow> s \\<rightarrow> v = v", "with snoc Cs_def"], ["proof (chain)\npicking this:\n  ss = ts @ [t]\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums (s # ss))\n  Ms = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) s) (sums ts))\n  Cn = sum_list (s # ss) `\\<rightarrow> C0", "have \"Cs = C0 # Ms @ [Cn]\""], ["proof (prove)\nusing this:\n  ss = ts @ [t]\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums (s # ss))\n  Ms = map (\\<lambda>w. w `\\<rightarrow> C0) (map ((+) s) (sums ts))\n  Cn = sum_list (s # ss) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. Cs = C0 # Ms @ [Cn]", "by (simp add: sums_snoc zero_permutation.rep_eq)"], ["proof (state)\nthis:\n  Cs = C0 # Ms @ [Cn]\n\ngoal (1 subgoal):\n 1. \\<And>ys y. ss = ys @ [y] \\<Longrightarrow> s \\<rightarrow> v = v", "with minCs Cs_def fg"], ["proof (chain)\npicking this:\n  min_gallery Cs\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums (s # ss))\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g\n  Cs = C0 # Ms @ [Cn]", "have \"C0\\<in>f\\<turnstile>\\<C>\" \"Cn\\<in>g\\<turnstile>\\<C>\""], ["proof (prove)\nusing this:\n  min_gallery Cs\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums (s # ss))\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g\n  Cs = C0 # Ms @ [Cn]\n\ngoal (1 subgoal):\n 1. C0 \\<in> f \\<turnstile> \\<C> &&& Cn \\<in> g \\<turnstile> \\<C>", "using sums_Cons_conv_append_tl[THEN sym, of s ss]\n              wall_crossings_subset_walls_betw[of C0 Ms Cn] fundfoldpairs_def\n              the_wall_betw_adj_fundchamber walls_betw_def\n              OpposedThinChamberComplexFoldings.basech_halfchsys(1)[\n                OF opp_fg\n              ]\n              OpposedThinChamberComplexFoldings.separated_by_this_wall_fg[\n                OF opp_fg, of C0 Cn\n              ]"], ["proof (prove)\nusing this:\n  min_gallery Cs\n  Cs = map (\\<lambda>w. w `\\<rightarrow> C0) (sums (s # ss))\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g\n  Cs = C0 # Ms @ [Cn]\n  0 # s # map ((+) s) (tl (sums ss)) = sums (s # ss)\n  min_gallery (C0 # Ms @ [Cn]) \\<Longrightarrow>\n  order.greater_eq (walls_betw C0 Cn)\n   (set (wall_crossings (C0 # Ms @ [Cn])))\n  fundfoldpairs \\<equiv>\n  {(f, g). OpposedThinChamberComplexFoldings X f g C0}\n  (?f, ?g) \\<in> fundfoldpairs \\<Longrightarrow>\n  THE_default {}\n   (\\<lambda>H.\n       H \\<in> (\\<Union>(f, g)\\<in>foldpairs.\n                   {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}) \\<and>\n       separated_by H C0 (Abs_induced_automorph ?f ?g `\\<rightarrow> C0)) =\n  {?f \\<turnstile> \\<C>, ?g \\<turnstile> \\<C>}\n  walls_betw ?C ?D \\<equiv>\n  {H \\<in> \\<Union>(f, g)\\<in>foldpairs.\n              {{f \\<turnstile> \\<C>, g \\<turnstile> \\<C>}}.\n   separated_by H ?C ?D}\n  C0 \\<in> f \\<turnstile> \\<C>\n  \\<lbrakk>separated_by {f \\<turnstile> \\<C>, g \\<turnstile> \\<C>} C0 Cn;\n   C0 \\<in> f \\<turnstile> \\<C>\\<rbrakk>\n  \\<Longrightarrow> Cn \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. C0 \\<in> f \\<turnstile> \\<C> &&& Cn \\<in> g \\<turnstile> \\<C>", "by    (auto simp add: zero_permutation.rep_eq)"], ["proof (state)\nthis:\n  C0 \\<in> f \\<turnstile> \\<C>\n  Cn \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<And>ys y. ss = ys @ [y] \\<Longrightarrow> s \\<rightarrow> v = v", "moreover"], ["proof (state)\nthis:\n  C0 \\<in> f \\<turnstile> \\<C>\n  Cn \\<in> g \\<turnstile> \\<C>\n\ngoal (1 subgoal):\n 1. \\<And>ys y. ss = ys @ [y] \\<Longrightarrow> s \\<rightarrow> v = v", "from Cons(3) Cn_def"], ["proof (chain)\npicking this:\n  sum_list (s # ss) \\<rightarrow> v = v\n  Cn = sum_list (s # ss) `\\<rightarrow> C0", "have \"v\\<in>Cn\""], ["proof (prove)\nusing this:\n  sum_list (s # ss) \\<rightarrow> v = v\n  Cn = sum_list (s # ss) `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. v \\<in> Cn", "using v_C0"], ["proof (prove)\nusing this:\n  sum_list (s # ss) \\<rightarrow> v = v\n  Cn = sum_list (s # ss) `\\<rightarrow> C0\n  v \\<in> C0\n\ngoal (1 subgoal):\n 1. v \\<in> Cn", "by force"], ["proof (state)\nthis:\n  v \\<in> Cn\n\ngoal (1 subgoal):\n 1. \\<And>ys y. ss = ys @ [y] \\<Longrightarrow> s \\<rightarrow> v = v", "ultimately"], ["proof (chain)\npicking this:\n  C0 \\<in> f \\<turnstile> \\<C>\n  Cn \\<in> g \\<turnstile> \\<C>\n  v \\<in> Cn", "show \"s\\<rightarrow>v = v\""], ["proof (prove)\nusing this:\n  C0 \\<in> f \\<turnstile> \\<C>\n  Cn \\<in> g \\<turnstile> \\<C>\n  v \\<in> Cn\n\ngoal (1 subgoal):\n 1. s \\<rightarrow> v = v", "using v_C0 fg\n              OpposedThinChamberComplexFoldings.indaut_wallvertex[\n                OF opp_fg\n              ]"], ["proof (prove)\nusing this:\n  C0 \\<in> f \\<turnstile> \\<C>\n  Cn \\<in> g \\<turnstile> \\<C>\n  v \\<in> Cn\n  v \\<in> C0\n  (f, g) \\<in> fundfoldpairs\n  s = Abs_induced_automorph f g\n  \\<lbrakk>?C \\<in> f \\<turnstile> \\<C>; ?D \\<in> g \\<turnstile> \\<C>;\n   ?v \\<in> ?C \\<inter> ?D\\<rbrakk>\n  \\<Longrightarrow> induced_automorph f g ?v = ?v\n\ngoal (1 subgoal):\n 1. s \\<rightarrow> v = v", "by    (simp add: permutation_conv_induced_automorph)"], ["proof (state)\nthis:\n  s \\<rightarrow> v = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<rightarrow> v = v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>reduced_word\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          ss;\n                 sum_list ss \\<rightarrow> v = v\\<rbrakk>\n                \\<Longrightarrow> sum_list ss\n                                  \\<in> \\<langle>(\\<Union>(f,\n               g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {t}\\<rangle>;\n        reduced_word\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (a # ss);\n        sum_list (a # ss) \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss)\n                         \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n      {Abs_induced_automorph f g}) -\n  {t}\\<rangle>", "moreover"], ["proof (state)\nthis:\n  s \\<rightarrow> v = v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>reduced_word\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          ss;\n                 sum_list ss \\<rightarrow> v = v\\<rbrakk>\n                \\<Longrightarrow> sum_list ss\n                                  \\<in> \\<langle>(\\<Union>(f,\n               g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {t}\\<rangle>;\n        reduced_word\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (a # ss);\n        sum_list (a # ss) \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss)\n                         \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n      {Abs_induced_automorph f g}) -\n  {t}\\<rangle>", "from Cons(3)"], ["proof (chain)\npicking this:\n  sum_list (s # ss) \\<rightarrow> v = v", "have \"0 \\<rightarrow> sum_list ss \\<rightarrow> v = s\\<rightarrow>v\""], ["proof (prove)\nusing this:\n  sum_list (s # ss) \\<rightarrow> v = v\n\ngoal (1 subgoal):\n 1. 0 \\<rightarrow> sum_list ss \\<rightarrow> v = s \\<rightarrow> v", "using s_S"], ["proof (prove)\nusing this:\n  sum_list (s # ss) \\<rightarrow> v = v\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. 0 \\<rightarrow> sum_list ss \\<rightarrow> v = s \\<rightarrow> v", "by    (simp add: plus_permutation.rep_eq S_order2_add[THEN sym])"], ["proof (state)\nthis:\n  0 \\<rightarrow> sum_list ss \\<rightarrow> v = s \\<rightarrow> v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>reduced_word\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          ss;\n                 sum_list ss \\<rightarrow> v = v\\<rbrakk>\n                \\<Longrightarrow> sum_list ss\n                                  \\<in> \\<langle>(\\<Union>(f,\n               g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {t}\\<rangle>;\n        reduced_word\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (a # ss);\n        sum_list (a # ss) \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss)\n                         \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n      {Abs_induced_automorph f g}) -\n  {t}\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  s \\<rightarrow> v = v\n  0 \\<rightarrow> sum_list ss \\<rightarrow> v = s \\<rightarrow> v", "have \"sum_list ss \\<rightarrow> v = v\""], ["proof (prove)\nusing this:\n  s \\<rightarrow> v = v\n  0 \\<rightarrow> sum_list ss \\<rightarrow> v = s \\<rightarrow> v\n\ngoal (1 subgoal):\n 1. sum_list ss \\<rightarrow> v = v", "by (simp add: zero_permutation.rep_eq)"], ["proof (state)\nthis:\n  sum_list ss \\<rightarrow> v = v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>reduced_word\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          ss;\n                 sum_list ss \\<rightarrow> v = v\\<rbrakk>\n                \\<Longrightarrow> sum_list ss\n                                  \\<in> \\<langle>(\\<Union>(f,\n               g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {t}\\<rangle>;\n        reduced_word\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (a # ss);\n        sum_list (a # ss) \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss)\n                         \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n      {Abs_induced_automorph f g}) -\n  {t}\\<rangle>", "with Cons(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>reduced_word\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n            ss;\n   sum_list ss \\<rightarrow> v = v\\<rbrakk>\n  \\<Longrightarrow> sum_list ss\n                    \\<in> \\<langle>(\\<Union>a\\<in>fundfoldpairs.\n case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g}) -\n                                   {t}\\<rangle>\n  reduced_word\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (s # ss)\n  sum_list ss \\<rightarrow> v = v", "have \"sum_list ss \\<in> \\<langle>S-{t}\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>reduced_word\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n            ss;\n   sum_list ss \\<rightarrow> v = v\\<rbrakk>\n  \\<Longrightarrow> sum_list ss\n                    \\<in> \\<langle>(\\<Union>a\\<in>fundfoldpairs.\n case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g}) -\n                                   {t}\\<rangle>\n  reduced_word\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (s # ss)\n  sum_list ss \\<rightarrow> v = v\n\ngoal (1 subgoal):\n 1. sum_list ss\n    \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {t}\\<rangle>", "using reduced_word_Cons_reduce"], ["proof (prove)\nusing this:\n  \\<lbrakk>reduced_word\n            (\\<Union>a\\<in>fundfoldpairs.\n                case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n            ss;\n   sum_list ss \\<rightarrow> v = v\\<rbrakk>\n  \\<Longrightarrow> sum_list ss\n                    \\<in> \\<langle>(\\<Union>a\\<in>fundfoldpairs.\n case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g}) -\n                                   {t}\\<rangle>\n  reduced_word\n   (\\<Union>a\\<in>fundfoldpairs.\n       case a of (f, g) \\<Rightarrow> {Abs_induced_automorph f g})\n   (s # ss)\n  sum_list ss \\<rightarrow> v = v\n  reduced_word ?A (?a # ?as) \\<Longrightarrow> reduced_word ?A ?as\n\ngoal (1 subgoal):\n 1. sum_list ss\n    \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {t}\\<rangle>", "by auto"], ["proof (state)\nthis:\n  sum_list ss\n  \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}) -\n                 {t}\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>reduced_word\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          ss;\n                 sum_list ss \\<rightarrow> v = v\\<rbrakk>\n                \\<Longrightarrow> sum_list ss\n                                  \\<in> \\<langle>(\\<Union>(f,\n               g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {t}\\<rangle>;\n        reduced_word\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (a # ss);\n        sum_list (a # ss) \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss)\n                         \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n      {Abs_induced_automorph f g}) -\n  {t}\\<rangle>", "moreover"], ["proof (state)\nthis:\n  sum_list ss\n  \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}) -\n                 {t}\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>reduced_word\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          ss;\n                 sum_list ss \\<rightarrow> v = v\\<rbrakk>\n                \\<Longrightarrow> sum_list ss\n                                  \\<in> \\<langle>(\\<Union>(f,\n               g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {t}\\<rangle>;\n        reduced_word\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (a # ss);\n        sum_list (a # ss) \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss)\n                         \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n      {Abs_induced_automorph f g}) -\n  {t}\\<rangle>", "from tw(1) v"], ["proof (chain)\npicking this:\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  v \\<equiv> fundantivertex t", "have \"s\\<in>\\<langle>S-{t}\\<rangle>\""], ["proof (prove)\nusing this:\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  v \\<equiv> fundantivertex t\n\ngoal (1 subgoal):\n 1. s \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}) -\n                     {t}\\<rangle>", "using sv s_S genby_genset_closed[of s \"S-{t}\"] fundantivertex_unstable"], ["proof (prove)\nusing this:\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  v \\<equiv> fundantivertex t\n  s \\<rightarrow> v = v\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n          {t} \\<Longrightarrow>\n  s \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {t}\\<rangle>\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  ?s \\<rightarrow> fundantivertex ?s \\<noteq> fundantivertex ?s\n\ngoal (1 subgoal):\n 1. s \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}) -\n                     {t}\\<rangle>", "by    fastforce"], ["proof (state)\nthis:\n  s \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {t}\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>reduced_word\n                          (\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g})\n                          ss;\n                 sum_list ss \\<rightarrow> v = v\\<rbrakk>\n                \\<Longrightarrow> sum_list ss\n                                  \\<in> \\<langle>(\\<Union>(f,\n               g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {t}\\<rangle>;\n        reduced_word\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n         (a # ss);\n        sum_list (a # ss) \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # ss)\n                         \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n      {Abs_induced_automorph f g}) -\n  {t}\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  sum_list ss\n  \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}) -\n                 {t}\\<rangle>\n  s \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {t}\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  sum_list ss\n  \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}) -\n                 {t}\\<rangle>\n  s \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {t}\\<rangle>\n\ngoal (1 subgoal):\n 1. sum_list (s # ss)\n    \\<in> \\<langle>(\\<Union>a\\<in>fundfoldpairs.\n                       case a of\n                       (f, g) \\<Rightarrow> {Abs_induced_automorph f g}) -\n                   {t}\\<rangle>", "using genby_add_closed"], ["proof (prove)\nusing this:\n  sum_list ss\n  \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}) -\n                 {t}\\<rangle>\n  s \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {t}\\<rangle>\n  \\<lbrakk>?g \\<in> \\<langle>?S\\<rangle>;\n   ?h \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?g + ?h \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. sum_list (s # ss)\n    \\<in> \\<langle>(\\<Union>a\\<in>fundfoldpairs.\n                       case a of\n                       (f, g) \\<Rightarrow> {Abs_induced_automorph f g}) -\n                   {t}\\<rangle>", "by simp"], ["proof (state)\nthis:\n  sum_list (s # ss)\n  \\<in> \\<langle>(\\<Union>a\\<in>fundfoldpairs.\n                     case a of\n                     (f, g) \\<Rightarrow> {Abs_induced_automorph f g}) -\n                 {t}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reduced_word\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})\n              [];\n     sum_list [] \\<rightarrow> v = v\\<rbrakk>\n    \\<Longrightarrow> sum_list []\n                      \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}) -\n                                     {t}\\<rangle>", "qed (simp add: genby_0_closed)"], ["proof (state)\nthis:\n  \\<lbrakk>reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss;\n   sum_list ss \\<rightarrow> v = v\\<rbrakk>\n  \\<Longrightarrow> sum_list ss\n                    \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n {Abs_induced_automorph f g}) -\n                                   {t}\\<rangle>\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}) -\n                     {t}\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  ss =\n  arg_min length\n   (word_for (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     w)\n  \\<lbrakk>reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss;\n   sum_list ss \\<rightarrow> v = v\\<rbrakk>\n  \\<Longrightarrow> sum_list ss\n                    \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n {Abs_induced_automorph f g}) -\n                                   {t}\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  ss =\n  arg_min length\n   (word_for (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     w)\n  \\<lbrakk>reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss;\n   sum_list ss \\<rightarrow> v = v\\<rbrakk>\n  \\<Longrightarrow> sum_list ss\n                    \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n {Abs_induced_automorph f g}) -\n                                   {t}\\<rangle>\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}) -\n                     {t}\\<rangle>", "using tw(2,3) reduced_word_for_genby_sym_arg_min[OF S_sym]\n          reduced_word_for_sum_list"], ["proof (prove)\nusing this:\n  ss =\n  arg_min length\n   (word_for (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     w)\n  \\<lbrakk>reduced_word\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n            ss;\n   sum_list ss \\<rightarrow> v = v\\<rbrakk>\n  \\<Longrightarrow> sum_list ss\n                    \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n {Abs_induced_automorph f g}) -\n                                   {t}\\<rangle>\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  w \\<rightarrow> v = v\n  ?a \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f\n                         g}\\<rangle> \\<Longrightarrow>\n  reduced_word_for\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) ?a\n   (arg_min length\n     (word_for\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) ?a))\n  reduced_word_for ?A ?a ?as \\<Longrightarrow> sum_list ?as = ?a\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}) -\n                     {t}\\<rangle>", "by    fastforce"], ["proof (state)\nthis:\n  w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {t}\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fundchamber_vertex_stabilizer2:\n  assumes s: \"s\\<in>S\"\n  defines v: \"v \\<equiv> fundantivertex s\"\n  shows   \"w \\<in> \\<langle>S-{s}\\<rangle> \\<Longrightarrow> w\\<rightarrow>v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}) -\n                     {s}\\<rangle> \\<Longrightarrow>\n    w \\<rightarrow> v = v", "proof (erule genby.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<rightarrow> v = v\n 2. \\<And>sa.\n       sa \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) -\n                {s} \\<Longrightarrow>\n       sa \\<rightarrow> v = v\n 3. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}) -\n                                 {s}\\<rangle>;\n        w \\<rightarrow> v = v;\n        w' \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) -\n                          {s}\\<rangle>;\n        w' \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> (w - w') \\<rightarrow> v = v", "show \"0\\<rightarrow>v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<rightarrow> v = v", "by (simp add: zero_permutation.rep_eq)"], ["proof (state)\nthis:\n  0 \\<rightarrow> v = v\n\ngoal (2 subgoals):\n 1. \\<And>sa.\n       sa \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) -\n                {s} \\<Longrightarrow>\n       sa \\<rightarrow> v = v\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}) -\n                                 {s}\\<rangle>;\n        w \\<rightarrow> v = v;\n        w' \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) -\n                          {s}\\<rangle>;\n        w' \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> (w - w') \\<rightarrow> v = v", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>sa.\n       sa \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) -\n                {s} \\<Longrightarrow>\n       sa \\<rightarrow> v = v\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}) -\n                                 {s}\\<rangle>;\n        w \\<rightarrow> v = v;\n        w' \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) -\n                          {s}\\<rangle>;\n        w' \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> (w - w') \\<rightarrow> v = v", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>sa.\n       sa \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) -\n                {s} \\<Longrightarrow>\n       sa \\<rightarrow> v = v\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}) -\n                                 {s}\\<rangle>;\n        w \\<rightarrow> v = v;\n        w' \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) -\n                          {s}\\<rangle>;\n        w' \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> (w - w') \\<rightarrow> v = v", "assume \"t\\<in>S-{s}\""], ["proof (state)\nthis:\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n          {s}\n\ngoal (2 subgoals):\n 1. \\<And>sa.\n       sa \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) -\n                {s} \\<Longrightarrow>\n       sa \\<rightarrow> v = v\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}) -\n                                 {s}\\<rangle>;\n        w \\<rightarrow> v = v;\n        w' \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) -\n                          {s}\\<rangle>;\n        w' \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> (w - w') \\<rightarrow> v = v", "moreover"], ["proof (state)\nthis:\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n          {s}\n\ngoal (2 subgoals):\n 1. \\<And>sa.\n       sa \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) -\n                {s} \\<Longrightarrow>\n       sa \\<rightarrow> v = v\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}) -\n                                 {s}\\<rangle>;\n        w \\<rightarrow> v = v;\n        w' \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) -\n                          {s}\\<rangle>;\n        w' \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> (w - w') \\<rightarrow> v = v", "with s v"], ["proof (chain)\npicking this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  v \\<equiv> fundantivertex s\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n          {s}", "have \"v\\<in>C0\\<inter>t`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  v \\<equiv> fundantivertex s\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n          {s}\n\ngoal (1 subgoal):\n 1. v \\<in> C0 \\<inter> t `\\<rightarrow> C0", "using     inj_on_eq_iff[OF fundantivertex_inj_on] fundchamber_S_adjacent\n              fundchamber_S_image_neq_fundchamber[THEN not_sym]\n              not_the1[OF adj_antivertex, of C0 \"t`\\<rightarrow>C0\" v] fundantivertex"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  v \\<equiv> fundantivertex s\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n          {s}\n  \\<lbrakk>?x \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g});\n   ?y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g})\\<rbrakk>\n  \\<Longrightarrow> (fundantivertex ?x = fundantivertex ?y) = (?x = ?y)\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<sim> ?s `\\<rightarrow> C0\n  ?s1\n  \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n            {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<noteq> ?s1 `\\<rightarrow> C0\n  \\<lbrakk>C0 \\<sim> t `\\<rightarrow> C0; C0 \\<noteq> t `\\<rightarrow> C0;\n   v \\<noteq> (THE x. x \\<in> C0 - t `\\<rightarrow> C0)\\<rbrakk>\n  \\<Longrightarrow> v \\<notin> C0 - t `\\<rightarrow> C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  fundantivertex ?s \\<in> C0 - ?s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. v \\<in> C0 \\<inter> t `\\<rightarrow> C0", "unfolding fundantivertex_def"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  v \\<equiv> THE v. v \\<in> C0 - s `\\<rightarrow> C0\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n          {s}\n  \\<lbrakk>?x \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g});\n   ?y \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g})\\<rbrakk>\n  \\<Longrightarrow> ((THE v. v \\<in> C0 - ?x `\\<rightarrow> C0) =\n                     (THE v. v \\<in> C0 - ?y `\\<rightarrow> C0)) =\n                    (?x = ?y)\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<sim> ?s `\\<rightarrow> C0\n  ?s1\n  \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n            {Abs_induced_automorph f g}) \\<Longrightarrow>\n  C0 \\<noteq> ?s1 `\\<rightarrow> C0\n  \\<lbrakk>C0 \\<sim> t `\\<rightarrow> C0; C0 \\<noteq> t `\\<rightarrow> C0;\n   v \\<noteq> (THE x. x \\<in> C0 - t `\\<rightarrow> C0)\\<rbrakk>\n  \\<Longrightarrow> v \\<notin> C0 - t `\\<rightarrow> C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  (THE v. v \\<in> C0 - ?s `\\<rightarrow> C0) \\<in> C0 - ?s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. v \\<in> C0 \\<inter> t `\\<rightarrow> C0", "by        auto"], ["proof (state)\nthis:\n  v \\<in> C0 \\<inter> t `\\<rightarrow> C0\n\ngoal (2 subgoals):\n 1. \\<And>sa.\n       sa \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) -\n                {s} \\<Longrightarrow>\n       sa \\<rightarrow> v = v\n 2. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}) -\n                                 {s}\\<rangle>;\n        w \\<rightarrow> v = v;\n        w' \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) -\n                          {s}\\<rangle>;\n        w' \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> (w - w') \\<rightarrow> v = v", "ultimately"], ["proof (chain)\npicking this:\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n          {s}\n  v \\<in> C0 \\<inter> t `\\<rightarrow> C0", "show \"t\\<rightarrow>v = v\""], ["proof (prove)\nusing this:\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n          {s}\n  v \\<in> C0 \\<inter> t `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. t \\<rightarrow> v = v", "using S_fixespointwise_fundchamber_image_int fixespointwiseD"], ["proof (prove)\nusing this:\n  t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n          {s}\n  v \\<in> C0 \\<inter> t `\\<rightarrow> C0\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  fixespointwise ((\\<rightarrow>) ?s) (C0 \\<inter> ?s `\\<rightarrow> C0)\n  \\<lbrakk>fixespointwise ?f ?A; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f ?a = id ?a\n\ngoal (1 subgoal):\n 1. t \\<rightarrow> v = v", "by fastforce"], ["proof (state)\nthis:\n  t \\<rightarrow> v = v\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}) -\n                                 {s}\\<rangle>;\n        w \\<rightarrow> v = v;\n        w' \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) -\n                          {s}\\<rangle>;\n        w' \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> (w - w') \\<rightarrow> v = v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}) -\n                                 {s}\\<rangle>;\n        w \\<rightarrow> v = v;\n        w' \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) -\n                          {s}\\<rangle>;\n        w' \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> (w - w') \\<rightarrow> v = v", "fix w w'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}) -\n                                 {s}\\<rangle>;\n        w \\<rightarrow> v = v;\n        w' \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) -\n                          {s}\\<rangle>;\n        w' \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> (w - w') \\<rightarrow> v = v", "assume ww': \"w\\<rightarrow>v = v\" \"w'\\<rightarrow>v = v\""], ["proof (state)\nthis:\n  w \\<rightarrow> v = v\n  w' \\<rightarrow> v = v\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}) -\n                                 {s}\\<rangle>;\n        w \\<rightarrow> v = v;\n        w' \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) -\n                          {s}\\<rangle>;\n        w' \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> (w - w') \\<rightarrow> v = v", "from ww'(2)"], ["proof (chain)\npicking this:\n  w' \\<rightarrow> v = v", "have \"(-w')\\<rightarrow>v = id v\""], ["proof (prove)\nusing this:\n  w' \\<rightarrow> v = v\n\ngoal (1 subgoal):\n 1. (- w') \\<rightarrow> v = id v", "using plus_permutation.rep_eq[of \"-w'\" w']"], ["proof (prove)\nusing this:\n  w' \\<rightarrow> v = v\n  (\\<rightarrow>) (- w' + w') =\n  (\\<rightarrow>) (- w') \\<circ> (\\<rightarrow>) w'\n\ngoal (1 subgoal):\n 1. (- w') \\<rightarrow> v = id v", "by    (auto simp add: zero_permutation.rep_eq[THEN sym])"], ["proof (state)\nthis:\n  (- w') \\<rightarrow> v = id v\n\ngoal (1 subgoal):\n 1. \\<And>w w'.\n       \\<lbrakk>w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}) -\n                                 {s}\\<rangle>;\n        w \\<rightarrow> v = v;\n        w' \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}) -\n                          {s}\\<rangle>;\n        w' \\<rightarrow> v = v\\<rbrakk>\n       \\<Longrightarrow> (w - w') \\<rightarrow> v = v", "with ww'(1)"], ["proof (chain)\npicking this:\n  w \\<rightarrow> v = v\n  (- w') \\<rightarrow> v = id v", "show \"(w-w')\\<rightarrow>v = v\""], ["proof (prove)\nusing this:\n  w \\<rightarrow> v = v\n  (- w') \\<rightarrow> v = id v\n\ngoal (1 subgoal):\n 1. (w - w') \\<rightarrow> v = v", "using plus_permutation.rep_eq[of w \"-w'\"]"], ["proof (prove)\nusing this:\n  w \\<rightarrow> v = v\n  (- w') \\<rightarrow> v = id v\n  (\\<rightarrow>) (w + - w') =\n  (\\<rightarrow>) w \\<circ> (\\<rightarrow>) (- w')\n\ngoal (1 subgoal):\n 1. (w - w') \\<rightarrow> v = v", "by simp"], ["proof (state)\nthis:\n  (w - w') \\<rightarrow> v = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma label_wrt_special_coset1:\n  assumes \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\" \"w0\\<in>W\" \"s\\<in>S\"\n  defines \"v \\<equiv> fundantivertex s\"\n  shows   \"{w\\<in>W. w \\<rightarrow> \\<phi> (w0\\<rightarrow>v) = w0\\<rightarrow>v} = w0 +o \\<langle>S-{s}\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}\\<rangle>.\n     w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) = w0 \\<rightarrow> v} =\n    w0 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s}\\<rangle>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}\\<rangle>.\n     w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) = w0 \\<rightarrow> v} =\n    w0 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s}\\<rangle>", "from assms(4,5)"], ["proof (chain)\npicking this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  v \\<equiv> fundantivertex s", "have v_C0: \"v\\<in>C0\""], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  v \\<equiv> fundantivertex s\n\ngoal (1 subgoal):\n 1. v \\<in> C0", "using fundantivertex[of s]"], ["proof (prove)\nusing this:\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  v \\<equiv> fundantivertex s\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n              {Abs_induced_automorph f g}) \\<Longrightarrow>\n  fundantivertex s \\<in> C0 - s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. v \\<in> C0", "by simp"], ["proof (state)\nthis:\n  v \\<in> C0\n\ngoal (1 subgoal):\n 1. {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}\\<rangle>.\n     w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) = w0 \\<rightarrow> v} =\n    w0 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s}\\<rangle>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}\\<rangle>.\n     w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) = w0 \\<rightarrow> v} =\n    w0 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s}\\<rangle>", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v} \\<Longrightarrow>\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle>\n 2. \\<And>x.\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle> \\<Longrightarrow>\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v}", "fix w"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v} \\<Longrightarrow>\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle>\n 2. \\<And>x.\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle> \\<Longrightarrow>\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v}", "assume \"w\\<in>{w\\<in>W. w\\<rightarrow>(\\<phi> (w0\\<rightarrow>v)) = w0\\<rightarrow>v}\""], ["proof (state)\nthis:\n  w \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n           w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) = w0 \\<rightarrow> v}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v} \\<Longrightarrow>\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle>\n 2. \\<And>x.\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle> \\<Longrightarrow>\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v}", "hence w: \"w\\<in>W\" \"w\\<rightarrow>(\\<phi> (w0\\<rightarrow>v)) = w0\\<rightarrow>v\""], ["proof (prove)\nusing this:\n  w \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n           w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) = w0 \\<rightarrow> v}\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}\\<rangle> &&&\n    w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) = w0 \\<rightarrow> v", "by auto"], ["proof (state)\nthis:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) = w0 \\<rightarrow> v\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v} \\<Longrightarrow>\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle>\n 2. \\<And>x.\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle> \\<Longrightarrow>\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v}", "from assms(2,3)"], ["proof (chain)\npicking this:\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>", "have \"(-w0 + w) \\<rightarrow> v = 0\\<rightarrow>v\""], ["proof (prove)\nusing this:\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n\ngoal (1 subgoal):\n 1. (- w0 + w) \\<rightarrow> v = 0 \\<rightarrow> v", "using w(2) v_C0 fundchamber chamberD_simplex\n            W_respects_labels[OF assms(1)] plus_permutation.rep_eq[of \"-w0\" w0]"], ["proof (prove)\nusing this:\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) = w0 \\<rightarrow> v\n  v \\<in> C0\n  chamber C0\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                {Abs_induced_automorph f g}\\<rangle>;\n   ?v \\<in> \\<Union> X\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (?w \\<rightarrow> ?v) = \\<phi> ?v\n  (\\<rightarrow>) (- w0 + w0) =\n  (\\<rightarrow>) (- w0) \\<circ> (\\<rightarrow>) w0\n\ngoal (1 subgoal):\n 1. (- w0 + w) \\<rightarrow> v = 0 \\<rightarrow> v", "by    (fastforce simp add: plus_permutation.rep_eq fixespointwiseD)"], ["proof (state)\nthis:\n  (- w0 + w) \\<rightarrow> v = 0 \\<rightarrow> v\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v} \\<Longrightarrow>\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle>\n 2. \\<And>x.\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle> \\<Longrightarrow>\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v}", "with assms(3-5)"], ["proof (chain)\npicking this:\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  v \\<equiv> fundantivertex s\n  (- w0 + w) \\<rightarrow> v = 0 \\<rightarrow> v", "show \"w \\<in> w0 +o \\<langle>S-{s}\\<rangle>\""], ["proof (prove)\nusing this:\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  v \\<equiv> fundantivertex s\n  (- w0 + w) \\<rightarrow> v = 0 \\<rightarrow> v\n\ngoal (1 subgoal):\n 1. w \\<in> w0 +o\n            \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}) -\n                     {s}\\<rangle>", "using w(1) genby_uminus_add_closed[of w0 S w]\n            fundchamber_vertex_stabilizer1"], ["proof (prove)\nusing this:\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  v \\<equiv> fundantivertex s\n  (- w0 + w) \\<rightarrow> v = 0 \\<rightarrow> v\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  \\<lbrakk>w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                {Abs_induced_automorph f g}\\<rangle>;\n   w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> - w0 + w\n                    \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n{Abs_induced_automorph f g}\\<rangle>\n  \\<lbrakk>?t \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g});\n   ?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}\\<rangle>;\n   ?w \\<rightarrow> fundantivertex ?t = fundantivertex ?t\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n    {Abs_induced_automorph f g}) -\n{?t}\\<rangle>\n\ngoal (1 subgoal):\n 1. w \\<in> w0 +o\n            \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}) -\n                     {s}\\<rangle>", "by    (force simp add: zero_permutation.rep_eq elt_set_plus_def)"], ["proof (state)\nthis:\n  w \\<in> w0 +o\n          \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle> \\<Longrightarrow>\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle> \\<Longrightarrow>\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v}", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle> \\<Longrightarrow>\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v}", "assume w: \"w \\<in> w0 +o \\<langle>S-{s}\\<rangle>\""], ["proof (state)\nthis:\n  w \\<in> w0 +o\n          \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle> \\<Longrightarrow>\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v}", "from this"], ["proof (chain)\npicking this:\n  w \\<in> w0 +o\n          \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {s}\\<rangle>", "obtain w1 where w1: \"w1 \\<in> \\<langle>S-{s}\\<rangle>\" \"w = w0 + w1\""], ["proof (prove)\nusing this:\n  w \\<in> w0 +o\n          \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>w1.\n        \\<lbrakk>w1 \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n {Abs_induced_automorph f g}) -\n                                   {s}\\<rangle>;\n         w = w0 + w1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using elt_set_plus_def"], ["proof (prove)\nusing this:\n  w \\<in> w0 +o\n          \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {s}\\<rangle>\n  ?a +o ?B = {c. \\<exists>b\\<in>?B. c = ?a + b}\n\ngoal (1 subgoal):\n 1. (\\<And>w1.\n        \\<lbrakk>w1 \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n {Abs_induced_automorph f g}) -\n                                   {s}\\<rangle>;\n         w = w0 + w1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w1 \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}) -\n                    {s}\\<rangle>\n  w = w0 + w1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle> \\<Longrightarrow>\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v}", "moreover"], ["proof (state)\nthis:\n  w1 \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}) -\n                    {s}\\<rangle>\n  w = w0 + w1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle> \\<Longrightarrow>\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v}", "with w assms(3)"], ["proof (chain)\npicking this:\n  w \\<in> w0 +o\n          \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {s}\\<rangle>\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  w1 \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}) -\n                    {s}\\<rangle>\n  w = w0 + w1", "have w_W: \"w\\<in>W\""], ["proof (prove)\nusing this:\n  w \\<in> w0 +o\n          \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {s}\\<rangle>\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  w1 \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}) -\n                    {s}\\<rangle>\n  w = w0 + w1\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}\\<rangle>", "using genby_mono[of \"S-{s}\" S] genby_add_closed"], ["proof (prove)\nusing this:\n  w \\<in> w0 +o\n          \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {s}\\<rangle>\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  w1 \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}) -\n                    {s}\\<rangle>\n  w = w0 + w1\n  order.greater_eq\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   ((\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n    {s}) \\<Longrightarrow>\n  order.greater_eq\n   \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}\\<rangle>\n   \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) -\n            {s}\\<rangle>\n  \\<lbrakk>?g \\<in> \\<langle>?S\\<rangle>;\n   ?h \\<in> \\<langle>?S\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> ?g + ?h \\<in> \\<langle>?S\\<rangle>\n\ngoal (1 subgoal):\n 1. w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}\\<rangle>", "by fastforce"], ["proof (state)\nthis:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> w0 +o\n               \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                            {Abs_induced_automorph f g}) -\n                        {s}\\<rangle> \\<Longrightarrow>\n       x \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}\\<rangle>.\n                w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n                w0 \\<rightarrow> v}", "ultimately"], ["proof (chain)\npicking this:\n  w1 \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}) -\n                    {s}\\<rangle>\n  w = w0 + w1\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>", "show \"w\\<in>{w\\<in>W. w\\<rightarrow>(\\<phi> (w0\\<rightarrow>v)) = w0\\<rightarrow>v}\""], ["proof (prove)\nusing this:\n  w1 \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}) -\n                    {s}\\<rangle>\n  w = w0 + w1\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n\ngoal (1 subgoal):\n 1. w \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}\\<rangle>.\n             w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n             w0 \\<rightarrow> v}", "using assms(2-5) v_C0 fundchamber chamberD_simplex\n            W_respects_labels[OF assms(1), of w0 v]\n            fundchamber_vertex_stabilizer2[of s w1]"], ["proof (prove)\nusing this:\n  w1 \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}) -\n                    {s}\\<rangle>\n  w = w0 + w1\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  v \\<equiv> fundantivertex s\n  v \\<in> C0\n  chamber C0\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                {Abs_induced_automorph f g}\\<rangle>;\n   v \\<in> \\<Union> X\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (w0 \\<rightarrow> v) = \\<phi> v\n  \\<lbrakk>s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g});\n   w1 \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}) -\n                     {s}\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> w1 \\<rightarrow> fundantivertex s = fundantivertex s\n\ngoal (1 subgoal):\n 1. w \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}\\<rangle>.\n             w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) =\n             w0 \\<rightarrow> v}", "by    (fastforce simp add: fixespointwiseD plus_permutation.rep_eq)"], ["proof (state)\nthis:\n  w \\<in> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>.\n           w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) = w0 \\<rightarrow> v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>.\n   w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) = w0 \\<rightarrow> v} =\n  w0 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s}\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma label_wrt_special_coset1':\n  assumes \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\" \"w0\\<in>W\" \"v\\<in>C0\"\n  defines \"s \\<equiv> fundantipermutation v\"\n  shows   \"{w\\<in>W. w \\<rightarrow> \\<phi> (w0\\<rightarrow>v) = w0\\<rightarrow>v} = w0 +o \\<langle>S-{s}\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}\\<rangle>.\n     w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) = w0 \\<rightarrow> v} =\n    w0 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s}\\<rangle>", "using   assms fundantipermutation1 fundantivertex_bij_betw\n          bij_betw_f_the_inv_into_f label_wrt_special_coset1[of \\<phi> w0 s]"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  v \\<in> C0\n  s \\<equiv>\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex v\n  ?v \\<in> C0 \\<Longrightarrow>\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex ?v\n  \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  bij_betw fundantivertex\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) C0\n  \\<lbrakk>bij_betw ?f ?A ?B; ?y \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> ?f (the_inv_into ?A ?f ?y) = ?y\n  \\<lbrakk>label_wrt C0 \\<phi>; fixespointwise \\<phi> C0;\n   w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}\\<rangle>;\n   s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g})\\<rbrakk>\n  \\<Longrightarrow> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}\\<rangle>.\n                     w \\<rightarrow>\n                     \\<phi> (w0 \\<rightarrow> fundantivertex s) =\n                     w0 \\<rightarrow> fundantivertex s} =\n                    w0 +o\n                    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}) -\n                             {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}\\<rangle>.\n     w \\<rightarrow> \\<phi> (w0 \\<rightarrow> v) = w0 \\<rightarrow> v} =\n    w0 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s}\\<rangle>", "by      fastforce"], ["", "lemma label_wrt_special_coset2':\n  assumes \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\" \"w0\\<in>W\" \"v \\<in> w0`\\<rightarrow>C0\"\n  defines \"s \\<equiv> fundantipermutation (\\<phi> v)\"\n  shows   \"{w\\<in>W. w \\<rightarrow> \\<phi> v = v} = w0 +o \\<langle>S-{s}\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}\\<rangle>.\n     w \\<rightarrow> \\<phi> v = v} =\n    w0 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s}\\<rangle>", "using   assms fundchamber chamberD_simplex W_respects_labels\n          label_wrt_special_coset1'[OF assms(1-3)]"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  v \\<in> w0 `\\<rightarrow> C0\n  s \\<equiv>\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v)\n  chamber C0\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n  \\<lbrakk>label_wrt ?B ?\\<phi>;\n   ?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}\\<rangle>;\n   ?v \\<in> \\<Union> X\\<rbrakk>\n  \\<Longrightarrow> ?\\<phi> (?w \\<rightarrow> ?v) = ?\\<phi> ?v\n  ?v \\<in> C0 \\<Longrightarrow>\n  {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>.\n   w \\<rightarrow> \\<phi> (w0 \\<rightarrow> ?v) = w0 \\<rightarrow> ?v} =\n  w0 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {the_inv_into\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n             fundantivertex ?v}\\<rangle>\n\ngoal (1 subgoal):\n 1. {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}\\<rangle>.\n     w \\<rightarrow> \\<phi> v = v} =\n    w0 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s}\\<rangle>", "by      (fastforce simp add: fixespointwiseD)"], ["", "(* slow *)"], ["", "lemma label_stab_map_W_fundchamber_image:\n  assumes \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\" \"w0\\<in>W\"\n  defines \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows   \"\\<psi>`(w0`\\<rightarrow>C0) = CoxeterComplex.smap S {w0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` w0 `\\<rightarrow> C0 \\<Longrightarrow>\n       x \\<in> dual_order.poset_simplex_map\n                (PreCoxeterSystem.special_cosets\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n                {w0}\n 2. \\<And>x.\n       x \\<in> dual_order.poset_simplex_map\n                (PreCoxeterSystem.special_cosets\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n                {w0} \\<Longrightarrow>\n       x \\<in> \\<psi> ` w0 `\\<rightarrow> C0", "from assms"], ["proof (chain)\npicking this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}", "show  \"\\<And>x. x \\<in> CoxeterComplex.smap S {w0} \\<Longrightarrow> x \\<in> \\<psi>`(w0`\\<rightarrow>C0)\""], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dual_order.poset_simplex_map\n                (PreCoxeterSystem.special_cosets\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n                {w0} \\<Longrightarrow>\n       x \\<in> \\<psi> ` w0 `\\<rightarrow> C0", "using CoxeterComplex.chamber_vertex_conv_special_coset[\n            OF CoxeterComplex, of w0\n          ]\n          label_wrt_special_coset1 fundantivertex"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  \\<lbrakk>w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                {Abs_induced_automorph f g}\\<rangle>;\n   ?X \\<in> dual_order.poset_simplex_map\n             (PreCoxeterSystem.special_cosets\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g}))\n             {w0}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s\\<in>\\<Union>(f, g)\\<in>fundfoldpairs.\n{Abs_induced_automorph f g}.\n                       ?X =\n                       w0 +o\n                       \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                    {Abs_induced_automorph f g}) -\n                                {s}\\<rangle>\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0;\n   ?w0.0\n   \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}\\<rangle>;\n   ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g})\\<rbrakk>\n  \\<Longrightarrow> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}\\<rangle>.\n                     w \\<rightarrow>\n                     ?\\<phi> (?w0.0 \\<rightarrow> fundantivertex ?s) =\n                     ?w0.0 \\<rightarrow> fundantivertex ?s} =\n                    ?w0.0 +o\n                    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}) -\n                             {?s}\\<rangle>\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  fundantivertex ?s \\<in> C0 - ?s `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> dual_order.poset_simplex_map\n                (PreCoxeterSystem.special_cosets\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n                {w0} \\<Longrightarrow>\n       x \\<in> \\<psi> ` w0 `\\<rightarrow> C0", "by    fastforce"], ["proof (state)\nthis:\n  ?x1\n  \\<in> dual_order.poset_simplex_map\n         (PreCoxeterSystem.special_cosets\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n         {w0} \\<Longrightarrow>\n  ?x1 \\<in> \\<psi> ` w0 `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` w0 `\\<rightarrow> C0 \\<Longrightarrow>\n       x \\<in> dual_order.poset_simplex_map\n                (PreCoxeterSystem.special_cosets\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n                {w0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` w0 `\\<rightarrow> C0 \\<Longrightarrow>\n       x \\<in> dual_order.poset_simplex_map\n                (PreCoxeterSystem.special_cosets\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n                {w0}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` w0 `\\<rightarrow> C0 \\<Longrightarrow>\n       x \\<in> dual_order.poset_simplex_map\n                (PreCoxeterSystem.special_cosets\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n                {w0}", "assume \"x\\<in> \\<psi>`(w0`\\<rightarrow>C0)\""], ["proof (state)\nthis:\n  x \\<in> \\<psi> ` w0 `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` w0 `\\<rightarrow> C0 \\<Longrightarrow>\n       x \\<in> dual_order.poset_simplex_map\n                (PreCoxeterSystem.special_cosets\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n                {w0}", "from this"], ["proof (chain)\npicking this:\n  x \\<in> \\<psi> ` w0 `\\<rightarrow> C0", "obtain v where v: \"v\\<in>w0`\\<rightarrow>C0\" \"x = \\<psi> v\""], ["proof (prove)\nusing this:\n  x \\<in> \\<psi> ` w0 `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> w0 `\\<rightarrow> C0; x = \\<psi> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  v \\<in> w0 `\\<rightarrow> C0\n  x = \\<psi> v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` w0 `\\<rightarrow> C0 \\<Longrightarrow>\n       x \\<in> dual_order.poset_simplex_map\n                (PreCoxeterSystem.special_cosets\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n                {w0}", "with assms"], ["proof (chain)\npicking this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  v \\<in> w0 `\\<rightarrow> C0\n  x = \\<psi> v", "have \"x = w0 +o \\<langle>S-{fundantipermutation (\\<phi> v)}\\<rangle>\""], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  v \\<in> w0 `\\<rightarrow> C0\n  x = \\<psi> v\n\ngoal (1 subgoal):\n 1. x =\n    w0 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {the_inv_into\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\n               fundantivertex (\\<phi> v)}\\<rangle>", "using label_wrt_special_coset2'"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  v \\<in> w0 `\\<rightarrow> C0\n  x = \\<psi> v\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0;\n   ?w0.0\n   \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}\\<rangle>;\n   ?v \\<in> ?w0.0 `\\<rightarrow> C0\\<rbrakk>\n  \\<Longrightarrow> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}\\<rangle>.\n                     w \\<rightarrow> ?\\<phi> ?v = ?v} =\n                    ?w0.0 +o\n                    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}) -\n                             {the_inv_into\n                               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                                   {Abs_induced_automorph f g})\n                               fundantivertex (?\\<phi> ?v)}\\<rangle>\n\ngoal (1 subgoal):\n 1. x =\n    w0 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {the_inv_into\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\n               fundantivertex (\\<phi> v)}\\<rangle>", "by fast"], ["proof (state)\nthis:\n  x =\n  w0 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {the_inv_into\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n             fundantivertex (\\<phi> v)}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` w0 `\\<rightarrow> C0 \\<Longrightarrow>\n       x \\<in> dual_order.poset_simplex_map\n                (PreCoxeterSystem.special_cosets\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n                {w0}", "moreover"], ["proof (state)\nthis:\n  x =\n  w0 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {the_inv_into\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n             fundantivertex (\\<phi> v)}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` w0 `\\<rightarrow> C0 \\<Longrightarrow>\n       x \\<in> dual_order.poset_simplex_map\n                (PreCoxeterSystem.special_cosets\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n                {w0}", "from v(1) assms(3)"], ["proof (chain)\npicking this:\n  v \\<in> w0 `\\<rightarrow> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>", "have \"v\\<in>\\<Union>X\""], ["proof (prove)\nusing this:\n  v \\<in> w0 `\\<rightarrow> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n\ngoal (1 subgoal):\n 1. v \\<in> \\<Union> X", "using fundchamber chamberD_simplex W_endomorphism\n          ChamberComplexEndomorphism.vertex_map"], ["proof (prove)\nusing this:\n  v \\<in> w0 `\\<rightarrow> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  chamber C0\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n  ?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f\n                         g}\\<rangle> \\<Longrightarrow>\n  ChamberComplexEndomorphism X ((\\<rightarrow>) ?w)\n  \\<lbrakk>ChamberComplexEndomorphism ?X ?f; ?x \\<in> \\<Union> ?X\\<rbrakk>\n  \\<Longrightarrow> ?f ?x \\<in> \\<Union> ?X\n\ngoal (1 subgoal):\n 1. v \\<in> \\<Union> X", "by    fastforce"], ["proof (state)\nthis:\n  v \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` w0 `\\<rightarrow> C0 \\<Longrightarrow>\n       x \\<in> dual_order.poset_simplex_map\n                (PreCoxeterSystem.special_cosets\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n                {w0}", "ultimately"], ["proof (chain)\npicking this:\n  x =\n  w0 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {the_inv_into\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n             fundantivertex (\\<phi> v)}\\<rangle>\n  v \\<in> \\<Union> X", "show \"x \\<in> CoxeterComplex.smap S {w0}\""], ["proof (prove)\nusing this:\n  x =\n  w0 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {the_inv_into\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n             fundantivertex (\\<phi> v)}\\<rangle>\n  v \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. x \\<in> dual_order.poset_simplex_map\n             (PreCoxeterSystem.special_cosets\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g}))\n             {w0}", "using assms(1,3) label_wrt_elt_image fundantipermutation1\n          CoxeterComplex.chamber_vertices[OF CoxeterComplex]"], ["proof (prove)\nusing this:\n  x =\n  w0 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {the_inv_into\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n             fundantivertex (\\<phi> v)}\\<rangle>\n  v \\<in> \\<Union> X\n  label_wrt C0 \\<phi>\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<lbrakk>label_wrt ?B ?f; ?v \\<in> \\<Union> X\\<rbrakk>\n  \\<Longrightarrow> ?f ?v \\<in> ?B\n  ?v \\<in> C0 \\<Longrightarrow>\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex ?v\n  \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<lbrakk>?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                {Abs_induced_automorph f g}\\<rangle>;\n   ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g})\\<rbrakk>\n  \\<Longrightarrow> ?w +o\n                    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}) -\n                             {?s}\\<rangle>\n                    \\<in> dual_order.poset_simplex_map\n                           (PreCoxeterSystem.special_cosets\n                             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}))\n                           {?w}\n\ngoal (1 subgoal):\n 1. x \\<in> dual_order.poset_simplex_map\n             (PreCoxeterSystem.special_cosets\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g}))\n             {w0}", "by    fastforce"], ["proof (state)\nthis:\n  x \\<in> dual_order.poset_simplex_map\n           (PreCoxeterSystem.special_cosets\n             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}))\n           {w0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma label_stab_map_chamber_map:\n  assumes \\<phi>: \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\"\n  and     C: \"chamber C\"\n  defines \\<psi>: \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows   \"CoxeterComplex.chamber S (\\<psi>`C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     (\\<psi> ` C)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     (\\<psi> ` C)", "from C"], ["proof (chain)\npicking this:\n  chamber C", "obtain w where w: \"w\\<in>W\" \"C = w`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  chamber C\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}\\<rangle>;\n         C = w `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using chamber_eq_W_image"], ["proof (prove)\nusing this:\n  chamber C\n  chamber ?C \\<Longrightarrow>\n  \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g}\\<rangle>.\n     ?C = w `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}\\<rangle>;\n         C = w `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  C = w `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     (\\<psi> ` C)", "with \\<phi> \\<psi>"], ["proof (chain)\npicking this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  C = w `\\<rightarrow> C0", "have \"\\<psi>`C = CoxeterComplex.smap S {w}\""], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  C = w `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<psi> ` C =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w}", "using label_stab_map_W_fundchamber_image"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  C = w `\\<rightarrow> C0\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0;\n   ?w0.0\n   \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>v.\n                        {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n       {Abs_induced_automorph f g}\\<rangle>.\n                         w \\<rightarrow> ?\\<phi> v = v}) `\n                    ?w0.0 `\\<rightarrow> C0 =\n                    dual_order.poset_simplex_map\n                     (PreCoxeterSystem.special_cosets\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}))\n                     {?w0.0}\n\ngoal (1 subgoal):\n 1. \\<psi> ` C =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w}", "by simp"], ["proof (state)\nthis:\n  \\<psi> ` C =\n  dual_order.poset_simplex_map\n   (PreCoxeterSystem.special_cosets\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   {w}\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     (\\<psi> ` C)", "with w(1)"], ["proof (chain)\npicking this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> ` C =\n  dual_order.poset_simplex_map\n   (PreCoxeterSystem.special_cosets\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   {w}", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> ` C =\n  dual_order.poset_simplex_map\n   (PreCoxeterSystem.special_cosets\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   {w}\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     (\\<psi> ` C)", "using CoxeterComplex.chamber_singleton[OF CoxeterComplex]"], ["proof (prove)\nusing this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> ` C =\n  dual_order.poset_simplex_map\n   (PreCoxeterSystem.special_cosets\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   {w}\n  ?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f\n                         g}\\<rangle> \\<Longrightarrow>\n  SimplicialComplex.maxsimp\n   (CoxeterComplex.TheComplex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   (dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {?w})\n\ngoal (1 subgoal):\n 1. SimplicialComplex.maxsimp\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     (\\<psi> ` C)", "by simp"], ["proof (state)\nthis:\n  SimplicialComplex.maxsimp\n   (CoxeterComplex.TheComplex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   (\\<psi> ` C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma label_stab_map_inj_on_vertices:\n  assumes \\<phi>: \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\"\n  defines \\<psi>: \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows \"inj_on \\<psi> (\\<Union>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<psi> (\\<Union> X)", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<Union> X; y \\<in> \\<Union> X;\n        \\<psi> x = \\<psi> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix v1 v2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<Union> X; y \\<in> \\<Union> X;\n        \\<psi> x = \\<psi> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume v: \"v1\\<in>\\<Union>X\" \"v2\\<in>\\<Union>X\" \"\\<psi> v1 = \\<psi> v2\""], ["proof (state)\nthis:\n  v1 \\<in> \\<Union> X\n  v2 \\<in> \\<Union> X\n  \\<psi> v1 = \\<psi> v2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<Union> X; y \\<in> \\<Union> X;\n        \\<psi> x = \\<psi> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from v(1,2)"], ["proof (chain)\npicking this:\n  v1 \\<in> \\<Union> X\n  v2 \\<in> \\<Union> X", "have \\<phi>v: \"\\<phi> v1 \\<in> C0\" \"\\<phi> v2 \\<in> C0\""], ["proof (prove)\nusing this:\n  v1 \\<in> \\<Union> X\n  v2 \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. \\<phi> v1 \\<in> C0 &&& \\<phi> v2 \\<in> C0", "using label_wrt_elt_image[OF \\<phi>(1)]"], ["proof (prove)\nusing this:\n  v1 \\<in> \\<Union> X\n  v2 \\<in> \\<Union> X\n  ?v \\<in> \\<Union> X \\<Longrightarrow> \\<phi> ?v \\<in> C0\n\ngoal (1 subgoal):\n 1. \\<phi> v1 \\<in> C0 &&& \\<phi> v2 \\<in> C0", "by auto"], ["proof (state)\nthis:\n  \\<phi> v1 \\<in> C0\n  \\<phi> v2 \\<in> C0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<Union> X; y \\<in> \\<Union> X;\n        \\<psi> x = \\<psi> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "define s1 s2 where \"s1 = fundantipermutation (\\<phi> v1)\" and \"s2 = fundantipermutation (\\<phi> v2)\""], ["proof (state)\nthis:\n  s1 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v1)\n  s2 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v2)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<Union> X; y \\<in> \\<Union> X;\n        \\<psi> x = \\<psi> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from v(1,2)"], ["proof (chain)\npicking this:\n  v1 \\<in> \\<Union> X\n  v2 \\<in> \\<Union> X", "obtain w1 w2 where \"w1\\<in>W\" \"v1\\<in>w1`\\<rightarrow>C0\" \"w2\\<in>W\" \"v2\\<in>w2`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  v1 \\<in> \\<Union> X\n  v2 \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. (\\<And>w1 w2.\n        \\<lbrakk>w1 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n{Abs_induced_automorph f g}\\<rangle>;\n         v1 \\<in> w1 `\\<rightarrow> C0;\n         w2 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}\\<rangle>;\n         v2 \\<in> w2 `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using simplex_in_max chamber_eq_W_image"], ["proof (prove)\nusing this:\n  v1 \\<in> \\<Union> X\n  v2 \\<in> \\<Union> X\n  ?y \\<in> X \\<Longrightarrow>\n  \\<exists>x. chamber x \\<and> order.greater_eq x ?y\n  chamber ?C \\<Longrightarrow>\n  \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g}\\<rangle>.\n     ?C = w `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (\\<And>w1 w2.\n        \\<lbrakk>w1 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n{Abs_induced_automorph f g}\\<rangle>;\n         v1 \\<in> w1 `\\<rightarrow> C0;\n         w2 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                              {Abs_induced_automorph f g}\\<rangle>;\n         v2 \\<in> w2 `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w1 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  v1 \\<in> w1 `\\<rightarrow> C0\n  w2 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  v2 \\<in> w2 `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<Union> X; y \\<in> \\<Union> X;\n        \\<psi> x = \\<psi> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with assms s1_def s2_def"], ["proof (chain)\npicking this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  s1 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v1)\n  s2 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v2)\n  w1 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  v1 \\<in> w1 `\\<rightarrow> C0\n  w2 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  v2 \\<in> w2 `\\<rightarrow> C0", "have \\<psi>v: \"\\<psi> v1 = w1 +o \\<langle>S-{s1}\\<rangle>\" \"\\<psi> v2 = w2 +o \\<langle>S-{s2}\\<rangle>\""], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  s1 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v1)\n  s2 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v2)\n  w1 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  v1 \\<in> w1 `\\<rightarrow> C0\n  w2 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  v2 \\<in> w2 `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. \\<psi> v1 =\n    w1 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s1}\\<rangle> &&&\n    \\<psi> v2 =\n    w2 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s2}\\<rangle>", "using label_wrt_special_coset2'"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  s1 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v1)\n  s2 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v2)\n  w1 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  v1 \\<in> w1 `\\<rightarrow> C0\n  w2 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  v2 \\<in> w2 `\\<rightarrow> C0\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0;\n   ?w0.0\n   \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}\\<rangle>;\n   ?v \\<in> ?w0.0 `\\<rightarrow> C0\\<rbrakk>\n  \\<Longrightarrow> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}\\<rangle>.\n                     w \\<rightarrow> ?\\<phi> ?v = ?v} =\n                    ?w0.0 +o\n                    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}) -\n                             {the_inv_into\n                               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                                   {Abs_induced_automorph f g})\n                               fundantivertex (?\\<phi> ?v)}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<psi> v1 =\n    w1 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s1}\\<rangle> &&&\n    \\<psi> v2 =\n    w2 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s2}\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<psi> v1 =\n  w1 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s1}\\<rangle>\n  \\<psi> v2 =\n  w2 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s2}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<Union> X; y \\<in> \\<Union> X;\n        \\<psi> x = \\<psi> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with v(3)"], ["proof (chain)\npicking this:\n  \\<psi> v1 = \\<psi> v2\n  \\<psi> v1 =\n  w1 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s1}\\<rangle>\n  \\<psi> v2 =\n  w2 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s2}\\<rangle>", "have \"w1 +o \\<langle>S-{s1}\\<rangle> = w2 +o \\<langle>S-{s2}\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<psi> v1 = \\<psi> v2\n  \\<psi> v1 =\n  w1 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s1}\\<rangle>\n  \\<psi> v2 =\n  w2 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s2}\\<rangle>\n\ngoal (1 subgoal):\n 1. w1 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s1}\\<rangle> =\n    w2 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s2}\\<rangle>", "using label_wrt_special_coset2'"], ["proof (prove)\nusing this:\n  \\<psi> v1 = \\<psi> v2\n  \\<psi> v1 =\n  w1 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s1}\\<rangle>\n  \\<psi> v2 =\n  w2 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s2}\\<rangle>\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0;\n   ?w0.0\n   \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}\\<rangle>;\n   ?v \\<in> ?w0.0 `\\<rightarrow> C0\\<rbrakk>\n  \\<Longrightarrow> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}\\<rangle>.\n                     w \\<rightarrow> ?\\<phi> ?v = ?v} =\n                    ?w0.0 +o\n                    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}) -\n                             {the_inv_into\n                               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                                   {Abs_induced_automorph f g})\n                               fundantivertex (?\\<phi> ?v)}\\<rangle>\n\ngoal (1 subgoal):\n 1. w1 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s1}\\<rangle> =\n    w2 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {s2}\\<rangle>", "by auto"], ["proof (state)\nthis:\n  w1 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s1}\\<rangle> =\n  w2 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s2}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<Union> X; y \\<in> \\<Union> X;\n        \\<psi> x = \\<psi> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with s1_def s2_def"], ["proof (chain)\npicking this:\n  s1 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v1)\n  s2 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v2)\n  w1 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s1}\\<rangle> =\n  w2 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s2}\\<rangle>", "have \"\\<phi> v1 = \\<phi> v2\""], ["proof (prove)\nusing this:\n  s1 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v1)\n  s2 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v2)\n  w1 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s1}\\<rangle> =\n  w2 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s2}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<phi> v1 = \\<phi> v2", "using PreCoxeterSystemWithDeletion.special_coset_eq_imp_eq_gensets[\n            OF PreCoxeterSystemWithDeletion, of \"S-{s1}\" \"S-{s2}\" w1 w2\n          ]\n          \\<phi>v fundantipermutation1[of \"\\<phi> v1\"] fundantipermutation1[of \"\\<phi> v2\"]\n          bij_betw_f_the_inv_into_f[OF fundantivertex_bij_betw, of \"\\<phi> v1\"]\n          bij_betw_f_the_inv_into_f[OF fundantivertex_bij_betw, of \"\\<phi> v2\"]"], ["proof (prove)\nusing this:\n  s1 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v1)\n  s2 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v2)\n  w1 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s1}\\<rangle> =\n  w2 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s2}\\<rangle>\n  \\<lbrakk>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s1}\n           \\<in> Pow (\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g});\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) - {s2}\n   \\<in> Pow (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g});\n   w1 +o\n   \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) -\n            {s1}\\<rangle> =\n   w2 +o\n   \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) -\n            {s2}\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}) -\n                    {s1} =\n                    (\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}) -\n                    {s2}\n  \\<phi> v1 \\<in> C0\n  \\<phi> v2 \\<in> C0\n  \\<phi> v1 \\<in> C0 \\<Longrightarrow>\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v1)\n  \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<phi> v2 \\<in> C0 \\<Longrightarrow>\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex (\\<phi> v2)\n  \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<phi> v1 \\<in> C0 \\<Longrightarrow>\n  fundantivertex\n   (the_inv_into\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     fundantivertex (\\<phi> v1)) =\n  \\<phi> v1\n  \\<phi> v2 \\<in> C0 \\<Longrightarrow>\n  fundantivertex\n   (the_inv_into\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     fundantivertex (\\<phi> v2)) =\n  \\<phi> v2\n\ngoal (1 subgoal):\n 1. \\<phi> v1 = \\<phi> v2", "by    fastforce"], ["proof (state)\nthis:\n  \\<phi> v1 = \\<phi> v2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<Union> X; y \\<in> \\<Union> X;\n        \\<psi> x = \\<psi> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with v(3) \\<psi>"], ["proof (chain)\npicking this:\n  \\<psi> v1 = \\<psi> v2\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  \\<phi> v1 = \\<phi> v2", "show \"v1=v2\""], ["proof (prove)\nusing this:\n  \\<psi> v1 = \\<psi> v2\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  \\<phi> v1 = \\<phi> v2\n\ngoal (1 subgoal):\n 1. v1 = v2", "using \\<psi>v(1) genby_0_closed[of \"S-{s1}\"] lcoset_refl[of \"\\<langle>S-{s1}\\<rangle>\" w1]"], ["proof (prove)\nusing this:\n  \\<psi> v1 = \\<psi> v2\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  \\<phi> v1 = \\<phi> v2\n  \\<psi> v1 =\n  w1 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s1}\\<rangle>\n  0 \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {s1}\\<rangle>\n  0 \\<in> \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}) -\n                   {s1}\\<rangle> \\<Longrightarrow>\n  w1 \\<in> w1 +o\n           \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}) -\n                    {s1}\\<rangle>\n\ngoal (1 subgoal):\n 1. v1 = v2", "by    fastforce"], ["proof (state)\nthis:\n  v1 = v2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma label_stab_map_surj_on_vertices:\n  assumes \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\"\n  defines \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows   \"\\<psi>`(\\<Union>X) = \\<Union>\\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> ` \\<Union> X =\n    \\<Union>\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` \\<Union> X \\<Longrightarrow>\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n 2. \\<And>x.\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g})) \\<Longrightarrow>\n       x \\<in> \\<psi> ` \\<Union> X", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` \\<Union> X \\<Longrightarrow>\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n 2. \\<And>x.\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g})) \\<Longrightarrow>\n       x \\<in> \\<psi> ` \\<Union> X", "assume \"u \\<in> \\<psi>`(\\<Union>X)\""], ["proof (state)\nthis:\n  u \\<in> \\<psi> ` \\<Union> X\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` \\<Union> X \\<Longrightarrow>\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n 2. \\<And>x.\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g})) \\<Longrightarrow>\n       x \\<in> \\<psi> ` \\<Union> X", "from this"], ["proof (chain)\npicking this:\n  u \\<in> \\<psi> ` \\<Union> X", "obtain v where v: \"v\\<in>\\<Union>X\" \"u = \\<psi> v\""], ["proof (prove)\nusing this:\n  u \\<in> \\<psi> ` \\<Union> X\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> \\<Union> X; u = \\<psi> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  v \\<in> \\<Union> X\n  u = \\<psi> v\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` \\<Union> X \\<Longrightarrow>\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n 2. \\<And>x.\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g})) \\<Longrightarrow>\n       x \\<in> \\<psi> ` \\<Union> X", "from v(1)"], ["proof (chain)\npicking this:\n  v \\<in> \\<Union> X", "obtain w where \"w\\<in>W\" \"v\\<in>w`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> X\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}\\<rangle>;\n         v \\<in> w `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using simplex_in_max chamber_eq_W_image"], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> X\n  ?y \\<in> X \\<Longrightarrow>\n  \\<exists>x. chamber x \\<and> order.greater_eq x ?y\n  chamber ?C \\<Longrightarrow>\n  \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g}\\<rangle>.\n     ?C = w `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}\\<rangle>;\n         v \\<in> w `\\<rightarrow> C0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  v \\<in> w `\\<rightarrow> C0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` \\<Union> X \\<Longrightarrow>\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}))\n 2. \\<And>x.\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g})) \\<Longrightarrow>\n       x \\<in> \\<psi> ` \\<Union> X", "with assms v"], ["proof (chain)\npicking this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  v \\<in> \\<Union> X\n  u = \\<psi> v\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  v \\<in> w `\\<rightarrow> C0", "show \"u\\<in>\\<Union>\\<Sigma>\""], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  v \\<in> \\<Union> X\n  u = \\<psi> v\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  v \\<in> w `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. u \\<in> \\<Union>\n             (CoxeterComplex.TheComplex\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g}))", "using label_wrt_special_coset2' label_wrt_elt_image[OF assms(1)]\n          fundantipermutation1 CoxeterComplex.vertices[OF CoxeterComplex]"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  v \\<in> \\<Union> X\n  u = \\<psi> v\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  v \\<in> w `\\<rightarrow> C0\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0;\n   ?w0.0\n   \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}\\<rangle>;\n   ?v \\<in> ?w0.0 `\\<rightarrow> C0\\<rbrakk>\n  \\<Longrightarrow> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}\\<rangle>.\n                     w \\<rightarrow> ?\\<phi> ?v = ?v} =\n                    ?w0.0 +o\n                    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}) -\n                             {the_inv_into\n                               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                                   {Abs_induced_automorph f g})\n                               fundantivertex (?\\<phi> ?v)}\\<rangle>\n  ?v \\<in> \\<Union> X \\<Longrightarrow> \\<phi> ?v \\<in> C0\n  ?v \\<in> C0 \\<Longrightarrow>\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex ?v\n  \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<lbrakk>?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                {Abs_induced_automorph f g}\\<rangle>;\n   ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g})\\<rbrakk>\n  \\<Longrightarrow> ?w +o\n                    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}) -\n                             {?s}\\<rangle>\n                    \\<in> \\<Union>\n                           (CoxeterComplex.TheComplex\n                             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}))\n\ngoal (1 subgoal):\n 1. u \\<in> \\<Union>\n             (CoxeterComplex.TheComplex\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g}))", "by    auto"], ["proof (state)\nthis:\n  u \\<in> \\<Union>\n           (CoxeterComplex.TheComplex\n             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g})) \\<Longrightarrow>\n       x \\<in> \\<psi> ` \\<Union> X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g})) \\<Longrightarrow>\n       x \\<in> \\<psi> ` \\<Union> X", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g})) \\<Longrightarrow>\n       x \\<in> \\<psi> ` \\<Union> X", "assume \"u\\<in>\\<Union>\\<Sigma>\""], ["proof (state)\nthis:\n  u \\<in> \\<Union>\n           (CoxeterComplex.TheComplex\n             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g})) \\<Longrightarrow>\n       x \\<in> \\<psi> ` \\<Union> X", "from this"], ["proof (chain)\npicking this:\n  u \\<in> \\<Union>\n           (CoxeterComplex.TheComplex\n             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}))", "obtain w s where \"w\\<in>W\" \"s\\<in>S\" \"u = w +o \\<langle>S-{s}\\<rangle>\""], ["proof (prove)\nusing this:\n  u \\<in> \\<Union>\n           (CoxeterComplex.TheComplex\n             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}))\n\ngoal (1 subgoal):\n 1. (\\<And>w s.\n        \\<lbrakk>w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}\\<rangle>;\n         s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g});\n         u =\n         w +o\n         \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}) -\n                  {s}\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using CoxeterComplex.vertex_conv_special_coset[OF CoxeterComplex]"], ["proof (prove)\nusing this:\n  u \\<in> \\<Union>\n           (CoxeterComplex.TheComplex\n             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}))\n  ?X \\<in> \\<Union>\n            (CoxeterComplex.TheComplex\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g})) \\<Longrightarrow>\n  \\<exists>w s.\n     w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g}\\<rangle> \\<and>\n     s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) \\<and>\n     ?X =\n     w +o\n     \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}) -\n              {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>w s.\n        \\<lbrakk>w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}\\<rangle>;\n         s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g});\n         u =\n         w +o\n         \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}) -\n                  {s}\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  u =\n  w +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g})) \\<Longrightarrow>\n       x \\<in> \\<psi> ` \\<Union> X", "with assms"], ["proof (chain)\npicking this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  u =\n  w +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s}\\<rangle>", "show \"u \\<in> \\<psi>`(\\<Union>X)\""], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  u =\n  w +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s}\\<rangle>\n\ngoal (1 subgoal):\n 1. u \\<in> \\<psi> ` \\<Union> X", "using label_wrt_special_coset1 fundantivertex fundchamber chamberD_simplex\n          W_endomorphism ChamberComplexEndomorphism.vertex_map"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  u =\n  w +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {s}\\<rangle>\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0;\n   ?w0.0\n   \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}\\<rangle>;\n   ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g})\\<rbrakk>\n  \\<Longrightarrow> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}\\<rangle>.\n                     w \\<rightarrow>\n                     ?\\<phi> (?w0.0 \\<rightarrow> fundantivertex ?s) =\n                     ?w0.0 \\<rightarrow> fundantivertex ?s} =\n                    ?w0.0 +o\n                    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}) -\n                             {?s}\\<rangle>\n  ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  fundantivertex ?s \\<in> C0 - ?s `\\<rightarrow> C0\n  chamber C0\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n  ?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f\n                         g}\\<rangle> \\<Longrightarrow>\n  ChamberComplexEndomorphism X ((\\<rightarrow>) ?w)\n  \\<lbrakk>ChamberComplexEndomorphism ?X ?f; ?x \\<in> \\<Union> ?X\\<rbrakk>\n  \\<Longrightarrow> ?f ?x \\<in> \\<Union> ?X\n\ngoal (1 subgoal):\n 1. u \\<in> \\<psi> ` \\<Union> X", "by    fast"], ["proof (state)\nthis:\n  u \\<in> \\<psi> ` \\<Union> X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma label_stab_map_bij_betw_vertices:\n  assumes   \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\"\n  defines   \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows     \"bij_betw \\<psi> (\\<Union>X) (\\<Union>\\<Sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw \\<psi> (\\<Union> X)\n     (\\<Union>\n       (CoxeterComplex.TheComplex\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})))", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<psi> (\\<Union> X) \\<and>\n    \\<psi> ` \\<Union> X =\n    \\<Union>\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))", "using     assms label_stab_map_inj_on_vertices label_stab_map_surj_on_vertices"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0\\<rbrakk>\n  \\<Longrightarrow> inj_on\n                     (\\<lambda>v.\n                         {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                          w \\<rightarrow> ?\\<phi> v = v})\n                     (\\<Union> X)\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>v.\n                        {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n       {Abs_induced_automorph f g}\\<rangle>.\n                         w \\<rightarrow> ?\\<phi> v = v}) `\n                    \\<Union> X =\n                    \\<Union>\n                     (CoxeterComplex.TheComplex\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}))\n\ngoal (1 subgoal):\n 1. inj_on \\<psi> (\\<Union> X) \\<and>\n    \\<psi> ` \\<Union> X =\n    \\<Union>\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))", "by        auto"], ["", "lemma label_stab_map_bij_betw_W_chambers:\n  assumes   \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\" \"w0\\<in>W\"\n  defines   \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows     \"bij_betw \\<psi> (w0`\\<rightarrow>C0) (CoxeterComplex.smap S {w0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw \\<psi> (w0 `\\<rightarrow> C0)\n     (dual_order.poset_simplex_map\n       (PreCoxeterSystem.special_cosets\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n       {w0})", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<psi> (w0 `\\<rightarrow> C0) \\<and>\n    \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "proof (rule conjI, rule inj_on_inverseI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> w0 `\\<rightarrow> C0 \\<Longrightarrow> ?g3 (\\<psi> x) = x\n 2. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "define f1 f2\n    where \"f1 = the_inv_into (CoxeterComplex.smap S 0) ((+o) w0)\"\n      and \"f2 = the_inv_into S (\\<lambda>s. \\<langle>S-{s}\\<rangle>)\""], ["proof (state)\nthis:\n  f1 =\n  the_inv_into\n   (dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     0)\n   ((+o) w0)\n  f2 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   (\\<lambda>s.\n       \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) -\n                {s}\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> w0 `\\<rightarrow> C0 \\<Longrightarrow> ?g3 (\\<psi> x) = x\n 2. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "define g where \"g = ((\\<rightarrow>) w0) \\<circ> fundantivertex \\<circ> f2 \\<circ> f1\""], ["proof (state)\nthis:\n  g = (\\<rightarrow>) w0 \\<circ> fundantivertex \\<circ> f2 \\<circ> f1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> w0 `\\<rightarrow> C0 \\<Longrightarrow> ?g3 (\\<psi> x) = x\n 2. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "from assms(3)"], ["proof (chain)\npicking this:\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>", "have inj_opw0: \"inj_on ((+o) w0) (CoxeterComplex.smap S 0)\""], ["proof (prove)\nusing this:\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n\ngoal (1 subgoal):\n 1. inj_on ((+o) w0)\n     (dual_order.poset_simplex_map\n       (PreCoxeterSystem.special_cosets\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n       0)", "using bij_betw_imp_inj_on[OF CoxeterComplex.W_lcoset_bij_betw_singletons]\n          CoxeterComplex"], ["proof (prove)\nusing this:\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<lbrakk>CoxeterComplex ?S1; ?w1 \\<in> \\<langle>?S1\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> inj_on ((+o) ?w1)\n                     (dual_order.poset_simplex_map\n                       (PreCoxeterSystem.special_cosets ?S1) 0)\n  CoxeterComplex\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. inj_on ((+o) w0)\n     (dual_order.poset_simplex_map\n       (PreCoxeterSystem.special_cosets\n         (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n       0)", "by    fast"], ["proof (state)\nthis:\n  inj_on ((+o) w0)\n   (dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     0)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> w0 `\\<rightarrow> C0 \\<Longrightarrow> ?g3 (\\<psi> x) = x\n 2. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "have inj_genby_minus_s: \"inj_on (\\<lambda>s. \\<langle>S-{s}\\<rangle>) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on\n     (\\<lambda>s.\n         \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}) -\n                  {s}\\<rangle>)\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "using bij_betw_imp_inj_on[OF CoxeterComplex.S_bij_betw_chamber0]\n          CoxeterComplex"], ["proof (prove)\nusing this:\n  CoxeterComplex ?A \\<Longrightarrow>\n  inj_on (\\<lambda>s. \\<langle>?A - {s}\\<rangle>) ?A\n  CoxeterComplex\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. inj_on\n     (\\<lambda>s.\n         \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}) -\n                  {s}\\<rangle>)\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "by    fast"], ["proof (state)\nthis:\n  inj_on\n   (\\<lambda>s.\n       \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) -\n                {s}\\<rangle>)\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> w0 `\\<rightarrow> C0 \\<Longrightarrow> ?g3 (\\<psi> x) = x\n 2. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> w0 `\\<rightarrow> C0 \\<Longrightarrow> ?g3 (\\<psi> x) = x\n 2. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "assume v: \"v\\<in>w0`\\<rightarrow>C0\""], ["proof (state)\nthis:\n  v \\<in> w0 `\\<rightarrow> C0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> w0 `\\<rightarrow> C0 \\<Longrightarrow> ?g3 (\\<psi> x) = x\n 2. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "from this"], ["proof (chain)\npicking this:\n  v \\<in> w0 `\\<rightarrow> C0", "obtain v0 where v0: \"v0\\<in>C0\" \"v = w0\\<rightarrow>v0\""], ["proof (prove)\nusing this:\n  v \\<in> w0 `\\<rightarrow> C0\n\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        \\<lbrakk>v0 \\<in> C0; v = w0 \\<rightarrow> v0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  v0 \\<in> C0\n  v = w0 \\<rightarrow> v0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> w0 `\\<rightarrow> C0 \\<Longrightarrow> ?g3 (\\<psi> x) = x\n 2. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "from v0(1)"], ["proof (chain)\npicking this:\n  v0 \\<in> C0", "have fap_v0: \"fundantipermutation v0 \\<in> S\""], ["proof (prove)\nusing this:\n  v0 \\<in> C0\n\ngoal (1 subgoal):\n 1. the_inv_into\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     fundantivertex v0\n    \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "using fundantipermutation1"], ["proof (prove)\nusing this:\n  v0 \\<in> C0\n  ?v \\<in> C0 \\<Longrightarrow>\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex ?v\n  \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. the_inv_into\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     fundantivertex v0\n    \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "by auto"], ["proof (state)\nthis:\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex v0\n  \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> w0 `\\<rightarrow> C0 \\<Longrightarrow> ?g3 (\\<psi> x) = x\n 2. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "with assms(3)"], ["proof (chain)\npicking this:\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex v0\n  \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "have  v0': \"\\<langle>S-{fundantipermutation v0}\\<rangle> \\<in> CoxeterComplex.smap S 0\""], ["proof (prove)\nusing this:\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex v0\n  \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {the_inv_into\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\n               fundantivertex v0}\\<rangle>\n    \\<in> dual_order.poset_simplex_map\n           (PreCoxeterSystem.special_cosets\n             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}))\n           0", "using genby_0_closed[of S]\n          CoxeterComplex.chamber_vertices[OF CoxeterComplex, of 0]"], ["proof (prove)\nusing this:\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex v0\n  \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  \\<lbrakk>0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                               {Abs_induced_automorph f g}\\<rangle>;\n   ?s \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g})\\<rbrakk>\n  \\<Longrightarrow> 0 +o\n                    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}) -\n                             {?s}\\<rangle>\n                    \\<in> dual_order.poset_simplex_map\n                           (PreCoxeterSystem.special_cosets\n                             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}))\n                           {0}\n\ngoal (1 subgoal):\n 1. \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {the_inv_into\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\n               fundantivertex v0}\\<rangle>\n    \\<in> dual_order.poset_simplex_map\n           (PreCoxeterSystem.special_cosets\n             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}))\n           0", "by    simp"], ["proof (state)\nthis:\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {the_inv_into\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n             fundantivertex v0}\\<rangle>\n  \\<in> dual_order.poset_simplex_map\n         (PreCoxeterSystem.special_cosets\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n         0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> w0 `\\<rightarrow> C0 \\<Longrightarrow> ?g3 (\\<psi> x) = x\n 2. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "from v0 assms"], ["proof (chain)\npicking this:\n  v0 \\<in> C0\n  v = w0 \\<rightarrow> v0\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}", "have \"\\<psi> v = w0 +o \\<langle>S-{fundantipermutation v0}\\<rangle>\""], ["proof (prove)\nusing this:\n  v0 \\<in> C0\n  v = w0 \\<rightarrow> v0\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n\ngoal (1 subgoal):\n 1. \\<psi> v =\n    w0 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {the_inv_into\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\n               fundantivertex v0}\\<rangle>", "using label_wrt_special_coset1'"], ["proof (prove)\nusing this:\n  v0 \\<in> C0\n  v = w0 \\<rightarrow> v0\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0;\n   ?w0.0\n   \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}\\<rangle>;\n   ?v \\<in> C0\\<rbrakk>\n  \\<Longrightarrow> {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n   {Abs_induced_automorph f g}\\<rangle>.\n                     w \\<rightarrow> ?\\<phi> (?w0.0 \\<rightarrow> ?v) =\n                     ?w0.0 \\<rightarrow> ?v} =\n                    ?w0.0 +o\n                    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g}) -\n                             {the_inv_into\n                               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                                   {Abs_induced_automorph f g})\n                               fundantivertex ?v}\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<psi> v =\n    w0 +o\n    \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                 {Abs_induced_automorph f g}) -\n             {the_inv_into\n               (\\<Union>(f, g)\\<in>fundfoldpairs.\n                   {Abs_induced_automorph f g})\n               fundantivertex v0}\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<psi> v =\n  w0 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {the_inv_into\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n             fundantivertex v0}\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> w0 `\\<rightarrow> C0 \\<Longrightarrow> ?g3 (\\<psi> x) = x\n 2. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "with f1_def assms(3) f2_def v0 g_def"], ["proof (chain)\npicking this:\n  f1 =\n  the_inv_into\n   (dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     0)\n   ((+o) w0)\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  f2 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   (\\<lambda>s.\n       \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) -\n                {s}\\<rangle>)\n  v0 \\<in> C0\n  v = w0 \\<rightarrow> v0\n  g = (\\<rightarrow>) w0 \\<circ> fundantivertex \\<circ> f2 \\<circ> f1\n  \\<psi> v =\n  w0 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {the_inv_into\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n             fundantivertex v0}\\<rangle>", "show \"g (\\<psi> v) = v\""], ["proof (prove)\nusing this:\n  f1 =\n  the_inv_into\n   (dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     0)\n   ((+o) w0)\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  f2 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   (\\<lambda>s.\n       \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) -\n                {s}\\<rangle>)\n  v0 \\<in> C0\n  v = w0 \\<rightarrow> v0\n  g = (\\<rightarrow>) w0 \\<circ> fundantivertex \\<circ> f2 \\<circ> f1\n  \\<psi> v =\n  w0 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {the_inv_into\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n             fundantivertex v0}\\<rangle>\n\ngoal (1 subgoal):\n 1. g (\\<psi> v) = v", "using v0' fap_v0 the_inv_into_f_f[OF inj_opw0]\n          the_inv_into_f_f[OF inj_genby_minus_s]\n          bij_betw_f_the_inv_into_f[OF fundantivertex_bij_betw]"], ["proof (prove)\nusing this:\n  f1 =\n  the_inv_into\n   (dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     0)\n   ((+o) w0)\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  f2 =\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   (\\<lambda>s.\n       \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) -\n                {s}\\<rangle>)\n  v0 \\<in> C0\n  v = w0 \\<rightarrow> v0\n  g = (\\<rightarrow>) w0 \\<circ> fundantivertex \\<circ> f2 \\<circ> f1\n  \\<psi> v =\n  w0 +o\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {the_inv_into\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n             fundantivertex v0}\\<rangle>\n  \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}) -\n           {the_inv_into\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n             fundantivertex v0}\\<rangle>\n  \\<in> dual_order.poset_simplex_map\n         (PreCoxeterSystem.special_cosets\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n         0\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   fundantivertex v0\n  \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ?x \\<in> dual_order.poset_simplex_map\n            (PreCoxeterSystem.special_cosets\n              (\\<Union>(f, g)\\<in>fundfoldpairs.\n                  {Abs_induced_automorph f g}))\n            0 \\<Longrightarrow>\n  the_inv_into\n   (dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     0)\n   ((+o) w0) (w0 +o ?x) =\n  ?x\n  ?x \\<in> (\\<Union>(f, g)\\<in>fundfoldpairs.\n               {Abs_induced_automorph f g}) \\<Longrightarrow>\n  the_inv_into\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n   (\\<lambda>s.\n       \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) -\n                {s}\\<rangle>)\n   \\<langle>(\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) -\n            {?x}\\<rangle> =\n  ?x\n  ?y \\<in> C0 \\<Longrightarrow>\n  fundantivertex\n   (the_inv_into\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n     fundantivertex ?y) =\n  ?y\n\ngoal (1 subgoal):\n 1. g (\\<psi> v) = v", "by    simp"], ["proof (state)\nthis:\n  g (\\<psi> v) = v\n\ngoal (1 subgoal):\n 1. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "from assms"], ["proof (chain)\npicking this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}", "show \"\\<psi>`(w0`\\<rightarrow>C0) = CoxeterComplex.smap S {w0}\""], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n\ngoal (1 subgoal):\n 1. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "using label_stab_map_W_fundchamber_image"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  w0 \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f g}\\<rangle>\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0;\n   ?w0.0\n   \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>v.\n                        {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n       {Abs_induced_automorph f g}\\<rangle>.\n                         w \\<rightarrow> ?\\<phi> v = v}) `\n                    ?w0.0 `\\<rightarrow> C0 =\n                    dual_order.poset_simplex_map\n                     (PreCoxeterSystem.special_cosets\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}))\n                     {?w0.0}\n\ngoal (1 subgoal):\n 1. \\<psi> ` w0 `\\<rightarrow> C0 =\n    dual_order.poset_simplex_map\n     (PreCoxeterSystem.special_cosets\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     {w0}", "by simp"], ["proof (state)\nthis:\n  \\<psi> ` w0 `\\<rightarrow> C0 =\n  dual_order.poset_simplex_map\n   (PreCoxeterSystem.special_cosets\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   {w0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma label_stab_map_surj_on_simplices:\n  assumes \\<phi>: \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\"\n  defines \\<psi>: \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows   \"\\<psi> \\<turnstile> X = \\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<turnstile> X =\n    CoxeterComplex.TheComplex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "proof (rule seteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<psi> \\<turnstile> X \\<Longrightarrow>\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g})\n 2. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<psi> \\<turnstile> X \\<Longrightarrow>\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g})\n 2. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "assume \"y \\<in> \\<psi> \\<turnstile> X\""], ["proof (state)\nthis:\n  y \\<in> \\<psi> \\<turnstile> X\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<psi> \\<turnstile> X \\<Longrightarrow>\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g})\n 2. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "from this"], ["proof (chain)\npicking this:\n  y \\<in> \\<psi> \\<turnstile> X", "obtain x where x: \"x\\<in>X\" \"y = \\<psi> ` x\""], ["proof (prove)\nusing this:\n  y \\<in> \\<psi> \\<turnstile> X\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> X; y = \\<psi> ` x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  x \\<in> X\n  y = \\<psi> ` x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<psi> \\<turnstile> X \\<Longrightarrow>\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g})\n 2. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "from x(1)"], ["proof (chain)\npicking this:\n  x \\<in> X", "obtain C where \"chamber C\" \"x\\<subseteq>C\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>chamber C; order.greater_eq C x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using simplex_in_max"], ["proof (prove)\nusing this:\n  x \\<in> X\n  ?y \\<in> X \\<Longrightarrow>\n  \\<exists>x. chamber x \\<and> order.greater_eq x ?y\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>chamber C; order.greater_eq C x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  chamber C\n  order.greater_eq C x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<psi> \\<turnstile> X \\<Longrightarrow>\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g})\n 2. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "with assms x(2)"], ["proof (chain)\npicking this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  y = \\<psi> ` x\n  chamber C\n  order.greater_eq C x", "show \"y \\<in> \\<Sigma>\""], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  y = \\<psi> ` x\n  chamber C\n  order.greater_eq C x\n\ngoal (1 subgoal):\n 1. y \\<in> CoxeterComplex.TheComplex\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "using label_stab_map_chamber_map\n          CoxeterComplex.chamberD_simplex[OF CoxeterComplex]\n          CoxeterComplex.faces[OF CoxeterComplex, of \"\\<psi>`C\" y]"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  y = \\<psi> ` x\n  chamber C\n  order.greater_eq C x\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0;\n   chamber ?C\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp\n                     (CoxeterComplex.TheComplex\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}))\n                     ((\\<lambda>v.\n                          {w \\<in> \\<langle>\\<Union>(f,\n         g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                           w \\<rightarrow> ?\\<phi> v = v}) `\n                      ?C)\n  SimplicialComplex.maxsimp\n   (CoxeterComplex.TheComplex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   ?x \\<Longrightarrow>\n  ?x \\<in> CoxeterComplex.TheComplex\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<lbrakk>\\<psi> ` C\n           \\<in> CoxeterComplex.TheComplex\n                  (\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g});\n   order.greater_eq (\\<psi> ` C) y\\<rbrakk>\n  \\<Longrightarrow> y \\<in> CoxeterComplex.TheComplex\n                             (\\<Union>(f, g)\\<in>fundfoldpairs.\n                                 {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. y \\<in> CoxeterComplex.TheComplex\n             (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "by    auto"], ["proof (state)\nthis:\n  y \\<in> CoxeterComplex.TheComplex\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "assume \"y \\<in> \\<Sigma>\""], ["proof (state)\nthis:\n  y \\<in> CoxeterComplex.TheComplex\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "from this"], ["proof (chain)\npicking this:\n  y \\<in> CoxeterComplex.TheComplex\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})", "obtain z where z: \"CoxeterComplex.chamber S z\" \"y\\<subseteq>z\""], ["proof (prove)\nusing this:\n  y \\<in> CoxeterComplex.TheComplex\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>SimplicialComplex.maxsimp\n                  (CoxeterComplex.TheComplex\n                    (\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}))\n                  z;\n         order.greater_eq z y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ChamberComplex.simplex_in_max[\n            OF CoxeterComplex.ChamberComplex_\\<Sigma>,\n            OF CoxeterComplex\n          ]"], ["proof (prove)\nusing this:\n  y \\<in> CoxeterComplex.TheComplex\n           (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  ?y \\<in> CoxeterComplex.TheComplex\n            (\\<Union>(f, g)\\<in>fundfoldpairs.\n                {Abs_induced_automorph f g}) \\<Longrightarrow>\n  \\<exists>x.\n     SimplicialComplex.maxsimp\n      (CoxeterComplex.TheComplex\n        (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n      x \\<and>\n     order.greater_eq x ?y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>SimplicialComplex.maxsimp\n                  (CoxeterComplex.TheComplex\n                    (\\<Union>(f, g)\\<in>fundfoldpairs.\n                        {Abs_induced_automorph f g}))\n                  z;\n         order.greater_eq z y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by    fast"], ["proof (state)\nthis:\n  SimplicialComplex.maxsimp\n   (CoxeterComplex.TheComplex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   z\n  order.greater_eq z y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "from z(1)"], ["proof (chain)\npicking this:\n  SimplicialComplex.maxsimp\n   (CoxeterComplex.TheComplex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   z", "obtain w where w: \"w\\<in>W\" \"z = CoxeterComplex.smap S {w}\""], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp\n   (CoxeterComplex.TheComplex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   z\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}\\<rangle>;\n         z =\n         dual_order.poset_simplex_map\n          (PreCoxeterSystem.special_cosets\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n          {w}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using CoxeterComplex.chamber_is_singleton[OF CoxeterComplex]"], ["proof (prove)\nusing this:\n  SimplicialComplex.maxsimp\n   (CoxeterComplex.TheComplex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   z\n  SimplicialComplex.maxsimp\n   (CoxeterComplex.TheComplex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   ?x \\<Longrightarrow>\n  \\<exists>w\\<in>\\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g}\\<rangle>.\n     dual_order.poset_simplex_map\n      (PreCoxeterSystem.special_cosets\n        (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n      {w} =\n     ?x\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                                     {Abs_induced_automorph f g}\\<rangle>;\n         z =\n         dual_order.poset_simplex_map\n          (PreCoxeterSystem.special_cosets\n            (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n          {w}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  z =\n  dual_order.poset_simplex_map\n   (PreCoxeterSystem.special_cosets\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   {w}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "with assms"], ["proof (chain)\npicking this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  z =\n  dual_order.poset_simplex_map\n   (PreCoxeterSystem.special_cosets\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   {w}", "have \"bij_betw \\<psi> (w`\\<rightarrow>C0) z\""], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  z =\n  dual_order.poset_simplex_map\n   (PreCoxeterSystem.special_cosets\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   {w}\n\ngoal (1 subgoal):\n 1. bij_betw \\<psi> (w `\\<rightarrow> C0) z", "using label_stab_map_bij_betw_W_chambers"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  z =\n  dual_order.poset_simplex_map\n   (PreCoxeterSystem.special_cosets\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   {w}\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0;\n   ?w0.0\n   \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                     {Abs_induced_automorph f g}\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> bij_betw\n                     (\\<lambda>v.\n                         {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                          w \\<rightarrow> ?\\<phi> v = v})\n                     (?w0.0 `\\<rightarrow> C0)\n                     (dual_order.poset_simplex_map\n                       (PreCoxeterSystem.special_cosets\n                         (\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g}))\n                       {?w0.0})\n\ngoal (1 subgoal):\n 1. bij_betw \\<psi> (w `\\<rightarrow> C0) z", "by fast"], ["proof (state)\nthis:\n  bij_betw \\<psi> (w `\\<rightarrow> C0) z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "hence 1: \"bij_betw ((`) \\<psi>) (Pow (w`\\<rightarrow>C0)) (Pow z)\""], ["proof (prove)\nusing this:\n  bij_betw \\<psi> (w `\\<rightarrow> C0) z\n\ngoal (1 subgoal):\n 1. bij_betw ((`) \\<psi>) (Pow (w `\\<rightarrow> C0)) (Pow z)", "using bij_betw_imp_bij_betw_Pow"], ["proof (prove)\nusing this:\n  bij_betw \\<psi> (w `\\<rightarrow> C0) z\n  bij_betw ?f ?A ?B \\<Longrightarrow> bij_betw ((`) ?f) (Pow ?A) (Pow ?B)\n\ngoal (1 subgoal):\n 1. bij_betw ((`) \\<psi>) (Pow (w `\\<rightarrow> C0)) (Pow z)", "by fast"], ["proof (state)\nthis:\n  bij_betw ((`) \\<psi>) (Pow (w `\\<rightarrow> C0)) (Pow z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "define x where x: \"x \\<equiv> the_inv_into (Pow (w`\\<rightarrow>C0)) ((`) \\<psi>) y\""], ["proof (state)\nthis:\n  x \\<equiv> the_inv_into (Pow (w `\\<rightarrow> C0)) ((`) \\<psi>) y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "with z(2)"], ["proof (chain)\npicking this:\n  order.greater_eq z y\n  x \\<equiv> the_inv_into (Pow (w `\\<rightarrow> C0)) ((`) \\<psi>) y", "have \"x \\<subseteq> w`\\<rightarrow>C0\""], ["proof (prove)\nusing this:\n  order.greater_eq z y\n  x \\<equiv> the_inv_into (Pow (w `\\<rightarrow> C0)) ((`) \\<psi>) y\n\ngoal (1 subgoal):\n 1. order.greater_eq (w `\\<rightarrow> C0) x", "using bij_betw_the_inv_into_onto[OF 1]"], ["proof (prove)\nusing this:\n  order.greater_eq z y\n  x \\<equiv> the_inv_into (Pow (w `\\<rightarrow> C0)) ((`) \\<psi>) y\n  the_inv_into (Pow (w `\\<rightarrow> C0)) ((`) \\<psi>) ` Pow z =\n  Pow (w `\\<rightarrow> C0)\n\ngoal (1 subgoal):\n 1. order.greater_eq (w `\\<rightarrow> C0) x", "by auto"], ["proof (state)\nthis:\n  order.greater_eq (w `\\<rightarrow> C0) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "with w(1)"], ["proof (chain)\npicking this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  order.greater_eq (w `\\<rightarrow> C0) x", "have \"x\\<in>X\""], ["proof (prove)\nusing this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  order.greater_eq (w `\\<rightarrow> C0) x\n\ngoal (1 subgoal):\n 1. x \\<in> X", "using faces fundchamber_W_image_chamber chamberD_simplex"], ["proof (prove)\nusing this:\n  w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                      {Abs_induced_automorph f g}\\<rangle>\n  order.greater_eq (w `\\<rightarrow> C0) x\n  \\<lbrakk>?x \\<in> X; order.greater_eq ?x ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> X\n  ?w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                       {Abs_induced_automorph f\n                         g}\\<rangle> \\<Longrightarrow>\n  chamber (?w `\\<rightarrow> C0)\n  chamber ?x \\<Longrightarrow> ?x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> X", "by    fastforce"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "moreover"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "from x z(2)"], ["proof (chain)\npicking this:\n  x \\<equiv> the_inv_into (Pow (w `\\<rightarrow> C0)) ((`) \\<psi>) y\n  order.greater_eq z y", "have \"y = \\<psi> ` x\""], ["proof (prove)\nusing this:\n  x \\<equiv> the_inv_into (Pow (w `\\<rightarrow> C0)) ((`) \\<psi>) y\n  order.greater_eq z y\n\ngoal (1 subgoal):\n 1. y = \\<psi> ` x", "using bij_betw_f_the_inv_into_f[OF 1]"], ["proof (prove)\nusing this:\n  x \\<equiv> the_inv_into (Pow (w `\\<rightarrow> C0)) ((`) \\<psi>) y\n  order.greater_eq z y\n  ?y \\<in> Pow z \\<Longrightarrow>\n  \\<psi> ` the_inv_into (Pow (w `\\<rightarrow> C0)) ((`) \\<psi>) ?y = ?y\n\ngoal (1 subgoal):\n 1. y = \\<psi> ` x", "by simp"], ["proof (state)\nthis:\n  y = \\<psi> ` x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> CoxeterComplex.TheComplex\n                (\\<Union>(f, g)\\<in>fundfoldpairs.\n                    {Abs_induced_automorph f g}) \\<Longrightarrow>\n       x \\<in> \\<psi> \\<turnstile> X", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> X\n  y = \\<psi> ` x", "show \"y \\<in> \\<psi> \\<turnstile> X\""], ["proof (prove)\nusing this:\n  x \\<in> X\n  y = \\<psi> ` x\n\ngoal (1 subgoal):\n 1. y \\<in> \\<psi> \\<turnstile> X", "by fast"], ["proof (state)\nthis:\n  y \\<in> \\<psi> \\<turnstile> X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma label_stab_map_iso_to_coxeter_complex:\n  assumes \"label_wrt C0 \\<phi>\" \"fixespointwise \\<phi> C0\"\n  defines \"\\<psi> \\<equiv> \\<lambda>v. {w\\<in>W. w\\<rightarrow>(\\<phi> v) = v}\"\n  shows   \"ChamberComplexIsomorphism X \\<Sigma> \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplexIsomorphism X\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     \\<psi>", "proof (\n  rule ChamberComplexIsomorphism.intro,\n  rule ChamberComplexMorphism.intro\n)"], ["proof (state)\ngoal (4 subgoals):\n 1. ChamberComplex X\n 2. ChamberComplex\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n 3. ChamberComplexMorphism_axioms X\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     \\<psi>\n 4. ChamberComplexIsomorphism_axioms X\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     \\<psi>", "show \"ChamberComplex X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplex X", ".."], ["proof (state)\nthis:\n  ChamberComplex X\n\ngoal (3 subgoals):\n 1. ChamberComplex\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n 2. ChamberComplexMorphism_axioms X\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     \\<psi>\n 3. ChamberComplexIsomorphism_axioms X\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     \\<psi>", "show \"ChamberComplex \\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ChamberComplex\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))", "using CoxeterComplex CoxeterComplex.ChamberComplex_\\<Sigma>"], ["proof (prove)\nusing this:\n  CoxeterComplex\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  CoxeterComplex ?S \\<Longrightarrow>\n  ChamberComplex (CoxeterComplex.TheComplex ?S)\n\ngoal (1 subgoal):\n 1. ChamberComplex\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))", "by fast"], ["proof (state)\nthis:\n  ChamberComplex\n   (CoxeterComplex.TheComplex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n\ngoal (2 subgoals):\n 1. ChamberComplexMorphism_axioms X\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     \\<psi>\n 2. ChamberComplexIsomorphism_axioms X\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     \\<psi>", "from assms"], ["proof (chain)\npicking this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}", "show \"ChamberComplexMorphism_axioms X \\<Sigma> \\<psi>\""], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n\ngoal (1 subgoal):\n 1. ChamberComplexMorphism_axioms X\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     \\<psi>", "using label_stab_map_chamber_map\n          CoxeterComplex.card_chamber[OF CoxeterComplex]\n          card_S_chamber"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0;\n   chamber ?C\\<rbrakk>\n  \\<Longrightarrow> SimplicialComplex.maxsimp\n                     (CoxeterComplex.TheComplex\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}))\n                     ((\\<lambda>v.\n                          {w \\<in> \\<langle>\\<Union>(f,\n         g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}\\<rangle>.\n                           w \\<rightarrow> ?\\<phi> v = v}) `\n                      ?C)\n  SimplicialComplex.maxsimp\n   (CoxeterComplex.TheComplex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   ?x \\<Longrightarrow>\n  card ?x =\n  card (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  chamber ?C \\<Longrightarrow>\n  card ?C =\n  card (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. ChamberComplexMorphism_axioms X\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     \\<psi>", "by    unfold_locales auto"], ["proof (state)\nthis:\n  ChamberComplexMorphism_axioms X\n   (CoxeterComplex.TheComplex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   \\<psi>\n\ngoal (1 subgoal):\n 1. ChamberComplexIsomorphism_axioms X\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     \\<psi>", "from assms"], ["proof (chain)\npicking this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}", "show \"ChamberComplexIsomorphism_axioms X \\<Sigma> \\<psi>\""], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n\ngoal (1 subgoal):\n 1. ChamberComplexIsomorphism_axioms X\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     \\<psi>", "using label_stab_map_bij_betw_vertices label_stab_map_surj_on_simplices"], ["proof (prove)\nusing this:\n  label_wrt C0 \\<phi>\n  fixespointwise \\<phi> C0\n  \\<psi> \\<equiv>\n  \\<lambda>v.\n     {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n                          {Abs_induced_automorph f g}\\<rangle>.\n      w \\<rightarrow> \\<phi> v = v}\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0\\<rbrakk>\n  \\<Longrightarrow> bij_betw\n                     (\\<lambda>v.\n                         {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                          w \\<rightarrow> ?\\<phi> v = v})\n                     (\\<Union> X)\n                     (\\<Union>\n                       (CoxeterComplex.TheComplex\n                         (\\<Union>(f, g)\\<in>fundfoldpairs.\n                             {Abs_induced_automorph f g})))\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>v.\n                        {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n       {Abs_induced_automorph f g}\\<rangle>.\n                         w \\<rightarrow> ?\\<phi> v = v}) \\<turnstile>\n                    X =\n                    CoxeterComplex.TheComplex\n                     (\\<Union>(f, g)\\<in>fundfoldpairs.\n                         {Abs_induced_automorph f g})\n\ngoal (1 subgoal):\n 1. ChamberComplexIsomorphism_axioms X\n     (CoxeterComplex.TheComplex\n       (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n     \\<psi>", "by    unfold_locales auto"], ["proof (state)\nthis:\n  ChamberComplexIsomorphism_axioms X\n   (CoxeterComplex.TheComplex\n     (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n   \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_iso_to_coxeter_complex':\n  \"\\<exists>\\<psi>. ChamberComplexIsomorphism X (CoxeterComplex.TheComplex S) \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<psi>.\n       ChamberComplexIsomorphism X\n        (CoxeterComplex.TheComplex\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n        \\<psi>", "using CoxeterComplex ex_label_retraction label_stab_map_iso_to_coxeter_complex"], ["proof (prove)\nusing this:\n  CoxeterComplex\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<exists>\\<phi>. label_wrt C0 \\<phi> \\<and> fixespointwise \\<phi> C0\n  \\<lbrakk>label_wrt C0 ?\\<phi>; fixespointwise ?\\<phi> C0\\<rbrakk>\n  \\<Longrightarrow> ChamberComplexIsomorphism X\n                     (CoxeterComplex.TheComplex\n                       (\\<Union>(f, g)\\<in>fundfoldpairs.\n                           {Abs_induced_automorph f g}))\n                     (\\<lambda>v.\n                         {w \\<in> \\<langle>\\<Union>(f, g)\\<in>fundfoldpairs.\n        {Abs_induced_automorph f g}\\<rangle>.\n                          w \\<rightarrow> ?\\<phi> v = v})\n\ngoal (1 subgoal):\n 1. \\<exists>\\<psi>.\n       ChamberComplexIsomorphism X\n        (CoxeterComplex.TheComplex\n          (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n        \\<psi>", "by    force"], ["", "lemma ex_iso_to_coxeter_complex:\n  \"\\<exists>S::'a permutation set. CoxeterComplex S \\<and>\n      (\\<exists>\\<psi>. ChamberComplexIsomorphism X (CoxeterComplex.TheComplex S) \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S.\n       CoxeterComplex S \\<and>\n       (\\<exists>\\<psi>.\n           ChamberComplexIsomorphism X (CoxeterComplex.TheComplex S) \\<psi>)", "using CoxeterComplex ex_iso_to_coxeter_complex'"], ["proof (prove)\nusing this:\n  CoxeterComplex\n   (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g})\n  \\<exists>\\<psi>.\n     ChamberComplexIsomorphism X\n      (CoxeterComplex.TheComplex\n        (\\<Union>(f, g)\\<in>fundfoldpairs. {Abs_induced_automorph f g}))\n      \\<psi>\n\ngoal (1 subgoal):\n 1. \\<exists>S.\n       CoxeterComplex S \\<and>\n       (\\<exists>\\<psi>.\n           ChamberComplexIsomorphism X (CoxeterComplex.TheComplex S) \\<psi>)", "by fast"], ["", "end"], ["", "(* context ThinChamberComplexManyFoldings *)"], ["", "end"], ["", "(* theory *)"]]}