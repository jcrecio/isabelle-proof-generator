{"file_name": "/home/qj213/afp-2021-10-22/thys/Stone_Algebras/Stone_Construction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stone_Algebras", "problem_names": ["lemma simp_regular [simp]:\n  \"\\<exists>y . Rep_regular x = -y\"", "lemma simp_dense [simp]:\n  \"-Rep_dense x = bot\"", "lemma up_filter_dense_antitone_dense:\n  \"dense (x \\<squnion> -x \\<squnion> y) \\<and> dense (x \\<squnion> -x \\<squnion> y \\<squnion> z)\"", "lemma up_filter_dense_antitone:\n  \"up_filter (Abs_dense (x \\<squnion> -x \\<squnion> y \\<squnion> z)) \\<le> up_filter (Abs_dense (x \\<squnion> -x \\<squnion> y))\"", "lemma stone_phi_base_filter:\n  \"filter (stone_phi_base x)\"", "lemma phi_bot:\n  \"phi bot = Abs_filter {top}\"", "lemma phi_top:\n  \"phi top = Abs_filter UNIV\"", "lemma pairs_top_in_set:\n  \"(x,y) \\<in> pairs \\<Longrightarrow> top \\<in> Rep_filter y\"", "lemma phi_complemented:\n  \"complement (phi x) (phi (-x))\"", "lemma phi_inf_principal:\n  \"\\<exists>z . up_filter z = phi x \\<sqinter> up_filter y\"", "lemma rho_char:\n  \"up_filter (rho x y) = phi x \\<sqinter> up_filter y\"", "lemma pairs_sup_closed:\n  assumes \"(x,y) \\<in> pairs\"\n      and \"(z,w) \\<in> pairs\"\n    shows \"pairs_sup (x,y) (z,w) \\<in> pairs\"", "lemma pairs_inf_closed:\n  assumes \"(x,y) \\<in> pairs\"\n      and \"(z,w) \\<in> pairs\"\n    shows \"pairs_inf (x,y) (z,w) \\<in> pairs\"", "lemma pairs_uminus_closed:\n  \"pairs_uminus (x,y) \\<in> pairs\"", "lemma pairs_bot_closed:\n  \"pairs_bot \\<in> pairs\"", "lemma pairs_top_closed:\n  \"pairs_top \\<in> pairs\"", "lemma pairs_sup_dist_inf:\n  \"(x,y) \\<in> pairs \\<Longrightarrow> (z,w) \\<in> pairs \\<Longrightarrow> (u,v) \\<in> pairs \\<Longrightarrow> pairs_sup (x,y) (pairs_inf (z,w) (u,v)) = pairs_inf (pairs_sup (x,y) (z,w)) (pairs_sup (x,y) (u,v))\"", "lemma pairs_phi_less_eq:\n  \"(x,y) \\<in> pairs \\<Longrightarrow> phi (-x) \\<le> y\"", "lemma pairs_uminus_galois:\n  assumes \"(x,y) \\<in> pairs\"\n      and \"(z,w) \\<in> pairs\"\n    shows \"pairs_inf (x,y) (z,w) = pairs_bot \\<longleftrightarrow> pairs_less_eq (x,y) (pairs_uminus (z,w))\"", "lemma pairs_stone:\n  \"(x,y) \\<in> pairs \\<Longrightarrow> pairs_sup (pairs_uminus (x,y)) (pairs_uminus (pairs_uminus (x,y))) = pairs_top\"", "lemma dense_pairs:\n  \"dense_pairs = { (x,y) . x = top \\<and> is_principal_up_filter y }\"", "lemma regular_pairs:\n  \"regular_pairs = { (x,y) . y = phi (-x) }\"", "lemma get_rho_pair_char:\n  assumes \"(x,y) \\<in> pairs\"\n    shows \"up_filter (rho_pair (x,y)) = phi x \\<sqinter> y\"", "lemma sa_iso_pair:\n  \"(--x,phi (-x) \\<squnion> up_filter y) \\<in> pairs\"", "lemma simp_phi [simp]:\n  \"bounded_lattice_homomorphism (Rep_phi x)\"", "lemma simp_lifted_pair [simp]:\n  \"\\<forall>f . Rep_lifted_pair pf f \\<in> triple.pairs (Rep_phi f)\"", "lemma stone_phi_embed_triple_pair:\n  \"(if Rep_phi f = stone_phi then Rep_stone_phi_pair x else triple.pairs_uminus (Rep_phi f) (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) \\<in> triple.pairs (Rep_phi f)\"", "lemma stone_phi_embed_homomorphism:\n  \"sup_inf_top_bot_uminus_ord_homomorphism stone_phi_embed\"", "lemma stone_phi_embed_injective:\n  \"inj stone_phi_embed\"", "lemma stone_phi_embed_order_injective:\n  assumes \"stone_phi_embed x \\<le> stone_phi_embed y\"\n    shows \"x \\<le> y\"", "lemma stone_phi_embed_strict_order_isomorphism:\n  \"x < y \\<longleftrightarrow> stone_phi_embed x < stone_phi_embed y\"", "lemma sa_iso_triple_pair:\n  \"(Abs_regular (--x),stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) \\<in> triple.pairs stone_phi\"", "lemma stone_phi_inf_dense:\n  \"stone_phi (Abs_regular (-x)) \\<sqinter> up_filter (Abs_dense (y \\<squnion> -y)) \\<le> up_filter (Abs_dense (y \\<squnion> -y \\<squnion> x))\"", "lemma stone_phi_complement:\n  \"complement (stone_phi (Abs_regular (-x))) (stone_phi (Abs_regular (--x)))\"", "lemma up_dense_stone_phi:\n  \"up_filter (Abs_dense (x \\<squnion> -x)) \\<le> stone_phi (Abs_regular (--x))\"", "lemma sa_iso_left_invertible:\n  \"sa_iso_inv (sa_iso x) = x\"", "lemma sa_iso_right_invertible:\n  \"sa_iso (sa_iso_inv p) = p\"", "lemma sa_iso:\n  \"stone_algebra_isomorphism sa_iso\"", "lemma ba_iso_inv_lifted_pair:\n  \"(Rep_lifted_boolean_algebra xf f,Rep_phi f (-Rep_lifted_boolean_algebra xf f)) \\<in> triple.pairs (Rep_phi f)\"", "lemma ba_iso_inv_regular:\n  \"regular (Abs_lifted_pair (\\<lambda>f . (Rep_lifted_boolean_algebra xf f,Rep_phi f (-Rep_lifted_boolean_algebra xf f))))\"", "lemma ba_iso_left_invertible:\n  \"ba_iso_inv (ba_iso pf) = pf\"", "lemma ba_iso_right_invertible:\n  \"ba_iso (ba_iso_inv xf) = xf\"", "lemma ba_iso:\n  \"boolean_algebra_isomorphism ba_iso\"", "lemma get_dense_char:\n  \"Rep_lifted_pair (Rep_dense pf) f = (top,up_filter (get_dense pf f))\"", "lemma dl_iso_inv_lifted_pair:\n  \"(top,up_filter (Rep_lifted_distrib_lattice_top xf f)) \\<in> triple.pairs (Rep_phi f)\"", "lemma dl_iso_inv_dense:\n  \"dense (Abs_lifted_pair (\\<lambda>f . (top,up_filter (Rep_lifted_distrib_lattice_top xf f))))\"", "lemma dl_iso_left_invertible:\n  \"dl_iso_inv (dl_iso pf) = pf\"", "lemma dl_iso_right_invertible:\n  \"dl_iso (dl_iso_inv xf) = xf\"", "lemma dl_iso:\n  \"bounded_lattice_top_isomorphism dl_iso\"", "lemma phi_iso_filter:\n  \"filter ((\\<lambda>qf::('a::non_trivial_boolean_algebra,'b::distrib_lattice_top) lifted_pair dense . Rep_lifted_distrib_lattice_top (dl_iso qf) f) ` Rep_filter (stone_phi pf))\"", "lemma phi_iso:\n  \"Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) = filter_map (\\<lambda>qf::('a::non_trivial_boolean_algebra,'b::distrib_lattice_top) lifted_pair dense . Rep_lifted_distrib_lattice_top (dl_iso qf) f) (stone_phi pf)\""], "translations": [["", "lemma simp_regular [simp]:\n  \"\\<exists>y . Rep_regular x = -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_p_image (Rep_regular x)", "using Rep_regular"], ["proof (prove)\nusing this:\n  Rep_regular ?x \\<in> regular_elements\n\ngoal (1 subgoal):\n 1. in_p_image (Rep_regular x)", "by simp"], ["", "setup_lifting type_definition_regular"], ["", "instantiation regular :: (stone_algebra) boolean_algebra\nbegin"], ["", "lift_definition sup_regular :: \"'a regular \\<Rightarrow> 'a regular \\<Rightarrow> 'a regular\" is sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>in_p_image a1; in_p_image a2\\<rbrakk>\n       \\<Longrightarrow> in_p_image (a1 \\<squnion> a2)", "by (meson regular_in_p_image_iff regular_closed_sup)"], ["", "lift_definition inf_regular :: \"'a regular \\<Rightarrow> 'a regular \\<Rightarrow> 'a regular\" is inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>in_p_image a1; in_p_image a2\\<rbrakk>\n       \\<Longrightarrow> in_p_image (a1 \\<sqinter> a2)", "by (meson regular_in_p_image_iff regular_closed_inf)"], ["", "lift_definition minus_regular :: \"'a regular \\<Rightarrow> 'a regular \\<Rightarrow> 'a regular\" is \"\\<lambda>x y . x \\<sqinter> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>in_p_image a1; in_p_image a2\\<rbrakk>\n       \\<Longrightarrow> in_p_image (a1 \\<sqinter> - a2)", "by (meson regular_in_p_image_iff regular_closed_inf)"], ["", "lift_definition uminus_regular :: \"'a regular \\<Rightarrow> 'a regular\" is uminus"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. in_p_image a \\<Longrightarrow> in_p_image (- a)", "by auto"], ["", "lift_definition bot_regular :: \"'a regular\" is bot"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_p_image bot", "by (meson regular_in_p_image_iff regular_closed_bot)"], ["", "lift_definition top_regular :: \"'a regular\" is top"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_p_image top", "by (meson regular_in_p_image_iff regular_closed_top)"], ["", "lift_definition less_eq_regular :: \"'a regular \\<Rightarrow> 'a regular \\<Rightarrow> bool\" is less_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_regular :: \"'a regular \\<Rightarrow> 'a regular \\<Rightarrow> bool\" is less"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a regular, boolean_algebra_class)", "apply intro_classes"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 16 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x_ < y_) = (x_ \\<le> y_ \\<and> \\<not> y_ \\<le> x_)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>in_p_image x; in_p_image y\\<rbrakk>\n       \\<Longrightarrow> (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by (simp add: less_le_not_le)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 15 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. in_p_image x \\<Longrightarrow> x \\<le> x", "by simp"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 14 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; y_ \\<le> z_\\<rbrakk> \\<Longrightarrow> x_ \\<le> z_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>in_p_image x; in_p_image y; x \\<le> y; in_p_image z;\n        y \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> z", "by simp"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 13 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; y_ \\<le> x_\\<rbrakk> \\<Longrightarrow> x_ = y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>in_p_image x; in_p_image y; x \\<le> y; y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "by simp"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x. x \\<sqinter> - x = bot\nA total of 12 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<sqinter> y_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>in_p_image x; in_p_image y\\<rbrakk>\n       \\<Longrightarrow> x \\<sqinter> y \\<le> x", "by simp"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x. x \\<sqinter> - x = bot\n 10. \\<And>x. x \\<squnion> - x = top\nA total of 11 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<sqinter> y_ \\<le> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>in_p_image x; in_p_image y\\<rbrakk>\n       \\<Longrightarrow> x \\<sqinter> y \\<le> y", "by simp"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x. x \\<sqinter> - x = bot\n 9. \\<And>x. x \\<squnion> - x = top\n 10. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; x_ \\<le> z_\\<rbrakk>\n    \\<Longrightarrow> x_ \\<le> y_ \\<sqinter> z_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>in_p_image x; in_p_image y; x \\<le> y; in_p_image z;\n        x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z", "by simp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x. x \\<sqinter> - x = bot\n 8. \\<And>x. x \\<squnion> - x = top\n 9. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<le> x_ \\<squnion> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>in_p_image x; in_p_image y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> x \\<squnion> y", "by simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x. x \\<sqinter> - x = bot\n 7. \\<And>x. x \\<squnion> - x = top\n 8. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. y_ \\<le> x_ \\<squnion> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>in_p_image y; in_p_image x\\<rbrakk>\n       \\<Longrightarrow> y \\<le> x \\<squnion> y", "by simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x. x \\<sqinter> - x = bot\n 6. \\<And>x. x \\<squnion> - x = top\n 7. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y_ \\<le> x_; z_ \\<le> x_\\<rbrakk>\n    \\<Longrightarrow> y_ \\<squnion> z_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x z.\n       \\<lbrakk>in_p_image y; in_p_image x; y \\<le> x; in_p_image z;\n        z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "by simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x. x \\<sqinter> - x = bot\n 5. \\<And>x. x \\<squnion> - x = top\n 6. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. bot \\<le> a_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. in_p_image x \\<Longrightarrow> bot \\<le> x", "by simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x. x \\<sqinter> - x = bot\n 4. \\<And>x. x \\<squnion> - x = top\n 5. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_ \\<le> top", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. in_p_image a \\<Longrightarrow> a \\<le> top", "by simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x. x \\<sqinter> - x = bot\n 3. \\<And>x. x \\<squnion> - x = top\n 4. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<squnion> y_ \\<sqinter> z_ =\n    (x_ \\<squnion> y_) \\<sqinter> (x_ \\<squnion> z_)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>in_p_image x; in_p_image y; in_p_image z\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z =\n                         (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "by (simp add: sup_inf_distrib1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<sqinter> - x = bot\n 2. \\<And>x. x \\<squnion> - x = top\n 3. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<sqinter> - x_ = bot", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. in_p_image x \\<Longrightarrow> x \\<sqinter> - x = bot", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<squnion> - x = top\n 2. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<squnion> - x_ = top", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. in_p_image x \\<Longrightarrow> x \\<squnion> - x = top", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ - y_ = x_ \\<sqinter> - y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>in_p_image x; in_p_image y\\<rbrakk>\n       \\<Longrightarrow> x \\<sqinter> - y = x \\<sqinter> - y", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "instantiation regular :: (non_trivial_stone_algebra) non_trivial_boolean_algebra\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a regular, non_trivial_boolean_algebra_class)", "proof (intro_classes, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x y. x \\<noteq> y \\<Longrightarrow> False", "assume \"\\<not>(\\<exists>x y::'a regular . x \\<noteq> y)\""], ["proof (state)\nthis:\n  \\<nexists>x y. x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<nexists>x y. x \\<noteq> y \\<Longrightarrow> False", "hence \"(bot::'a regular) = top\""], ["proof (prove)\nusing this:\n  \\<nexists>x y. x \\<noteq> y\n\ngoal (1 subgoal):\n 1. bot = top", "by simp"], ["proof (state)\nthis:\n  bot = top\n\ngoal (1 subgoal):\n 1. \\<nexists>x y. x \\<noteq> y \\<Longrightarrow> False", "hence \"(bot::'a) = top\""], ["proof (prove)\nusing this:\n  bot = top\n\ngoal (1 subgoal):\n 1. bot = top", "by (metis bot_regular.rep_eq top_regular.rep_eq)"], ["proof (state)\nthis:\n  bot = top\n\ngoal (1 subgoal):\n 1. \\<nexists>x y. x \\<noteq> y \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  bot = top\n\ngoal (1 subgoal):\n 1. False", "by (simp add: bot_not_top)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Dense Elements\\<close>"], ["", "text \\<open>\nThe dense elements of a Stone algebra form a distributive lattice with a greatest element.\n\\<close>"], ["", "typedef (overloaded) 'a dense = \"dense_elements::'a::stone_algebra set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> dense_elements", "using dense_closed_top"], ["proof (prove)\nusing this:\n  dense top\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> dense_elements", "by blast"], ["", "lemma simp_dense [simp]:\n  \"-Rep_dense x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense (Rep_dense x)", "using Rep_dense"], ["proof (prove)\nusing this:\n  Rep_dense ?x \\<in> dense_elements\n\ngoal (1 subgoal):\n 1. dense (Rep_dense x)", "by simp"], ["", "setup_lifting type_definition_dense"], ["", "instantiation dense :: (stone_algebra) distrib_lattice_top\nbegin"], ["", "lift_definition sup_dense :: \"'a dense \\<Rightarrow> 'a dense \\<Rightarrow> 'a dense\" is sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>dense a1; dense a2\\<rbrakk>\n       \\<Longrightarrow> dense (a1 \\<squnion> a2)", "by simp"], ["", "lift_definition inf_dense :: \"'a dense \\<Rightarrow> 'a dense \\<Rightarrow> 'a dense\" is inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>dense a1; dense a2\\<rbrakk>\n       \\<Longrightarrow> dense (a1 \\<sqinter> a2)", "by simp"], ["", "lift_definition top_dense :: \"'a dense\" is top"], ["proof (prove)\ngoal (1 subgoal):\n 1. dense top", "by simp"], ["", "lift_definition less_eq_dense :: \"'a dense \\<Rightarrow> 'a dense \\<Rightarrow> bool\" is less_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_dense :: \"'a dense \\<Rightarrow> 'a dense \\<Rightarrow> bool\" is less"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a dense, distrib_lattice_top_class)", "apply intro_classes"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 12 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x_ < y_) = (x_ \\<le> y_ \\<and> \\<not> y_ \\<le> x_)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>dense x; dense y\\<rbrakk>\n       \\<Longrightarrow> (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by (simp add: inf.less_le_not_le)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. a \\<le> top\nA total of 11 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. dense x \\<Longrightarrow> x \\<le> x", "by simp"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; y_ \\<le> z_\\<rbrakk> \\<Longrightarrow> x_ \\<le> z_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>dense x; dense y; x \\<le> y; dense z; y \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> z", "by simp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; y_ \\<le> x_\\<rbrakk> \\<Longrightarrow> x_ = y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>dense x; dense y; x \\<le> y; y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "by simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<sqinter> y_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>dense x; dense y\\<rbrakk>\n       \\<Longrightarrow> x \\<sqinter> y \\<le> x", "by simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<sqinter> y_ \\<le> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>dense x; dense y\\<rbrakk>\n       \\<Longrightarrow> x \\<sqinter> y \\<le> y", "by simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; x_ \\<le> z_\\<rbrakk>\n    \\<Longrightarrow> x_ \\<le> y_ \\<sqinter> z_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>dense x; dense y; x \\<le> y; dense z; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z", "by simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<le> x_ \\<squnion> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>dense x; dense y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> x \\<squnion> y", "by simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. y_ \\<le> x_ \\<squnion> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>dense y; dense x\\<rbrakk>\n       \\<Longrightarrow> y \\<le> x \\<squnion> y", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y_ \\<le> x_; z_ \\<le> x_\\<rbrakk>\n    \\<Longrightarrow> y_ \\<squnion> z_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x z.\n       \\<lbrakk>dense y; dense x; y \\<le> x; dense z; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_ \\<le> top", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. dense a \\<Longrightarrow> a \\<le> top", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<squnion> y_ \\<sqinter> z_ =\n    (x_ \\<squnion> y_) \\<sqinter> (x_ \\<squnion> z_)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>dense x; dense y; dense z\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z =\n                         (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "by (simp add: sup_inf_distrib1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma up_filter_dense_antitone_dense:\n  \"dense (x \\<squnion> -x \\<squnion> y) \\<and> dense (x \\<squnion> -x \\<squnion> y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense (x \\<squnion> - x \\<squnion> y) \\<and>\n    dense (x \\<squnion> - x \\<squnion> y \\<squnion> z)", "by simp"], ["", "lemma up_filter_dense_antitone:\n  \"up_filter (Abs_dense (x \\<squnion> -x \\<squnion> y \\<squnion> z)) \\<le> up_filter (Abs_dense (x \\<squnion> -x \\<squnion> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y \\<squnion> z))\n    \\<le> up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))", "by (unfold up_filter_antitone[THEN sym]) (simp add: Abs_dense_inverse less_eq_dense.rep_eq)"], ["", "text \\<open>\nThe filters of dense elements of a Stone algebra form a bounded distributive lattice.\n\\<close>"], ["", "type_synonym 'a dense_filter = \"'a dense filter\""], ["", "typedef (overloaded) 'a dense_filter_type = \"{ x::'a dense_filter . True }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {x. True}", "using filter_top"], ["proof (prove)\nusing this:\n  ord_class.filter {top}\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {x. True}", "by blast"], ["", "setup_lifting type_definition_dense_filter_type"], ["", "instantiation dense_filter_type :: (stone_algebra) bounded_distrib_lattice\nbegin"], ["", "lift_definition sup_dense_filter_type :: \"'a dense_filter_type \\<Rightarrow> 'a dense_filter_type \\<Rightarrow> 'a dense_filter_type\" is sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>filter1 filter2.\n       \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> True", "."], ["", "lift_definition inf_dense_filter_type :: \"'a dense_filter_type \\<Rightarrow> 'a dense_filter_type \\<Rightarrow> 'a dense_filter_type\" is inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>filter1 filter2.\n       \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> True", "."], ["", "lift_definition bot_dense_filter_type :: \"'a dense_filter_type\" is bot"], ["proof (prove)\ngoal (1 subgoal):\n 1. True", ".."], ["", "lift_definition top_dense_filter_type :: \"'a dense_filter_type\" is top"], ["proof (prove)\ngoal (1 subgoal):\n 1. True", ".."], ["", "lift_definition less_eq_dense_filter_type :: \"'a dense_filter_type \\<Rightarrow> 'a dense_filter_type \\<Rightarrow> bool\" is less_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_dense_filter_type :: \"'a dense_filter_type \\<Rightarrow> 'a dense_filter_type \\<Rightarrow> bool\" is less"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a dense_filter_type, bounded_distrib_lattice_class)", "apply intro_classes"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 13 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x_ < y_) = (x_ \\<le> y_ \\<and> \\<not> y_ \\<le> x_)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True\\<rbrakk>\n       \\<Longrightarrow> (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by (simp add: inf.less_le_not_le)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 12 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. True \\<Longrightarrow> x \\<le> x", "by simp"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 11 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; y_ \\<le> z_\\<rbrakk> \\<Longrightarrow> x_ \\<le> z_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>True; True; x \\<le> y; True; y \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> z", "by simp"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; y_ \\<le> x_\\<rbrakk> \\<Longrightarrow> x_ = y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True; x \\<le> y; y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "by simp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<sqinter> y_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> x \\<sqinter> y \\<le> x", "by simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<sqinter> y_ \\<le> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> x \\<sqinter> y \\<le> y", "by simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; x_ \\<le> z_\\<rbrakk>\n    \\<Longrightarrow> x_ \\<le> y_ \\<sqinter> z_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>True; True; x \\<le> y; True; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z", "by simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<le> x_ \\<squnion> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> x \\<le> x \\<squnion> y", "by simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. y_ \\<le> x_ \\<squnion> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> y \\<le> x \\<squnion> y", "by simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y_ \\<le> x_; z_ \\<le> x_\\<rbrakk>\n    \\<Longrightarrow> y_ \\<squnion> z_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x z.\n       \\<lbrakk>True; True; y \\<le> x; True; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. bot \\<le> a_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. True \\<Longrightarrow> bot \\<le> x", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_ \\<le> top", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. True \\<Longrightarrow> a \\<le> top", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<squnion> y_ \\<sqinter> z_ =\n    (x_ \\<squnion> y_) \\<sqinter> (x_ \\<squnion> z_)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>True; True; True\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqinter> z =\n                         (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "by (simp add: sup_inf_distrib1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \\<open>The Structure Map\\<close>"], ["", "text \\<open>\nThe structure map of a Stone algebra is a bounded lattice homomorphism.\nIt maps a regular element \\<open>x\\<close> to the set of all dense elements above \\<open>-x\\<close>.\nThis set is a filter.\n\\<close>"], ["", "abbreviation stone_phi_base :: \"'a::stone_algebra regular \\<Rightarrow> 'a dense set\"\n  where \"stone_phi_base x \\<equiv> { y . -Rep_regular x \\<le> Rep_dense y }\""], ["", "lemma stone_phi_base_filter:\n  \"filter (stone_phi_base x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_class.filter (stone_phi_base x)", "apply (unfold filter_def, intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. stone_phi_base x \\<noteq> {}\n 2. \\<forall>xa\\<in>stone_phi_base x.\n       \\<forall>y\\<in>stone_phi_base x.\n          \\<exists>z\\<in>stone_phi_base x. z \\<le> xa \\<and> z \\<le> y\n 3. is_up_set (stone_phi_base x)", "apply (metis Collect_empty_eq top_dense.rep_eq top_greatest)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>xa\\<in>stone_phi_base x.\n       \\<forall>y\\<in>stone_phi_base x.\n          \\<exists>z\\<in>stone_phi_base x. z \\<le> xa \\<and> z \\<le> y\n 2. is_up_set (stone_phi_base x)", "apply (metis inf_dense.rep_eq inf_le2 le_inf_iff mem_Collect_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_up_set (stone_phi_base x)", "using order_trans less_eq_dense.rep_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  (?x \\<le> ?xa) = (Rep_dense ?x \\<le> Rep_dense ?xa)\n\ngoal (1 subgoal):\n 1. is_up_set (stone_phi_base x)", "by blast"], ["", "definition stone_phi :: \"'a::stone_algebra regular \\<Rightarrow> 'a dense_filter\"\n  where \"stone_phi x = Abs_filter (stone_phi_base x)\""], ["", "text \\<open>\nTo show that we obtain a triple, we only need to prove that \\<open>stone_phi\\<close> is a bounded lattice homomorphism.\nThe Boolean algebra and the distributive lattice requirements are taken care of by the type system.\n\\<close>"], ["", "interpretation stone_phi: triple \"stone_phi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple stone_phi", "proof (unfold_locales, intro conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. sup_homomorphism stone_phi\n 2. inf_homomorphism stone_phi\n 3. top_homomorphism stone_phi\n 4. bot_homomorphism stone_phi", "have 1: \"Rep_regular (Abs_regular bot) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_regular (Abs_regular bot) = bot", "by (metis bot_regular.rep_eq bot_regular_def)"], ["proof (state)\nthis:\n  Rep_regular (Abs_regular bot) = bot\n\ngoal (4 subgoals):\n 1. sup_homomorphism stone_phi\n 2. inf_homomorphism stone_phi\n 3. top_homomorphism stone_phi\n 4. bot_homomorphism stone_phi", "show \"stone_phi bot = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot_homomorphism stone_phi", "apply (unfold stone_phi_def bot_regular_def 1 p_bot bot_filter_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Filters.filter.Abs_filter {y. top \\<le> Rep_dense y} =\n    Filters.filter.Abs_filter {top}", "by (metis (mono_tags, lifting) Collect_cong Rep_dense_inject order_refl singleton_conv top.extremum_uniqueI top_dense.rep_eq)"], ["proof (state)\nthis:\n  bot_homomorphism stone_phi\n\ngoal (3 subgoals):\n 1. sup_homomorphism stone_phi\n 2. inf_homomorphism stone_phi\n 3. top_homomorphism stone_phi", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. sup_homomorphism stone_phi\n 2. inf_homomorphism stone_phi\n 3. top_homomorphism stone_phi", "show \"stone_phi top = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_homomorphism stone_phi", "by (metis Collect_cong stone_phi_def UNIV_I bot.extremum dense_closed_top top_empty_eq top_filter.abs_eq top_regular.rep_eq top_set_def)"], ["proof (state)\nthis:\n  top_homomorphism stone_phi\n\ngoal (2 subgoals):\n 1. sup_homomorphism stone_phi\n 2. inf_homomorphism stone_phi", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sup_homomorphism stone_phi\n 2. inf_homomorphism stone_phi", "show \"\\<forall>x y::'a regular . stone_phi (x \\<squnion> y) = stone_phi x \\<squnion> stone_phi y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_homomorphism stone_phi", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi (x \\<squnion> y) = stone_phi x \\<squnion> stone_phi y", "fix x y :: \"'a regular\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi (x \\<squnion> y) = stone_phi x \\<squnion> stone_phi y", "have \"stone_phi_base (x \\<squnion> y) = filter_sup (stone_phi_base x) (stone_phi_base y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi_base (x \\<squnion> y) =\n    filter_sup (stone_phi_base x) (stone_phi_base y)", "proof (rule set_eqI, rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "fix z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "assume 2: \"z \\<in> stone_phi_base (x \\<squnion> y)\""], ["proof (state)\nthis:\n  z \\<in> stone_phi_base (x \\<squnion> y)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "let ?t = \"-Rep_regular x \\<squnion> Rep_dense z\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "let ?u = \"-Rep_regular y \\<squnion> Rep_dense z\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "let ?v = \"Abs_dense ?t\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "let ?w = \"Abs_dense ?u\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "have 3: \"?v \\<in> stone_phi_base x \\<and> ?w \\<in> stone_phi_base y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_dense (- Rep_regular x \\<squnion> Rep_dense z)\n    \\<in> stone_phi_base x \\<and>\n    Abs_dense (- Rep_regular y \\<squnion> Rep_dense z)\n    \\<in> stone_phi_base y", "by (simp add: Abs_dense_inverse)"], ["proof (state)\nthis:\n  Abs_dense (- Rep_regular x \\<squnion> Rep_dense z)\n  \\<in> stone_phi_base x \\<and>\n  Abs_dense (- Rep_regular y \\<squnion> Rep_dense z) \\<in> stone_phi_base y\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "have \"?v \\<sqinter> ?w = Abs_dense (?t \\<sqinter> ?u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_dense (- Rep_regular x \\<squnion> Rep_dense z) \\<sqinter>\n    Abs_dense (- Rep_regular y \\<squnion> Rep_dense z) =\n    Abs_dense\n     ((- Rep_regular x \\<squnion> Rep_dense z) \\<sqinter>\n      (- Rep_regular y \\<squnion> Rep_dense z))", "by (simp add: eq_onp_def inf_dense.abs_eq)"], ["proof (state)\nthis:\n  Abs_dense (- Rep_regular x \\<squnion> Rep_dense z) \\<sqinter>\n  Abs_dense (- Rep_regular y \\<squnion> Rep_dense z) =\n  Abs_dense\n   ((- Rep_regular x \\<squnion> Rep_dense z) \\<sqinter>\n    (- Rep_regular y \\<squnion> Rep_dense z))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "also"], ["proof (state)\nthis:\n  Abs_dense (- Rep_regular x \\<squnion> Rep_dense z) \\<sqinter>\n  Abs_dense (- Rep_regular y \\<squnion> Rep_dense z) =\n  Abs_dense\n   ((- Rep_regular x \\<squnion> Rep_dense z) \\<sqinter>\n    (- Rep_regular y \\<squnion> Rep_dense z))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "have \"... = Abs_dense (-Rep_regular (x \\<squnion> y) \\<squnion> Rep_dense z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_dense\n     ((- Rep_regular x \\<squnion> Rep_dense z) \\<sqinter>\n      (- Rep_regular y \\<squnion> Rep_dense z)) =\n    Abs_dense (- Rep_regular (x \\<squnion> y) \\<squnion> Rep_dense z)", "by (simp add: distrib(1) sup_commute sup_regular.rep_eq)"], ["proof (state)\nthis:\n  Abs_dense\n   ((- Rep_regular x \\<squnion> Rep_dense z) \\<sqinter>\n    (- Rep_regular y \\<squnion> Rep_dense z)) =\n  Abs_dense (- Rep_regular (x \\<squnion> y) \\<squnion> Rep_dense z)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "also"], ["proof (state)\nthis:\n  Abs_dense\n   ((- Rep_regular x \\<squnion> Rep_dense z) \\<sqinter>\n    (- Rep_regular y \\<squnion> Rep_dense z)) =\n  Abs_dense (- Rep_regular (x \\<squnion> y) \\<squnion> Rep_dense z)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "have \"... = Abs_dense (Rep_dense z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_dense (- Rep_regular (x \\<squnion> y) \\<squnion> Rep_dense z) =\n    Abs_dense (Rep_dense z)", "using 2"], ["proof (prove)\nusing this:\n  z \\<in> stone_phi_base (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. Abs_dense (- Rep_regular (x \\<squnion> y) \\<squnion> Rep_dense z) =\n    Abs_dense (Rep_dense z)", "by (simp add: le_iff_sup)"], ["proof (state)\nthis:\n  Abs_dense (- Rep_regular (x \\<squnion> y) \\<squnion> Rep_dense z) =\n  Abs_dense (Rep_dense z)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "also"], ["proof (state)\nthis:\n  Abs_dense (- Rep_regular (x \\<squnion> y) \\<squnion> Rep_dense z) =\n  Abs_dense (Rep_dense z)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "have \"... = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_dense (Rep_dense z) = z", "by (simp add: Rep_dense_inverse)"], ["proof (state)\nthis:\n  Abs_dense (Rep_dense z) = z\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> stone_phi_base (x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n 2. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "finally"], ["proof (chain)\npicking this:\n  Abs_dense (- Rep_regular x \\<squnion> Rep_dense z) \\<sqinter>\n  Abs_dense (- Rep_regular y \\<squnion> Rep_dense z) =\n  z", "show \"z \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\""], ["proof (prove)\nusing this:\n  Abs_dense (- Rep_regular x \\<squnion> Rep_dense z) \\<sqinter>\n  Abs_dense (- Rep_regular y \\<squnion> Rep_dense z) =\n  z\n\ngoal (1 subgoal):\n 1. z \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)", "using 3 mem_Collect_eq order_refl filter_sup_def"], ["proof (prove)\nusing this:\n  Abs_dense (- Rep_regular x \\<squnion> Rep_dense z) \\<sqinter>\n  Abs_dense (- Rep_regular y \\<squnion> Rep_dense z) =\n  z\n  Abs_dense (- Rep_regular x \\<squnion> Rep_dense z)\n  \\<in> stone_phi_base x \\<and>\n  Abs_dense (- Rep_regular y \\<squnion> Rep_dense z) \\<in> stone_phi_base y\n  (?a \\<in> Collect ?P) = ?P ?a\n  ?x \\<le> ?x\n  filter_sup ?F ?G \\<equiv>\n  {z. \\<exists>x\\<in>?F. \\<exists>y\\<in>?G. x \\<sqinter> y \\<le> z}\n\ngoal (1 subgoal):\n 1. z \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)", "by fastforce"], ["proof (state)\nthis:\n  z \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "assume \"z \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\""], ["proof (state)\nthis:\n  z \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "then"], ["proof (chain)\npicking this:\n  z \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)", "obtain v w where 4: \"v \\<in> stone_phi_base x \\<and> w \\<in> stone_phi_base y \\<and> v \\<sqinter> w \\<le> z\""], ["proof (prove)\nusing this:\n  z \\<in> filter_sup (stone_phi_base x) (stone_phi_base y)\n\ngoal (1 subgoal):\n 1. (\\<And>v w.\n        v \\<in> stone_phi_base x \\<and>\n        w \\<in> stone_phi_base y \\<and>\n        v \\<sqinter> w \\<le> z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding filter_sup_def"], ["proof (prove)\nusing this:\n  z \\<in> {z. \\<exists>x\\<in>stone_phi_base x.\n                 \\<exists>y\\<in>stone_phi_base y. x \\<sqinter> y \\<le> z}\n\ngoal (1 subgoal):\n 1. (\\<And>v w.\n        v \\<in> stone_phi_base x \\<and>\n        w \\<in> stone_phi_base y \\<and>\n        v \\<sqinter> w \\<le> z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> stone_phi_base x \\<and>\n  w \\<in> stone_phi_base y \\<and> v \\<sqinter> w \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "have \"-Rep_regular (x \\<squnion> y) = Rep_regular (-(x \\<squnion> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - Rep_regular (x \\<squnion> y) = Rep_regular (- (x \\<squnion> y))", "by (metis uminus_regular.rep_eq)"], ["proof (state)\nthis:\n  - Rep_regular (x \\<squnion> y) = Rep_regular (- (x \\<squnion> y))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "also"], ["proof (state)\nthis:\n  - Rep_regular (x \\<squnion> y) = Rep_regular (- (x \\<squnion> y))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "have \"... = -Rep_regular x \\<sqinter> -Rep_regular y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_regular (- (x \\<squnion> y)) =\n    - Rep_regular x \\<sqinter> - Rep_regular y", "by (simp add: inf_regular.rep_eq uminus_regular.rep_eq)"], ["proof (state)\nthis:\n  Rep_regular (- (x \\<squnion> y)) =\n  - Rep_regular x \\<sqinter> - Rep_regular y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "also"], ["proof (state)\nthis:\n  Rep_regular (- (x \\<squnion> y)) =\n  - Rep_regular x \\<sqinter> - Rep_regular y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "have \"... \\<le> Rep_dense v \\<sqinter> Rep_dense w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - Rep_regular x \\<sqinter> - Rep_regular y\n    \\<le> Rep_dense v \\<sqinter> Rep_dense w", "using 4 inf_mono mem_Collect_eq"], ["proof (prove)\nusing this:\n  v \\<in> stone_phi_base x \\<and>\n  w \\<in> stone_phi_base y \\<and> v \\<sqinter> w \\<le> z\n  \\<lbrakk>?a \\<le> ?c; ?b \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a \\<sqinter> ?b \\<le> ?c \\<sqinter> ?d\n  (?a \\<in> Collect ?P) = ?P ?a\n\ngoal (1 subgoal):\n 1. - Rep_regular x \\<sqinter> - Rep_regular y\n    \\<le> Rep_dense v \\<sqinter> Rep_dense w", "by blast"], ["proof (state)\nthis:\n  - Rep_regular x \\<sqinter> - Rep_regular y\n  \\<le> Rep_dense v \\<sqinter> Rep_dense w\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "also"], ["proof (state)\nthis:\n  - Rep_regular x \\<sqinter> - Rep_regular y\n  \\<le> Rep_dense v \\<sqinter> Rep_dense w\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "have \"... = Rep_dense (v \\<sqinter> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_dense v \\<sqinter> Rep_dense w = Rep_dense (v \\<sqinter> w)", "by (simp add: inf_dense.rep_eq)"], ["proof (state)\nthis:\n  Rep_dense v \\<sqinter> Rep_dense w = Rep_dense (v \\<sqinter> w)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "also"], ["proof (state)\nthis:\n  Rep_dense v \\<sqinter> Rep_dense w = Rep_dense (v \\<sqinter> w)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "have \"... \\<le> Rep_dense z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_dense (v \\<sqinter> w) \\<le> Rep_dense z", "using 4"], ["proof (prove)\nusing this:\n  v \\<in> stone_phi_base x \\<and>\n  w \\<in> stone_phi_base y \\<and> v \\<sqinter> w \\<le> z\n\ngoal (1 subgoal):\n 1. Rep_dense (v \\<sqinter> w) \\<le> Rep_dense z", "by (simp add: less_eq_dense.rep_eq)"], ["proof (state)\nthis:\n  Rep_dense (v \\<sqinter> w) \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> filter_sup (stone_phi_base x)\n                 (stone_phi_base y) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (x \\<squnion> y)", "finally"], ["proof (chain)\npicking this:\n  - Rep_regular (x \\<squnion> y) \\<le> Rep_dense z", "show \"z \\<in> stone_phi_base (x \\<squnion> y)\""], ["proof (prove)\nusing this:\n  - Rep_regular (x \\<squnion> y) \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. z \\<in> stone_phi_base (x \\<squnion> y)", "by simp"], ["proof (state)\nthis:\n  z \\<in> stone_phi_base (x \\<squnion> y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  stone_phi_base (x \\<squnion> y) =\n  filter_sup (stone_phi_base x) (stone_phi_base y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi (x \\<squnion> y) = stone_phi x \\<squnion> stone_phi y", "thus \"stone_phi (x \\<squnion> y) = stone_phi x \\<squnion> stone_phi y\""], ["proof (prove)\nusing this:\n  stone_phi_base (x \\<squnion> y) =\n  filter_sup (stone_phi_base x) (stone_phi_base y)\n\ngoal (1 subgoal):\n 1. stone_phi (x \\<squnion> y) = stone_phi x \\<squnion> stone_phi y", "by (simp add: stone_phi_def eq_onp_same_args stone_phi_base_filter sup_filter.abs_eq)"], ["proof (state)\nthis:\n  stone_phi (x \\<squnion> y) = stone_phi x \\<squnion> stone_phi y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sup_homomorphism stone_phi\n\ngoal (1 subgoal):\n 1. inf_homomorphism stone_phi", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inf_homomorphism stone_phi", "show \"\\<forall>x y::'a regular . stone_phi (x \\<sqinter> y) = stone_phi x \\<sqinter> stone_phi y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_homomorphism stone_phi", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi (x \\<sqinter> y) = stone_phi x \\<sqinter> stone_phi y", "fix x y :: \"'a regular\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi (x \\<sqinter> y) = stone_phi x \\<sqinter> stone_phi y", "have \"\\<forall>z . -Rep_regular (x \\<sqinter> y) \\<le> Rep_dense z \\<longleftrightarrow> -Rep_regular x \\<le> Rep_dense z \\<and> -Rep_regular y \\<le> Rep_dense z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       (- Rep_regular (x \\<sqinter> y) \\<le> Rep_dense z) =\n       (- Rep_regular x \\<le> Rep_dense z \\<and>\n        - Rep_regular y \\<le> Rep_dense z)", "by (simp add: inf_regular.rep_eq)"], ["proof (state)\nthis:\n  \\<forall>z.\n     (- Rep_regular (x \\<sqinter> y) \\<le> Rep_dense z) =\n     (- Rep_regular x \\<le> Rep_dense z \\<and>\n      - Rep_regular y \\<le> Rep_dense z)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi (x \\<sqinter> y) = stone_phi x \\<sqinter> stone_phi y", "hence \"stone_phi_base (x \\<sqinter> y) = (stone_phi_base x) \\<inter> (stone_phi_base y)\""], ["proof (prove)\nusing this:\n  \\<forall>z.\n     (- Rep_regular (x \\<sqinter> y) \\<le> Rep_dense z) =\n     (- Rep_regular x \\<le> Rep_dense z \\<and>\n      - Rep_regular y \\<le> Rep_dense z)\n\ngoal (1 subgoal):\n 1. stone_phi_base (x \\<sqinter> y) =\n    stone_phi_base x \\<inter> stone_phi_base y", "by auto"], ["proof (state)\nthis:\n  stone_phi_base (x \\<sqinter> y) =\n  stone_phi_base x \\<inter> stone_phi_base y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi (x \\<sqinter> y) = stone_phi x \\<sqinter> stone_phi y", "thus \"stone_phi (x \\<sqinter> y) = stone_phi x \\<sqinter> stone_phi y\""], ["proof (prove)\nusing this:\n  stone_phi_base (x \\<sqinter> y) =\n  stone_phi_base x \\<inter> stone_phi_base y\n\ngoal (1 subgoal):\n 1. stone_phi (x \\<sqinter> y) = stone_phi x \\<sqinter> stone_phi y", "by (simp add: stone_phi_def eq_onp_same_args stone_phi_base_filter inf_filter.abs_eq)"], ["proof (state)\nthis:\n  stone_phi (x \\<sqinter> y) = stone_phi x \\<sqinter> stone_phi y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inf_homomorphism stone_phi\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Properties of Triples\\<close>"], ["", "text \\<open>\nIn this section we construct a certain set of pairs from a triple, introduce operations on these pairs and develop their properties.\nThe given set and operations will form a Stone algebra.\n\\<close>"], ["", "context triple\nbegin"], ["", "lemma phi_bot:\n  \"phi bot = Abs_filter {top}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phi bot = Filters.filter.Abs_filter {top}", "by (metis hom bot_filter_def)"], ["", "lemma phi_top:\n  \"phi top = Abs_filter UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phi top = Filters.filter.Abs_filter UNIV", "by (metis hom top_filter_def)"], ["", "text \\<open>\nThe occurrence of \\<open>phi\\<close> in the following definition of the pairs creates a need for dependent types.\n\\<close>"], ["", "definition pairs :: \"('a \\<times> 'b filter) set\"\n  where \"pairs = { (x,y) . \\<exists>z . y = phi (-x) \\<squnion> up_filter z }\""], ["", "text \\<open>\nOperations on pairs are defined in the following.\nThey will be used to establish that the pairs form a Stone algebra.\n\\<close>"], ["", "fun pairs_less_eq :: \"('a \\<times> 'b filter) \\<Rightarrow> ('a \\<times> 'b filter) \\<Rightarrow> bool\"\n  where \"pairs_less_eq (x,y) (z,w) = (x \\<le> z \\<and> w \\<le> y)\""], ["", "fun pairs_less :: \"('a \\<times> 'b filter) \\<Rightarrow> ('a \\<times> 'b filter) \\<Rightarrow> bool\"\n  where \"pairs_less (x,y) (z,w) = (pairs_less_eq (x,y) (z,w) \\<and> \\<not> pairs_less_eq (z,w) (x,y))\""], ["", "fun pairs_sup :: \"('a \\<times> 'b filter) \\<Rightarrow> ('a \\<times> 'b filter) \\<Rightarrow> ('a \\<times> 'b filter)\"\n  where \"pairs_sup (x,y) (z,w) = (x \\<squnion> z,y \\<sqinter> w)\""], ["", "fun pairs_inf :: \"('a \\<times> 'b filter) \\<Rightarrow> ('a \\<times> 'b filter) \\<Rightarrow> ('a \\<times> 'b filter)\"\n  where \"pairs_inf (x,y) (z,w) = (x \\<sqinter> z,y \\<squnion> w)\""], ["", "fun pairs_minus :: \"('a \\<times> 'b filter) \\<Rightarrow> ('a \\<times> 'b filter) \\<Rightarrow> ('a \\<times> 'b filter)\"\n  where \"pairs_minus (x,y) (z,w) = (x \\<sqinter> -z,y \\<squnion> phi z)\""], ["", "fun pairs_uminus :: \"('a \\<times> 'b filter) \\<Rightarrow> ('a \\<times> 'b filter)\"\n  where \"pairs_uminus (x,y) = (-x,phi x)\""], ["", "abbreviation pairs_bot :: \"('a \\<times> 'b filter)\"\n  where \"pairs_bot \\<equiv> (bot,Abs_filter UNIV)\""], ["", "abbreviation pairs_top :: \"('a \\<times> 'b filter)\"\n  where \"pairs_top \\<equiv> (top,Abs_filter {top})\""], ["", "lemma pairs_top_in_set:\n  \"(x,y) \\<in> pairs \\<Longrightarrow> top \\<in> Rep_filter y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> pairs \\<Longrightarrow>\n    top \\<in> Filters.filter.Rep_filter y", "by simp"], ["", "lemma phi_complemented:\n  \"complement (phi x) (phi (-x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complement (phi x) (phi (- x))", "by (metis hom inf_compl_bot sup_compl_top)"], ["", "lemma phi_inf_principal:\n  \"\\<exists>z . up_filter z = phi x \\<sqinter> up_filter y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y", "let ?F = \"Rep_filter (phi x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y", "let ?G = \"Rep_filter (phi (-x))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y", "have 1: \"eq_onp filter ?F ?F \\<and> eq_onp filter (\\<up>y) (\\<up>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_onp ord_class.filter (Filters.filter.Rep_filter (phi x))\n     (Filters.filter.Rep_filter (phi x)) \\<and>\n    eq_onp ord_class.filter (\\<up>y) (\\<up>y)", "by (simp add: eq_onp_def)"], ["proof (state)\nthis:\n  eq_onp ord_class.filter (Filters.filter.Rep_filter (phi x))\n   (Filters.filter.Rep_filter (phi x)) \\<and>\n  eq_onp ord_class.filter (\\<up>y) (\\<up>y)\n\ngoal (1 subgoal):\n 1. \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y", "have \"filter_complements ?F ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_complements (Filters.filter.Rep_filter (phi x))\n     (Filters.filter.Rep_filter (phi (- x)))", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ord_class.filter (Filters.filter.Rep_filter (phi x))\n 2. ord_class.filter (Filters.filter.Rep_filter (phi (- x)))\n 3. filter_sup (Filters.filter.Rep_filter (phi x))\n     (Filters.filter.Rep_filter (phi (- x))) =\n    UNIV\n 4. Filters.filter.Rep_filter (phi x) \\<inter>\n    Filters.filter.Rep_filter (phi (- x)) =\n    {top}", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. ord_class.filter (Filters.filter.Rep_filter (phi (- x)))\n 2. filter_sup (Filters.filter.Rep_filter (phi x))\n     (Filters.filter.Rep_filter (phi (- x))) =\n    UNIV\n 3. Filters.filter.Rep_filter (phi x) \\<inter>\n    Filters.filter.Rep_filter (phi (- x)) =\n    {top}", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. filter_sup (Filters.filter.Rep_filter (phi x))\n     (Filters.filter.Rep_filter (phi (- x))) =\n    UNIV\n 2. Filters.filter.Rep_filter (phi x) \\<inter>\n    Filters.filter.Rep_filter (phi (- x)) =\n    {top}", "apply (metis (no_types) phi_complemented sup_filter.rep_eq top_filter.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Filters.filter.Rep_filter (phi x) \\<inter>\n    Filters.filter.Rep_filter (phi (- x)) =\n    {top}", "by (metis (no_types) phi_complemented inf_filter.rep_eq bot_filter.rep_eq)"], ["proof (state)\nthis:\n  filter_complements (Filters.filter.Rep_filter (phi x))\n   (Filters.filter.Rep_filter (phi (- x)))\n\ngoal (1 subgoal):\n 1. \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y", "hence \"is_principal_up (?F \\<inter> \\<up>y)\""], ["proof (prove)\nusing this:\n  filter_complements (Filters.filter.Rep_filter (phi x))\n   (Filters.filter.Rep_filter (phi (- x)))\n\ngoal (1 subgoal):\n 1. inf.is_principal_down\n     (Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y)", "using complemented_filter_inf_principal"], ["proof (prove)\nusing this:\n  filter_complements (Filters.filter.Rep_filter (phi x))\n   (Filters.filter.Rep_filter (phi (- x)))\n  filter_complements ?F ?G \\<Longrightarrow>\n  inf.is_principal_down (?F \\<inter> \\<up>?x)\n\ngoal (1 subgoal):\n 1. inf.is_principal_down\n     (Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y)", "by blast"], ["proof (state)\nthis:\n  inf.is_principal_down (Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y)\n\ngoal (1 subgoal):\n 1. \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y", "then"], ["proof (chain)\npicking this:\n  inf.is_principal_down (Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y)", "obtain z where \"\\<up>z = ?F \\<inter> \\<up>y\""], ["proof (prove)\nusing this:\n  inf.is_principal_down (Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<up>z =\n        Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<up>z = Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y\n\ngoal (1 subgoal):\n 1. \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y", "hence \"up_filter z = Abs_filter (?F \\<inter> \\<up>y)\""], ["proof (prove)\nusing this:\n  \\<up>z = Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y\n\ngoal (1 subgoal):\n 1. up_filter z =\n    Filters.filter.Abs_filter\n     (Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y)", "by simp"], ["proof (state)\nthis:\n  up_filter z =\n  Filters.filter.Abs_filter\n   (Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y)\n\ngoal (1 subgoal):\n 1. \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y", "also"], ["proof (state)\nthis:\n  up_filter z =\n  Filters.filter.Abs_filter\n   (Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y)\n\ngoal (1 subgoal):\n 1. \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y", "have \"... = Abs_filter ?F \\<sqinter> up_filter y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filters.filter.Abs_filter\n     (Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y) =\n    Filters.filter.Abs_filter (Filters.filter.Rep_filter (phi x)) \\<sqinter>\n    up_filter y", "using 1 inf_filter.abs_eq"], ["proof (prove)\nusing this:\n  eq_onp ord_class.filter (Filters.filter.Rep_filter (phi x))\n   (Filters.filter.Rep_filter (phi x)) \\<and>\n  eq_onp ord_class.filter (\\<up>y) (\\<up>y)\n  \\<lbrakk>eq_onp ord_class.filter ?xa ?xa;\n   eq_onp ord_class.filter ?x ?x\\<rbrakk>\n  \\<Longrightarrow> Filters.filter.Abs_filter ?xa \\<sqinter>\n                    Filters.filter.Abs_filter ?x =\n                    Filters.filter.Abs_filter (?xa \\<inter> ?x)\n\ngoal (1 subgoal):\n 1. Filters.filter.Abs_filter\n     (Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y) =\n    Filters.filter.Abs_filter (Filters.filter.Rep_filter (phi x)) \\<sqinter>\n    up_filter y", "by force"], ["proof (state)\nthis:\n  Filters.filter.Abs_filter\n   (Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y) =\n  Filters.filter.Abs_filter (Filters.filter.Rep_filter (phi x)) \\<sqinter>\n  up_filter y\n\ngoal (1 subgoal):\n 1. \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y", "also"], ["proof (state)\nthis:\n  Filters.filter.Abs_filter\n   (Filters.filter.Rep_filter (phi x) \\<inter> \\<up>y) =\n  Filters.filter.Abs_filter (Filters.filter.Rep_filter (phi x)) \\<sqinter>\n  up_filter y\n\ngoal (1 subgoal):\n 1. \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y", "have \"... = phi x \\<sqinter> up_filter y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filters.filter.Abs_filter (Filters.filter.Rep_filter (phi x)) \\<sqinter>\n    up_filter y =\n    phi x \\<sqinter> up_filter y", "by (simp add: Rep_filter_inverse)"], ["proof (state)\nthis:\n  Filters.filter.Abs_filter (Filters.filter.Rep_filter (phi x)) \\<sqinter>\n  up_filter y =\n  phi x \\<sqinter> up_filter y\n\ngoal (1 subgoal):\n 1. \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y", "finally"], ["proof (chain)\npicking this:\n  up_filter z = phi x \\<sqinter> up_filter y", "show ?thesis"], ["proof (prove)\nusing this:\n  up_filter z = phi x \\<sqinter> up_filter y\n\ngoal (1 subgoal):\n 1. \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y", "by auto"], ["proof (state)\nthis:\n  \\<exists>z. up_filter z = phi x \\<sqinter> up_filter y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nQuite a bit of filter theory is involved in showing that the intersection of \\<open>phi x\\<close> with a principal filter is a principal filter, so the following function can extract its least element.\n\\<close>"], ["", "fun rho :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'b\"\n  where \"rho x y = (SOME z . up_filter z = phi x \\<sqinter> up_filter y)\""], ["", "lemma rho_char:\n  \"up_filter (rho x y) = phi x \\<sqinter> up_filter y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_filter (rho x y) = phi x \\<sqinter> up_filter y", "by (metis (mono_tags) someI_ex rho.simps phi_inf_principal)"], ["", "text \\<open>\nThe following results show that the pairs are closed under the given operations.\n\\<close>"], ["", "lemma pairs_sup_closed:\n  assumes \"(x,y) \\<in> pairs\"\n      and \"(z,w) \\<in> pairs\"\n    shows \"pairs_sup (x,y) (z,w) \\<in> pairs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "from assms"], ["proof (chain)\npicking this:\n  (x, y) \\<in> pairs\n  (z, w) \\<in> pairs", "obtain u v where \"y = phi (-x) \\<squnion> up_filter u \\<and> w = phi (-z) \\<squnion> up_filter v\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> pairs\n  (z, w) \\<in> pairs\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        y = phi (- x) \\<squnion> up_filter u \\<and>\n        w = phi (- z) \\<squnion> up_filter v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using pairs_def"], ["proof (prove)\nusing this:\n  (x, y) \\<in> pairs\n  (z, w) \\<in> pairs\n  pairs = {(x, y). \\<exists>z. y = phi (- x) \\<squnion> up_filter z}\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        y = phi (- x) \\<squnion> up_filter u \\<and>\n        w = phi (- z) \\<squnion> up_filter v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = phi (- x) \\<squnion> up_filter u \\<and>\n  w = phi (- z) \\<squnion> up_filter v\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "hence \"pairs_sup (x,y) (z,w) = (x \\<squnion> z,(phi (-x) \\<squnion> up_filter u) \\<sqinter> (phi (-z) \\<squnion> up_filter v))\""], ["proof (prove)\nusing this:\n  y = phi (- x) \\<squnion> up_filter u \\<and>\n  w = phi (- z) \\<squnion> up_filter v\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) =\n    (x \\<squnion> z,\n     (phi (- x) \\<squnion> up_filter u) \\<sqinter>\n     (phi (- z) \\<squnion> up_filter v))", "by simp"], ["proof (state)\nthis:\n  pairs_sup (x, y) (z, w) =\n  (x \\<squnion> z,\n   (phi (- x) \\<squnion> up_filter u) \\<sqinter>\n   (phi (- z) \\<squnion> up_filter v))\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "also"], ["proof (state)\nthis:\n  pairs_sup (x, y) (z, w) =\n  (x \\<squnion> z,\n   (phi (- x) \\<squnion> up_filter u) \\<sqinter>\n   (phi (- z) \\<squnion> up_filter v))\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "have \"... = (x \\<squnion> z,(phi (-x) \\<sqinter> phi (-z)) \\<squnion> (phi (-x) \\<sqinter> up_filter v) \\<squnion> (up_filter u \\<sqinter> phi (-z)) \\<squnion> (up_filter u \\<sqinter> up_filter v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> z,\n     (phi (- x) \\<squnion> up_filter u) \\<sqinter>\n     (phi (- z) \\<squnion> up_filter v)) =\n    (x \\<squnion> z,\n     phi (- x) \\<sqinter> phi (- z) \\<squnion>\n     phi (- x) \\<sqinter> up_filter v \\<squnion>\n     up_filter u \\<sqinter> phi (- z) \\<squnion>\n     up_filter u \\<sqinter> up_filter v)", "by (simp add: inf.sup_commute inf_sup_distrib1 sup_commute sup_left_commute)"], ["proof (state)\nthis:\n  (x \\<squnion> z,\n   (phi (- x) \\<squnion> up_filter u) \\<sqinter>\n   (phi (- z) \\<squnion> up_filter v)) =\n  (x \\<squnion> z,\n   phi (- x) \\<sqinter> phi (- z) \\<squnion>\n   phi (- x) \\<sqinter> up_filter v \\<squnion>\n   up_filter u \\<sqinter> phi (- z) \\<squnion>\n   up_filter u \\<sqinter> up_filter v)\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "also"], ["proof (state)\nthis:\n  (x \\<squnion> z,\n   (phi (- x) \\<squnion> up_filter u) \\<sqinter>\n   (phi (- z) \\<squnion> up_filter v)) =\n  (x \\<squnion> z,\n   phi (- x) \\<sqinter> phi (- z) \\<squnion>\n   phi (- x) \\<sqinter> up_filter v \\<squnion>\n   up_filter u \\<sqinter> phi (- z) \\<squnion>\n   up_filter u \\<sqinter> up_filter v)\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "have \"... = (x \\<squnion> z,phi (-(x \\<squnion> z)) \\<squnion> (phi (-x) \\<sqinter> up_filter v) \\<squnion> (up_filter u \\<sqinter> phi (-z)) \\<squnion> (up_filter u \\<sqinter> up_filter v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> z,\n     phi (- x) \\<sqinter> phi (- z) \\<squnion>\n     phi (- x) \\<sqinter> up_filter v \\<squnion>\n     up_filter u \\<sqinter> phi (- z) \\<squnion>\n     up_filter u \\<sqinter> up_filter v) =\n    (x \\<squnion> z,\n     phi (- (x \\<squnion> z)) \\<squnion>\n     phi (- x) \\<sqinter> up_filter v \\<squnion>\n     up_filter u \\<sqinter> phi (- z) \\<squnion>\n     up_filter u \\<sqinter> up_filter v)", "using hom"], ["proof (prove)\nusing this:\n  bounded_lattice_homomorphism phi\n\ngoal (1 subgoal):\n 1. (x \\<squnion> z,\n     phi (- x) \\<sqinter> phi (- z) \\<squnion>\n     phi (- x) \\<sqinter> up_filter v \\<squnion>\n     up_filter u \\<sqinter> phi (- z) \\<squnion>\n     up_filter u \\<sqinter> up_filter v) =\n    (x \\<squnion> z,\n     phi (- (x \\<squnion> z)) \\<squnion>\n     phi (- x) \\<sqinter> up_filter v \\<squnion>\n     up_filter u \\<sqinter> phi (- z) \\<squnion>\n     up_filter u \\<sqinter> up_filter v)", "by simp"], ["proof (state)\nthis:\n  (x \\<squnion> z,\n   phi (- x) \\<sqinter> phi (- z) \\<squnion>\n   phi (- x) \\<sqinter> up_filter v \\<squnion>\n   up_filter u \\<sqinter> phi (- z) \\<squnion>\n   up_filter u \\<sqinter> up_filter v) =\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion>\n   phi (- x) \\<sqinter> up_filter v \\<squnion>\n   up_filter u \\<sqinter> phi (- z) \\<squnion>\n   up_filter u \\<sqinter> up_filter v)\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "also"], ["proof (state)\nthis:\n  (x \\<squnion> z,\n   phi (- x) \\<sqinter> phi (- z) \\<squnion>\n   phi (- x) \\<sqinter> up_filter v \\<squnion>\n   up_filter u \\<sqinter> phi (- z) \\<squnion>\n   up_filter u \\<sqinter> up_filter v) =\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion>\n   phi (- x) \\<sqinter> up_filter v \\<squnion>\n   up_filter u \\<sqinter> phi (- z) \\<squnion>\n   up_filter u \\<sqinter> up_filter v)\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "have \"... = (x \\<squnion> z,phi (-(x \\<squnion> z)) \\<squnion> up_filter (rho (-x) v) \\<squnion> up_filter (rho (-z) u) \\<squnion> (up_filter u \\<sqinter> up_filter v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> z,\n     phi (- (x \\<squnion> z)) \\<squnion>\n     phi (- x) \\<sqinter> up_filter v \\<squnion>\n     up_filter u \\<sqinter> phi (- z) \\<squnion>\n     up_filter u \\<sqinter> up_filter v) =\n    (x \\<squnion> z,\n     phi (- (x \\<squnion> z)) \\<squnion> up_filter (rho (- x) v) \\<squnion>\n     up_filter (rho (- z) u) \\<squnion>\n     up_filter u \\<sqinter> up_filter v)", "by (metis inf.sup_commute rho_char)"], ["proof (state)\nthis:\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion>\n   phi (- x) \\<sqinter> up_filter v \\<squnion>\n   up_filter u \\<sqinter> phi (- z) \\<squnion>\n   up_filter u \\<sqinter> up_filter v) =\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion> up_filter (rho (- x) v) \\<squnion>\n   up_filter (rho (- z) u) \\<squnion>\n   up_filter u \\<sqinter> up_filter v)\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "also"], ["proof (state)\nthis:\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion>\n   phi (- x) \\<sqinter> up_filter v \\<squnion>\n   up_filter u \\<sqinter> phi (- z) \\<squnion>\n   up_filter u \\<sqinter> up_filter v) =\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion> up_filter (rho (- x) v) \\<squnion>\n   up_filter (rho (- z) u) \\<squnion>\n   up_filter u \\<sqinter> up_filter v)\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "have \"... = (x \\<squnion> z,phi (-(x \\<squnion> z)) \\<squnion> up_filter (rho (-x) v) \\<squnion> up_filter (rho (-z) u) \\<squnion> up_filter (u \\<squnion> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> z,\n     phi (- (x \\<squnion> z)) \\<squnion> up_filter (rho (- x) v) \\<squnion>\n     up_filter (rho (- z) u) \\<squnion>\n     up_filter u \\<sqinter> up_filter v) =\n    (x \\<squnion> z,\n     phi (- (x \\<squnion> z)) \\<squnion> up_filter (rho (- x) v) \\<squnion>\n     up_filter (rho (- z) u) \\<squnion>\n     up_filter (u \\<squnion> v))", "by (metis up_filter_dist_sup)"], ["proof (state)\nthis:\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion> up_filter (rho (- x) v) \\<squnion>\n   up_filter (rho (- z) u) \\<squnion>\n   up_filter u \\<sqinter> up_filter v) =\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion> up_filter (rho (- x) v) \\<squnion>\n   up_filter (rho (- z) u) \\<squnion>\n   up_filter (u \\<squnion> v))\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "also"], ["proof (state)\nthis:\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion> up_filter (rho (- x) v) \\<squnion>\n   up_filter (rho (- z) u) \\<squnion>\n   up_filter u \\<sqinter> up_filter v) =\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion> up_filter (rho (- x) v) \\<squnion>\n   up_filter (rho (- z) u) \\<squnion>\n   up_filter (u \\<squnion> v))\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "have \"... = (x \\<squnion> z,phi (-(x \\<squnion> z)) \\<squnion> up_filter (rho (-x) v \\<sqinter> rho (-z) u \\<sqinter> (u \\<squnion> v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> z,\n     phi (- (x \\<squnion> z)) \\<squnion> up_filter (rho (- x) v) \\<squnion>\n     up_filter (rho (- z) u) \\<squnion>\n     up_filter (u \\<squnion> v)) =\n    (x \\<squnion> z,\n     phi (- (x \\<squnion> z)) \\<squnion>\n     up_filter\n      (rho (- x) v \\<sqinter> rho (- z) u \\<sqinter> (u \\<squnion> v)))", "by (simp add: sup_commute sup_left_commute up_filter_dist_inf)"], ["proof (state)\nthis:\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion> up_filter (rho (- x) v) \\<squnion>\n   up_filter (rho (- z) u) \\<squnion>\n   up_filter (u \\<squnion> v)) =\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion>\n   up_filter\n    (rho (- x) v \\<sqinter> rho (- z) u \\<sqinter> (u \\<squnion> v)))\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "finally"], ["proof (chain)\npicking this:\n  pairs_sup (x, y) (z, w) =\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion>\n   up_filter\n    (rho (- x) v \\<sqinter> rho (- z) u \\<sqinter> (u \\<squnion> v)))", "show ?thesis"], ["proof (prove)\nusing this:\n  pairs_sup (x, y) (z, w) =\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion>\n   up_filter\n    (rho (- x) v \\<sqinter> rho (- z) u \\<sqinter> (u \\<squnion> v)))\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "using pairs_def"], ["proof (prove)\nusing this:\n  pairs_sup (x, y) (z, w) =\n  (x \\<squnion> z,\n   phi (- (x \\<squnion> z)) \\<squnion>\n   up_filter\n    (rho (- x) v \\<sqinter> rho (- z) u \\<sqinter> (u \\<squnion> v)))\n  pairs = {(x, y). \\<exists>z. y = phi (- x) \\<squnion> up_filter z}\n\ngoal (1 subgoal):\n 1. pairs_sup (x, y) (z, w) \\<in> pairs", "by auto"], ["proof (state)\nthis:\n  pairs_sup (x, y) (z, w) \\<in> pairs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pairs_inf_closed:\n  assumes \"(x,y) \\<in> pairs\"\n      and \"(z,w) \\<in> pairs\"\n    shows \"pairs_inf (x,y) (z,w) \\<in> pairs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairs_inf (x, y) (z, w) \\<in> pairs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pairs_inf (x, y) (z, w) \\<in> pairs", "from assms"], ["proof (chain)\npicking this:\n  (x, y) \\<in> pairs\n  (z, w) \\<in> pairs", "obtain u v where \"y = phi (-x) \\<squnion> up_filter u \\<and> w = phi (-z) \\<squnion> up_filter v\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> pairs\n  (z, w) \\<in> pairs\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        y = phi (- x) \\<squnion> up_filter u \\<and>\n        w = phi (- z) \\<squnion> up_filter v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using pairs_def"], ["proof (prove)\nusing this:\n  (x, y) \\<in> pairs\n  (z, w) \\<in> pairs\n  pairs = {(x, y). \\<exists>z. y = phi (- x) \\<squnion> up_filter z}\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        y = phi (- x) \\<squnion> up_filter u \\<and>\n        w = phi (- z) \\<squnion> up_filter v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = phi (- x) \\<squnion> up_filter u \\<and>\n  w = phi (- z) \\<squnion> up_filter v\n\ngoal (1 subgoal):\n 1. pairs_inf (x, y) (z, w) \\<in> pairs", "hence \"pairs_inf (x,y) (z,w) = (x \\<sqinter> z,(phi (-x) \\<squnion> up_filter u) \\<squnion> (phi (-z) \\<squnion> up_filter v))\""], ["proof (prove)\nusing this:\n  y = phi (- x) \\<squnion> up_filter u \\<and>\n  w = phi (- z) \\<squnion> up_filter v\n\ngoal (1 subgoal):\n 1. pairs_inf (x, y) (z, w) =\n    (x \\<sqinter> z,\n     phi (- x) \\<squnion> up_filter u \\<squnion>\n     (phi (- z) \\<squnion> up_filter v))", "by simp"], ["proof (state)\nthis:\n  pairs_inf (x, y) (z, w) =\n  (x \\<sqinter> z,\n   phi (- x) \\<squnion> up_filter u \\<squnion>\n   (phi (- z) \\<squnion> up_filter v))\n\ngoal (1 subgoal):\n 1. pairs_inf (x, y) (z, w) \\<in> pairs", "also"], ["proof (state)\nthis:\n  pairs_inf (x, y) (z, w) =\n  (x \\<sqinter> z,\n   phi (- x) \\<squnion> up_filter u \\<squnion>\n   (phi (- z) \\<squnion> up_filter v))\n\ngoal (1 subgoal):\n 1. pairs_inf (x, y) (z, w) \\<in> pairs", "have \"... = (x \\<sqinter> z,(phi (-x) \\<squnion> phi (-z)) \\<squnion> (up_filter u \\<squnion> up_filter v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> z,\n     phi (- x) \\<squnion> up_filter u \\<squnion>\n     (phi (- z) \\<squnion> up_filter v)) =\n    (x \\<sqinter> z,\n     phi (- x) \\<squnion> phi (- z) \\<squnion>\n     (up_filter u \\<squnion> up_filter v))", "by (simp add: sup_commute sup_left_commute)"], ["proof (state)\nthis:\n  (x \\<sqinter> z,\n   phi (- x) \\<squnion> up_filter u \\<squnion>\n   (phi (- z) \\<squnion> up_filter v)) =\n  (x \\<sqinter> z,\n   phi (- x) \\<squnion> phi (- z) \\<squnion>\n   (up_filter u \\<squnion> up_filter v))\n\ngoal (1 subgoal):\n 1. pairs_inf (x, y) (z, w) \\<in> pairs", "also"], ["proof (state)\nthis:\n  (x \\<sqinter> z,\n   phi (- x) \\<squnion> up_filter u \\<squnion>\n   (phi (- z) \\<squnion> up_filter v)) =\n  (x \\<sqinter> z,\n   phi (- x) \\<squnion> phi (- z) \\<squnion>\n   (up_filter u \\<squnion> up_filter v))\n\ngoal (1 subgoal):\n 1. pairs_inf (x, y) (z, w) \\<in> pairs", "have \"... = (x \\<sqinter> z,phi (-(x \\<sqinter> z)) \\<squnion> (up_filter u \\<squnion> up_filter v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> z,\n     phi (- x) \\<squnion> phi (- z) \\<squnion>\n     (up_filter u \\<squnion> up_filter v)) =\n    (x \\<sqinter> z,\n     phi (- (x \\<sqinter> z)) \\<squnion>\n     (up_filter u \\<squnion> up_filter v))", "using hom"], ["proof (prove)\nusing this:\n  bounded_lattice_homomorphism phi\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> z,\n     phi (- x) \\<squnion> phi (- z) \\<squnion>\n     (up_filter u \\<squnion> up_filter v)) =\n    (x \\<sqinter> z,\n     phi (- (x \\<sqinter> z)) \\<squnion>\n     (up_filter u \\<squnion> up_filter v))", "by simp"], ["proof (state)\nthis:\n  (x \\<sqinter> z,\n   phi (- x) \\<squnion> phi (- z) \\<squnion>\n   (up_filter u \\<squnion> up_filter v)) =\n  (x \\<sqinter> z,\n   phi (- (x \\<sqinter> z)) \\<squnion> (up_filter u \\<squnion> up_filter v))\n\ngoal (1 subgoal):\n 1. pairs_inf (x, y) (z, w) \\<in> pairs", "also"], ["proof (state)\nthis:\n  (x \\<sqinter> z,\n   phi (- x) \\<squnion> phi (- z) \\<squnion>\n   (up_filter u \\<squnion> up_filter v)) =\n  (x \\<sqinter> z,\n   phi (- (x \\<sqinter> z)) \\<squnion> (up_filter u \\<squnion> up_filter v))\n\ngoal (1 subgoal):\n 1. pairs_inf (x, y) (z, w) \\<in> pairs", "have \"... = (x \\<sqinter> z,phi (-(x \\<sqinter> z)) \\<squnion> up_filter (u \\<sqinter> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> z,\n     phi (- (x \\<sqinter> z)) \\<squnion>\n     (up_filter u \\<squnion> up_filter v)) =\n    (x \\<sqinter> z,\n     phi (- (x \\<sqinter> z)) \\<squnion> up_filter (u \\<sqinter> v))", "by (simp add: up_filter_dist_inf)"], ["proof (state)\nthis:\n  (x \\<sqinter> z,\n   phi (- (x \\<sqinter> z)) \\<squnion>\n   (up_filter u \\<squnion> up_filter v)) =\n  (x \\<sqinter> z,\n   phi (- (x \\<sqinter> z)) \\<squnion> up_filter (u \\<sqinter> v))\n\ngoal (1 subgoal):\n 1. pairs_inf (x, y) (z, w) \\<in> pairs", "finally"], ["proof (chain)\npicking this:\n  pairs_inf (x, y) (z, w) =\n  (x \\<sqinter> z,\n   phi (- (x \\<sqinter> z)) \\<squnion> up_filter (u \\<sqinter> v))", "show ?thesis"], ["proof (prove)\nusing this:\n  pairs_inf (x, y) (z, w) =\n  (x \\<sqinter> z,\n   phi (- (x \\<sqinter> z)) \\<squnion> up_filter (u \\<sqinter> v))\n\ngoal (1 subgoal):\n 1. pairs_inf (x, y) (z, w) \\<in> pairs", "using pairs_def"], ["proof (prove)\nusing this:\n  pairs_inf (x, y) (z, w) =\n  (x \\<sqinter> z,\n   phi (- (x \\<sqinter> z)) \\<squnion> up_filter (u \\<sqinter> v))\n  pairs = {(x, y). \\<exists>z. y = phi (- x) \\<squnion> up_filter z}\n\ngoal (1 subgoal):\n 1. pairs_inf (x, y) (z, w) \\<in> pairs", "by auto"], ["proof (state)\nthis:\n  pairs_inf (x, y) (z, w) \\<in> pairs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pairs_uminus_closed:\n  \"pairs_uminus (x,y) \\<in> pairs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairs_uminus (x, y) \\<in> pairs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pairs_uminus (x, y) \\<in> pairs", "have \"pairs_uminus (x,y) = (-x,phi (--x) \\<squnion> bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairs_uminus (x, y) = (- x, phi (- - x) \\<squnion> bot)", "by simp"], ["proof (state)\nthis:\n  pairs_uminus (x, y) = (- x, phi (- - x) \\<squnion> bot)\n\ngoal (1 subgoal):\n 1. pairs_uminus (x, y) \\<in> pairs", "also"], ["proof (state)\nthis:\n  pairs_uminus (x, y) = (- x, phi (- - x) \\<squnion> bot)\n\ngoal (1 subgoal):\n 1. pairs_uminus (x, y) \\<in> pairs", "have \"... = (-x,phi (--x) \\<squnion> up_filter top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- x, phi (- - x) \\<squnion> bot) =\n    (- x, phi (- - x) \\<squnion> up_filter top)", "by (simp add: bot_filter.abs_eq)"], ["proof (state)\nthis:\n  (- x, phi (- - x) \\<squnion> bot) =\n  (- x, phi (- - x) \\<squnion> up_filter top)\n\ngoal (1 subgoal):\n 1. pairs_uminus (x, y) \\<in> pairs", "finally"], ["proof (chain)\npicking this:\n  pairs_uminus (x, y) = (- x, phi (- - x) \\<squnion> up_filter top)", "show ?thesis"], ["proof (prove)\nusing this:\n  pairs_uminus (x, y) = (- x, phi (- - x) \\<squnion> up_filter top)\n\ngoal (1 subgoal):\n 1. pairs_uminus (x, y) \\<in> pairs", "by (metis (mono_tags, lifting) mem_Collect_eq old.prod.case pairs_def)"], ["proof (state)\nthis:\n  pairs_uminus (x, y) \\<in> pairs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pairs_bot_closed:\n  \"pairs_bot \\<in> pairs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairs_bot \\<in> pairs", "using pairs_def phi_top triple.hom triple_axioms"], ["proof (prove)\nusing this:\n  pairs = {(x, y). \\<exists>z. y = phi (- x) \\<squnion> up_filter z}\n  phi top = Filters.filter.Abs_filter UNIV\n  triple ?phi \\<Longrightarrow> bounded_lattice_homomorphism ?phi\n  triple phi\n\ngoal (1 subgoal):\n 1. pairs_bot \\<in> pairs", "by fastforce"], ["", "lemma pairs_top_closed:\n  \"pairs_top \\<in> pairs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairs_top \\<in> pairs", "by (metis p_bot pairs_uminus.simps pairs_uminus_closed phi_bot)"], ["", "text \\<open>\nWe prove enough properties of the pair operations so that we can later show they form a Stone algebra.\n\\<close>"], ["", "lemma pairs_sup_dist_inf:\n  \"(x,y) \\<in> pairs \\<Longrightarrow> (z,w) \\<in> pairs \\<Longrightarrow> (u,v) \\<in> pairs \\<Longrightarrow> pairs_sup (x,y) (pairs_inf (z,w) (u,v)) = pairs_inf (pairs_sup (x,y) (z,w)) (pairs_sup (x,y) (u,v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> pairs; (z, w) \\<in> pairs;\n     (u, v) \\<in> pairs\\<rbrakk>\n    \\<Longrightarrow> pairs_sup (x, y) (pairs_inf (z, w) (u, v)) =\n                      pairs_inf (pairs_sup (x, y) (z, w))\n                       (pairs_sup (x, y) (u, v))", "using sup_inf_distrib1 inf_sup_distrib1"], ["proof (prove)\nusing this:\n  ?x \\<squnion> ?y \\<sqinter> ?z =\n  (?x \\<squnion> ?y) \\<sqinter> (?x \\<squnion> ?z)\n  ?x \\<sqinter> (?y \\<squnion> ?z) =\n  ?x \\<sqinter> ?y \\<squnion> ?x \\<sqinter> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> pairs; (z, w) \\<in> pairs;\n     (u, v) \\<in> pairs\\<rbrakk>\n    \\<Longrightarrow> pairs_sup (x, y) (pairs_inf (z, w) (u, v)) =\n                      pairs_inf (pairs_sup (x, y) (z, w))\n                       (pairs_sup (x, y) (u, v))", "by auto"], ["", "lemma pairs_phi_less_eq:\n  \"(x,y) \\<in> pairs \\<Longrightarrow> phi (-x) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> pairs \\<Longrightarrow> phi (- x) \\<le> y", "using pairs_def"], ["proof (prove)\nusing this:\n  pairs = {(x, y). \\<exists>z. y = phi (- x) \\<squnion> up_filter z}\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> pairs \\<Longrightarrow> phi (- x) \\<le> y", "by auto"], ["", "lemma pairs_uminus_galois:\n  assumes \"(x,y) \\<in> pairs\"\n      and \"(z,w) \\<in> pairs\"\n    shows \"pairs_inf (x,y) (z,w) = pairs_bot \\<longleftrightarrow> pairs_less_eq (x,y) (pairs_uminus (z,w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pairs_inf (x, y) (z, w) = pairs_bot) =\n    pairs_less_eq (x, y) (pairs_uminus (z, w))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (pairs_inf (x, y) (z, w) = pairs_bot) =\n    pairs_less_eq (x, y) (pairs_uminus (z, w))", "have 1: \"x \\<sqinter> z = bot \\<and> y \\<squnion> w = Abs_filter UNIV \\<longrightarrow> phi z \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> z = bot \\<and>\n    y \\<squnion> w = Filters.filter.Abs_filter UNIV \\<longrightarrow>\n    phi z \\<le> y", "by (metis (no_types, lifting) assms(1) heyting.implies_inf_absorb hom le_supE pairs_phi_less_eq sup_bot_right)"], ["proof (state)\nthis:\n  x \\<sqinter> z = bot \\<and>\n  y \\<squnion> w = Filters.filter.Abs_filter UNIV \\<longrightarrow>\n  phi z \\<le> y\n\ngoal (1 subgoal):\n 1. (pairs_inf (x, y) (z, w) = pairs_bot) =\n    pairs_less_eq (x, y) (pairs_uminus (z, w))", "have 2: \"x \\<le> -z \\<and> phi z \\<le> y \\<longrightarrow> y \\<squnion> w = Abs_filter UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - z \\<and> phi z \\<le> y \\<longrightarrow>\n    y \\<squnion> w = Filters.filter.Abs_filter UNIV", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> - z \\<and> phi z \\<le> y \\<Longrightarrow>\n    y \\<squnion> w = Filters.filter.Abs_filter UNIV", "assume 3: \"x \\<le> -z \\<and> phi z \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> - z \\<and> phi z \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> - z \\<and> phi z \\<le> y \\<Longrightarrow>\n    y \\<squnion> w = Filters.filter.Abs_filter UNIV", "have \"Abs_filter UNIV = phi z \\<squnion> phi (-z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filters.filter.Abs_filter UNIV = phi z \\<squnion> phi (- z)", "using hom phi_complemented phi_top"], ["proof (prove)\nusing this:\n  bounded_lattice_homomorphism phi\n  complement (phi ?x) (phi (- ?x))\n  phi top = Filters.filter.Abs_filter UNIV\n\ngoal (1 subgoal):\n 1. Filters.filter.Abs_filter UNIV = phi z \\<squnion> phi (- z)", "by auto"], ["proof (state)\nthis:\n  Filters.filter.Abs_filter UNIV = phi z \\<squnion> phi (- z)\n\ngoal (1 subgoal):\n 1. x \\<le> - z \\<and> phi z \\<le> y \\<Longrightarrow>\n    y \\<squnion> w = Filters.filter.Abs_filter UNIV", "also"], ["proof (state)\nthis:\n  Filters.filter.Abs_filter UNIV = phi z \\<squnion> phi (- z)\n\ngoal (1 subgoal):\n 1. x \\<le> - z \\<and> phi z \\<le> y \\<Longrightarrow>\n    y \\<squnion> w = Filters.filter.Abs_filter UNIV", "have \"... \\<le> y \\<squnion> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phi z \\<squnion> phi (- z) \\<le> y \\<squnion> w", "using 3 assms(2) sup_mono pairs_phi_less_eq"], ["proof (prove)\nusing this:\n  x \\<le> - z \\<and> phi z \\<le> y\n  (z, w) \\<in> pairs\n  \\<lbrakk>?a \\<le> ?c; ?b \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a \\<squnion> ?b \\<le> ?c \\<squnion> ?d\n  (?x, ?y) \\<in> pairs \\<Longrightarrow> phi (- ?x) \\<le> ?y\n\ngoal (1 subgoal):\n 1. phi z \\<squnion> phi (- z) \\<le> y \\<squnion> w", "by auto"], ["proof (state)\nthis:\n  phi z \\<squnion> phi (- z) \\<le> y \\<squnion> w\n\ngoal (1 subgoal):\n 1. x \\<le> - z \\<and> phi z \\<le> y \\<Longrightarrow>\n    y \\<squnion> w = Filters.filter.Abs_filter UNIV", "finally"], ["proof (chain)\npicking this:\n  Filters.filter.Abs_filter UNIV \\<le> y \\<squnion> w", "show \"y \\<squnion> w = Abs_filter UNIV\""], ["proof (prove)\nusing this:\n  Filters.filter.Abs_filter UNIV \\<le> y \\<squnion> w\n\ngoal (1 subgoal):\n 1. y \\<squnion> w = Filters.filter.Abs_filter UNIV", "using hom phi_top top.extremum_uniqueI"], ["proof (prove)\nusing this:\n  Filters.filter.Abs_filter UNIV \\<le> y \\<squnion> w\n  bounded_lattice_homomorphism phi\n  phi top = Filters.filter.Abs_filter UNIV\n  top \\<le> ?a \\<Longrightarrow> ?a = top\n\ngoal (1 subgoal):\n 1. y \\<squnion> w = Filters.filter.Abs_filter UNIV", "by auto"], ["proof (state)\nthis:\n  y \\<squnion> w = Filters.filter.Abs_filter UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<le> - z \\<and> phi z \\<le> y \\<longrightarrow>\n  y \\<squnion> w = Filters.filter.Abs_filter UNIV\n\ngoal (1 subgoal):\n 1. (pairs_inf (x, y) (z, w) = pairs_bot) =\n    pairs_less_eq (x, y) (pairs_uminus (z, w))", "have \"x \\<sqinter> z = bot \\<longleftrightarrow> x \\<le> -z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> z = bot) = (x \\<le> - z)", "by (simp add: shunting_1)"], ["proof (state)\nthis:\n  (x \\<sqinter> z = bot) = (x \\<le> - z)\n\ngoal (1 subgoal):\n 1. (pairs_inf (x, y) (z, w) = pairs_bot) =\n    pairs_less_eq (x, y) (pairs_uminus (z, w))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x \\<sqinter> z = bot) = (x \\<le> - z)\n\ngoal (1 subgoal):\n 1. (pairs_inf (x, y) (z, w) = pairs_bot) =\n    pairs_less_eq (x, y) (pairs_uminus (z, w))", "using 1 2 Pair_inject pairs_inf.simps pairs_less_eq.simps pairs_uminus.simps"], ["proof (prove)\nusing this:\n  (x \\<sqinter> z = bot) = (x \\<le> - z)\n  x \\<sqinter> z = bot \\<and>\n  y \\<squnion> w = Filters.filter.Abs_filter UNIV \\<longrightarrow>\n  phi z \\<le> y\n  x \\<le> - z \\<and> phi z \\<le> y \\<longrightarrow>\n  y \\<squnion> w = Filters.filter.Abs_filter UNIV\n  \\<lbrakk>(?a, ?b) = (?a', ?b');\n   \\<lbrakk>?a = ?a'; ?b = ?b'\\<rbrakk> \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n  pairs_inf (?x, ?y) (?z, ?w) = (?x \\<sqinter> ?z, ?y \\<squnion> ?w)\n  pairs_less_eq (?x, ?y) (?z, ?w) = (?x \\<le> ?z \\<and> ?w \\<le> ?y)\n  pairs_uminus (?x, ?y) = (- ?x, phi ?x)\n\ngoal (1 subgoal):\n 1. (pairs_inf (x, y) (z, w) = pairs_bot) =\n    pairs_less_eq (x, y) (pairs_uminus (z, w))", "by auto"], ["proof (state)\nthis:\n  (pairs_inf (x, y) (z, w) = pairs_bot) =\n  pairs_less_eq (x, y) (pairs_uminus (z, w))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pairs_stone:\n  \"(x,y) \\<in> pairs \\<Longrightarrow> pairs_sup (pairs_uminus (x,y)) (pairs_uminus (pairs_uminus (x,y))) = pairs_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> pairs \\<Longrightarrow>\n    pairs_sup (pairs_uminus (x, y)) (pairs_uminus (pairs_uminus (x, y))) =\n    pairs_top", "by (metis hom pairs_sup.simps pairs_uminus.simps phi_bot phi_complemented stone)"], ["", "text \\<open>\nThe following results show how the regular elements and the dense elements among the pairs look like.\n\\<close>"], ["", "abbreviation \"dense_pairs \\<equiv> { (x,y) . (x,y) \\<in> pairs \\<and> pairs_uminus (x,y) = pairs_bot }\""], ["", "abbreviation \"regular_pairs \\<equiv> { (x,y) . (x,y) \\<in> pairs \\<and> pairs_uminus (pairs_uminus (x,y)) = (x,y) }\""], ["", "abbreviation \"is_principal_up_filter x \\<equiv> \\<exists>y . x = up_filter y\""], ["", "lemma dense_pairs:\n  \"dense_pairs = { (x,y) . x = top \\<and> is_principal_up_filter y }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> pairs \\<and> pairs_uminus (x, y) = pairs_bot} =\n    {(x, y). x = top \\<and> (\\<exists>ya. y = up_filter ya)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> pairs \\<and> pairs_uminus (x, y) = pairs_bot} =\n    {(x, y). x = top \\<and> (\\<exists>ya. y = up_filter ya)}", "have \"dense_pairs = { (x,y) . (x,y) \\<in> pairs \\<and> x = top }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> pairs \\<and> pairs_uminus (x, y) = pairs_bot} =\n    {(x, y). (x, y) \\<in> pairs \\<and> x = top}", "by (metis Pair_inject compl_bot_eq double_compl pairs_uminus.simps phi_top)"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> pairs \\<and> pairs_uminus (x, y) = pairs_bot} =\n  {(x, y). (x, y) \\<in> pairs \\<and> x = top}\n\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> pairs \\<and> pairs_uminus (x, y) = pairs_bot} =\n    {(x, y). x = top \\<and> (\\<exists>ya. y = up_filter ya)}", "also"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> pairs \\<and> pairs_uminus (x, y) = pairs_bot} =\n  {(x, y). (x, y) \\<in> pairs \\<and> x = top}\n\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> pairs \\<and> pairs_uminus (x, y) = pairs_bot} =\n    {(x, y). x = top \\<and> (\\<exists>ya. y = up_filter ya)}", "have \"... = { (x,y) . (\\<exists>z . y = up_filter z) \\<and> x = top }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> pairs \\<and> x = top} =\n    {(x, y). (\\<exists>z. y = up_filter z) \\<and> x = top}", "using hom pairs_def"], ["proof (prove)\nusing this:\n  bounded_lattice_homomorphism phi\n  pairs = {(x, y). \\<exists>z. y = phi (- x) \\<squnion> up_filter z}\n\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> pairs \\<and> x = top} =\n    {(x, y). (\\<exists>z. y = up_filter z) \\<and> x = top}", "by auto"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> pairs \\<and> x = top} =\n  {(x, y). (\\<exists>z. y = up_filter z) \\<and> x = top}\n\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> pairs \\<and> pairs_uminus (x, y) = pairs_bot} =\n    {(x, y). x = top \\<and> (\\<exists>ya. y = up_filter ya)}", "finally"], ["proof (chain)\npicking this:\n  {(x, y). (x, y) \\<in> pairs \\<and> pairs_uminus (x, y) = pairs_bot} =\n  {(x, y). (\\<exists>z. y = up_filter z) \\<and> x = top}", "show ?thesis"], ["proof (prove)\nusing this:\n  {(x, y). (x, y) \\<in> pairs \\<and> pairs_uminus (x, y) = pairs_bot} =\n  {(x, y). (\\<exists>z. y = up_filter z) \\<and> x = top}\n\ngoal (1 subgoal):\n 1. {(x, y). (x, y) \\<in> pairs \\<and> pairs_uminus (x, y) = pairs_bot} =\n    {(x, y). x = top \\<and> (\\<exists>ya. y = up_filter ya)}", "by auto"], ["proof (state)\nthis:\n  {(x, y). (x, y) \\<in> pairs \\<and> pairs_uminus (x, y) = pairs_bot} =\n  {(x, y). x = top \\<and> (\\<exists>ya. y = up_filter ya)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma regular_pairs:\n  \"regular_pairs = { (x,y) . y = phi (-x) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular_pairs = {(x, y). y = phi (- x)}", "using pairs_def pairs_uminus_closed"], ["proof (prove)\nusing this:\n  pairs = {(x, y). \\<exists>z. y = phi (- x) \\<squnion> up_filter z}\n  pairs_uminus (?x, ?y) \\<in> pairs\n\ngoal (1 subgoal):\n 1. regular_pairs = {(x, y). y = phi (- x)}", "by fastforce"], ["", "text \\<open>\nThe following extraction function will be used in defining one direction of the Stone algebra isomorphism.\n\\<close>"], ["", "fun rho_pair :: \"'a \\<times> 'b filter \\<Rightarrow> 'b\"\n  where \"rho_pair (x,y) = (SOME z . up_filter z = phi x \\<sqinter> y)\""], ["", "lemma get_rho_pair_char:\n  assumes \"(x,y) \\<in> pairs\"\n    shows \"up_filter (rho_pair (x,y)) = phi x \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_filter (rho_pair (x, y)) = phi x \\<sqinter> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. up_filter (rho_pair (x, y)) = phi x \\<sqinter> y", "from assms"], ["proof (chain)\npicking this:\n  (x, y) \\<in> pairs", "obtain w where \"y = phi (-x) \\<squnion> up_filter w\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> pairs\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        y = phi (- x) \\<squnion> up_filter w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using pairs_def"], ["proof (prove)\nusing this:\n  (x, y) \\<in> pairs\n  pairs = {(x, y). \\<exists>z. y = phi (- x) \\<squnion> up_filter z}\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        y = phi (- x) \\<squnion> up_filter w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = phi (- x) \\<squnion> up_filter w\n\ngoal (1 subgoal):\n 1. up_filter (rho_pair (x, y)) = phi x \\<sqinter> y", "hence \"phi x \\<sqinter> y = phi x \\<sqinter> up_filter w\""], ["proof (prove)\nusing this:\n  y = phi (- x) \\<squnion> up_filter w\n\ngoal (1 subgoal):\n 1. phi x \\<sqinter> y = phi x \\<sqinter> up_filter w", "by (simp add: inf_sup_distrib1 phi_complemented)"], ["proof (state)\nthis:\n  phi x \\<sqinter> y = phi x \\<sqinter> up_filter w\n\ngoal (1 subgoal):\n 1. up_filter (rho_pair (x, y)) = phi x \\<sqinter> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  phi x \\<sqinter> y = phi x \\<sqinter> up_filter w\n\ngoal (1 subgoal):\n 1. up_filter (rho_pair (x, y)) = phi x \\<sqinter> y", "using rho_char"], ["proof (prove)\nusing this:\n  phi x \\<sqinter> y = phi x \\<sqinter> up_filter w\n  up_filter (rho ?x ?y) = phi ?x \\<sqinter> up_filter ?y\n\ngoal (1 subgoal):\n 1. up_filter (rho_pair (x, y)) = phi x \\<sqinter> y", "by auto"], ["proof (state)\nthis:\n  up_filter (rho_pair (x, y)) = phi x \\<sqinter> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sa_iso_pair:\n  \"(--x,phi (-x) \\<squnion> up_filter y) \\<in> pairs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- - x, phi (- x) \\<squnion> up_filter y) \\<in> pairs", "using pairs_def"], ["proof (prove)\nusing this:\n  pairs = {(x, y). \\<exists>z. y = phi (- x) \\<squnion> up_filter z}\n\ngoal (1 subgoal):\n 1. (- - x, phi (- x) \\<squnion> up_filter y) \\<in> pairs", "by auto"], ["", "end"], ["", "subsection \\<open>The Stone Algebra of a Triple\\<close>"], ["", "text \\<open>\nIn this section we prove that the set of pairs constructed in a triple forms a Stone Algebra.\nThe following type captures the parameter \\<open>phi\\<close> on which the type of triples depends.\nThis parameter is the structure map that occurs in the definition of the set of pairs.\nThe set of all structure maps is the set of all bounded lattice homomorphisms (of appropriate type).\nIn order to make it a HOL type, we need to show that at least one such structure map exists.\nTo this end we use the ultrafilter lemma: the required bounded lattice homomorphism is essentially the characteristic map of an ultrafilter, but the latter must exist.\nIn particular, the underlying Boolean algebra must contain at least two elements.\n\\<close>"], ["", "typedef (overloaded) ('a,'b) phi = \"{ f::'a::non_trivial_boolean_algebra \\<Rightarrow> 'b::distrib_lattice_top filter . bounded_lattice_homomorphism f }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. bounded_lattice_homomorphism f}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. bounded_lattice_homomorphism f}", "from ultra_filter_exists"], ["proof (chain)\npicking this:\n  \\<exists>F. ultra_filter F", "obtain F :: \"'a set\" where 1: \"ultra_filter F\""], ["proof (prove)\nusing this:\n  \\<exists>F. ultra_filter F\n\ngoal (1 subgoal):\n 1. (\\<And>F. ultra_filter F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ultra_filter F\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. bounded_lattice_homomorphism f}", "hence 2: \"prime_filter F\""], ["proof (prove)\nusing this:\n  ultra_filter F\n\ngoal (1 subgoal):\n 1. prime_filter F", "using ultra_filter_prime"], ["proof (prove)\nusing this:\n  ultra_filter F\n  ultra_filter ?F \\<Longrightarrow> prime_filter ?F\n\ngoal (1 subgoal):\n 1. prime_filter F", "by auto"], ["proof (state)\nthis:\n  prime_filter F\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. bounded_lattice_homomorphism f}", "let ?f = \"\\<lambda>x . if x\\<in>F then top else bot::'b filter\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. bounded_lattice_homomorphism f}", "have \"bounded_lattice_homomorphism ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<forall>x y.\n          (if x \\<squnion> y \\<in> F then top else bot) =\n          (if x \\<in> F then top else bot) \\<squnion>\n          (if y \\<in> F then top else bot)) \\<and>\n      (\\<forall>x y.\n          (if x \\<sqinter> y \\<in> F then top else bot) =\n          (if x \\<in> F then top else bot) \\<sqinter>\n          (if y \\<in> F then top else bot))) \\<and>\n     (if top \\<in> F then top else bot) = top) \\<and>\n    bot_homomorphism (If (bot \\<in> F) top)", "proof (intro conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>x y.\n       (if x \\<squnion> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<squnion>\n       (if y \\<in> F then top else bot)\n 2. \\<forall>x y.\n       (if x \\<sqinter> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<sqinter>\n       (if y \\<in> F then top else bot)\n 3. (if top \\<in> F then top else bot) = top\n 4. bot_homomorphism (If (bot \\<in> F) top)", "show \"?f bot = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot_homomorphism (If (bot \\<in> F) top)", "using 1"], ["proof (prove)\nusing this:\n  ultra_filter F\n\ngoal (1 subgoal):\n 1. bot_homomorphism (If (bot \\<in> F) top)", "by (meson bot.extremum filter_def subset_eq top.extremum_unique)"], ["proof (state)\nthis:\n  bot_homomorphism (If (bot \\<in> F) top)\n\ngoal (3 subgoals):\n 1. \\<forall>x y.\n       (if x \\<squnion> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<squnion>\n       (if y \\<in> F then top else bot)\n 2. \\<forall>x y.\n       (if x \\<sqinter> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<sqinter>\n       (if y \\<in> F then top else bot)\n 3. (if top \\<in> F then top else bot) = top", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>x y.\n       (if x \\<squnion> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<squnion>\n       (if y \\<in> F then top else bot)\n 2. \\<forall>x y.\n       (if x \\<sqinter> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<sqinter>\n       (if y \\<in> F then top else bot)\n 3. (if top \\<in> F then top else bot) = top", "show \"?f top = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if top \\<in> F then top else bot) = top", "using 1"], ["proof (prove)\nusing this:\n  ultra_filter F\n\ngoal (1 subgoal):\n 1. (if top \\<in> F then top else bot) = top", "by simp"], ["proof (state)\nthis:\n  (if top \\<in> F then top else bot) = top\n\ngoal (2 subgoals):\n 1. \\<forall>x y.\n       (if x \\<squnion> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<squnion>\n       (if y \\<in> F then top else bot)\n 2. \\<forall>x y.\n       (if x \\<sqinter> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<sqinter>\n       (if y \\<in> F then top else bot)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x y.\n       (if x \\<squnion> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<squnion>\n       (if y \\<in> F then top else bot)\n 2. \\<forall>x y.\n       (if x \\<sqinter> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<sqinter>\n       (if y \\<in> F then top else bot)", "show \"\\<forall>x y . ?f (x \\<squnion> y) = ?f x \\<squnion> ?f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (if x \\<squnion> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<squnion>\n       (if y \\<in> F then top else bot)", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (if x \\<squnion> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<squnion>\n       (if y \\<in> F then top else bot)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (if x \\<squnion> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<squnion>\n       (if y \\<in> F then top else bot)", "show \"?f (x \\<squnion> y) = ?f x \\<squnion> ?f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x \\<squnion> y \\<in> F then top else bot) =\n    (if x \\<in> F then top else bot) \\<squnion>\n    (if y \\<in> F then top else bot)", "apply (cases \"x \\<in> F\"; cases \"y \\<in> F\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)\n 2. \\<lbrakk>x \\<in> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)\n 3. \\<lbrakk>x \\<notin> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)\n 4. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)", "using 1 filter_def"], ["proof (prove)\nusing this:\n  ultra_filter F\n  ord_class.filter ?F \\<equiv>\n  ?F \\<noteq> {} \\<and>\n  (\\<forall>x\\<in>?F.\n      \\<forall>y\\<in>?F.\n         \\<exists>z\\<in>?F. z \\<le> x \\<and> z \\<le> y) \\<and>\n  is_up_set ?F\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)\n 2. \\<lbrakk>x \\<in> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)\n 3. \\<lbrakk>x \\<notin> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)\n 4. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)\n 2. \\<lbrakk>x \\<notin> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)\n 3. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)", "using 1 filter_def"], ["proof (prove)\nusing this:\n  ultra_filter F\n  ord_class.filter ?F \\<equiv>\n  ?F \\<noteq> {} \\<and>\n  (\\<forall>x\\<in>?F.\n      \\<forall>y\\<in>?F.\n         \\<exists>z\\<in>?F. z \\<le> x \\<and> z \\<le> y) \\<and>\n  is_up_set ?F\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)\n 2. \\<lbrakk>x \\<notin> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)\n 3. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)\n 2. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)", "using 1 filter_def"], ["proof (prove)\nusing this:\n  ultra_filter F\n  ord_class.filter ?F \\<equiv>\n  ?F \\<noteq> {} \\<and>\n  (\\<forall>x\\<in>?F.\n      \\<forall>y\\<in>?F.\n         \\<exists>z\\<in>?F. z \\<le> x \\<and> z \\<le> y) \\<and>\n  is_up_set ?F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)\n 2. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)", "using 2 sup_bot_left"], ["proof (prove)\nusing this:\n  prime_filter F\n  bot \\<squnion> ?x = ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<squnion> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<squnion>\n                      (if y \\<in> F then top else bot)", "by auto"], ["proof (state)\nthis:\n  (if x \\<squnion> y \\<in> F then top else bot) =\n  (if x \\<in> F then top else bot) \\<squnion>\n  (if y \\<in> F then top else bot)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y.\n     (if x \\<squnion> y \\<in> F then top else bot) =\n     (if x \\<in> F then top else bot) \\<squnion>\n     (if y \\<in> F then top else bot)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (if x \\<sqinter> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<sqinter>\n       (if y \\<in> F then top else bot)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (if x \\<sqinter> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<sqinter>\n       (if y \\<in> F then top else bot)", "show \"\\<forall>x y . ?f (x \\<sqinter> y) = ?f x \\<sqinter> ?f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (if x \\<sqinter> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<sqinter>\n       (if y \\<in> F then top else bot)", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (if x \\<sqinter> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<sqinter>\n       (if y \\<in> F then top else bot)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (if x \\<sqinter> y \\<in> F then top else bot) =\n       (if x \\<in> F then top else bot) \\<sqinter>\n       (if y \\<in> F then top else bot)", "show \"?f (x \\<sqinter> y) = ?f x \\<sqinter> ?f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x \\<sqinter> y \\<in> F then top else bot) =\n    (if x \\<in> F then top else bot) \\<sqinter>\n    (if y \\<in> F then top else bot)", "apply (cases \"x \\<in> F\"; cases \"y \\<in> F\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)\n 2. \\<lbrakk>x \\<in> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)\n 3. \\<lbrakk>x \\<notin> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)\n 4. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)", "using 1"], ["proof (prove)\nusing this:\n  ultra_filter F\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)\n 2. \\<lbrakk>x \\<in> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)\n 3. \\<lbrakk>x \\<notin> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)\n 4. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)", "apply (simp add: filter_inf_closed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)\n 2. \\<lbrakk>x \\<notin> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)\n 3. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)", "using 1"], ["proof (prove)\nusing this:\n  ultra_filter F\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)\n 2. \\<lbrakk>x \\<notin> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)\n 3. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)", "apply (metis (mono_tags, lifting) brouwer.inf_sup_ord(4) inf_top_left filter_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)\n 2. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)", "using 1"], ["proof (prove)\nusing this:\n  ultra_filter F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> F; y \\<in> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)\n 2. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)", "apply (metis (mono_tags, lifting) brouwer.inf_sup_ord(3) inf_top_right filter_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)", "using 1 filter_def"], ["proof (prove)\nusing this:\n  ultra_filter F\n  ord_class.filter ?F \\<equiv>\n  ?F \\<noteq> {} \\<and>\n  (\\<forall>x\\<in>?F.\n      \\<forall>y\\<in>?F.\n         \\<exists>z\\<in>?F. z \\<le> x \\<and> z \\<le> y) \\<and>\n  is_up_set ?F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> F; y \\<notin> F\\<rbrakk>\n    \\<Longrightarrow> (if x \\<sqinter> y \\<in> F then top else bot) =\n                      (if x \\<in> F then top else bot) \\<sqinter>\n                      (if y \\<in> F then top else bot)", "by force"], ["proof (state)\nthis:\n  (if x \\<sqinter> y \\<in> F then top else bot) =\n  (if x \\<in> F then top else bot) \\<sqinter>\n  (if y \\<in> F then top else bot)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y.\n     (if x \\<sqinter> y \\<in> F then top else bot) =\n     (if x \\<in> F then top else bot) \\<sqinter>\n     (if y \\<in> F then top else bot)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (((\\<forall>x y.\n        (if x \\<squnion> y \\<in> F then top else bot) =\n        (if x \\<in> F then top else bot) \\<squnion>\n        (if y \\<in> F then top else bot)) \\<and>\n    (\\<forall>x y.\n        (if x \\<sqinter> y \\<in> F then top else bot) =\n        (if x \\<in> F then top else bot) \\<sqinter>\n        (if y \\<in> F then top else bot))) \\<and>\n   (if top \\<in> F then top else bot) = top) \\<and>\n  bot_homomorphism (If (bot \\<in> F) top)\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. bounded_lattice_homomorphism f}", "hence \"?f \\<in> {f . bounded_lattice_homomorphism f}\""], ["proof (prove)\nusing this:\n  (((\\<forall>x y.\n        (if x \\<squnion> y \\<in> F then top else bot) =\n        (if x \\<in> F then top else bot) \\<squnion>\n        (if y \\<in> F then top else bot)) \\<and>\n    (\\<forall>x y.\n        (if x \\<sqinter> y \\<in> F then top else bot) =\n        (if x \\<in> F then top else bot) \\<sqinter>\n        (if y \\<in> F then top else bot))) \\<and>\n   (if top \\<in> F then top else bot) = top) \\<and>\n  bot_homomorphism (If (bot \\<in> F) top)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> F then top else bot)\n    \\<in> {f. bounded_lattice_homomorphism f}", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x. if x \\<in> F then top else bot)\n  \\<in> {f. bounded_lattice_homomorphism f}\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. bounded_lattice_homomorphism f}", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. if x \\<in> F then top else bot)\n  \\<in> {f. bounded_lattice_homomorphism f}\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. bounded_lattice_homomorphism f}", "by meson"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> {f. bounded_lattice_homomorphism f}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simp_phi [simp]:\n  \"bounded_lattice_homomorphism (Rep_phi x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_lattice_homomorphism (Rep_phi x)", "using Rep_phi"], ["proof (prove)\nusing this:\n  Rep_phi ?x \\<in> {f. bounded_lattice_homomorphism f}\n\ngoal (1 subgoal):\n 1. bounded_lattice_homomorphism (Rep_phi x)", "by simp"], ["", "setup_lifting type_definition_phi"], ["", "text \\<open>\nThe following implements the dependent type of pairs depending on structure maps.\nIt uses functions from structure maps to pairs with the requirement that, for each structure map, the corresponding pair is contained in the set of pairs constructed for a triple with that structure map.\n\nIf this type could be defined in the locale \\<open>triple\\<close> and instantiated to Stone algebras there, there would be no need for the lifting and we could work with triples directly.\n\\<close>"], ["", "typedef (overloaded) ('a,'b) lifted_pair = \"{ pf::('a::non_trivial_boolean_algebra,'b::distrib_lattice_top) phi \\<Rightarrow> 'a \\<times> 'b filter . \\<forall>f . pf f \\<in> triple.pairs (Rep_phi f) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {pf. \\<forall>f. pf f \\<in> triple.pairs (Rep_phi f)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {pf. \\<forall>f. pf f \\<in> triple.pairs (Rep_phi f)}", "have \"\\<forall>f::('a,'b) phi . triple.pairs_bot \\<in> triple.pairs (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       (bot, Filters.filter.Abs_filter UNIV) \\<in> triple.pairs (Rep_phi f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       (bot, Filters.filter.Abs_filter UNIV) \\<in> triple.pairs (Rep_phi f)", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       (bot, Filters.filter.Abs_filter UNIV) \\<in> triple.pairs (Rep_phi f)", "have \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       (bot, Filters.filter.Abs_filter UNIV) \\<in> triple.pairs (Rep_phi f)", "thus \"triple.pairs_bot \\<in> triple.pairs (Rep_phi f)\""], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. (bot, Filters.filter.Abs_filter UNIV) \\<in> triple.pairs (Rep_phi f)", "using triple.regular_pairs triple.phi_top"], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n  triple ?phi \\<Longrightarrow>\n  {(x, y).\n   (x, y) \\<in> triple.pairs ?phi \\<and>\n   triple.pairs_uminus ?phi (triple.pairs_uminus ?phi (x, y)) = (x, y)} =\n  {(x, y). y = ?phi (- x)}\n  triple ?phi \\<Longrightarrow> ?phi top = Filters.filter.Abs_filter UNIV\n\ngoal (1 subgoal):\n 1. (bot, Filters.filter.Abs_filter UNIV) \\<in> triple.pairs (Rep_phi f)", "by fastforce"], ["proof (state)\nthis:\n  (bot, Filters.filter.Abs_filter UNIV) \\<in> triple.pairs (Rep_phi f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>f.\n     (bot, Filters.filter.Abs_filter UNIV) \\<in> triple.pairs (Rep_phi f)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {pf. \\<forall>f. pf f \\<in> triple.pairs (Rep_phi f)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     (bot, Filters.filter.Abs_filter UNIV) \\<in> triple.pairs (Rep_phi f)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {pf. \\<forall>f. pf f \\<in> triple.pairs (Rep_phi f)}", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> {pf. \\<forall>f. pf f \\<in> triple.pairs (Rep_phi f)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simp_lifted_pair [simp]:\n  \"\\<forall>f . Rep_lifted_pair pf f \\<in> triple.pairs (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f. Rep_lifted_pair pf f \\<in> triple.pairs (Rep_phi f)", "using Rep_lifted_pair"], ["proof (prove)\nusing this:\n  Rep_lifted_pair ?x\n  \\<in> {pf. \\<forall>f. pf f \\<in> triple.pairs (Rep_phi f)}\n\ngoal (1 subgoal):\n 1. \\<forall>f. Rep_lifted_pair pf f \\<in> triple.pairs (Rep_phi f)", "by simp"], ["", "setup_lifting type_definition_lifted_pair"], ["", "text \\<open>\nThe lifted pairs form a Stone algebra.\n\\<close>"], ["", "instantiation lifted_pair :: (non_trivial_boolean_algebra,distrib_lattice_top) stone_algebra\nbegin"], ["", "text \\<open>\nAll operations are lifted point-wise.\n\\<close>"], ["", "lift_definition sup_lifted_pair :: \"('a,'b) lifted_pair \\<Rightarrow> ('a,'b) lifted_pair \\<Rightarrow> ('a,'b) lifted_pair\" is \"\\<lambda>xf yf f . triple.pairs_sup (xf f) (yf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 phi.\n       \\<lbrakk>\\<And>f. fun1 f \\<in> triple.pairs (Rep_phi f);\n        \\<And>f. fun2 f \\<in> triple.pairs (Rep_phi f)\\<rbrakk>\n       \\<Longrightarrow> triple.pairs_sup (fun1 phi) (fun2 phi)\n                         \\<in> triple.pairs (Rep_phi phi)", "by (metis (no_types, hide_lams) simp_phi triple_def triple.pairs_sup_closed prod.collapse)"], ["", "lift_definition inf_lifted_pair :: \"('a,'b) lifted_pair \\<Rightarrow> ('a,'b) lifted_pair \\<Rightarrow> ('a,'b) lifted_pair\" is \"\\<lambda>xf yf f . triple.pairs_inf (xf f) (yf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 phi.\n       \\<lbrakk>\\<And>f. fun1 f \\<in> triple.pairs (Rep_phi f);\n        \\<And>f. fun2 f \\<in> triple.pairs (Rep_phi f)\\<rbrakk>\n       \\<Longrightarrow> triple.pairs_inf (fun1 phi) (fun2 phi)\n                         \\<in> triple.pairs (Rep_phi phi)", "by (metis (no_types, hide_lams) simp_phi triple_def triple.pairs_inf_closed prod.collapse)"], ["", "lift_definition uminus_lifted_pair :: \"('a,'b) lifted_pair \\<Rightarrow> ('a,'b) lifted_pair\" is \"\\<lambda>xf f . triple.pairs_uminus (Rep_phi f) (xf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun phi.\n       (\\<And>f. fun f \\<in> triple.pairs (Rep_phi f)) \\<Longrightarrow>\n       triple.pairs_uminus (Rep_phi phi) (fun phi)\n       \\<in> triple.pairs (Rep_phi phi)", "by (metis (no_types, hide_lams) simp_phi triple_def triple.pairs_uminus_closed prod.collapse)"], ["", "lift_definition bot_lifted_pair :: \"('a,'b) lifted_pair\" is \"\\<lambda>f . triple.pairs_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>phi.\n       (bot, Filters.filter.Abs_filter UNIV)\n       \\<in> triple.pairs (Rep_phi phi)", "by (metis (no_types, hide_lams) simp_phi triple_def triple.pairs_bot_closed)"], ["", "lift_definition top_lifted_pair :: \"('a,'b) lifted_pair\" is \"\\<lambda>f . triple.pairs_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>phi.\n       (top, Filters.filter.Abs_filter {top})\n       \\<in> triple.pairs (Rep_phi phi)", "by (metis (no_types, hide_lams) simp_phi triple_def triple.pairs_top_closed)"], ["", "lift_definition less_eq_lifted_pair :: \"('a,'b) lifted_pair \\<Rightarrow> ('a,'b) lifted_pair \\<Rightarrow> bool\" is \"\\<lambda>xf yf . \\<forall>f . triple.pairs_less_eq (xf f) (yf f)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_lifted_pair :: \"('a,'b) lifted_pair \\<Rightarrow> ('a,'b) lifted_pair \\<Rightarrow> bool\" is \"\\<lambda>xf yf . (\\<forall>f . triple.pairs_less_eq (xf f) (yf f)) \\<and> \\<not> (\\<forall>f . triple.pairs_less_eq (yf f) (xf f))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) lifted_pair, stone_algebra_class)", "proof intro_classes"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 15 subgoals...", "fix xf yf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 15 subgoals...", "show \"xf < yf \\<longleftrightarrow> xf \\<le> yf \\<and> \\<not> yf \\<le> xf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xf < yf) = (xf \\<le> yf \\<and> \\<not> yf \\<le> xf)", "by (simp add: less_lifted_pair.rep_eq less_eq_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  (xf < yf) = (xf \\<le> yf \\<and> \\<not> yf \\<le> xf)\n\ngoal (14 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 14 subgoals...", "fix xf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 14 subgoals...", "{"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 14 subgoals...", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 14 subgoals...", "have 1: \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (14 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 14 subgoals...", "let ?x = \"Rep_lifted_pair xf f\""], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 14 subgoals...", "obtain x1 x2 where \"(x1,x2) = ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        (x1, x2) = Rep_lifted_pair xf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        (x1, x2) = Rep_lifted_pair xf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_lifted_pair xf f\n\ngoal (14 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 14 subgoals...", "hence \"triple.pairs_less_eq ?x ?x\""], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair xf f)", "using 1"], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair xf f)", "by (metis triple.pairs_less_eq.simps order_refl)"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair xf f)\n\ngoal (14 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 14 subgoals...", "}"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair xf ?f2) (Rep_lifted_pair xf ?f2)\n\ngoal (14 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 14 subgoals...", "thus \"xf \\<le> xf\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair xf ?f2) (Rep_lifted_pair xf ?f2)\n\ngoal (1 subgoal):\n 1. xf \\<le> xf", "by (simp add: less_eq_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  xf \\<le> xf\n\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "fix xf yf zf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "assume 1: \"xf \\<le> yf\" and 2: \"yf \\<le> zf\""], ["proof (state)\nthis:\n  xf \\<le> yf\n  yf \\<le> zf\n\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "{"], ["proof (state)\nthis:\n  xf \\<le> yf\n  yf \\<le> zf\n\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "have 3: \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "let ?x = \"Rep_lifted_pair xf f\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "let ?y = \"Rep_lifted_pair yf f\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "let ?z = \"Rep_lifted_pair zf f\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "obtain x1 x2 y1 y2 z1 z2 where 4: \"(x1,x2) = ?x \\<and> (y1,y2) = ?y \\<and> (z1,z2) = ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2 z1 z2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<and>\n        (z1, z2) = Rep_lifted_pair zf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2 z1 z2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<and>\n        (z1, z2) = Rep_lifted_pair zf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_lifted_pair xf f \\<and>\n  (y1, y2) = Rep_lifted_pair yf f \\<and> (z1, z2) = Rep_lifted_pair zf f\n\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "have \"triple.pairs_less_eq ?x ?y \\<and> triple.pairs_less_eq ?y ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f)\n     (Rep_lifted_pair yf f) \\<and>\n    triple.pairs_less_eq (Rep_lifted_pair yf f) (Rep_lifted_pair zf f)", "using 1 2 3 less_eq_lifted_pair.rep_eq"], ["proof (prove)\nusing this:\n  xf \\<le> yf\n  yf \\<le> zf\n  triple (Rep_phi f)\n  (?x \\<le> ?xa) =\n  (\\<forall>f.\n      triple.pairs_less_eq (Rep_lifted_pair ?x f) (Rep_lifted_pair ?xa f))\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f)\n     (Rep_lifted_pair yf f) \\<and>\n    triple.pairs_less_eq (Rep_lifted_pair yf f) (Rep_lifted_pair zf f)", "by simp"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair yf f) \\<and>\n  triple.pairs_less_eq (Rep_lifted_pair yf f) (Rep_lifted_pair zf f)\n\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "hence \"triple.pairs_less_eq ?x ?z\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair yf f) \\<and>\n  triple.pairs_less_eq (Rep_lifted_pair yf f) (Rep_lifted_pair zf f)\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair zf f)", "using 3 4"], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair yf f) \\<and>\n  triple.pairs_less_eq (Rep_lifted_pair yf f) (Rep_lifted_pair zf f)\n  triple (Rep_phi f)\n  (x1, x2) = Rep_lifted_pair xf f \\<and>\n  (y1, y2) = Rep_lifted_pair yf f \\<and> (z1, z2) = Rep_lifted_pair zf f\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair zf f)", "by (metis (mono_tags, lifting) triple.pairs_less_eq.simps order_trans)"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair zf f)\n\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "}"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair xf ?f2) (Rep_lifted_pair zf ?f2)\n\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "thus \"xf \\<le> zf\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair xf ?f2) (Rep_lifted_pair zf ?f2)\n\ngoal (1 subgoal):\n 1. xf \\<le> zf", "by (simp add: less_eq_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  xf \\<le> zf\n\ngoal (12 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 12 subgoals...", "fix xf yf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 12 subgoals...", "assume 1: \"xf \\<le> yf\" and 2: \"yf \\<le> xf\""], ["proof (state)\nthis:\n  xf \\<le> yf\n  yf \\<le> xf\n\ngoal (12 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 12 subgoals...", "{"], ["proof (state)\nthis:\n  xf \\<le> yf\n  yf \\<le> xf\n\ngoal (12 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 12 subgoals...", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 12 subgoals...", "have 3: \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (12 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 12 subgoals...", "let ?x = \"Rep_lifted_pair xf f\""], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 12 subgoals...", "let ?y = \"Rep_lifted_pair yf f\""], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 12 subgoals...", "obtain x1 x2 y1 y2 where 4: \"(x1,x2) = ?x \\<and> (y1,y2) = ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n\ngoal (12 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 12 subgoals...", "have \"triple.pairs_less_eq ?x ?y \\<and> triple.pairs_less_eq ?y ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f)\n     (Rep_lifted_pair yf f) \\<and>\n    triple.pairs_less_eq (Rep_lifted_pair yf f) (Rep_lifted_pair xf f)", "using 1 2 3 less_eq_lifted_pair.rep_eq"], ["proof (prove)\nusing this:\n  xf \\<le> yf\n  yf \\<le> xf\n  triple (Rep_phi f)\n  (?x \\<le> ?xa) =\n  (\\<forall>f.\n      triple.pairs_less_eq (Rep_lifted_pair ?x f) (Rep_lifted_pair ?xa f))\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f)\n     (Rep_lifted_pair yf f) \\<and>\n    triple.pairs_less_eq (Rep_lifted_pair yf f) (Rep_lifted_pair xf f)", "by simp"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair yf f) \\<and>\n  triple.pairs_less_eq (Rep_lifted_pair yf f) (Rep_lifted_pair xf f)\n\ngoal (12 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 12 subgoals...", "hence \"?x = ?y\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair yf f) \\<and>\n  triple.pairs_less_eq (Rep_lifted_pair yf f) (Rep_lifted_pair xf f)\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair xf f = Rep_lifted_pair yf f", "using 3 4"], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair yf f) \\<and>\n  triple.pairs_less_eq (Rep_lifted_pair yf f) (Rep_lifted_pair xf f)\n  triple (Rep_phi f)\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair xf f = Rep_lifted_pair yf f", "by (metis (mono_tags, lifting) triple.pairs_less_eq.simps antisym)"], ["proof (state)\nthis:\n  Rep_lifted_pair xf f = Rep_lifted_pair yf f\n\ngoal (12 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 12 subgoals...", "}"], ["proof (state)\nthis:\n  Rep_lifted_pair xf ?f2 = Rep_lifted_pair yf ?f2\n\ngoal (12 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 12 subgoals...", "thus \"xf = yf\""], ["proof (prove)\nusing this:\n  Rep_lifted_pair xf ?f2 = Rep_lifted_pair yf ?f2\n\ngoal (1 subgoal):\n 1. xf = yf", "by (metis Rep_lifted_pair_inverse ext)"], ["proof (state)\nthis:\n  xf = yf\n\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\nA total of 11 subgoals...", "fix xf yf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\nA total of 11 subgoals...", "{"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\nA total of 11 subgoals...", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\nA total of 11 subgoals...", "have 1: \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\nA total of 11 subgoals...", "let ?x = \"Rep_lifted_pair xf f\""], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\nA total of 11 subgoals...", "let ?y = \"Rep_lifted_pair yf f\""], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\nA total of 11 subgoals...", "obtain x1 x2 y1 y2 where \"(x1,x2) = ?x \\<and> (y1,y2) = ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\nA total of 11 subgoals...", "hence \"triple.pairs_less_eq (triple.pairs_inf ?x ?y) ?y\""], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq\n     (triple.pairs_inf (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))\n     (Rep_lifted_pair yf f)", "using 1"], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq\n     (triple.pairs_inf (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))\n     (Rep_lifted_pair yf f)", "by (metis (mono_tags, lifting) inf_sup_ord(2) sup.cobounded2 triple.pairs_inf.simps triple.pairs_less_eq.simps inf_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  triple.pairs_less_eq\n   (triple.pairs_inf (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))\n   (Rep_lifted_pair yf f)\n\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\nA total of 11 subgoals...", "}"], ["proof (state)\nthis:\n  triple.pairs_less_eq\n   (triple.pairs_inf (Rep_lifted_pair xf ?f2) (Rep_lifted_pair yf ?f2))\n   (Rep_lifted_pair yf ?f2)\n\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\nA total of 11 subgoals...", "thus \"xf \\<sqinter> yf \\<le> yf\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq\n   (triple.pairs_inf (Rep_lifted_pair xf ?f2) (Rep_lifted_pair yf ?f2))\n   (Rep_lifted_pair yf ?f2)\n\ngoal (1 subgoal):\n 1. xf \\<sqinter> yf \\<le> yf", "by (simp add: less_eq_lifted_pair.rep_eq inf_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  xf \\<sqinter> yf \\<le> yf\n\ngoal (10 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 10. \\<And>x. - x \\<squnion> - - x = top", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 10. \\<And>x. - x \\<squnion> - - x = top", "fix xf yf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 10. \\<And>x. - x \\<squnion> - - x = top", "{"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 10. \\<And>x. - x \\<squnion> - - x = top", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 10. \\<And>x. - x \\<squnion> - - x = top", "have 1: \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (10 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 10. \\<And>x. - x \\<squnion> - - x = top", "let ?x = \"Rep_lifted_pair xf f\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 10. \\<And>x. - x \\<squnion> - - x = top", "let ?y = \"Rep_lifted_pair yf f\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 10. \\<And>x. - x \\<squnion> - - x = top", "obtain x1 x2 y1 y2 where \"(x1,x2) = ?x \\<and> (y1,y2) = ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n\ngoal (10 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 10. \\<And>x. - x \\<squnion> - - x = top", "hence \"triple.pairs_less_eq (triple.pairs_inf ?x ?y) ?x\""], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq\n     (triple.pairs_inf (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))\n     (Rep_lifted_pair xf f)", "using 1"], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq\n     (triple.pairs_inf (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))\n     (Rep_lifted_pair xf f)", "by (metis (mono_tags, lifting) inf_sup_ord(1) sup.cobounded1 triple.pairs_inf.simps triple.pairs_less_eq.simps inf_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  triple.pairs_less_eq\n   (triple.pairs_inf (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))\n   (Rep_lifted_pair xf f)\n\ngoal (10 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 10. \\<And>x. - x \\<squnion> - - x = top", "}"], ["proof (state)\nthis:\n  triple.pairs_less_eq\n   (triple.pairs_inf (Rep_lifted_pair xf ?f2) (Rep_lifted_pair yf ?f2))\n   (Rep_lifted_pair xf ?f2)\n\ngoal (10 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 10. \\<And>x. - x \\<squnion> - - x = top", "thus \"xf \\<sqinter> yf \\<le> xf\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq\n   (triple.pairs_inf (Rep_lifted_pair xf ?f2) (Rep_lifted_pair yf ?f2))\n   (Rep_lifted_pair xf ?f2)\n\ngoal (1 subgoal):\n 1. xf \\<sqinter> yf \\<le> xf", "by (simp add: less_eq_lifted_pair.rep_eq inf_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  xf \\<sqinter> yf \\<le> xf\n\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "fix xf yf zf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "assume 1: \"xf \\<le> yf\" and 2: \"xf \\<le> zf\""], ["proof (state)\nthis:\n  xf \\<le> yf\n  xf \\<le> zf\n\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "{"], ["proof (state)\nthis:\n  xf \\<le> yf\n  xf \\<le> zf\n\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "have 3: \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "let ?x = \"Rep_lifted_pair xf f\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "let ?y = \"Rep_lifted_pair yf f\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "let ?z = \"Rep_lifted_pair zf f\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "obtain x1 x2 y1 y2 z1 z2 where 4: \"(x1,x2) = ?x \\<and> (y1,y2) = ?y \\<and> (z1,z2) = ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2 z1 z2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<and>\n        (z1, z2) = Rep_lifted_pair zf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2 z1 z2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<and>\n        (z1, z2) = Rep_lifted_pair zf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_lifted_pair xf f \\<and>\n  (y1, y2) = Rep_lifted_pair yf f \\<and> (z1, z2) = Rep_lifted_pair zf f\n\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "have \"triple.pairs_less_eq ?x ?y \\<and> triple.pairs_less_eq ?x ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f)\n     (Rep_lifted_pair yf f) \\<and>\n    triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair zf f)", "using 1 2 3 less_eq_lifted_pair.rep_eq"], ["proof (prove)\nusing this:\n  xf \\<le> yf\n  xf \\<le> zf\n  triple (Rep_phi f)\n  (?x \\<le> ?xa) =\n  (\\<forall>f.\n      triple.pairs_less_eq (Rep_lifted_pair ?x f) (Rep_lifted_pair ?xa f))\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f)\n     (Rep_lifted_pair yf f) \\<and>\n    triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair zf f)", "by simp"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair yf f) \\<and>\n  triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair zf f)\n\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "hence \"triple.pairs_less_eq ?x (triple.pairs_inf ?y ?z)\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair yf f) \\<and>\n  triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair zf f)\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f)\n     (triple.pairs_inf (Rep_lifted_pair yf f) (Rep_lifted_pair zf f))", "using 3 4"], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair yf f) \\<and>\n  triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair zf f)\n  triple (Rep_phi f)\n  (x1, x2) = Rep_lifted_pair xf f \\<and>\n  (y1, y2) = Rep_lifted_pair yf f \\<and> (z1, z2) = Rep_lifted_pair zf f\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f)\n     (triple.pairs_inf (Rep_lifted_pair yf f) (Rep_lifted_pair zf f))", "by (metis (mono_tags, lifting) le_inf_iff sup.bounded_iff triple.pairs_inf.simps triple.pairs_less_eq.simps)"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair xf f)\n   (triple.pairs_inf (Rep_lifted_pair yf f) (Rep_lifted_pair zf f))\n\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "}"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair xf ?f2)\n   (triple.pairs_inf (Rep_lifted_pair yf ?f2) (Rep_lifted_pair zf ?f2))\n\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "thus \"xf \\<le> yf \\<sqinter> zf\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair xf ?f2)\n   (triple.pairs_inf (Rep_lifted_pair yf ?f2) (Rep_lifted_pair zf ?f2))\n\ngoal (1 subgoal):\n 1. xf \\<le> yf \\<sqinter> zf", "by (simp add: less_eq_lifted_pair.rep_eq inf_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  xf \\<le> yf \\<sqinter> zf\n\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 8. \\<And>x. - x \\<squnion> - - x = top", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 8. \\<And>x. - x \\<squnion> - - x = top", "fix xf yf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 8. \\<And>x. - x \\<squnion> - - x = top", "{"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 8. \\<And>x. - x \\<squnion> - - x = top", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 8. \\<And>x. - x \\<squnion> - - x = top", "have 1: \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 8. \\<And>x. - x \\<squnion> - - x = top", "let ?x = \"Rep_lifted_pair xf f\""], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 8. \\<And>x. - x \\<squnion> - - x = top", "let ?y = \"Rep_lifted_pair yf f\""], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 8. \\<And>x. - x \\<squnion> - - x = top", "obtain x1 x2 y1 y2 where \"(x1,x2) = ?x \\<and> (y1,y2) = ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 8. \\<And>x. - x \\<squnion> - - x = top", "hence \"triple.pairs_less_eq ?x (triple.pairs_sup ?x ?y)\""], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f)\n     (triple.pairs_sup (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))", "using 1"], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f)\n     (triple.pairs_sup (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))", "by (metis (no_types, lifting) inf_commute sup.cobounded1 inf.cobounded2 triple.pairs_sup.simps triple.pairs_less_eq.simps sup_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair xf f)\n   (triple.pairs_sup (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))\n\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 8. \\<And>x. - x \\<squnion> - - x = top", "}"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair xf ?f2)\n   (triple.pairs_sup (Rep_lifted_pair xf ?f2) (Rep_lifted_pair yf ?f2))\n\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 8. \\<And>x. - x \\<squnion> - - x = top", "thus \"xf \\<le> xf \\<squnion> yf\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair xf ?f2)\n   (triple.pairs_sup (Rep_lifted_pair xf ?f2) (Rep_lifted_pair yf ?f2))\n\ngoal (1 subgoal):\n 1. xf \\<le> xf \\<squnion> yf", "by (simp add: less_eq_lifted_pair.rep_eq sup_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  xf \\<le> xf \\<squnion> yf\n\ngoal (7 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 7. \\<And>x. - x \\<squnion> - - x = top", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 7. \\<And>x. - x \\<squnion> - - x = top", "fix xf yf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 7. \\<And>x. - x \\<squnion> - - x = top", "{"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 7. \\<And>x. - x \\<squnion> - - x = top", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 7. \\<And>x. - x \\<squnion> - - x = top", "have 1: \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (7 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 7. \\<And>x. - x \\<squnion> - - x = top", "let ?x = \"Rep_lifted_pair xf f\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 7. \\<And>x. - x \\<squnion> - - x = top", "let ?y = \"Rep_lifted_pair yf f\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 7. \\<And>x. - x \\<squnion> - - x = top", "obtain x1 x2 y1 y2 where \"(x1,x2) = ?x \\<and> (y1,y2) = ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n\ngoal (7 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 7. \\<And>x. - x \\<squnion> - - x = top", "hence \"triple.pairs_less_eq ?y (triple.pairs_sup ?x ?y)\""], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair yf f)\n     (triple.pairs_sup (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))", "using 1"], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair yf f)\n     (triple.pairs_sup (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))", "by (metis (no_types, lifting) sup.cobounded2 inf.cobounded2 triple.pairs_sup.simps triple.pairs_less_eq.simps sup_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair yf f)\n   (triple.pairs_sup (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))\n\ngoal (7 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 7. \\<And>x. - x \\<squnion> - - x = top", "}"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair yf ?f2)\n   (triple.pairs_sup (Rep_lifted_pair xf ?f2) (Rep_lifted_pair yf ?f2))\n\ngoal (7 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 7. \\<And>x. - x \\<squnion> - - x = top", "thus \"yf \\<le> xf \\<squnion> yf\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair yf ?f2)\n   (triple.pairs_sup (Rep_lifted_pair xf ?f2) (Rep_lifted_pair yf ?f2))\n\ngoal (1 subgoal):\n 1. yf \\<le> xf \\<squnion> yf", "by (simp add: less_eq_lifted_pair.rep_eq sup_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  yf \\<le> xf \\<squnion> yf\n\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "fix xf yf zf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "assume 1: \"yf \\<le> xf\" and 2: \"zf \\<le> xf\""], ["proof (state)\nthis:\n  yf \\<le> xf\n  zf \\<le> xf\n\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "{"], ["proof (state)\nthis:\n  yf \\<le> xf\n  zf \\<le> xf\n\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "have 3: \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "let ?x = \"Rep_lifted_pair xf f\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "let ?y = \"Rep_lifted_pair yf f\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "let ?z = \"Rep_lifted_pair zf f\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "obtain x1 x2 y1 y2 z1 z2 where 4: \"(x1,x2) = ?x \\<and> (y1,y2) = ?y \\<and> (z1,z2) = ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2 z1 z2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<and>\n        (z1, z2) = Rep_lifted_pair zf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2 z1 z2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<and>\n        (z1, z2) = Rep_lifted_pair zf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_lifted_pair xf f \\<and>\n  (y1, y2) = Rep_lifted_pair yf f \\<and> (z1, z2) = Rep_lifted_pair zf f\n\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "have \"triple.pairs_less_eq ?y ?x \\<and> triple.pairs_less_eq ?z ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair yf f)\n     (Rep_lifted_pair xf f) \\<and>\n    triple.pairs_less_eq (Rep_lifted_pair zf f) (Rep_lifted_pair xf f)", "using 1 2 3 less_eq_lifted_pair.rep_eq"], ["proof (prove)\nusing this:\n  yf \\<le> xf\n  zf \\<le> xf\n  triple (Rep_phi f)\n  (?x \\<le> ?xa) =\n  (\\<forall>f.\n      triple.pairs_less_eq (Rep_lifted_pair ?x f) (Rep_lifted_pair ?xa f))\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair yf f)\n     (Rep_lifted_pair xf f) \\<and>\n    triple.pairs_less_eq (Rep_lifted_pair zf f) (Rep_lifted_pair xf f)", "by simp"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair yf f) (Rep_lifted_pair xf f) \\<and>\n  triple.pairs_less_eq (Rep_lifted_pair zf f) (Rep_lifted_pair xf f)\n\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "hence \"triple.pairs_less_eq (triple.pairs_sup ?y ?z) ?x\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair yf f) (Rep_lifted_pair xf f) \\<and>\n  triple.pairs_less_eq (Rep_lifted_pair zf f) (Rep_lifted_pair xf f)\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq\n     (triple.pairs_sup (Rep_lifted_pair yf f) (Rep_lifted_pair zf f))\n     (Rep_lifted_pair xf f)", "using 3 4"], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair yf f) (Rep_lifted_pair xf f) \\<and>\n  triple.pairs_less_eq (Rep_lifted_pair zf f) (Rep_lifted_pair xf f)\n  triple (Rep_phi f)\n  (x1, x2) = Rep_lifted_pair xf f \\<and>\n  (y1, y2) = Rep_lifted_pair yf f \\<and> (z1, z2) = Rep_lifted_pair zf f\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq\n     (triple.pairs_sup (Rep_lifted_pair yf f) (Rep_lifted_pair zf f))\n     (Rep_lifted_pair xf f)", "by (metis (mono_tags, lifting) le_inf_iff sup.bounded_iff triple.pairs_sup.simps triple.pairs_less_eq.simps)"], ["proof (state)\nthis:\n  triple.pairs_less_eq\n   (triple.pairs_sup (Rep_lifted_pair yf f) (Rep_lifted_pair zf f))\n   (Rep_lifted_pair xf f)\n\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "}"], ["proof (state)\nthis:\n  triple.pairs_less_eq\n   (triple.pairs_sup (Rep_lifted_pair yf ?f2) (Rep_lifted_pair zf ?f2))\n   (Rep_lifted_pair xf ?f2)\n\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "thus \"yf \\<squnion> zf \\<le> xf\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq\n   (triple.pairs_sup (Rep_lifted_pair yf ?f2) (Rep_lifted_pair zf ?f2))\n   (Rep_lifted_pair xf ?f2)\n\ngoal (1 subgoal):\n 1. yf \\<squnion> zf \\<le> xf", "by (simp add: less_eq_lifted_pair.rep_eq sup_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  yf \\<squnion> zf \\<le> xf\n\ngoal (5 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 5. \\<And>x. - x \\<squnion> - - x = top", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 5. \\<And>x. - x \\<squnion> - - x = top", "fix xf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 5. \\<And>x. - x \\<squnion> - - x = top", "{"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 5. \\<And>x. - x \\<squnion> - - x = top", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 5. \\<And>x. - x \\<squnion> - - x = top", "have 1: \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (5 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 5. \\<And>x. - x \\<squnion> - - x = top", "let ?x = \"Rep_lifted_pair xf f\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 5. \\<And>x. - x \\<squnion> - - x = top", "obtain x1 x2 where \"(x1,x2) = ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        (x1, x2) = Rep_lifted_pair xf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        (x1, x2) = Rep_lifted_pair xf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_lifted_pair xf f\n\ngoal (5 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 5. \\<And>x. - x \\<squnion> - - x = top", "hence \"triple.pairs_less_eq triple.pairs_bot ?x\""], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (bot, Filters.filter.Abs_filter UNIV)\n     (Rep_lifted_pair xf f)", "using 1"], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (bot, Filters.filter.Abs_filter UNIV)\n     (Rep_lifted_pair xf f)", "by (metis bot.extremum top_greatest top_filter.abs_eq triple.pairs_less_eq.simps)"], ["proof (state)\nthis:\n  triple.pairs_less_eq (bot, Filters.filter.Abs_filter UNIV)\n   (Rep_lifted_pair xf f)\n\ngoal (5 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 5. \\<And>x. - x \\<squnion> - - x = top", "}"], ["proof (state)\nthis:\n  triple.pairs_less_eq (bot, Filters.filter.Abs_filter UNIV)\n   (Rep_lifted_pair xf ?f2)\n\ngoal (5 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 5. \\<And>x. - x \\<squnion> - - x = top", "thus \"bot \\<le> xf\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (bot, Filters.filter.Abs_filter UNIV)\n   (Rep_lifted_pair xf ?f2)\n\ngoal (1 subgoal):\n 1. bot \\<le> xf", "by (simp add: less_eq_lifted_pair.rep_eq bot_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  bot \\<le> xf\n\ngoal (4 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 4. \\<And>x. - x \\<squnion> - - x = top", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 4. \\<And>x. - x \\<squnion> - - x = top", "fix xf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 4. \\<And>x. - x \\<squnion> - - x = top", "{"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 4. \\<And>x. - x \\<squnion> - - x = top", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 4. \\<And>x. - x \\<squnion> - - x = top", "have 1: \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (4 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 4. \\<And>x. - x \\<squnion> - - x = top", "let ?x = \"Rep_lifted_pair xf f\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 4. \\<And>x. - x \\<squnion> - - x = top", "obtain x1 x2 where \"(x1,x2) = ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        (x1, x2) = Rep_lifted_pair xf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        (x1, x2) = Rep_lifted_pair xf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_lifted_pair xf f\n\ngoal (4 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 4. \\<And>x. - x \\<squnion> - - x = top", "hence \"triple.pairs_less_eq ?x triple.pairs_top\""], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f)\n     (top, Filters.filter.Abs_filter {top})", "using 1"], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair xf f)\n     (top, Filters.filter.Abs_filter {top})", "by (metis top.extremum bot_least bot_filter.abs_eq triple.pairs_less_eq.simps)"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair xf f)\n   (top, Filters.filter.Abs_filter {top})\n\ngoal (4 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 4. \\<And>x. - x \\<squnion> - - x = top", "}"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair xf ?f2)\n   (top, Filters.filter.Abs_filter {top})\n\ngoal (4 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 4. \\<And>x. - x \\<squnion> - - x = top", "thus \"xf \\<le> top\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair xf ?f2)\n   (top, Filters.filter.Abs_filter {top})\n\ngoal (1 subgoal):\n 1. xf \\<le> top", "by (simp add: less_eq_lifted_pair.rep_eq top_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  xf \\<le> top\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "fix xf yf zf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "have 1: \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "let ?x = \"Rep_lifted_pair xf f\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "let ?y = \"Rep_lifted_pair yf f\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "let ?z = \"Rep_lifted_pair zf f\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "obtain x1 x2 y1 y2 z1 z2 where \"(x1,x2) = ?x \\<and> (y1,y2) = ?y \\<and> (z1,z2) = ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2 z1 z2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<and>\n        (z1, z2) = Rep_lifted_pair zf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2 z1 z2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<and>\n        (z1, z2) = Rep_lifted_pair zf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_lifted_pair xf f \\<and>\n  (y1, y2) = Rep_lifted_pair yf f \\<and> (z1, z2) = Rep_lifted_pair zf f\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "hence \"triple.pairs_sup ?x (triple.pairs_inf ?y ?z) = triple.pairs_inf (triple.pairs_sup ?x ?y) (triple.pairs_sup ?x ?z)\""], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f \\<and>\n  (y1, y2) = Rep_lifted_pair yf f \\<and> (z1, z2) = Rep_lifted_pair zf f\n\ngoal (1 subgoal):\n 1. triple.pairs_sup (Rep_lifted_pair xf f)\n     (triple.pairs_inf (Rep_lifted_pair yf f) (Rep_lifted_pair zf f)) =\n    triple.pairs_inf\n     (triple.pairs_sup (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))\n     (triple.pairs_sup (Rep_lifted_pair xf f) (Rep_lifted_pair zf f))", "using 1"], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f \\<and>\n  (y1, y2) = Rep_lifted_pair yf f \\<and> (z1, z2) = Rep_lifted_pair zf f\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. triple.pairs_sup (Rep_lifted_pair xf f)\n     (triple.pairs_inf (Rep_lifted_pair yf f) (Rep_lifted_pair zf f)) =\n    triple.pairs_inf\n     (triple.pairs_sup (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))\n     (triple.pairs_sup (Rep_lifted_pair xf f) (Rep_lifted_pair zf f))", "by (metis (no_types) sup_inf_distrib1 inf_sup_distrib1 triple.pairs_sup.simps triple.pairs_inf.simps)"], ["proof (state)\nthis:\n  triple.pairs_sup (Rep_lifted_pair xf f)\n   (triple.pairs_inf (Rep_lifted_pair yf f) (Rep_lifted_pair zf f)) =\n  triple.pairs_inf\n   (triple.pairs_sup (Rep_lifted_pair xf f) (Rep_lifted_pair yf f))\n   (triple.pairs_sup (Rep_lifted_pair xf f) (Rep_lifted_pair zf f))\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "}"], ["proof (state)\nthis:\n  triple.pairs_sup (Rep_lifted_pair xf ?f2)\n   (triple.pairs_inf (Rep_lifted_pair yf ?f2) (Rep_lifted_pair zf ?f2)) =\n  triple.pairs_inf\n   (triple.pairs_sup (Rep_lifted_pair xf ?f2) (Rep_lifted_pair yf ?f2))\n   (triple.pairs_sup (Rep_lifted_pair xf ?f2) (Rep_lifted_pair zf ?f2))\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "thus \"xf \\<squnion> (yf \\<sqinter> zf) = (xf \\<squnion> yf) \\<sqinter> (xf \\<squnion> zf)\""], ["proof (prove)\nusing this:\n  triple.pairs_sup (Rep_lifted_pair xf ?f2)\n   (triple.pairs_inf (Rep_lifted_pair yf ?f2) (Rep_lifted_pair zf ?f2)) =\n  triple.pairs_inf\n   (triple.pairs_sup (Rep_lifted_pair xf ?f2) (Rep_lifted_pair yf ?f2))\n   (triple.pairs_sup (Rep_lifted_pair xf ?f2) (Rep_lifted_pair zf ?f2))\n\ngoal (1 subgoal):\n 1. xf \\<squnion> yf \\<sqinter> zf =\n    (xf \\<squnion> yf) \\<sqinter> (xf \\<squnion> zf)", "by (metis Rep_lifted_pair_inverse ext sup_lifted_pair.rep_eq inf_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  xf \\<squnion> yf \\<sqinter> zf =\n  (xf \\<squnion> yf) \\<sqinter> (xf \\<squnion> zf)\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "fix xf yf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "have 1: \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "let ?x = \"Rep_lifted_pair xf f\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "let ?y = \"Rep_lifted_pair yf f\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "obtain x1 x2 y1 y2 where 2: \"(x1,x2) = ?x \\<and> (y1,y2) = ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_lifted_pair xf f \\<and>\n        (y1, y2) = Rep_lifted_pair yf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "have \"?x \\<in> triple.pairs (Rep_phi f) \\<and> ?y \\<in> triple.pairs (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_lifted_pair xf f \\<in> triple.pairs (Rep_phi f) \\<and>\n    Rep_lifted_pair yf f \\<in> triple.pairs (Rep_phi f)", "by simp"], ["proof (state)\nthis:\n  Rep_lifted_pair xf f \\<in> triple.pairs (Rep_phi f) \\<and>\n  Rep_lifted_pair yf f \\<in> triple.pairs (Rep_phi f)\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "hence \"(triple.pairs_inf ?x ?y = triple.pairs_bot) \\<longleftrightarrow> triple.pairs_less_eq ?x (triple.pairs_uminus (Rep_phi f) ?y)\""], ["proof (prove)\nusing this:\n  Rep_lifted_pair xf f \\<in> triple.pairs (Rep_phi f) \\<and>\n  Rep_lifted_pair yf f \\<in> triple.pairs (Rep_phi f)\n\ngoal (1 subgoal):\n 1. (triple.pairs_inf (Rep_lifted_pair xf f) (Rep_lifted_pair yf f) =\n     (bot, Filters.filter.Abs_filter UNIV)) =\n    triple.pairs_less_eq (Rep_lifted_pair xf f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_lifted_pair yf f))", "using 1 2"], ["proof (prove)\nusing this:\n  Rep_lifted_pair xf f \\<in> triple.pairs (Rep_phi f) \\<and>\n  Rep_lifted_pair yf f \\<in> triple.pairs (Rep_phi f)\n  triple (Rep_phi f)\n  (x1, x2) = Rep_lifted_pair xf f \\<and> (y1, y2) = Rep_lifted_pair yf f\n\ngoal (1 subgoal):\n 1. (triple.pairs_inf (Rep_lifted_pair xf f) (Rep_lifted_pair yf f) =\n     (bot, Filters.filter.Abs_filter UNIV)) =\n    triple.pairs_less_eq (Rep_lifted_pair xf f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_lifted_pair yf f))", "by (metis triple.pairs_uminus_galois)"], ["proof (state)\nthis:\n  (triple.pairs_inf (Rep_lifted_pair xf f) (Rep_lifted_pair yf f) =\n   (bot, Filters.filter.Abs_filter UNIV)) =\n  triple.pairs_less_eq (Rep_lifted_pair xf f)\n   (triple.pairs_uminus (Rep_phi f) (Rep_lifted_pair yf f))\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "}"], ["proof (state)\nthis:\n  (triple.pairs_inf (Rep_lifted_pair xf ?f2) (Rep_lifted_pair yf ?f2) =\n   (bot, Filters.filter.Abs_filter UNIV)) =\n  triple.pairs_less_eq (Rep_lifted_pair xf ?f2)\n   (triple.pairs_uminus (Rep_phi ?f2) (Rep_lifted_pair yf ?f2))\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "hence \"\\<forall>f . (Rep_lifted_pair (xf \\<sqinter> yf) f = Rep_lifted_pair bot f) \\<longleftrightarrow> triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair (-yf) f)\""], ["proof (prove)\nusing this:\n  (triple.pairs_inf (Rep_lifted_pair xf ?f2) (Rep_lifted_pair yf ?f2) =\n   (bot, Filters.filter.Abs_filter UNIV)) =\n  triple.pairs_less_eq (Rep_lifted_pair xf ?f2)\n   (triple.pairs_uminus (Rep_phi ?f2) (Rep_lifted_pair yf ?f2))\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       (Rep_lifted_pair (xf \\<sqinter> yf) f = Rep_lifted_pair bot f) =\n       triple.pairs_less_eq (Rep_lifted_pair xf f)\n        (Rep_lifted_pair (- yf) f)", "using bot_lifted_pair.rep_eq inf_lifted_pair.rep_eq uminus_lifted_pair.rep_eq"], ["proof (prove)\nusing this:\n  (triple.pairs_inf (Rep_lifted_pair xf ?f2) (Rep_lifted_pair yf ?f2) =\n   (bot, Filters.filter.Abs_filter UNIV)) =\n  triple.pairs_less_eq (Rep_lifted_pair xf ?f2)\n   (triple.pairs_uminus (Rep_phi ?f2) (Rep_lifted_pair yf ?f2))\n  Rep_lifted_pair bot = (\\<lambda>f. (bot, Filters.filter.Abs_filter UNIV))\n  Rep_lifted_pair (?x \\<sqinter> ?xa) =\n  (\\<lambda>f.\n      triple.pairs_inf (Rep_lifted_pair ?x f) (Rep_lifted_pair ?xa f))\n  Rep_lifted_pair (- ?x) =\n  (\\<lambda>f. triple.pairs_uminus (Rep_phi f) (Rep_lifted_pair ?x f))\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       (Rep_lifted_pair (xf \\<sqinter> yf) f = Rep_lifted_pair bot f) =\n       triple.pairs_less_eq (Rep_lifted_pair xf f)\n        (Rep_lifted_pair (- yf) f)", "by simp"], ["proof (state)\nthis:\n  \\<forall>f.\n     (Rep_lifted_pair (xf \\<sqinter> yf) f = Rep_lifted_pair bot f) =\n     triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair (- yf) f)\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "hence \"(Rep_lifted_pair (xf \\<sqinter> yf) = Rep_lifted_pair bot) \\<longleftrightarrow> xf \\<le> -yf\""], ["proof (prove)\nusing this:\n  \\<forall>f.\n     (Rep_lifted_pair (xf \\<sqinter> yf) f = Rep_lifted_pair bot f) =\n     triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair (- yf) f)\n\ngoal (1 subgoal):\n 1. (Rep_lifted_pair (xf \\<sqinter> yf) = Rep_lifted_pair bot) =\n    (xf \\<le> - yf)", "using less_eq_lifted_pair.rep_eq"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     (Rep_lifted_pair (xf \\<sqinter> yf) f = Rep_lifted_pair bot f) =\n     triple.pairs_less_eq (Rep_lifted_pair xf f) (Rep_lifted_pair (- yf) f)\n  (?x \\<le> ?xa) =\n  (\\<forall>f.\n      triple.pairs_less_eq (Rep_lifted_pair ?x f) (Rep_lifted_pair ?xa f))\n\ngoal (1 subgoal):\n 1. (Rep_lifted_pair (xf \\<sqinter> yf) = Rep_lifted_pair bot) =\n    (xf \\<le> - yf)", "by auto"], ["proof (state)\nthis:\n  (Rep_lifted_pair (xf \\<sqinter> yf) = Rep_lifted_pair bot) =\n  (xf \\<le> - yf)\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "thus \"(xf \\<sqinter> yf = bot) \\<longleftrightarrow> (xf \\<le> -yf)\""], ["proof (prove)\nusing this:\n  (Rep_lifted_pair (xf \\<sqinter> yf) = Rep_lifted_pair bot) =\n  (xf \\<le> - yf)\n\ngoal (1 subgoal):\n 1. (xf \\<sqinter> yf = bot) = (xf \\<le> - yf)", "by (simp add: Rep_lifted_pair_inject)"], ["proof (state)\nthis:\n  (xf \\<sqinter> yf = bot) = (xf \\<le> - yf)\n\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "fix xf :: \"('a,'b) lifted_pair\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "have 1: \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "let ?x = \"Rep_lifted_pair xf f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "obtain x1 x2 where \"(x1,x2) = ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        (x1, x2) = Rep_lifted_pair xf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        (x1, x2) = Rep_lifted_pair xf f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_lifted_pair xf f\n\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "hence \"triple.pairs_sup (triple.pairs_uminus (Rep_phi f) ?x) (triple.pairs_uminus (Rep_phi f) (triple.pairs_uminus (Rep_phi f) ?x)) = triple.pairs_top\""], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f\n\ngoal (1 subgoal):\n 1. triple.pairs_sup\n     (triple.pairs_uminus (Rep_phi f) (Rep_lifted_pair xf f))\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_lifted_pair xf f))) =\n    (top, Filters.filter.Abs_filter {top})", "using 1"], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_lifted_pair xf f\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. triple.pairs_sup\n     (triple.pairs_uminus (Rep_phi f) (Rep_lifted_pair xf f))\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_lifted_pair xf f))) =\n    (top, Filters.filter.Abs_filter {top})", "by (metis simp_lifted_pair triple.pairs_stone)"], ["proof (state)\nthis:\n  triple.pairs_sup (triple.pairs_uminus (Rep_phi f) (Rep_lifted_pair xf f))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_lifted_pair xf f))) =\n  (top, Filters.filter.Abs_filter {top})\n\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "}"], ["proof (state)\nthis:\n  triple.pairs_sup\n   (triple.pairs_uminus (Rep_phi ?f2) (Rep_lifted_pair xf ?f2))\n   (triple.pairs_uminus (Rep_phi ?f2)\n     (triple.pairs_uminus (Rep_phi ?f2) (Rep_lifted_pair xf ?f2))) =\n  (top, Filters.filter.Abs_filter {top})\n\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "hence \"Rep_lifted_pair (-xf \\<squnion> --xf) = Rep_lifted_pair top\""], ["proof (prove)\nusing this:\n  triple.pairs_sup\n   (triple.pairs_uminus (Rep_phi ?f2) (Rep_lifted_pair xf ?f2))\n   (triple.pairs_uminus (Rep_phi ?f2)\n     (triple.pairs_uminus (Rep_phi ?f2) (Rep_lifted_pair xf ?f2))) =\n  (top, Filters.filter.Abs_filter {top})\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair (- xf \\<squnion> - - xf) = Rep_lifted_pair top", "using sup_lifted_pair.rep_eq uminus_lifted_pair.rep_eq top_lifted_pair.rep_eq"], ["proof (prove)\nusing this:\n  triple.pairs_sup\n   (triple.pairs_uminus (Rep_phi ?f2) (Rep_lifted_pair xf ?f2))\n   (triple.pairs_uminus (Rep_phi ?f2)\n     (triple.pairs_uminus (Rep_phi ?f2) (Rep_lifted_pair xf ?f2))) =\n  (top, Filters.filter.Abs_filter {top})\n  Rep_lifted_pair (?x \\<squnion> ?xa) =\n  (\\<lambda>f.\n      triple.pairs_sup (Rep_lifted_pair ?x f) (Rep_lifted_pair ?xa f))\n  Rep_lifted_pair (- ?x) =\n  (\\<lambda>f. triple.pairs_uminus (Rep_phi f) (Rep_lifted_pair ?x f))\n  Rep_lifted_pair top = (\\<lambda>f. (top, Filters.filter.Abs_filter {top}))\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair (- xf \\<squnion> - - xf) = Rep_lifted_pair top", "by simp"], ["proof (state)\nthis:\n  Rep_lifted_pair (- xf \\<squnion> - - xf) = Rep_lifted_pair top\n\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "thus \"-xf \\<squnion> --xf = top\""], ["proof (prove)\nusing this:\n  Rep_lifted_pair (- xf \\<squnion> - - xf) = Rep_lifted_pair top\n\ngoal (1 subgoal):\n 1. - xf \\<squnion> - - xf = top", "by (simp add: Rep_lifted_pair_inject)"], ["proof (state)\nthis:\n  - xf \\<squnion> - - xf = top\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>The Stone Algebra of the Triple of a Stone Algebra\\<close>"], ["", "text \\<open>\nIn this section we specialise the above construction to a particular structure map, namely the one obtained in the triple of a Stone algebra.\nFor this particular structure map (as well as for any other particular structure map) the resulting type is no longer a dependent type.\nIt is just the set of pairs obtained for the given structure map.\n\\<close>"], ["", "typedef (overloaded) 'a stone_phi_pair = \"triple.pairs (stone_phi::'a::stone_algebra regular \\<Rightarrow> 'a dense_filter)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> stone_phi.pairs", "using stone_phi.pairs_bot_closed"], ["proof (prove)\nusing this:\n  stone_phi.pairs_bot \\<in> stone_phi.pairs\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> stone_phi.pairs", "by auto"], ["", "setup_lifting type_definition_stone_phi_pair"], ["", "instantiation stone_phi_pair :: (stone_algebra) sup_inf_top_bot_uminus_ord\nbegin"], ["", "lift_definition sup_stone_phi_pair :: \"'a stone_phi_pair \\<Rightarrow> 'a stone_phi_pair \\<Rightarrow> 'a stone_phi_pair\" is triple.pairs_sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       \\<lbrakk>prod1 \\<in> stone_phi.pairs;\n        prod2 \\<in> stone_phi.pairs\\<rbrakk>\n       \\<Longrightarrow> stone_phi.pairs_sup prod1 prod2\n                         \\<in> stone_phi.pairs", "using stone_phi.pairs_sup_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?y) \\<in> stone_phi.pairs;\n   (?z, ?w) \\<in> stone_phi.pairs\\<rbrakk>\n  \\<Longrightarrow> stone_phi.pairs_sup (?x, ?y) (?z, ?w)\n                    \\<in> stone_phi.pairs\n\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       \\<lbrakk>prod1 \\<in> stone_phi.pairs;\n        prod2 \\<in> stone_phi.pairs\\<rbrakk>\n       \\<Longrightarrow> stone_phi.pairs_sup prod1 prod2\n                         \\<in> stone_phi.pairs", "by auto"], ["", "lift_definition inf_stone_phi_pair :: \"'a stone_phi_pair \\<Rightarrow> 'a stone_phi_pair \\<Rightarrow> 'a stone_phi_pair\" is triple.pairs_inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       \\<lbrakk>prod1 \\<in> stone_phi.pairs;\n        prod2 \\<in> stone_phi.pairs\\<rbrakk>\n       \\<Longrightarrow> stone_phi.pairs_inf prod1 prod2\n                         \\<in> stone_phi.pairs", "using stone_phi.pairs_inf_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?y) \\<in> stone_phi.pairs;\n   (?z, ?w) \\<in> stone_phi.pairs\\<rbrakk>\n  \\<Longrightarrow> stone_phi.pairs_inf (?x, ?y) (?z, ?w)\n                    \\<in> stone_phi.pairs\n\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       \\<lbrakk>prod1 \\<in> stone_phi.pairs;\n        prod2 \\<in> stone_phi.pairs\\<rbrakk>\n       \\<Longrightarrow> stone_phi.pairs_inf prod1 prod2\n                         \\<in> stone_phi.pairs", "by auto"], ["", "lift_definition uminus_stone_phi_pair :: \"'a stone_phi_pair \\<Rightarrow> 'a stone_phi_pair\" is \"triple.pairs_uminus stone_phi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod.\n       prod \\<in> stone_phi.pairs \\<Longrightarrow>\n       stone_phi.pairs_uminus prod \\<in> stone_phi.pairs", "using stone_phi.pairs_uminus_closed"], ["proof (prove)\nusing this:\n  stone_phi.pairs_uminus (?x, ?y) \\<in> stone_phi.pairs\n\ngoal (1 subgoal):\n 1. \\<And>prod.\n       prod \\<in> stone_phi.pairs \\<Longrightarrow>\n       stone_phi.pairs_uminus prod \\<in> stone_phi.pairs", "by auto"], ["", "lift_definition bot_stone_phi_pair :: \"'a stone_phi_pair\" is \"triple.pairs_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi.pairs_bot \\<in> stone_phi.pairs", "by (rule stone_phi.pairs_bot_closed)"], ["", "lift_definition top_stone_phi_pair :: \"'a stone_phi_pair\" is \"triple.pairs_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi.pairs_top \\<in> stone_phi.pairs", "by (rule stone_phi.pairs_top_closed)"], ["", "lift_definition less_eq_stone_phi_pair :: \"'a stone_phi_pair \\<Rightarrow> 'a stone_phi_pair \\<Rightarrow> bool\" is triple.pairs_less_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_stone_phi_pair :: \"'a stone_phi_pair \\<Rightarrow> 'a stone_phi_pair \\<Rightarrow> bool\" is triple.pairs_less"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stone_phi_pair, sup_inf_top_bot_uminus_ord_class)", ".."], ["", "end"], ["", "(*\ninstantiation stone_phi_pair :: (stone_algebra) stone_algebra\nbegin\n\ninstance\n  apply intro_classes\n  subgoal apply transfer by auto\n  subgoal apply transfer by auto\n  subgoal apply transfer by auto\n  subgoal apply transfer by auto\n  subgoal apply transfer by auto\n  subgoal apply transfer by auto\n  subgoal apply transfer by auto\n  subgoal apply transfer by auto\n  subgoal apply transfer by auto\n  subgoal apply transfer by auto\n  subgoal apply transfer by (metis (no_types, lifting) Pair_inject compl_bot_eq heyting.implies_order stone_phi.pairs_less_eq.elims(3) stone_phi.phi_top stone_phi.triple_axioms sup_top_left top_greatest triple_def)\n  subgoal apply transfer by (metis (no_types, lifting) Pair_inject stone_phi.pairs_less_eq.elims(3) top.extremum bot_least bot_filter.abs_eq)\n  subgoal apply transfer using stone_phi.triple_axioms triple.pairs_sup_dist_inf by fastforce\n  subgoal apply transfer using stone_phi.pairs_uminus_galois by fastforce\n  subgoal apply transfer using stone_phi.pairs_stone by fastforce\n  done\n\nend\n*)"], ["", "text \\<open>\nThe result is a Stone algebra and could be proved so by repeating and specialising the above proof for lifted pairs.\nWe choose a different approach, namely by embedding the type of pairs into the lifted type.\nThe embedding injects a pair \\<open>x\\<close> into a function as the value at the given structure map; this makes the embedding injective.\nThe value of the function at any other structure map needs to be carefully chosen so that the resulting function is a Stone algebra homomorphism.\nWe use \\<open>--x\\<close>, which is essentially a projection to the regular element component of \\<open>x\\<close>, whence the image has the structure of a Boolean algebra.\n\\<close>"], ["", "fun stone_phi_embed :: \"'a::non_trivial_stone_algebra stone_phi_pair \\<Rightarrow> ('a regular,'a dense) lifted_pair\"\n  where \"stone_phi_embed x = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair x else triple.pairs_uminus (Rep_phi f) (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\""], ["", "text \\<open>\nThe following lemma shows that in both cases the value of the function is a valid pair for the given structure map.\n\\<close>"], ["", "lemma stone_phi_embed_triple_pair:\n  \"(if Rep_phi f = stone_phi then Rep_stone_phi_pair x else triple.pairs_uminus (Rep_phi f) (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) \\<in> triple.pairs (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n     else triple.pairs_uminus (Rep_phi f)\n           (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n    \\<in> triple.pairs (Rep_phi f)", "by (metis (no_types, hide_lams) Rep_stone_phi_pair simp_phi surj_pair triple.pairs_uminus_closed triple_def)"], ["", "text \\<open>\nThe following result shows that the embedding preserves the operations of Stone algebras.\nOf course, it is not (yet) a Stone algebra homomorphism as we do not know (yet) that the domain of the embedding is a Stone algebra.\nTo establish the latter is the purpose of the embedding.\n\\<close>"], ["", "lemma stone_phi_embed_homomorphism:\n  \"sup_inf_top_bot_uminus_ord_homomorphism stone_phi_embed\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_inf_top_bot_uminus_ord_homomorphism stone_phi_embed", "proof (intro conjI)"], ["proof (state)\ngoal (6 subgoals):\n 1. sup_homomorphism stone_phi_embed\n 2. inf_homomorphism stone_phi_embed\n 3. top_homomorphism stone_phi_embed\n 4. bot_homomorphism stone_phi_embed\n 5. uminus_homomorphism stone_phi_embed\n 6. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "let ?p = \"\\<lambda>f . triple.pairs_uminus (Rep_phi f)\""], ["proof (state)\ngoal (6 subgoals):\n 1. sup_homomorphism stone_phi_embed\n 2. inf_homomorphism stone_phi_embed\n 3. top_homomorphism stone_phi_embed\n 4. bot_homomorphism stone_phi_embed\n 5. uminus_homomorphism stone_phi_embed\n 6. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "let ?pp = \"\\<lambda>f x . ?p f (?p f x)\""], ["proof (state)\ngoal (6 subgoals):\n 1. sup_homomorphism stone_phi_embed\n 2. inf_homomorphism stone_phi_embed\n 3. top_homomorphism stone_phi_embed\n 4. bot_homomorphism stone_phi_embed\n 5. uminus_homomorphism stone_phi_embed\n 6. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "let ?q = \"\\<lambda>f x . ?pp f (Rep_stone_phi_pair x)\""], ["proof (state)\ngoal (6 subgoals):\n 1. sup_homomorphism stone_phi_embed\n 2. inf_homomorphism stone_phi_embed\n 3. top_homomorphism stone_phi_embed\n 4. bot_homomorphism stone_phi_embed\n 5. uminus_homomorphism stone_phi_embed\n 6. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "show \"\\<forall>x y::'a stone_phi_pair . stone_phi_embed (x \\<squnion> y) = stone_phi_embed x \\<squnion> stone_phi_embed y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_homomorphism stone_phi_embed", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<squnion> y) =\n       stone_phi_embed x \\<squnion> stone_phi_embed y", "fix x y :: \"'a stone_phi_pair\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<squnion> y) =\n       stone_phi_embed x \\<squnion> stone_phi_embed y", "have 1: \"\\<forall>f . triple.pairs_sup (?q f x) (?q f y) = ?q f (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "fix f :: \"('a regular,'a dense) phi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "let ?r = \"Rep_phi f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "obtain x1 x2 y1 y2 where 2: \"(x1,x2) = Rep_stone_phi_pair x \\<and> (y1,y2) = Rep_stone_phi_pair y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_stone_phi_pair x \\<and>\n        (y1, y2) = Rep_stone_phi_pair y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_stone_phi_pair x \\<and>\n        (y1, y2) = Rep_stone_phi_pair y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_stone_phi_pair x \\<and> (y1, y2) = Rep_stone_phi_pair y\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "hence \"triple.pairs_sup (?q f x) (?q f y) = triple.pairs_sup (?pp f (x1,x2)) (?pp f (y1,y2))\""], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_stone_phi_pair x \\<and> (y1, y2) = Rep_stone_phi_pair y\n\ngoal (1 subgoal):\n 1. stone_phi.pairs_sup\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n    stone_phi.pairs_sup\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (y1, y2)))", "by simp"], ["proof (state)\nthis:\n  stone_phi.pairs_sup\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n  stone_phi.pairs_sup\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (y1, y2)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "also"], ["proof (state)\nthis:\n  stone_phi.pairs_sup\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n  stone_phi.pairs_sup\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (y1, y2)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "have \"... = triple.pairs_sup (--x1,?r (-x1)) (--y1,?r (-y1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi.pairs_sup\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (y1, y2))) =\n    stone_phi.pairs_sup (- - x1, Rep_phi f (- x1))\n     (- - y1, Rep_phi f (- y1))", "by (simp add: triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  stone_phi.pairs_sup\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (y1, y2))) =\n  stone_phi.pairs_sup (- - x1, Rep_phi f (- x1)) (- - y1, Rep_phi f (- y1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "also"], ["proof (state)\nthis:\n  stone_phi.pairs_sup\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (y1, y2))) =\n  stone_phi.pairs_sup (- - x1, Rep_phi f (- x1)) (- - y1, Rep_phi f (- y1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "have \"... = (--x1 \\<squnion> --y1,?r (-x1) \\<sqinter> ?r (-y1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi.pairs_sup (- - x1, Rep_phi f (- x1))\n     (- - y1, Rep_phi f (- y1)) =\n    (- - x1 \\<squnion> - - y1, Rep_phi f (- x1) \\<sqinter> Rep_phi f (- y1))", "by simp"], ["proof (state)\nthis:\n  stone_phi.pairs_sup (- - x1, Rep_phi f (- x1))\n   (- - y1, Rep_phi f (- y1)) =\n  (- - x1 \\<squnion> - - y1, Rep_phi f (- x1) \\<sqinter> Rep_phi f (- y1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "also"], ["proof (state)\nthis:\n  stone_phi.pairs_sup (- - x1, Rep_phi f (- x1))\n   (- - y1, Rep_phi f (- y1)) =\n  (- - x1 \\<squnion> - - y1, Rep_phi f (- x1) \\<sqinter> Rep_phi f (- y1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "have \"... = (--(x1 \\<squnion> y1),?r (-(x1 \\<squnion> y1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- - x1 \\<squnion> - - y1,\n     Rep_phi f (- x1) \\<sqinter> Rep_phi f (- y1)) =\n    (- - (x1 \\<squnion> y1), Rep_phi f (- (x1 \\<squnion> y1)))", "by simp"], ["proof (state)\nthis:\n  (- - x1 \\<squnion> - - y1, Rep_phi f (- x1) \\<sqinter> Rep_phi f (- y1)) =\n  (- - (x1 \\<squnion> y1), Rep_phi f (- (x1 \\<squnion> y1)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "also"], ["proof (state)\nthis:\n  (- - x1 \\<squnion> - - y1, Rep_phi f (- x1) \\<sqinter> Rep_phi f (- y1)) =\n  (- - (x1 \\<squnion> y1), Rep_phi f (- (x1 \\<squnion> y1)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "have \"... = ?pp f (x1 \\<squnion> y1,x2 \\<sqinter> y2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- - (x1 \\<squnion> y1), Rep_phi f (- (x1 \\<squnion> y1))) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1 \\<squnion> y1, x2 \\<sqinter> y2))", "by (simp add: triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  (- - (x1 \\<squnion> y1), Rep_phi f (- (x1 \\<squnion> y1))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (x1 \\<squnion> y1, x2 \\<sqinter> y2))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "also"], ["proof (state)\nthis:\n  (- - (x1 \\<squnion> y1), Rep_phi f (- (x1 \\<squnion> y1))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (x1 \\<squnion> y1, x2 \\<sqinter> y2))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "have \"... = ?pp f (triple.pairs_sup (x1,x2) (y1,y2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f)\n       (x1 \\<squnion> y1, x2 \\<sqinter> y2)) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f)\n       (stone_phi.pairs_sup (x1, x2) (y1, y2)))", "by simp"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (x1 \\<squnion> y1, x2 \\<sqinter> y2)) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (stone_phi.pairs_sup (x1, x2) (y1, y2)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "also"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (x1 \\<squnion> y1, x2 \\<sqinter> y2)) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (stone_phi.pairs_sup (x1, x2) (y1, y2)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "have \"... = ?q f (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f)\n       (stone_phi.pairs_sup (x1, x2) (y1, y2))) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (x \\<squnion> y)))", "using 2"], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_stone_phi_pair x \\<and> (y1, y2) = Rep_stone_phi_pair y\n\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f)\n       (stone_phi.pairs_sup (x1, x2) (y1, y2))) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (x \\<squnion> y)))", "by (simp add: sup_stone_phi_pair.rep_eq)"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f)\n     (stone_phi.pairs_sup (x1, x2) (y1, y2))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (x \\<squnion> y)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_sup\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<squnion> y)))", "finally"], ["proof (chain)\npicking this:\n  stone_phi.pairs_sup\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (x \\<squnion> y)))", "show \"triple.pairs_sup (?q f x) (?q f y) = ?q f (x \\<squnion> y)\""], ["proof (prove)\nusing this:\n  stone_phi.pairs_sup\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (x \\<squnion> y)))\n\ngoal (1 subgoal):\n 1. stone_phi.pairs_sup\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (x \\<squnion> y)))", "."], ["proof (state)\nthis:\n  stone_phi.pairs_sup\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (x \\<squnion> y)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>f.\n     stone_phi.pairs_sup\n      (triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n      (triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n     triple.pairs_uminus (Rep_phi f)\n      (triple.pairs_uminus (Rep_phi f)\n        (Rep_stone_phi_pair (x \\<squnion> y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<squnion> y) =\n       stone_phi_embed x \\<squnion> stone_phi_embed y", "have \"stone_phi_embed x \\<squnion> stone_phi_embed y = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair x else ?q f x) \\<squnion> Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair y else ?q f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi_embed x \\<squnion> stone_phi_embed y =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair x))) \\<squnion>\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "by simp"], ["proof (state)\nthis:\n  stone_phi_embed x \\<squnion> stone_phi_embed y =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair x))) \\<squnion>\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<squnion> y) =\n       stone_phi_embed x \\<squnion> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  stone_phi_embed x \\<squnion> stone_phi_embed y =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair x))) \\<squnion>\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<squnion> y) =\n       stone_phi_embed x \\<squnion> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . triple.pairs_sup (if Rep_phi f = stone_phi then Rep_stone_phi_pair x else ?q f x) (if Rep_phi f = stone_phi then Rep_stone_phi_pair y else ?q f y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair x))) \\<squnion>\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         stone_phi.pairs_sup\n          (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n           else triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n          (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n           else triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))))", "by (rule sup_lifted_pair.abs_eq) (simp_all add: eq_onp_same_args stone_phi_embed_triple_pair)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair x))) \\<squnion>\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       stone_phi.pairs_sup\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<squnion> y) =\n       stone_phi_embed x \\<squnion> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair x))) \\<squnion>\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       stone_phi.pairs_sup\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<squnion> y) =\n       stone_phi_embed x \\<squnion> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then triple.pairs_sup (Rep_stone_phi_pair x) (Rep_stone_phi_pair y) else triple.pairs_sup (?q f x) (?q f y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         stone_phi.pairs_sup\n          (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n           else triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n          (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n           else triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f)\n                   (Rep_stone_phi_pair y)))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then stone_phi.pairs_sup (Rep_stone_phi_pair x)\n               (Rep_stone_phi_pair y)\n         else stone_phi.pairs_sup\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))))", "by (simp add: if_distrib_2)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       stone_phi.pairs_sup\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_sup (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else stone_phi.pairs_sup\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<squnion> y) =\n       stone_phi_embed x \\<squnion> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       stone_phi.pairs_sup\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_sup (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else stone_phi.pairs_sup\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<squnion> y) =\n       stone_phi_embed x \\<squnion> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then triple.pairs_sup (Rep_stone_phi_pair x) (Rep_stone_phi_pair y) else ?q f (x \\<squnion> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then stone_phi.pairs_sup (Rep_stone_phi_pair x)\n               (Rep_stone_phi_pair y)\n         else stone_phi.pairs_sup\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f)\n                   (Rep_stone_phi_pair y)))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then stone_phi.pairs_sup (Rep_stone_phi_pair x)\n               (Rep_stone_phi_pair y)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair (x \\<squnion> y))))", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     stone_phi.pairs_sup\n      (triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n      (triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n     triple.pairs_uminus (Rep_phi f)\n      (triple.pairs_uminus (Rep_phi f)\n        (Rep_stone_phi_pair (x \\<squnion> y)))\n\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then stone_phi.pairs_sup (Rep_stone_phi_pair x)\n               (Rep_stone_phi_pair y)\n         else stone_phi.pairs_sup\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f)\n                   (Rep_stone_phi_pair y)))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then stone_phi.pairs_sup (Rep_stone_phi_pair x)\n               (Rep_stone_phi_pair y)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair (x \\<squnion> y))))", "by meson"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_sup (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else stone_phi.pairs_sup\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_sup (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair (x \\<squnion> y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<squnion> y) =\n       stone_phi_embed x \\<squnion> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_sup (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else stone_phi.pairs_sup\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_sup (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair (x \\<squnion> y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<squnion> y) =\n       stone_phi_embed x \\<squnion> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair (x \\<squnion> y) else ?q f (x \\<squnion> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then stone_phi.pairs_sup (Rep_stone_phi_pair x)\n               (Rep_stone_phi_pair y)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair (x \\<squnion> y)))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair (x \\<squnion> y)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair (x \\<squnion> y))))", "by (metis sup_stone_phi_pair.rep_eq)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_sup (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair (x \\<squnion> y)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair (x \\<squnion> y)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair (x \\<squnion> y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<squnion> y) =\n       stone_phi_embed x \\<squnion> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_sup (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair (x \\<squnion> y)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair (x \\<squnion> y)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair (x \\<squnion> y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<squnion> y) =\n       stone_phi_embed x \\<squnion> stone_phi_embed y", "have \"... = stone_phi_embed (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair (x \\<squnion> y)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair (x \\<squnion> y)))) =\n    stone_phi_embed (x \\<squnion> y)", "by simp"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair (x \\<squnion> y)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair (x \\<squnion> y)))) =\n  stone_phi_embed (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<squnion> y) =\n       stone_phi_embed x \\<squnion> stone_phi_embed y", "finally"], ["proof (chain)\npicking this:\n  stone_phi_embed x \\<squnion> stone_phi_embed y =\n  stone_phi_embed (x \\<squnion> y)", "show \"stone_phi_embed (x \\<squnion> y) = stone_phi_embed x \\<squnion> stone_phi_embed y\""], ["proof (prove)\nusing this:\n  stone_phi_embed x \\<squnion> stone_phi_embed y =\n  stone_phi_embed (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. stone_phi_embed (x \\<squnion> y) =\n    stone_phi_embed x \\<squnion> stone_phi_embed y", "by simp"], ["proof (state)\nthis:\n  stone_phi_embed (x \\<squnion> y) =\n  stone_phi_embed x \\<squnion> stone_phi_embed y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sup_homomorphism stone_phi_embed\n\ngoal (5 subgoals):\n 1. inf_homomorphism stone_phi_embed\n 2. top_homomorphism stone_phi_embed\n 3. bot_homomorphism stone_phi_embed\n 4. uminus_homomorphism stone_phi_embed\n 5. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. inf_homomorphism stone_phi_embed\n 2. top_homomorphism stone_phi_embed\n 3. bot_homomorphism stone_phi_embed\n 4. uminus_homomorphism stone_phi_embed\n 5. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "let ?p = \"\\<lambda>f . triple.pairs_uminus (Rep_phi f)\""], ["proof (state)\ngoal (5 subgoals):\n 1. inf_homomorphism stone_phi_embed\n 2. top_homomorphism stone_phi_embed\n 3. bot_homomorphism stone_phi_embed\n 4. uminus_homomorphism stone_phi_embed\n 5. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "let ?pp = \"\\<lambda>f x . ?p f (?p f x)\""], ["proof (state)\ngoal (5 subgoals):\n 1. inf_homomorphism stone_phi_embed\n 2. top_homomorphism stone_phi_embed\n 3. bot_homomorphism stone_phi_embed\n 4. uminus_homomorphism stone_phi_embed\n 5. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "let ?q = \"\\<lambda>f x . ?pp f (Rep_stone_phi_pair x)\""], ["proof (state)\ngoal (5 subgoals):\n 1. inf_homomorphism stone_phi_embed\n 2. top_homomorphism stone_phi_embed\n 3. bot_homomorphism stone_phi_embed\n 4. uminus_homomorphism stone_phi_embed\n 5. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "show \"\\<forall>x y::'a stone_phi_pair . stone_phi_embed (x \\<sqinter> y) = stone_phi_embed x \\<sqinter> stone_phi_embed y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_homomorphism stone_phi_embed", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<sqinter> y) =\n       stone_phi_embed x \\<sqinter> stone_phi_embed y", "fix x y :: \"'a stone_phi_pair\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<sqinter> y) =\n       stone_phi_embed x \\<sqinter> stone_phi_embed y", "have 1: \"\\<forall>f . triple.pairs_inf (?q f x) (?q f y) = ?q f (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "fix f :: \"('a regular,'a dense) phi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "let ?r = \"Rep_phi f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "obtain x1 x2 y1 y2 where 2: \"(x1,x2) = Rep_stone_phi_pair x \\<and> (y1,y2) = Rep_stone_phi_pair y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_stone_phi_pair x \\<and>\n        (y1, y2) = Rep_stone_phi_pair y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_stone_phi_pair x \\<and>\n        (y1, y2) = Rep_stone_phi_pair y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_stone_phi_pair x \\<and> (y1, y2) = Rep_stone_phi_pair y\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "hence \"triple.pairs_inf (?q f x) (?q f y) = triple.pairs_inf (?pp f (x1,x2)) (?pp f (y1,y2))\""], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_stone_phi_pair x \\<and> (y1, y2) = Rep_stone_phi_pair y\n\ngoal (1 subgoal):\n 1. stone_phi.pairs_inf\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n    stone_phi.pairs_inf\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (y1, y2)))", "by simp"], ["proof (state)\nthis:\n  stone_phi.pairs_inf\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n  stone_phi.pairs_inf\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (y1, y2)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "also"], ["proof (state)\nthis:\n  stone_phi.pairs_inf\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n  stone_phi.pairs_inf\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (y1, y2)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "have \"... = triple.pairs_inf (--x1,?r (-x1)) (--y1,?r (-y1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi.pairs_inf\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (y1, y2))) =\n    stone_phi.pairs_inf (- - x1, Rep_phi f (- x1))\n     (- - y1, Rep_phi f (- y1))", "by (simp add: triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  stone_phi.pairs_inf\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (y1, y2))) =\n  stone_phi.pairs_inf (- - x1, Rep_phi f (- x1)) (- - y1, Rep_phi f (- y1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "also"], ["proof (state)\nthis:\n  stone_phi.pairs_inf\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (y1, y2))) =\n  stone_phi.pairs_inf (- - x1, Rep_phi f (- x1)) (- - y1, Rep_phi f (- y1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "have \"... = (--x1 \\<sqinter> --y1,?r (-x1) \\<squnion> ?r (-y1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi.pairs_inf (- - x1, Rep_phi f (- x1))\n     (- - y1, Rep_phi f (- y1)) =\n    (- - x1 \\<sqinter> - - y1, Rep_phi f (- x1) \\<squnion> Rep_phi f (- y1))", "by simp"], ["proof (state)\nthis:\n  stone_phi.pairs_inf (- - x1, Rep_phi f (- x1))\n   (- - y1, Rep_phi f (- y1)) =\n  (- - x1 \\<sqinter> - - y1, Rep_phi f (- x1) \\<squnion> Rep_phi f (- y1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "also"], ["proof (state)\nthis:\n  stone_phi.pairs_inf (- - x1, Rep_phi f (- x1))\n   (- - y1, Rep_phi f (- y1)) =\n  (- - x1 \\<sqinter> - - y1, Rep_phi f (- x1) \\<squnion> Rep_phi f (- y1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "have \"... = (--(x1 \\<sqinter> y1),?r (-(x1 \\<sqinter> y1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- - x1 \\<sqinter> - - y1,\n     Rep_phi f (- x1) \\<squnion> Rep_phi f (- y1)) =\n    (- - (x1 \\<sqinter> y1), Rep_phi f (- (x1 \\<sqinter> y1)))", "by simp"], ["proof (state)\nthis:\n  (- - x1 \\<sqinter> - - y1, Rep_phi f (- x1) \\<squnion> Rep_phi f (- y1)) =\n  (- - (x1 \\<sqinter> y1), Rep_phi f (- (x1 \\<sqinter> y1)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "also"], ["proof (state)\nthis:\n  (- - x1 \\<sqinter> - - y1, Rep_phi f (- x1) \\<squnion> Rep_phi f (- y1)) =\n  (- - (x1 \\<sqinter> y1), Rep_phi f (- (x1 \\<sqinter> y1)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "have \"... = ?pp f (x1 \\<sqinter> y1,x2 \\<squnion> y2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- - (x1 \\<sqinter> y1), Rep_phi f (- (x1 \\<sqinter> y1))) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1 \\<sqinter> y1, x2 \\<squnion> y2))", "by (simp add: triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  (- - (x1 \\<sqinter> y1), Rep_phi f (- (x1 \\<sqinter> y1))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (x1 \\<sqinter> y1, x2 \\<squnion> y2))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "also"], ["proof (state)\nthis:\n  (- - (x1 \\<sqinter> y1), Rep_phi f (- (x1 \\<sqinter> y1))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (x1 \\<sqinter> y1, x2 \\<squnion> y2))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "have \"... = ?pp f (triple.pairs_inf (x1,x2) (y1,y2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f)\n       (x1 \\<sqinter> y1, x2 \\<squnion> y2)) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f)\n       (stone_phi.pairs_inf (x1, x2) (y1, y2)))", "by simp"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (x1 \\<sqinter> y1, x2 \\<squnion> y2)) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (stone_phi.pairs_inf (x1, x2) (y1, y2)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "also"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (x1 \\<sqinter> y1, x2 \\<squnion> y2)) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (stone_phi.pairs_inf (x1, x2) (y1, y2)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "have \"... = ?q f (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f)\n       (stone_phi.pairs_inf (x1, x2) (y1, y2))) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (x \\<sqinter> y)))", "using 2"], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_stone_phi_pair x \\<and> (y1, y2) = Rep_stone_phi_pair y\n\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f)\n       (stone_phi.pairs_inf (x1, x2) (y1, y2))) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (x \\<sqinter> y)))", "by (simp add: inf_stone_phi_pair.rep_eq)"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f)\n     (stone_phi.pairs_inf (x1, x2) (y1, y2))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (x \\<sqinter> y)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_inf\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_stone_phi_pair (x \\<sqinter> y)))", "finally"], ["proof (chain)\npicking this:\n  stone_phi.pairs_inf\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (x \\<sqinter> y)))", "show \"triple.pairs_inf (?q f x) (?q f y) = ?q f (x \\<sqinter> y)\""], ["proof (prove)\nusing this:\n  stone_phi.pairs_inf\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (x \\<sqinter> y)))\n\ngoal (1 subgoal):\n 1. stone_phi.pairs_inf\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (x \\<sqinter> y)))", "."], ["proof (state)\nthis:\n  stone_phi.pairs_inf\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (x \\<sqinter> y)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>f.\n     stone_phi.pairs_inf\n      (triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n      (triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n     triple.pairs_uminus (Rep_phi f)\n      (triple.pairs_uminus (Rep_phi f)\n        (Rep_stone_phi_pair (x \\<sqinter> y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<sqinter> y) =\n       stone_phi_embed x \\<sqinter> stone_phi_embed y", "have \"stone_phi_embed x \\<sqinter> stone_phi_embed y = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair x else ?q f x) \\<sqinter> Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair y else ?q f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi_embed x \\<sqinter> stone_phi_embed y =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair x))) \\<sqinter>\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "by simp"], ["proof (state)\nthis:\n  stone_phi_embed x \\<sqinter> stone_phi_embed y =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair x))) \\<sqinter>\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<sqinter> y) =\n       stone_phi_embed x \\<sqinter> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  stone_phi_embed x \\<sqinter> stone_phi_embed y =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair x))) \\<sqinter>\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<sqinter> y) =\n       stone_phi_embed x \\<sqinter> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . triple.pairs_inf (if Rep_phi f = stone_phi then Rep_stone_phi_pair x else ?q f x) (if Rep_phi f = stone_phi then Rep_stone_phi_pair y else ?q f y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair x))) \\<sqinter>\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         stone_phi.pairs_inf\n          (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n           else triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n          (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n           else triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))))", "by (rule inf_lifted_pair.abs_eq) (simp_all add: eq_onp_same_args stone_phi_embed_triple_pair)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair x))) \\<sqinter>\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       stone_phi.pairs_inf\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<sqinter> y) =\n       stone_phi_embed x \\<sqinter> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair x))) \\<sqinter>\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       stone_phi.pairs_inf\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<sqinter> y) =\n       stone_phi_embed x \\<sqinter> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then triple.pairs_inf (Rep_stone_phi_pair x) (Rep_stone_phi_pair y) else triple.pairs_inf (?q f x) (?q f y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         stone_phi.pairs_inf\n          (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n           else triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n          (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n           else triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f)\n                   (Rep_stone_phi_pair y)))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then stone_phi.pairs_inf (Rep_stone_phi_pair x)\n               (Rep_stone_phi_pair y)\n         else stone_phi.pairs_inf\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))))", "by (simp add: if_distrib_2)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       stone_phi.pairs_inf\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_inf (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else stone_phi.pairs_inf\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<sqinter> y) =\n       stone_phi_embed x \\<sqinter> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       stone_phi.pairs_inf\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_inf (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else stone_phi.pairs_inf\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<sqinter> y) =\n       stone_phi_embed x \\<sqinter> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then triple.pairs_inf (Rep_stone_phi_pair x) (Rep_stone_phi_pair y) else ?q f (x \\<sqinter> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then stone_phi.pairs_inf (Rep_stone_phi_pair x)\n               (Rep_stone_phi_pair y)\n         else stone_phi.pairs_inf\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f)\n                   (Rep_stone_phi_pair y)))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then stone_phi.pairs_inf (Rep_stone_phi_pair x)\n               (Rep_stone_phi_pair y)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair (x \\<sqinter> y))))", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     stone_phi.pairs_inf\n      (triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n      (triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y))) =\n     triple.pairs_uminus (Rep_phi f)\n      (triple.pairs_uminus (Rep_phi f)\n        (Rep_stone_phi_pair (x \\<sqinter> y)))\n\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then stone_phi.pairs_inf (Rep_stone_phi_pair x)\n               (Rep_stone_phi_pair y)\n         else stone_phi.pairs_inf\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f)\n                   (Rep_stone_phi_pair y)))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then stone_phi.pairs_inf (Rep_stone_phi_pair x)\n               (Rep_stone_phi_pair y)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair (x \\<sqinter> y))))", "by meson"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_inf (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else stone_phi.pairs_inf\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_inf (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair (x \\<sqinter> y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<sqinter> y) =\n       stone_phi_embed x \\<sqinter> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_inf (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else stone_phi.pairs_inf\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_inf (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair (x \\<sqinter> y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<sqinter> y) =\n       stone_phi_embed x \\<sqinter> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair (x \\<sqinter> y) else ?q f (x \\<sqinter> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then stone_phi.pairs_inf (Rep_stone_phi_pair x)\n               (Rep_stone_phi_pair y)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair (x \\<sqinter> y)))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair (x \\<sqinter> y)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair (x \\<sqinter> y))))", "by (metis inf_stone_phi_pair.rep_eq)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_inf (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair (x \\<sqinter> y)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair (x \\<sqinter> y)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair (x \\<sqinter> y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<sqinter> y) =\n       stone_phi_embed x \\<sqinter> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then stone_phi.pairs_inf (Rep_stone_phi_pair x)\n             (Rep_stone_phi_pair y)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair (x \\<sqinter> y)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair (x \\<sqinter> y)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair (x \\<sqinter> y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<sqinter> y) =\n       stone_phi_embed x \\<sqinter> stone_phi_embed y", "have \"... = stone_phi_embed (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair (x \\<sqinter> y)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair (x \\<sqinter> y)))) =\n    stone_phi_embed (x \\<sqinter> y)", "by simp"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair (x \\<sqinter> y)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (Rep_stone_phi_pair (x \\<sqinter> y)))) =\n  stone_phi_embed (x \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi_embed (x \\<sqinter> y) =\n       stone_phi_embed x \\<sqinter> stone_phi_embed y", "finally"], ["proof (chain)\npicking this:\n  stone_phi_embed x \\<sqinter> stone_phi_embed y =\n  stone_phi_embed (x \\<sqinter> y)", "show \"stone_phi_embed (x \\<sqinter> y) = stone_phi_embed x \\<sqinter> stone_phi_embed y\""], ["proof (prove)\nusing this:\n  stone_phi_embed x \\<sqinter> stone_phi_embed y =\n  stone_phi_embed (x \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. stone_phi_embed (x \\<sqinter> y) =\n    stone_phi_embed x \\<sqinter> stone_phi_embed y", "by simp"], ["proof (state)\nthis:\n  stone_phi_embed (x \\<sqinter> y) =\n  stone_phi_embed x \\<sqinter> stone_phi_embed y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inf_homomorphism stone_phi_embed\n\ngoal (4 subgoals):\n 1. top_homomorphism stone_phi_embed\n 2. bot_homomorphism stone_phi_embed\n 3. uminus_homomorphism stone_phi_embed\n 4. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. top_homomorphism stone_phi_embed\n 2. bot_homomorphism stone_phi_embed\n 3. uminus_homomorphism stone_phi_embed\n 4. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "have \"stone_phi_embed (top::'a stone_phi_pair) = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair top else triple.pairs_uminus (Rep_phi f) (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair top)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi_embed top =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair top\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair top)))", "by simp"], ["proof (state)\nthis:\n  stone_phi_embed top =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair top\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair top)))\n\ngoal (4 subgoals):\n 1. top_homomorphism stone_phi_embed\n 2. bot_homomorphism stone_phi_embed\n 3. uminus_homomorphism stone_phi_embed\n 4. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  stone_phi_embed top =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair top\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair top)))\n\ngoal (4 subgoals):\n 1. top_homomorphism stone_phi_embed\n 2. bot_homomorphism stone_phi_embed\n 3. uminus_homomorphism stone_phi_embed\n 4. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then (top,bot) else triple.pairs_uminus (Rep_phi f) (triple.pairs_uminus (Rep_phi f) (top,bot)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair top\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair top))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then (top, bot)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (top, bot)))", "by (metis (no_types, hide_lams) bot_filter.abs_eq top_stone_phi_pair.rep_eq)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair top\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair top))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (top, bot)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (top, bot)))\n\ngoal (4 subgoals):\n 1. top_homomorphism stone_phi_embed\n 2. bot_homomorphism stone_phi_embed\n 3. uminus_homomorphism stone_phi_embed\n 4. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair top\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair top))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (top, bot)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (top, bot)))\n\ngoal (4 subgoals):\n 1. top_homomorphism stone_phi_embed\n 2. bot_homomorphism stone_phi_embed\n 3. uminus_homomorphism stone_phi_embed\n 4. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then (top,bot) else triple.pairs_uminus (Rep_phi f) (bot,top))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then (top, bot)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (top, bot))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then (top, bot)\n         else triple.pairs_uminus (Rep_phi f) (bot, top))", "by (metis (no_types, hide_lams) dense_closed_top simp_phi triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (top, bot)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (top, bot))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (top, bot)\n       else triple.pairs_uminus (Rep_phi f) (bot, top))\n\ngoal (4 subgoals):\n 1. top_homomorphism stone_phi_embed\n 2. bot_homomorphism stone_phi_embed\n 3. uminus_homomorphism stone_phi_embed\n 4. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (top, bot)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (top, bot))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (top, bot)\n       else triple.pairs_uminus (Rep_phi f) (bot, top))\n\ngoal (4 subgoals):\n 1. top_homomorphism stone_phi_embed\n 2. bot_homomorphism stone_phi_embed\n 3. uminus_homomorphism stone_phi_embed\n 4. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then (top,bot) else (top,bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then (top, bot)\n         else triple.pairs_uminus (Rep_phi f) (bot, top)) =\n    Abs_lifted_pair\n     (\\<lambda>f. if Rep_phi f = stone_phi then (top, bot) else (top, bot))", "by (metis (no_types, hide_lams) p_bot simp_phi triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (top, bot)\n       else triple.pairs_uminus (Rep_phi f) (bot, top)) =\n  Abs_lifted_pair\n   (\\<lambda>f. if Rep_phi f = stone_phi then (top, bot) else (top, bot))\n\ngoal (4 subgoals):\n 1. top_homomorphism stone_phi_embed\n 2. bot_homomorphism stone_phi_embed\n 3. uminus_homomorphism stone_phi_embed\n 4. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (top, bot)\n       else triple.pairs_uminus (Rep_phi f) (bot, top)) =\n  Abs_lifted_pair\n   (\\<lambda>f. if Rep_phi f = stone_phi then (top, bot) else (top, bot))\n\ngoal (4 subgoals):\n 1. top_homomorphism stone_phi_embed\n 2. bot_homomorphism stone_phi_embed\n 3. uminus_homomorphism stone_phi_embed\n 4. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . (top,Abs_filter {top}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then (top, bot) else (top, bot)) =\n    Abs_lifted_pair (\\<lambda>f. stone_phi.pairs_top)", "by (simp add: bot_filter.abs_eq)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f. if Rep_phi f = stone_phi then (top, bot) else (top, bot)) =\n  Abs_lifted_pair (\\<lambda>f. stone_phi.pairs_top)\n\ngoal (4 subgoals):\n 1. top_homomorphism stone_phi_embed\n 2. bot_homomorphism stone_phi_embed\n 3. uminus_homomorphism stone_phi_embed\n 4. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f. if Rep_phi f = stone_phi then (top, bot) else (top, bot)) =\n  Abs_lifted_pair (\\<lambda>f. stone_phi.pairs_top)\n\ngoal (4 subgoals):\n 1. top_homomorphism stone_phi_embed\n 2. bot_homomorphism stone_phi_embed\n 3. uminus_homomorphism stone_phi_embed\n 4. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "have \"... = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair (\\<lambda>f. stone_phi.pairs_top) = top", "by (rule top_lifted_pair.abs_eq[THEN sym])"], ["proof (state)\nthis:\n  Abs_lifted_pair (\\<lambda>f. stone_phi.pairs_top) = top\n\ngoal (4 subgoals):\n 1. top_homomorphism stone_phi_embed\n 2. bot_homomorphism stone_phi_embed\n 3. uminus_homomorphism stone_phi_embed\n 4. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "finally"], ["proof (chain)\npicking this:\n  top_homomorphism stone_phi_embed", "show \"stone_phi_embed (top::'a stone_phi_pair) = top\""], ["proof (prove)\nusing this:\n  top_homomorphism stone_phi_embed\n\ngoal (1 subgoal):\n 1. top_homomorphism stone_phi_embed", "."], ["proof (state)\nthis:\n  top_homomorphism stone_phi_embed\n\ngoal (3 subgoals):\n 1. bot_homomorphism stone_phi_embed\n 2. uminus_homomorphism stone_phi_embed\n 3. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. bot_homomorphism stone_phi_embed\n 2. uminus_homomorphism stone_phi_embed\n 3. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "have \"stone_phi_embed (bot::'a stone_phi_pair) = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair bot else triple.pairs_uminus (Rep_phi f) (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair bot)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi_embed bot =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair bot\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair bot)))", "by simp"], ["proof (state)\nthis:\n  stone_phi_embed bot =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair bot\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair bot)))\n\ngoal (3 subgoals):\n 1. bot_homomorphism stone_phi_embed\n 2. uminus_homomorphism stone_phi_embed\n 3. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  stone_phi_embed bot =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair bot\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair bot)))\n\ngoal (3 subgoals):\n 1. bot_homomorphism stone_phi_embed\n 2. uminus_homomorphism stone_phi_embed\n 3. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then (bot,top) else triple.pairs_uminus (Rep_phi f) (triple.pairs_uminus (Rep_phi f) (bot,top)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair bot\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair bot))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then (bot, top)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (bot, top)))", "by (metis (no_types, hide_lams) top_filter.abs_eq bot_stone_phi_pair.rep_eq)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair bot\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair bot))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (bot, top)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (bot, top)))\n\ngoal (3 subgoals):\n 1. bot_homomorphism stone_phi_embed\n 2. uminus_homomorphism stone_phi_embed\n 3. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair bot\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair bot))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (bot, top)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (bot, top)))\n\ngoal (3 subgoals):\n 1. bot_homomorphism stone_phi_embed\n 2. uminus_homomorphism stone_phi_embed\n 3. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then (bot,top) else triple.pairs_uminus (Rep_phi f) (top,bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then (bot, top)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (bot, top))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then (bot, top)\n         else triple.pairs_uminus (Rep_phi f) (top, bot))", "by (metis (no_types, hide_lams) p_bot simp_phi triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (bot, top)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (bot, top))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (bot, top)\n       else triple.pairs_uminus (Rep_phi f) (top, bot))\n\ngoal (3 subgoals):\n 1. bot_homomorphism stone_phi_embed\n 2. uminus_homomorphism stone_phi_embed\n 3. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (bot, top)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (bot, top))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (bot, top)\n       else triple.pairs_uminus (Rep_phi f) (top, bot))\n\ngoal (3 subgoals):\n 1. bot_homomorphism stone_phi_embed\n 2. uminus_homomorphism stone_phi_embed\n 3. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then (bot,top) else (bot,top))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then (bot, top)\n         else triple.pairs_uminus (Rep_phi f) (top, bot)) =\n    Abs_lifted_pair\n     (\\<lambda>f. if Rep_phi f = stone_phi then (bot, top) else (bot, top))", "by (metis (no_types, hide_lams) p_top simp_phi triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (bot, top)\n       else triple.pairs_uminus (Rep_phi f) (top, bot)) =\n  Abs_lifted_pair\n   (\\<lambda>f. if Rep_phi f = stone_phi then (bot, top) else (bot, top))\n\ngoal (3 subgoals):\n 1. bot_homomorphism stone_phi_embed\n 2. uminus_homomorphism stone_phi_embed\n 3. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then (bot, top)\n       else triple.pairs_uminus (Rep_phi f) (top, bot)) =\n  Abs_lifted_pair\n   (\\<lambda>f. if Rep_phi f = stone_phi then (bot, top) else (bot, top))\n\ngoal (3 subgoals):\n 1. bot_homomorphism stone_phi_embed\n 2. uminus_homomorphism stone_phi_embed\n 3. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "have \"... = Abs_lifted_pair (\\<lambda>f . (bot,Abs_filter UNIV))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then (bot, top) else (bot, top)) =\n    Abs_lifted_pair (\\<lambda>f. stone_phi.pairs_bot)", "by (simp add: top_filter.abs_eq)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f. if Rep_phi f = stone_phi then (bot, top) else (bot, top)) =\n  Abs_lifted_pair (\\<lambda>f. stone_phi.pairs_bot)\n\ngoal (3 subgoals):\n 1. bot_homomorphism stone_phi_embed\n 2. uminus_homomorphism stone_phi_embed\n 3. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f. if Rep_phi f = stone_phi then (bot, top) else (bot, top)) =\n  Abs_lifted_pair (\\<lambda>f. stone_phi.pairs_bot)\n\ngoal (3 subgoals):\n 1. bot_homomorphism stone_phi_embed\n 2. uminus_homomorphism stone_phi_embed\n 3. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair (\\<lambda>f. stone_phi.pairs_bot) = bot", "by (rule bot_lifted_pair.abs_eq[THEN sym])"], ["proof (state)\nthis:\n  Abs_lifted_pair (\\<lambda>f. stone_phi.pairs_bot) = bot\n\ngoal (3 subgoals):\n 1. bot_homomorphism stone_phi_embed\n 2. uminus_homomorphism stone_phi_embed\n 3. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "finally"], ["proof (chain)\npicking this:\n  bot_homomorphism stone_phi_embed", "show \"stone_phi_embed (bot::'a stone_phi_pair) = bot\""], ["proof (prove)\nusing this:\n  bot_homomorphism stone_phi_embed\n\ngoal (1 subgoal):\n 1. bot_homomorphism stone_phi_embed", "."], ["proof (state)\nthis:\n  bot_homomorphism stone_phi_embed\n\ngoal (2 subgoals):\n 1. uminus_homomorphism stone_phi_embed\n 2. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. uminus_homomorphism stone_phi_embed\n 2. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "let ?p = \"\\<lambda>f . triple.pairs_uminus (Rep_phi f)\""], ["proof (state)\ngoal (2 subgoals):\n 1. uminus_homomorphism stone_phi_embed\n 2. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "let ?pp = \"\\<lambda>f x . ?p f (?p f x)\""], ["proof (state)\ngoal (2 subgoals):\n 1. uminus_homomorphism stone_phi_embed\n 2. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "let ?q = \"\\<lambda>f x . ?pp f (Rep_stone_phi_pair x)\""], ["proof (state)\ngoal (2 subgoals):\n 1. uminus_homomorphism stone_phi_embed\n 2. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "show \"\\<forall>x::'a stone_phi_pair . stone_phi_embed (-x) = -stone_phi_embed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uminus_homomorphism stone_phi_embed", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. stone_phi_embed (- x) = - stone_phi_embed x", "fix x :: \"'a stone_phi_pair\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. stone_phi_embed (- x) = - stone_phi_embed x", "have 1: \"\\<forall>f . triple.pairs_uminus (Rep_phi f) (?q f x) = ?q f (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "fix f :: \"('a regular,'a dense) phi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "let ?r = \"Rep_phi f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "obtain x1 x2 where 2: \"(x1,x2) = Rep_stone_phi_pair x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        (x1, x2) = Rep_stone_phi_pair x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        (x1, x2) = Rep_stone_phi_pair x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_stone_phi_pair x\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "hence \"triple.pairs_uminus (Rep_phi f) (?q f x) = triple.pairs_uminus (Rep_phi f) (?pp f (x1,x2))\""], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_stone_phi_pair x\n\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (x1, x2)))", "by simp"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "also"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "have \"... = triple.pairs_uminus (Rep_phi f) (--x1,?r (-x1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (x1, x2))) =\n    triple.pairs_uminus (Rep_phi f) (- - x1, Rep_phi f (- x1))", "by (simp add: triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2))) =\n  triple.pairs_uminus (Rep_phi f) (- - x1, Rep_phi f (- x1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "also"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2))) =\n  triple.pairs_uminus (Rep_phi f) (- - x1, Rep_phi f (- x1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "have \"... = (---x1,?r (--x1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi f) (- - x1, Rep_phi f (- x1)) =\n    (- - - x1, Rep_phi f (- - x1))", "by (simp add: triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f) (- - x1, Rep_phi f (- x1)) =\n  (- - - x1, Rep_phi f (- - x1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "also"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f) (- - x1, Rep_phi f (- x1)) =\n  (- - - x1, Rep_phi f (- - x1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "have \"... = ?pp f (-x1,stone_phi x1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- - - x1, Rep_phi f (- - x1)) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (- x1, stone_phi x1))", "by (simp add: triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  (- - - x1, Rep_phi f (- - x1)) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (- x1, stone_phi x1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "also"], ["proof (state)\nthis:\n  (- - - x1, Rep_phi f (- - x1)) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (- x1, stone_phi x1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "have \"... = ?pp f (triple.pairs_uminus stone_phi (x1,x2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (- x1, stone_phi x1)) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (stone_phi.pairs_uminus (x1, x2)))", "by simp"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (- x1, stone_phi x1)) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (stone_phi.pairs_uminus (x1, x2)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "also"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (- x1, stone_phi x1)) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (stone_phi.pairs_uminus (x1, x2)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "have \"... = ?q f (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (stone_phi.pairs_uminus (x1, x2))) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "using 2"], ["proof (prove)\nusing this:\n  (x1, x2) = Rep_stone_phi_pair x\n\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (stone_phi.pairs_uminus (x1, x2))) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "by (simp add: uminus_stone_phi_pair.rep_eq)"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (stone_phi.pairs_uminus (x1, x2))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "finally"], ["proof (chain)\npicking this:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "show \"triple.pairs_uminus (Rep_phi f) (?q f x) = ?q f (-x)\""], ["proof (prove)\nusing this:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))\n\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n    triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))", "."], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n  triple.pairs_uminus (Rep_phi f)\n   (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>f.\n     triple.pairs_uminus (Rep_phi f)\n      (triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n     triple.pairs_uminus (Rep_phi f)\n      (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))\n\ngoal (1 subgoal):\n 1. \\<And>x. stone_phi_embed (- x) = - stone_phi_embed x", "have \"-stone_phi_embed x = -Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair x else ?q f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - stone_phi_embed x =\n    - Abs_lifted_pair\n       (\\<lambda>f.\n           if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n           else triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))", "by simp"], ["proof (state)\nthis:\n  - stone_phi_embed x =\n  - Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n\ngoal (1 subgoal):\n 1. \\<And>x. stone_phi_embed (- x) = - stone_phi_embed x", "also"], ["proof (state)\nthis:\n  - stone_phi_embed x =\n  - Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n\ngoal (1 subgoal):\n 1. \\<And>x. stone_phi_embed (- x) = - stone_phi_embed x", "have \"... = Abs_lifted_pair (\\<lambda>f . triple.pairs_uminus (Rep_phi f) (if Rep_phi f = stone_phi then Rep_stone_phi_pair x else ?q f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - Abs_lifted_pair\n       (\\<lambda>f.\n           if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n           else triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         triple.pairs_uminus (Rep_phi f)\n          (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n           else triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))))", "by (rule uminus_lifted_pair.abs_eq) (simp_all add: eq_onp_same_args stone_phi_embed_triple_pair)"], ["proof (state)\nthis:\n  - Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       triple.pairs_uminus (Rep_phi f)\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))))\n\ngoal (1 subgoal):\n 1. \\<And>x. stone_phi_embed (- x) = - stone_phi_embed x", "also"], ["proof (state)\nthis:\n  - Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       triple.pairs_uminus (Rep_phi f)\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))))\n\ngoal (1 subgoal):\n 1. \\<And>x. stone_phi_embed (- x) = - stone_phi_embed x", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x) else triple.pairs_uminus (Rep_phi f) (?q f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         triple.pairs_uminus (Rep_phi f)\n          (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n           else triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f)\n                   (Rep_stone_phi_pair x)))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))))", "by (simp add: if_distrib)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       triple.pairs_uminus (Rep_phi f)\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))))\n\ngoal (1 subgoal):\n 1. \\<And>x. stone_phi_embed (- x) = - stone_phi_embed x", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       triple.pairs_uminus (Rep_phi f)\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))))\n\ngoal (1 subgoal):\n 1. \\<And>x. stone_phi_embed (- x) = - stone_phi_embed x", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x) else ?q f (-x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f)\n                   (Rep_stone_phi_pair x)))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x))))", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     triple.pairs_uminus (Rep_phi f)\n      (triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n     triple.pairs_uminus (Rep_phi f)\n      (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))\n\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f)\n                   (Rep_stone_phi_pair x)))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x))))", "by meson"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x))))\n\ngoal (1 subgoal):\n 1. \\<And>x. stone_phi_embed (- x) = - stone_phi_embed x", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x))))\n\ngoal (1 subgoal):\n 1. \\<And>x. stone_phi_embed (- x) = - stone_phi_embed x", "have \"... = Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair (-x) else ?q f (-x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi\n         then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair (- x)))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair (- x)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x))))", "by (metis uminus_stone_phi_pair.rep_eq)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair (- x)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x))))\n\ngoal (1 subgoal):\n 1. \\<And>x. stone_phi_embed (- x) = - stone_phi_embed x", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi\n       then triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair (- x)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x))))\n\ngoal (1 subgoal):\n 1. \\<And>x. stone_phi_embed (- x) = - stone_phi_embed x", "have \"... = stone_phi_embed (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair (- x)\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f)\n                 (Rep_stone_phi_pair (- x)))) =\n    stone_phi_embed (- x)", "by simp"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair (- x)\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair (- x)))) =\n  stone_phi_embed (- x)\n\ngoal (1 subgoal):\n 1. \\<And>x. stone_phi_embed (- x) = - stone_phi_embed x", "finally"], ["proof (chain)\npicking this:\n  - stone_phi_embed x = stone_phi_embed (- x)", "show \"stone_phi_embed (-x) = -stone_phi_embed x\""], ["proof (prove)\nusing this:\n  - stone_phi_embed x = stone_phi_embed (- x)\n\ngoal (1 subgoal):\n 1. stone_phi_embed (- x) = - stone_phi_embed x", "by simp"], ["proof (state)\nthis:\n  stone_phi_embed (- x) = - stone_phi_embed x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  uminus_homomorphism stone_phi_embed\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "let ?p = \"\\<lambda>f . triple.pairs_uminus (Rep_phi f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "let ?pp = \"\\<lambda>f x . ?p f (?p f x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "let ?q = \"\\<lambda>f x . ?pp f (Rep_stone_phi_pair x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "show \"\\<forall>x y::'a stone_phi_pair . x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "proof (intro allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "fix x y :: \"'a stone_phi_pair\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "assume 1: \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "have \"\\<forall>f . triple.pairs_less_eq (if Rep_phi f = stone_phi then Rep_stone_phi_pair x else ?q f x) (if Rep_phi f = stone_phi then Rep_stone_phi_pair y else ?q f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       stone_phi.pairs_less_eq\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_less_eq\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "fix f :: \"('a regular,'a dense) phi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_less_eq\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "let ?r = \"Rep_phi f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_less_eq\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "obtain x1 x2 y1 y2 where 2: \"(x1,x2) = Rep_stone_phi_pair x \\<and> (y1,y2) = Rep_stone_phi_pair y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_stone_phi_pair x \\<and>\n        (y1, y2) = Rep_stone_phi_pair y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2 y1 y2.\n        (x1, x2) = Rep_stone_phi_pair x \\<and>\n        (y1, y2) = Rep_stone_phi_pair y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x1, x2) = Rep_stone_phi_pair x \\<and> (y1, y2) = Rep_stone_phi_pair y\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_less_eq\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "have \"x1 \\<le> y1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 \\<le> y1", "using 1 2"], ["proof (prove)\nusing this:\n  x \\<le> y\n  (x1, x2) = Rep_stone_phi_pair x \\<and> (y1, y2) = Rep_stone_phi_pair y\n\ngoal (1 subgoal):\n 1. x1 \\<le> y1", "by (metis less_eq_stone_phi_pair.rep_eq stone_phi.pairs_less_eq.simps)"], ["proof (state)\nthis:\n  x1 \\<le> y1\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_less_eq\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "hence \"--x1 \\<le> --y1 \\<and> ?r (-y1) \\<le> ?r (-x1)\""], ["proof (prove)\nusing this:\n  x1 \\<le> y1\n\ngoal (1 subgoal):\n 1. - - x1 \\<le> - - y1 \\<and> Rep_phi f (- y1) \\<le> Rep_phi f (- x1)", "by (metis compl_le_compl_iff le_iff_sup simp_phi)"], ["proof (state)\nthis:\n  - - x1 \\<le> - - y1 \\<and> Rep_phi f (- y1) \\<le> Rep_phi f (- x1)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_less_eq\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "hence \"triple.pairs_less_eq (--x1,?r (-x1)) (--y1,?r (-y1))\""], ["proof (prove)\nusing this:\n  - - x1 \\<le> - - y1 \\<and> Rep_phi f (- y1) \\<le> Rep_phi f (- x1)\n\ngoal (1 subgoal):\n 1. stone_phi.pairs_less_eq (- - x1, Rep_phi f (- x1))\n     (- - y1, Rep_phi f (- y1))", "by simp"], ["proof (state)\nthis:\n  stone_phi.pairs_less_eq (- - x1, Rep_phi f (- x1))\n   (- - y1, Rep_phi f (- y1))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_less_eq\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "hence \"triple.pairs_less_eq (?pp f (x1,x2)) (?pp f (y1,y2))\""], ["proof (prove)\nusing this:\n  stone_phi.pairs_less_eq (- - x1, Rep_phi f (- x1))\n   (- - y1, Rep_phi f (- y1))\n\ngoal (1 subgoal):\n 1. stone_phi.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (y1, y2)))", "by (simp add: triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  stone_phi.pairs_less_eq\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (y1, y2)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_less_eq\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "hence \"triple.pairs_less_eq (?q f x) (?q f y)\""], ["proof (prove)\nusing this:\n  stone_phi.pairs_less_eq\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (y1, y2)))\n\ngoal (1 subgoal):\n 1. stone_phi.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "using 2"], ["proof (prove)\nusing this:\n  stone_phi.pairs_less_eq\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (x1, x2)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (y1, y2)))\n  (x1, x2) = Rep_stone_phi_pair x \\<and> (y1, y2) = Rep_stone_phi_pair y\n\ngoal (1 subgoal):\n 1. stone_phi.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n     (triple.pairs_uminus (Rep_phi f)\n       (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "by simp"], ["proof (state)\nthis:\n  stone_phi.pairs_less_eq\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_less_eq\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "hence \"if ?r = stone_phi then triple.pairs_less_eq (Rep_stone_phi_pair x) (Rep_stone_phi_pair y) else triple.pairs_less_eq (?q f x) (?q f y)\""], ["proof (prove)\nusing this:\n  stone_phi.pairs_less_eq\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. if Rep_phi f = stone_phi\n    then stone_phi.pairs_less_eq (Rep_stone_phi_pair x)\n          (Rep_stone_phi_pair y)\n    else stone_phi.pairs_less_eq\n          (triple.pairs_uminus (Rep_phi f)\n            (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n          (triple.pairs_uminus (Rep_phi f)\n            (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "using 1"], ["proof (prove)\nusing this:\n  stone_phi.pairs_less_eq\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n   (triple.pairs_uminus (Rep_phi f)\n     (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. if Rep_phi f = stone_phi\n    then stone_phi.pairs_less_eq (Rep_stone_phi_pair x)\n          (Rep_stone_phi_pair y)\n    else stone_phi.pairs_less_eq\n          (triple.pairs_uminus (Rep_phi f)\n            (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n          (triple.pairs_uminus (Rep_phi f)\n            (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "by (simp add: less_eq_stone_phi_pair.rep_eq)"], ["proof (state)\nthis:\n  if Rep_phi f = stone_phi\n  then stone_phi.pairs_less_eq (Rep_stone_phi_pair x) (Rep_stone_phi_pair y)\n  else stone_phi.pairs_less_eq\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       stone_phi.pairs_less_eq\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "thus \"triple.pairs_less_eq (if ?r = stone_phi then Rep_stone_phi_pair x else ?q f x) (if ?r = stone_phi then Rep_stone_phi_pair y else ?q f y)\""], ["proof (prove)\nusing this:\n  if Rep_phi f = stone_phi\n  then stone_phi.pairs_less_eq (Rep_stone_phi_pair x) (Rep_stone_phi_pair y)\n  else stone_phi.pairs_less_eq\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. stone_phi.pairs_less_eq\n     (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n      else triple.pairs_uminus (Rep_phi f)\n            (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n     (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n      else triple.pairs_uminus (Rep_phi f)\n            (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "by (simp add: if_distrib_2)"], ["proof (state)\nthis:\n  stone_phi.pairs_less_eq\n   (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n    else triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n   (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n    else triple.pairs_uminus (Rep_phi f)\n          (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>f.\n     stone_phi.pairs_less_eq\n      (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n      (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "hence \"Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair x else ?q f x) \\<le> Abs_lifted_pair (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair y else ?q f y)\""], ["proof (prove)\nusing this:\n  \\<forall>f.\n     stone_phi.pairs_less_eq\n      (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n      (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n    \\<le> Abs_lifted_pair\n           (\\<lambda>f.\n               if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n               else triple.pairs_uminus (Rep_phi f)\n                     (triple.pairs_uminus (Rep_phi f)\n                       (Rep_stone_phi_pair y)))", "by (subst less_eq_lifted_pair.abs_eq) (simp_all add: eq_onp_same_args stone_phi_embed_triple_pair)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n  \\<le> Abs_lifted_pair\n         (\\<lambda>f.\n             if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n             else triple.pairs_uminus (Rep_phi f)\n                   (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<le> y \\<Longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y", "thus \"stone_phi_embed x \\<le> stone_phi_embed y\""], ["proof (prove)\nusing this:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n  \\<le> Abs_lifted_pair\n         (\\<lambda>f.\n             if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n             else triple.pairs_uminus (Rep_phi f)\n                   (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. stone_phi_embed x \\<le> stone_phi_embed y", "by simp"], ["proof (state)\nthis:\n  stone_phi_embed x \\<le> stone_phi_embed y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y.\n     x \\<le> y \\<longrightarrow> stone_phi_embed x \\<le> stone_phi_embed y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe following lemmas show that the embedding is injective and reflects the order.\nThe latter allows us to easily inherit properties involving inequalities from the target of the embedding, without transforming them to equations.\n\\<close>"], ["", "lemma stone_phi_embed_injective:\n  \"inj stone_phi_embed\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj stone_phi_embed", "proof (rule injI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. stone_phi_embed x = stone_phi_embed y \\<Longrightarrow> x = y", "fix x y :: \"'a stone_phi_pair\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. stone_phi_embed x = stone_phi_embed y \\<Longrightarrow> x = y", "have 1: \"Rep_phi (Abs_phi stone_phi) = stone_phi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_phi (Abs_phi stone_phi) = stone_phi", "by (simp add: Abs_phi_inverse stone_phi.hom)"], ["proof (state)\nthis:\n  Rep_phi (Abs_phi stone_phi) = stone_phi\n\ngoal (1 subgoal):\n 1. \\<And>x y. stone_phi_embed x = stone_phi_embed y \\<Longrightarrow> x = y", "assume 2: \"stone_phi_embed x = stone_phi_embed y\""], ["proof (state)\nthis:\n  stone_phi_embed x = stone_phi_embed y\n\ngoal (1 subgoal):\n 1. \\<And>x y. stone_phi_embed x = stone_phi_embed y \\<Longrightarrow> x = y", "have \"\\<forall>x::'a stone_phi_pair . Rep_lifted_pair (stone_phi_embed x) = (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair x else triple.pairs_uminus (Rep_phi f) (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       Rep_lifted_pair (stone_phi_embed x) =\n       (\\<lambda>f.\n           if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n           else triple.pairs_uminus (Rep_phi f)\n                 (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))", "by (simp add: Abs_lifted_pair_inverse stone_phi_embed_triple_pair)"], ["proof (state)\nthis:\n  \\<forall>x.\n     Rep_lifted_pair (stone_phi_embed x) =\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. stone_phi_embed x = stone_phi_embed y \\<Longrightarrow> x = y", "hence \"(\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair x else triple.pairs_uminus (Rep_phi f) (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) = (\\<lambda>f . if Rep_phi f = stone_phi then Rep_stone_phi_pair y else triple.pairs_uminus (Rep_phi f) (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     Rep_lifted_pair (stone_phi_embed x) =\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n        else triple.pairs_uminus (Rep_phi f)\n              (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n    (\\<lambda>f.\n        if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n        else triple.pairs_uminus (Rep_phi f)\n              (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "using 2"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     Rep_lifted_pair (stone_phi_embed x) =\n     (\\<lambda>f.\n         if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n  stone_phi_embed x = stone_phi_embed y\n\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n        else triple.pairs_uminus (Rep_phi f)\n              (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n    (\\<lambda>f.\n        if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n        else triple.pairs_uminus (Rep_phi f)\n              (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "by metis"], ["proof (state)\nthis:\n  (\\<lambda>f.\n      if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n      else triple.pairs_uminus (Rep_phi f)\n            (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n  (\\<lambda>f.\n      if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n      else triple.pairs_uminus (Rep_phi f)\n            (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. stone_phi_embed x = stone_phi_embed y \\<Longrightarrow> x = y", "hence \"Rep_stone_phi_pair x = Rep_stone_phi_pair y\""], ["proof (prove)\nusing this:\n  (\\<lambda>f.\n      if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n      else triple.pairs_uminus (Rep_phi f)\n            (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n  (\\<lambda>f.\n      if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n      else triple.pairs_uminus (Rep_phi f)\n            (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. Rep_stone_phi_pair x = Rep_stone_phi_pair y", "using 1"], ["proof (prove)\nusing this:\n  (\\<lambda>f.\n      if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n      else triple.pairs_uminus (Rep_phi f)\n            (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) =\n  (\\<lambda>f.\n      if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n      else triple.pairs_uminus (Rep_phi f)\n            (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n  Rep_phi (Abs_phi stone_phi) = stone_phi\n\ngoal (1 subgoal):\n 1. Rep_stone_phi_pair x = Rep_stone_phi_pair y", "by metis"], ["proof (state)\nthis:\n  Rep_stone_phi_pair x = Rep_stone_phi_pair y\n\ngoal (1 subgoal):\n 1. \\<And>x y. stone_phi_embed x = stone_phi_embed y \\<Longrightarrow> x = y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  Rep_stone_phi_pair x = Rep_stone_phi_pair y\n\ngoal (1 subgoal):\n 1. x = y", "by (simp add: Rep_stone_phi_pair_inject)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stone_phi_embed_order_injective:\n  assumes \"stone_phi_embed x \\<le> stone_phi_embed y\"\n    shows \"x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> y", "let ?f = \"Abs_phi stone_phi\""], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> y", "have \"\\<forall>f . triple.pairs_less_eq (if Rep_phi f = stone_phi then Rep_stone_phi_pair x else triple.pairs_uminus (Rep_phi f) (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x))) (if Rep_phi f = stone_phi then Rep_stone_phi_pair y else triple.pairs_uminus (Rep_phi f) (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       stone_phi.pairs_less_eq\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "using assms"], ["proof (prove)\nusing this:\n  stone_phi_embed x \\<le> stone_phi_embed y\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       stone_phi.pairs_less_eq\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n        (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n         else triple.pairs_uminus (Rep_phi f)\n               (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))", "by (subst less_eq_lifted_pair.abs_eq[THEN sym]) (simp_all add: eq_onp_same_args stone_phi_embed_triple_pair)"], ["proof (state)\nthis:\n  \\<forall>f.\n     stone_phi.pairs_less_eq\n      (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n      (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. x \\<le> y", "hence \"triple.pairs_less_eq (if Rep_phi ?f = (stone_phi::'a regular \\<Rightarrow> 'a dense_filter) then Rep_stone_phi_pair x else triple.pairs_uminus (Rep_phi ?f) (triple.pairs_uminus (Rep_phi ?f) (Rep_stone_phi_pair x))) (if Rep_phi ?f = (stone_phi::'a regular \\<Rightarrow> 'a dense_filter) then Rep_stone_phi_pair y else triple.pairs_uminus (Rep_phi ?f) (triple.pairs_uminus (Rep_phi ?f) (Rep_stone_phi_pair y)))\""], ["proof (prove)\nusing this:\n  \\<forall>f.\n     stone_phi.pairs_less_eq\n      (if Rep_phi f = stone_phi then Rep_stone_phi_pair x\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair x)))\n      (if Rep_phi f = stone_phi then Rep_stone_phi_pair y\n       else triple.pairs_uminus (Rep_phi f)\n             (triple.pairs_uminus (Rep_phi f) (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. stone_phi.pairs_less_eq\n     (if Rep_phi (Abs_phi stone_phi) = stone_phi then Rep_stone_phi_pair x\n      else triple.pairs_uminus (Rep_phi (Abs_phi stone_phi))\n            (triple.pairs_uminus (Rep_phi (Abs_phi stone_phi))\n              (Rep_stone_phi_pair x)))\n     (if Rep_phi (Abs_phi stone_phi) = stone_phi then Rep_stone_phi_pair y\n      else triple.pairs_uminus (Rep_phi (Abs_phi stone_phi))\n            (triple.pairs_uminus (Rep_phi (Abs_phi stone_phi))\n              (Rep_stone_phi_pair y)))", "by simp"], ["proof (state)\nthis:\n  stone_phi.pairs_less_eq\n   (if Rep_phi (Abs_phi stone_phi) = stone_phi then Rep_stone_phi_pair x\n    else triple.pairs_uminus (Rep_phi (Abs_phi stone_phi))\n          (triple.pairs_uminus (Rep_phi (Abs_phi stone_phi))\n            (Rep_stone_phi_pair x)))\n   (if Rep_phi (Abs_phi stone_phi) = stone_phi then Rep_stone_phi_pair y\n    else triple.pairs_uminus (Rep_phi (Abs_phi stone_phi))\n          (triple.pairs_uminus (Rep_phi (Abs_phi stone_phi))\n            (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. x \\<le> y", "hence \"triple.pairs_less_eq (Rep_stone_phi_pair x) (Rep_stone_phi_pair y)\""], ["proof (prove)\nusing this:\n  stone_phi.pairs_less_eq\n   (if Rep_phi (Abs_phi stone_phi) = stone_phi then Rep_stone_phi_pair x\n    else triple.pairs_uminus (Rep_phi (Abs_phi stone_phi))\n          (triple.pairs_uminus (Rep_phi (Abs_phi stone_phi))\n            (Rep_stone_phi_pair x)))\n   (if Rep_phi (Abs_phi stone_phi) = stone_phi then Rep_stone_phi_pair y\n    else triple.pairs_uminus (Rep_phi (Abs_phi stone_phi))\n          (triple.pairs_uminus (Rep_phi (Abs_phi stone_phi))\n            (Rep_stone_phi_pair y)))\n\ngoal (1 subgoal):\n 1. stone_phi.pairs_less_eq (Rep_stone_phi_pair x) (Rep_stone_phi_pair y)", "by (simp add: Abs_phi_inverse stone_phi.hom)"], ["proof (state)\nthis:\n  stone_phi.pairs_less_eq (Rep_stone_phi_pair x) (Rep_stone_phi_pair y)\n\ngoal (1 subgoal):\n 1. x \\<le> y", "thus \"x \\<le> y\""], ["proof (prove)\nusing this:\n  stone_phi.pairs_less_eq (Rep_stone_phi_pair x) (Rep_stone_phi_pair y)\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by (simp add: less_eq_stone_phi_pair.rep_eq)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stone_phi_embed_strict_order_isomorphism:\n  \"x < y \\<longleftrightarrow> stone_phi_embed x < stone_phi_embed y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (stone_phi_embed x < stone_phi_embed y)", "by (smt less_eq_stone_phi_pair.rep_eq less_le_not_le less_stone_phi_pair.rep_eq stone_phi.pairs_less.elims(2,3) stone_phi_embed_homomorphism stone_phi_embed_order_injective)"], ["", "text \\<open>\nNow all Stone algebra axioms can be inherited using the embedding.\nThis is due to the fact that the axioms are universally quantified equations or conditional equations (or inequalities); this is called a quasivariety in universal algebra.\nIt would be useful to have this construction available for arbitrary quasivarieties.\n\\<close>"], ["", "instantiation stone_phi_pair :: (non_trivial_stone_algebra) stone_algebra\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a stone_phi_pair, stone_algebra_class)", "apply intro_classes"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 15 subgoals...", "apply (metis (mono_tags, lifting) stone_phi_embed_homomorphism stone_phi_embed_strict_order_isomorphism stone_phi_embed_order_injective less_le_not_le)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 14 subgoals...", "apply (simp add: stone_phi_embed_order_injective)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 13 subgoals...", "apply (meson order.trans stone_phi_embed_homomorphism stone_phi_embed_order_injective)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 12 subgoals...", "apply (meson stone_phi_embed_homomorphism antisym stone_phi_embed_injective injD)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\nA total of 11 subgoals...", "apply (metis inf.sup_ge1 stone_phi_embed_homomorphism stone_phi_embed_order_injective)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 10. \\<And>x. - x \\<squnion> - - x = top", "apply (metis inf.sup_ge2 stone_phi_embed_homomorphism stone_phi_embed_order_injective)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 9. \\<And>x. - x \\<squnion> - - x = top", "apply (metis inf_greatest stone_phi_embed_homomorphism stone_phi_embed_order_injective)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 8. \\<And>x. - x \\<squnion> - - x = top", "apply (metis stone_phi_embed_homomorphism stone_phi_embed_order_injective sup_ge1)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 7. \\<And>x. - x \\<squnion> - - x = top", "apply (metis stone_phi_embed_homomorphism stone_phi_embed_order_injective sup.cobounded2)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 6. \\<And>x. - x \\<squnion> - - x = top", "apply (metis stone_phi_embed_homomorphism stone_phi_embed_order_injective sup_least)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 5. \\<And>x. - x \\<squnion> - - x = top", "apply (metis bot.extremum stone_phi_embed_homomorphism stone_phi_embed_order_injective)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 4. \\<And>x. - x \\<squnion> - - x = top", "apply (metis stone_phi_embed_homomorphism stone_phi_embed_order_injective top_greatest)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "apply (metis (mono_tags, lifting) stone_phi_embed_homomorphism sup_inf_distrib1 stone_phi_embed_injective injD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "apply (metis stone_phi_embed_homomorphism stone_phi_embed_injective injD stone_phi_embed_order_injective pseudo_complement)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "by (metis injD stone_phi_embed_homomorphism stone_phi_embed_injective stone)"], ["", "end"], ["", "subsection \\<open>Stone Algebra Isomorphism\\<close>"], ["", "text \\<open>\nIn this section we prove that the Stone algebra of the triple of a Stone algebra is isomorphic to the original Stone algebra.\nThe following two definitions give the isomorphism.\n\\<close>"], ["", "abbreviation sa_iso_inv :: \"'a::non_trivial_stone_algebra stone_phi_pair \\<Rightarrow> 'a\"\n  where \"sa_iso_inv \\<equiv> \\<lambda>p . Rep_regular (fst (Rep_stone_phi_pair p)) \\<sqinter> Rep_dense (triple.rho_pair stone_phi (Rep_stone_phi_pair p))\""], ["", "abbreviation sa_iso :: \"'a::non_trivial_stone_algebra \\<Rightarrow> 'a stone_phi_pair\"\n  where \"sa_iso \\<equiv> \\<lambda>x . Abs_stone_phi_pair (Abs_regular (--x),stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x)))\""], ["", "lemma sa_iso_triple_pair:\n  \"(Abs_regular (--x),stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) \\<in> triple.pairs stone_phi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_regular (- - x),\n     stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x)))\n    \\<in> stone_phi.pairs", "by (metis (mono_tags, lifting) double_compl eq_onp_same_args stone_phi.sa_iso_pair uminus_regular.abs_eq)"], ["", "lemma stone_phi_inf_dense:\n  \"stone_phi (Abs_regular (-x)) \\<sqinter> up_filter (Abs_dense (y \\<squnion> -y)) \\<le> up_filter (Abs_dense (y \\<squnion> -y \\<squnion> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "have \"Rep_filter (stone_phi (Abs_regular (-x)) \\<sqinter> up_filter (Abs_dense (y \\<squnion> -y))) \\<le> \\<up>(Abs_dense (y \\<squnion> -y \\<squnion> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filters.filter.Rep_filter\n     (stone_phi (Abs_regular (- x)) \\<sqinter>\n      up_filter (Abs_dense (y \\<squnion> - y)))\n    \\<subseteq> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- x)) \\<sqinter>\n                  up_filter\n                   (Abs_dense (y \\<squnion> - y))) \\<Longrightarrow>\n       xa \\<in> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)", "fix z :: \"'a dense\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- x)) \\<sqinter>\n                  up_filter\n                   (Abs_dense (y \\<squnion> - y))) \\<Longrightarrow>\n       xa \\<in> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)", "let ?r = \"Rep_dense z\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- x)) \\<sqinter>\n                  up_filter\n                   (Abs_dense (y \\<squnion> - y))) \\<Longrightarrow>\n       xa \\<in> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)", "assume \"z \\<in> Rep_filter (stone_phi (Abs_regular (-x)) \\<sqinter> up_filter (Abs_dense (y \\<squnion> -y)))\""], ["proof (state)\nthis:\n  z \\<in> Filters.filter.Rep_filter\n           (stone_phi (Abs_regular (- x)) \\<sqinter>\n            up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- x)) \\<sqinter>\n                  up_filter\n                   (Abs_dense (y \\<squnion> - y))) \\<Longrightarrow>\n       xa \\<in> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)", "also"], ["proof (state)\nthis:\n  z \\<in> Filters.filter.Rep_filter\n           (stone_phi (Abs_regular (- x)) \\<sqinter>\n            up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- x)) \\<sqinter>\n                  up_filter\n                   (Abs_dense (y \\<squnion> - y))) \\<Longrightarrow>\n       xa \\<in> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)", "have \"... = Rep_filter (stone_phi (Abs_regular (-x))) \\<inter> Rep_filter (up_filter (Abs_dense (y \\<squnion> -y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filters.filter.Rep_filter\n     (stone_phi (Abs_regular (- x)) \\<sqinter>\n      up_filter (Abs_dense (y \\<squnion> - y))) =\n    Filters.filter.Rep_filter (stone_phi (Abs_regular (- x))) \\<inter>\n    Filters.filter.Rep_filter (up_filter (Abs_dense (y \\<squnion> - y)))", "by (simp add: inf_filter.rep_eq)"], ["proof (state)\nthis:\n  Filters.filter.Rep_filter\n   (stone_phi (Abs_regular (- x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))) =\n  Filters.filter.Rep_filter (stone_phi (Abs_regular (- x))) \\<inter>\n  Filters.filter.Rep_filter (up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- x)) \\<sqinter>\n                  up_filter\n                   (Abs_dense (y \\<squnion> - y))) \\<Longrightarrow>\n       xa \\<in> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)", "also"], ["proof (state)\nthis:\n  Filters.filter.Rep_filter\n   (stone_phi (Abs_regular (- x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))) =\n  Filters.filter.Rep_filter (stone_phi (Abs_regular (- x))) \\<inter>\n  Filters.filter.Rep_filter (up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- x)) \\<sqinter>\n                  up_filter\n                   (Abs_dense (y \\<squnion> - y))) \\<Longrightarrow>\n       xa \\<in> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)", "have \"... = stone_phi_base (Abs_regular (-x)) \\<inter> \\<up>(Abs_dense (y \\<squnion> -y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filters.filter.Rep_filter (stone_phi (Abs_regular (- x))) \\<inter>\n    Filters.filter.Rep_filter (up_filter (Abs_dense (y \\<squnion> - y))) =\n    stone_phi_base (Abs_regular (- x)) \\<inter>\n    \\<up>Abs_dense (y \\<squnion> - y)", "by (metis Abs_filter_inverse mem_Collect_eq up_filter stone_phi_base_filter stone_phi_def)"], ["proof (state)\nthis:\n  Filters.filter.Rep_filter (stone_phi (Abs_regular (- x))) \\<inter>\n  Filters.filter.Rep_filter (up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi_base (Abs_regular (- x)) \\<inter>\n  \\<up>Abs_dense (y \\<squnion> - y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- x)) \\<sqinter>\n                  up_filter\n                   (Abs_dense (y \\<squnion> - y))) \\<Longrightarrow>\n       xa \\<in> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)", "finally"], ["proof (chain)\npicking this:\n  z \\<in> stone_phi_base (Abs_regular (- x)) \\<inter>\n          \\<up>Abs_dense (y \\<squnion> - y)", "have \"--x \\<le> ?r \\<and> Abs_dense (y \\<squnion> -y) \\<le> z\""], ["proof (prove)\nusing this:\n  z \\<in> stone_phi_base (Abs_regular (- x)) \\<inter>\n          \\<up>Abs_dense (y \\<squnion> - y)\n\ngoal (1 subgoal):\n 1. - - x \\<le> Rep_dense z \\<and> Abs_dense (y \\<squnion> - y) \\<le> z", "by (metis (mono_tags, lifting) Abs_regular_inverse Int_Collect mem_Collect_eq)"], ["proof (state)\nthis:\n  - - x \\<le> Rep_dense z \\<and> Abs_dense (y \\<squnion> - y) \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- x)) \\<sqinter>\n                  up_filter\n                   (Abs_dense (y \\<squnion> - y))) \\<Longrightarrow>\n       xa \\<in> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)", "hence \"--x \\<le> ?r \\<and> y \\<squnion> -y \\<le> ?r\""], ["proof (prove)\nusing this:\n  - - x \\<le> Rep_dense z \\<and> Abs_dense (y \\<squnion> - y) \\<le> z\n\ngoal (1 subgoal):\n 1. - - x \\<le> Rep_dense z \\<and> y \\<squnion> - y \\<le> Rep_dense z", "by (simp add: Abs_dense_inverse less_eq_dense.rep_eq)"], ["proof (state)\nthis:\n  - - x \\<le> Rep_dense z \\<and> y \\<squnion> - y \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- x)) \\<sqinter>\n                  up_filter\n                   (Abs_dense (y \\<squnion> - y))) \\<Longrightarrow>\n       xa \\<in> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)", "hence \"y \\<squnion> -y \\<squnion> x \\<le> ?r\""], ["proof (prove)\nusing this:\n  - - x \\<le> Rep_dense z \\<and> y \\<squnion> - y \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. y \\<squnion> - y \\<squnion> x \\<le> Rep_dense z", "using order_trans pp_increasing"], ["proof (prove)\nusing this:\n  - - x \\<le> Rep_dense z \\<and> y \\<squnion> - y \\<le> Rep_dense z\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  ?x \\<le> - - ?x\n\ngoal (1 subgoal):\n 1. y \\<squnion> - y \\<squnion> x \\<le> Rep_dense z", "by auto"], ["proof (state)\nthis:\n  y \\<squnion> - y \\<squnion> x \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- x)) \\<sqinter>\n                  up_filter\n                   (Abs_dense (y \\<squnion> - y))) \\<Longrightarrow>\n       xa \\<in> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)", "hence \"Abs_dense (y \\<squnion> -y \\<squnion> x) \\<le> Abs_dense ?r\""], ["proof (prove)\nusing this:\n  y \\<squnion> - y \\<squnion> x \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. Abs_dense (y \\<squnion> - y \\<squnion> x) \\<le> Abs_dense (Rep_dense z)", "by (subst less_eq_dense.abs_eq) (simp_all add: eq_onp_same_args)"], ["proof (state)\nthis:\n  Abs_dense (y \\<squnion> - y \\<squnion> x) \\<le> Abs_dense (Rep_dense z)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- x)) \\<sqinter>\n                  up_filter\n                   (Abs_dense (y \\<squnion> - y))) \\<Longrightarrow>\n       xa \\<in> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)", "thus \"z \\<in> \\<up>(Abs_dense (y \\<squnion> -y \\<squnion> x))\""], ["proof (prove)\nusing this:\n  Abs_dense (y \\<squnion> - y \\<squnion> x) \\<le> Abs_dense (Rep_dense z)\n\ngoal (1 subgoal):\n 1. z \\<in> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)", "by (simp add: Rep_dense_inverse)"], ["proof (state)\nthis:\n  z \\<in> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Filters.filter.Rep_filter\n   (stone_phi (Abs_regular (- x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y)))\n  \\<subseteq> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "hence \"Abs_filter (Rep_filter (stone_phi (Abs_regular (-x)) \\<sqinter> up_filter (Abs_dense (y \\<squnion> -y)))) \\<le> up_filter (Abs_dense (y \\<squnion> -y \\<squnion> x))\""], ["proof (prove)\nusing this:\n  Filters.filter.Rep_filter\n   (stone_phi (Abs_regular (- x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y)))\n  \\<subseteq> \\<up>Abs_dense (y \\<squnion> - y \\<squnion> x)\n\ngoal (1 subgoal):\n 1. Filters.filter.Abs_filter\n     (Filters.filter.Rep_filter\n       (stone_phi (Abs_regular (- x)) \\<sqinter>\n        up_filter (Abs_dense (y \\<squnion> - y))))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "by (simp add: eq_onp_same_args less_eq_filter.abs_eq)"], ["proof (state)\nthis:\n  Filters.filter.Abs_filter\n   (Filters.filter.Rep_filter\n     (stone_phi (Abs_regular (- x)) \\<sqinter>\n      up_filter (Abs_dense (y \\<squnion> - y))))\n  \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Filters.filter.Abs_filter\n   (Filters.filter.Rep_filter\n     (stone_phi (Abs_regular (- x)) \\<sqinter>\n      up_filter (Abs_dense (y \\<squnion> - y))))\n  \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "by (simp add: Rep_filter_inverse)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  up_filter (Abs_dense (y \\<squnion> - y))\n  \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stone_phi_complement:\n  \"complement (stone_phi (Abs_regular (-x))) (stone_phi (Abs_regular (--x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complement (stone_phi (Abs_regular (- x)))\n     (stone_phi (Abs_regular (- - x)))", "by (metis (mono_tags, lifting) eq_onp_same_args stone_phi.phi_complemented uminus_regular.abs_eq)"], ["", "lemma up_dense_stone_phi:\n  \"up_filter (Abs_dense (x \\<squnion> -x)) \\<le> stone_phi (Abs_regular (--x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x))\n    \\<le> stone_phi (Abs_regular (- - x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x))\n    \\<le> stone_phi (Abs_regular (- - x))", "have \"\\<up>(Abs_dense (x \\<squnion> -x)) \\<le> stone_phi_base (Abs_regular (--x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>Abs_dense (x \\<squnion> - x)\n    \\<subseteq> stone_phi_base (Abs_regular (- - x))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense (x \\<squnion> - x) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (Abs_regular (- - x))", "fix z :: \"'a dense\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense (x \\<squnion> - x) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (Abs_regular (- - x))", "let ?r = \"Rep_dense z\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense (x \\<squnion> - x) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (Abs_regular (- - x))", "assume \"z \\<in> \\<up>(Abs_dense (x \\<squnion> -x))\""], ["proof (state)\nthis:\n  z \\<in> \\<up>Abs_dense (x \\<squnion> - x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense (x \\<squnion> - x) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (Abs_regular (- - x))", "hence \"---x \\<le> ?r\""], ["proof (prove)\nusing this:\n  z \\<in> \\<up>Abs_dense (x \\<squnion> - x)\n\ngoal (1 subgoal):\n 1. - - - x \\<le> Rep_dense z", "by (simp add: Abs_dense_inverse less_eq_dense.rep_eq)"], ["proof (state)\nthis:\n  - - - x \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense (x \\<squnion> - x) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (Abs_regular (- - x))", "hence \"-Rep_regular (Abs_regular (--x)) \\<le> ?r\""], ["proof (prove)\nusing this:\n  - - - x \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. - Rep_regular (Abs_regular (- - x)) \\<le> Rep_dense z", "by (metis (mono_tags, lifting) Abs_regular_inverse mem_Collect_eq)"], ["proof (state)\nthis:\n  - Rep_regular (Abs_regular (- - x)) \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense (x \\<squnion> - x) \\<Longrightarrow>\n       xa \\<in> stone_phi_base (Abs_regular (- - x))", "thus \"z \\<in> stone_phi_base (Abs_regular (--x))\""], ["proof (prove)\nusing this:\n  - Rep_regular (Abs_regular (- - x)) \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. z \\<in> stone_phi_base (Abs_regular (- - x))", "by simp"], ["proof (state)\nthis:\n  z \\<in> stone_phi_base (Abs_regular (- - x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<up>Abs_dense (x \\<squnion> - x)\n  \\<subseteq> stone_phi_base (Abs_regular (- - x))\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x))\n    \\<le> stone_phi (Abs_regular (- - x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<up>Abs_dense (x \\<squnion> - x)\n  \\<subseteq> stone_phi_base (Abs_regular (- - x))\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x))\n    \\<le> stone_phi (Abs_regular (- - x))", "by (unfold stone_phi_def, subst less_eq_filter.abs_eq, simp_all add: eq_onp_same_args stone_phi_base_filter)"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> - x))\n  \\<le> stone_phi (Abs_regular (- - x))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe following two results prove that the isomorphisms are mutually inverse.\n\\<close>"], ["", "lemma sa_iso_left_invertible:\n  \"sa_iso_inv (sa_iso x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "have \"up_filter (triple.rho_pair stone_phi (Abs_regular (--x),stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x)))) = stone_phi (Abs_regular (--x)) \\<sqinter> (stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_filter\n     (stone_phi.rho_pair\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x)))) =\n    stone_phi (Abs_regular (- - x)) \\<sqinter>\n    (stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x)))", "using sa_iso_triple_pair stone_phi.get_rho_pair_char"], ["proof (prove)\nusing this:\n  (Abs_regular (- - ?x),\n   stone_phi (Abs_regular (- ?x)) \\<squnion>\n   up_filter (Abs_dense (?x \\<squnion> - ?x)))\n  \\<in> stone_phi.pairs\n  (?x, ?y) \\<in> stone_phi.pairs \\<Longrightarrow>\n  up_filter (stone_phi.rho_pair (?x, ?y)) = stone_phi ?x \\<sqinter> ?y\n\ngoal (1 subgoal):\n 1. up_filter\n     (stone_phi.rho_pair\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x)))) =\n    stone_phi (Abs_regular (- - x)) \\<sqinter>\n    (stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x)))", "by blast"], ["proof (state)\nthis:\n  up_filter\n   (stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))) =\n  stone_phi (Abs_regular (- - x)) \\<sqinter>\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x)))\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "also"], ["proof (state)\nthis:\n  up_filter\n   (stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))) =\n  stone_phi (Abs_regular (- - x)) \\<sqinter>\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x)))\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "have \"... = stone_phi (Abs_regular (--x)) \\<sqinter> up_filter (Abs_dense (x \\<squnion> -x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- - x)) \\<sqinter>\n    (stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x))) =\n    stone_phi (Abs_regular (- - x)) \\<sqinter>\n    up_filter (Abs_dense (x \\<squnion> - x))", "by (simp add: inf.sup_commute inf_sup_distrib1 stone_phi_complement)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- - x)) \\<sqinter>\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x))) =\n  stone_phi (Abs_regular (- - x)) \\<sqinter>\n  up_filter (Abs_dense (x \\<squnion> - x))\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "also"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- - x)) \\<sqinter>\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x))) =\n  stone_phi (Abs_regular (- - x)) \\<sqinter>\n  up_filter (Abs_dense (x \\<squnion> - x))\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "have \"... = up_filter (Abs_dense (x \\<squnion> -x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- - x)) \\<sqinter>\n    up_filter (Abs_dense (x \\<squnion> - x)) =\n    up_filter (Abs_dense (x \\<squnion> - x))", "using up_dense_stone_phi inf.absorb2"], ["proof (prove)\nusing this:\n  up_filter (Abs_dense (?x \\<squnion> - ?x))\n  \\<le> stone_phi (Abs_regular (- - ?x))\n  ?b \\<le> ?a \\<Longrightarrow> ?a \\<sqinter> ?b = ?b\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- - x)) \\<sqinter>\n    up_filter (Abs_dense (x \\<squnion> - x)) =\n    up_filter (Abs_dense (x \\<squnion> - x))", "by auto"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- - x)) \\<sqinter>\n  up_filter (Abs_dense (x \\<squnion> - x)) =\n  up_filter (Abs_dense (x \\<squnion> - x))\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "finally"], ["proof (chain)\npicking this:\n  up_filter\n   (stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))) =\n  up_filter (Abs_dense (x \\<squnion> - x))", "have 1: \"triple.rho_pair stone_phi (Abs_regular (--x),stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) = Abs_dense (x \\<squnion> -x)\""], ["proof (prove)\nusing this:\n  up_filter\n   (stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))) =\n  up_filter (Abs_dense (x \\<squnion> - x))\n\ngoal (1 subgoal):\n 1. stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x))) =\n    Abs_dense (x \\<squnion> - x)", "using up_filter_injective"], ["proof (prove)\nusing this:\n  up_filter\n   (stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))) =\n  up_filter (Abs_dense (x \\<squnion> - x))\n  up_filter ?x = up_filter ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x))) =\n    Abs_dense (x \\<squnion> - x)", "by auto"], ["proof (state)\nthis:\n  stone_phi.rho_pair\n   (Abs_regular (- - x),\n    stone_phi (Abs_regular (- x)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x))) =\n  Abs_dense (x \\<squnion> - x)\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "have \"sa_iso_inv (sa_iso x) = (\\<lambda>p . Rep_regular (fst p) \\<sqinter> Rep_dense (triple.rho_pair stone_phi p)) (Abs_regular (--x),stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) =\n    Rep_regular\n     (fst (Abs_regular (- - x),\n           stone_phi (Abs_regular (- x)) \\<squnion>\n           up_filter (Abs_dense (x \\<squnion> - x)))) \\<sqinter>\n    Rep_dense\n     (stone_phi.rho_pair\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x))))", "by (simp add: Abs_stone_phi_pair_inverse sa_iso_triple_pair)"], ["proof (state)\nthis:\n  sa_iso_inv (sa_iso x) =\n  Rep_regular\n   (fst (Abs_regular (- - x),\n         stone_phi (Abs_regular (- x)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x)))) \\<sqinter>\n  Rep_dense\n   (stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x))))\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "also"], ["proof (state)\nthis:\n  sa_iso_inv (sa_iso x) =\n  Rep_regular\n   (fst (Abs_regular (- - x),\n         stone_phi (Abs_regular (- x)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x)))) \\<sqinter>\n  Rep_dense\n   (stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x))))\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "have \"... = Rep_regular (Abs_regular (--x)) \\<sqinter> Rep_dense (triple.rho_pair stone_phi (Abs_regular (--x),stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_regular\n     (fst (Abs_regular (- - x),\n           stone_phi (Abs_regular (- x)) \\<squnion>\n           up_filter (Abs_dense (x \\<squnion> - x)))) \\<sqinter>\n    Rep_dense\n     (stone_phi.rho_pair\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x)))) =\n    Rep_regular (Abs_regular (- - x)) \\<sqinter>\n    Rep_dense\n     (stone_phi.rho_pair\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x))))", "by simp"], ["proof (state)\nthis:\n  Rep_regular\n   (fst (Abs_regular (- - x),\n         stone_phi (Abs_regular (- x)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x)))) \\<sqinter>\n  Rep_dense\n   (stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))) =\n  Rep_regular (Abs_regular (- - x)) \\<sqinter>\n  Rep_dense\n   (stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x))))\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "also"], ["proof (state)\nthis:\n  Rep_regular\n   (fst (Abs_regular (- - x),\n         stone_phi (Abs_regular (- x)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x)))) \\<sqinter>\n  Rep_dense\n   (stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))) =\n  Rep_regular (Abs_regular (- - x)) \\<sqinter>\n  Rep_dense\n   (stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x))))\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "have \"... = --x \\<sqinter> Rep_dense (Abs_dense (x \\<squnion> -x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_regular (Abs_regular (- - x)) \\<sqinter>\n    Rep_dense\n     (stone_phi.rho_pair\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x)))) =\n    - - x \\<sqinter> Rep_dense (Abs_dense (x \\<squnion> - x))", "using 1"], ["proof (prove)\nusing this:\n  stone_phi.rho_pair\n   (Abs_regular (- - x),\n    stone_phi (Abs_regular (- x)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x))) =\n  Abs_dense (x \\<squnion> - x)\n\ngoal (1 subgoal):\n 1. Rep_regular (Abs_regular (- - x)) \\<sqinter>\n    Rep_dense\n     (stone_phi.rho_pair\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x)))) =\n    - - x \\<sqinter> Rep_dense (Abs_dense (x \\<squnion> - x))", "by (subst Abs_regular_inverse) auto"], ["proof (state)\nthis:\n  Rep_regular (Abs_regular (- - x)) \\<sqinter>\n  Rep_dense\n   (stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))) =\n  - - x \\<sqinter> Rep_dense (Abs_dense (x \\<squnion> - x))\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "also"], ["proof (state)\nthis:\n  Rep_regular (Abs_regular (- - x)) \\<sqinter>\n  Rep_dense\n   (stone_phi.rho_pair\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))) =\n  - - x \\<sqinter> Rep_dense (Abs_dense (x \\<squnion> - x))\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "have \"... = --x \\<sqinter> (x \\<squnion> -x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x \\<sqinter> Rep_dense (Abs_dense (x \\<squnion> - x)) =\n    - - x \\<sqinter> (x \\<squnion> - x)", "by (subst Abs_dense_inverse) simp_all"], ["proof (state)\nthis:\n  - - x \\<sqinter> Rep_dense (Abs_dense (x \\<squnion> - x)) =\n  - - x \\<sqinter> (x \\<squnion> - x)\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "also"], ["proof (state)\nthis:\n  - - x \\<sqinter> Rep_dense (Abs_dense (x \\<squnion> - x)) =\n  - - x \\<sqinter> (x \\<squnion> - x)\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "have \"... = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x \\<sqinter> (x \\<squnion> - x) = x", "by simp"], ["proof (state)\nthis:\n  - - x \\<sqinter> (x \\<squnion> - x) = x\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "finally"], ["proof (chain)\npicking this:\n  sa_iso_inv (sa_iso x) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  sa_iso_inv (sa_iso x) = x\n\ngoal (1 subgoal):\n 1. sa_iso_inv (sa_iso x) = x", "by auto"], ["proof (state)\nthis:\n  sa_iso_inv (sa_iso x) = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sa_iso_right_invertible:\n  \"sa_iso (sa_iso_inv p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "obtain x y where 1: \"(x,y) = Rep_stone_phi_pair p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        (x, y) = Rep_stone_phi_pair p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        (x, y) = Rep_stone_phi_pair p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x, y) = Rep_stone_phi_pair p\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "hence 2: \"(x,y) \\<in> triple.pairs stone_phi\""], ["proof (prove)\nusing this:\n  (x, y) = Rep_stone_phi_pair p\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> stone_phi.pairs", "by (simp add: Rep_stone_phi_pair)"], ["proof (state)\nthis:\n  (x, y) \\<in> stone_phi.pairs\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "hence 3: \"stone_phi (-x) \\<le> y\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> stone_phi.pairs\n\ngoal (1 subgoal):\n 1. stone_phi (- x) \\<le> y", "by (simp add: stone_phi.pairs_phi_less_eq)"], ["proof (state)\nthis:\n  stone_phi (- x) \\<le> y\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "have 4: \"\\<forall>z . z \\<in> Rep_filter (stone_phi x \\<sqinter> y) \\<longrightarrow> -Rep_regular x \\<le> Rep_dense z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       z \\<in> Filters.filter.Rep_filter\n                (stone_phi x \\<sqinter> y) \\<longrightarrow>\n       - Rep_regular x \\<le> Rep_dense z", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> Filters.filter.Rep_filter\n                (stone_phi x \\<sqinter> y) \\<Longrightarrow>\n       - Rep_regular x \\<le> Rep_dense z", "fix z :: \"'a dense\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> Filters.filter.Rep_filter\n                (stone_phi x \\<sqinter> y) \\<Longrightarrow>\n       - Rep_regular x \\<le> Rep_dense z", "let ?r = \"Rep_dense z\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> Filters.filter.Rep_filter\n                (stone_phi x \\<sqinter> y) \\<Longrightarrow>\n       - Rep_regular x \\<le> Rep_dense z", "assume \"z \\<in> Rep_filter (stone_phi x \\<sqinter> y)\""], ["proof (state)\nthis:\n  z \\<in> Filters.filter.Rep_filter (stone_phi x \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> Filters.filter.Rep_filter\n                (stone_phi x \\<sqinter> y) \\<Longrightarrow>\n       - Rep_regular x \\<le> Rep_dense z", "hence \"z \\<in> Rep_filter (stone_phi x)\""], ["proof (prove)\nusing this:\n  z \\<in> Filters.filter.Rep_filter (stone_phi x \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. z \\<in> Filters.filter.Rep_filter (stone_phi x)", "by (simp add: inf_filter.rep_eq)"], ["proof (state)\nthis:\n  z \\<in> Filters.filter.Rep_filter (stone_phi x)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> Filters.filter.Rep_filter\n                (stone_phi x \\<sqinter> y) \\<Longrightarrow>\n       - Rep_regular x \\<le> Rep_dense z", "also"], ["proof (state)\nthis:\n  z \\<in> Filters.filter.Rep_filter (stone_phi x)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> Filters.filter.Rep_filter\n                (stone_phi x \\<sqinter> y) \\<Longrightarrow>\n       - Rep_regular x \\<le> Rep_dense z", "have \"... = stone_phi_base x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filters.filter.Rep_filter (stone_phi x) = stone_phi_base x", "by (simp add: stone_phi_def Abs_filter_inverse stone_phi_base_filter)"], ["proof (state)\nthis:\n  Filters.filter.Rep_filter (stone_phi x) = stone_phi_base x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> Filters.filter.Rep_filter\n                (stone_phi x \\<sqinter> y) \\<Longrightarrow>\n       - Rep_regular x \\<le> Rep_dense z", "finally"], ["proof (chain)\npicking this:\n  z \\<in> stone_phi_base x", "show \"-Rep_regular x \\<le> ?r\""], ["proof (prove)\nusing this:\n  z \\<in> stone_phi_base x\n\ngoal (1 subgoal):\n 1. - Rep_regular x \\<le> Rep_dense z", "by simp"], ["proof (state)\nthis:\n  - Rep_regular x \\<le> Rep_dense z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>z.\n     z \\<in> Filters.filter.Rep_filter\n              (stone_phi x \\<sqinter> y) \\<longrightarrow>\n     - Rep_regular x \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "have \"triple.rho_pair stone_phi (x,y) \\<in> \\<up>(triple.rho_pair stone_phi (x,y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi.rho_pair (x, y) \\<in> \\<up>stone_phi.rho_pair (x, y)", "by simp"], ["proof (state)\nthis:\n  stone_phi.rho_pair (x, y) \\<in> \\<up>stone_phi.rho_pair (x, y)\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "also"], ["proof (state)\nthis:\n  stone_phi.rho_pair (x, y) \\<in> \\<up>stone_phi.rho_pair (x, y)\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "have \"... = Rep_filter (Abs_filter (\\<up>(triple.rho_pair stone_phi (x,y))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>stone_phi.rho_pair (x, y) =\n    Filters.filter.Rep_filter (up_filter (stone_phi.rho_pair (x, y)))", "by (simp add: Abs_filter_inverse)"], ["proof (state)\nthis:\n  \\<up>stone_phi.rho_pair (x, y) =\n  Filters.filter.Rep_filter (up_filter (stone_phi.rho_pair (x, y)))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "also"], ["proof (state)\nthis:\n  \\<up>stone_phi.rho_pair (x, y) =\n  Filters.filter.Rep_filter (up_filter (stone_phi.rho_pair (x, y)))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "have \"... = Rep_filter (stone_phi x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filters.filter.Rep_filter (up_filter (stone_phi.rho_pair (x, y))) =\n    Filters.filter.Rep_filter (stone_phi x \\<sqinter> y)", "using 2 stone_phi.get_rho_pair_char"], ["proof (prove)\nusing this:\n  (x, y) \\<in> stone_phi.pairs\n  (?x, ?y) \\<in> stone_phi.pairs \\<Longrightarrow>\n  up_filter (stone_phi.rho_pair (?x, ?y)) = stone_phi ?x \\<sqinter> ?y\n\ngoal (1 subgoal):\n 1. Filters.filter.Rep_filter (up_filter (stone_phi.rho_pair (x, y))) =\n    Filters.filter.Rep_filter (stone_phi x \\<sqinter> y)", "by fastforce"], ["proof (state)\nthis:\n  Filters.filter.Rep_filter (up_filter (stone_phi.rho_pair (x, y))) =\n  Filters.filter.Rep_filter (stone_phi x \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "finally"], ["proof (chain)\npicking this:\n  stone_phi.rho_pair (x, y)\n  \\<in> Filters.filter.Rep_filter (stone_phi x \\<sqinter> y)", "have \"triple.rho_pair stone_phi (x,y) \\<in> Rep_filter (stone_phi x \\<sqinter> y)\""], ["proof (prove)\nusing this:\n  stone_phi.rho_pair (x, y)\n  \\<in> Filters.filter.Rep_filter (stone_phi x \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. stone_phi.rho_pair (x, y)\n    \\<in> Filters.filter.Rep_filter (stone_phi x \\<sqinter> y)", "by simp"], ["proof (state)\nthis:\n  stone_phi.rho_pair (x, y)\n  \\<in> Filters.filter.Rep_filter (stone_phi x \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "hence 5: \"-Rep_regular x \\<le> Rep_dense (triple.rho_pair stone_phi (x,y))\""], ["proof (prove)\nusing this:\n  stone_phi.rho_pair (x, y)\n  \\<in> Filters.filter.Rep_filter (stone_phi x \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. - Rep_regular x \\<le> Rep_dense (stone_phi.rho_pair (x, y))", "using 4"], ["proof (prove)\nusing this:\n  stone_phi.rho_pair (x, y)\n  \\<in> Filters.filter.Rep_filter (stone_phi x \\<sqinter> y)\n  \\<forall>z.\n     z \\<in> Filters.filter.Rep_filter\n              (stone_phi x \\<sqinter> y) \\<longrightarrow>\n     - Rep_regular x \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. - Rep_regular x \\<le> Rep_dense (stone_phi.rho_pair (x, y))", "by simp"], ["proof (state)\nthis:\n  - Rep_regular x \\<le> Rep_dense (stone_phi.rho_pair (x, y))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "have 6: \"sa_iso_inv p = Rep_regular x \\<sqinter> Rep_dense (triple.rho_pair stone_phi (x,y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sa_iso_inv p =\n    Rep_regular x \\<sqinter> Rep_dense (stone_phi.rho_pair (x, y))", "using 1"], ["proof (prove)\nusing this:\n  (x, y) = Rep_stone_phi_pair p\n\ngoal (1 subgoal):\n 1. sa_iso_inv p =\n    Rep_regular x \\<sqinter> Rep_dense (stone_phi.rho_pair (x, y))", "by (metis fstI)"], ["proof (state)\nthis:\n  sa_iso_inv p =\n  Rep_regular x \\<sqinter> Rep_dense (stone_phi.rho_pair (x, y))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "hence \"-sa_iso_inv p = -Rep_regular x\""], ["proof (prove)\nusing this:\n  sa_iso_inv p =\n  Rep_regular x \\<sqinter> Rep_dense (stone_phi.rho_pair (x, y))\n\ngoal (1 subgoal):\n 1. - sa_iso_inv p = - Rep_regular x", "by simp"], ["proof (state)\nthis:\n  - sa_iso_inv p = - Rep_regular x\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "hence \"sa_iso (sa_iso_inv p) = Abs_stone_phi_pair (Abs_regular (--Rep_regular x),stone_phi (Abs_regular (-Rep_regular x)) \\<squnion> up_filter (Abs_dense ((Rep_regular x \\<sqinter> Rep_dense (triple.rho_pair stone_phi (x,y))) \\<squnion> -Rep_regular x)))\""], ["proof (prove)\nusing this:\n  - sa_iso_inv p = - Rep_regular x\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) =\n    Abs_stone_phi_pair\n     (Abs_regular (- - Rep_regular x),\n      stone_phi (Abs_regular (- Rep_regular x)) \\<squnion>\n      up_filter\n       (Abs_dense\n         (Rep_regular x \\<sqinter>\n          Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n          - Rep_regular x)))", "using 6"], ["proof (prove)\nusing this:\n  - sa_iso_inv p = - Rep_regular x\n  sa_iso_inv p =\n  Rep_regular x \\<sqinter> Rep_dense (stone_phi.rho_pair (x, y))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) =\n    Abs_stone_phi_pair\n     (Abs_regular (- - Rep_regular x),\n      stone_phi (Abs_regular (- Rep_regular x)) \\<squnion>\n      up_filter\n       (Abs_dense\n         (Rep_regular x \\<sqinter>\n          Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n          - Rep_regular x)))", "by simp"], ["proof (state)\nthis:\n  sa_iso (sa_iso_inv p) =\n  Abs_stone_phi_pair\n   (Abs_regular (- - Rep_regular x),\n    stone_phi (Abs_regular (- Rep_regular x)) \\<squnion>\n    up_filter\n     (Abs_dense\n       (Rep_regular x \\<sqinter>\n        Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n        - Rep_regular x)))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "also"], ["proof (state)\nthis:\n  sa_iso (sa_iso_inv p) =\n  Abs_stone_phi_pair\n   (Abs_regular (- - Rep_regular x),\n    stone_phi (Abs_regular (- Rep_regular x)) \\<squnion>\n    up_filter\n     (Abs_dense\n       (Rep_regular x \\<sqinter>\n        Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n        - Rep_regular x)))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "have \"... = Abs_stone_phi_pair (x,stone_phi (-x) \\<squnion> up_filter (Abs_dense ((Rep_regular x \\<sqinter> Rep_dense (triple.rho_pair stone_phi (x,y))) \\<squnion> -Rep_regular x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (Abs_regular (- - Rep_regular x),\n      stone_phi (Abs_regular (- Rep_regular x)) \\<squnion>\n      up_filter\n       (Abs_dense\n         (Rep_regular x \\<sqinter>\n          Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n          - Rep_regular x))) =\n    Abs_stone_phi_pair\n     (x, stone_phi (- x) \\<squnion>\n         up_filter\n          (Abs_dense\n            (Rep_regular x \\<sqinter>\n             Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n             - Rep_regular x)))", "by (metis (mono_tags, lifting) Rep_regular_inverse double_compl uminus_regular.rep_eq)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (Abs_regular (- - Rep_regular x),\n    stone_phi (Abs_regular (- Rep_regular x)) \\<squnion>\n    up_filter\n     (Abs_dense\n       (Rep_regular x \\<sqinter>\n        Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n        - Rep_regular x))) =\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion>\n       up_filter\n        (Abs_dense\n          (Rep_regular x \\<sqinter>\n           Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n           - Rep_regular x)))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "also"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (Abs_regular (- - Rep_regular x),\n    stone_phi (Abs_regular (- Rep_regular x)) \\<squnion>\n    up_filter\n     (Abs_dense\n       (Rep_regular x \\<sqinter>\n        Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n        - Rep_regular x))) =\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion>\n       up_filter\n        (Abs_dense\n          (Rep_regular x \\<sqinter>\n           Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n           - Rep_regular x)))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "have \"... = Abs_stone_phi_pair (x,stone_phi (-x) \\<squnion> up_filter (Abs_dense (Rep_dense (triple.rho_pair stone_phi (x,y)) \\<squnion> -Rep_regular x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (x, stone_phi (- x) \\<squnion>\n         up_filter\n          (Abs_dense\n            (Rep_regular x \\<sqinter>\n             Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n             - Rep_regular x))) =\n    Abs_stone_phi_pair\n     (x, stone_phi (- x) \\<squnion>\n         up_filter\n          (Abs_dense\n            (Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n             - Rep_regular x)))", "by (metis inf_sup_aci(5) maddux_3_21_pp simp_regular)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion>\n       up_filter\n        (Abs_dense\n          (Rep_regular x \\<sqinter>\n           Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n           - Rep_regular x))) =\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion>\n       up_filter\n        (Abs_dense\n          (Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n           - Rep_regular x)))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "also"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion>\n       up_filter\n        (Abs_dense\n          (Rep_regular x \\<sqinter>\n           Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n           - Rep_regular x))) =\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion>\n       up_filter\n        (Abs_dense\n          (Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n           - Rep_regular x)))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "have \"... = Abs_stone_phi_pair (x,stone_phi (-x) \\<squnion> up_filter (Abs_dense (Rep_dense (triple.rho_pair stone_phi (x,y)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (x, stone_phi (- x) \\<squnion>\n         up_filter\n          (Abs_dense\n            (Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n             - Rep_regular x))) =\n    Abs_stone_phi_pair\n     (x, stone_phi (- x) \\<squnion>\n         up_filter (Abs_dense (Rep_dense (stone_phi.rho_pair (x, y)))))", "using 5"], ["proof (prove)\nusing this:\n  - Rep_regular x \\<le> Rep_dense (stone_phi.rho_pair (x, y))\n\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (x, stone_phi (- x) \\<squnion>\n         up_filter\n          (Abs_dense\n            (Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n             - Rep_regular x))) =\n    Abs_stone_phi_pair\n     (x, stone_phi (- x) \\<squnion>\n         up_filter (Abs_dense (Rep_dense (stone_phi.rho_pair (x, y)))))", "by (simp add: sup.absorb1)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion>\n       up_filter\n        (Abs_dense\n          (Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n           - Rep_regular x))) =\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion>\n       up_filter (Abs_dense (Rep_dense (stone_phi.rho_pair (x, y)))))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "also"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion>\n       up_filter\n        (Abs_dense\n          (Rep_dense (stone_phi.rho_pair (x, y)) \\<squnion>\n           - Rep_regular x))) =\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion>\n       up_filter (Abs_dense (Rep_dense (stone_phi.rho_pair (x, y)))))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "have \"... = Abs_stone_phi_pair (x,stone_phi (-x) \\<squnion> up_filter (triple.rho_pair stone_phi (x,y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (x, stone_phi (- x) \\<squnion>\n         up_filter (Abs_dense (Rep_dense (stone_phi.rho_pair (x, y))))) =\n    Abs_stone_phi_pair\n     (x, stone_phi (- x) \\<squnion> up_filter (stone_phi.rho_pair (x, y)))", "by (simp add: Rep_dense_inverse)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion>\n       up_filter (Abs_dense (Rep_dense (stone_phi.rho_pair (x, y))))) =\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion> up_filter (stone_phi.rho_pair (x, y)))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "also"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion>\n       up_filter (Abs_dense (Rep_dense (stone_phi.rho_pair (x, y))))) =\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion> up_filter (stone_phi.rho_pair (x, y)))\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "have \"... = Abs_stone_phi_pair (x,stone_phi (-x) \\<squnion> (stone_phi x \\<sqinter> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (x, stone_phi (- x) \\<squnion> up_filter (stone_phi.rho_pair (x, y))) =\n    Abs_stone_phi_pair\n     (x, stone_phi (- x) \\<squnion> stone_phi x \\<sqinter> y)", "using 2 stone_phi.get_rho_pair_char"], ["proof (prove)\nusing this:\n  (x, y) \\<in> stone_phi.pairs\n  (?x, ?y) \\<in> stone_phi.pairs \\<Longrightarrow>\n  up_filter (stone_phi.rho_pair (?x, ?y)) = stone_phi ?x \\<sqinter> ?y\n\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (x, stone_phi (- x) \\<squnion> up_filter (stone_phi.rho_pair (x, y))) =\n    Abs_stone_phi_pair\n     (x, stone_phi (- x) \\<squnion> stone_phi x \\<sqinter> y)", "by fastforce"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion> up_filter (stone_phi.rho_pair (x, y))) =\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion> stone_phi x \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "also"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion> up_filter (stone_phi.rho_pair (x, y))) =\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion> stone_phi x \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "have \"... = Abs_stone_phi_pair (x,stone_phi (-x) \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (x, stone_phi (- x) \\<squnion> stone_phi x \\<sqinter> y) =\n    Abs_stone_phi_pair (x, stone_phi (- x) \\<squnion> y)", "by (simp add: stone_phi.phi_complemented sup.commute sup_inf_distrib1)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion> stone_phi x \\<sqinter> y) =\n  Abs_stone_phi_pair (x, stone_phi (- x) \\<squnion> y)\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "also"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (x, stone_phi (- x) \\<squnion> stone_phi x \\<sqinter> y) =\n  Abs_stone_phi_pair (x, stone_phi (- x) \\<squnion> y)\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "have \"... = Abs_stone_phi_pair (x,y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair (x, stone_phi (- x) \\<squnion> y) =\n    Abs_stone_phi_pair (x, y)", "using 3"], ["proof (prove)\nusing this:\n  stone_phi (- x) \\<le> y\n\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair (x, stone_phi (- x) \\<squnion> y) =\n    Abs_stone_phi_pair (x, y)", "by (simp add: le_iff_sup)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair (x, stone_phi (- x) \\<squnion> y) =\n  Abs_stone_phi_pair (x, y)\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "also"], ["proof (state)\nthis:\n  Abs_stone_phi_pair (x, stone_phi (- x) \\<squnion> y) =\n  Abs_stone_phi_pair (x, y)\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "have \"... = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair (x, y) = p", "using 1"], ["proof (prove)\nusing this:\n  (x, y) = Rep_stone_phi_pair p\n\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair (x, y) = p", "by (simp add: Rep_stone_phi_pair_inverse)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair (x, y) = p\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "finally"], ["proof (chain)\npicking this:\n  sa_iso (sa_iso_inv p) = p", "show ?thesis"], ["proof (prove)\nusing this:\n  sa_iso (sa_iso_inv p) = p\n\ngoal (1 subgoal):\n 1. sa_iso (sa_iso_inv p) = p", "."], ["proof (state)\nthis:\n  sa_iso (sa_iso_inv p) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nIt remains to show the homomorphism properties, which is done in the following result.\n\\<close>"], ["", "lemma sa_iso:\n  \"stone_algebra_isomorphism sa_iso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bounded_lattice_homomorphism sa_iso \\<and>\n     uminus_homomorphism sa_iso) \\<and>\n    bij sa_iso", "proof (intro conjI)"], ["proof (state)\ngoal (6 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. top_homomorphism sa_iso\n 4. bot_homomorphism sa_iso\n 5. uminus_homomorphism sa_iso\n 6. bij sa_iso", "have \"Abs_stone_phi_pair (Abs_regular (--bot),stone_phi (Abs_regular (-bot)) \\<squnion> up_filter (Abs_dense (bot \\<squnion> -bot))) = Abs_stone_phi_pair (bot,stone_phi top \\<squnion> up_filter top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (Abs_regular (- - bot),\n      stone_phi (Abs_regular (- bot)) \\<squnion>\n      up_filter (Abs_dense (bot \\<squnion> - bot))) =\n    Abs_stone_phi_pair (bot, stone_phi top \\<squnion> up_filter top)", "by (simp add: bot_regular.abs_eq top_regular.abs_eq top_dense.abs_eq)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (Abs_regular (- - bot),\n    stone_phi (Abs_regular (- bot)) \\<squnion>\n    up_filter (Abs_dense (bot \\<squnion> - bot))) =\n  Abs_stone_phi_pair (bot, stone_phi top \\<squnion> up_filter top)\n\ngoal (6 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. top_homomorphism sa_iso\n 4. bot_homomorphism sa_iso\n 5. uminus_homomorphism sa_iso\n 6. bij sa_iso", "also"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (Abs_regular (- - bot),\n    stone_phi (Abs_regular (- bot)) \\<squnion>\n    up_filter (Abs_dense (bot \\<squnion> - bot))) =\n  Abs_stone_phi_pair (bot, stone_phi top \\<squnion> up_filter top)\n\ngoal (6 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. top_homomorphism sa_iso\n 4. bot_homomorphism sa_iso\n 5. uminus_homomorphism sa_iso\n 6. bij sa_iso", "have \"... = Abs_stone_phi_pair (bot,stone_phi top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair (bot, stone_phi top \\<squnion> up_filter top) =\n    Abs_stone_phi_pair (bot, stone_phi top)", "by (simp add: stone_phi.hom)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair (bot, stone_phi top \\<squnion> up_filter top) =\n  Abs_stone_phi_pair (bot, stone_phi top)\n\ngoal (6 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. top_homomorphism sa_iso\n 4. bot_homomorphism sa_iso\n 5. uminus_homomorphism sa_iso\n 6. bij sa_iso", "also"], ["proof (state)\nthis:\n  Abs_stone_phi_pair (bot, stone_phi top \\<squnion> up_filter top) =\n  Abs_stone_phi_pair (bot, stone_phi top)\n\ngoal (6 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. top_homomorphism sa_iso\n 4. bot_homomorphism sa_iso\n 5. uminus_homomorphism sa_iso\n 6. bij sa_iso", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair (bot, stone_phi top) = bot", "by (simp add: bot_stone_phi_pair_def stone_phi.phi_top)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair (bot, stone_phi top) = bot\n\ngoal (6 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. top_homomorphism sa_iso\n 4. bot_homomorphism sa_iso\n 5. uminus_homomorphism sa_iso\n 6. bij sa_iso", "finally"], ["proof (chain)\npicking this:\n  Abs_stone_phi_pair\n   (Abs_regular (- - bot),\n    stone_phi (Abs_regular (- bot)) \\<squnion>\n    up_filter (Abs_dense (bot \\<squnion> - bot))) =\n  bot", "show \"sa_iso bot = bot\""], ["proof (prove)\nusing this:\n  Abs_stone_phi_pair\n   (Abs_regular (- - bot),\n    stone_phi (Abs_regular (- bot)) \\<squnion>\n    up_filter (Abs_dense (bot \\<squnion> - bot))) =\n  bot\n\ngoal (1 subgoal):\n 1. bot_homomorphism sa_iso", "."], ["proof (state)\nthis:\n  bot_homomorphism sa_iso\n\ngoal (5 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. top_homomorphism sa_iso\n 4. uminus_homomorphism sa_iso\n 5. bij sa_iso", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. top_homomorphism sa_iso\n 4. uminus_homomorphism sa_iso\n 5. bij sa_iso", "have \"Abs_stone_phi_pair (Abs_regular (--top),stone_phi (Abs_regular (-top)) \\<squnion> up_filter (Abs_dense (top \\<squnion> -top))) = Abs_stone_phi_pair (top,stone_phi bot \\<squnion> up_filter top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (Abs_regular (- - top),\n      stone_phi (Abs_regular (- top)) \\<squnion>\n      up_filter (Abs_dense (top \\<squnion> - top))) =\n    Abs_stone_phi_pair (top, stone_phi bot \\<squnion> up_filter top)", "by (simp add: bot_regular.abs_eq top_regular.abs_eq top_dense.abs_eq)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (Abs_regular (- - top),\n    stone_phi (Abs_regular (- top)) \\<squnion>\n    up_filter (Abs_dense (top \\<squnion> - top))) =\n  Abs_stone_phi_pair (top, stone_phi bot \\<squnion> up_filter top)\n\ngoal (5 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. top_homomorphism sa_iso\n 4. uminus_homomorphism sa_iso\n 5. bij sa_iso", "also"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (Abs_regular (- - top),\n    stone_phi (Abs_regular (- top)) \\<squnion>\n    up_filter (Abs_dense (top \\<squnion> - top))) =\n  Abs_stone_phi_pair (top, stone_phi bot \\<squnion> up_filter top)\n\ngoal (5 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. top_homomorphism sa_iso\n 4. uminus_homomorphism sa_iso\n 5. bij sa_iso", "have \"... = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair (top, stone_phi bot \\<squnion> up_filter top) = top", "by (simp add: stone_phi.phi_bot top_stone_phi_pair_def)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair (top, stone_phi bot \\<squnion> up_filter top) = top\n\ngoal (5 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. top_homomorphism sa_iso\n 4. uminus_homomorphism sa_iso\n 5. bij sa_iso", "finally"], ["proof (chain)\npicking this:\n  Abs_stone_phi_pair\n   (Abs_regular (- - top),\n    stone_phi (Abs_regular (- top)) \\<squnion>\n    up_filter (Abs_dense (top \\<squnion> - top))) =\n  top", "show \"sa_iso top = top\""], ["proof (prove)\nusing this:\n  Abs_stone_phi_pair\n   (Abs_regular (- - top),\n    stone_phi (Abs_regular (- top)) \\<squnion>\n    up_filter (Abs_dense (top \\<squnion> - top))) =\n  top\n\ngoal (1 subgoal):\n 1. top_homomorphism sa_iso", "."], ["proof (state)\nthis:\n  top_homomorphism sa_iso\n\ngoal (4 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. uminus_homomorphism sa_iso\n 4. bij sa_iso", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. uminus_homomorphism sa_iso\n 4. bij sa_iso", "have 1: \"\\<forall>x y::'a . dense (x \\<squnion> -x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. dense (x \\<squnion> - x \\<squnion> y)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x y. dense (x \\<squnion> - x \\<squnion> y)\n\ngoal (4 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. uminus_homomorphism sa_iso\n 4. bij sa_iso", "have 2: \"\\<forall>x y::'a . up_filter (Abs_dense (x \\<squnion> -x \\<squnion> y)) \\<le> (stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) \\<sqinter> (stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n       \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n              up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n             (stone_phi (Abs_regular (- y)) \\<squnion>\n              up_filter (Abs_dense (y \\<squnion> - y)))", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n       \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n              up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n             (stone_phi (Abs_regular (- y)) \\<squnion>\n              up_filter (Abs_dense (y \\<squnion> - y)))", "fix x y :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n       \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n              up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n             (stone_phi (Abs_regular (- y)) \\<squnion>\n              up_filter (Abs_dense (y \\<squnion> - y)))", "let ?u = \"Abs_dense (x \\<squnion> -x \\<squnion> --y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n       \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n              up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n             (stone_phi (Abs_regular (- y)) \\<squnion>\n              up_filter (Abs_dense (y \\<squnion> - y)))", "let ?v = \"Abs_dense (y \\<squnion> -y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n       \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n              up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n             (stone_phi (Abs_regular (- y)) \\<squnion>\n              up_filter (Abs_dense (y \\<squnion> - y)))", "have \"\\<up>(Abs_dense (x \\<squnion> -x \\<squnion> y)) \\<le> Rep_filter (stone_phi (Abs_regular (-y)) \\<squnion> up_filter ?v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>Abs_dense (x \\<squnion> - x \\<squnion> y)\n    \\<subseteq> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "assume \"z \\<in> \\<up>(Abs_dense (x \\<squnion> -x \\<squnion> y))\""], ["proof (state)\nthis:\n  z \\<in> \\<up>Abs_dense (x \\<squnion> - x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "hence \"Abs_dense (x \\<squnion> -x \\<squnion> y) \\<le> z\""], ["proof (prove)\nusing this:\n  z \\<in> \\<up>Abs_dense (x \\<squnion> - x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. Abs_dense (x \\<squnion> - x \\<squnion> y) \\<le> z", "by simp"], ["proof (state)\nthis:\n  Abs_dense (x \\<squnion> - x \\<squnion> y) \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "hence 3: \"x \\<squnion> -x \\<squnion> y \\<le> Rep_dense z\""], ["proof (prove)\nusing this:\n  Abs_dense (x \\<squnion> - x \\<squnion> y) \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<squnion> - x \\<squnion> y \\<le> Rep_dense z", "by (simp add: Abs_dense_inverse less_eq_dense.rep_eq)"], ["proof (state)\nthis:\n  x \\<squnion> - x \\<squnion> y \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "have \"y \\<le> x \\<squnion> -x \\<squnion> --y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<squnion> - x \\<squnion> - - y", "by (simp add: le_supI2 pp_increasing)"], ["proof (state)\nthis:\n  y \\<le> x \\<squnion> - x \\<squnion> - - y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "hence \"(x \\<squnion> -x \\<squnion> --y) \\<sqinter> (y \\<squnion> -y) = y \\<squnion> ((x \\<squnion> -x \\<squnion> --y) \\<sqinter> -y)\""], ["proof (prove)\nusing this:\n  y \\<le> x \\<squnion> - x \\<squnion> - - y\n\ngoal (1 subgoal):\n 1. (x \\<squnion> - x \\<squnion> - - y) \\<sqinter> (y \\<squnion> - y) =\n    y \\<squnion> (x \\<squnion> - x \\<squnion> - - y) \\<sqinter> - y", "by (simp add: le_iff_sup sup_inf_distrib1)"], ["proof (state)\nthis:\n  (x \\<squnion> - x \\<squnion> - - y) \\<sqinter> (y \\<squnion> - y) =\n  y \\<squnion> (x \\<squnion> - x \\<squnion> - - y) \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "also"], ["proof (state)\nthis:\n  (x \\<squnion> - x \\<squnion> - - y) \\<sqinter> (y \\<squnion> - y) =\n  y \\<squnion> (x \\<squnion> - x \\<squnion> - - y) \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "have \"... = y \\<squnion> ((x \\<squnion> -x) \\<sqinter> -y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<squnion> (x \\<squnion> - x \\<squnion> - - y) \\<sqinter> - y =\n    y \\<squnion> (x \\<squnion> - x) \\<sqinter> - y", "by (simp add: inf_commute inf_sup_distrib1)"], ["proof (state)\nthis:\n  y \\<squnion> (x \\<squnion> - x \\<squnion> - - y) \\<sqinter> - y =\n  y \\<squnion> (x \\<squnion> - x) \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "also"], ["proof (state)\nthis:\n  y \\<squnion> (x \\<squnion> - x \\<squnion> - - y) \\<sqinter> - y =\n  y \\<squnion> (x \\<squnion> - x) \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "have \"... \\<le> Rep_dense z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<squnion> (x \\<squnion> - x) \\<sqinter> - y \\<le> Rep_dense z", "using 3"], ["proof (prove)\nusing this:\n  x \\<squnion> - x \\<squnion> y \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. y \\<squnion> (x \\<squnion> - x) \\<sqinter> - y \\<le> Rep_dense z", "by (meson le_infI1 sup.bounded_iff)"], ["proof (state)\nthis:\n  y \\<squnion> (x \\<squnion> - x) \\<sqinter> - y \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "finally"], ["proof (chain)\npicking this:\n  (x \\<squnion> - x \\<squnion> - - y) \\<sqinter> (y \\<squnion> - y)\n  \\<le> Rep_dense z", "have \"Abs_dense ((x \\<squnion> -x \\<squnion> --y) \\<sqinter> (y \\<squnion> -y)) \\<le> z\""], ["proof (prove)\nusing this:\n  (x \\<squnion> - x \\<squnion> - - y) \\<sqinter> (y \\<squnion> - y)\n  \\<le> Rep_dense z\n\ngoal (1 subgoal):\n 1. Abs_dense\n     ((x \\<squnion> - x \\<squnion> - - y) \\<sqinter> (y \\<squnion> - y))\n    \\<le> z", "by (simp add: Abs_dense_inverse less_eq_dense.rep_eq)"], ["proof (state)\nthis:\n  Abs_dense\n   ((x \\<squnion> - x \\<squnion> - - y) \\<sqinter> (y \\<squnion> - y))\n  \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "hence 4: \"?u \\<sqinter> ?v \\<le> z\""], ["proof (prove)\nusing this:\n  Abs_dense\n   ((x \\<squnion> - x \\<squnion> - - y) \\<sqinter> (y \\<squnion> - y))\n  \\<le> z\n\ngoal (1 subgoal):\n 1. Abs_dense (x \\<squnion> - x \\<squnion> - - y) \\<sqinter>\n    Abs_dense (y \\<squnion> - y)\n    \\<le> z", "by (simp add: eq_onp_same_args inf_dense.abs_eq)"], ["proof (state)\nthis:\n  Abs_dense (x \\<squnion> - x \\<squnion> - - y) \\<sqinter>\n  Abs_dense (y \\<squnion> - y)\n  \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "have \"-Rep_regular (Abs_regular (-y)) = --y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - Rep_regular (Abs_regular (- y)) = - - y", "by (metis (mono_tags, lifting) mem_Collect_eq Abs_regular_inverse)"], ["proof (state)\nthis:\n  - Rep_regular (Abs_regular (- y)) = - - y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "also"], ["proof (state)\nthis:\n  - Rep_regular (Abs_regular (- y)) = - - y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "have \"... \\<le> Rep_dense ?u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - y \\<le> Rep_dense (Abs_dense (x \\<squnion> - x \\<squnion> - - y))", "by (simp add: Abs_dense_inverse)"], ["proof (state)\nthis:\n  - - y \\<le> Rep_dense (Abs_dense (x \\<squnion> - x \\<squnion> - - y))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "finally"], ["proof (chain)\npicking this:\n  - Rep_regular (Abs_regular (- y))\n  \\<le> Rep_dense (Abs_dense (x \\<squnion> - x \\<squnion> - - y))", "have \"?u \\<in> stone_phi_base (Abs_regular (-y))\""], ["proof (prove)\nusing this:\n  - Rep_regular (Abs_regular (- y))\n  \\<le> Rep_dense (Abs_dense (x \\<squnion> - x \\<squnion> - - y))\n\ngoal (1 subgoal):\n 1. Abs_dense (x \\<squnion> - x \\<squnion> - - y)\n    \\<in> stone_phi_base (Abs_regular (- y))", "by simp"], ["proof (state)\nthis:\n  Abs_dense (x \\<squnion> - x \\<squnion> - - y)\n  \\<in> stone_phi_base (Abs_regular (- y))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "hence 5: \"?u \\<in> Rep_filter (stone_phi (Abs_regular (-y)))\""], ["proof (prove)\nusing this:\n  Abs_dense (x \\<squnion> - x \\<squnion> - - y)\n  \\<in> stone_phi_base (Abs_regular (- y))\n\ngoal (1 subgoal):\n 1. Abs_dense (x \\<squnion> - x \\<squnion> - - y)\n    \\<in> Filters.filter.Rep_filter (stone_phi (Abs_regular (- y)))", "by (metis mem_Collect_eq stone_phi_def stone_phi_base_filter Abs_filter_inverse)"], ["proof (state)\nthis:\n  Abs_dense (x \\<squnion> - x \\<squnion> - - y)\n  \\<in> Filters.filter.Rep_filter (stone_phi (Abs_regular (- y)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "have \"?v \\<in> \\<up>?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_dense (y \\<squnion> - y) \\<in> \\<up>Abs_dense (y \\<squnion> - y)", "by simp"], ["proof (state)\nthis:\n  Abs_dense (y \\<squnion> - y) \\<in> \\<up>Abs_dense (y \\<squnion> - y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "hence \"?v \\<in> Rep_filter (up_filter ?v)\""], ["proof (prove)\nusing this:\n  Abs_dense (y \\<squnion> - y) \\<in> \\<up>Abs_dense (y \\<squnion> - y)\n\ngoal (1 subgoal):\n 1. Abs_dense (y \\<squnion> - y)\n    \\<in> Filters.filter.Rep_filter\n           (up_filter (Abs_dense (y \\<squnion> - y)))", "by (metis Abs_filter_inverse mem_Collect_eq up_filter)"], ["proof (state)\nthis:\n  Abs_dense (y \\<squnion> - y)\n  \\<in> Filters.filter.Rep_filter (up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> \\<up>Abs_dense\n                      (x \\<squnion> - x \\<squnion> y) \\<Longrightarrow>\n       xa \\<in> Filters.filter.Rep_filter\n                 (stone_phi (Abs_regular (- y)) \\<squnion>\n                  up_filter (Abs_dense (y \\<squnion> - y)))", "thus \"z \\<in> Rep_filter (stone_phi (Abs_regular (-y)) \\<squnion> up_filter ?v)\""], ["proof (prove)\nusing this:\n  Abs_dense (y \\<squnion> - y)\n  \\<in> Filters.filter.Rep_filter (up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. z \\<in> Filters.filter.Rep_filter\n             (stone_phi (Abs_regular (- y)) \\<squnion>\n              up_filter (Abs_dense (y \\<squnion> - y)))", "using 4 5 sup_filter.rep_eq filter_sup_def"], ["proof (prove)\nusing this:\n  Abs_dense (y \\<squnion> - y)\n  \\<in> Filters.filter.Rep_filter (up_filter (Abs_dense (y \\<squnion> - y)))\n  Abs_dense (x \\<squnion> - x \\<squnion> - - y) \\<sqinter>\n  Abs_dense (y \\<squnion> - y)\n  \\<le> z\n  Abs_dense (x \\<squnion> - x \\<squnion> - - y)\n  \\<in> Filters.filter.Rep_filter (stone_phi (Abs_regular (- y)))\n  Filters.filter.Rep_filter (?x \\<squnion> ?xa) =\n  filter_sup (Filters.filter.Rep_filter ?x) (Filters.filter.Rep_filter ?xa)\n  filter_sup ?F ?G \\<equiv>\n  {z. \\<exists>x\\<in>?F. \\<exists>y\\<in>?G. x \\<sqinter> y \\<le> z}\n\ngoal (1 subgoal):\n 1. z \\<in> Filters.filter.Rep_filter\n             (stone_phi (Abs_regular (- y)) \\<squnion>\n              up_filter (Abs_dense (y \\<squnion> - y)))", "by blast"], ["proof (state)\nthis:\n  z \\<in> Filters.filter.Rep_filter\n           (stone_phi (Abs_regular (- y)) \\<squnion>\n            up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<up>Abs_dense (x \\<squnion> - x \\<squnion> y)\n  \\<subseteq> Filters.filter.Rep_filter\n               (stone_phi (Abs_regular (- y)) \\<squnion>\n                up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n       \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n              up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n             (stone_phi (Abs_regular (- y)) \\<squnion>\n              up_filter (Abs_dense (y \\<squnion> - y)))", "hence \"up_filter (Abs_dense (x \\<squnion> -x \\<squnion> y)) \\<le> Abs_filter (Rep_filter (stone_phi (Abs_regular (-y)) \\<squnion> up_filter ?v))\""], ["proof (prove)\nusing this:\n  \\<up>Abs_dense (x \\<squnion> - x \\<squnion> y)\n  \\<subseteq> Filters.filter.Rep_filter\n               (stone_phi (Abs_regular (- y)) \\<squnion>\n                up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n    \\<le> Filters.filter.Abs_filter\n           (Filters.filter.Rep_filter\n             (stone_phi (Abs_regular (- y)) \\<squnion>\n              up_filter (Abs_dense (y \\<squnion> - y))))", "by (simp add: eq_onp_same_args less_eq_filter.abs_eq)"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n  \\<le> Filters.filter.Abs_filter\n         (Filters.filter.Rep_filter\n           (stone_phi (Abs_regular (- y)) \\<squnion>\n            up_filter (Abs_dense (y \\<squnion> - y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n       \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n              up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n             (stone_phi (Abs_regular (- y)) \\<squnion>\n              up_filter (Abs_dense (y \\<squnion> - y)))", "also"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n  \\<le> Filters.filter.Abs_filter\n         (Filters.filter.Rep_filter\n           (stone_phi (Abs_regular (- y)) \\<squnion>\n            up_filter (Abs_dense (y \\<squnion> - y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n       \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n              up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n             (stone_phi (Abs_regular (- y)) \\<squnion>\n              up_filter (Abs_dense (y \\<squnion> - y)))", "have \"... = stone_phi (Abs_regular (-y)) \\<squnion> up_filter ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filters.filter.Abs_filter\n     (Filters.filter.Rep_filter\n       (stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y)))) =\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (y \\<squnion> - y))", "by (simp add: Rep_filter_inverse)"], ["proof (state)\nthis:\n  Filters.filter.Abs_filter\n   (Filters.filter.Rep_filter\n     (stone_phi (Abs_regular (- y)) \\<squnion>\n      up_filter (Abs_dense (y \\<squnion> - y)))) =\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (y \\<squnion> - y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n       \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n              up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n             (stone_phi (Abs_regular (- y)) \\<squnion>\n              up_filter (Abs_dense (y \\<squnion> - y)))", "finally"], ["proof (chain)\npicking this:\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n  \\<le> stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y))", "show \"up_filter (Abs_dense (x \\<squnion> -x \\<squnion> y)) \\<le> (stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) \\<sqinter> (stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y)))\""], ["proof (prove)\nusing this:\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n  \\<le> stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y))\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n    \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n           up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n          (stone_phi (Abs_regular (- y)) \\<squnion>\n           up_filter (Abs_dense (y \\<squnion> - y)))", "by (metis le_infI le_supI2 sup_bot.right_neutral up_filter_dense_antitone)"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n  \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n        (stone_phi (Abs_regular (- y)) \\<squnion>\n         up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y.\n     up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n     \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n            up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n           (stone_phi (Abs_regular (- y)) \\<squnion>\n            up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (4 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. uminus_homomorphism sa_iso\n 4. bij sa_iso", "have 6: \"\\<forall>x::'a . in_p_image (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. in_p_image (- x)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. in_p_image (- x)\n\ngoal (4 subgoals):\n 1. sup_homomorphism sa_iso\n 2. inf_homomorphism sa_iso\n 3. uminus_homomorphism sa_iso\n 4. bij sa_iso", "show \"\\<forall>x y::'a . sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_homomorphism sa_iso", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "fix x y :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "have 7: \"up_filter (Abs_dense (x \\<squnion> -x)) \\<sqinter> up_filter (Abs_dense (y \\<squnion> -y)) \\<le> up_filter (Abs_dense (y \\<squnion> -y \\<squnion> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "have \"up_filter (Abs_dense (x \\<squnion> -x)) \\<sqinter> up_filter (Abs_dense (y \\<squnion> -y)) = up_filter (Abs_dense (x \\<squnion> -x) \\<squnion> Abs_dense (y \\<squnion> -y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y)) =\n    up_filter\n     (Abs_dense (x \\<squnion> - x) \\<squnion> Abs_dense (y \\<squnion> - y))", "by (metis up_filter_dist_sup)"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n  up_filter (Abs_dense (y \\<squnion> - y)) =\n  up_filter\n   (Abs_dense (x \\<squnion> - x) \\<squnion> Abs_dense (y \\<squnion> - y))\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "also"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n  up_filter (Abs_dense (y \\<squnion> - y)) =\n  up_filter\n   (Abs_dense (x \\<squnion> - x) \\<squnion> Abs_dense (y \\<squnion> - y))\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "have \"... = up_filter (Abs_dense (x \\<squnion> -x \\<squnion> (y \\<squnion> -y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_filter\n     (Abs_dense (x \\<squnion> - x) \\<squnion>\n      Abs_dense (y \\<squnion> - y)) =\n    up_filter (Abs_dense (x \\<squnion> - x \\<squnion> (y \\<squnion> - y)))", "by (subst sup_dense.abs_eq) (simp_all add: eq_onp_same_args)"], ["proof (state)\nthis:\n  up_filter\n   (Abs_dense (x \\<squnion> - x) \\<squnion> Abs_dense (y \\<squnion> - y)) =\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "also"], ["proof (state)\nthis:\n  up_filter\n   (Abs_dense (x \\<squnion> - x) \\<squnion> Abs_dense (y \\<squnion> - y)) =\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "have \"... = up_filter (Abs_dense (y \\<squnion> -y \\<squnion> x \\<squnion> -x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x \\<squnion> (y \\<squnion> - y))) =\n    up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x \\<squnion> - x))", "by (simp add: sup_commute sup_left_commute)"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> (y \\<squnion> - y))) =\n  up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x \\<squnion> - x))\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "also"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> (y \\<squnion> - y))) =\n  up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x \\<squnion> - x))\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "have \"... \\<le> up_filter (Abs_dense (y \\<squnion> -y \\<squnion> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x \\<squnion> - x))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "using up_filter_dense_antitone"], ["proof (prove)\nusing this:\n  up_filter (Abs_dense (?x \\<squnion> - ?x \\<squnion> ?y \\<squnion> ?z))\n  \\<le> up_filter (Abs_dense (?x \\<squnion> - ?x \\<squnion> ?y))\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x \\<squnion> - x))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "by auto"], ["proof (state)\nthis:\n  up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x \\<squnion> - x))\n  \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "finally"], ["proof (chain)\npicking this:\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n  up_filter (Abs_dense (y \\<squnion> - y))\n  \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "show ?thesis"], ["proof (prove)\nusing this:\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n  up_filter (Abs_dense (y \\<squnion> - y))\n  \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "."], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n  up_filter (Abs_dense (y \\<squnion> - y))\n  \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n  up_filter (Abs_dense (y \\<squnion> - y))\n  \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "have \"Abs_dense (x \\<squnion> y \\<squnion> -(x \\<squnion> y)) = Abs_dense ((x \\<squnion> -x \\<squnion> y) \\<sqinter> (y \\<squnion> -y \\<squnion> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)) =\n    Abs_dense\n     ((x \\<squnion> - x \\<squnion> y) \\<sqinter>\n      (y \\<squnion> - y \\<squnion> x))", "by (simp add: sup_commute sup_inf_distrib1 sup_left_commute)"], ["proof (state)\nthis:\n  Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)) =\n  Abs_dense\n   ((x \\<squnion> - x \\<squnion> y) \\<sqinter>\n    (y \\<squnion> - y \\<squnion> x))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "also"], ["proof (state)\nthis:\n  Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)) =\n  Abs_dense\n   ((x \\<squnion> - x \\<squnion> y) \\<sqinter>\n    (y \\<squnion> - y \\<squnion> x))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "have \"... = Abs_dense (x \\<squnion> -x \\<squnion> y) \\<sqinter> Abs_dense (y \\<squnion> -y \\<squnion> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_dense\n     ((x \\<squnion> - x \\<squnion> y) \\<sqinter>\n      (y \\<squnion> - y \\<squnion> x)) =\n    Abs_dense (x \\<squnion> - x \\<squnion> y) \\<sqinter>\n    Abs_dense (y \\<squnion> - y \\<squnion> x)", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>x y. dense (x \\<squnion> - x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. Abs_dense\n     ((x \\<squnion> - x \\<squnion> y) \\<sqinter>\n      (y \\<squnion> - y \\<squnion> x)) =\n    Abs_dense (x \\<squnion> - x \\<squnion> y) \\<sqinter>\n    Abs_dense (y \\<squnion> - y \\<squnion> x)", "by (metis (mono_tags, lifting) Abs_dense_inverse Rep_dense_inverse inf_dense.rep_eq mem_Collect_eq)"], ["proof (state)\nthis:\n  Abs_dense\n   ((x \\<squnion> - x \\<squnion> y) \\<sqinter>\n    (y \\<squnion> - y \\<squnion> x)) =\n  Abs_dense (x \\<squnion> - x \\<squnion> y) \\<sqinter>\n  Abs_dense (y \\<squnion> - y \\<squnion> x)\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "finally"], ["proof (chain)\npicking this:\n  Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)) =\n  Abs_dense (x \\<squnion> - x \\<squnion> y) \\<sqinter>\n  Abs_dense (y \\<squnion> - y \\<squnion> x)", "have 8: \"up_filter (Abs_dense (x \\<squnion> y \\<squnion> -(x \\<squnion> y))) = up_filter (Abs_dense (x \\<squnion> -x \\<squnion> y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y \\<squnion> x))\""], ["proof (prove)\nusing this:\n  Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)) =\n  Abs_dense (x \\<squnion> - x \\<squnion> y) \\<sqinter>\n  Abs_dense (y \\<squnion> - y \\<squnion> x)\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y))) =\n    up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) \\<squnion>\n    up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))", "by (simp add: up_filter_dist_inf)"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y))) =\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) \\<squnion>\n  up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "also"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y))) =\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) \\<squnion>\n  up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "have \"... \\<le> (stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) \\<sqinter> (stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) \\<squnion>\n    up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))\n    \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n           up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n          (stone_phi (Abs_regular (- y)) \\<squnion>\n           up_filter (Abs_dense (y \\<squnion> - y)))", "using 2"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n     \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n            up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n           (stone_phi (Abs_regular (- y)) \\<squnion>\n            up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) \\<squnion>\n    up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))\n    \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n           up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n          (stone_phi (Abs_regular (- y)) \\<squnion>\n           up_filter (Abs_dense (y \\<squnion> - y)))", "by (simp add: inf.sup_commute le_sup_iff)"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) \\<squnion>\n  up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))\n  \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n        (stone_phi (Abs_regular (- y)) \\<squnion>\n         up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "finally"], ["proof (chain)\npicking this:\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n  \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n        (stone_phi (Abs_regular (- y)) \\<squnion>\n         up_filter (Abs_dense (y \\<squnion> - y)))", "have 9: \"(stone_phi (Abs_regular (-x)) \\<sqinter> stone_phi (Abs_regular (-y))) \\<squnion> up_filter (Abs_dense (x \\<squnion> y \\<squnion> -(x \\<squnion> y))) \\<le> ...\""], ["proof (prove)\nusing this:\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n  \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n        (stone_phi (Abs_regular (- y)) \\<squnion>\n         up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<sqinter>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n    \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n           up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n          (stone_phi (Abs_regular (- y)) \\<squnion>\n           up_filter (Abs_dense (y \\<squnion> - y)))", "by (simp add: le_supI1)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n  \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n        (stone_phi (Abs_regular (- y)) \\<squnion>\n         up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "have \"... = (stone_phi (Abs_regular (-x)) \\<sqinter> stone_phi (Abs_regular (-y))) \\<squnion> (stone_phi (Abs_regular (-x)) \\<sqinter> up_filter (Abs_dense (y \\<squnion> -y))) \\<squnion> ((up_filter (Abs_dense (x \\<squnion> -x)) \\<sqinter> stone_phi (Abs_regular (-y))) \\<squnion> (up_filter (Abs_dense (x \\<squnion> -x)) \\<sqinter> up_filter (Abs_dense (y \\<squnion> -y))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n    (stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y))) =\n    stone_phi (Abs_regular (- x)) \\<sqinter>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    stone_phi (Abs_regular (- x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y)) \\<squnion>\n    (up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n     stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n     up_filter (Abs_dense (y \\<squnion> - y)))", "by (metis (no_types) inf_sup_distrib1 inf_sup_distrib2)"], ["proof (state)\nthis:\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  up_filter (Abs_dense (y \\<squnion> - y)) \\<squnion>\n  (up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n   stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "also"], ["proof (state)\nthis:\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  up_filter (Abs_dense (y \\<squnion> - y)) \\<squnion>\n  (up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n   stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "have \"... \\<le> (stone_phi (Abs_regular (-x)) \\<sqinter> stone_phi (Abs_regular (-y))) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y \\<squnion> x)) \\<squnion> ((up_filter (Abs_dense (x \\<squnion> -x)) \\<sqinter> stone_phi (Abs_regular (-y))) \\<squnion> (up_filter (Abs_dense (x \\<squnion> -x)) \\<sqinter> up_filter (Abs_dense (y \\<squnion> -y))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<sqinter>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    stone_phi (Abs_regular (- x)) \\<sqinter>\n    up_filter (Abs_dense (y \\<squnion> - y)) \\<squnion>\n    (up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n     stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n     up_filter (Abs_dense (y \\<squnion> - y)))\n    \\<le> stone_phi (Abs_regular (- x)) \\<sqinter>\n          stone_phi (Abs_regular (- y)) \\<squnion>\n          up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n          (up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n           stone_phi (Abs_regular (- y)) \\<squnion>\n           up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n           up_filter (Abs_dense (y \\<squnion> - y)))", "by (meson sup_left_isotone sup_right_isotone stone_phi_inf_dense)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  up_filter (Abs_dense (y \\<squnion> - y)) \\<squnion>\n  (up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n   stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n  \\<le> stone_phi (Abs_regular (- x)) \\<sqinter>\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n        (up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n         stone_phi (Abs_regular (- y)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n         up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "also"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  up_filter (Abs_dense (y \\<squnion> - y)) \\<squnion>\n  (up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n   stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n  \\<le> stone_phi (Abs_regular (- x)) \\<sqinter>\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n        (up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n         stone_phi (Abs_regular (- y)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n         up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "have \"... \\<le> (stone_phi (Abs_regular (-x)) \\<sqinter> stone_phi (Abs_regular (-y))) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y \\<squnion> x)) \\<squnion> (up_filter (Abs_dense (x \\<squnion> -x \\<squnion> y)) \\<squnion> (up_filter (Abs_dense (x \\<squnion> -x)) \\<sqinter> up_filter (Abs_dense (y \\<squnion> -y))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<sqinter>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n    (up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n     stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n     up_filter (Abs_dense (y \\<squnion> - y)))\n    \\<le> stone_phi (Abs_regular (- x)) \\<sqinter>\n          stone_phi (Abs_regular (- y)) \\<squnion>\n          up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n          (up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) \\<squnion>\n           up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n           up_filter (Abs_dense (y \\<squnion> - y)))", "by (metis inf.commute sup_left_isotone sup_right_isotone stone_phi_inf_dense)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n  (up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n   stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n  \\<le> stone_phi (Abs_regular (- x)) \\<sqinter>\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n        (up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n         up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "also"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n  (up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n   stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n  \\<le> stone_phi (Abs_regular (- x)) \\<sqinter>\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n        (up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n         up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "have \"... \\<le> (stone_phi (Abs_regular (-x)) \\<sqinter> stone_phi (Abs_regular (-y))) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y \\<squnion> x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x \\<squnion> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<sqinter>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n    (up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n     up_filter (Abs_dense (y \\<squnion> - y)))\n    \\<le> stone_phi (Abs_regular (- x)) \\<sqinter>\n          stone_phi (Abs_regular (- y)) \\<squnion>\n          up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n          up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))", "using 7"], ["proof (prove)\nusing this:\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n  up_filter (Abs_dense (y \\<squnion> - y))\n  \\<le> up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<sqinter>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n    (up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n     up_filter (Abs_dense (y \\<squnion> - y)))\n    \\<le> stone_phi (Abs_regular (- x)) \\<sqinter>\n          stone_phi (Abs_regular (- y)) \\<squnion>\n          up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n          up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))", "by (simp add: sup.absorb1 sup_commute sup_left_commute)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n  (up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n  \\<le> stone_phi (Abs_regular (- x)) \\<sqinter>\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "also"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n  (up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x)) \\<sqinter>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n  \\<le> stone_phi (Abs_regular (- x)) \\<sqinter>\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "have \"... = (stone_phi (Abs_regular (-x)) \\<sqinter> stone_phi (Abs_regular (-y))) \\<squnion> up_filter (Abs_dense (x \\<squnion> y \\<squnion> -(x \\<squnion> y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<sqinter>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) =\n    stone_phi (Abs_regular (- x)) \\<sqinter>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))", "using 8"], ["proof (prove)\nusing this:\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y))) =\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) \\<squnion>\n  up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x))\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<sqinter>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) =\n    stone_phi (Abs_regular (- x)) \\<sqinter>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))", "by (simp add: sup.commute sup.left_commute)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (y \\<squnion> - y \\<squnion> x)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> y)) =\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "finally"], ["proof (chain)\npicking this:\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n  \\<le> stone_phi (Abs_regular (- x)) \\<sqinter>\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))", "have \"(stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) \\<sqinter> (stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y))) = ...\""], ["proof (prove)\nusing this:\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n  \\<le> stone_phi (Abs_regular (- x)) \\<sqinter>\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n\ngoal (1 subgoal):\n 1. (stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n    (stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y))) =\n    stone_phi (Abs_regular (- x)) \\<sqinter>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))", "using 9"], ["proof (prove)\nusing this:\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n  \\<le> stone_phi (Abs_regular (- x)) \\<sqinter>\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n  \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n        (stone_phi (Abs_regular (- y)) \\<squnion>\n         up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. (stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n    (stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y))) =\n    stone_phi (Abs_regular (- x)) \\<sqinter>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))", "using antisym"], ["proof (prove)\nusing this:\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n  \\<le> stone_phi (Abs_regular (- x)) \\<sqinter>\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n  \\<le> (stone_phi (Abs_regular (- x)) \\<squnion>\n         up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n        (stone_phi (Abs_regular (- y)) \\<squnion>\n         up_filter (Abs_dense (y \\<squnion> - y)))\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. (stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n    (stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y))) =\n    stone_phi (Abs_regular (- x)) \\<sqinter>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))", "by blast"], ["proof (state)\nthis:\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "also"], ["proof (state)\nthis:\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "have \"... = stone_phi (Abs_regular (-x) \\<sqinter> Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (x \\<squnion> y \\<squnion> -(x \\<squnion> y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<sqinter>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y))) =\n    stone_phi (Abs_regular (- x) \\<sqinter> Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))", "by (simp add: stone_phi.hom)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y))) =\n  stone_phi (Abs_regular (- x) \\<sqinter> Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "also"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<sqinter>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y))) =\n  stone_phi (Abs_regular (- x) \\<sqinter> Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "have \"... = stone_phi (Abs_regular (-(x \\<squnion> y))) \\<squnion> up_filter (Abs_dense (x \\<squnion> y \\<squnion> -(x \\<squnion> y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x) \\<sqinter> Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y))) =\n    stone_phi (Abs_regular (- (x \\<squnion> y))) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))", "using 6"], ["proof (prove)\nusing this:\n  \\<forall>x. in_p_image (- x)\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x) \\<sqinter> Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y))) =\n    stone_phi (Abs_regular (- (x \\<squnion> y))) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))", "by (subst inf_regular.abs_eq) (simp_all add: eq_onp_same_args)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x) \\<sqinter> Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y))) =\n  stone_phi (Abs_regular (- (x \\<squnion> y))) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "finally"], ["proof (chain)\npicking this:\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- (x \\<squnion> y))) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))", "have 10: \"stone_phi (Abs_regular (-(x \\<squnion> y))) \\<squnion> up_filter (Abs_dense (x \\<squnion> y \\<squnion> -(x \\<squnion> y))) = (stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) \\<sqinter> (stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y)))\""], ["proof (prove)\nusing this:\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- (x \\<squnion> y))) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y)))\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- (x \\<squnion> y))) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y))) =\n    (stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n    (stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y)))", "by simp"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- (x \\<squnion> y))) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y))) =\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "have \"Abs_regular (--(x \\<squnion> y)) = Abs_regular (--x) \\<squnion> Abs_regular (--y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_regular (- - (x \\<squnion> y)) =\n    Abs_regular (- - x) \\<squnion> Abs_regular (- - y)", "using 6"], ["proof (prove)\nusing this:\n  \\<forall>x. in_p_image (- x)\n\ngoal (1 subgoal):\n 1. Abs_regular (- - (x \\<squnion> y)) =\n    Abs_regular (- - x) \\<squnion> Abs_regular (- - y)", "by (subst sup_regular.abs_eq) (simp_all add: eq_onp_same_args)"], ["proof (state)\nthis:\n  Abs_regular (- - (x \\<squnion> y)) =\n  Abs_regular (- - x) \\<squnion> Abs_regular (- - y)\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "hence \"Abs_stone_phi_pair (Abs_regular (--(x \\<squnion> y)),stone_phi (Abs_regular (-(x \\<squnion> y))) \\<squnion> up_filter (Abs_dense (x \\<squnion> y \\<squnion> -(x \\<squnion> y)))) = Abs_stone_phi_pair (triple.pairs_sup (Abs_regular (--x),stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) (Abs_regular (--y),stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y))))\""], ["proof (prove)\nusing this:\n  Abs_regular (- - (x \\<squnion> y)) =\n  Abs_regular (- - x) \\<squnion> Abs_regular (- - y)\n\ngoal (1 subgoal):\n 1. sa_iso (x \\<squnion> y) =\n    Abs_stone_phi_pair\n     (stone_phi.pairs_sup\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x)))\n       (Abs_regular (- - y),\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y))))", "using 10"], ["proof (prove)\nusing this:\n  Abs_regular (- - (x \\<squnion> y)) =\n  Abs_regular (- - x) \\<squnion> Abs_regular (- - y)\n  stone_phi (Abs_regular (- (x \\<squnion> y))) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> y \\<squnion> - (x \\<squnion> y))) =\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (x \\<squnion> - x))) \\<sqinter>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. sa_iso (x \\<squnion> y) =\n    Abs_stone_phi_pair\n     (stone_phi.pairs_sup\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x)))\n       (Abs_regular (- - y),\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y))))", "by auto"], ["proof (state)\nthis:\n  sa_iso (x \\<squnion> y) =\n  Abs_stone_phi_pair\n   (stone_phi.pairs_sup\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))\n     (Abs_regular (- - y),\n      stone_phi (Abs_regular (- y)) \\<squnion>\n      up_filter (Abs_dense (y \\<squnion> - y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "also"], ["proof (state)\nthis:\n  sa_iso (x \\<squnion> y) =\n  Abs_stone_phi_pair\n   (stone_phi.pairs_sup\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))\n     (Abs_regular (- - y),\n      stone_phi (Abs_regular (- y)) \\<squnion>\n      up_filter (Abs_dense (y \\<squnion> - y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "have \"... = Abs_stone_phi_pair (Abs_regular (--x),stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) \\<squnion> Abs_stone_phi_pair (Abs_regular (--y),stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (stone_phi.pairs_sup\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x)))\n       (Abs_regular (- - y),\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y)))) =\n    sa_iso x \\<squnion> sa_iso y", "by (rule sup_stone_phi_pair.abs_eq[THEN sym]) (simp_all add: eq_onp_same_args sa_iso_triple_pair)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (stone_phi.pairs_sup\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))\n     (Abs_regular (- - y),\n      stone_phi (Abs_regular (- y)) \\<squnion>\n      up_filter (Abs_dense (y \\<squnion> - y)))) =\n  sa_iso x \\<squnion> sa_iso y\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "finally"], ["proof (chain)\npicking this:\n  sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "show \"sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y\""], ["proof (prove)\nusing this:\n  sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y\n\ngoal (1 subgoal):\n 1. sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y", "."], ["proof (state)\nthis:\n  sa_iso (x \\<squnion> y) = sa_iso x \\<squnion> sa_iso y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sup_homomorphism sa_iso\n\ngoal (3 subgoals):\n 1. inf_homomorphism sa_iso\n 2. uminus_homomorphism sa_iso\n 3. bij sa_iso", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. inf_homomorphism sa_iso\n 2. uminus_homomorphism sa_iso\n 3. bij sa_iso", "have 1: \"\\<forall>x y::'a . dense (x \\<squnion> -x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. dense (x \\<squnion> - x \\<squnion> y)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x y. dense (x \\<squnion> - x \\<squnion> y)\n\ngoal (3 subgoals):\n 1. inf_homomorphism sa_iso\n 2. uminus_homomorphism sa_iso\n 3. bij sa_iso", "have 2: \"\\<forall>x::'a . in_p_image (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. in_p_image (- x)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. in_p_image (- x)\n\ngoal (3 subgoals):\n 1. inf_homomorphism sa_iso\n 2. uminus_homomorphism sa_iso\n 3. bij sa_iso", "have 3: \"\\<forall>x y::'a . stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x)) = stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x \\<squnion> -y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       stone_phi (Abs_regular (- y)) \\<squnion>\n       up_filter (Abs_dense (x \\<squnion> - x)) =\n       stone_phi (Abs_regular (- y)) \\<squnion>\n       up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi (Abs_regular (- y)) \\<squnion>\n       up_filter (Abs_dense (x \\<squnion> - x)) =\n       stone_phi (Abs_regular (- y)) \\<squnion>\n       up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))", "fix x y :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi (Abs_regular (- y)) \\<squnion>\n       up_filter (Abs_dense (x \\<squnion> - x)) =\n       stone_phi (Abs_regular (- y)) \\<squnion>\n       up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))", "have 4: \"up_filter (Abs_dense (x \\<squnion> -x)) \\<le> stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x \\<squnion> -y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x))\n    \\<le> stone_phi (Abs_regular (- y)) \\<squnion>\n          up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))", "by (metis (no_types, lifting) complement_shunting stone_phi_inf_dense stone_phi_complement complement_symmetric)"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> - x))\n  \\<le> stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi (Abs_regular (- y)) \\<squnion>\n       up_filter (Abs_dense (x \\<squnion> - x)) =\n       stone_phi (Abs_regular (- y)) \\<squnion>\n       up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))", "have \"up_filter (Abs_dense (x \\<squnion> -x \\<squnion> -y)) \\<le> up_filter (Abs_dense (x \\<squnion> -x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))\n    \\<le> up_filter (Abs_dense (x \\<squnion> - x))", "by (metis sup_idem up_filter_dense_antitone)"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))\n  \\<le> up_filter (Abs_dense (x \\<squnion> - x))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       stone_phi (Abs_regular (- y)) \\<squnion>\n       up_filter (Abs_dense (x \\<squnion> - x)) =\n       stone_phi (Abs_regular (- y)) \\<squnion>\n       up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))", "thus \"stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x)) = stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x \\<squnion> -y))\""], ["proof (prove)\nusing this:\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))\n  \\<le> up_filter (Abs_dense (x \\<squnion> - x))\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x)) =\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))", "using 4"], ["proof (prove)\nusing this:\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))\n  \\<le> up_filter (Abs_dense (x \\<squnion> - x))\n  up_filter (Abs_dense (x \\<squnion> - x))\n  \\<le> stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x)) =\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))", "by (simp add: le_iff_sup sup_commute sup_left_commute)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) =\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y.\n     stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x)) =\n     stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))\n\ngoal (3 subgoals):\n 1. inf_homomorphism sa_iso\n 2. uminus_homomorphism sa_iso\n 3. bij sa_iso", "show \"\\<forall>x y::'a . sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_homomorphism sa_iso", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "fix x y :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "have \"Abs_dense ((x \\<sqinter> y) \\<squnion> -(x \\<sqinter> y)) = Abs_dense ((x \\<squnion> -x \\<squnion> -y) \\<sqinter> (y \\<squnion> -y \\<squnion> -x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)) =\n    Abs_dense\n     ((x \\<squnion> - x \\<squnion> - y) \\<sqinter>\n      (y \\<squnion> - y \\<squnion> - x))", "by (simp add: sup_commute sup_inf_distrib1 sup_left_commute)"], ["proof (state)\nthis:\n  Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)) =\n  Abs_dense\n   ((x \\<squnion> - x \\<squnion> - y) \\<sqinter>\n    (y \\<squnion> - y \\<squnion> - x))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "also"], ["proof (state)\nthis:\n  Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)) =\n  Abs_dense\n   ((x \\<squnion> - x \\<squnion> - y) \\<sqinter>\n    (y \\<squnion> - y \\<squnion> - x))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "have \"... = Abs_dense (x \\<squnion> -x \\<squnion> -y) \\<sqinter> Abs_dense (y \\<squnion> -y \\<squnion> -x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_dense\n     ((x \\<squnion> - x \\<squnion> - y) \\<sqinter>\n      (y \\<squnion> - y \\<squnion> - x)) =\n    Abs_dense (x \\<squnion> - x \\<squnion> - y) \\<sqinter>\n    Abs_dense (y \\<squnion> - y \\<squnion> - x)", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>x y. dense (x \\<squnion> - x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. Abs_dense\n     ((x \\<squnion> - x \\<squnion> - y) \\<sqinter>\n      (y \\<squnion> - y \\<squnion> - x)) =\n    Abs_dense (x \\<squnion> - x \\<squnion> - y) \\<sqinter>\n    Abs_dense (y \\<squnion> - y \\<squnion> - x)", "by (metis (mono_tags, lifting) Abs_dense_inverse Rep_dense_inverse inf_dense.rep_eq mem_Collect_eq)"], ["proof (state)\nthis:\n  Abs_dense\n   ((x \\<squnion> - x \\<squnion> - y) \\<sqinter>\n    (y \\<squnion> - y \\<squnion> - x)) =\n  Abs_dense (x \\<squnion> - x \\<squnion> - y) \\<sqinter>\n  Abs_dense (y \\<squnion> - y \\<squnion> - x)\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "finally"], ["proof (chain)\npicking this:\n  Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)) =\n  Abs_dense (x \\<squnion> - x \\<squnion> - y) \\<sqinter>\n  Abs_dense (y \\<squnion> - y \\<squnion> - x)", "have 5: \"up_filter (Abs_dense ((x \\<sqinter> y) \\<squnion> -(x \\<sqinter> y))) = up_filter (Abs_dense (x \\<squnion> -x \\<squnion> -y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y \\<squnion> -x))\""], ["proof (prove)\nusing this:\n  Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)) =\n  Abs_dense (x \\<squnion> - x \\<squnion> - y) \\<sqinter>\n  Abs_dense (y \\<squnion> - y \\<squnion> - x)\n\ngoal (1 subgoal):\n 1. up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y))) =\n    up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n    up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x))", "by (simp add: up_filter_dist_inf)"], ["proof (state)\nthis:\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y))) =\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n  up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "have \"(stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) \\<squnion> (stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y))) = (stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) \\<squnion> (stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n    (stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y))) =\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n    (stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y)))", "by (simp add: inf_sup_aci(6) sup_left_commute)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "also"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "have \"... = (stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x \\<squnion> -y))) \\<squnion> (stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y \\<squnion> -x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n    (stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y))) =\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n    (stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x)))", "using 3"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x)) =\n     stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y))\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n    (stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y))) =\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n    (stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x)))", "by simp"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "also"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "have \"... = (stone_phi (Abs_regular (-x)) \\<squnion> stone_phi (Abs_regular (-y))) \\<squnion> (up_filter (Abs_dense (x \\<squnion> -x \\<squnion> -y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y \\<squnion> -x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n    (stone_phi (Abs_regular (- x)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x))) =\n    stone_phi (Abs_regular (- x)) \\<squnion>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    (up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x)))", "by (simp add: inf_sup_aci(6) sup_left_commute)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x))) =\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  (up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "also"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n  (stone_phi (Abs_regular (- x)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x))) =\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  (up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "have \"... = (stone_phi (Abs_regular (-x)) \\<squnion> stone_phi (Abs_regular (-y))) \\<squnion> up_filter (Abs_dense ((x \\<sqinter> y) \\<squnion> -(x \\<sqinter> y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<squnion>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    (up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x))) =\n    stone_phi (Abs_regular (- x)) \\<squnion>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))", "using 5"], ["proof (prove)\nusing this:\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y))) =\n  up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n  up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x))\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<squnion>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    (up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x))) =\n    stone_phi (Abs_regular (- x)) \\<squnion>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))", "by (simp add: sup.commute sup.left_commute)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  (up_filter (Abs_dense (x \\<squnion> - x \\<squnion> - y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y \\<squnion> - x))) =\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "finally"], ["proof (chain)\npicking this:\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))", "have \"(stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) \\<squnion> (stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y))) = ...\""], ["proof (prove)\nusing this:\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n    (stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y))) =\n    stone_phi (Abs_regular (- x)) \\<squnion>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))", "by simp"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "also"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "have \"... = stone_phi (Abs_regular (-x) \\<squnion> Abs_regular (-y)) \\<squnion> up_filter (Abs_dense ((x \\<sqinter> y) \\<squnion> -(x \\<sqinter> y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x)) \\<squnion>\n    stone_phi (Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y))) =\n    stone_phi (Abs_regular (- x) \\<squnion> Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))", "by (simp add: stone_phi.hom)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y))) =\n  stone_phi (Abs_regular (- x) \\<squnion> Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "also"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  stone_phi (Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y))) =\n  stone_phi (Abs_regular (- x) \\<squnion> Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "have \"... = stone_phi (Abs_regular (-(x \\<sqinter> y))) \\<squnion> up_filter (Abs_dense ((x \\<sqinter> y) \\<squnion> -(x \\<sqinter> y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x) \\<squnion> Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y))) =\n    stone_phi (Abs_regular (- (x \\<sqinter> y))) \\<squnion>\n    up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))", "using 2"], ["proof (prove)\nusing this:\n  \\<forall>x. in_p_image (- x)\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- x) \\<squnion> Abs_regular (- y)) \\<squnion>\n    up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y))) =\n    stone_phi (Abs_regular (- (x \\<sqinter> y))) \\<squnion>\n    up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))", "by (subst sup_regular.abs_eq) (simp_all add: eq_onp_same_args)"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- x) \\<squnion> Abs_regular (- y)) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y))) =\n  stone_phi (Abs_regular (- (x \\<sqinter> y))) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "finally"], ["proof (chain)\npicking this:\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- (x \\<sqinter> y))) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))", "have 6: \"stone_phi (Abs_regular (-(x \\<sqinter> y))) \\<squnion> up_filter (Abs_dense ((x \\<sqinter> y) \\<squnion> -(x \\<sqinter> y))) = (stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) \\<squnion> (stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y)))\""], ["proof (prove)\nusing this:\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y))) =\n  stone_phi (Abs_regular (- (x \\<sqinter> y))) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y)))\n\ngoal (1 subgoal):\n 1. stone_phi (Abs_regular (- (x \\<sqinter> y))) \\<squnion>\n    up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y))) =\n    stone_phi (Abs_regular (- x)) \\<squnion>\n    up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n    (stone_phi (Abs_regular (- y)) \\<squnion>\n     up_filter (Abs_dense (y \\<squnion> - y)))", "by simp"], ["proof (state)\nthis:\n  stone_phi (Abs_regular (- (x \\<sqinter> y))) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y))) =\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "have \"Abs_regular (--(x \\<sqinter> y)) = Abs_regular (--x) \\<sqinter> Abs_regular (--y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_regular (- - (x \\<sqinter> y)) =\n    Abs_regular (- - x) \\<sqinter> Abs_regular (- - y)", "using 2"], ["proof (prove)\nusing this:\n  \\<forall>x. in_p_image (- x)\n\ngoal (1 subgoal):\n 1. Abs_regular (- - (x \\<sqinter> y)) =\n    Abs_regular (- - x) \\<sqinter> Abs_regular (- - y)", "by (subst inf_regular.abs_eq) (simp_all add: eq_onp_same_args)"], ["proof (state)\nthis:\n  Abs_regular (- - (x \\<sqinter> y)) =\n  Abs_regular (- - x) \\<sqinter> Abs_regular (- - y)\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "hence \"Abs_stone_phi_pair (Abs_regular (--(x \\<sqinter> y)),stone_phi (Abs_regular (-(x \\<sqinter> y))) \\<squnion> up_filter (Abs_dense ((x \\<sqinter> y) \\<squnion> -(x \\<sqinter> y)))) = Abs_stone_phi_pair (triple.pairs_inf (Abs_regular (--x),stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) (Abs_regular (--y),stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y))))\""], ["proof (prove)\nusing this:\n  Abs_regular (- - (x \\<sqinter> y)) =\n  Abs_regular (- - x) \\<sqinter> Abs_regular (- - y)\n\ngoal (1 subgoal):\n 1. sa_iso (x \\<sqinter> y) =\n    Abs_stone_phi_pair\n     (stone_phi.pairs_inf\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x)))\n       (Abs_regular (- - y),\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y))))", "using 6"], ["proof (prove)\nusing this:\n  Abs_regular (- - (x \\<sqinter> y)) =\n  Abs_regular (- - x) \\<sqinter> Abs_regular (- - y)\n  stone_phi (Abs_regular (- (x \\<sqinter> y))) \\<squnion>\n  up_filter (Abs_dense (x \\<sqinter> y \\<squnion> - (x \\<sqinter> y))) =\n  stone_phi (Abs_regular (- x)) \\<squnion>\n  up_filter (Abs_dense (x \\<squnion> - x)) \\<squnion>\n  (stone_phi (Abs_regular (- y)) \\<squnion>\n   up_filter (Abs_dense (y \\<squnion> - y)))\n\ngoal (1 subgoal):\n 1. sa_iso (x \\<sqinter> y) =\n    Abs_stone_phi_pair\n     (stone_phi.pairs_inf\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x)))\n       (Abs_regular (- - y),\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y))))", "by auto"], ["proof (state)\nthis:\n  sa_iso (x \\<sqinter> y) =\n  Abs_stone_phi_pair\n   (stone_phi.pairs_inf\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))\n     (Abs_regular (- - y),\n      stone_phi (Abs_regular (- y)) \\<squnion>\n      up_filter (Abs_dense (y \\<squnion> - y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "also"], ["proof (state)\nthis:\n  sa_iso (x \\<sqinter> y) =\n  Abs_stone_phi_pair\n   (stone_phi.pairs_inf\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))\n     (Abs_regular (- - y),\n      stone_phi (Abs_regular (- y)) \\<squnion>\n      up_filter (Abs_dense (y \\<squnion> - y))))\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "have \"... = Abs_stone_phi_pair (Abs_regular (--x),stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))) \\<sqinter> Abs_stone_phi_pair (Abs_regular (--y),stone_phi (Abs_regular (-y)) \\<squnion> up_filter (Abs_dense (y \\<squnion> -y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (stone_phi.pairs_inf\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x)))\n       (Abs_regular (- - y),\n        stone_phi (Abs_regular (- y)) \\<squnion>\n        up_filter (Abs_dense (y \\<squnion> - y)))) =\n    sa_iso x \\<sqinter> sa_iso y", "by (rule inf_stone_phi_pair.abs_eq[THEN sym]) (simp_all add: eq_onp_same_args sa_iso_triple_pair)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (stone_phi.pairs_inf\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))\n     (Abs_regular (- - y),\n      stone_phi (Abs_regular (- y)) \\<squnion>\n      up_filter (Abs_dense (y \\<squnion> - y)))) =\n  sa_iso x \\<sqinter> sa_iso y\n\ngoal (1 subgoal):\n 1. \\<And>x y. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "finally"], ["proof (chain)\npicking this:\n  sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "show \"sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y\""], ["proof (prove)\nusing this:\n  sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y\n\ngoal (1 subgoal):\n 1. sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y", "."], ["proof (state)\nthis:\n  sa_iso (x \\<sqinter> y) = sa_iso x \\<sqinter> sa_iso y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inf_homomorphism sa_iso\n\ngoal (2 subgoals):\n 1. uminus_homomorphism sa_iso\n 2. bij sa_iso", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. uminus_homomorphism sa_iso\n 2. bij sa_iso", "show \"\\<forall>x::'a . sa_iso (-x) = -sa_iso x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uminus_homomorphism sa_iso", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. sa_iso (- x) = - sa_iso x", "fix x :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. sa_iso (- x) = - sa_iso x", "have \"sa_iso (-x) = Abs_stone_phi_pair (Abs_regular (---x),stone_phi (Abs_regular (--x)) \\<squnion> up_filter top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sa_iso (- x) =\n    Abs_stone_phi_pair\n     (Abs_regular (- - - x),\n      stone_phi (Abs_regular (- - x)) \\<squnion> up_filter top)", "by (simp add: top_dense_def)"], ["proof (state)\nthis:\n  sa_iso (- x) =\n  Abs_stone_phi_pair\n   (Abs_regular (- - - x),\n    stone_phi (Abs_regular (- - x)) \\<squnion> up_filter top)\n\ngoal (1 subgoal):\n 1. \\<And>x. sa_iso (- x) = - sa_iso x", "also"], ["proof (state)\nthis:\n  sa_iso (- x) =\n  Abs_stone_phi_pair\n   (Abs_regular (- - - x),\n    stone_phi (Abs_regular (- - x)) \\<squnion> up_filter top)\n\ngoal (1 subgoal):\n 1. \\<And>x. sa_iso (- x) = - sa_iso x", "have \"... = Abs_stone_phi_pair (Abs_regular (---x),stone_phi (Abs_regular (--x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (Abs_regular (- - - x),\n      stone_phi (Abs_regular (- - x)) \\<squnion> up_filter top) =\n    Abs_stone_phi_pair\n     (Abs_regular (- - - x), stone_phi (Abs_regular (- - x)))", "by (metis bot_filter.abs_eq sup_bot.right_neutral up_top)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (Abs_regular (- - - x),\n    stone_phi (Abs_regular (- - x)) \\<squnion> up_filter top) =\n  Abs_stone_phi_pair\n   (Abs_regular (- - - x), stone_phi (Abs_regular (- - x)))\n\ngoal (1 subgoal):\n 1. \\<And>x. sa_iso (- x) = - sa_iso x", "also"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (Abs_regular (- - - x),\n    stone_phi (Abs_regular (- - x)) \\<squnion> up_filter top) =\n  Abs_stone_phi_pair\n   (Abs_regular (- - - x), stone_phi (Abs_regular (- - x)))\n\ngoal (1 subgoal):\n 1. \\<And>x. sa_iso (- x) = - sa_iso x", "have \"... = Abs_stone_phi_pair (triple.pairs_uminus stone_phi (Abs_regular (--x),stone_phi (Abs_regular (-x)) \\<squnion> up_filter (Abs_dense (x \\<squnion> -x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (Abs_regular (- - - x), stone_phi (Abs_regular (- - x))) =\n    Abs_stone_phi_pair\n     (stone_phi.pairs_uminus\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x))))", "by (subst uminus_regular.abs_eq[THEN sym], unfold eq_onp_same_args) auto"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (Abs_regular (- - - x), stone_phi (Abs_regular (- - x))) =\n  Abs_stone_phi_pair\n   (stone_phi.pairs_uminus\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x))))\n\ngoal (1 subgoal):\n 1. \\<And>x. sa_iso (- x) = - sa_iso x", "also"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (Abs_regular (- - - x), stone_phi (Abs_regular (- - x))) =\n  Abs_stone_phi_pair\n   (stone_phi.pairs_uminus\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x))))\n\ngoal (1 subgoal):\n 1. \\<And>x. sa_iso (- x) = - sa_iso x", "have \"... = -sa_iso x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_stone_phi_pair\n     (stone_phi.pairs_uminus\n       (Abs_regular (- - x),\n        stone_phi (Abs_regular (- x)) \\<squnion>\n        up_filter (Abs_dense (x \\<squnion> - x)))) =\n    - sa_iso x", "by (simp add: eq_onp_def sa_iso_triple_pair uminus_stone_phi_pair.abs_eq)"], ["proof (state)\nthis:\n  Abs_stone_phi_pair\n   (stone_phi.pairs_uminus\n     (Abs_regular (- - x),\n      stone_phi (Abs_regular (- x)) \\<squnion>\n      up_filter (Abs_dense (x \\<squnion> - x)))) =\n  - sa_iso x\n\ngoal (1 subgoal):\n 1. \\<And>x. sa_iso (- x) = - sa_iso x", "finally"], ["proof (chain)\npicking this:\n  sa_iso (- x) = - sa_iso x", "show \"sa_iso (-x) = -sa_iso x\""], ["proof (prove)\nusing this:\n  sa_iso (- x) = - sa_iso x\n\ngoal (1 subgoal):\n 1. sa_iso (- x) = - sa_iso x", "by simp"], ["proof (state)\nthis:\n  sa_iso (- x) = - sa_iso x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  uminus_homomorphism sa_iso\n\ngoal (1 subgoal):\n 1. bij sa_iso", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bij sa_iso", "show \"bij sa_iso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij sa_iso", "by (metis (mono_tags, lifting) sa_iso_left_invertible sa_iso_right_invertible invertible_bij[where g=sa_iso_inv])"], ["proof (state)\nthis:\n  bij sa_iso\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Triple Isomorphism\\<close>"], ["", "text \\<open>\nIn this section we prove that the triple of the Stone algebra of a triple is isomorphic to the original triple.\nThe notion of isomorphism for triples is described in \\cite{ChenGraetzer1969}.\nIt amounts to an isomorphism of Boolean algebras, an isomorphism of distributive lattices with a greatest element, and a commuting diagram involving the structure maps.\n\\<close>"], ["", "subsubsection \\<open>Boolean Algebra Isomorphism\\<close>"], ["", "text \\<open>\nWe first define and prove the isomorphism of Boolean algebras.\nBecause the Stone algebra of a triple is implemented as a lifted pair, we also lift the Boolean algebra.\n\\<close>"], ["", "typedef (overloaded) ('a,'b) lifted_boolean_algebra = \"{ xf::('a::non_trivial_boolean_algebra,'b::distrib_lattice_top) phi \\<Rightarrow> 'a . True }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {xf. True}", "by simp"], ["", "setup_lifting type_definition_lifted_boolean_algebra"], ["", "instantiation lifted_boolean_algebra :: (non_trivial_boolean_algebra,distrib_lattice_top) boolean_algebra\nbegin"], ["", "lift_definition sup_lifted_boolean_algebra :: \"('a,'b) lifted_boolean_algebra \\<Rightarrow> ('a,'b) lifted_boolean_algebra \\<Rightarrow> ('a,'b) lifted_boolean_algebra\" is \"\\<lambda>xf yf f . sup (xf f) (yf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2. \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> True", "."], ["", "lift_definition inf_lifted_boolean_algebra :: \"('a,'b) lifted_boolean_algebra \\<Rightarrow> ('a,'b) lifted_boolean_algebra \\<Rightarrow> ('a,'b) lifted_boolean_algebra\" is \"\\<lambda>xf yf f . inf (xf f) (yf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2. \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> True", "."], ["", "lift_definition minus_lifted_boolean_algebra :: \"('a,'b) lifted_boolean_algebra \\<Rightarrow> ('a,'b) lifted_boolean_algebra \\<Rightarrow> ('a,'b) lifted_boolean_algebra\" is \"\\<lambda>xf yf f . minus (xf f) (yf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2. \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> True", "."], ["", "lift_definition uminus_lifted_boolean_algebra :: \"('a,'b) lifted_boolean_algebra \\<Rightarrow> ('a,'b) lifted_boolean_algebra\" is \"\\<lambda>xf f . uminus (xf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. True \\<Longrightarrow> True", "."], ["", "lift_definition bot_lifted_boolean_algebra :: \"('a,'b) lifted_boolean_algebra\" is \"\\<lambda>f . bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True", ".."], ["", "lift_definition top_lifted_boolean_algebra :: \"('a,'b) lifted_boolean_algebra\" is \"\\<lambda>f . top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True", ".."], ["", "lift_definition less_eq_lifted_boolean_algebra :: \"('a,'b) lifted_boolean_algebra \\<Rightarrow> ('a,'b) lifted_boolean_algebra \\<Rightarrow> bool\" is \"\\<lambda>xf yf . \\<forall>f . less_eq (xf f) (yf f)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_lifted_boolean_algebra :: \"('a,'b) lifted_boolean_algebra \\<Rightarrow> ('a,'b) lifted_boolean_algebra \\<Rightarrow> bool\" is \"\\<lambda>xf yf . (\\<forall>f . less_eq (xf f) (yf f)) \\<and> \\<not> (\\<forall>f . less_eq (yf f) (xf f))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) lifted_boolean_algebra, boolean_algebra_class)", "apply intro_classes"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 16 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x_ < y_) = (x_ \\<le> y_ \\<and> \\<not> y_ \\<le> x_)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>f. x f \\<le> y f) \\<and>\n                          \\<not> (\\<forall>f. y f \\<le> x f)) =\n                         ((\\<forall>f. x f \\<le> y f) \\<and>\n                          \\<not> (\\<forall>f. y f \\<le> x f))", "by auto"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. bot \\<le> a\nA total of 15 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. True \\<Longrightarrow> \\<forall>f. x f \\<le> x f", "by auto"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. bot \\<le> a\n 10. \\<And>a. a \\<le> top\nA total of 14 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; y_ \\<le> z_\\<rbrakk> \\<Longrightarrow> x_ \\<le> z_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>True; True; \\<forall>f. x f \\<le> y f; True;\n        \\<forall>f. y f \\<le> z f\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. x f \\<le> z f", "using order_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>True; True; \\<forall>f. x f \\<le> y f; True;\n        \\<forall>f. y f \\<le> z f\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. x f \\<le> z f", "by blast"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 13 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; y_ \\<le> x_\\<rbrakk> \\<Longrightarrow> x_ = y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True; \\<forall>f. x f \\<le> y f;\n        \\<forall>f. y f \\<le> x f\\<rbrakk>\n       \\<Longrightarrow> x = y", "using antisym ext"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  (\\<And>x. ?f x = ?g x) \\<Longrightarrow> ?f = ?g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True; \\<forall>f. x f \\<le> y f;\n        \\<forall>f. y f \\<le> x f\\<rbrakk>\n       \\<Longrightarrow> x = y", "by blast"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. bot \\<le> a\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x. x \\<sqinter> - x = bot\nA total of 12 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<sqinter> y_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. x f \\<sqinter> y f \\<le> x f", "by auto"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x. x \\<sqinter> - x = bot\n 10. \\<And>x. x \\<squnion> - x = top\nA total of 11 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<sqinter> y_ \\<le> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. x f \\<sqinter> y f \\<le> y f", "by auto"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x. x \\<sqinter> - x = bot\n 9. \\<And>x. x \\<squnion> - x = top\n 10. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; x_ \\<le> z_\\<rbrakk>\n    \\<Longrightarrow> x_ \\<le> y_ \\<sqinter> z_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>True; True; \\<forall>f. x f \\<le> y f; True;\n        \\<forall>f. x f \\<le> z f\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. x f \\<le> y f \\<sqinter> z f", "by auto"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x. x \\<sqinter> - x = bot\n 8. \\<And>x. x \\<squnion> - x = top\n 9. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<le> x_ \\<squnion> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. x f \\<le> x f \\<squnion> y f", "by auto"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x. x \\<sqinter> - x = bot\n 7. \\<And>x. x \\<squnion> - x = top\n 8. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. y_ \\<le> x_ \\<squnion> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>True; True\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. y f \\<le> x f \\<squnion> y f", "by auto"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x. x \\<sqinter> - x = bot\n 6. \\<And>x. x \\<squnion> - x = top\n 7. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y_ \\<le> x_; z_ \\<le> x_\\<rbrakk>\n    \\<Longrightarrow> y_ \\<squnion> z_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x z.\n       \\<lbrakk>True; True; \\<forall>f. y f \\<le> x f; True;\n        \\<forall>f. z f \\<le> x f\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. y f \\<squnion> z f \\<le> x f", "by auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x. x \\<sqinter> - x = bot\n 5. \\<And>x. x \\<squnion> - x = top\n 6. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. bot \\<le> a_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. True \\<Longrightarrow> \\<forall>f. bot \\<le> a f", "by auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x. x \\<sqinter> - x = bot\n 4. \\<And>x. x \\<squnion> - x = top\n 5. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_ \\<le> top", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. True \\<Longrightarrow> \\<forall>f. a f \\<le> top", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x. x \\<sqinter> - x = bot\n 3. \\<And>x. x \\<squnion> - x = top\n 4. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<squnion> y_ \\<sqinter> z_ =\n    (x_ \\<squnion> y_) \\<sqinter> (x_ \\<squnion> z_)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>True; True; True\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>f. x f \\<squnion> y f \\<sqinter> z f) =\n                         (\\<lambda>f.\n                             (x f \\<squnion> y f) \\<sqinter>\n                             (x f \\<squnion> z f))", "by (simp add: sup_inf_distrib1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<sqinter> - x = bot\n 2. \\<And>x. x \\<squnion> - x = top\n 3. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<sqinter> - x_ = bot", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       True \\<Longrightarrow>\n       (\\<lambda>f. x f \\<sqinter> - x f) = (\\<lambda>f. bot)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<squnion> - x = top\n 2. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<squnion> - x_ = top", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       True \\<Longrightarrow>\n       (\\<lambda>f. x f \\<squnion> - x f) = (\\<lambda>f. top)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x - y = x \\<sqinter> - y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ - y_ = x_ \\<sqinter> - y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>f. x f - y f) =\n                         (\\<lambda>f. x f \\<sqinter> - y f)", "by (simp add: diff_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text \\<open>\nThe following two definitions give the Boolean algebra isomorphism.\n\\<close>"], ["", "abbreviation ba_iso_inv :: \"('a::non_trivial_boolean_algebra,'b::distrib_lattice_top) lifted_boolean_algebra \\<Rightarrow> ('a,'b) lifted_pair regular\"\n  where \"ba_iso_inv \\<equiv> \\<lambda>xf . Abs_regular (Abs_lifted_pair (\\<lambda>f . (Rep_lifted_boolean_algebra xf f,Rep_phi f (-Rep_lifted_boolean_algebra xf f))))\""], ["", "abbreviation ba_iso :: \"('a::non_trivial_boolean_algebra,'b::distrib_lattice_top) lifted_pair regular \\<Rightarrow> ('a,'b) lifted_boolean_algebra\"\n  where \"ba_iso \\<equiv> \\<lambda>pf . Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular pf) f))\""], ["", "lemma ba_iso_inv_lifted_pair:\n  \"(Rep_lifted_boolean_algebra xf f,Rep_phi f (-Rep_lifted_boolean_algebra xf f)) \\<in> triple.pairs (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Rep_lifted_boolean_algebra xf f,\n     Rep_phi f (- Rep_lifted_boolean_algebra xf f))\n    \\<in> triple.pairs (Rep_phi f)", "by (metis (no_types, hide_lams) double_compl simp_phi triple.pairs_uminus.simps triple_def triple.pairs_uminus_closed)"], ["", "lemma ba_iso_inv_regular:\n  \"regular (Abs_lifted_pair (\\<lambda>f . (Rep_lifted_boolean_algebra xf f,Rep_phi f (-Rep_lifted_boolean_algebra xf f))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "have \"\\<forall>f . (Rep_lifted_boolean_algebra xf f,Rep_phi f (-Rep_lifted_boolean_algebra xf f)) = triple.pairs_uminus (Rep_phi f) (triple.pairs_uminus (Rep_phi f) (Rep_lifted_boolean_algebra xf f,Rep_phi f (-Rep_lifted_boolean_algebra xf f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       (Rep_lifted_boolean_algebra xf f,\n        Rep_phi f (- Rep_lifted_boolean_algebra xf f)) =\n       triple.pairs_uminus (Rep_phi f)\n        (triple.pairs_uminus (Rep_phi f)\n          (Rep_lifted_boolean_algebra xf f,\n           Rep_phi f (- Rep_lifted_boolean_algebra xf f)))", "by (simp add: triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  \\<forall>f.\n     (Rep_lifted_boolean_algebra xf f,\n      Rep_phi f (- Rep_lifted_boolean_algebra xf f)) =\n     triple.pairs_uminus (Rep_phi f)\n      (triple.pairs_uminus (Rep_phi f)\n        (Rep_lifted_boolean_algebra xf f,\n         Rep_phi f (- Rep_lifted_boolean_algebra xf f)))\n\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "hence \"Abs_lifted_pair (\\<lambda>f . (Rep_lifted_boolean_algebra xf f,Rep_phi f (-Rep_lifted_boolean_algebra xf f))) = --Abs_lifted_pair (\\<lambda>f . (Rep_lifted_boolean_algebra xf f,Rep_phi f (-Rep_lifted_boolean_algebra xf f)))\""], ["proof (prove)\nusing this:\n  \\<forall>f.\n     (Rep_lifted_boolean_algebra xf f,\n      Rep_phi f (- Rep_lifted_boolean_algebra xf f)) =\n     triple.pairs_uminus (Rep_phi f)\n      (triple.pairs_uminus (Rep_phi f)\n        (Rep_lifted_boolean_algebra xf f,\n         Rep_phi f (- Rep_lifted_boolean_algebra xf f)))\n\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "by (simp add: triple.pairs_uminus_closed triple_def eq_onp_def uminus_lifted_pair.abs_eq ba_iso_inv_lifted_pair)"], ["proof (state)\nthis:\n  regular\n   (Abs_lifted_pair\n     (\\<lambda>f.\n         (Rep_lifted_boolean_algebra xf f,\n          Rep_phi f (- Rep_lifted_boolean_algebra xf f))))\n\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  regular\n   (Abs_lifted_pair\n     (\\<lambda>f.\n         (Rep_lifted_boolean_algebra xf f,\n          Rep_phi f (- Rep_lifted_boolean_algebra xf f))))\n\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "by simp"], ["proof (state)\nthis:\n  regular\n   (Abs_lifted_pair\n     (\\<lambda>f.\n         (Rep_lifted_boolean_algebra xf f,\n          Rep_phi f (- Rep_lifted_boolean_algebra xf f))))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe following two results prove that the isomorphisms are mutually inverse.\n\\<close>"], ["", "lemma ba_iso_left_invertible:\n  \"ba_iso_inv (ba_iso pf) = pf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ba_iso_inv (ba_iso pf) = pf", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ba_iso_inv (ba_iso pf) = pf", "have 1: \"\\<forall>f . snd (Rep_lifted_pair (Rep_regular pf) f) = Rep_phi f (-fst (Rep_lifted_pair (Rep_regular pf) f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       snd (Rep_lifted_pair (Rep_regular pf) f) =\n       Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       snd (Rep_lifted_pair (Rep_regular pf) f) =\n       Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       snd (Rep_lifted_pair (Rep_regular pf) f) =\n       Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))", "let ?r = \"Rep_phi f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       snd (Rep_lifted_pair (Rep_regular pf) f) =\n       Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))", "have \"triple ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       snd (Rep_lifted_pair (Rep_regular pf) f) =\n       Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))", "hence 2: \"\\<forall>p . triple.pairs_uminus ?r p = (-fst p,?r (fst p))\""], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       triple.pairs_uminus (Rep_phi f) p = (- fst p, Rep_phi f (fst p))", "by (metis prod.collapse triple.pairs_uminus.simps)"], ["proof (state)\nthis:\n  \\<forall>p.\n     triple.pairs_uminus (Rep_phi f) p = (- fst p, Rep_phi f (fst p))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       snd (Rep_lifted_pair (Rep_regular pf) f) =\n       Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))", "have 3: \"Rep_regular pf = --Rep_regular pf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (Rep_regular pf)", "by (simp add: regular_in_p_image_iff)"], ["proof (state)\nthis:\n  regular (Rep_regular pf)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       snd (Rep_lifted_pair (Rep_regular pf) f) =\n       Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))", "show \"snd (Rep_lifted_pair (Rep_regular pf) f) = ?r (-fst (Rep_lifted_pair (Rep_regular pf) f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Rep_lifted_pair (Rep_regular pf) f) =\n    Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))", "using 2 3"], ["proof (prove)\nusing this:\n  \\<forall>p.\n     triple.pairs_uminus (Rep_phi f) p = (- fst p, Rep_phi f (fst p))\n  regular (Rep_regular pf)\n\ngoal (1 subgoal):\n 1. snd (Rep_lifted_pair (Rep_regular pf) f) =\n    Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))", "by (metis fstI sndI uminus_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  snd (Rep_lifted_pair (Rep_regular pf) f) =\n  Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>f.\n     snd (Rep_lifted_pair (Rep_regular pf) f) =\n     Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))\n\ngoal (1 subgoal):\n 1. ba_iso_inv (ba_iso pf) = pf", "have \"ba_iso_inv (ba_iso pf) = Abs_regular (Abs_lifted_pair (\\<lambda>f . (fst (Rep_lifted_pair (Rep_regular pf) f),Rep_phi f (-fst (Rep_lifted_pair (Rep_regular pf) f)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ba_iso_inv (ba_iso pf) =\n    Abs_regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (fst (Rep_lifted_pair (Rep_regular pf) f),\n            Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f)))))", "by (simp add: Abs_lifted_boolean_algebra_inverse)"], ["proof (state)\nthis:\n  ba_iso_inv (ba_iso pf) =\n  Abs_regular\n   (Abs_lifted_pair\n     (\\<lambda>f.\n         (fst (Rep_lifted_pair (Rep_regular pf) f),\n          Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f)))))\n\ngoal (1 subgoal):\n 1. ba_iso_inv (ba_iso pf) = pf", "also"], ["proof (state)\nthis:\n  ba_iso_inv (ba_iso pf) =\n  Abs_regular\n   (Abs_lifted_pair\n     (\\<lambda>f.\n         (fst (Rep_lifted_pair (Rep_regular pf) f),\n          Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f)))))\n\ngoal (1 subgoal):\n 1. ba_iso_inv (ba_iso pf) = pf", "have \"... = Abs_regular (Abs_lifted_pair (Rep_lifted_pair (Rep_regular pf)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (fst (Rep_lifted_pair (Rep_regular pf) f),\n            Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))))) =\n    Abs_regular (Abs_lifted_pair (Rep_lifted_pair (Rep_regular pf)))", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     snd (Rep_lifted_pair (Rep_regular pf) f) =\n     Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))\n\ngoal (1 subgoal):\n 1. Abs_regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (fst (Rep_lifted_pair (Rep_regular pf) f),\n            Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))))) =\n    Abs_regular (Abs_lifted_pair (Rep_lifted_pair (Rep_regular pf)))", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  Abs_regular\n   (Abs_lifted_pair\n     (\\<lambda>f.\n         (fst (Rep_lifted_pair (Rep_regular pf) f),\n          Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))))) =\n  Abs_regular (Abs_lifted_pair (Rep_lifted_pair (Rep_regular pf)))\n\ngoal (1 subgoal):\n 1. ba_iso_inv (ba_iso pf) = pf", "also"], ["proof (state)\nthis:\n  Abs_regular\n   (Abs_lifted_pair\n     (\\<lambda>f.\n         (fst (Rep_lifted_pair (Rep_regular pf) f),\n          Rep_phi f (- fst (Rep_lifted_pair (Rep_regular pf) f))))) =\n  Abs_regular (Abs_lifted_pair (Rep_lifted_pair (Rep_regular pf)))\n\ngoal (1 subgoal):\n 1. ba_iso_inv (ba_iso pf) = pf", "have \"... = pf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_regular (Abs_lifted_pair (Rep_lifted_pair (Rep_regular pf))) = pf", "by (simp add: Rep_regular_inverse Rep_lifted_pair_inverse)"], ["proof (state)\nthis:\n  Abs_regular (Abs_lifted_pair (Rep_lifted_pair (Rep_regular pf))) = pf\n\ngoal (1 subgoal):\n 1. ba_iso_inv (ba_iso pf) = pf", "finally"], ["proof (chain)\npicking this:\n  ba_iso_inv (ba_iso pf) = pf", "show ?thesis"], ["proof (prove)\nusing this:\n  ba_iso_inv (ba_iso pf) = pf\n\ngoal (1 subgoal):\n 1. ba_iso_inv (ba_iso pf) = pf", "."], ["proof (state)\nthis:\n  ba_iso_inv (ba_iso pf) = pf\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ba_iso_right_invertible:\n  \"ba_iso (ba_iso_inv xf) = xf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ba_iso (ba_iso_inv xf) = xf", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ba_iso (ba_iso_inv xf) = xf", "let ?rf = \"Rep_lifted_boolean_algebra xf\""], ["proof (state)\ngoal (1 subgoal):\n 1. ba_iso (ba_iso_inv xf) = xf", "have 1: \"\\<forall>f . (-?rf f,Rep_phi f (?rf f)) \\<in> triple.pairs (Rep_phi f) \\<and> (?rf f,Rep_phi f (-?rf f)) \\<in> triple.pairs (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       (- Rep_lifted_boolean_algebra xf f,\n        Rep_phi f (Rep_lifted_boolean_algebra xf f))\n       \\<in> triple.pairs (Rep_phi f) \\<and>\n       (Rep_lifted_boolean_algebra xf f,\n        Rep_phi f (- Rep_lifted_boolean_algebra xf f))\n       \\<in> triple.pairs (Rep_phi f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       (- Rep_lifted_boolean_algebra xf f,\n        Rep_phi f (Rep_lifted_boolean_algebra xf f))\n       \\<in> triple.pairs (Rep_phi f) \\<and>\n       (Rep_lifted_boolean_algebra xf f,\n        Rep_phi f (- Rep_lifted_boolean_algebra xf f))\n       \\<in> triple.pairs (Rep_phi f)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       (- Rep_lifted_boolean_algebra xf f,\n        Rep_phi f (Rep_lifted_boolean_algebra xf f))\n       \\<in> triple.pairs (Rep_phi f) \\<and>\n       (Rep_lifted_boolean_algebra xf f,\n        Rep_phi f (- Rep_lifted_boolean_algebra xf f))\n       \\<in> triple.pairs (Rep_phi f)", "have \"up_filter top = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up_filter top = bot", "by (simp add: bot_filter.abs_eq)"], ["proof (state)\nthis:\n  up_filter top = bot\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       (- Rep_lifted_boolean_algebra xf f,\n        Rep_phi f (Rep_lifted_boolean_algebra xf f))\n       \\<in> triple.pairs (Rep_phi f) \\<and>\n       (Rep_lifted_boolean_algebra xf f,\n        Rep_phi f (- Rep_lifted_boolean_algebra xf f))\n       \\<in> triple.pairs (Rep_phi f)", "hence \"(\\<exists>z . Rep_phi f (?rf f) = Rep_phi f (?rf f) \\<squnion> up_filter z) \\<and> (\\<exists>z . Rep_phi f (-?rf f) = Rep_phi f (-?rf f) \\<squnion> up_filter z)\""], ["proof (prove)\nusing this:\n  up_filter top = bot\n\ngoal (1 subgoal):\n 1. (\\<exists>z.\n        Rep_phi f (Rep_lifted_boolean_algebra xf f) =\n        Rep_phi f (Rep_lifted_boolean_algebra xf f) \\<squnion>\n        up_filter z) \\<and>\n    (\\<exists>z.\n        Rep_phi f (- Rep_lifted_boolean_algebra xf f) =\n        Rep_phi f (- Rep_lifted_boolean_algebra xf f) \\<squnion>\n        up_filter z)", "by (metis sup_bot_right)"], ["proof (state)\nthis:\n  (\\<exists>z.\n      Rep_phi f (Rep_lifted_boolean_algebra xf f) =\n      Rep_phi f (Rep_lifted_boolean_algebra xf f) \\<squnion>\n      up_filter z) \\<and>\n  (\\<exists>z.\n      Rep_phi f (- Rep_lifted_boolean_algebra xf f) =\n      Rep_phi f (- Rep_lifted_boolean_algebra xf f) \\<squnion> up_filter z)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       (- Rep_lifted_boolean_algebra xf f,\n        Rep_phi f (Rep_lifted_boolean_algebra xf f))\n       \\<in> triple.pairs (Rep_phi f) \\<and>\n       (Rep_lifted_boolean_algebra xf f,\n        Rep_phi f (- Rep_lifted_boolean_algebra xf f))\n       \\<in> triple.pairs (Rep_phi f)", "thus \"(-?rf f,Rep_phi f (?rf f)) \\<in> triple.pairs (Rep_phi f) \\<and> (?rf f,Rep_phi f (-?rf f)) \\<in> triple.pairs (Rep_phi f)\""], ["proof (prove)\nusing this:\n  (\\<exists>z.\n      Rep_phi f (Rep_lifted_boolean_algebra xf f) =\n      Rep_phi f (Rep_lifted_boolean_algebra xf f) \\<squnion>\n      up_filter z) \\<and>\n  (\\<exists>z.\n      Rep_phi f (- Rep_lifted_boolean_algebra xf f) =\n      Rep_phi f (- Rep_lifted_boolean_algebra xf f) \\<squnion> up_filter z)\n\ngoal (1 subgoal):\n 1. (- Rep_lifted_boolean_algebra xf f,\n     Rep_phi f (Rep_lifted_boolean_algebra xf f))\n    \\<in> triple.pairs (Rep_phi f) \\<and>\n    (Rep_lifted_boolean_algebra xf f,\n     Rep_phi f (- Rep_lifted_boolean_algebra xf f))\n    \\<in> triple.pairs (Rep_phi f)", "by (simp add: triple_def triple.pairs_def)"], ["proof (state)\nthis:\n  (- Rep_lifted_boolean_algebra xf f,\n   Rep_phi f (Rep_lifted_boolean_algebra xf f))\n  \\<in> triple.pairs (Rep_phi f) \\<and>\n  (Rep_lifted_boolean_algebra xf f,\n   Rep_phi f (- Rep_lifted_boolean_algebra xf f))\n  \\<in> triple.pairs (Rep_phi f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>f.\n     (- Rep_lifted_boolean_algebra xf f,\n      Rep_phi f (Rep_lifted_boolean_algebra xf f))\n     \\<in> triple.pairs (Rep_phi f) \\<and>\n     (Rep_lifted_boolean_algebra xf f,\n      Rep_phi f (- Rep_lifted_boolean_algebra xf f))\n     \\<in> triple.pairs (Rep_phi f)\n\ngoal (1 subgoal):\n 1. ba_iso (ba_iso_inv xf) = xf", "have \"regular (Abs_lifted_pair (\\<lambda>f . (?rf f,Rep_phi f (-?rf f))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "have \"--Abs_lifted_pair (\\<lambda>f . (?rf f,Rep_phi f (-?rf f))) = -Abs_lifted_pair (\\<lambda>f . triple.pairs_uminus (Rep_phi f) (?rf f,Rep_phi f (-?rf f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - Abs_lifted_pair\n         (\\<lambda>f.\n             (Rep_lifted_boolean_algebra xf f,\n              Rep_phi f (- Rep_lifted_boolean_algebra xf f))) =\n    - Abs_lifted_pair\n       (\\<lambda>f.\n           triple.pairs_uminus (Rep_phi f)\n            (Rep_lifted_boolean_algebra xf f,\n             Rep_phi f (- Rep_lifted_boolean_algebra xf f)))", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     (- Rep_lifted_boolean_algebra xf f,\n      Rep_phi f (Rep_lifted_boolean_algebra xf f))\n     \\<in> triple.pairs (Rep_phi f) \\<and>\n     (Rep_lifted_boolean_algebra xf f,\n      Rep_phi f (- Rep_lifted_boolean_algebra xf f))\n     \\<in> triple.pairs (Rep_phi f)\n\ngoal (1 subgoal):\n 1. - - Abs_lifted_pair\n         (\\<lambda>f.\n             (Rep_lifted_boolean_algebra xf f,\n              Rep_phi f (- Rep_lifted_boolean_algebra xf f))) =\n    - Abs_lifted_pair\n       (\\<lambda>f.\n           triple.pairs_uminus (Rep_phi f)\n            (Rep_lifted_boolean_algebra xf f,\n             Rep_phi f (- Rep_lifted_boolean_algebra xf f)))", "by (simp add: eq_onp_same_args uminus_lifted_pair.abs_eq)"], ["proof (state)\nthis:\n  - - Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))) =\n  - Abs_lifted_pair\n     (\\<lambda>f.\n         triple.pairs_uminus (Rep_phi f)\n          (Rep_lifted_boolean_algebra xf f,\n           Rep_phi f (- Rep_lifted_boolean_algebra xf f)))\n\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "also"], ["proof (state)\nthis:\n  - - Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))) =\n  - Abs_lifted_pair\n     (\\<lambda>f.\n         triple.pairs_uminus (Rep_phi f)\n          (Rep_lifted_boolean_algebra xf f,\n           Rep_phi f (- Rep_lifted_boolean_algebra xf f)))\n\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "have \"... = -Abs_lifted_pair (\\<lambda>f . (-?rf f,Rep_phi f (?rf f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - Abs_lifted_pair\n       (\\<lambda>f.\n           triple.pairs_uminus (Rep_phi f)\n            (Rep_lifted_boolean_algebra xf f,\n             Rep_phi f (- Rep_lifted_boolean_algebra xf f))) =\n    - Abs_lifted_pair\n       (\\<lambda>f.\n           (- Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (Rep_lifted_boolean_algebra xf f)))", "by (metis (no_types, lifting) simp_phi triple_def triple.pairs_uminus.simps)"], ["proof (state)\nthis:\n  - Abs_lifted_pair\n     (\\<lambda>f.\n         triple.pairs_uminus (Rep_phi f)\n          (Rep_lifted_boolean_algebra xf f,\n           Rep_phi f (- Rep_lifted_boolean_algebra xf f))) =\n  - Abs_lifted_pair\n     (\\<lambda>f.\n         (- Rep_lifted_boolean_algebra xf f,\n          Rep_phi f (Rep_lifted_boolean_algebra xf f)))\n\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "also"], ["proof (state)\nthis:\n  - Abs_lifted_pair\n     (\\<lambda>f.\n         triple.pairs_uminus (Rep_phi f)\n          (Rep_lifted_boolean_algebra xf f,\n           Rep_phi f (- Rep_lifted_boolean_algebra xf f))) =\n  - Abs_lifted_pair\n     (\\<lambda>f.\n         (- Rep_lifted_boolean_algebra xf f,\n          Rep_phi f (Rep_lifted_boolean_algebra xf f)))\n\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "have \"... = Abs_lifted_pair (\\<lambda>f . triple.pairs_uminus (Rep_phi f) (-?rf f,Rep_phi f (?rf f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - Abs_lifted_pair\n       (\\<lambda>f.\n           (- Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (Rep_lifted_boolean_algebra xf f))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         triple.pairs_uminus (Rep_phi f)\n          (- Rep_lifted_boolean_algebra xf f,\n           Rep_phi f (Rep_lifted_boolean_algebra xf f)))", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     (- Rep_lifted_boolean_algebra xf f,\n      Rep_phi f (Rep_lifted_boolean_algebra xf f))\n     \\<in> triple.pairs (Rep_phi f) \\<and>\n     (Rep_lifted_boolean_algebra xf f,\n      Rep_phi f (- Rep_lifted_boolean_algebra xf f))\n     \\<in> triple.pairs (Rep_phi f)\n\ngoal (1 subgoal):\n 1. - Abs_lifted_pair\n       (\\<lambda>f.\n           (- Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (Rep_lifted_boolean_algebra xf f))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         triple.pairs_uminus (Rep_phi f)\n          (- Rep_lifted_boolean_algebra xf f,\n           Rep_phi f (Rep_lifted_boolean_algebra xf f)))", "by (simp add: eq_onp_same_args uminus_lifted_pair.abs_eq)"], ["proof (state)\nthis:\n  - Abs_lifted_pair\n     (\\<lambda>f.\n         (- Rep_lifted_boolean_algebra xf f,\n          Rep_phi f (Rep_lifted_boolean_algebra xf f))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       triple.pairs_uminus (Rep_phi f)\n        (- Rep_lifted_boolean_algebra xf f,\n         Rep_phi f (Rep_lifted_boolean_algebra xf f)))\n\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "also"], ["proof (state)\nthis:\n  - Abs_lifted_pair\n     (\\<lambda>f.\n         (- Rep_lifted_boolean_algebra xf f,\n          Rep_phi f (Rep_lifted_boolean_algebra xf f))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       triple.pairs_uminus (Rep_phi f)\n        (- Rep_lifted_boolean_algebra xf f,\n         Rep_phi f (Rep_lifted_boolean_algebra xf f)))\n\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "have \"... = Abs_lifted_pair (\\<lambda>f . (?rf f,Rep_phi f (-?rf f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         triple.pairs_uminus (Rep_phi f)\n          (- Rep_lifted_boolean_algebra xf f,\n           Rep_phi f (Rep_lifted_boolean_algebra xf f))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         (Rep_lifted_boolean_algebra xf f,\n          Rep_phi f (- Rep_lifted_boolean_algebra xf f)))", "by (metis (no_types, lifting) simp_phi triple_def triple.pairs_uminus.simps double_compl)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       triple.pairs_uminus (Rep_phi f)\n        (- Rep_lifted_boolean_algebra xf f,\n         Rep_phi f (Rep_lifted_boolean_algebra xf f))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       (Rep_lifted_boolean_algebra xf f,\n        Rep_phi f (- Rep_lifted_boolean_algebra xf f)))\n\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "finally"], ["proof (chain)\npicking this:\n  - - Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       (Rep_lifted_boolean_algebra xf f,\n        Rep_phi f (- Rep_lifted_boolean_algebra xf f)))", "show ?thesis"], ["proof (prove)\nusing this:\n  - - Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       (Rep_lifted_boolean_algebra xf f,\n        Rep_phi f (- Rep_lifted_boolean_algebra xf f)))\n\ngoal (1 subgoal):\n 1. regular\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "by simp"], ["proof (state)\nthis:\n  regular\n   (Abs_lifted_pair\n     (\\<lambda>f.\n         (Rep_lifted_boolean_algebra xf f,\n          Rep_phi f (- Rep_lifted_boolean_algebra xf f))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  regular\n   (Abs_lifted_pair\n     (\\<lambda>f.\n         (Rep_lifted_boolean_algebra xf f,\n          Rep_phi f (- Rep_lifted_boolean_algebra xf f))))\n\ngoal (1 subgoal):\n 1. ba_iso (ba_iso_inv xf) = xf", "hence \"in_p_image (Abs_lifted_pair (\\<lambda>f . (?rf f,Rep_phi f (-?rf f))))\""], ["proof (prove)\nusing this:\n  regular\n   (Abs_lifted_pair\n     (\\<lambda>f.\n         (Rep_lifted_boolean_algebra xf f,\n          Rep_phi f (- Rep_lifted_boolean_algebra xf f))))\n\ngoal (1 subgoal):\n 1. in_p_image\n     (Abs_lifted_pair\n       (\\<lambda>f.\n           (Rep_lifted_boolean_algebra xf f,\n            Rep_phi f (- Rep_lifted_boolean_algebra xf f))))", "by blast"], ["proof (state)\nthis:\n  in_p_image\n   (Abs_lifted_pair\n     (\\<lambda>f.\n         (Rep_lifted_boolean_algebra xf f,\n          Rep_phi f (- Rep_lifted_boolean_algebra xf f))))\n\ngoal (1 subgoal):\n 1. ba_iso (ba_iso_inv xf) = xf", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_p_image\n   (Abs_lifted_pair\n     (\\<lambda>f.\n         (Rep_lifted_boolean_algebra xf f,\n          Rep_phi f (- Rep_lifted_boolean_algebra xf f))))\n\ngoal (1 subgoal):\n 1. ba_iso (ba_iso_inv xf) = xf", "using 1"], ["proof (prove)\nusing this:\n  in_p_image\n   (Abs_lifted_pair\n     (\\<lambda>f.\n         (Rep_lifted_boolean_algebra xf f,\n          Rep_phi f (- Rep_lifted_boolean_algebra xf f))))\n  \\<forall>f.\n     (- Rep_lifted_boolean_algebra xf f,\n      Rep_phi f (Rep_lifted_boolean_algebra xf f))\n     \\<in> triple.pairs (Rep_phi f) \\<and>\n     (Rep_lifted_boolean_algebra xf f,\n      Rep_phi f (- Rep_lifted_boolean_algebra xf f))\n     \\<in> triple.pairs (Rep_phi f)\n\ngoal (1 subgoal):\n 1. ba_iso (ba_iso_inv xf) = xf", "by (simp add: Rep_lifted_boolean_algebra_inverse Abs_lifted_pair_inverse Abs_regular_inverse)"], ["proof (state)\nthis:\n  ba_iso (ba_iso_inv xf) = xf\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe isomorphism is established by proving the remaining Boolean algebra homomorphism properties.\n\\<close>"], ["", "lemma ba_iso:\n  \"boolean_algebra_isomorphism ba_iso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((bounded_lattice_homomorphism ba_iso \\<and>\n      uminus_homomorphism ba_iso) \\<and>\n     bij ba_iso) \\<and>\n    minus_homomorphism ba_iso", "proof (intro conjI)"], ["proof (state)\ngoal (7 subgoals):\n 1. sup_homomorphism ba_iso\n 2. inf_homomorphism ba_iso\n 3. top_homomorphism ba_iso\n 4. bot_homomorphism ba_iso\n 5. uminus_homomorphism ba_iso\n 6. bij ba_iso\n 7. minus_homomorphism ba_iso", "show \"Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular bot) f)) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot_homomorphism ba_iso", "by (simp add: bot_lifted_boolean_algebra_def bot_regular.rep_eq bot_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  bot_homomorphism ba_iso\n\ngoal (6 subgoals):\n 1. sup_homomorphism ba_iso\n 2. inf_homomorphism ba_iso\n 3. top_homomorphism ba_iso\n 4. uminus_homomorphism ba_iso\n 5. bij ba_iso\n 6. minus_homomorphism ba_iso", "show \"Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular top) f)) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_homomorphism ba_iso", "by (simp add: top_lifted_boolean_algebra_def top_regular.rep_eq top_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  top_homomorphism ba_iso\n\ngoal (5 subgoals):\n 1. sup_homomorphism ba_iso\n 2. inf_homomorphism ba_iso\n 3. uminus_homomorphism ba_iso\n 4. bij ba_iso\n 5. minus_homomorphism ba_iso", "show \"\\<forall>pf qf . Abs_lifted_boolean_algebra (\\<lambda>f::('a,'b) phi . fst (Rep_lifted_pair (Rep_regular (pf \\<squnion> qf)) f)) = Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular pf) f)) \\<squnion> Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular qf) f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_homomorphism ba_iso", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<squnion> qf) = ba_iso pf \\<squnion> ba_iso qf", "fix pf qf :: \"('a,'b) lifted_pair regular\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<squnion> qf) = ba_iso pf \\<squnion> ba_iso qf", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<squnion> qf) = ba_iso pf \\<squnion> ba_iso qf", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<squnion> qf) = ba_iso pf \\<squnion> ba_iso qf", "obtain x y z w where 1: \"(x,y) = Rep_lifted_pair (Rep_regular pf) f \\<and> (z,w) = Rep_lifted_pair (Rep_regular qf) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y z w.\n        (x, y) = Rep_lifted_pair (Rep_regular pf) f \\<and>\n        (z, w) = Rep_lifted_pair (Rep_regular qf) f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x y z w.\n        (x, y) = Rep_lifted_pair (Rep_regular pf) f \\<and>\n        (z, w) = Rep_lifted_pair (Rep_regular qf) f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x, y) = Rep_lifted_pair (Rep_regular pf) f \\<and>\n  (z, w) = Rep_lifted_pair (Rep_regular qf) f\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<squnion> qf) = ba_iso pf \\<squnion> ba_iso qf", "have \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<squnion> qf) = ba_iso pf \\<squnion> ba_iso qf", "hence \"fst (triple.pairs_sup (x,y) (z,w)) = fst (x,y) \\<squnion> fst (z,w)\""], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. fst (triple.pairs_sup (x, y) (z, w)) = fst (x, y) \\<squnion> fst (z, w)", "using triple.pairs_sup.simps"], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n  triple ?phi \\<Longrightarrow>\n  triple.pairs_sup (?x, ?y) (?z, ?w) = (?x \\<squnion> ?z, ?y \\<sqinter> ?w)\n\ngoal (1 subgoal):\n 1. fst (triple.pairs_sup (x, y) (z, w)) = fst (x, y) \\<squnion> fst (z, w)", "by force"], ["proof (state)\nthis:\n  fst (triple.pairs_sup (x, y) (z, w)) = fst (x, y) \\<squnion> fst (z, w)\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<squnion> qf) = ba_iso pf \\<squnion> ba_iso qf", "hence \"fst (triple.pairs_sup (Rep_lifted_pair (Rep_regular pf) f) (Rep_lifted_pair (Rep_regular qf) f)) = fst (Rep_lifted_pair (Rep_regular pf) f) \\<squnion> fst (Rep_lifted_pair (Rep_regular qf) f)\""], ["proof (prove)\nusing this:\n  fst (triple.pairs_sup (x, y) (z, w)) = fst (x, y) \\<squnion> fst (z, w)\n\ngoal (1 subgoal):\n 1. fst (triple.pairs_sup (Rep_lifted_pair (Rep_regular pf) f)\n          (Rep_lifted_pair (Rep_regular qf) f)) =\n    fst (Rep_lifted_pair (Rep_regular pf) f) \\<squnion>\n    fst (Rep_lifted_pair (Rep_regular qf) f)", "using 1"], ["proof (prove)\nusing this:\n  fst (triple.pairs_sup (x, y) (z, w)) = fst (x, y) \\<squnion> fst (z, w)\n  (x, y) = Rep_lifted_pair (Rep_regular pf) f \\<and>\n  (z, w) = Rep_lifted_pair (Rep_regular qf) f\n\ngoal (1 subgoal):\n 1. fst (triple.pairs_sup (Rep_lifted_pair (Rep_regular pf) f)\n          (Rep_lifted_pair (Rep_regular qf) f)) =\n    fst (Rep_lifted_pair (Rep_regular pf) f) \\<squnion>\n    fst (Rep_lifted_pair (Rep_regular qf) f)", "by simp"], ["proof (state)\nthis:\n  fst (triple.pairs_sup (Rep_lifted_pair (Rep_regular pf) f)\n        (Rep_lifted_pair (Rep_regular qf) f)) =\n  fst (Rep_lifted_pair (Rep_regular pf) f) \\<squnion>\n  fst (Rep_lifted_pair (Rep_regular qf) f)\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<squnion> qf) = ba_iso pf \\<squnion> ba_iso qf", "hence \"fst (Rep_lifted_pair (Rep_regular (pf \\<squnion> qf)) f) = fst (Rep_lifted_pair (Rep_regular pf) f) \\<squnion> fst (Rep_lifted_pair (Rep_regular qf) f)\""], ["proof (prove)\nusing this:\n  fst (triple.pairs_sup (Rep_lifted_pair (Rep_regular pf) f)\n        (Rep_lifted_pair (Rep_regular qf) f)) =\n  fst (Rep_lifted_pair (Rep_regular pf) f) \\<squnion>\n  fst (Rep_lifted_pair (Rep_regular qf) f)\n\ngoal (1 subgoal):\n 1. fst (Rep_lifted_pair (Rep_regular (pf \\<squnion> qf)) f) =\n    fst (Rep_lifted_pair (Rep_regular pf) f) \\<squnion>\n    fst (Rep_lifted_pair (Rep_regular qf) f)", "by (unfold sup_regular.rep_eq sup_lifted_pair.rep_eq) simp"], ["proof (state)\nthis:\n  fst (Rep_lifted_pair (Rep_regular (pf \\<squnion> qf)) f) =\n  fst (Rep_lifted_pair (Rep_regular pf) f) \\<squnion>\n  fst (Rep_lifted_pair (Rep_regular qf) f)\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<squnion> qf) = ba_iso pf \\<squnion> ba_iso qf", "}"], ["proof (state)\nthis:\n  fst (Rep_lifted_pair (Rep_regular (pf \\<squnion> qf)) ?f4) =\n  fst (Rep_lifted_pair (Rep_regular pf) ?f4) \\<squnion>\n  fst (Rep_lifted_pair (Rep_regular qf) ?f4)\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<squnion> qf) = ba_iso pf \\<squnion> ba_iso qf", "thus \"Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular (pf \\<squnion> qf)) f)) = Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular pf) f)) \\<squnion> Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular qf) f))\""], ["proof (prove)\nusing this:\n  fst (Rep_lifted_pair (Rep_regular (pf \\<squnion> qf)) ?f4) =\n  fst (Rep_lifted_pair (Rep_regular pf) ?f4) \\<squnion>\n  fst (Rep_lifted_pair (Rep_regular qf) ?f4)\n\ngoal (1 subgoal):\n 1. ba_iso (pf \\<squnion> qf) = ba_iso pf \\<squnion> ba_iso qf", "by (simp add: eq_onp_same_args sup_lifted_boolean_algebra.abs_eq sup_regular.rep_eq sup_lifted_boolean_algebra.rep_eq)"], ["proof (state)\nthis:\n  ba_iso (pf \\<squnion> qf) = ba_iso pf \\<squnion> ba_iso qf\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sup_homomorphism ba_iso\n\ngoal (4 subgoals):\n 1. inf_homomorphism ba_iso\n 2. uminus_homomorphism ba_iso\n 3. bij ba_iso\n 4. minus_homomorphism ba_iso", "show 1: \"\\<forall>pf qf . Abs_lifted_boolean_algebra (\\<lambda>f::('a,'b) phi . fst (Rep_lifted_pair (Rep_regular (pf \\<sqinter> qf)) f)) = Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular pf) f)) \\<sqinter> Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular qf) f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_homomorphism ba_iso", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<sqinter> qf) = ba_iso pf \\<sqinter> ba_iso qf", "fix pf qf :: \"('a,'b) lifted_pair regular\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<sqinter> qf) = ba_iso pf \\<sqinter> ba_iso qf", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<sqinter> qf) = ba_iso pf \\<sqinter> ba_iso qf", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<sqinter> qf) = ba_iso pf \\<sqinter> ba_iso qf", "obtain x y z w where 1: \"(x,y) = Rep_lifted_pair (Rep_regular pf) f \\<and> (z,w) = Rep_lifted_pair (Rep_regular qf) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y z w.\n        (x, y) = Rep_lifted_pair (Rep_regular pf) f \\<and>\n        (z, w) = Rep_lifted_pair (Rep_regular qf) f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x y z w.\n        (x, y) = Rep_lifted_pair (Rep_regular pf) f \\<and>\n        (z, w) = Rep_lifted_pair (Rep_regular qf) f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x, y) = Rep_lifted_pair (Rep_regular pf) f \\<and>\n  (z, w) = Rep_lifted_pair (Rep_regular qf) f\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<sqinter> qf) = ba_iso pf \\<sqinter> ba_iso qf", "have \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<sqinter> qf) = ba_iso pf \\<sqinter> ba_iso qf", "hence \"fst (triple.pairs_inf (x,y) (z,w)) = fst (x,y) \\<sqinter> fst (z,w)\""], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. fst (triple.pairs_inf (x, y) (z, w)) = fst (x, y) \\<sqinter> fst (z, w)", "using triple.pairs_inf.simps"], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n  triple ?phi \\<Longrightarrow>\n  triple.pairs_inf (?x, ?y) (?z, ?w) = (?x \\<sqinter> ?z, ?y \\<squnion> ?w)\n\ngoal (1 subgoal):\n 1. fst (triple.pairs_inf (x, y) (z, w)) = fst (x, y) \\<sqinter> fst (z, w)", "by force"], ["proof (state)\nthis:\n  fst (triple.pairs_inf (x, y) (z, w)) = fst (x, y) \\<sqinter> fst (z, w)\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<sqinter> qf) = ba_iso pf \\<sqinter> ba_iso qf", "hence \"fst (triple.pairs_inf (Rep_lifted_pair (Rep_regular pf) f) (Rep_lifted_pair (Rep_regular qf) f)) = fst (Rep_lifted_pair (Rep_regular pf) f) \\<sqinter> fst (Rep_lifted_pair (Rep_regular qf) f)\""], ["proof (prove)\nusing this:\n  fst (triple.pairs_inf (x, y) (z, w)) = fst (x, y) \\<sqinter> fst (z, w)\n\ngoal (1 subgoal):\n 1. fst (triple.pairs_inf (Rep_lifted_pair (Rep_regular pf) f)\n          (Rep_lifted_pair (Rep_regular qf) f)) =\n    fst (Rep_lifted_pair (Rep_regular pf) f) \\<sqinter>\n    fst (Rep_lifted_pair (Rep_regular qf) f)", "using 1"], ["proof (prove)\nusing this:\n  fst (triple.pairs_inf (x, y) (z, w)) = fst (x, y) \\<sqinter> fst (z, w)\n  (x, y) = Rep_lifted_pair (Rep_regular pf) f \\<and>\n  (z, w) = Rep_lifted_pair (Rep_regular qf) f\n\ngoal (1 subgoal):\n 1. fst (triple.pairs_inf (Rep_lifted_pair (Rep_regular pf) f)\n          (Rep_lifted_pair (Rep_regular qf) f)) =\n    fst (Rep_lifted_pair (Rep_regular pf) f) \\<sqinter>\n    fst (Rep_lifted_pair (Rep_regular qf) f)", "by simp"], ["proof (state)\nthis:\n  fst (triple.pairs_inf (Rep_lifted_pair (Rep_regular pf) f)\n        (Rep_lifted_pair (Rep_regular qf) f)) =\n  fst (Rep_lifted_pair (Rep_regular pf) f) \\<sqinter>\n  fst (Rep_lifted_pair (Rep_regular qf) f)\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<sqinter> qf) = ba_iso pf \\<sqinter> ba_iso qf", "hence \"fst (Rep_lifted_pair (Rep_regular (pf \\<sqinter> qf)) f) = fst (Rep_lifted_pair (Rep_regular pf) f) \\<sqinter> fst (Rep_lifted_pair (Rep_regular qf) f)\""], ["proof (prove)\nusing this:\n  fst (triple.pairs_inf (Rep_lifted_pair (Rep_regular pf) f)\n        (Rep_lifted_pair (Rep_regular qf) f)) =\n  fst (Rep_lifted_pair (Rep_regular pf) f) \\<sqinter>\n  fst (Rep_lifted_pair (Rep_regular qf) f)\n\ngoal (1 subgoal):\n 1. fst (Rep_lifted_pair (Rep_regular (pf \\<sqinter> qf)) f) =\n    fst (Rep_lifted_pair (Rep_regular pf) f) \\<sqinter>\n    fst (Rep_lifted_pair (Rep_regular qf) f)", "by (unfold inf_regular.rep_eq inf_lifted_pair.rep_eq) simp"], ["proof (state)\nthis:\n  fst (Rep_lifted_pair (Rep_regular (pf \\<sqinter> qf)) f) =\n  fst (Rep_lifted_pair (Rep_regular pf) f) \\<sqinter>\n  fst (Rep_lifted_pair (Rep_regular qf) f)\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<sqinter> qf) = ba_iso pf \\<sqinter> ba_iso qf", "}"], ["proof (state)\nthis:\n  fst (Rep_lifted_pair (Rep_regular (pf \\<sqinter> qf)) ?f4) =\n  fst (Rep_lifted_pair (Rep_regular pf) ?f4) \\<sqinter>\n  fst (Rep_lifted_pair (Rep_regular qf) ?f4)\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. ba_iso (pf \\<sqinter> qf) = ba_iso pf \\<sqinter> ba_iso qf", "thus \"Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular (pf \\<sqinter> qf)) f)) = Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular pf) f)) \\<sqinter> Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular qf) f))\""], ["proof (prove)\nusing this:\n  fst (Rep_lifted_pair (Rep_regular (pf \\<sqinter> qf)) ?f4) =\n  fst (Rep_lifted_pair (Rep_regular pf) ?f4) \\<sqinter>\n  fst (Rep_lifted_pair (Rep_regular qf) ?f4)\n\ngoal (1 subgoal):\n 1. ba_iso (pf \\<sqinter> qf) = ba_iso pf \\<sqinter> ba_iso qf", "by (simp add: eq_onp_same_args inf_lifted_boolean_algebra.abs_eq inf_regular.rep_eq inf_lifted_boolean_algebra.rep_eq)"], ["proof (state)\nthis:\n  ba_iso (pf \\<sqinter> qf) = ba_iso pf \\<sqinter> ba_iso qf\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inf_homomorphism ba_iso\n\ngoal (3 subgoals):\n 1. uminus_homomorphism ba_iso\n 2. bij ba_iso\n 3. minus_homomorphism ba_iso", "show \"\\<forall>pf . Abs_lifted_boolean_algebra (\\<lambda>f::('a,'b) phi . fst (Rep_lifted_pair (Rep_regular (-pf)) f)) = -Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular pf) f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uminus_homomorphism ba_iso", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf. ba_iso (- pf) = - ba_iso pf", "fix pf :: \"('a,'b) lifted_pair regular\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf. ba_iso (- pf) = - ba_iso pf", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf. ba_iso (- pf) = - ba_iso pf", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf. ba_iso (- pf) = - ba_iso pf", "obtain x y where 1: \"(x,y) = Rep_lifted_pair (Rep_regular pf) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        (x, y) = Rep_lifted_pair (Rep_regular pf) f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        (x, y) = Rep_lifted_pair (Rep_regular pf) f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x, y) = Rep_lifted_pair (Rep_regular pf) f\n\ngoal (1 subgoal):\n 1. \\<And>pf. ba_iso (- pf) = - ba_iso pf", "have \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. \\<And>pf. ba_iso (- pf) = - ba_iso pf", "hence \"fst (triple.pairs_uminus (Rep_phi f) (x,y)) = -fst (x,y)\""], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. fst (triple.pairs_uminus (Rep_phi f) (x, y)) = - fst (x, y)", "using triple.pairs_uminus.simps"], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n  triple ?phi \\<Longrightarrow>\n  triple.pairs_uminus ?phi (?x, ?y) = (- ?x, ?phi ?x)\n\ngoal (1 subgoal):\n 1. fst (triple.pairs_uminus (Rep_phi f) (x, y)) = - fst (x, y)", "by force"], ["proof (state)\nthis:\n  fst (triple.pairs_uminus (Rep_phi f) (x, y)) = - fst (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>pf. ba_iso (- pf) = - ba_iso pf", "hence \"fst (triple.pairs_uminus (Rep_phi f) (Rep_lifted_pair (Rep_regular pf) f)) = -fst (Rep_lifted_pair (Rep_regular pf) f)\""], ["proof (prove)\nusing this:\n  fst (triple.pairs_uminus (Rep_phi f) (x, y)) = - fst (x, y)\n\ngoal (1 subgoal):\n 1. fst (triple.pairs_uminus (Rep_phi f)\n          (Rep_lifted_pair (Rep_regular pf) f)) =\n    - fst (Rep_lifted_pair (Rep_regular pf) f)", "using 1"], ["proof (prove)\nusing this:\n  fst (triple.pairs_uminus (Rep_phi f) (x, y)) = - fst (x, y)\n  (x, y) = Rep_lifted_pair (Rep_regular pf) f\n\ngoal (1 subgoal):\n 1. fst (triple.pairs_uminus (Rep_phi f)\n          (Rep_lifted_pair (Rep_regular pf) f)) =\n    - fst (Rep_lifted_pair (Rep_regular pf) f)", "by simp"], ["proof (state)\nthis:\n  fst (triple.pairs_uminus (Rep_phi f)\n        (Rep_lifted_pair (Rep_regular pf) f)) =\n  - fst (Rep_lifted_pair (Rep_regular pf) f)\n\ngoal (1 subgoal):\n 1. \\<And>pf. ba_iso (- pf) = - ba_iso pf", "hence \"fst (Rep_lifted_pair (Rep_regular (-pf)) f) = -fst (Rep_lifted_pair (Rep_regular pf) f)\""], ["proof (prove)\nusing this:\n  fst (triple.pairs_uminus (Rep_phi f)\n        (Rep_lifted_pair (Rep_regular pf) f)) =\n  - fst (Rep_lifted_pair (Rep_regular pf) f)\n\ngoal (1 subgoal):\n 1. fst (Rep_lifted_pair (Rep_regular (- pf)) f) =\n    - fst (Rep_lifted_pair (Rep_regular pf) f)", "by (unfold uminus_regular.rep_eq uminus_lifted_pair.rep_eq) simp"], ["proof (state)\nthis:\n  fst (Rep_lifted_pair (Rep_regular (- pf)) f) =\n  - fst (Rep_lifted_pair (Rep_regular pf) f)\n\ngoal (1 subgoal):\n 1. \\<And>pf. ba_iso (- pf) = - ba_iso pf", "}"], ["proof (state)\nthis:\n  fst (Rep_lifted_pair (Rep_regular (- pf)) ?f4) =\n  - fst (Rep_lifted_pair (Rep_regular pf) ?f4)\n\ngoal (1 subgoal):\n 1. \\<And>pf. ba_iso (- pf) = - ba_iso pf", "thus \"Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular (-pf)) f)) = -Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular pf) f))\""], ["proof (prove)\nusing this:\n  fst (Rep_lifted_pair (Rep_regular (- pf)) ?f4) =\n  - fst (Rep_lifted_pair (Rep_regular pf) ?f4)\n\ngoal (1 subgoal):\n 1. ba_iso (- pf) = - ba_iso pf", "by (simp add: eq_onp_same_args uminus_lifted_boolean_algebra.abs_eq uminus_regular.rep_eq uminus_lifted_boolean_algebra.rep_eq)"], ["proof (state)\nthis:\n  ba_iso (- pf) = - ba_iso pf\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  uminus_homomorphism ba_iso\n\ngoal (2 subgoals):\n 1. bij ba_iso\n 2. minus_homomorphism ba_iso", "thus \"\\<forall>pf qf . Abs_lifted_boolean_algebra (\\<lambda>f::('a,'b) phi . fst (Rep_lifted_pair (Rep_regular (pf - qf)) f)) = Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular pf) f)) - Abs_lifted_boolean_algebra (\\<lambda>f . fst (Rep_lifted_pair (Rep_regular qf) f))\""], ["proof (prove)\nusing this:\n  uminus_homomorphism ba_iso\n\ngoal (1 subgoal):\n 1. minus_homomorphism ba_iso", "using 1"], ["proof (prove)\nusing this:\n  uminus_homomorphism ba_iso\n  inf_homomorphism ba_iso\n\ngoal (1 subgoal):\n 1. minus_homomorphism ba_iso", "by (simp add: diff_eq)"], ["proof (state)\nthis:\n  minus_homomorphism ba_iso\n\ngoal (1 subgoal):\n 1. bij ba_iso", "show \"bij ba_iso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij ba_iso", "by (rule invertible_bij[where g=ba_iso_inv]) (simp_all add: ba_iso_left_invertible ba_iso_right_invertible)"], ["proof (state)\nthis:\n  bij ba_iso\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Distributive Lattice Isomorphism\\<close>"], ["", "text \\<open>\nWe carry out a similar development for the isomorphism of distributive lattices.\nAgain, the original distributive lattice with a greatest element needs to be lifted to match the lifted pairs.\n\\<close>"], ["", "typedef (overloaded) ('a,'b) lifted_distrib_lattice_top = \"{ xf::('a::non_trivial_boolean_algebra,'b::distrib_lattice_top) phi \\<Rightarrow> 'b . True }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {xf. True}", "by simp"], ["", "setup_lifting type_definition_lifted_distrib_lattice_top"], ["", "instantiation lifted_distrib_lattice_top :: (non_trivial_boolean_algebra,distrib_lattice_top) distrib_lattice_top\nbegin"], ["", "lift_definition sup_lifted_distrib_lattice_top :: \"('a,'b) lifted_distrib_lattice_top \\<Rightarrow> ('a,'b) lifted_distrib_lattice_top \\<Rightarrow> ('a,'b) lifted_distrib_lattice_top\" is \"\\<lambda>xf yf f . sup (xf f) (yf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2. \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> True", "."], ["", "lift_definition inf_lifted_distrib_lattice_top :: \"('a,'b) lifted_distrib_lattice_top \\<Rightarrow> ('a,'b) lifted_distrib_lattice_top \\<Rightarrow> ('a,'b) lifted_distrib_lattice_top\" is \"\\<lambda>xf yf f . inf (xf f) (yf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2. \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> True", "."], ["", "lift_definition top_lifted_distrib_lattice_top :: \"('a,'b) lifted_distrib_lattice_top\" is \"\\<lambda>f . top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True", ".."], ["", "lift_definition less_eq_lifted_distrib_lattice_top :: \"('a,'b) lifted_distrib_lattice_top \\<Rightarrow> ('a,'b) lifted_distrib_lattice_top \\<Rightarrow> bool\" is \"\\<lambda>xf yf . \\<forall>f . less_eq (xf f) (yf f)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_lifted_distrib_lattice_top :: \"('a,'b) lifted_distrib_lattice_top \\<Rightarrow> ('a,'b) lifted_distrib_lattice_top \\<Rightarrow> bool\" is \"\\<lambda>xf yf . (\\<forall>f . less_eq (xf f) (yf f)) \\<and> \\<not> (\\<forall>f . less_eq (yf f) (xf f))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) lifted_distrib_lattice_top, distrib_lattice_top_class)", "apply intro_classes"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 12 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x_ < y_) = (x_ \\<le> y_ \\<and> \\<not> y_ \\<le> x_)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>f. x f \\<le> y f) \\<and>\n                          \\<not> (\\<forall>f. y f \\<le> x f)) =\n                         ((\\<forall>f. x f \\<le> y f) \\<and>\n                          \\<not> (\\<forall>f. y f \\<le> x f))", "by auto"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. a \\<le> top\nA total of 11 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. True \\<Longrightarrow> \\<forall>f. x f \\<le> x f", "by auto"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. a \\<le> top\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; y_ \\<le> z_\\<rbrakk> \\<Longrightarrow> x_ \\<le> z_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>True; True; \\<forall>f. x f \\<le> y f; True;\n        \\<forall>f. y f \\<le> z f\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. x f \\<le> z f", "using order_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>True; True; \\<forall>f. x f \\<le> y f; True;\n        \\<forall>f. y f \\<le> z f\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. x f \\<le> z f", "by blast"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. a \\<le> top\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; y_ \\<le> x_\\<rbrakk> \\<Longrightarrow> x_ = y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True; \\<forall>f. x f \\<le> y f;\n        \\<forall>f. y f \\<le> x f\\<rbrakk>\n       \\<Longrightarrow> x = y", "using antisym ext"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  (\\<And>x. ?f x = ?g x) \\<Longrightarrow> ?f = ?g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True; \\<forall>f. x f \\<le> y f;\n        \\<forall>f. y f \\<le> x f\\<rbrakk>\n       \\<Longrightarrow> x = y", "by blast"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. a \\<le> top\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<sqinter> y_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. x f \\<sqinter> y f \\<le> x f", "by auto"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. a \\<le> top\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<sqinter> y_ \\<le> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. x f \\<sqinter> y f \\<le> y f", "by auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. a \\<le> top\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<le> y_; x_ \\<le> z_\\<rbrakk>\n    \\<Longrightarrow> x_ \\<le> y_ \\<sqinter> z_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>True; True; \\<forall>f. x f \\<le> y f; True;\n        \\<forall>f. x f \\<le> z f\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. x f \\<le> y f \\<sqinter> z f", "by auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<le> x_ \\<squnion> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; True\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. x f \\<le> x f \\<squnion> y f", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. a \\<le> top\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. y_ \\<le> x_ \\<squnion> y_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>True; True\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. y f \\<le> x f \\<squnion> y f", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. a \\<le> top\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y_ \\<le> x_; z_ \\<le> x_\\<rbrakk>\n    \\<Longrightarrow> y_ \\<squnion> z_ \\<le> x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x z.\n       \\<lbrakk>True; True; \\<forall>f. y f \\<le> x f; True;\n        \\<forall>f. z f \\<le> x f\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f. y f \\<squnion> z f \\<le> x f", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_ \\<le> top", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. True \\<Longrightarrow> \\<forall>f. a f \\<le> top", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<squnion> y_ \\<sqinter> z_ =\n    (x_ \\<squnion> y_) \\<sqinter> (x_ \\<squnion> z_)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>True; True; True\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>f. x f \\<squnion> y f \\<sqinter> z f) =\n                         (\\<lambda>f.\n                             (x f \\<squnion> y f) \\<sqinter>\n                             (x f \\<squnion> z f))", "by (simp add: sup_inf_distrib1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text \\<open>\nThe following function extracts the least element of the filter of a dense pair, which turns out to be a principal filter.\nIt is used to define one of the isomorphisms below.\n\\<close>"], ["", "fun get_dense :: \"('a::non_trivial_boolean_algebra,'b::distrib_lattice_top) lifted_pair dense \\<Rightarrow> ('a,'b) phi \\<Rightarrow> 'b\"\n  where \"get_dense pf f = (SOME z . Rep_lifted_pair (Rep_dense pf) f = (top,up_filter z))\""], ["", "lemma get_dense_char:\n  \"Rep_lifted_pair (Rep_dense pf) f = (top,up_filter (get_dense pf f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense pf) f = (top, up_filter (get_dense pf f))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense pf) f = (top, up_filter (get_dense pf f))", "obtain x y where 1: \"(x,y) = Rep_lifted_pair (Rep_dense pf) f \\<and> (x,y) \\<in> triple.pairs (Rep_phi f) \\<and> triple.pairs_uminus (Rep_phi f) (x,y) = triple.pairs_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        (x, y) = Rep_lifted_pair (Rep_dense pf) f \\<and>\n        (x, y) \\<in> triple.pairs (Rep_phi f) \\<and>\n        triple.pairs_uminus (Rep_phi f) (x, y) =\n        (bot, Filters.filter.Abs_filter UNIV) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis bot_lifted_pair.rep_eq prod.collapse simp_dense simp_lifted_pair uminus_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  (x, y) = Rep_lifted_pair (Rep_dense pf) f \\<and>\n  (x, y) \\<in> triple.pairs (Rep_phi f) \\<and>\n  triple.pairs_uminus (Rep_phi f) (x, y) =\n  (bot, Filters.filter.Abs_filter UNIV)\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense pf) f = (top, up_filter (get_dense pf f))", "hence 2: \"x = top\""], ["proof (prove)\nusing this:\n  (x, y) = Rep_lifted_pair (Rep_dense pf) f \\<and>\n  (x, y) \\<in> triple.pairs (Rep_phi f) \\<and>\n  triple.pairs_uminus (Rep_phi f) (x, y) =\n  (bot, Filters.filter.Abs_filter UNIV)\n\ngoal (1 subgoal):\n 1. x = top", "by (simp add: triple.intro triple.pairs_uminus.simps dense_pp)"], ["proof (state)\nthis:\n  x = top\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense pf) f = (top, up_filter (get_dense pf f))", "have \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense pf) f = (top, up_filter (get_dense pf f))", "hence \"\\<exists>z. y = Rep_phi f (-x) \\<squnion> up_filter z\""], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. \\<exists>z. y = Rep_phi f (- x) \\<squnion> up_filter z", "using 1 triple.pairs_def"], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n  (x, y) = Rep_lifted_pair (Rep_dense pf) f \\<and>\n  (x, y) \\<in> triple.pairs (Rep_phi f) \\<and>\n  triple.pairs_uminus (Rep_phi f) (x, y) =\n  (bot, Filters.filter.Abs_filter UNIV)\n  triple ?phi \\<Longrightarrow>\n  triple.pairs ?phi =\n  {(x, y). \\<exists>z. y = ?phi (- x) \\<squnion> up_filter z}\n\ngoal (1 subgoal):\n 1. \\<exists>z. y = Rep_phi f (- x) \\<squnion> up_filter z", "by blast"], ["proof (state)\nthis:\n  \\<exists>z. y = Rep_phi f (- x) \\<squnion> up_filter z\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense pf) f = (top, up_filter (get_dense pf f))", "then"], ["proof (chain)\npicking this:\n  \\<exists>z. y = Rep_phi f (- x) \\<squnion> up_filter z", "obtain z where \"y = up_filter z\""], ["proof (prove)\nusing this:\n  \\<exists>z. y = Rep_phi f (- x) \\<squnion> up_filter z\n\ngoal (1 subgoal):\n 1. (\\<And>z. y = up_filter z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2"], ["proof (prove)\nusing this:\n  \\<exists>z. y = Rep_phi f (- x) \\<squnion> up_filter z\n  x = top\n\ngoal (1 subgoal):\n 1. (\\<And>z. y = up_filter z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = up_filter z\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense pf) f = (top, up_filter (get_dense pf f))", "hence \"Rep_lifted_pair (Rep_dense pf) f = (top,up_filter z)\""], ["proof (prove)\nusing this:\n  y = up_filter z\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense pf) f = (top, up_filter z)", "using 1 2"], ["proof (prove)\nusing this:\n  y = up_filter z\n  (x, y) = Rep_lifted_pair (Rep_dense pf) f \\<and>\n  (x, y) \\<in> triple.pairs (Rep_phi f) \\<and>\n  triple.pairs_uminus (Rep_phi f) (x, y) =\n  (bot, Filters.filter.Abs_filter UNIV)\n  x = top\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense pf) f = (top, up_filter z)", "by simp"], ["proof (state)\nthis:\n  Rep_lifted_pair (Rep_dense pf) f = (top, up_filter z)\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense pf) f = (top, up_filter (get_dense pf f))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Rep_lifted_pair (Rep_dense pf) f = (top, up_filter z)\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense pf) f = (top, up_filter (get_dense pf f))", "by (metis (mono_tags, lifting) tfl_some get_dense.simps)"], ["proof (state)\nthis:\n  Rep_lifted_pair (Rep_dense pf) f = (top, up_filter (get_dense pf f))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe following two definitions give the distributive lattice isomorphism.\n\\<close>"], ["", "abbreviation dl_iso_inv :: \"('a::non_trivial_boolean_algebra,'b::distrib_lattice_top) lifted_distrib_lattice_top \\<Rightarrow> ('a,'b) lifted_pair dense\"\n  where \"dl_iso_inv \\<equiv> \\<lambda>xf . Abs_dense (Abs_lifted_pair (\\<lambda>f . (top,up_filter (Rep_lifted_distrib_lattice_top xf f))))\""], ["", "abbreviation dl_iso :: \"('a::non_trivial_boolean_algebra,'b::distrib_lattice_top) lifted_pair dense \\<Rightarrow> ('a,'b) lifted_distrib_lattice_top\"\n  where \"dl_iso \\<equiv> \\<lambda>pf . Abs_lifted_distrib_lattice_top (get_dense pf)\""], ["", "lemma dl_iso_inv_lifted_pair:\n  \"(top,up_filter (Rep_lifted_distrib_lattice_top xf f)) \\<in> triple.pairs (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))\n    \\<in> triple.pairs (Rep_phi f)", "by (metis (no_types, hide_lams) compl_bot_eq double_compl simp_phi sup_bot.left_neutral triple.sa_iso_pair triple_def)"], ["", "lemma dl_iso_inv_dense:\n  \"dense (Abs_lifted_pair (\\<lambda>f . (top,up_filter (Rep_lifted_distrib_lattice_top xf f))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "have \"\\<forall>f . triple.pairs_uminus (Rep_phi f) (top,up_filter (Rep_lifted_distrib_lattice_top xf f)) = triple.pairs_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       triple.pairs_uminus (Rep_phi f)\n        (top, up_filter (Rep_lifted_distrib_lattice_top xf f)) =\n       (bot, Filters.filter.Abs_filter UNIV)", "by (simp add: top_filter.abs_eq triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  \\<forall>f.\n     triple.pairs_uminus (Rep_phi f)\n      (top, up_filter (Rep_lifted_distrib_lattice_top xf f)) =\n     (bot, Filters.filter.Abs_filter UNIV)\n\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "hence \"bot = -Abs_lifted_pair (\\<lambda>f . (top,up_filter (Rep_lifted_distrib_lattice_top xf f)))\""], ["proof (prove)\nusing this:\n  \\<forall>f.\n     triple.pairs_uminus (Rep_phi f)\n      (top, up_filter (Rep_lifted_distrib_lattice_top xf f)) =\n     (bot, Filters.filter.Abs_filter UNIV)\n\ngoal (1 subgoal):\n 1. bot =\n    - Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f)))", "by (simp add: eq_onp_def uminus_lifted_pair.abs_eq dl_iso_inv_lifted_pair bot_lifted_pair_def)"], ["proof (state)\nthis:\n  bot =\n  - Abs_lifted_pair\n     (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f)))\n\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bot =\n  - Abs_lifted_pair\n     (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f)))\n\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "by simp"], ["proof (state)\nthis:\n  dense\n   (Abs_lifted_pair\n     (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe following two results prove that the isomorphisms are mutually inverse.\n\\<close>"], ["", "lemma dl_iso_left_invertible:\n  \"dl_iso_inv (dl_iso pf) = pf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dl_iso_inv (dl_iso pf) = pf", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dl_iso_inv (dl_iso pf) = pf", "have \"dl_iso_inv (dl_iso pf) = Abs_dense (Abs_lifted_pair (\\<lambda>f . (top,up_filter (get_dense pf f))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dl_iso_inv (dl_iso pf) =\n    Abs_dense\n     (Abs_lifted_pair (\\<lambda>f. (top, up_filter (get_dense pf f))))", "by (metis Abs_lifted_distrib_lattice_top_inverse UNIV_I UNIV_def)"], ["proof (state)\nthis:\n  dl_iso_inv (dl_iso pf) =\n  Abs_dense\n   (Abs_lifted_pair (\\<lambda>f. (top, up_filter (get_dense pf f))))\n\ngoal (1 subgoal):\n 1. dl_iso_inv (dl_iso pf) = pf", "also"], ["proof (state)\nthis:\n  dl_iso_inv (dl_iso pf) =\n  Abs_dense\n   (Abs_lifted_pair (\\<lambda>f. (top, up_filter (get_dense pf f))))\n\ngoal (1 subgoal):\n 1. dl_iso_inv (dl_iso pf) = pf", "have \"... = Abs_dense (Abs_lifted_pair (Rep_lifted_pair (Rep_dense pf)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_dense\n     (Abs_lifted_pair (\\<lambda>f. (top, up_filter (get_dense pf f)))) =\n    Abs_dense (Abs_lifted_pair (Rep_lifted_pair (Rep_dense pf)))", "by (metis get_dense_char)"], ["proof (state)\nthis:\n  Abs_dense\n   (Abs_lifted_pair (\\<lambda>f. (top, up_filter (get_dense pf f)))) =\n  Abs_dense (Abs_lifted_pair (Rep_lifted_pair (Rep_dense pf)))\n\ngoal (1 subgoal):\n 1. dl_iso_inv (dl_iso pf) = pf", "also"], ["proof (state)\nthis:\n  Abs_dense\n   (Abs_lifted_pair (\\<lambda>f. (top, up_filter (get_dense pf f)))) =\n  Abs_dense (Abs_lifted_pair (Rep_lifted_pair (Rep_dense pf)))\n\ngoal (1 subgoal):\n 1. dl_iso_inv (dl_iso pf) = pf", "have \"... = pf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_dense (Abs_lifted_pair (Rep_lifted_pair (Rep_dense pf))) = pf", "by (simp add: Rep_dense_inverse Rep_lifted_pair_inverse)"], ["proof (state)\nthis:\n  Abs_dense (Abs_lifted_pair (Rep_lifted_pair (Rep_dense pf))) = pf\n\ngoal (1 subgoal):\n 1. dl_iso_inv (dl_iso pf) = pf", "finally"], ["proof (chain)\npicking this:\n  dl_iso_inv (dl_iso pf) = pf", "show ?thesis"], ["proof (prove)\nusing this:\n  dl_iso_inv (dl_iso pf) = pf\n\ngoal (1 subgoal):\n 1. dl_iso_inv (dl_iso pf) = pf", "."], ["proof (state)\nthis:\n  dl_iso_inv (dl_iso pf) = pf\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dl_iso_right_invertible:\n  \"dl_iso (dl_iso_inv xf) = xf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dl_iso (dl_iso_inv xf) = xf", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dl_iso (dl_iso_inv xf) = xf", "let ?rf = \"Rep_lifted_distrib_lattice_top xf\""], ["proof (state)\ngoal (1 subgoal):\n 1. dl_iso (dl_iso_inv xf) = xf", "let ?pf = \"Abs_dense (Abs_lifted_pair (\\<lambda>f . (top,up_filter (?rf f))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. dl_iso (dl_iso_inv xf) = xf", "have 1: \"\\<forall>f . (top,up_filter (?rf f)) \\<in> triple.pairs (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       (top, up_filter (Rep_lifted_distrib_lattice_top xf f))\n       \\<in> triple.pairs (Rep_phi f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       (top, up_filter (Rep_lifted_distrib_lattice_top xf f))\n       \\<in> triple.pairs (Rep_phi f)", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       (top, up_filter (Rep_lifted_distrib_lattice_top xf f))\n       \\<in> triple.pairs (Rep_phi f)", "have \"triple (Rep_phi f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       (top, up_filter (Rep_lifted_distrib_lattice_top xf f))\n       \\<in> triple.pairs (Rep_phi f)", "thus \"(top,up_filter (?rf f)) \\<in> triple.pairs (Rep_phi f)\""], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))\n    \\<in> triple.pairs (Rep_phi f)", "using triple.pairs_def"], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n  triple ?phi \\<Longrightarrow>\n  triple.pairs ?phi =\n  {(x, y). \\<exists>z. y = ?phi (- x) \\<squnion> up_filter z}\n\ngoal (1 subgoal):\n 1. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))\n    \\<in> triple.pairs (Rep_phi f)", "by force"], ["proof (state)\nthis:\n  (top, up_filter (Rep_lifted_distrib_lattice_top xf f))\n  \\<in> triple.pairs (Rep_phi f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>f.\n     (top, up_filter (Rep_lifted_distrib_lattice_top xf f))\n     \\<in> triple.pairs (Rep_phi f)\n\ngoal (1 subgoal):\n 1. dl_iso (dl_iso_inv xf) = xf", "have 2: \"dense (Abs_lifted_pair (\\<lambda>f . (top,up_filter (?rf f))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "have \"-Abs_lifted_pair (\\<lambda>f . (top,up_filter (?rf f))) = Abs_lifted_pair (\\<lambda>f . triple.pairs_uminus (Rep_phi f) (top,up_filter (?rf f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - Abs_lifted_pair\n       (\\<lambda>f.\n           (top, up_filter (Rep_lifted_distrib_lattice_top xf f))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         triple.pairs_uminus (Rep_phi f)\n          (top, up_filter (Rep_lifted_distrib_lattice_top xf f)))", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     (top, up_filter (Rep_lifted_distrib_lattice_top xf f))\n     \\<in> triple.pairs (Rep_phi f)\n\ngoal (1 subgoal):\n 1. - Abs_lifted_pair\n       (\\<lambda>f.\n           (top, up_filter (Rep_lifted_distrib_lattice_top xf f))) =\n    Abs_lifted_pair\n     (\\<lambda>f.\n         triple.pairs_uminus (Rep_phi f)\n          (top, up_filter (Rep_lifted_distrib_lattice_top xf f)))", "by (simp add: eq_onp_same_args uminus_lifted_pair.abs_eq)"], ["proof (state)\nthis:\n  - Abs_lifted_pair\n     (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       triple.pairs_uminus (Rep_phi f)\n        (top, up_filter (Rep_lifted_distrib_lattice_top xf f)))\n\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "also"], ["proof (state)\nthis:\n  - Abs_lifted_pair\n     (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))) =\n  Abs_lifted_pair\n   (\\<lambda>f.\n       triple.pairs_uminus (Rep_phi f)\n        (top, up_filter (Rep_lifted_distrib_lattice_top xf f)))\n\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "have \"... = Abs_lifted_pair (\\<lambda>f . (bot,Rep_phi f top))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>f.\n         triple.pairs_uminus (Rep_phi f)\n          (top, up_filter (Rep_lifted_distrib_lattice_top xf f))) =\n    Abs_lifted_pair (\\<lambda>f. (bot, Rep_phi f top))", "by (simp add: triple.pairs_uminus.simps triple_def)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       triple.pairs_uminus (Rep_phi f)\n        (top, up_filter (Rep_lifted_distrib_lattice_top xf f))) =\n  Abs_lifted_pair (\\<lambda>f. (bot, Rep_phi f top))\n\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>f.\n       triple.pairs_uminus (Rep_phi f)\n        (top, up_filter (Rep_lifted_distrib_lattice_top xf f))) =\n  Abs_lifted_pair (\\<lambda>f. (bot, Rep_phi f top))\n\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "have \"... = Abs_lifted_pair (\\<lambda>f . triple.pairs_bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair (\\<lambda>f. (bot, Rep_phi f top)) =\n    Abs_lifted_pair (\\<lambda>f. (bot, Filters.filter.Abs_filter UNIV))", "by (metis (no_types, hide_lams) simp_phi triple.phi_top triple_def)"], ["proof (state)\nthis:\n  Abs_lifted_pair (\\<lambda>f. (bot, Rep_phi f top)) =\n  Abs_lifted_pair (\\<lambda>f. (bot, Filters.filter.Abs_filter UNIV))\n\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair (\\<lambda>f. (bot, Rep_phi f top)) =\n  Abs_lifted_pair (\\<lambda>f. (bot, Filters.filter.Abs_filter UNIV))\n\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair (\\<lambda>f. (bot, Filters.filter.Abs_filter UNIV)) =\n    bot", "by (simp add: bot_lifted_pair_def)"], ["proof (state)\nthis:\n  Abs_lifted_pair (\\<lambda>f. (bot, Filters.filter.Abs_filter UNIV)) = bot\n\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "finally"], ["proof (chain)\npicking this:\n  dense\n   (Abs_lifted_pair\n     (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "show ?thesis"], ["proof (prove)\nusing this:\n  dense\n   (Abs_lifted_pair\n     (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))\n\ngoal (1 subgoal):\n 1. dense\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))", "by simp"], ["proof (state)\nthis:\n  dense\n   (Abs_lifted_pair\n     (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dense\n   (Abs_lifted_pair\n     (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))\n\ngoal (1 subgoal):\n 1. dl_iso (dl_iso_inv xf) = xf", "have \"get_dense ?pf = ?rf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_dense (dl_iso_inv xf) = Rep_lifted_distrib_lattice_top xf", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       get_dense (dl_iso_inv xf) x = Rep_lifted_distrib_lattice_top xf x", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       get_dense (dl_iso_inv xf) x = Rep_lifted_distrib_lattice_top xf x", "have \"(top,up_filter (get_dense ?pf f)) = Rep_lifted_pair (Rep_dense ?pf) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (top, up_filter (get_dense (dl_iso_inv xf) f)) =\n    Rep_lifted_pair (Rep_dense (dl_iso_inv xf)) f", "by (metis get_dense_char)"], ["proof (state)\nthis:\n  (top, up_filter (get_dense (dl_iso_inv xf) f)) =\n  Rep_lifted_pair (Rep_dense (dl_iso_inv xf)) f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       get_dense (dl_iso_inv xf) x = Rep_lifted_distrib_lattice_top xf x", "also"], ["proof (state)\nthis:\n  (top, up_filter (get_dense (dl_iso_inv xf) f)) =\n  Rep_lifted_pair (Rep_dense (dl_iso_inv xf)) f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       get_dense (dl_iso_inv xf) x = Rep_lifted_distrib_lattice_top xf x", "have \"... = Rep_lifted_pair (Abs_lifted_pair (\\<lambda>f . (top,up_filter (?rf f)))) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense (dl_iso_inv xf)) f =\n    Rep_lifted_pair\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))\n     f", "using Abs_dense_inverse 2"], ["proof (prove)\nusing this:\n  ?y \\<in> dense_elements \\<Longrightarrow> Rep_dense (Abs_dense ?y) = ?y\n  dense\n   (Abs_lifted_pair\n     (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense (dl_iso_inv xf)) f =\n    Rep_lifted_pair\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))\n     f", "by force"], ["proof (state)\nthis:\n  Rep_lifted_pair (Rep_dense (dl_iso_inv xf)) f =\n  Rep_lifted_pair\n   (Abs_lifted_pair\n     (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))\n   f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       get_dense (dl_iso_inv xf) x = Rep_lifted_distrib_lattice_top xf x", "also"], ["proof (state)\nthis:\n  Rep_lifted_pair (Rep_dense (dl_iso_inv xf)) f =\n  Rep_lifted_pair\n   (Abs_lifted_pair\n     (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))\n   f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       get_dense (dl_iso_inv xf) x = Rep_lifted_distrib_lattice_top xf x", "have \"... = (top,up_filter (?rf f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_lifted_pair\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))\n     f =\n    (top, up_filter (Rep_lifted_distrib_lattice_top xf f))", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     (top, up_filter (Rep_lifted_distrib_lattice_top xf f))\n     \\<in> triple.pairs (Rep_phi f)\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair\n     (Abs_lifted_pair\n       (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))\n     f =\n    (top, up_filter (Rep_lifted_distrib_lattice_top xf f))", "by (simp add: Abs_lifted_pair_inverse)"], ["proof (state)\nthis:\n  Rep_lifted_pair\n   (Abs_lifted_pair\n     (\\<lambda>f. (top, up_filter (Rep_lifted_distrib_lattice_top xf f))))\n   f =\n  (top, up_filter (Rep_lifted_distrib_lattice_top xf f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       get_dense (dl_iso_inv xf) x = Rep_lifted_distrib_lattice_top xf x", "finally"], ["proof (chain)\npicking this:\n  (top, up_filter (get_dense (dl_iso_inv xf) f)) =\n  (top, up_filter (Rep_lifted_distrib_lattice_top xf f))", "show \"get_dense ?pf f = ?rf f\""], ["proof (prove)\nusing this:\n  (top, up_filter (get_dense (dl_iso_inv xf) f)) =\n  (top, up_filter (Rep_lifted_distrib_lattice_top xf f))\n\ngoal (1 subgoal):\n 1. get_dense (dl_iso_inv xf) f = Rep_lifted_distrib_lattice_top xf f", "using up_filter_injective"], ["proof (prove)\nusing this:\n  (top, up_filter (get_dense (dl_iso_inv xf) f)) =\n  (top, up_filter (Rep_lifted_distrib_lattice_top xf f))\n  up_filter ?x = up_filter ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. get_dense (dl_iso_inv xf) f = Rep_lifted_distrib_lattice_top xf f", "by auto"], ["proof (state)\nthis:\n  get_dense (dl_iso_inv xf) f = Rep_lifted_distrib_lattice_top xf f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  get_dense (dl_iso_inv xf) = Rep_lifted_distrib_lattice_top xf\n\ngoal (1 subgoal):\n 1. dl_iso (dl_iso_inv xf) = xf", "thus ?thesis"], ["proof (prove)\nusing this:\n  get_dense (dl_iso_inv xf) = Rep_lifted_distrib_lattice_top xf\n\ngoal (1 subgoal):\n 1. dl_iso (dl_iso_inv xf) = xf", "by (simp add: Rep_lifted_distrib_lattice_top_inverse)"], ["proof (state)\nthis:\n  dl_iso (dl_iso_inv xf) = xf\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nTo obtain the isomorphism, it remains to show the homomorphism properties of lattices with a greatest element.\n\\<close>"], ["", "lemma dl_iso:\n  \"bounded_lattice_top_isomorphism dl_iso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_lattice_top_isomorphism dl_iso", "proof (intro conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. sup_homomorphism dl_iso\n 2. inf_homomorphism dl_iso\n 3. top_homomorphism dl_iso\n 4. bij dl_iso", "have \"get_dense top = (\\<lambda>f::('a,'b) phi . top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_dense top = (\\<lambda>f. top)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. get_dense top f = top", "fix f :: \"('a,'b) phi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. get_dense top f = top", "have \"Rep_lifted_pair (Rep_dense top) f = (top,Abs_filter {top})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense top) f =\n    (top, Filters.filter.Abs_filter {top})", "by (simp add: top_dense.rep_eq top_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  Rep_lifted_pair (Rep_dense top) f = (top, Filters.filter.Abs_filter {top})\n\ngoal (1 subgoal):\n 1. \\<And>f. get_dense top f = top", "hence \"up_filter (get_dense top f) = Abs_filter {top}\""], ["proof (prove)\nusing this:\n  Rep_lifted_pair (Rep_dense top) f = (top, Filters.filter.Abs_filter {top})\n\ngoal (1 subgoal):\n 1. up_filter (get_dense top f) = Filters.filter.Abs_filter {top}", "by (metis prod.inject get_dense_char)"], ["proof (state)\nthis:\n  up_filter (get_dense top f) = Filters.filter.Abs_filter {top}\n\ngoal (1 subgoal):\n 1. \\<And>f. get_dense top f = top", "hence \"Rep_filter (up_filter (get_dense top f)) = {top}\""], ["proof (prove)\nusing this:\n  up_filter (get_dense top f) = Filters.filter.Abs_filter {top}\n\ngoal (1 subgoal):\n 1. Filters.filter.Rep_filter (up_filter (get_dense top f)) = {top}", "by (metis bot_filter.abs_eq bot_filter.rep_eq)"], ["proof (state)\nthis:\n  Filters.filter.Rep_filter (up_filter (get_dense top f)) = {top}\n\ngoal (1 subgoal):\n 1. \\<And>f. get_dense top f = top", "thus \"get_dense top f = top\""], ["proof (prove)\nusing this:\n  Filters.filter.Rep_filter (up_filter (get_dense top f)) = {top}\n\ngoal (1 subgoal):\n 1. get_dense top f = top", "by (metis self_in_upset singletonD Abs_filter_inverse mem_Collect_eq up_filter)"], ["proof (state)\nthis:\n  get_dense top f = top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  get_dense top = (\\<lambda>f. top)\n\ngoal (4 subgoals):\n 1. sup_homomorphism dl_iso\n 2. inf_homomorphism dl_iso\n 3. top_homomorphism dl_iso\n 4. bij dl_iso", "thus \"Abs_lifted_distrib_lattice_top (get_dense top::('a,'b) phi \\<Rightarrow> 'b) = top\""], ["proof (prove)\nusing this:\n  get_dense top = (\\<lambda>f. top)\n\ngoal (1 subgoal):\n 1. top_homomorphism dl_iso", "by (metis top_lifted_distrib_lattice_top_def)"], ["proof (state)\nthis:\n  top_homomorphism dl_iso\n\ngoal (3 subgoals):\n 1. sup_homomorphism dl_iso\n 2. inf_homomorphism dl_iso\n 3. bij dl_iso", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. sup_homomorphism dl_iso\n 2. inf_homomorphism dl_iso\n 3. bij dl_iso", "show \"\\<forall>pf qf :: ('a,'b) lifted_pair dense . Abs_lifted_distrib_lattice_top (get_dense (pf \\<squnion> qf)) = Abs_lifted_distrib_lattice_top (get_dense pf) \\<squnion> Abs_lifted_distrib_lattice_top (get_dense qf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_homomorphism dl_iso", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf qf. dl_iso (pf \\<squnion> qf) = dl_iso pf \\<squnion> dl_iso qf", "fix pf qf :: \"('a,'b) lifted_pair dense\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf qf. dl_iso (pf \\<squnion> qf) = dl_iso pf \\<squnion> dl_iso qf", "have 1: \"Abs_lifted_distrib_lattice_top (get_dense pf) \\<squnion> Abs_lifted_distrib_lattice_top (get_dense qf) = Abs_lifted_distrib_lattice_top (\\<lambda>f . get_dense pf f \\<squnion> get_dense qf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dl_iso pf \\<squnion> dl_iso qf =\n    Abs_lifted_distrib_lattice_top\n     (\\<lambda>f. get_dense pf f \\<squnion> get_dense qf f)", "by (simp add: eq_onp_same_args sup_lifted_distrib_lattice_top.abs_eq)"], ["proof (state)\nthis:\n  dl_iso pf \\<squnion> dl_iso qf =\n  Abs_lifted_distrib_lattice_top\n   (\\<lambda>f. get_dense pf f \\<squnion> get_dense qf f)\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. dl_iso (pf \\<squnion> qf) = dl_iso pf \\<squnion> dl_iso qf", "have \"(\\<lambda>f . get_dense (pf \\<squnion> qf) f) = (\\<lambda>f . get_dense pf f \\<squnion> get_dense qf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_dense (pf \\<squnion> qf) =\n    (\\<lambda>f. get_dense pf f \\<squnion> get_dense qf f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<squnion> qf) f =\n       get_dense pf f \\<squnion> get_dense qf f", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<squnion> qf) f =\n       get_dense pf f \\<squnion> get_dense qf f", "have \"(top,up_filter (get_dense (pf \\<squnion> qf) f)) = Rep_lifted_pair (Rep_dense (pf \\<squnion> qf)) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (top, up_filter (get_dense (pf \\<squnion> qf) f)) =\n    Rep_lifted_pair (Rep_dense (pf \\<squnion> qf)) f", "by (metis get_dense_char)"], ["proof (state)\nthis:\n  (top, up_filter (get_dense (pf \\<squnion> qf) f)) =\n  Rep_lifted_pair (Rep_dense (pf \\<squnion> qf)) f\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<squnion> qf) f =\n       get_dense pf f \\<squnion> get_dense qf f", "also"], ["proof (state)\nthis:\n  (top, up_filter (get_dense (pf \\<squnion> qf) f)) =\n  Rep_lifted_pair (Rep_dense (pf \\<squnion> qf)) f\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<squnion> qf) f =\n       get_dense pf f \\<squnion> get_dense qf f", "have \"... = triple.pairs_sup (Rep_lifted_pair (Rep_dense pf) f) (Rep_lifted_pair (Rep_dense qf) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense (pf \\<squnion> qf)) f =\n    triple.pairs_sup (Rep_lifted_pair (Rep_dense pf) f)\n     (Rep_lifted_pair (Rep_dense qf) f)", "by (simp add: sup_lifted_pair.rep_eq sup_dense.rep_eq)"], ["proof (state)\nthis:\n  Rep_lifted_pair (Rep_dense (pf \\<squnion> qf)) f =\n  triple.pairs_sup (Rep_lifted_pair (Rep_dense pf) f)\n   (Rep_lifted_pair (Rep_dense qf) f)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<squnion> qf) f =\n       get_dense pf f \\<squnion> get_dense qf f", "also"], ["proof (state)\nthis:\n  Rep_lifted_pair (Rep_dense (pf \\<squnion> qf)) f =\n  triple.pairs_sup (Rep_lifted_pair (Rep_dense pf) f)\n   (Rep_lifted_pair (Rep_dense qf) f)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<squnion> qf) f =\n       get_dense pf f \\<squnion> get_dense qf f", "have \"... = triple.pairs_sup (top,up_filter (get_dense pf f)) (top,up_filter (get_dense qf f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_sup (Rep_lifted_pair (Rep_dense pf) f)\n     (Rep_lifted_pair (Rep_dense qf) f) =\n    triple.pairs_sup (top, up_filter (get_dense pf f))\n     (top, up_filter (get_dense qf f))", "by (metis get_dense_char)"], ["proof (state)\nthis:\n  triple.pairs_sup (Rep_lifted_pair (Rep_dense pf) f)\n   (Rep_lifted_pair (Rep_dense qf) f) =\n  triple.pairs_sup (top, up_filter (get_dense pf f))\n   (top, up_filter (get_dense qf f))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<squnion> qf) f =\n       get_dense pf f \\<squnion> get_dense qf f", "also"], ["proof (state)\nthis:\n  triple.pairs_sup (Rep_lifted_pair (Rep_dense pf) f)\n   (Rep_lifted_pair (Rep_dense qf) f) =\n  triple.pairs_sup (top, up_filter (get_dense pf f))\n   (top, up_filter (get_dense qf f))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<squnion> qf) f =\n       get_dense pf f \\<squnion> get_dense qf f", "have \"... = (top,up_filter (get_dense pf f) \\<sqinter> up_filter (get_dense qf f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_sup (top, up_filter (get_dense pf f))\n     (top, up_filter (get_dense qf f)) =\n    (top, up_filter (get_dense pf f) \\<sqinter> up_filter (get_dense qf f))", "by (metis (no_types, lifting) calculation prod.simps(1) simp_phi triple.pairs_sup.simps triple_def)"], ["proof (state)\nthis:\n  triple.pairs_sup (top, up_filter (get_dense pf f))\n   (top, up_filter (get_dense qf f)) =\n  (top, up_filter (get_dense pf f) \\<sqinter> up_filter (get_dense qf f))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<squnion> qf) f =\n       get_dense pf f \\<squnion> get_dense qf f", "also"], ["proof (state)\nthis:\n  triple.pairs_sup (top, up_filter (get_dense pf f))\n   (top, up_filter (get_dense qf f)) =\n  (top, up_filter (get_dense pf f) \\<sqinter> up_filter (get_dense qf f))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<squnion> qf) f =\n       get_dense pf f \\<squnion> get_dense qf f", "have \"... = (top,up_filter (get_dense pf f \\<squnion> get_dense qf f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (top,\n     up_filter (get_dense pf f) \\<sqinter> up_filter (get_dense qf f)) =\n    (top, up_filter (get_dense pf f \\<squnion> get_dense qf f))", "by (metis up_filter_dist_sup)"], ["proof (state)\nthis:\n  (top, up_filter (get_dense pf f) \\<sqinter> up_filter (get_dense qf f)) =\n  (top, up_filter (get_dense pf f \\<squnion> get_dense qf f))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<squnion> qf) f =\n       get_dense pf f \\<squnion> get_dense qf f", "finally"], ["proof (chain)\npicking this:\n  (top, up_filter (get_dense (pf \\<squnion> qf) f)) =\n  (top, up_filter (get_dense pf f \\<squnion> get_dense qf f))", "show \"get_dense (pf \\<squnion> qf) f = get_dense pf f \\<squnion> get_dense qf f\""], ["proof (prove)\nusing this:\n  (top, up_filter (get_dense (pf \\<squnion> qf) f)) =\n  (top, up_filter (get_dense pf f \\<squnion> get_dense qf f))\n\ngoal (1 subgoal):\n 1. get_dense (pf \\<squnion> qf) f =\n    get_dense pf f \\<squnion> get_dense qf f", "using up_filter_injective"], ["proof (prove)\nusing this:\n  (top, up_filter (get_dense (pf \\<squnion> qf) f)) =\n  (top, up_filter (get_dense pf f \\<squnion> get_dense qf f))\n  up_filter ?x = up_filter ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. get_dense (pf \\<squnion> qf) f =\n    get_dense pf f \\<squnion> get_dense qf f", "by blast"], ["proof (state)\nthis:\n  get_dense (pf \\<squnion> qf) f = get_dense pf f \\<squnion> get_dense qf f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  get_dense (pf \\<squnion> qf) =\n  (\\<lambda>f. get_dense pf f \\<squnion> get_dense qf f)\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. dl_iso (pf \\<squnion> qf) = dl_iso pf \\<squnion> dl_iso qf", "thus \"Abs_lifted_distrib_lattice_top (get_dense (pf \\<squnion> qf)) = Abs_lifted_distrib_lattice_top (get_dense pf) \\<squnion> Abs_lifted_distrib_lattice_top (get_dense qf)\""], ["proof (prove)\nusing this:\n  get_dense (pf \\<squnion> qf) =\n  (\\<lambda>f. get_dense pf f \\<squnion> get_dense qf f)\n\ngoal (1 subgoal):\n 1. dl_iso (pf \\<squnion> qf) = dl_iso pf \\<squnion> dl_iso qf", "using 1"], ["proof (prove)\nusing this:\n  get_dense (pf \\<squnion> qf) =\n  (\\<lambda>f. get_dense pf f \\<squnion> get_dense qf f)\n  dl_iso pf \\<squnion> dl_iso qf =\n  Abs_lifted_distrib_lattice_top\n   (\\<lambda>f. get_dense pf f \\<squnion> get_dense qf f)\n\ngoal (1 subgoal):\n 1. dl_iso (pf \\<squnion> qf) = dl_iso pf \\<squnion> dl_iso qf", "by metis"], ["proof (state)\nthis:\n  dl_iso (pf \\<squnion> qf) = dl_iso pf \\<squnion> dl_iso qf\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sup_homomorphism dl_iso\n\ngoal (2 subgoals):\n 1. inf_homomorphism dl_iso\n 2. bij dl_iso", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. inf_homomorphism dl_iso\n 2. bij dl_iso", "show \"\\<forall>pf qf :: ('a,'b) lifted_pair dense . Abs_lifted_distrib_lattice_top (get_dense (pf \\<sqinter> qf)) = Abs_lifted_distrib_lattice_top (get_dense pf) \\<sqinter> Abs_lifted_distrib_lattice_top (get_dense qf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_homomorphism dl_iso", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf qf. dl_iso (pf \\<sqinter> qf) = dl_iso pf \\<sqinter> dl_iso qf", "fix pf qf :: \"('a,'b) lifted_pair dense\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pf qf. dl_iso (pf \\<sqinter> qf) = dl_iso pf \\<sqinter> dl_iso qf", "have 1: \"Abs_lifted_distrib_lattice_top (get_dense pf) \\<sqinter> Abs_lifted_distrib_lattice_top (get_dense qf) = Abs_lifted_distrib_lattice_top (\\<lambda>f . get_dense pf f \\<sqinter> get_dense qf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dl_iso pf \\<sqinter> dl_iso qf =\n    Abs_lifted_distrib_lattice_top\n     (\\<lambda>f. get_dense pf f \\<sqinter> get_dense qf f)", "by (simp add: eq_onp_same_args inf_lifted_distrib_lattice_top.abs_eq)"], ["proof (state)\nthis:\n  dl_iso pf \\<sqinter> dl_iso qf =\n  Abs_lifted_distrib_lattice_top\n   (\\<lambda>f. get_dense pf f \\<sqinter> get_dense qf f)\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. dl_iso (pf \\<sqinter> qf) = dl_iso pf \\<sqinter> dl_iso qf", "have \"(\\<lambda>f . get_dense (pf \\<sqinter> qf) f) = (\\<lambda>f . get_dense pf f \\<sqinter> get_dense qf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_dense (pf \\<sqinter> qf) =\n    (\\<lambda>f. get_dense pf f \\<sqinter> get_dense qf f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<sqinter> qf) f =\n       get_dense pf f \\<sqinter> get_dense qf f", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<sqinter> qf) f =\n       get_dense pf f \\<sqinter> get_dense qf f", "have \"(top,up_filter (get_dense (pf \\<sqinter> qf) f)) = Rep_lifted_pair (Rep_dense (pf \\<sqinter> qf)) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (top, up_filter (get_dense (pf \\<sqinter> qf) f)) =\n    Rep_lifted_pair (Rep_dense (pf \\<sqinter> qf)) f", "by (metis get_dense_char)"], ["proof (state)\nthis:\n  (top, up_filter (get_dense (pf \\<sqinter> qf) f)) =\n  Rep_lifted_pair (Rep_dense (pf \\<sqinter> qf)) f\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<sqinter> qf) f =\n       get_dense pf f \\<sqinter> get_dense qf f", "also"], ["proof (state)\nthis:\n  (top, up_filter (get_dense (pf \\<sqinter> qf) f)) =\n  Rep_lifted_pair (Rep_dense (pf \\<sqinter> qf)) f\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<sqinter> qf) f =\n       get_dense pf f \\<sqinter> get_dense qf f", "have \"... = triple.pairs_inf (Rep_lifted_pair (Rep_dense pf) f) (Rep_lifted_pair (Rep_dense qf) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense (pf \\<sqinter> qf)) f =\n    triple.pairs_inf (Rep_lifted_pair (Rep_dense pf) f)\n     (Rep_lifted_pair (Rep_dense qf) f)", "by (simp add: inf_lifted_pair.rep_eq inf_dense.rep_eq)"], ["proof (state)\nthis:\n  Rep_lifted_pair (Rep_dense (pf \\<sqinter> qf)) f =\n  triple.pairs_inf (Rep_lifted_pair (Rep_dense pf) f)\n   (Rep_lifted_pair (Rep_dense qf) f)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<sqinter> qf) f =\n       get_dense pf f \\<sqinter> get_dense qf f", "also"], ["proof (state)\nthis:\n  Rep_lifted_pair (Rep_dense (pf \\<sqinter> qf)) f =\n  triple.pairs_inf (Rep_lifted_pair (Rep_dense pf) f)\n   (Rep_lifted_pair (Rep_dense qf) f)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<sqinter> qf) f =\n       get_dense pf f \\<sqinter> get_dense qf f", "have \"... = triple.pairs_inf (top,up_filter (get_dense pf f)) (top,up_filter (get_dense qf f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_inf (Rep_lifted_pair (Rep_dense pf) f)\n     (Rep_lifted_pair (Rep_dense qf) f) =\n    triple.pairs_inf (top, up_filter (get_dense pf f))\n     (top, up_filter (get_dense qf f))", "by (metis get_dense_char)"], ["proof (state)\nthis:\n  triple.pairs_inf (Rep_lifted_pair (Rep_dense pf) f)\n   (Rep_lifted_pair (Rep_dense qf) f) =\n  triple.pairs_inf (top, up_filter (get_dense pf f))\n   (top, up_filter (get_dense qf f))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<sqinter> qf) f =\n       get_dense pf f \\<sqinter> get_dense qf f", "also"], ["proof (state)\nthis:\n  triple.pairs_inf (Rep_lifted_pair (Rep_dense pf) f)\n   (Rep_lifted_pair (Rep_dense qf) f) =\n  triple.pairs_inf (top, up_filter (get_dense pf f))\n   (top, up_filter (get_dense qf f))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<sqinter> qf) f =\n       get_dense pf f \\<sqinter> get_dense qf f", "have \"... = (top,up_filter (get_dense pf f) \\<squnion> up_filter (get_dense qf f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_inf (top, up_filter (get_dense pf f))\n     (top, up_filter (get_dense qf f)) =\n    (top, up_filter (get_dense pf f) \\<squnion> up_filter (get_dense qf f))", "by (metis (no_types, lifting) calculation prod.simps(1) simp_phi triple.pairs_inf.simps triple_def)"], ["proof (state)\nthis:\n  triple.pairs_inf (top, up_filter (get_dense pf f))\n   (top, up_filter (get_dense qf f)) =\n  (top, up_filter (get_dense pf f) \\<squnion> up_filter (get_dense qf f))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<sqinter> qf) f =\n       get_dense pf f \\<sqinter> get_dense qf f", "also"], ["proof (state)\nthis:\n  triple.pairs_inf (top, up_filter (get_dense pf f))\n   (top, up_filter (get_dense qf f)) =\n  (top, up_filter (get_dense pf f) \\<squnion> up_filter (get_dense qf f))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<sqinter> qf) f =\n       get_dense pf f \\<sqinter> get_dense qf f", "have \"... = (top,up_filter (get_dense pf f \\<sqinter> get_dense qf f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (top,\n     up_filter (get_dense pf f) \\<squnion> up_filter (get_dense qf f)) =\n    (top, up_filter (get_dense pf f \\<sqinter> get_dense qf f))", "by (metis up_filter_dist_inf)"], ["proof (state)\nthis:\n  (top, up_filter (get_dense pf f) \\<squnion> up_filter (get_dense qf f)) =\n  (top, up_filter (get_dense pf f \\<sqinter> get_dense qf f))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       get_dense (pf \\<sqinter> qf) f =\n       get_dense pf f \\<sqinter> get_dense qf f", "finally"], ["proof (chain)\npicking this:\n  (top, up_filter (get_dense (pf \\<sqinter> qf) f)) =\n  (top, up_filter (get_dense pf f \\<sqinter> get_dense qf f))", "show \"get_dense (pf \\<sqinter> qf) f = get_dense pf f \\<sqinter> get_dense qf f\""], ["proof (prove)\nusing this:\n  (top, up_filter (get_dense (pf \\<sqinter> qf) f)) =\n  (top, up_filter (get_dense pf f \\<sqinter> get_dense qf f))\n\ngoal (1 subgoal):\n 1. get_dense (pf \\<sqinter> qf) f =\n    get_dense pf f \\<sqinter> get_dense qf f", "using up_filter_injective"], ["proof (prove)\nusing this:\n  (top, up_filter (get_dense (pf \\<sqinter> qf) f)) =\n  (top, up_filter (get_dense pf f \\<sqinter> get_dense qf f))\n  up_filter ?x = up_filter ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. get_dense (pf \\<sqinter> qf) f =\n    get_dense pf f \\<sqinter> get_dense qf f", "by blast"], ["proof (state)\nthis:\n  get_dense (pf \\<sqinter> qf) f = get_dense pf f \\<sqinter> get_dense qf f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  get_dense (pf \\<sqinter> qf) =\n  (\\<lambda>f. get_dense pf f \\<sqinter> get_dense qf f)\n\ngoal (1 subgoal):\n 1. \\<And>pf qf. dl_iso (pf \\<sqinter> qf) = dl_iso pf \\<sqinter> dl_iso qf", "thus \"Abs_lifted_distrib_lattice_top (get_dense (pf \\<sqinter> qf)) = Abs_lifted_distrib_lattice_top (get_dense pf) \\<sqinter> Abs_lifted_distrib_lattice_top (get_dense qf)\""], ["proof (prove)\nusing this:\n  get_dense (pf \\<sqinter> qf) =\n  (\\<lambda>f. get_dense pf f \\<sqinter> get_dense qf f)\n\ngoal (1 subgoal):\n 1. dl_iso (pf \\<sqinter> qf) = dl_iso pf \\<sqinter> dl_iso qf", "using 1"], ["proof (prove)\nusing this:\n  get_dense (pf \\<sqinter> qf) =\n  (\\<lambda>f. get_dense pf f \\<sqinter> get_dense qf f)\n  dl_iso pf \\<sqinter> dl_iso qf =\n  Abs_lifted_distrib_lattice_top\n   (\\<lambda>f. get_dense pf f \\<sqinter> get_dense qf f)\n\ngoal (1 subgoal):\n 1. dl_iso (pf \\<sqinter> qf) = dl_iso pf \\<sqinter> dl_iso qf", "by metis"], ["proof (state)\nthis:\n  dl_iso (pf \\<sqinter> qf) = dl_iso pf \\<sqinter> dl_iso qf\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inf_homomorphism dl_iso\n\ngoal (1 subgoal):\n 1. bij dl_iso", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bij dl_iso", "show \"bij dl_iso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij dl_iso", "by (rule invertible_bij[where g=dl_iso_inv]) (simp_all add: dl_iso_left_invertible dl_iso_right_invertible)"], ["proof (state)\nthis:\n  bij dl_iso\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Structure Map Preservation\\<close>"], ["", "text \\<open>\nWe finally show that the isomorphisms are compatible with the structure maps.\nThis involves lifting the distributive lattice isomorphism to filters of distributive lattices (as these are the targets of the structure maps).\nTo this end, we first show that the lifted isomorphism preserves filters.\n\\<close>"], ["", "lemma phi_iso_filter:\n  \"filter ((\\<lambda>qf::('a::non_trivial_boolean_algebra,'b::distrib_lattice_top) lifted_pair dense . Rep_lifted_distrib_lattice_top (dl_iso qf) f) ` Rep_filter (stone_phi pf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_class.filter\n     ((\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f) `\n      Filters.filter.Rep_filter (stone_phi pf))", "proof (rule filter_map_filter)"], ["proof (state)\ngoal (2 subgoals):\n 1. mono (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n 2. \\<forall>x y.\n       Rep_lifted_distrib_lattice_top (dl_iso x) f \\<le> y \\<longrightarrow>\n       (\\<exists>z\\<ge>x. y = Rep_lifted_distrib_lattice_top (dl_iso z) f)", "show \"mono (\\<lambda>qf::('a::non_trivial_boolean_algebra,'b::distrib_lattice_top) lifted_pair dense . Rep_lifted_distrib_lattice_top (dl_iso qf) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)", "by (metis (no_types, lifting) mono_def dl_iso le_iff_sup sup_lifted_distrib_lattice_top.rep_eq)"], ["proof (state)\nthis:\n  mono (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       Rep_lifted_distrib_lattice_top (dl_iso x) f \\<le> y \\<longrightarrow>\n       (\\<exists>z\\<ge>x. y = Rep_lifted_distrib_lattice_top (dl_iso z) f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       Rep_lifted_distrib_lattice_top (dl_iso x) f \\<le> y \\<longrightarrow>\n       (\\<exists>z\\<ge>x. y = Rep_lifted_distrib_lattice_top (dl_iso z) f)", "show \"\\<forall>qf y . Rep_lifted_distrib_lattice_top (dl_iso qf) f \\<le> y \\<longrightarrow> (\\<exists>rf . qf \\<le> rf \\<and> y = Rep_lifted_distrib_lattice_top (dl_iso rf) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<longrightarrow>\n       (\\<exists>rf\\<ge>qf.\n           y = Rep_lifted_distrib_lattice_top (dl_iso rf) f)", "proof (intro allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "fix qf :: \"('a,'b) lifted_pair dense\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "fix y :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "assume 1: \"Rep_lifted_distrib_lattice_top (dl_iso qf) f \\<le> y\""], ["proof (state)\nthis:\n  Rep_lifted_distrib_lattice_top (dl_iso qf) f \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "let ?rf = \"Abs_dense (Abs_lifted_pair (\\<lambda>g . if g = f then (top,up_filter y) else Rep_lifted_pair (Rep_dense qf) g))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "have 2: \"\\<forall>g . (if g = f then (top,up_filter y) else Rep_lifted_pair (Rep_dense qf) g) \\<in> triple.pairs (Rep_phi g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g.\n       (if g = f then (top, up_filter y)\n        else Rep_lifted_pair (Rep_dense qf) g)\n       \\<in> triple.pairs (Rep_phi g)", "by (metis Abs_lifted_distrib_lattice_top_inverse dl_iso_inv_lifted_pair mem_Collect_eq simp_lifted_pair)"], ["proof (state)\nthis:\n  \\<forall>g.\n     (if g = f then (top, up_filter y)\n      else Rep_lifted_pair (Rep_dense qf) g)\n     \\<in> triple.pairs (Rep_phi g)\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "hence \"-Abs_lifted_pair (\\<lambda>g . if g = f then (top,up_filter y) else Rep_lifted_pair (Rep_dense qf) g) = Abs_lifted_pair (\\<lambda>g . triple.pairs_uminus (Rep_phi g) (if g = f then (top,up_filter y) else Rep_lifted_pair (Rep_dense qf) g))\""], ["proof (prove)\nusing this:\n  \\<forall>g.\n     (if g = f then (top, up_filter y)\n      else Rep_lifted_pair (Rep_dense qf) g)\n     \\<in> triple.pairs (Rep_phi g)\n\ngoal (1 subgoal):\n 1. - Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g) =\n    Abs_lifted_pair\n     (\\<lambda>g.\n         triple.pairs_uminus (Rep_phi g)\n          (if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g))", "by (simp add: eq_onp_def uminus_lifted_pair.abs_eq)"], ["proof (state)\nthis:\n  - Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g) =\n  Abs_lifted_pair\n   (\\<lambda>g.\n       triple.pairs_uminus (Rep_phi g)\n        (if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g))\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "also"], ["proof (state)\nthis:\n  - Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g) =\n  Abs_lifted_pair\n   (\\<lambda>g.\n       triple.pairs_uminus (Rep_phi g)\n        (if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g))\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "have \"... = Abs_lifted_pair (\\<lambda>g . if g = f then triple.pairs_uminus (Rep_phi g) (top,up_filter y) else triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_dense qf) g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>g.\n         triple.pairs_uminus (Rep_phi g)\n          (if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g)) =\n    Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then triple.pairs_uminus (Rep_phi g) (top, up_filter y)\n         else triple.pairs_uminus (Rep_phi g)\n               (Rep_lifted_pair (Rep_dense qf) g))", "by (simp add: if_distrib)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       triple.pairs_uminus (Rep_phi g)\n        (if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g)) =\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then triple.pairs_uminus (Rep_phi g) (top, up_filter y)\n       else triple.pairs_uminus (Rep_phi g)\n             (Rep_lifted_pair (Rep_dense qf) g))\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       triple.pairs_uminus (Rep_phi g)\n        (if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g)) =\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then triple.pairs_uminus (Rep_phi g) (top, up_filter y)\n       else triple.pairs_uminus (Rep_phi g)\n             (Rep_lifted_pair (Rep_dense qf) g))\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "have \"... = Abs_lifted_pair (\\<lambda>g . if g = f then (bot,top) else triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_dense qf) g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then triple.pairs_uminus (Rep_phi g) (top, up_filter y)\n         else triple.pairs_uminus (Rep_phi g)\n               (Rep_lifted_pair (Rep_dense qf) g)) =\n    Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (bot, top)\n         else triple.pairs_uminus (Rep_phi g)\n               (Rep_lifted_pair (Rep_dense qf) g))", "by (subst triple.pairs_uminus.simps, simp add: triple_def, metis compl_top_eq simp_phi)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then triple.pairs_uminus (Rep_phi g) (top, up_filter y)\n       else triple.pairs_uminus (Rep_phi g)\n             (Rep_lifted_pair (Rep_dense qf) g)) =\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then (bot, top)\n       else triple.pairs_uminus (Rep_phi g)\n             (Rep_lifted_pair (Rep_dense qf) g))\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then triple.pairs_uminus (Rep_phi g) (top, up_filter y)\n       else triple.pairs_uminus (Rep_phi g)\n             (Rep_lifted_pair (Rep_dense qf) g)) =\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then (bot, top)\n       else triple.pairs_uminus (Rep_phi g)\n             (Rep_lifted_pair (Rep_dense qf) g))\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "have \"... = Abs_lifted_pair (\\<lambda>g . if g = f then (bot,top) else (bot,top))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (bot, top)\n         else triple.pairs_uminus (Rep_phi g)\n               (Rep_lifted_pair (Rep_dense qf) g)) =\n    Abs_lifted_pair (\\<lambda>g. if g = f then (bot, top) else (bot, top))", "by (metis bot_lifted_pair.rep_eq simp_dense top_filter.abs_eq uminus_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then (bot, top)\n       else triple.pairs_uminus (Rep_phi g)\n             (Rep_lifted_pair (Rep_dense qf) g)) =\n  Abs_lifted_pair (\\<lambda>g. if g = f then (bot, top) else (bot, top))\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then (bot, top)\n       else triple.pairs_uminus (Rep_phi g)\n             (Rep_lifted_pair (Rep_dense qf) g)) =\n  Abs_lifted_pair (\\<lambda>g. if g = f then (bot, top) else (bot, top))\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair (\\<lambda>g. if g = f then (bot, top) else (bot, top)) =\n    bot", "by (simp add: bot_lifted_pair.abs_eq top_filter.abs_eq)"], ["proof (state)\nthis:\n  Abs_lifted_pair (\\<lambda>g. if g = f then (bot, top) else (bot, top)) =\n  bot\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "finally"], ["proof (chain)\npicking this:\n  dense\n   (Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g))", "have 3: \"Abs_lifted_pair (\\<lambda>g . if g = f then (top,up_filter y) else Rep_lifted_pair (Rep_dense qf) g) \\<in> dense_elements\""], ["proof (prove)\nusing this:\n  dense\n   (Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g))\n\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g)\n    \\<in> dense_elements", "by blast"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then (top, up_filter y)\n       else Rep_lifted_pair (Rep_dense qf) g)\n  \\<in> dense_elements\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "hence \"(top,up_filter (get_dense (Abs_dense (Abs_lifted_pair (\\<lambda>g . if g = f then (top,up_filter y) else Rep_lifted_pair (Rep_dense qf) g))) f)) = Rep_lifted_pair (Rep_dense (Abs_dense (Abs_lifted_pair (\\<lambda>g . if g = f then (top,up_filter y) else Rep_lifted_pair (Rep_dense qf) g)))) f\""], ["proof (prove)\nusing this:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then (top, up_filter y)\n       else Rep_lifted_pair (Rep_dense qf) g)\n  \\<in> dense_elements\n\ngoal (1 subgoal):\n 1. (top,\n     up_filter\n      (get_dense\n        (Abs_dense\n          (Abs_lifted_pair\n            (\\<lambda>g.\n                if g = f then (top, up_filter y)\n                else Rep_lifted_pair (Rep_dense qf) g)))\n        f)) =\n    Rep_lifted_pair\n     (Rep_dense\n       (Abs_dense\n         (Abs_lifted_pair\n           (\\<lambda>g.\n               if g = f then (top, up_filter y)\n               else Rep_lifted_pair (Rep_dense qf) g))))\n     f", "by (metis (mono_tags, lifting) get_dense_char)"], ["proof (state)\nthis:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter y)\n              else Rep_lifted_pair (Rep_dense qf) g)))\n      f)) =\n  Rep_lifted_pair\n   (Rep_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g))))\n   f\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "also"], ["proof (state)\nthis:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter y)\n              else Rep_lifted_pair (Rep_dense qf) g)))\n      f)) =\n  Rep_lifted_pair\n   (Rep_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g))))\n   f\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "have \"... = Rep_lifted_pair (Abs_lifted_pair (\\<lambda>g . if g = f then (top,up_filter y) else Rep_lifted_pair (Rep_dense qf) g)) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_lifted_pair\n     (Rep_dense\n       (Abs_dense\n         (Abs_lifted_pair\n           (\\<lambda>g.\n               if g = f then (top, up_filter y)\n               else Rep_lifted_pair (Rep_dense qf) g))))\n     f =\n    Rep_lifted_pair\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g))\n     f", "using 3"], ["proof (prove)\nusing this:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then (top, up_filter y)\n       else Rep_lifted_pair (Rep_dense qf) g)\n  \\<in> dense_elements\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair\n     (Rep_dense\n       (Abs_dense\n         (Abs_lifted_pair\n           (\\<lambda>g.\n               if g = f then (top, up_filter y)\n               else Rep_lifted_pair (Rep_dense qf) g))))\n     f =\n    Rep_lifted_pair\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g))\n     f", "by (simp add: Abs_dense_inverse)"], ["proof (state)\nthis:\n  Rep_lifted_pair\n   (Rep_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g))))\n   f =\n  Rep_lifted_pair\n   (Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g))\n   f\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "also"], ["proof (state)\nthis:\n  Rep_lifted_pair\n   (Rep_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g))))\n   f =\n  Rep_lifted_pair\n   (Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g))\n   f\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "have \"... = (top,up_filter y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_lifted_pair\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g))\n     f =\n    (top, up_filter y)", "using 2"], ["proof (prove)\nusing this:\n  \\<forall>g.\n     (if g = f then (top, up_filter y)\n      else Rep_lifted_pair (Rep_dense qf) g)\n     \\<in> triple.pairs (Rep_phi g)\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g))\n     f =\n    (top, up_filter y)", "by (simp add: Abs_lifted_pair_inverse)"], ["proof (state)\nthis:\n  Rep_lifted_pair\n   (Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g))\n   f =\n  (top, up_filter y)\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "finally"], ["proof (chain)\npicking this:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter y)\n              else Rep_lifted_pair (Rep_dense qf) g)))\n      f)) =\n  (top, up_filter y)", "have \"get_dense (Abs_dense (Abs_lifted_pair (\\<lambda>g . if g = f then (top,up_filter y) else Rep_lifted_pair (Rep_dense qf) g))) f = y\""], ["proof (prove)\nusing this:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter y)\n              else Rep_lifted_pair (Rep_dense qf) g)))\n      f)) =\n  (top, up_filter y)\n\ngoal (1 subgoal):\n 1. get_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g)))\n     f =\n    y", "using up_filter_injective"], ["proof (prove)\nusing this:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter y)\n              else Rep_lifted_pair (Rep_dense qf) g)))\n      f)) =\n  (top, up_filter y)\n  up_filter ?x = up_filter ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. get_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g)))\n     f =\n    y", "by blast"], ["proof (state)\nthis:\n  get_dense\n   (Abs_dense\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g)))\n   f =\n  y\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "hence 4: \"Rep_lifted_distrib_lattice_top (dl_iso ?rf) f = y\""], ["proof (prove)\nusing this:\n  get_dense\n   (Abs_dense\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g)))\n   f =\n  y\n\ngoal (1 subgoal):\n 1. Rep_lifted_distrib_lattice_top\n     (dl_iso\n       (Abs_dense\n         (Abs_lifted_pair\n           (\\<lambda>g.\n               if g = f then (top, up_filter y)\n               else Rep_lifted_pair (Rep_dense qf) g))))\n     f =\n    y", "by (simp add: Abs_lifted_distrib_lattice_top_inverse)"], ["proof (state)\nthis:\n  Rep_lifted_distrib_lattice_top\n   (dl_iso\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g))))\n   f =\n  y\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "{"], ["proof (state)\nthis:\n  Rep_lifted_distrib_lattice_top\n   (dl_iso\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g))))\n   f =\n  y\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "have \"Rep_lifted_distrib_lattice_top (dl_iso qf) g \\<le> Rep_lifted_distrib_lattice_top (dl_iso ?rf) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "proof (cases \"g = f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. g = f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g\n 2. g \\<noteq> f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "assume \"g = f\""], ["proof (state)\nthis:\n  g = f\n\ngoal (2 subgoals):\n 1. g = f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g\n 2. g \\<noteq> f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "thus ?thesis"], ["proof (prove)\nusing this:\n  g = f\n\ngoal (1 subgoal):\n 1. Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "using 1 4"], ["proof (prove)\nusing this:\n  g = f\n  Rep_lifted_distrib_lattice_top (dl_iso qf) f \\<le> y\n  Rep_lifted_distrib_lattice_top\n   (dl_iso\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g))))\n   f =\n  y\n\ngoal (1 subgoal):\n 1. Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "by simp"], ["proof (state)\nthis:\n  Rep_lifted_distrib_lattice_top (dl_iso qf) g\n  \\<le> Rep_lifted_distrib_lattice_top\n         (dl_iso\n           (Abs_dense\n             (Abs_lifted_pair\n               (\\<lambda>g.\n                   if g = f then (top, up_filter y)\n                   else Rep_lifted_pair (Rep_dense qf) g))))\n         g\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "assume 5: \"g \\<noteq> f\""], ["proof (state)\nthis:\n  g \\<noteq> f\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "have \"(top,up_filter (get_dense ?rf g)) = Rep_lifted_pair (Rep_dense (Abs_dense (Abs_lifted_pair (\\<lambda>g . if g = f then (top,up_filter y) else Rep_lifted_pair (Rep_dense qf) g)))) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (top,\n     up_filter\n      (get_dense\n        (Abs_dense\n          (Abs_lifted_pair\n            (\\<lambda>g.\n                if g = f then (top, up_filter y)\n                else Rep_lifted_pair (Rep_dense qf) g)))\n        g)) =\n    Rep_lifted_pair\n     (Rep_dense\n       (Abs_dense\n         (Abs_lifted_pair\n           (\\<lambda>g.\n               if g = f then (top, up_filter y)\n               else Rep_lifted_pair (Rep_dense qf) g))))\n     g", "by (metis (mono_tags, lifting) get_dense_char)"], ["proof (state)\nthis:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter y)\n              else Rep_lifted_pair (Rep_dense qf) g)))\n      g)) =\n  Rep_lifted_pair\n   (Rep_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g))))\n   g\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "also"], ["proof (state)\nthis:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter y)\n              else Rep_lifted_pair (Rep_dense qf) g)))\n      g)) =\n  Rep_lifted_pair\n   (Rep_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g))))\n   g\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "have \"... = Rep_lifted_pair (Abs_lifted_pair (\\<lambda>g . if g = f then (top,up_filter y) else Rep_lifted_pair (Rep_dense qf) g)) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_lifted_pair\n     (Rep_dense\n       (Abs_dense\n         (Abs_lifted_pair\n           (\\<lambda>g.\n               if g = f then (top, up_filter y)\n               else Rep_lifted_pair (Rep_dense qf) g))))\n     g =\n    Rep_lifted_pair\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g))\n     g", "using 3"], ["proof (prove)\nusing this:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then (top, up_filter y)\n       else Rep_lifted_pair (Rep_dense qf) g)\n  \\<in> dense_elements\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair\n     (Rep_dense\n       (Abs_dense\n         (Abs_lifted_pair\n           (\\<lambda>g.\n               if g = f then (top, up_filter y)\n               else Rep_lifted_pair (Rep_dense qf) g))))\n     g =\n    Rep_lifted_pair\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g))\n     g", "by (simp add: Abs_dense_inverse)"], ["proof (state)\nthis:\n  Rep_lifted_pair\n   (Rep_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g))))\n   g =\n  Rep_lifted_pair\n   (Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g))\n   g\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "also"], ["proof (state)\nthis:\n  Rep_lifted_pair\n   (Rep_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g))))\n   g =\n  Rep_lifted_pair\n   (Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g))\n   g\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "have \"... = Rep_lifted_pair (Rep_dense qf) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_lifted_pair\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g))\n     g =\n    Rep_lifted_pair (Rep_dense qf) g", "using 2 5"], ["proof (prove)\nusing this:\n  \\<forall>g.\n     (if g = f then (top, up_filter y)\n      else Rep_lifted_pair (Rep_dense qf) g)\n     \\<in> triple.pairs (Rep_phi g)\n  g \\<noteq> f\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g))\n     g =\n    Rep_lifted_pair (Rep_dense qf) g", "by (simp add: Abs_lifted_pair_inverse)"], ["proof (state)\nthis:\n  Rep_lifted_pair\n   (Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g))\n   g =\n  Rep_lifted_pair (Rep_dense qf) g\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "also"], ["proof (state)\nthis:\n  Rep_lifted_pair\n   (Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter y)\n         else Rep_lifted_pair (Rep_dense qf) g))\n   g =\n  Rep_lifted_pair (Rep_dense qf) g\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "have \"... = (top,up_filter (get_dense qf g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense qf) g = (top, up_filter (get_dense qf g))", "using get_dense_char"], ["proof (prove)\nusing this:\n  Rep_lifted_pair (Rep_dense ?pf) ?f = (top, up_filter (get_dense ?pf ?f))\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair (Rep_dense qf) g = (top, up_filter (get_dense qf g))", "by auto"], ["proof (state)\nthis:\n  Rep_lifted_pair (Rep_dense qf) g = (top, up_filter (get_dense qf g))\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "finally"], ["proof (chain)\npicking this:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter y)\n              else Rep_lifted_pair (Rep_dense qf) g)))\n      g)) =\n  (top, up_filter (get_dense qf g))", "have \"get_dense ?rf g = get_dense qf g\""], ["proof (prove)\nusing this:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter y)\n              else Rep_lifted_pair (Rep_dense qf) g)))\n      g)) =\n  (top, up_filter (get_dense qf g))\n\ngoal (1 subgoal):\n 1. get_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g)))\n     g =\n    get_dense qf g", "using up_filter_injective"], ["proof (prove)\nusing this:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter y)\n              else Rep_lifted_pair (Rep_dense qf) g)))\n      g)) =\n  (top, up_filter (get_dense qf g))\n  up_filter ?x = up_filter ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. get_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g)))\n     g =\n    get_dense qf g", "by blast"], ["proof (state)\nthis:\n  get_dense\n   (Abs_dense\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g)))\n   g =\n  get_dense qf g\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "thus \"Rep_lifted_distrib_lattice_top (dl_iso qf) g \\<le> Rep_lifted_distrib_lattice_top (dl_iso ?rf) g\""], ["proof (prove)\nusing this:\n  get_dense\n   (Abs_dense\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter y)\n           else Rep_lifted_pair (Rep_dense qf) g)))\n   g =\n  get_dense qf g\n\ngoal (1 subgoal):\n 1. Rep_lifted_distrib_lattice_top (dl_iso qf) g\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))\n           g", "by (simp add: Abs_lifted_distrib_lattice_top_inverse)"], ["proof (state)\nthis:\n  Rep_lifted_distrib_lattice_top (dl_iso qf) g\n  \\<le> Rep_lifted_distrib_lattice_top\n         (dl_iso\n           (Abs_dense\n             (Abs_lifted_pair\n               (\\<lambda>g.\n                   if g = f then (top, up_filter y)\n                   else Rep_lifted_pair (Rep_dense qf) g))))\n         g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Rep_lifted_distrib_lattice_top (dl_iso qf) g\n  \\<le> Rep_lifted_distrib_lattice_top\n         (dl_iso\n           (Abs_dense\n             (Abs_lifted_pair\n               (\\<lambda>g.\n                   if g = f then (top, up_filter y)\n                   else Rep_lifted_pair (Rep_dense qf) g))))\n         g\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "}"], ["proof (state)\nthis:\n  Rep_lifted_distrib_lattice_top (dl_iso qf) ?g2\n  \\<le> Rep_lifted_distrib_lattice_top\n         (dl_iso\n           (Abs_dense\n             (Abs_lifted_pair\n               (\\<lambda>g.\n                   if g = f then (top, up_filter y)\n                   else Rep_lifted_pair (Rep_dense qf) g))))\n         ?g2\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "hence \"Rep_lifted_distrib_lattice_top (dl_iso qf) \\<le> Rep_lifted_distrib_lattice_top (dl_iso ?rf)\""], ["proof (prove)\nusing this:\n  Rep_lifted_distrib_lattice_top (dl_iso qf) ?g2\n  \\<le> Rep_lifted_distrib_lattice_top\n         (dl_iso\n           (Abs_dense\n             (Abs_lifted_pair\n               (\\<lambda>g.\n                   if g = f then (top, up_filter y)\n                   else Rep_lifted_pair (Rep_dense qf) g))))\n         ?g2\n\ngoal (1 subgoal):\n 1. Rep_lifted_distrib_lattice_top (dl_iso qf)\n    \\<le> Rep_lifted_distrib_lattice_top\n           (dl_iso\n             (Abs_dense\n               (Abs_lifted_pair\n                 (\\<lambda>g.\n                     if g = f then (top, up_filter y)\n                     else Rep_lifted_pair (Rep_dense qf) g))))", "by (simp add: le_funI)"], ["proof (state)\nthis:\n  Rep_lifted_distrib_lattice_top (dl_iso qf)\n  \\<le> Rep_lifted_distrib_lattice_top\n         (dl_iso\n           (Abs_dense\n             (Abs_lifted_pair\n               (\\<lambda>g.\n                   if g = f then (top, up_filter y)\n                   else Rep_lifted_pair (Rep_dense qf) g))))\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "hence 6: \"dl_iso qf \\<le> dl_iso ?rf\""], ["proof (prove)\nusing this:\n  Rep_lifted_distrib_lattice_top (dl_iso qf)\n  \\<le> Rep_lifted_distrib_lattice_top\n         (dl_iso\n           (Abs_dense\n             (Abs_lifted_pair\n               (\\<lambda>g.\n                   if g = f then (top, up_filter y)\n                   else Rep_lifted_pair (Rep_dense qf) g))))\n\ngoal (1 subgoal):\n 1. dl_iso qf\n    \\<le> dl_iso\n           (Abs_dense\n             (Abs_lifted_pair\n               (\\<lambda>g.\n                   if g = f then (top, up_filter y)\n                   else Rep_lifted_pair (Rep_dense qf) g)))", "by (simp add: le_funD less_eq_lifted_distrib_lattice_top.rep_eq)"], ["proof (state)\nthis:\n  dl_iso qf\n  \\<le> dl_iso\n         (Abs_dense\n           (Abs_lifted_pair\n             (\\<lambda>g.\n                 if g = f then (top, up_filter y)\n                 else Rep_lifted_pair (Rep_dense qf) g)))\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "hence \"qf \\<le> ?rf\""], ["proof (prove)\nusing this:\n  dl_iso qf\n  \\<le> dl_iso\n         (Abs_dense\n           (Abs_lifted_pair\n             (\\<lambda>g.\n                 if g = f then (top, up_filter y)\n                 else Rep_lifted_pair (Rep_dense qf) g)))\n\ngoal (1 subgoal):\n 1. qf \\<le> Abs_dense\n              (Abs_lifted_pair\n                (\\<lambda>g.\n                    if g = f then (top, up_filter y)\n                    else Rep_lifted_pair (Rep_dense qf) g))", "by (metis (no_types, lifting) dl_iso sup_isomorphism_ord_isomorphism)"], ["proof (state)\nthis:\n  qf \\<le> Abs_dense\n            (Abs_lifted_pair\n              (\\<lambda>g.\n                  if g = f then (top, up_filter y)\n                  else Rep_lifted_pair (Rep_dense qf) g))\n\ngoal (1 subgoal):\n 1. \\<And>qf y.\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f\n       \\<le> y \\<Longrightarrow>\n       \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "thus \"\\<exists>rf . qf \\<le> rf \\<and> y = Rep_lifted_distrib_lattice_top (dl_iso rf) f\""], ["proof (prove)\nusing this:\n  qf \\<le> Abs_dense\n            (Abs_lifted_pair\n              (\\<lambda>g.\n                  if g = f then (top, up_filter y)\n                  else Rep_lifted_pair (Rep_dense qf) g))\n\ngoal (1 subgoal):\n 1. \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "using 4"], ["proof (prove)\nusing this:\n  qf \\<le> Abs_dense\n            (Abs_lifted_pair\n              (\\<lambda>g.\n                  if g = f then (top, up_filter y)\n                  else Rep_lifted_pair (Rep_dense qf) g))\n  Rep_lifted_distrib_lattice_top\n   (dl_iso\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter y)\n             else Rep_lifted_pair (Rep_dense qf) g))))\n   f =\n  y\n\ngoal (1 subgoal):\n 1. \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f", "by auto"], ["proof (state)\nthis:\n  \\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>qf y.\n     Rep_lifted_distrib_lattice_top (dl_iso qf) f \\<le> y \\<longrightarrow>\n     (\\<exists>rf\\<ge>qf. y = Rep_lifted_distrib_lattice_top (dl_iso rf) f)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe commutativity property states that the same result is obtained in two ways by starting with a regular lifted pair \\<open>pf\\<close>:\n\\begin{itemize}\n\\item apply the Boolean algebra isomorphism to the pair; then apply a structure map \\<open>f\\<close> to obtain a filter of dense elements; or,\n\\item apply the structure map \\<open>stone_phi\\<close> to the pair; then apply the distributive lattice isomorphism lifted to the resulting filter.\n\\end{itemize}\n\\<close>"], ["", "lemma phi_iso:\n  \"Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) = filter_map (\\<lambda>qf::('a::non_trivial_boolean_algebra,'b::distrib_lattice_top) lifted_pair dense . Rep_lifted_distrib_lattice_top (dl_iso qf) f) (stone_phi pf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n    filter_map (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n     (stone_phi pf)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n    filter_map (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n     (stone_phi pf)", "let ?r = \"Rep_phi f\""], ["proof (state)\ngoal (1 subgoal):\n 1. Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n    filter_map (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n     (stone_phi pf)", "let ?ppf = \"\\<lambda>g . triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n    filter_map (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n     (stone_phi pf)", "have 1: \"triple ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi f)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n    filter_map (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n     (stone_phi pf)", "have 2: \"Rep_filter (?r (fst (Rep_lifted_pair (Rep_regular pf) f))) \\<subseteq> { z . \\<exists>qf . -Rep_regular pf \\<le> Rep_dense qf \\<and> z = get_dense qf f }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filters.filter.Rep_filter\n     (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))\n    \\<subseteq> {z. \\<exists>qf.\n                       - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                       z = get_dense qf f}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "obtain x where 3: \"x = fst (Rep_lifted_pair (Rep_regular pf) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x = fst (Rep_lifted_pair (Rep_regular pf) f) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  x = fst (Rep_lifted_pair (Rep_regular pf) f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "assume \"z \\<in> Rep_filter (?r (fst (Rep_lifted_pair (Rep_regular pf) f)))\""], ["proof (state)\nthis:\n  z \\<in> Filters.filter.Rep_filter\n           (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "hence \"\\<up>z \\<subseteq> Rep_filter (?r x)\""], ["proof (prove)\nusing this:\n  z \\<in> Filters.filter.Rep_filter\n           (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))\n\ngoal (1 subgoal):\n 1. \\<up>z \\<subseteq> Filters.filter.Rep_filter (Rep_phi f x)", "using 3 filter_def"], ["proof (prove)\nusing this:\n  z \\<in> Filters.filter.Rep_filter\n           (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))\n  x = fst (Rep_lifted_pair (Rep_regular pf) f)\n  ord_class.filter ?F \\<equiv>\n  ?F \\<noteq> {} \\<and>\n  (\\<forall>x\\<in>?F.\n      \\<forall>y\\<in>?F.\n         \\<exists>z\\<in>?F. z \\<le> x \\<and> z \\<le> y) \\<and>\n  is_up_set ?F\n\ngoal (1 subgoal):\n 1. \\<up>z \\<subseteq> Filters.filter.Rep_filter (Rep_phi f x)", "by fastforce"], ["proof (state)\nthis:\n  \\<up>z \\<subseteq> Filters.filter.Rep_filter (Rep_phi f x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "hence 4: \"up_filter z \\<le> ?r x\""], ["proof (prove)\nusing this:\n  \\<up>z \\<subseteq> Filters.filter.Rep_filter (Rep_phi f x)\n\ngoal (1 subgoal):\n 1. up_filter z \\<le> Rep_phi f x", "by (metis Rep_filter_cases Rep_filter_inverse less_eq_filter.rep_eq mem_Collect_eq up_filter)"], ["proof (state)\nthis:\n  up_filter z \\<le> Rep_phi f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "have 5: \"\\<forall>g . ?ppf g \\<in> triple.pairs (Rep_phi g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g.\n       triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g)\n       \\<in> triple.pairs (Rep_phi g)", "by (metis (no_types) simp_lifted_pair uminus_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  \\<forall>g.\n     triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g)\n     \\<in> triple.pairs (Rep_phi g)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "let ?zf = \"\\<lambda>g . if g = f then (top,up_filter z) else triple.pairs_top\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "have 6: \"\\<forall>g . ?zf g \\<in> triple.pairs (Rep_phi g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g.\n       (if g = f then (top, up_filter z)\n        else (top, Filters.filter.Abs_filter {top}))\n       \\<in> triple.pairs (Rep_phi g)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       (if g = f then (top, up_filter z)\n        else (top, Filters.filter.Abs_filter {top}))\n       \\<in> triple.pairs (Rep_phi g)", "fix g :: \"('a,'b) phi\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       (if g = f then (top, up_filter z)\n        else (top, Filters.filter.Abs_filter {top}))\n       \\<in> triple.pairs (Rep_phi g)", "have \"triple (Rep_phi g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple (Rep_phi g)", "by (simp add: triple_def)"], ["proof (state)\nthis:\n  triple (Rep_phi g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (if g = f then (top, up_filter z)\n        else (top, Filters.filter.Abs_filter {top}))\n       \\<in> triple.pairs (Rep_phi g)", "hence \"(top,up_filter z) \\<in> triple.pairs (Rep_phi g)\""], ["proof (prove)\nusing this:\n  triple (Rep_phi g)\n\ngoal (1 subgoal):\n 1. (top, up_filter z) \\<in> triple.pairs (Rep_phi g)", "using triple.pairs_def"], ["proof (prove)\nusing this:\n  triple (Rep_phi g)\n  triple ?phi \\<Longrightarrow>\n  triple.pairs ?phi =\n  {(x, y). \\<exists>z. y = ?phi (- x) \\<squnion> up_filter z}\n\ngoal (1 subgoal):\n 1. (top, up_filter z) \\<in> triple.pairs (Rep_phi g)", "by force"], ["proof (state)\nthis:\n  (top, up_filter z) \\<in> triple.pairs (Rep_phi g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (if g = f then (top, up_filter z)\n        else (top, Filters.filter.Abs_filter {top}))\n       \\<in> triple.pairs (Rep_phi g)", "thus \"?zf g \\<in> triple.pairs (Rep_phi g)\""], ["proof (prove)\nusing this:\n  (top, up_filter z) \\<in> triple.pairs (Rep_phi g)\n\ngoal (1 subgoal):\n 1. (if g = f then (top, up_filter z)\n     else (top, Filters.filter.Abs_filter {top}))\n    \\<in> triple.pairs (Rep_phi g)", "by (metis simp_lifted_pair top_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  (if g = f then (top, up_filter z)\n   else (top, Filters.filter.Abs_filter {top}))\n  \\<in> triple.pairs (Rep_phi g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>g.\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))\n     \\<in> triple.pairs (Rep_phi g)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "hence \"-Abs_lifted_pair ?zf = Abs_lifted_pair (\\<lambda>g . triple.pairs_uminus (Rep_phi g) (?zf g))\""], ["proof (prove)\nusing this:\n  \\<forall>g.\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))\n     \\<in> triple.pairs (Rep_phi g)\n\ngoal (1 subgoal):\n 1. - Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter z)\n           else (top, Filters.filter.Abs_filter {top})) =\n    Abs_lifted_pair\n     (\\<lambda>g.\n         triple.pairs_uminus (Rep_phi g)\n          (if g = f then (top, up_filter z)\n           else (top, Filters.filter.Abs_filter {top})))", "by (subst uminus_lifted_pair.abs_eq) (simp_all add: eq_onp_same_args)"], ["proof (state)\nthis:\n  - Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter z)\n         else (top, Filters.filter.Abs_filter {top})) =\n  Abs_lifted_pair\n   (\\<lambda>g.\n       triple.pairs_uminus (Rep_phi g)\n        (if g = f then (top, up_filter z)\n         else (top, Filters.filter.Abs_filter {top})))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "also"], ["proof (state)\nthis:\n  - Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter z)\n         else (top, Filters.filter.Abs_filter {top})) =\n  Abs_lifted_pair\n   (\\<lambda>g.\n       triple.pairs_uminus (Rep_phi g)\n        (if g = f then (top, up_filter z)\n         else (top, Filters.filter.Abs_filter {top})))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "have \"... = Abs_lifted_pair (\\<lambda>g . if g = f then triple.pairs_uminus (Rep_phi g) (top,up_filter z) else triple.pairs_uminus (Rep_phi g) triple.pairs_top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>g.\n         triple.pairs_uminus (Rep_phi g)\n          (if g = f then (top, up_filter z)\n           else (top, Filters.filter.Abs_filter {top}))) =\n    Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then triple.pairs_uminus (Rep_phi g) (top, up_filter z)\n         else triple.pairs_uminus (Rep_phi g)\n               (top, Filters.filter.Abs_filter {top}))", "by (rule arg_cong[where f=Abs_lifted_pair]) auto"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       triple.pairs_uminus (Rep_phi g)\n        (if g = f then (top, up_filter z)\n         else (top, Filters.filter.Abs_filter {top}))) =\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then triple.pairs_uminus (Rep_phi g) (top, up_filter z)\n       else triple.pairs_uminus (Rep_phi g)\n             (top, Filters.filter.Abs_filter {top}))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "also"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       triple.pairs_uminus (Rep_phi g)\n        (if g = f then (top, up_filter z)\n         else (top, Filters.filter.Abs_filter {top}))) =\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then triple.pairs_uminus (Rep_phi g) (top, up_filter z)\n       else triple.pairs_uminus (Rep_phi g)\n             (top, Filters.filter.Abs_filter {top}))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "have \"... = Abs_lifted_pair (\\<lambda>g . triple.pairs_bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then triple.pairs_uminus (Rep_phi g) (top, up_filter z)\n         else triple.pairs_uminus (Rep_phi g)\n               (top, Filters.filter.Abs_filter {top})) =\n    Abs_lifted_pair (\\<lambda>g. (bot, Filters.filter.Abs_filter UNIV))", "using 1"], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then triple.pairs_uminus (Rep_phi g) (top, up_filter z)\n         else triple.pairs_uminus (Rep_phi g)\n               (top, Filters.filter.Abs_filter {top})) =\n    Abs_lifted_pair (\\<lambda>g. (bot, Filters.filter.Abs_filter UNIV))", "by (metis bot_lifted_pair.rep_eq dense_closed_top top_lifted_pair.rep_eq triple.pairs_uminus.simps uminus_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then triple.pairs_uminus (Rep_phi g) (top, up_filter z)\n       else triple.pairs_uminus (Rep_phi g)\n             (top, Filters.filter.Abs_filter {top})) =\n  Abs_lifted_pair (\\<lambda>g. (bot, Filters.filter.Abs_filter UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "finally"], ["proof (chain)\npicking this:\n  - Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter z)\n         else (top, Filters.filter.Abs_filter {top})) =\n  Abs_lifted_pair (\\<lambda>g. (bot, Filters.filter.Abs_filter UNIV))", "have 7: \"Abs_lifted_pair ?zf \\<in> dense_elements\""], ["proof (prove)\nusing this:\n  - Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter z)\n         else (top, Filters.filter.Abs_filter {top})) =\n  Abs_lifted_pair (\\<lambda>g. (bot, Filters.filter.Abs_filter UNIV))\n\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>g.\n         if g = f then (top, up_filter z)\n         else (top, Filters.filter.Abs_filter {top}))\n    \\<in> dense_elements", "by (simp add: bot_lifted_pair.abs_eq)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then (top, up_filter z)\n       else (top, Filters.filter.Abs_filter {top}))\n  \\<in> dense_elements\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "let ?qf = \"Abs_dense (Abs_lifted_pair ?zf)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "have \"\\<forall>g . triple.pairs_less_eq (?ppf g) (?zf g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g.\n       triple.pairs_less_eq\n        (triple.pairs_uminus (Rep_phi g)\n          (Rep_lifted_pair (Rep_regular pf) g))\n        (if g = f then (top, up_filter z)\n         else (top, Filters.filter.Abs_filter {top}))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       triple.pairs_less_eq\n        (triple.pairs_uminus (Rep_phi g)\n          (Rep_lifted_pair (Rep_regular pf) g))\n        (if g = f then (top, up_filter z)\n         else (top, Filters.filter.Abs_filter {top}))", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       triple.pairs_less_eq\n        (triple.pairs_uminus (Rep_phi g)\n          (Rep_lifted_pair (Rep_regular pf) g))\n        (if g = f then (top, up_filter z)\n         else (top, Filters.filter.Abs_filter {top}))", "show \"triple.pairs_less_eq (?ppf g) (?zf g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))", "proof (cases \"g = f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. g = f \\<Longrightarrow>\n    triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))\n 2. g \\<noteq> f \\<Longrightarrow>\n    triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))", "assume 8: \"g = f\""], ["proof (state)\nthis:\n  g = f\n\ngoal (2 subgoals):\n 1. g = f \\<Longrightarrow>\n    triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))\n 2. g \\<noteq> f \\<Longrightarrow>\n    triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))", "hence 9: \"?ppf g = (-x,?r x)\""], ["proof (prove)\nusing this:\n  g = f\n\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g) =\n    (- x, Rep_phi f x)", "using 1 3"], ["proof (prove)\nusing this:\n  g = f\n  triple (Rep_phi f)\n  x = fst (Rep_lifted_pair (Rep_regular pf) f)\n\ngoal (1 subgoal):\n 1. triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g) =\n    (- x, Rep_phi f x)", "by (metis prod.collapse triple.pairs_uminus.simps)"], ["proof (state)\nthis:\n  triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g) =\n  (- x, Rep_phi f x)\n\ngoal (2 subgoals):\n 1. g = f \\<Longrightarrow>\n    triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))\n 2. g \\<noteq> f \\<Longrightarrow>\n    triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))", "have \"triple.pairs_less_eq (-x,?r x) (top,up_filter z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (- x, Rep_phi f x) (top, up_filter z)", "using 1 4"], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n  up_filter z \\<le> Rep_phi f x\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (- x, Rep_phi f x) (top, up_filter z)", "by (meson inf.bot_least triple.pairs_less_eq.simps)"], ["proof (state)\nthis:\n  triple.pairs_less_eq (- x, Rep_phi f x) (top, up_filter z)\n\ngoal (2 subgoals):\n 1. g = f \\<Longrightarrow>\n    triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))\n 2. g \\<noteq> f \\<Longrightarrow>\n    triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))", "thus ?thesis"], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (- x, Rep_phi f x) (top, up_filter z)\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))", "using 8 9"], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (- x, Rep_phi f x) (top, up_filter z)\n  g = f\n  triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g) =\n  (- x, Rep_phi f x)\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))", "by simp"], ["proof (state)\nthis:\n  triple.pairs_less_eq\n   (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n   (if g = f then (top, up_filter z)\n    else (top, Filters.filter.Abs_filter {top}))\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))", "assume 10: \"g \\<noteq> f\""], ["proof (state)\nthis:\n  g \\<noteq> f\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))", "have \"triple.pairs_less_eq (?ppf g) triple.pairs_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (top, Filters.filter.Abs_filter {top})", "using 1"], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (top, Filters.filter.Abs_filter {top})", "by (metis (no_types, hide_lams) bot.extremum top_greatest prod.collapse triple_def triple.pairs_less_eq.simps triple.phi_bot)"], ["proof (state)\nthis:\n  triple.pairs_less_eq\n   (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n   (top, Filters.filter.Abs_filter {top})\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))", "thus ?thesis"], ["proof (prove)\nusing this:\n  triple.pairs_less_eq\n   (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n   (top, Filters.filter.Abs_filter {top})\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))", "using 10"], ["proof (prove)\nusing this:\n  triple.pairs_less_eq\n   (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n   (top, Filters.filter.Abs_filter {top})\n  g \\<noteq> f\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq\n     (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))", "by simp"], ["proof (state)\nthis:\n  triple.pairs_less_eq\n   (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n   (if g = f then (top, up_filter z)\n    else (top, Filters.filter.Abs_filter {top}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  triple.pairs_less_eq\n   (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n   (if g = f then (top, up_filter z)\n    else (top, Filters.filter.Abs_filter {top}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>g.\n     triple.pairs_less_eq\n      (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n      (if g = f then (top, up_filter z)\n       else (top, Filters.filter.Abs_filter {top}))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "hence \"Abs_lifted_pair ?ppf \\<le> Abs_lifted_pair ?zf\""], ["proof (prove)\nusing this:\n  \\<forall>g.\n     triple.pairs_less_eq\n      (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n      (if g = f then (top, up_filter z)\n       else (top, Filters.filter.Abs_filter {top}))\n\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>g.\n         triple.pairs_uminus (Rep_phi g)\n          (Rep_lifted_pair (Rep_regular pf) g))\n    \\<le> Abs_lifted_pair\n           (\\<lambda>g.\n               if g = f then (top, up_filter z)\n               else (top, Filters.filter.Abs_filter {top}))", "using 5 6"], ["proof (prove)\nusing this:\n  \\<forall>g.\n     triple.pairs_less_eq\n      (triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n      (if g = f then (top, up_filter z)\n       else (top, Filters.filter.Abs_filter {top}))\n  \\<forall>g.\n     triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g)\n     \\<in> triple.pairs (Rep_phi g)\n  \\<forall>g.\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))\n     \\<in> triple.pairs (Rep_phi g)\n\ngoal (1 subgoal):\n 1. Abs_lifted_pair\n     (\\<lambda>g.\n         triple.pairs_uminus (Rep_phi g)\n          (Rep_lifted_pair (Rep_regular pf) g))\n    \\<le> Abs_lifted_pair\n           (\\<lambda>g.\n               if g = f then (top, up_filter z)\n               else (top, Filters.filter.Abs_filter {top}))", "by (subst less_eq_lifted_pair.abs_eq) (simp_all add: eq_onp_same_args)"], ["proof (state)\nthis:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n  \\<le> Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter z)\n             else (top, Filters.filter.Abs_filter {top}))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "hence 11: \"-Rep_regular pf \\<le> Rep_dense ?qf\""], ["proof (prove)\nusing this:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n  \\<le> Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter z)\n             else (top, Filters.filter.Abs_filter {top}))\n\ngoal (1 subgoal):\n 1. - Rep_regular pf\n    \\<le> Rep_dense\n           (Abs_dense\n             (Abs_lifted_pair\n               (\\<lambda>g.\n                   if g = f then (top, up_filter z)\n                   else (top, Filters.filter.Abs_filter {top}))))", "using 7"], ["proof (prove)\nusing this:\n  Abs_lifted_pair\n   (\\<lambda>g.\n       triple.pairs_uminus (Rep_phi g) (Rep_lifted_pair (Rep_regular pf) g))\n  \\<le> Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter z)\n             else (top, Filters.filter.Abs_filter {top}))\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then (top, up_filter z)\n       else (top, Filters.filter.Abs_filter {top}))\n  \\<in> dense_elements\n\ngoal (1 subgoal):\n 1. - Rep_regular pf\n    \\<le> Rep_dense\n           (Abs_dense\n             (Abs_lifted_pair\n               (\\<lambda>g.\n                   if g = f then (top, up_filter z)\n                   else (top, Filters.filter.Abs_filter {top}))))", "by (simp add: uminus_lifted_pair_def Abs_dense_inverse)"], ["proof (state)\nthis:\n  - Rep_regular pf\n  \\<le> Rep_dense\n         (Abs_dense\n           (Abs_lifted_pair\n             (\\<lambda>g.\n                 if g = f then (top, up_filter z)\n                 else (top, Filters.filter.Abs_filter {top}))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "have \"(top,up_filter (get_dense ?qf f)) = Rep_lifted_pair (Rep_dense ?qf) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (top,\n     up_filter\n      (get_dense\n        (Abs_dense\n          (Abs_lifted_pair\n            (\\<lambda>g.\n                if g = f then (top, up_filter z)\n                else (top, Filters.filter.Abs_filter {top}))))\n        f)) =\n    Rep_lifted_pair\n     (Rep_dense\n       (Abs_dense\n         (Abs_lifted_pair\n           (\\<lambda>g.\n               if g = f then (top, up_filter z)\n               else (top, Filters.filter.Abs_filter {top})))))\n     f", "by (metis get_dense_char)"], ["proof (state)\nthis:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter z)\n              else (top, Filters.filter.Abs_filter {top}))))\n      f)) =\n  Rep_lifted_pair\n   (Rep_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter z)\n             else (top, Filters.filter.Abs_filter {top})))))\n   f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "also"], ["proof (state)\nthis:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter z)\n              else (top, Filters.filter.Abs_filter {top}))))\n      f)) =\n  Rep_lifted_pair\n   (Rep_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter z)\n             else (top, Filters.filter.Abs_filter {top})))))\n   f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "have \"... = (top,up_filter z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_lifted_pair\n     (Rep_dense\n       (Abs_dense\n         (Abs_lifted_pair\n           (\\<lambda>g.\n               if g = f then (top, up_filter z)\n               else (top, Filters.filter.Abs_filter {top})))))\n     f =\n    (top, up_filter z)", "using 6 7 Abs_dense_inverse Abs_lifted_pair_inverse"], ["proof (prove)\nusing this:\n  \\<forall>g.\n     (if g = f then (top, up_filter z)\n      else (top, Filters.filter.Abs_filter {top}))\n     \\<in> triple.pairs (Rep_phi g)\n  Abs_lifted_pair\n   (\\<lambda>g.\n       if g = f then (top, up_filter z)\n       else (top, Filters.filter.Abs_filter {top}))\n  \\<in> dense_elements\n  ?y \\<in> dense_elements \\<Longrightarrow> Rep_dense (Abs_dense ?y) = ?y\n  ?y \\<in> {pf.\n            \\<forall>f.\n               pf f \\<in> triple.pairs (Rep_phi f)} \\<Longrightarrow>\n  Rep_lifted_pair (Abs_lifted_pair ?y) = ?y\n\ngoal (1 subgoal):\n 1. Rep_lifted_pair\n     (Rep_dense\n       (Abs_dense\n         (Abs_lifted_pair\n           (\\<lambda>g.\n               if g = f then (top, up_filter z)\n               else (top, Filters.filter.Abs_filter {top})))))\n     f =\n    (top, up_filter z)", "by force"], ["proof (state)\nthis:\n  Rep_lifted_pair\n   (Rep_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter z)\n             else (top, Filters.filter.Abs_filter {top})))))\n   f =\n  (top, up_filter z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "finally"], ["proof (chain)\npicking this:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter z)\n              else (top, Filters.filter.Abs_filter {top}))))\n      f)) =\n  (top, up_filter z)", "have \"z = get_dense ?qf f\""], ["proof (prove)\nusing this:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter z)\n              else (top, Filters.filter.Abs_filter {top}))))\n      f)) =\n  (top, up_filter z)\n\ngoal (1 subgoal):\n 1. z =\n    get_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter z)\n             else (top, Filters.filter.Abs_filter {top}))))\n     f", "using up_filter_injective"], ["proof (prove)\nusing this:\n  (top,\n   up_filter\n    (get_dense\n      (Abs_dense\n        (Abs_lifted_pair\n          (\\<lambda>g.\n              if g = f then (top, up_filter z)\n              else (top, Filters.filter.Abs_filter {top}))))\n      f)) =\n  (top, up_filter z)\n  up_filter ?x = up_filter ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. z =\n    get_dense\n     (Abs_dense\n       (Abs_lifted_pair\n         (\\<lambda>g.\n             if g = f then (top, up_filter z)\n             else (top, Filters.filter.Abs_filter {top}))))\n     f", "by force"], ["proof (state)\nthis:\n  z =\n  get_dense\n   (Abs_dense\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter z)\n           else (top, Filters.filter.Abs_filter {top}))))\n   f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f\n                  (fst (Rep_lifted_pair (Rep_regular pf)\n                         f))) \\<Longrightarrow>\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f}", "thus \"z \\<in> { z . \\<exists>qf . -Rep_regular pf \\<le> Rep_dense qf \\<and> z = get_dense qf f }\""], ["proof (prove)\nusing this:\n  z =\n  get_dense\n   (Abs_dense\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter z)\n           else (top, Filters.filter.Abs_filter {top}))))\n   f\n\ngoal (1 subgoal):\n 1. z \\<in> {z. \\<exists>qf.\n                   - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                   z = get_dense qf f}", "using 11"], ["proof (prove)\nusing this:\n  z =\n  get_dense\n   (Abs_dense\n     (Abs_lifted_pair\n       (\\<lambda>g.\n           if g = f then (top, up_filter z)\n           else (top, Filters.filter.Abs_filter {top}))))\n   f\n  - Rep_regular pf\n  \\<le> Rep_dense\n         (Abs_dense\n           (Abs_lifted_pair\n             (\\<lambda>g.\n                 if g = f then (top, up_filter z)\n                 else (top, Filters.filter.Abs_filter {top}))))\n\ngoal (1 subgoal):\n 1. z \\<in> {z. \\<exists>qf.\n                   - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                   z = get_dense qf f}", "by auto"], ["proof (state)\nthis:\n  z \\<in> {z. \\<exists>qf.\n                 - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                 z = get_dense qf f}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Filters.filter.Rep_filter\n   (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))\n  \\<subseteq> {z. \\<exists>qf.\n                     - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                     z = get_dense qf f}\n\ngoal (1 subgoal):\n 1. Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n    filter_map (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n     (stone_phi pf)", "have 12: \"Rep_filter (?r (fst (Rep_lifted_pair (Rep_regular pf) f))) \\<supseteq> { z . \\<exists>qf . -Rep_regular pf \\<le> Rep_dense qf \\<and> z = get_dense qf f }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {z. \\<exists>qf.\n           - Rep_regular pf \\<le> Rep_dense qf \\<and> z = get_dense qf f}\n    \\<subseteq> Filters.filter.Rep_filter\n                 (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f} \\<Longrightarrow>\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f} \\<Longrightarrow>\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "assume \"z \\<in> { z . \\<exists>qf . -Rep_regular pf \\<le> Rep_dense qf \\<and> z = get_dense qf f }\""], ["proof (state)\nthis:\n  z \\<in> {z. \\<exists>qf.\n                 - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                 z = get_dense qf f}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f} \\<Longrightarrow>\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "hence \"\\<exists>qf . -Rep_regular pf \\<le> Rep_dense qf \\<and> z = get_dense qf f\""], ["proof (prove)\nusing this:\n  z \\<in> {z. \\<exists>qf.\n                 - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                 z = get_dense qf f}\n\ngoal (1 subgoal):\n 1. \\<exists>qf.\n       - Rep_regular pf \\<le> Rep_dense qf \\<and> z = get_dense qf f", "by auto"], ["proof (state)\nthis:\n  \\<exists>qf. - Rep_regular pf \\<le> Rep_dense qf \\<and> z = get_dense qf f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f} \\<Longrightarrow>\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "hence \"triple.pairs_less_eq (Rep_lifted_pair (-Rep_regular pf) f) (top,up_filter z)\""], ["proof (prove)\nusing this:\n  \\<exists>qf. - Rep_regular pf \\<le> Rep_dense qf \\<and> z = get_dense qf f\n\ngoal (1 subgoal):\n 1. triple.pairs_less_eq (Rep_lifted_pair (- Rep_regular pf) f)\n     (top, up_filter z)", "by (metis less_eq_lifted_pair.rep_eq get_dense_char)"], ["proof (state)\nthis:\n  triple.pairs_less_eq (Rep_lifted_pair (- Rep_regular pf) f)\n   (top, up_filter z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f} \\<Longrightarrow>\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "hence \"up_filter z \\<le> snd (Rep_lifted_pair (-Rep_regular pf) f)\""], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair (- Rep_regular pf) f)\n   (top, up_filter z)\n\ngoal (1 subgoal):\n 1. up_filter z \\<le> snd (Rep_lifted_pair (- Rep_regular pf) f)", "using 1"], ["proof (prove)\nusing this:\n  triple.pairs_less_eq (Rep_lifted_pair (- Rep_regular pf) f)\n   (top, up_filter z)\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. up_filter z \\<le> snd (Rep_lifted_pair (- Rep_regular pf) f)", "by (metis (no_types, hide_lams) prod.collapse triple.pairs_less_eq.simps)"], ["proof (state)\nthis:\n  up_filter z \\<le> snd (Rep_lifted_pair (- Rep_regular pf) f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f} \\<Longrightarrow>\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "also"], ["proof (state)\nthis:\n  up_filter z \\<le> snd (Rep_lifted_pair (- Rep_regular pf) f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f} \\<Longrightarrow>\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "have \"... = snd (?ppf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Rep_lifted_pair (- Rep_regular pf) f) =\n    snd (triple.pairs_uminus (Rep_phi f)\n          (Rep_lifted_pair (Rep_regular pf) f))", "by (metis uminus_lifted_pair.rep_eq)"], ["proof (state)\nthis:\n  snd (Rep_lifted_pair (- Rep_regular pf) f) =\n  snd (triple.pairs_uminus (Rep_phi f) (Rep_lifted_pair (Rep_regular pf) f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f} \\<Longrightarrow>\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "also"], ["proof (state)\nthis:\n  snd (Rep_lifted_pair (- Rep_regular pf) f) =\n  snd (triple.pairs_uminus (Rep_phi f) (Rep_lifted_pair (Rep_regular pf) f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f} \\<Longrightarrow>\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "have \"... = ?r (fst (Rep_lifted_pair (Rep_regular pf) f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (triple.pairs_uminus (Rep_phi f)\n          (Rep_lifted_pair (Rep_regular pf) f)) =\n    Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f))", "using 1"], ["proof (prove)\nusing this:\n  triple (Rep_phi f)\n\ngoal (1 subgoal):\n 1. snd (triple.pairs_uminus (Rep_phi f)\n          (Rep_lifted_pair (Rep_regular pf) f)) =\n    Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f))", "by (metis (no_types) prod.collapse prod.inject triple.pairs_uminus.simps)"], ["proof (state)\nthis:\n  snd (triple.pairs_uminus (Rep_phi f)\n        (Rep_lifted_pair (Rep_regular pf) f)) =\n  Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f} \\<Longrightarrow>\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "finally"], ["proof (chain)\npicking this:\n  up_filter z \\<le> Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f))", "have \"Rep_filter (up_filter z) \\<subseteq> Rep_filter (?r (fst (Rep_lifted_pair (Rep_regular pf) f)))\""], ["proof (prove)\nusing this:\n  up_filter z \\<le> Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f))\n\ngoal (1 subgoal):\n 1. Filters.filter.Rep_filter (up_filter z)\n    \\<subseteq> Filters.filter.Rep_filter\n                 (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "by (simp add: less_eq_filter.rep_eq)"], ["proof (state)\nthis:\n  Filters.filter.Rep_filter (up_filter z)\n  \\<subseteq> Filters.filter.Rep_filter\n               (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f} \\<Longrightarrow>\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "hence \"\\<up>z \\<subseteq> Rep_filter (?r (fst (Rep_lifted_pair (Rep_regular pf) f)))\""], ["proof (prove)\nusing this:\n  Filters.filter.Rep_filter (up_filter z)\n  \\<subseteq> Filters.filter.Rep_filter\n               (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))\n\ngoal (1 subgoal):\n 1. \\<up>z\n    \\<subseteq> Filters.filter.Rep_filter\n                 (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "by (metis Abs_filter_inverse mem_Collect_eq up_filter)"], ["proof (state)\nthis:\n  \\<up>z\n  \\<subseteq> Filters.filter.Rep_filter\n               (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {z. \\<exists>qf.\n                      - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                      z = get_dense qf f} \\<Longrightarrow>\n       x \\<in> Filters.filter.Rep_filter\n                (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "thus \"z \\<in> Rep_filter (?r (fst (Rep_lifted_pair (Rep_regular pf) f)))\""], ["proof (prove)\nusing this:\n  \\<up>z\n  \\<subseteq> Filters.filter.Rep_filter\n               (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))\n\ngoal (1 subgoal):\n 1. z \\<in> Filters.filter.Rep_filter\n             (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))", "by blast"], ["proof (state)\nthis:\n  z \\<in> Filters.filter.Rep_filter\n           (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {z. \\<exists>qf.\n         - Rep_regular pf \\<le> Rep_dense qf \\<and> z = get_dense qf f}\n  \\<subseteq> Filters.filter.Rep_filter\n               (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))\n\ngoal (1 subgoal):\n 1. Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n    filter_map (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n     (stone_phi pf)", "have 13: \"\\<forall>qf\\<in>Rep_filter (stone_phi pf) . Rep_lifted_distrib_lattice_top (Abs_lifted_distrib_lattice_top (get_dense qf)) f = get_dense qf f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qf\\<in>Filters.filter.Rep_filter (stone_phi pf).\n       Rep_lifted_distrib_lattice_top (dl_iso qf) f = get_dense qf f", "by (metis Abs_lifted_distrib_lattice_top_inverse UNIV_I UNIV_def)"], ["proof (state)\nthis:\n  \\<forall>qf\\<in>Filters.filter.Rep_filter (stone_phi pf).\n     Rep_lifted_distrib_lattice_top (dl_iso qf) f = get_dense qf f\n\ngoal (1 subgoal):\n 1. Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n    filter_map (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n     (stone_phi pf)", "have \"Rep_filter (?r (fst (Rep_lifted_pair (Rep_regular pf) f))) = { z . \\<exists>qf\\<in>stone_phi_base pf . z = get_dense qf f }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Filters.filter.Rep_filter\n     (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f))) =\n    {z. \\<exists>qf\\<in>stone_phi_base pf. z = get_dense qf f}", "using 2 12"], ["proof (prove)\nusing this:\n  Filters.filter.Rep_filter\n   (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))\n  \\<subseteq> {z. \\<exists>qf.\n                     - Rep_regular pf \\<le> Rep_dense qf \\<and>\n                     z = get_dense qf f}\n  {z. \\<exists>qf.\n         - Rep_regular pf \\<le> Rep_dense qf \\<and> z = get_dense qf f}\n  \\<subseteq> Filters.filter.Rep_filter\n               (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)))\n\ngoal (1 subgoal):\n 1. Filters.filter.Rep_filter\n     (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f))) =\n    {z. \\<exists>qf\\<in>stone_phi_base pf. z = get_dense qf f}", "by simp"], ["proof (state)\nthis:\n  Filters.filter.Rep_filter\n   (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f))) =\n  {z. \\<exists>qf\\<in>stone_phi_base pf. z = get_dense qf f}\n\ngoal (1 subgoal):\n 1. Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n    filter_map (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n     (stone_phi pf)", "hence \"?r (fst (Rep_lifted_pair (Rep_regular pf) f)) = Abs_filter { z . \\<exists>qf\\<in>stone_phi_base pf . z = get_dense qf f }\""], ["proof (prove)\nusing this:\n  Filters.filter.Rep_filter\n   (Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f))) =\n  {z. \\<exists>qf\\<in>stone_phi_base pf. z = get_dense qf f}\n\ngoal (1 subgoal):\n 1. Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)) =\n    Filters.filter.Abs_filter\n     {z. \\<exists>qf\\<in>stone_phi_base pf. z = get_dense qf f}", "by (metis Rep_filter_inverse)"], ["proof (state)\nthis:\n  Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)) =\n  Filters.filter.Abs_filter\n   {z. \\<exists>qf\\<in>stone_phi_base pf. z = get_dense qf f}\n\ngoal (1 subgoal):\n 1. Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n    filter_map (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n     (stone_phi pf)", "hence \"?r (Rep_lifted_boolean_algebra (ba_iso pf) f) = Abs_filter { z . \\<exists>qf\\<in>Rep_filter (stone_phi pf) . z = Rep_lifted_distrib_lattice_top (dl_iso qf) f }\""], ["proof (prove)\nusing this:\n  Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)) =\n  Filters.filter.Abs_filter\n   {z. \\<exists>qf\\<in>stone_phi_base pf. z = get_dense qf f}\n\ngoal (1 subgoal):\n 1. Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n    Filters.filter.Abs_filter\n     {z. \\<exists>qf\\<in>Filters.filter.Rep_filter (stone_phi pf).\n            z = Rep_lifted_distrib_lattice_top (dl_iso qf) f}", "using 13"], ["proof (prove)\nusing this:\n  Rep_phi f (fst (Rep_lifted_pair (Rep_regular pf) f)) =\n  Filters.filter.Abs_filter\n   {z. \\<exists>qf\\<in>stone_phi_base pf. z = get_dense qf f}\n  \\<forall>qf\\<in>Filters.filter.Rep_filter (stone_phi pf).\n     Rep_lifted_distrib_lattice_top (dl_iso qf) f = get_dense qf f\n\ngoal (1 subgoal):\n 1. Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n    Filters.filter.Abs_filter\n     {z. \\<exists>qf\\<in>Filters.filter.Rep_filter (stone_phi pf).\n            z = Rep_lifted_distrib_lattice_top (dl_iso qf) f}", "by (simp add: Abs_filter_inverse stone_phi_base_filter stone_phi_def Abs_lifted_boolean_algebra_inverse)"], ["proof (state)\nthis:\n  Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n  Filters.filter.Abs_filter\n   {z. \\<exists>qf\\<in>Filters.filter.Rep_filter (stone_phi pf).\n          z = Rep_lifted_distrib_lattice_top (dl_iso qf) f}\n\ngoal (1 subgoal):\n 1. Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n    filter_map (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n     (stone_phi pf)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n  Filters.filter.Abs_filter\n   {z. \\<exists>qf\\<in>Filters.filter.Rep_filter (stone_phi pf).\n          z = Rep_lifted_distrib_lattice_top (dl_iso qf) f}\n\ngoal (1 subgoal):\n 1. Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n    filter_map (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n     (stone_phi pf)", "by (simp add: image_def)"], ["proof (state)\nthis:\n  Rep_phi f (Rep_lifted_boolean_algebra (ba_iso pf) f) =\n  filter_map (\\<lambda>qf. Rep_lifted_distrib_lattice_top (dl_iso qf) f)\n   (stone_phi pf)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}