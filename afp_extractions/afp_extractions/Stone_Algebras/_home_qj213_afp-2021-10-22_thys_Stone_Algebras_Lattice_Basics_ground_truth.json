{"file_name": "/home/qj213/afp-2021-10-22/thys/Stone_Algebras/Lattice_Basics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stone_Algebras", "problem_names": ["lemma imp_as_conj:\n  assumes \"P x \\<Longrightarrow> Q x\"\n  shows \"P x \\<and> Q x \\<longleftrightarrow> P x\"", "lemma if_distrib_2:\n  \"f (if c then x else y) (if c then z else w) = (if c then f x z else f y w)\"", "lemma left_invertible_inj:\n  \"(\\<forall>x . g (f x) = x) \\<Longrightarrow> inj f\"", "lemma invertible_bij:\n  assumes \"\\<forall>x . g (f x) = x\"\n      and \"\\<forall>y . f (g y) = y\"\n    shows \"bij f\"", "lemma finite_ne_subset_induct [consumes 3, case_names singleton insert]:\n  assumes \"finite F\"\n      and \"F \\<noteq> {}\"\n      and \"F \\<subseteq> S\"\n      and singleton: \"\\<And>x . P {x}\"\n      and insert: \"\\<And>x F . finite F \\<Longrightarrow> F \\<noteq> {} \\<Longrightarrow> F \\<subseteq> S \\<Longrightarrow> x \\<in> S \\<Longrightarrow> x \\<notin> F \\<Longrightarrow> P F \\<Longrightarrow> P (insert x F)\"\n    shows \"P F\"", "lemma finite_set_of_finite_funs_pred:\n  assumes \"finite { x::'a . True }\"\n      and \"finite { y::'b . P y }\"\n    shows \"finite { f . (\\<forall>x::'a . P (f x)) }\"", "lemma order_lesseq_imp:\n  \"(\\<forall>z . x \\<le> z \\<longrightarrow> y \\<le> z) \\<longleftrightarrow> y \\<le> x\"", "lemma galois_char:\n  \"galois l u \\<longleftrightarrow> (\\<forall>x . x \\<le> u (l x)) \\<and> (\\<forall>x . l (u x) \\<le> x) \\<and> isotone l \\<and> isotone u\"", "lemma galois_closure:\n  \"galois l u \\<Longrightarrow> l x = l (u (l x)) \\<and> u x = u (l (u x))\"", "lemma lifted_reflexive:\n  \"f = g \\<Longrightarrow> f \\<le>\\<le> g\"", "lemma lifted_transitive:\n  \"f \\<le>\\<le> g \\<Longrightarrow> g \\<le>\\<le> h \\<Longrightarrow> f \\<le>\\<le> h\"", "lemma lifted_antisymmetric:\n  \"f \\<le>\\<le> g \\<Longrightarrow> g \\<le>\\<le> f \\<Longrightarrow> f = g\"", "lemma finite_set_minimal:\n  assumes \"finite s\"\n      and \"s \\<noteq> {}\"\n      and \"\\<forall>x\\<in>s . \\<forall>y\\<in>s . f x \\<le> f y \\<or> f y \\<le> f x\"\n    shows \"\\<exists>m\\<in>s . \\<forall>z\\<in>s . f m \\<le> f z\"", "lemma sup_left_isotone:\n  \"x \\<le> y \\<Longrightarrow> x \\<squnion> z \\<le> y \\<squnion> z\"", "lemma sup_right_isotone:\n  \"x \\<le> y \\<Longrightarrow> z \\<squnion> x \\<le> z \\<squnion> y\"", "lemma sup_left_divisibility:\n  \"x \\<le> y \\<longleftrightarrow> (\\<exists>z . x \\<squnion> z = y)\"", "lemma sup_right_divisibility:\n  \"x \\<le> y \\<longleftrightarrow> (\\<exists>z . z \\<squnion> x = y)\"", "lemma sup_same_context:\n  \"x \\<le> y \\<squnion> z \\<Longrightarrow> y \\<le> x \\<squnion> z \\<Longrightarrow> x \\<squnion> z = y \\<squnion> z\"", "lemma sup_relative_same_increasing:\n  \"x \\<le> y \\<Longrightarrow> x \\<squnion> z = x \\<squnion> w \\<Longrightarrow> y \\<squnion> z = y \\<squnion> w\"", "lemma inf_same_context:\n  \"x \\<le> y \\<sqinter> z \\<Longrightarrow> y \\<le> x \\<sqinter> z \\<Longrightarrow> x \\<sqinter> z = y \\<sqinter> z\"", "lemma complement_symmetric:\n  \"complement x y \\<Longrightarrow> complement y x\"", "lemma relative_equality:\n  \"x \\<squnion> z = y \\<squnion> z \\<Longrightarrow> x \\<sqinter> z = y \\<sqinter> z \\<Longrightarrow> x = y\"", "lemma complement_shunting:\n  assumes \"complement z w\"\n    shows \"z \\<sqinter> x \\<le> y \\<longleftrightarrow> x \\<le> w \\<squnion> y\"", "lemma max_sup:\n  \"max x y = x \\<squnion> y\"", "lemma min_inf:\n  \"min x y = x \\<sqinter> y\"", "lemma sup_inf_selective:\n  \"(x \\<squnion> y = x \\<and> x \\<sqinter> y = y) \\<or> (x \\<squnion> y = y \\<and> x \\<sqinter> y = x)\"", "lemma sup_selective:\n  \"x \\<squnion> y = x \\<or> x \\<squnion> y = y\"", "lemma inf_selective:\n  \"x \\<sqinter> y = x \\<or> x \\<sqinter> y = y\"", "lemma sup_less_eq:\n  \"x \\<le> y \\<squnion> z \\<longleftrightarrow> x \\<le> y \\<or> x \\<le> z\"", "lemma inf_less_eq:\n  \"x \\<sqinter> y \\<le> z \\<longleftrightarrow> x \\<le> z \\<or> y \\<le> z\"", "lemma sup_inf_sup:\n  \"x \\<squnion> y = (x \\<squnion> y) \\<squnion> (x \\<sqinter> y)\"", "lemma sup_dense:\n  \"x \\<noteq> top \\<Longrightarrow> y \\<noteq> top \\<Longrightarrow> x \\<squnion> y \\<noteq> top\"", "lemma inf_dense:\n  \"x \\<noteq> bot \\<Longrightarrow> y \\<noteq> bot \\<Longrightarrow> x \\<sqinter> y \\<noteq> bot\"", "lemma sup_not_bot:\n  \"x \\<noteq> bot \\<Longrightarrow> x \\<squnion> y \\<noteq> bot\"", "lemma inf_not_top:\n  \"x \\<noteq> top \\<Longrightarrow> x \\<sqinter> y \\<noteq> top\"", "lemma bot_not_top:\n  \"bot \\<noteq> top\"", "lemma sup_homomorphism_mono:\n  \"sup_homomorphism (f::'a::semilattice_sup \\<Rightarrow> 'b::semilattice_sup) \\<Longrightarrow> mono f\"", "lemma sup_isomorphism_ord_isomorphism:\n  assumes \"sup_homomorphism (f::'a::semilattice_sup \\<Rightarrow> 'b::semilattice_sup)\"\n      and \"bij f\"\n    shows \"x \\<le> y \\<longleftrightarrow> f x \\<le> f y\"", "lemma minus_homomorphism_default:\n  assumes \"\\<forall>x y::'a::{inf,minus,uminus} . x - y = x \\<sqinter> -y\"\n      and \"\\<forall>x y::'b::{inf,minus,uminus} . x - y = x \\<sqinter> -y\"\n      and \"inf_homomorphism (f::'a \\<Rightarrow> 'b)\"\n      and \"uminus_homomorphism f\"\n    shows \"minus_homomorphism f\""], "translations": [["", "lemma imp_as_conj:\n  assumes \"P x \\<Longrightarrow> Q x\"\n  shows \"P x \\<and> Q x \\<longleftrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P x \\<and> Q x) = P x", "using assms"], ["proof (prove)\nusing this:\n  P x \\<Longrightarrow> Q x\n\ngoal (1 subgoal):\n 1. (P x \\<and> Q x) = P x", "by auto"], ["", "lemma if_distrib_2:\n  \"f (if c then x else y) (if c then z else w) = (if c then f x z else f y w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (if c then x else y) (if c then z else w) =\n    (if c then f x z else f y w)", "by simp"], ["", "lemma left_invertible_inj:\n  \"(\\<forall>x . g (f x) = x) \\<Longrightarrow> inj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. g (f x) = x \\<Longrightarrow> inj f", "by (metis injI)"], ["", "lemma invertible_bij:\n  assumes \"\\<forall>x . g (f x) = x\"\n      and \"\\<forall>y . f (g y) = y\"\n    shows \"bij f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij f", "by (metis assms bijI')"], ["", "lemma finite_ne_subset_induct [consumes 3, case_names singleton insert]:\n  assumes \"finite F\"\n      and \"F \\<noteq> {}\"\n      and \"F \\<subseteq> S\"\n      and singleton: \"\\<And>x . P {x}\"\n      and insert: \"\\<And>x F . finite F \\<Longrightarrow> F \\<noteq> {} \\<Longrightarrow> F \\<subseteq> S \\<Longrightarrow> x \\<in> S \\<Longrightarrow> x \\<notin> F \\<Longrightarrow> P F \\<Longrightarrow> P (insert x F)\"\n    shows \"P F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P F", "using assms(1-3)"], ["proof (prove)\nusing this:\n  finite F\n  F \\<noteq> {}\n  F \\<subseteq> S\n\ngoal (1 subgoal):\n 1. P F", "apply (induct rule: finite_ne_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. {x} \\<subseteq> S \\<Longrightarrow> P {x}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        F \\<subseteq> S \\<Longrightarrow> P F;\n        insert x F \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P (insert x F)", "apply (simp add: singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        F \\<subseteq> S \\<Longrightarrow> P F;\n        insert x F \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> P (insert x F)", "by (simp add: insert)"], ["", "lemma finite_set_of_finite_funs_pred:\n  assumes \"finite { x::'a . True }\"\n      and \"finite { y::'b . P y }\"\n    shows \"finite { f . (\\<forall>x::'a . P (f x)) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {f. \\<forall>x. P (f x)}", "using assms finite_set_of_finite_funs"], ["proof (prove)\nusing this:\n  finite {x. True}\n  finite {y. P y}\n  \\<lbrakk>finite ?A; finite ?B\\<rbrakk>\n  \\<Longrightarrow> finite\n                     {f. \\<forall>x.\n                            (x \\<in> ?A \\<longrightarrow>\n                             f x \\<in> ?B) \\<and>\n                            (x \\<notin> ?A \\<longrightarrow> f x = ?d)}\n\ngoal (1 subgoal):\n 1. finite {f. \\<forall>x. P (f x)}", "by force"], ["", "text \\<open>\nWe use the following notations for the join, meet and complement operations.\nChanging the precedence of the unary complement allows us to write terms like \\<open>--x\\<close> instead of \\<open>-(-x)\\<close>.\n\\<close>"], ["", "context sup\nbegin"], ["", "notation sup (infixl \"\\<squnion>\" 65)"], ["", "definition additive :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"additive f \\<equiv> \\<forall>x y . f (x \\<squnion> y) = f x \\<squnion> f y\""], ["", "end"], ["", "context inf\nbegin"], ["", "notation inf (infixl \"\\<sqinter>\" 67)"], ["", "end"], ["", "context uminus\nbegin"], ["", "no_notation uminus (\"- _\" [81] 80)"], ["", "notation uminus (\"- _\" [80] 80)"], ["", "end"], ["", "subsection \\<open>Orders\\<close>"], ["", "text \\<open>\nWe use the following definition of monotonicity for operations defined in classes.\nThe standard \\<open>mono\\<close> places a sort constraint on the target type.\nWe also give basic properties of Galois connections and lift orders to functions.\n\\<close>"], ["", "context ord\nbegin"], ["", "definition isotone :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"isotone f \\<equiv> \\<forall>x y . x \\<le> y \\<longrightarrow> f x \\<le> f y\""], ["", "definition galois :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> ('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"galois l u \\<equiv> \\<forall>x y . l x \\<le> y \\<longleftrightarrow> x \\<le> u y\""], ["", "definition lifted_less_eq :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> ('a \\<Rightarrow> 'a) \\<Rightarrow> bool\" (\"(_ \\<le>\\<le> _)\" [51, 51] 50)\n  where \"f \\<le>\\<le> g \\<equiv> \\<forall>x . f x \\<le> g x\""], ["", "end"], ["", "context order\nbegin"], ["", "lemma order_lesseq_imp:\n  \"(\\<forall>z . x \\<le> z \\<longrightarrow> y \\<le> z) \\<longleftrightarrow> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>z\\<ge>x. y \\<le> z) = (y \\<le> x)", "using order_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. (\\<forall>z\\<ge>x. y \\<le> z) = (y \\<le> x)", "by blast"], ["", "lemma galois_char:\n  \"galois l u \\<longleftrightarrow> (\\<forall>x . x \\<le> u (l x)) \\<and> (\\<forall>x . l (u x) \\<le> x) \\<and> isotone l \\<and> isotone u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. galois l u =\n    ((\\<forall>x. x \\<le> u (l x)) \\<and>\n     (\\<forall>x. l (u x) \\<le> x) \\<and> isotone l \\<and> isotone u)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. galois l u \\<Longrightarrow>\n    (\\<forall>x. x \\<le> u (l x)) \\<and>\n    (\\<forall>x. l (u x) \\<le> x) \\<and> isotone l \\<and> isotone u\n 2. (\\<forall>x. x \\<le> u (l x)) \\<and>\n    (\\<forall>x. l (u x) \\<le> x) \\<and>\n    isotone l \\<and> isotone u \\<Longrightarrow>\n    galois l u", "apply (metis (full_types) galois_def isotone_def order_refl order_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. x \\<le> u (l x)) \\<and>\n    (\\<forall>x. l (u x) \\<le> x) \\<and>\n    isotone l \\<and> isotone u \\<Longrightarrow>\n    galois l u", "using galois_def isotone_def order_trans"], ["proof (prove)\nusing this:\n  galois ?l ?u \\<equiv> \\<forall>x y. (?l x \\<le> y) = (x \\<le> ?u y)\n  isotone ?f \\<equiv>\n  \\<forall>x y. x \\<le> y \\<longrightarrow> ?f x \\<le> ?f y\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. (\\<forall>x. x \\<le> u (l x)) \\<and>\n    (\\<forall>x. l (u x) \\<le> x) \\<and>\n    isotone l \\<and> isotone u \\<Longrightarrow>\n    galois l u", "by blast"], ["", "lemma galois_closure:\n  \"galois l u \\<Longrightarrow> l x = l (u (l x)) \\<and> u x = u (l (u x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. galois l u \\<Longrightarrow> l x = l (u (l x)) \\<and> u x = u (l (u x))", "by (simp add: galois_char isotone_def antisym)"], ["", "lemma lifted_reflexive:\n  \"f = g \\<Longrightarrow> f \\<le>\\<le> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g \\<Longrightarrow> f \\<le>\\<le> g", "by (simp add: lifted_less_eq_def)"], ["", "lemma lifted_transitive:\n  \"f \\<le>\\<le> g \\<Longrightarrow> g \\<le>\\<le> h \\<Longrightarrow> f \\<le>\\<le> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<le>\\<le> g; g \\<le>\\<le> h\\<rbrakk>\n    \\<Longrightarrow> f \\<le>\\<le> h", "using lifted_less_eq_def order_trans"], ["proof (prove)\nusing this:\n  ?f \\<le>\\<le> ?g \\<equiv> \\<forall>x. ?f x \\<le> ?g x\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<le>\\<le> g; g \\<le>\\<le> h\\<rbrakk>\n    \\<Longrightarrow> f \\<le>\\<le> h", "by blast"], ["", "lemma lifted_antisymmetric:\n  \"f \\<le>\\<le> g \\<Longrightarrow> g \\<le>\\<le> f \\<Longrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<le>\\<le> g; g \\<le>\\<le> f\\<rbrakk> \\<Longrightarrow> f = g", "by (metis (full_types) antisym ext lifted_less_eq_def)"], ["", "text \\<open>\nIf the image of a finite non-empty set under \\<open>f\\<close> is a totally ordered, there is an element that minimises the value of \\<open>f\\<close>.\n\\<close>"], ["", "lemma finite_set_minimal:\n  assumes \"finite s\"\n      and \"s \\<noteq> {}\"\n      and \"\\<forall>x\\<in>s . \\<forall>y\\<in>s . f x \\<le> f y \\<or> f y \\<le> f x\"\n    shows \"\\<exists>m\\<in>s . \\<forall>z\\<in>s . f m \\<le> f z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>s. \\<forall>z\\<in>s. f m \\<le> f z", "apply (rule finite_ne_subset_induct[where S=s])"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite s\n 2. s \\<noteq> {}\n 3. s \\<subseteq> s\n 4. \\<And>x. \\<exists>m\\<in>{x}. \\<forall>z\\<in>{x}. f m \\<le> f z\n 5. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; F \\<subseteq> s; x \\<in> s;\n        x \\<notin> F;\n        \\<exists>m\\<in>F. \\<forall>z\\<in>F. f m \\<le> f z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>insert x F.\n                            \\<forall>z\\<in>insert x F. f m \\<le> f z", "apply (rule assms(1))"], ["proof (prove)\ngoal (4 subgoals):\n 1. s \\<noteq> {}\n 2. s \\<subseteq> s\n 3. \\<And>x. \\<exists>m\\<in>{x}. \\<forall>z\\<in>{x}. f m \\<le> f z\n 4. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; F \\<subseteq> s; x \\<in> s;\n        x \\<notin> F;\n        \\<exists>m\\<in>F. \\<forall>z\\<in>F. f m \\<le> f z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>insert x F.\n                            \\<forall>z\\<in>insert x F. f m \\<le> f z", "apply (rule assms(2))"], ["proof (prove)\ngoal (3 subgoals):\n 1. s \\<subseteq> s\n 2. \\<And>x. \\<exists>m\\<in>{x}. \\<forall>z\\<in>{x}. f m \\<le> f z\n 3. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; F \\<subseteq> s; x \\<in> s;\n        x \\<notin> F;\n        \\<exists>m\\<in>F. \\<forall>z\\<in>F. f m \\<le> f z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>insert x F.\n                            \\<forall>z\\<in>insert x F. f m \\<le> f z", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. \\<exists>m\\<in>{x}. \\<forall>z\\<in>{x}. f m \\<le> f z\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; F \\<subseteq> s; x \\<in> s;\n        x \\<notin> F;\n        \\<exists>m\\<in>F. \\<forall>z\\<in>F. f m \\<le> f z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>insert x F.\n                            \\<forall>z\\<in>insert x F. f m \\<le> f z", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; F \\<subseteq> s; x \\<in> s;\n        x \\<notin> F;\n        \\<exists>m\\<in>F. \\<forall>z\\<in>F. f m \\<le> f z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>insert x F.\n                            \\<forall>z\\<in>insert x F. f m \\<le> f z", "by (metis assms(3) insert_iff order_trans subsetD)"], ["", "end"], ["", "subsection \\<open>Semilattices\\<close>"], ["", "text \\<open>\nThe following are basic facts in semilattices.\n\\<close>"], ["", "context semilattice_sup\nbegin"], ["", "lemma sup_left_isotone:\n  \"x \\<le> y \\<Longrightarrow> x \\<squnion> z \\<le> y \\<squnion> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x \\<squnion> z \\<le> y \\<squnion> z", "using sup.mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>?c \\<le> ?a; ?d \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?c \\<squnion> ?d \\<le> ?a \\<squnion> ?b\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x \\<squnion> z \\<le> y \\<squnion> z", "by blast"], ["", "lemma sup_right_isotone:\n  \"x \\<le> y \\<Longrightarrow> z \\<squnion> x \\<le> z \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<squnion> x \\<le> z \\<squnion> y", "using sup.mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>?c \\<le> ?a; ?d \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?c \\<squnion> ?d \\<le> ?a \\<squnion> ?b\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<squnion> x \\<le> z \\<squnion> y", "by blast"], ["", "lemma sup_left_divisibility:\n  \"x \\<le> y \\<longleftrightarrow> (\\<exists>z . x \\<squnion> z = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (\\<exists>z. x \\<squnion> z = y)", "using sup.absorb2 sup.cobounded1"], ["proof (prove)\nusing this:\n  ?a \\<le> ?b \\<Longrightarrow> ?a \\<squnion> ?b = ?b\n  ?a \\<le> ?a \\<squnion> ?b\n\ngoal (1 subgoal):\n 1. (x \\<le> y) = (\\<exists>z. x \\<squnion> z = y)", "by blast"], ["", "lemma sup_right_divisibility:\n  \"x \\<le> y \\<longleftrightarrow> (\\<exists>z . z \\<squnion> x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (\\<exists>z. z \\<squnion> x = y)", "by (metis sup.cobounded2 sup.orderE)"], ["", "lemma sup_same_context:\n  \"x \\<le> y \\<squnion> z \\<Longrightarrow> y \\<le> x \\<squnion> z \\<Longrightarrow> x \\<squnion> z = y \\<squnion> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y \\<squnion> z; y \\<le> x \\<squnion> z\\<rbrakk>\n    \\<Longrightarrow> x \\<squnion> z = y \\<squnion> z", "by (simp add: le_iff_sup sup_left_commute)"], ["", "lemma sup_relative_same_increasing:\n  \"x \\<le> y \\<Longrightarrow> x \\<squnion> z = x \\<squnion> w \\<Longrightarrow> y \\<squnion> z = y \\<squnion> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; x \\<squnion> z = x \\<squnion> w\\<rbrakk>\n    \\<Longrightarrow> y \\<squnion> z = y \\<squnion> w", "using sup.assoc sup_right_divisibility"], ["proof (prove)\nusing this:\n  ?a \\<squnion> ?b \\<squnion> ?c = ?a \\<squnion> (?b \\<squnion> ?c)\n  (?x \\<le> ?y) = (\\<exists>z. z \\<squnion> ?x = ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; x \\<squnion> z = x \\<squnion> w\\<rbrakk>\n    \\<Longrightarrow> y \\<squnion> z = y \\<squnion> w", "by auto"], ["", "end"], ["", "text \\<open>\nEvery bounded semilattice is a commutative monoid.\nFinite sums defined in commutative monoids are available via the following sublocale.\n\\<close>"], ["", "context bounded_semilattice_sup_bot\nbegin"], ["", "sublocale sup_monoid: comm_monoid_add where plus = sup and zero = bot"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.comm_monoid_add (\\<squnion>) bot", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c. a \\<squnion> b \\<squnion> c = a \\<squnion> (b \\<squnion> c)\n 2. \\<And>a b. a \\<squnion> b = b \\<squnion> a\n 3. \\<And>a. bot \\<squnion> a = a", "apply (simp add: sup_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b. a \\<squnion> b = b \\<squnion> a\n 2. \\<And>a. bot \\<squnion> a = a", "apply (simp add: sup_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. bot \\<squnion> a = a", "by simp"], ["", "end"], ["", "context semilattice_inf\nbegin"], ["", "lemma inf_same_context:\n  \"x \\<le> y \\<sqinter> z \\<Longrightarrow> y \\<le> x \\<sqinter> z \\<Longrightarrow> x \\<sqinter> z = y \\<sqinter> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y \\<sqinter> z; y \\<le> x \\<sqinter> z\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> z = y \\<sqinter> z", "using antisym"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y \\<sqinter> z; y \\<le> x \\<sqinter> z\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> z = y \\<sqinter> z", "by auto"], ["", "end"], ["", "text \\<open>\nThe following class requires only the existence of upper bounds, which is a property common to bounded semilattices and (not necessarily bounded) lattices.\nWe use it in our development of filters.\n\\<close>"], ["", "class directed_semilattice_inf = semilattice_inf +\n  assumes ub: \"\\<exists>z . x \\<le> z \\<and> y \\<le> z\""], ["", "text \\<open>\nWe extend the \\<open>inf\\<close> sublocale, which dualises the order in semilattices, to bounded semilattices.\n\\<close>"], ["", "context bounded_semilattice_inf_top\nbegin"], ["", "subclass directed_semilattice_inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.directed_semilattice_inf (\\<sqinter>) (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. \\<exists>z\\<ge>x. y \\<le> z", "using top_greatest"], ["proof (prove)\nusing this:\n  ?a \\<le> top\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<exists>z\\<ge>x. y \\<le> z", "by blast"], ["", "sublocale inf: bounded_semilattice_sup_bot where sup = inf and less_eq = greater_eq and less = greater and bot = top"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_semilattice_sup_bot (\\<sqinter>) (\\<lambda>x y. y \\<le> x)\n     (\\<lambda>x y. y < x) top", "by unfold_locales (simp_all add: less_le_not_le)"], ["", "end"], ["", "subsection \\<open>Lattices\\<close>"], ["", "context lattice\nbegin"], ["", "subclass directed_semilattice_inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.directed_semilattice_inf (\\<sqinter>) (\\<le>) (<)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. \\<exists>z\\<ge>x. y \\<le> z", "using sup_ge1 sup_ge2"], ["proof (prove)\nusing this:\n  ?x \\<le> ?x \\<squnion> ?y\n  ?y \\<le> ?x \\<squnion> ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y. \\<exists>z\\<ge>x. y \\<le> z", "by blast"], ["", "definition dual_additive :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"dual_additive f \\<equiv> \\<forall>x y . f (x \\<squnion> y) = f x \\<sqinter> f y\""], ["", "end"], ["", "text \\<open>\nNot every bounded lattice has complements, but two elements might still be complements of each other as captured in the following definition.\nIn this situation we can apply, for example, the shunting property shown below.\nWe introduce most definitions using the \\<open>abbreviation\\<close> command.\n\\<close>"], ["", "context bounded_lattice\nbegin"], ["", "abbreviation \"complement x y \\<equiv> x \\<squnion> y = top \\<and> x \\<sqinter> y = bot\""], ["", "lemma complement_symmetric:\n  \"complement x y \\<Longrightarrow> complement y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complement x y \\<Longrightarrow> complement y x", "by (simp add: inf.commute sup.commute)"], ["", "definition conjugate :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> ('a \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"conjugate f g \\<equiv> \\<forall>x y . f x \\<sqinter> y = bot \\<longleftrightarrow> x \\<sqinter> g y = bot\""], ["", "end"], ["", "class dense_lattice = bounded_lattice +\n  assumes bot_meet_irreducible: \"x \\<sqinter> y = bot \\<longrightarrow> x = bot \\<or> y = bot\""], ["", "context distrib_lattice\nbegin"], ["", "lemma relative_equality:\n  \"x \\<squnion> z = y \\<squnion> z \\<Longrightarrow> x \\<sqinter> z = y \\<sqinter> z \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<squnion> z = y \\<squnion> z;\n     x \\<sqinter> z = y \\<sqinter> z\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (metis inf.commute inf_sup_absorb inf_sup_distrib2)"], ["", "end"], ["", "text \\<open>\nDistributive lattices with a greatest element are widely used in the construction theorem for Stone algebras.\n\\<close>"], ["", "class distrib_lattice_bot = bounded_lattice_bot + distrib_lattice"], ["", "class distrib_lattice_top = bounded_lattice_top + distrib_lattice"], ["", "class bounded_distrib_lattice = bounded_lattice + distrib_lattice\nbegin"], ["", "subclass distrib_lattice_bot"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.distrib_lattice_bot (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot", ".."], ["", "subclass distrib_lattice_top"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.distrib_lattice_top (\\<sqinter>) (\\<le>) (<) (\\<squnion>) top", ".."], ["", "lemma complement_shunting:\n  assumes \"complement z w\"\n    shows \"z \\<sqinter> x \\<le> y \\<longleftrightarrow> x \\<le> w \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<sqinter> x \\<le> y) = (x \\<le> w \\<squnion> y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z \\<sqinter> x \\<le> y \\<Longrightarrow> x \\<le> w \\<squnion> y\n 2. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "assume 1: \"z \\<sqinter> x \\<le> y\""], ["proof (state)\nthis:\n  z \\<sqinter> x \\<le> y\n\ngoal (2 subgoals):\n 1. z \\<sqinter> x \\<le> y \\<Longrightarrow> x \\<le> w \\<squnion> y\n 2. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "have \"x = (z \\<squnion> w) \\<sqinter> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (z \\<squnion> w) \\<sqinter> x", "by (simp add: assms)"], ["proof (state)\nthis:\n  x = (z \\<squnion> w) \\<sqinter> x\n\ngoal (2 subgoals):\n 1. z \\<sqinter> x \\<le> y \\<Longrightarrow> x \\<le> w \\<squnion> y\n 2. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "also"], ["proof (state)\nthis:\n  x = (z \\<squnion> w) \\<sqinter> x\n\ngoal (2 subgoals):\n 1. z \\<sqinter> x \\<le> y \\<Longrightarrow> x \\<le> w \\<squnion> y\n 2. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "have \"... \\<le> y \\<squnion> (w \\<sqinter> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<squnion> w) \\<sqinter> x \\<le> y \\<squnion> w \\<sqinter> x", "using 1 sup.commute sup.left_commute inf_sup_distrib2 sup_right_divisibility"], ["proof (prove)\nusing this:\n  z \\<sqinter> x \\<le> y\n  ?a \\<squnion> ?b = ?b \\<squnion> ?a\n  ?b \\<squnion> (?a \\<squnion> ?c) = ?a \\<squnion> (?b \\<squnion> ?c)\n  (?y \\<squnion> ?z) \\<sqinter> ?x =\n  ?y \\<sqinter> ?x \\<squnion> ?z \\<sqinter> ?x\n  (?x \\<le> ?y) = (\\<exists>z. z \\<squnion> ?x = ?y)\n\ngoal (1 subgoal):\n 1. (z \\<squnion> w) \\<sqinter> x \\<le> y \\<squnion> w \\<sqinter> x", "by fastforce"], ["proof (state)\nthis:\n  (z \\<squnion> w) \\<sqinter> x \\<le> y \\<squnion> w \\<sqinter> x\n\ngoal (2 subgoals):\n 1. z \\<sqinter> x \\<le> y \\<Longrightarrow> x \\<le> w \\<squnion> y\n 2. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "also"], ["proof (state)\nthis:\n  (z \\<squnion> w) \\<sqinter> x \\<le> y \\<squnion> w \\<sqinter> x\n\ngoal (2 subgoals):\n 1. z \\<sqinter> x \\<le> y \\<Longrightarrow> x \\<le> w \\<squnion> y\n 2. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "have \"... \\<le> w \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<squnion> w \\<sqinter> x \\<le> w \\<squnion> y", "by (simp add: inf.coboundedI1)"], ["proof (state)\nthis:\n  y \\<squnion> w \\<sqinter> x \\<le> w \\<squnion> y\n\ngoal (2 subgoals):\n 1. z \\<sqinter> x \\<le> y \\<Longrightarrow> x \\<le> w \\<squnion> y\n 2. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "finally"], ["proof (chain)\npicking this:\n  x \\<le> w \\<squnion> y", "show \"x \\<le> w \\<squnion> y\""], ["proof (prove)\nusing this:\n  x \\<le> w \\<squnion> y\n\ngoal (1 subgoal):\n 1. x \\<le> w \\<squnion> y", "."], ["proof (state)\nthis:\n  x \\<le> w \\<squnion> y\n\ngoal (1 subgoal):\n 1. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "assume \"x \\<le> w \\<squnion> y\""], ["proof (state)\nthis:\n  x \\<le> w \\<squnion> y\n\ngoal (1 subgoal):\n 1. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "hence \"z \\<sqinter> x \\<le> z \\<sqinter> (w \\<squnion> y)\""], ["proof (prove)\nusing this:\n  x \\<le> w \\<squnion> y\n\ngoal (1 subgoal):\n 1. z \\<sqinter> x \\<le> z \\<sqinter> (w \\<squnion> y)", "using inf.sup_right_isotone"], ["proof (prove)\nusing this:\n  x \\<le> w \\<squnion> y\n  ?y \\<le> ?x \\<Longrightarrow> ?z \\<sqinter> ?y \\<le> ?z \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. z \\<sqinter> x \\<le> z \\<sqinter> (w \\<squnion> y)", "by auto"], ["proof (state)\nthis:\n  z \\<sqinter> x \\<le> z \\<sqinter> (w \\<squnion> y)\n\ngoal (1 subgoal):\n 1. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "also"], ["proof (state)\nthis:\n  z \\<sqinter> x \\<le> z \\<sqinter> (w \\<squnion> y)\n\ngoal (1 subgoal):\n 1. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "have \"... = z \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<sqinter> (w \\<squnion> y) = z \\<sqinter> y", "by (simp add: assms inf_sup_distrib1)"], ["proof (state)\nthis:\n  z \\<sqinter> (w \\<squnion> y) = z \\<sqinter> y\n\ngoal (1 subgoal):\n 1. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "also"], ["proof (state)\nthis:\n  z \\<sqinter> (w \\<squnion> y) = z \\<sqinter> y\n\ngoal (1 subgoal):\n 1. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "have \"... \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<sqinter> y \\<le> y", "by simp"], ["proof (state)\nthis:\n  z \\<sqinter> y \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> w \\<squnion> y \\<Longrightarrow> z \\<sqinter> x \\<le> y", "finally"], ["proof (chain)\npicking this:\n  z \\<sqinter> x \\<le> y", "show \"z \\<sqinter> x \\<le> y\""], ["proof (prove)\nusing this:\n  z \\<sqinter> x \\<le> y\n\ngoal (1 subgoal):\n 1. z \\<sqinter> x \\<le> y", "."], ["proof (state)\nthis:\n  z \\<sqinter> x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Linear Orders\\<close>"], ["", "text \\<open>\nWe next consider lattices with a linear order structure.\nIn such lattices, join and meet are selective operations, which give the maximum and the minimum of two elements, respectively.\nMoreover, the lattice is automatically distributive.\n\\<close>"], ["", "class bounded_linorder = linorder + order_bot + order_top"], ["", "class linear_lattice = lattice + linorder\nbegin"], ["", "lemma max_sup:\n  \"max x y = x \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max x y = x \\<squnion> y", "by (metis max.boundedI max.cobounded1 max.cobounded2 sup_unique)"], ["", "lemma min_inf:\n  \"min x y = x \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min x y = x \\<sqinter> y", "by (simp add: inf.absorb1 inf.absorb2 min_def)"], ["", "lemma sup_inf_selective:\n  \"(x \\<squnion> y = x \\<and> x \\<sqinter> y = y) \\<or> (x \\<squnion> y = y \\<and> x \\<sqinter> y = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y = x \\<and> x \\<sqinter> y = y \\<or>\n    x \\<squnion> y = y \\<and> x \\<sqinter> y = x", "by (meson inf.absorb1 inf.absorb2 le_cases sup.absorb1 sup.absorb2)"], ["", "lemma sup_selective:\n  \"x \\<squnion> y = x \\<or> x \\<squnion> y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y = x \\<or> x \\<squnion> y = y", "using sup_inf_selective"], ["proof (prove)\nusing this:\n  ?x \\<squnion> ?y = ?x \\<and> ?x \\<sqinter> ?y = ?y \\<or>\n  ?x \\<squnion> ?y = ?y \\<and> ?x \\<sqinter> ?y = ?x\n\ngoal (1 subgoal):\n 1. x \\<squnion> y = x \\<or> x \\<squnion> y = y", "by blast"], ["", "lemma inf_selective:\n  \"x \\<sqinter> y = x \\<or> x \\<sqinter> y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y = x \\<or> x \\<sqinter> y = y", "using sup_inf_selective"], ["proof (prove)\nusing this:\n  ?x \\<squnion> ?y = ?x \\<and> ?x \\<sqinter> ?y = ?y \\<or>\n  ?x \\<squnion> ?y = ?y \\<and> ?x \\<sqinter> ?y = ?x\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y = x \\<or> x \\<sqinter> y = y", "by blast"], ["", "subclass distrib_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "by (metis inf_selective antisym distrib_sup_le inf.commute inf_le2)"], ["", "lemma sup_less_eq:\n  \"x \\<le> y \\<squnion> z \\<longleftrightarrow> x \\<le> y \\<or> x \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y \\<squnion> z) = (x \\<le> y \\<or> x \\<le> z)", "by (metis le_supI1 le_supI2 sup_selective)"], ["", "lemma inf_less_eq:\n  \"x \\<sqinter> y \\<le> z \\<longleftrightarrow> x \\<le> z \\<or> y \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y \\<le> z) = (x \\<le> z \\<or> y \\<le> z)", "by (metis inf.coboundedI1 inf.coboundedI2 inf_selective)"], ["", "lemma sup_inf_sup:\n  \"x \\<squnion> y = (x \\<squnion> y) \\<squnion> (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y = x \\<squnion> y \\<squnion> x \\<sqinter> y", "by (metis sup_commute sup_inf_absorb sup_left_commute)"], ["", "end"], ["", "text \\<open>\nThe following class derives additional properties if the linear order of the lattice has a least and a greatest element.\n\\<close>"], ["", "class linear_bounded_lattice = bounded_lattice + linorder\nbegin"], ["", "subclass linear_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linear_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", ".."], ["", "subclass bounded_linorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_linorder (\\<le>) (<) bot top", ".."], ["", "subclass bounded_distrib_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot\n     top", ".."], ["", "lemma sup_dense:\n  \"x \\<noteq> top \\<Longrightarrow> y \\<noteq> top \\<Longrightarrow> x \\<squnion> y \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> top; y \\<noteq> top\\<rbrakk>\n    \\<Longrightarrow> x \\<squnion> y \\<noteq> top", "by (metis sup_selective)"], ["", "lemma inf_dense:\n  \"x \\<noteq> bot \\<Longrightarrow> y \\<noteq> bot \\<Longrightarrow> x \\<sqinter> y \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> bot; y \\<noteq> bot\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<noteq> bot", "by (metis inf_selective)"], ["", "lemma sup_not_bot:\n  \"x \\<noteq> bot \\<Longrightarrow> x \\<squnion> y \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> bot \\<Longrightarrow> x \\<squnion> y \\<noteq> bot", "by simp"], ["", "lemma inf_not_top:\n  \"x \\<noteq> top \\<Longrightarrow> x \\<sqinter> y \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> top \\<Longrightarrow> x \\<sqinter> y \\<noteq> top", "by simp"], ["", "subclass dense_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.dense_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot top", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<sqinter> y = bot \\<longrightarrow> x = bot \\<or> y = bot", "using inf_dense"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<noteq> bot; ?y \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> ?x \\<sqinter> ?y \\<noteq> bot\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<sqinter> y = bot \\<longrightarrow> x = bot \\<or> y = bot", "by blast"], ["", "end"], ["", "text \\<open>\nEvery bounded linear order can be expanded to a bounded lattice.\nJoin and meet are maximum and minimum, respectively.\n\\<close>"], ["", "class linorder_lattice_expansion = bounded_linorder + sup + inf +\n  assumes sup_def [simp]: \"x \\<squnion> y = max x y\"\n  assumes inf_def [simp]: \"x \\<sqinter> y = min x y\"\nbegin"], ["", "subclass linear_bounded_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linear_bounded_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot\n     top", "apply unfold_locales"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "by auto"], ["", "end"], ["", "subsection \\<open>Non-trivial Algebras\\<close>"], ["", "text \\<open>\nSome results, such as the existence of certain filters, require that the algebras are not trivial.\nThis is not an assumption of the order and lattice classes that come with Isabelle/HOL; for example, \\<open>bot = top\\<close> may hold in bounded lattices.\n\\<close>"], ["", "class non_trivial =\n  assumes consistent: \"\\<exists>x y . x \\<noteq> y\""], ["", "class non_trivial_order = non_trivial + order"], ["", "class non_trivial_order_bot = non_trivial_order + order_bot"], ["", "class non_trivial_bounded_order = non_trivial_order_bot + order_top\nbegin"], ["", "lemma bot_not_top:\n  \"bot \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot \\<noteq> top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bot \\<noteq> top", "from consistent"], ["proof (chain)\npicking this:\n  \\<exists>x y. x \\<noteq> y", "obtain x y :: 'a where \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  \\<exists>x y. x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (\\<And>x y. x \\<noteq> y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. bot \\<noteq> top", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. bot \\<noteq> top", "by (metis bot_less top.extremum_strict)"], ["proof (state)\nthis:\n  bot \\<noteq> top\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Homomorphisms\\<close>"], ["", "text \\<open>\nThis section gives definitions of lattice homomorphisms and isomorphisms and basic properties.\n\\<close>"], ["", "class sup_inf_top_bot_uminus = sup + inf + top + bot + uminus"], ["", "class sup_inf_top_bot_uminus_ord = sup_inf_top_bot_uminus + ord"], ["", "context boolean_algebra\nbegin"], ["", "subclass sup_inf_top_bot_uminus_ord"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "abbreviation sup_homomorphism :: \"('a::sup \\<Rightarrow> 'b::sup) \\<Rightarrow> bool\"\n  where \"sup_homomorphism f \\<equiv> \\<forall>x y . f (x \\<squnion> y) = f x \\<squnion> f y\""], ["", "abbreviation inf_homomorphism :: \"('a::inf \\<Rightarrow> 'b::inf) \\<Rightarrow> bool\"\n  where \"inf_homomorphism f \\<equiv> \\<forall>x y . f (x \\<sqinter> y) = f x \\<sqinter> f y\""], ["", "abbreviation bot_homomorphism :: \"('a::bot \\<Rightarrow> 'b::bot) \\<Rightarrow> bool\"\n  where \"bot_homomorphism f \\<equiv> f bot = bot\""], ["", "abbreviation top_homomorphism :: \"('a::top \\<Rightarrow> 'b::top) \\<Rightarrow> bool\"\n  where \"top_homomorphism f \\<equiv> f top = top\""], ["", "abbreviation minus_homomorphism :: \"('a::minus \\<Rightarrow> 'b::minus) \\<Rightarrow> bool\"\n  where \"minus_homomorphism f \\<equiv> \\<forall>x y . f (x - y) = f x - f y\""], ["", "abbreviation uminus_homomorphism :: \"('a::uminus \\<Rightarrow> 'b::uminus) \\<Rightarrow> bool\"\n  where \"uminus_homomorphism f \\<equiv> \\<forall>x . f (-x) = -f x\""], ["", "abbreviation sup_inf_homomorphism :: \"('a::{sup,inf} \\<Rightarrow> 'b::{sup,inf}) \\<Rightarrow> bool\"\n  where \"sup_inf_homomorphism f \\<equiv> sup_homomorphism f \\<and> inf_homomorphism f\""], ["", "abbreviation sup_inf_top_homomorphism :: \"('a::{sup,inf,top} \\<Rightarrow> 'b::{sup,inf,top}) \\<Rightarrow> bool\"\n  where \"sup_inf_top_homomorphism f \\<equiv> sup_inf_homomorphism f \\<and> top_homomorphism f\""], ["", "abbreviation sup_inf_top_bot_homomorphism :: \"('a::{sup,inf,top,bot} \\<Rightarrow> 'b::{sup,inf,top,bot}) \\<Rightarrow> bool\"\n  where \"sup_inf_top_bot_homomorphism f \\<equiv> sup_inf_top_homomorphism f \\<and> bot_homomorphism f\""], ["", "abbreviation bounded_lattice_homomorphism :: \"('a::bounded_lattice \\<Rightarrow> 'b::bounded_lattice) \\<Rightarrow> bool\"\n  where \"bounded_lattice_homomorphism f \\<equiv> sup_inf_top_bot_homomorphism f\""], ["", "abbreviation sup_inf_top_bot_uminus_homomorphism :: \"('a::sup_inf_top_bot_uminus \\<Rightarrow> 'b::sup_inf_top_bot_uminus) \\<Rightarrow> bool\"\n  where \"sup_inf_top_bot_uminus_homomorphism f \\<equiv> sup_inf_top_bot_homomorphism f \\<and> uminus_homomorphism f\""], ["", "abbreviation sup_inf_top_bot_uminus_ord_homomorphism :: \"('a::sup_inf_top_bot_uminus_ord \\<Rightarrow> 'b::sup_inf_top_bot_uminus_ord) \\<Rightarrow> bool\"\n  where \"sup_inf_top_bot_uminus_ord_homomorphism f \\<equiv> sup_inf_top_bot_uminus_homomorphism f \\<and> (\\<forall>x y . x \\<le> y \\<longrightarrow> f x \\<le> f y)\""], ["", "abbreviation sup_inf_top_isomorphism :: \"('a::{sup,inf,top} \\<Rightarrow> 'b::{sup,inf,top}) \\<Rightarrow> bool\"\n  where \"sup_inf_top_isomorphism f \\<equiv> sup_inf_top_homomorphism f \\<and> bij f\""], ["", "abbreviation bounded_lattice_top_isomorphism :: \"('a::bounded_lattice_top \\<Rightarrow> 'b::bounded_lattice_top) \\<Rightarrow> bool\"\n  where \"bounded_lattice_top_isomorphism f \\<equiv> sup_inf_top_isomorphism f\""], ["", "abbreviation sup_inf_top_bot_uminus_isomorphism :: \"('a::sup_inf_top_bot_uminus \\<Rightarrow> 'b::sup_inf_top_bot_uminus) \\<Rightarrow> bool\"\n  where \"sup_inf_top_bot_uminus_isomorphism f \\<equiv> sup_inf_top_bot_uminus_homomorphism f \\<and> bij f\""], ["", "abbreviation boolean_algebra_isomorphism :: \"('a::boolean_algebra \\<Rightarrow> 'b::boolean_algebra) \\<Rightarrow> bool\"\n  where \"boolean_algebra_isomorphism f \\<equiv> sup_inf_top_bot_uminus_isomorphism f \\<and> minus_homomorphism f\""], ["", "lemma sup_homomorphism_mono:\n  \"sup_homomorphism (f::'a::semilattice_sup \\<Rightarrow> 'b::semilattice_sup) \\<Longrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_homomorphism f \\<Longrightarrow> mono f", "by (metis le_iff_sup monoI)"], ["", "lemma sup_isomorphism_ord_isomorphism:\n  assumes \"sup_homomorphism (f::'a::semilattice_sup \\<Rightarrow> 'b::semilattice_sup)\"\n      and \"bij f\"\n    shows \"x \\<le> y \\<longleftrightarrow> f x \\<le> f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (f x \\<le> f y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> f x \\<le> f y\n 2. f x \\<le> f y \\<Longrightarrow> x \\<le> y", "assume \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> f x \\<le> f y\n 2. f x \\<le> f y \\<Longrightarrow> x \\<le> y", "thus \"f x \\<le> f y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. f x \\<le> f y", "by (metis assms(1) le_iff_sup)"], ["proof (state)\nthis:\n  f x \\<le> f y\n\ngoal (1 subgoal):\n 1. f x \\<le> f y \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f x \\<le> f y \\<Longrightarrow> x \\<le> y", "assume \"f x \\<le> f y\""], ["proof (state)\nthis:\n  f x \\<le> f y\n\ngoal (1 subgoal):\n 1. f x \\<le> f y \\<Longrightarrow> x \\<le> y", "hence \"f (x \\<squnion> y) = f y\""], ["proof (prove)\nusing this:\n  f x \\<le> f y\n\ngoal (1 subgoal):\n 1. f (x \\<squnion> y) = f y", "by (simp add: assms(1) le_iff_sup)"], ["proof (state)\nthis:\n  f (x \\<squnion> y) = f y\n\ngoal (1 subgoal):\n 1. f x \\<le> f y \\<Longrightarrow> x \\<le> y", "hence \"x \\<squnion> y = y\""], ["proof (prove)\nusing this:\n  f (x \\<squnion> y) = f y\n\ngoal (1 subgoal):\n 1. x \\<squnion> y = y", "by (metis injD bij_is_inj assms(2))"], ["proof (state)\nthis:\n  x \\<squnion> y = y\n\ngoal (1 subgoal):\n 1. f x \\<le> f y \\<Longrightarrow> x \\<le> y", "thus \"x \\<le> y\""], ["proof (prove)\nusing this:\n  x \\<squnion> y = y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by (simp add: le_iff_sup)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minus_homomorphism_default:\n  assumes \"\\<forall>x y::'a::{inf,minus,uminus} . x - y = x \\<sqinter> -y\"\n      and \"\\<forall>x y::'b::{inf,minus,uminus} . x - y = x \\<sqinter> -y\"\n      and \"inf_homomorphism (f::'a \\<Rightarrow> 'b)\"\n      and \"uminus_homomorphism f\"\n    shows \"minus_homomorphism f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minus_homomorphism f", "by (simp add: assms)"], ["", "end"]]}