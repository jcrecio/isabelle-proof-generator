{"file_name": "/home/qj213/afp-2021-10-22/thys/Stone_Algebras/P_Algebras.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stone_Algebras", "problem_names": ["lemma p_bot [simp]:\n  \"-bot = top\"", "lemma p_top [simp]:\n  \"-top = bot\"", "lemma inf_p [simp]:\n  \"x \\<sqinter> -x = bot\"", "lemma p_inf [simp]:\n  \"-x \\<sqinter> x = bot\"", "lemma pp_inf_p:\n  \"--x \\<sqinter> -x = bot\"", "lemma pp_increasing:\n  \"x \\<le> --x\"", "lemma ppp [simp]:\n  \"---x = -x\"", "lemma pp_idempotent:\n  \"----x = --x\"", "lemma regular_in_p_image_iff:\n  \"regular x \\<longleftrightarrow> in_p_image x\"", "lemma pseudo_complement_pp:\n  \"x \\<sqinter> y = bot \\<longleftrightarrow> --x \\<le> -y\"", "lemma p_antitone:\n  \"x \\<le> y \\<Longrightarrow> -y \\<le> -x\"", "lemma p_antitone_sup:\n  \"-(x \\<squnion> y) \\<le> -x\"", "lemma p_antitone_inf:\n  \"-x \\<le> -(x \\<sqinter> y)\"", "lemma p_antitone_iff:\n  \"x \\<le> -y \\<longleftrightarrow> y \\<le> -x\"", "lemma pp_isotone:\n  \"x \\<le> y \\<Longrightarrow> --x \\<le> --y\"", "lemma pp_isotone_sup:\n  \"--x \\<le> --(x \\<squnion> y)\"", "lemma pp_isotone_inf:\n  \"--(x \\<sqinter> y) \\<le> --x\"", "lemma p_dist_sup [simp]:\n  \"-(x \\<squnion> y) = -x \\<sqinter> -y\"", "lemma p_supdist_inf:\n  \"-x \\<squnion> -y \\<le> -(x \\<sqinter> y)\"", "lemma pp_dist_pp_sup [simp]:\n  \"--(--x \\<squnion> --y) = --(x \\<squnion> y)\"", "lemma p_sup_p [simp]:\n  \"-(x \\<squnion> -x) = bot\"", "lemma pp_sup_p [simp]:\n  \"--(x \\<squnion> -x) = top\"", "lemma dense_pp:\n  \"dense x \\<longleftrightarrow> --x = top\"", "lemma dense_sup_p:\n  \"dense (x \\<squnion> -x)\"", "lemma regular_char:\n  \"regular x \\<longleftrightarrow> (\\<exists>y . x = -y)\"", "lemma pp_inf_bot_iff:\n  \"x \\<sqinter> y = bot \\<longleftrightarrow> --x \\<sqinter> y = bot\"", "lemma p_shunting_swap:\n  \"x \\<sqinter> y \\<le> -z \\<longleftrightarrow> x \\<sqinter> z \\<le> -y\"", "lemma pp_inf_below_iff:\n  \"x \\<sqinter> y \\<le> -z \\<longleftrightarrow> --x \\<sqinter> y \\<le> -z\"", "lemma p_inf_pp [simp]:\n  \"-(x \\<sqinter> --y) = -(x \\<sqinter> y)\"", "lemma p_inf_pp_pp [simp]:\n  \"-(--x \\<sqinter> --y) = -(x \\<sqinter> y)\"", "lemma regular_closed_inf:\n  \"regular x \\<Longrightarrow> regular y \\<Longrightarrow> regular (x \\<sqinter> y)\"", "lemma regular_closed_p:\n  \"regular (-x)\"", "lemma regular_closed_pp:\n  \"regular (--x)\"", "lemma regular_closed_bot:\n  \"regular bot\"", "lemma regular_closed_top:\n  \"regular top\"", "lemma pp_dist_inf [simp]:\n  \"--(x \\<sqinter> y) = --x \\<sqinter> --y\"", "lemma inf_import_p [simp]:\n  \"x \\<sqinter> -(x \\<sqinter> y) = x \\<sqinter> -y\"", "lemma p_unique:\n  \"(\\<forall>x . x \\<sqinter> y = bot \\<longleftrightarrow> x \\<le> z) \\<Longrightarrow> z = -y\"", "lemma maddux_3_5:\n  \"x \\<squnion> x = x \\<squnion> -(y \\<squnion> -y)\"", "lemma shunting_1_pp:\n  \"x \\<le> --y \\<longleftrightarrow> x \\<sqinter> -y = bot\"", "lemma pp_pp_inf_bot_iff:\n  \"x \\<sqinter> y = bot \\<longleftrightarrow> --x \\<sqinter> --y = bot\"", "lemma inf_pp_semi_commute:\n  \"x \\<sqinter> --y \\<le> --(x \\<sqinter> y)\"", "lemma inf_pp_commute:\n  \"--(--x \\<sqinter> y) = --x \\<sqinter> --y\"", "lemma sup_pp_semi_commute:\n  \"x \\<squnion> --y \\<le> --(x \\<squnion> y)\"", "lemma regular_sup:\n  \"regular z \\<Longrightarrow> (x \\<le> z \\<and> y \\<le> z \\<longleftrightarrow> --(x \\<squnion> y) \\<le> z)\"", "lemma dense_closed_inf:\n  \"dense x \\<Longrightarrow> dense y \\<Longrightarrow> dense (x \\<sqinter> y)\"", "lemma dense_closed_sup:\n  \"dense x \\<Longrightarrow> dense y \\<Longrightarrow> dense (x \\<squnion> y)\"", "lemma dense_closed_pp:\n  \"dense x \\<Longrightarrow> dense (--x)\"", "lemma dense_closed_top:\n  \"dense top\"", "lemma dense_up_closed:\n  \"dense x \\<Longrightarrow> x \\<le> y \\<Longrightarrow> dense y\"", "lemma regular_dense_top:\n  \"regular x \\<Longrightarrow> dense x \\<Longrightarrow> x = top\"", "lemma selection_char:\n  \"selection s x \\<longleftrightarrow> (\\<exists>y . s = -y \\<sqinter> x)\"", "lemma selection_closed_inf:\n  \"selection s x \\<Longrightarrow> selection t x \\<Longrightarrow> selection (s \\<sqinter> t) x\"", "lemma selection_closed_pp:\n  \"regular x \\<Longrightarrow> selection s x \\<Longrightarrow> selection (--s) x\"", "lemma selection_closed_bot:\n  \"selection bot x\"", "lemma selection_closed_id:\n  \"selection x x\"", "lemma conjugate_unique_p:\n  assumes \"conjugate f g\"\n      and \"conjugate f h\"\n    shows \"uminus \\<circ> g = uminus \\<circ> h\"", "lemma conjugate_symmetric:\n  \"conjugate f g \\<Longrightarrow> conjugate g f\"", "lemma additive_isotone:\n  \"additive f \\<Longrightarrow> isotone f\"", "lemma dual_additive_antitone:\n  assumes \"dual_additive f\"\n    shows \"isotone (uminus \\<circ> f)\"", "lemma conjugate_dual_additive:\n  assumes \"conjugate f g\"\n    shows \"dual_additive (uminus \\<circ> f)\"", "lemma conjugate_isotone_pp:\n  \"conjugate f g \\<Longrightarrow> isotone (uminus \\<circ> uminus \\<circ> f)\"", "lemma conjugate_char_1_pp:\n  \"conjugate f g \\<longleftrightarrow> (\\<forall>x y . f(x \\<sqinter> -(g y)) \\<le> --f x \\<sqinter> -y \\<and> g(y \\<sqinter> -(f x)) \\<le> --g y \\<sqinter> -x)\"", "lemma conjugate_char_1_isotone:\n  \"conjugate f g \\<Longrightarrow> isotone f \\<Longrightarrow> isotone g \\<Longrightarrow> f(x \\<sqinter> -(g y)) \\<le> f x \\<sqinter> -y \\<and> g(y \\<sqinter> -(f x)) \\<le> g y \\<sqinter> -x\"", "lemma dense_lattice_char_1:\n  \"(\\<forall>x y . x \\<sqinter> y = bot \\<longrightarrow> x = bot \\<or> y = bot) \\<longleftrightarrow> (\\<forall>x . x \\<noteq> bot \\<longrightarrow> dense x)\"", "lemma dense_lattice_char_2:\n  \"(\\<forall>x y . x \\<sqinter> y = bot \\<longrightarrow> x = bot \\<or> y = bot) \\<longleftrightarrow> (\\<forall>x . regular x \\<longrightarrow> x = bot \\<or> x = top)\"", "lemma restrict_below_Rep_eq:\n  \"x \\<sqinter> --y \\<le> z \\<Longrightarrow> x \\<sqinter> y = x \\<sqinter> z \\<sqinter> y\"", "lemma inf_p_eq:\n  \"x \\<sqinter> -x = bot\"", "lemma p_inf_sup_below:\n  \"-x \\<sqinter> (x \\<squnion> y) \\<le> y\"", "lemma pp_inf_sup_p [simp]:\n  \"--x \\<sqinter> (x \\<squnion> -x) = x\"", "lemma complement_p:\n  \"x \\<sqinter> y = bot \\<Longrightarrow> x \\<squnion> y = top \\<Longrightarrow> -x = y\"", "lemma complemented_regular:\n  \"complemented x \\<Longrightarrow> regular x\"", "lemma regular_inf_dense:\n  \"\\<exists>y z . regular y \\<and> dense z \\<and> x = y \\<sqinter> z\"", "lemma maddux_3_12 [simp]:\n  \"(x \\<squnion> -y) \\<sqinter> (x \\<squnion> y) = x\"", "lemma maddux_3_13 [simp]:\n  \"(x \\<squnion> y) \\<sqinter> -x = y \\<sqinter> -x\"", "lemma maddux_3_20:\n  \"((v \\<sqinter> w) \\<squnion> (-v \\<sqinter> x)) \\<sqinter> -((v \\<sqinter> y) \\<squnion> (-v \\<sqinter> z)) = (v \\<sqinter> w \\<sqinter> -y) \\<squnion> (-v \\<sqinter> x \\<sqinter> -z)\"", "lemma order_char_1:\n  \"x \\<le> y \\<longleftrightarrow> x \\<le> y \\<squnion> -x\"", "lemma order_char_2:\n  \"x \\<le> y \\<longleftrightarrow> x \\<squnion> -x \\<le> y \\<squnion> -x\"", "lemma p_dist_inf [simp]:\n  \"-(x \\<sqinter> y) = -x \\<squnion> -y\"", "lemma pp_dist_sup [simp]:\n  \"--(x \\<squnion> y) = --x \\<squnion> --y\"", "lemma regular_closed_sup:\n  \"regular x \\<Longrightarrow> regular y \\<Longrightarrow> regular (x \\<squnion> y)\"", "lemma regular_complemented_iff:\n  \"regular x \\<longleftrightarrow> complemented x\"", "lemma selection_closed_sup:\n  \"selection s x \\<Longrightarrow> selection t x \\<Longrightarrow> selection (s \\<squnion> t) x\"", "lemma huntington_3_pp [simp]:\n  \"-(-x \\<squnion> -y) \\<squnion> -(-x \\<squnion> y) = --x\"", "lemma maddux_3_3 [simp]:\n  \"-(x \\<squnion> y) \\<squnion> -(x \\<squnion> -y) = -x\"", "lemma maddux_3_11_pp:\n  \"(x \\<sqinter> -y) \\<squnion> (x \\<sqinter> --y) = x\"", "lemma maddux_3_19_pp:\n  \"(-x \\<sqinter> y) \\<squnion> (--x \\<sqinter> z) = (--x \\<squnion> y) \\<sqinter> (-x \\<squnion> z)\"", "lemma compl_inter_eq_pp:\n  \"--x \\<sqinter> y = --x \\<sqinter> z \\<Longrightarrow> -x \\<sqinter> y = -x \\<sqinter> z \\<Longrightarrow> y = z\"", "lemma maddux_3_21_pp [simp]:\n  \"--x \\<squnion> (-x \\<sqinter> y) = --x \\<squnion> y\"", "lemma shunting_2_pp:\n  \"x \\<le> --y \\<longleftrightarrow> -x \\<squnion> --y = top\"", "lemma shunting_p:\n  \"x \\<sqinter> y \\<le> -z \\<longleftrightarrow> x \\<le> -z \\<squnion> -y\"", "lemma shunting_var_p:\n  \"x \\<sqinter> -y \\<le> z \\<longleftrightarrow> x \\<le> z \\<squnion> --y\"", "lemma conjugate_char_2_pp:\n  \"conjugate f g \\<longleftrightarrow> f bot = bot \\<and> g bot = bot \\<and> (\\<forall>x y . f x \\<sqinter> y \\<le> --(f(x \\<sqinter> --(g y))) \\<and> g y \\<sqinter> x \\<le> --(g(y \\<sqinter> --(f x))))\"", "lemma conjugate_char_2_pp_additive:\n  assumes \"conjugate f g\"\n      and \"additive f\"\n      and \"additive g\"\n    shows \"f x \\<sqinter> y \\<le> f(x \\<sqinter> --(g y)) \\<and> g y \\<sqinter> x \\<le> g(y \\<sqinter> --(f x))\"", "lemma regular_bot_top:\n  \"regular x \\<longleftrightarrow> x = bot \\<or> x = top\"", "lemma not_bot_dense:\n  \"x \\<noteq> bot \\<Longrightarrow> --x = top\"", "lemma implies_below_eq [simp]:\n  \"y \\<sqinter> (x \\<leadsto> y) = y\"", "lemma implies_increasing:\n  \"x \\<le> y \\<leadsto> x\"", "lemma implies_galois_swap:\n  \"x \\<le> y \\<leadsto> z \\<longleftrightarrow> y \\<le> x \\<leadsto> z\"", "lemma implies_galois_var:\n  \"x \\<sqinter> y \\<le> z \\<longleftrightarrow> y \\<le> x \\<leadsto> z\"", "lemma implies_galois_increasing:\n  \"x \\<le> y \\<leadsto> (x \\<sqinter> y)\"", "lemma implies_galois_decreasing:\n  \"(y \\<leadsto> x) \\<sqinter> y \\<le> x\"", "lemma implies_mp_below:\n  \"x \\<sqinter> (x \\<leadsto> y) \\<le> y\"", "lemma implies_isotone:\n  \"x \\<le> y \\<Longrightarrow> z \\<leadsto> x \\<le> z \\<leadsto> y\"", "lemma implies_antitone:\n  \"x \\<le> y \\<Longrightarrow> y \\<leadsto> z \\<le> x \\<leadsto> z\"", "lemma implies_isotone_inf:\n  \"x \\<leadsto> (y \\<sqinter> z) \\<le> x \\<leadsto> y\"", "lemma implies_antitone_inf:\n  \"x \\<leadsto> z \\<le> (x \\<sqinter> y) \\<leadsto> z\"", "lemma implies_curry:\n  \"x \\<leadsto> (y \\<leadsto> z) = (x \\<sqinter> y) \\<leadsto> z\"", "lemma implies_curry_flip:\n  \"x \\<leadsto> (y \\<leadsto> z) = y \\<leadsto> (x \\<leadsto> z)\"", "lemma triple_implies [simp]:\n  \"((x \\<leadsto> y) \\<leadsto> y) \\<leadsto> y = x \\<leadsto> y\"", "lemma implies_mp_eq [simp]:\n  \"x \\<sqinter> (x \\<leadsto> y) = x \\<sqinter> y\"", "lemma implies_dist_implies:\n  \"x \\<leadsto> (y \\<leadsto> z) \\<le> (x \\<leadsto> y) \\<leadsto> (x \\<leadsto> z)\"", "lemma implies_import_inf [simp]:\n  \"x \\<sqinter> ((x \\<sqinter> y) \\<leadsto> (x \\<leadsto> z)) = x \\<sqinter> (y \\<leadsto> z)\"", "lemma implies_dist_inf:\n  \"x \\<leadsto> (y \\<sqinter> z) = (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z)\"", "lemma implies_itself_top:\n  \"y \\<le> x \\<leadsto> x\"", "lemma inf_implies_top:\n  \"z \\<le> (x \\<sqinter> y) \\<leadsto> x\"", "lemma inf_inf_implies [simp]:\n  \"z \\<sqinter> ((x \\<sqinter> y) \\<leadsto> x) = z\"", "lemma le_implies_top:\n  \"x \\<le> y \\<Longrightarrow> z \\<le> x \\<leadsto> y\"", "lemma le_iff_le_implies:\n  \"x \\<le> y \\<longleftrightarrow> x \\<le> x \\<leadsto> y\"", "lemma implies_inf_isotone:\n  \"x \\<leadsto> y \\<le> (x \\<sqinter> z) \\<leadsto> (y \\<sqinter> z)\"", "lemma implies_transitive:\n  \"(x \\<leadsto> y) \\<sqinter> (y \\<leadsto> z) \\<le> x \\<leadsto> z\"", "lemma implies_inf_absorb [simp]:\n  \"x \\<leadsto> (x \\<sqinter> y) = x \\<leadsto> y\"", "lemma implies_implies_absorb [simp]:\n  \"x \\<leadsto> (x \\<leadsto> y) = x \\<leadsto> y\"", "lemma implies_inf_identity:\n  \"(x \\<leadsto> y) \\<sqinter> y = y\"", "lemma implies_itself_same:\n  \"x \\<leadsto> x = y \\<leadsto> y\"", "lemma implies_itself [simp]:\n  \"x \\<leadsto> x = top\"", "lemma implies_order:\n  \"x \\<le> y \\<longleftrightarrow> x \\<leadsto> y = top\"", "lemma inf_implies [simp]:\n  \"(x \\<sqinter> y) \\<leadsto> x = top\"", "lemma top_implies [simp]:\n  \"top \\<leadsto> x = x\"", "lemma sup_distrib_inf_le:\n  \"(x \\<squnion> y) \\<sqinter> (x \\<squnion> z) \\<le> x \\<squnion> (y \\<sqinter> z)\"", "lemma implies_isotone_sup:\n  \"x \\<leadsto> y \\<le> x \\<leadsto> (y \\<squnion> z)\"", "lemma implies_antitone_sup:\n  \"(x \\<squnion> y) \\<leadsto> z \\<le> x \\<leadsto> z\"", "lemma implies_sup:\n  \"x \\<leadsto> z \\<le> (y \\<leadsto> z) \\<leadsto> ((x \\<squnion> y) \\<leadsto> z)\"", "lemma implies_dist_sup:\n  \"(x \\<squnion> y) \\<leadsto> z = (x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z)\"", "lemma implies_antitone_isotone:\n  \"(x \\<squnion> y) \\<leadsto> (x \\<sqinter> y) \\<le> x \\<leadsto> y\"", "lemma implies_antisymmetry:\n  \"(x \\<leadsto> y) \\<sqinter> (y \\<leadsto> x) = (x \\<squnion> y) \\<leadsto> (x \\<sqinter> y)\"", "lemma sup_inf_implies [simp]:\n  \"(x \\<squnion> y) \\<sqinter> (x \\<leadsto> y) = y\"", "lemma implies_subdist_sup:\n  \"(x \\<leadsto> y) \\<squnion> (x \\<leadsto> z) \\<le> x \\<leadsto> (y \\<squnion> z)\"", "lemma implies_subdist_inf:\n  \"(x \\<leadsto> z) \\<squnion> (y \\<leadsto> z) \\<le> (x \\<sqinter> y) \\<leadsto> z\"", "lemma implies_sup_absorb:\n  \"(x \\<leadsto> y) \\<squnion> z \\<le> (x \\<squnion> z) \\<leadsto> (y \\<squnion> z)\"", "lemma sup_below_implies_implies:\n  \"x \\<squnion> y \\<le> (x \\<leadsto> y) \\<leadsto> y\"", "lemma implies_bot [simp]:\n  \"bot \\<leadsto> x = top\"", "lemma boolean_implies_below:\n  \"-x \\<squnion> y \\<le> x \\<leadsto> y\"", "lemma negation_implies:\n  \"-(x \\<leadsto> y) = --x \\<sqinter> -y\"", "lemma double_negation_dist_implies:\n  \"--(x \\<leadsto> y) = --x \\<leadsto> --y\"", "lemma curry_minus:\n  \"x - (y \\<squnion> z) = (x - y) - z\"", "lemma minus_subdist_sup:\n  \"(x - z) \\<squnion> (y - z) \\<le> (x \\<squnion> y) - z\"", "lemma inf_sup_minus:\n  \"(x \\<sqinter> y) \\<squnion> (x - y) = x\"", "lemma huntington_3 [simp]:\n  \"-(-x \\<squnion> -y) \\<squnion> -(-x \\<squnion> y) = x\"", "lemma maddux_3_1:\n  \"x \\<squnion> -x = y \\<squnion> -y\"", "lemma maddux_3_4:\n  \"x \\<squnion> (y \\<squnion> -y) = z \\<squnion> -z\"", "lemma maddux_3_11 [simp]:\n  \"(x \\<sqinter> y) \\<squnion> (x \\<sqinter> -y) = x\"", "lemma maddux_3_19:\n  \"(-x \\<sqinter> y) \\<squnion> (x \\<sqinter> z) = (x \\<squnion> y) \\<sqinter> (-x \\<squnion> z)\"", "lemma compl_inter_eq:\n  \"x \\<sqinter> y = x \\<sqinter> z \\<Longrightarrow> -x \\<sqinter> y = -x \\<sqinter> z \\<Longrightarrow> y = z\"", "lemma maddux_3_21 [simp]:\n  \"x \\<squnion> (-x \\<sqinter> y) = x \\<squnion> y\"", "lemma shunting_1:\n  \"x \\<le> y \\<longleftrightarrow> x \\<sqinter> -y = bot\"", "lemma uminus_involutive:\n  \"uminus \\<circ> uminus = id\"", "lemma uminus_injective:\n  \"uminus \\<circ> f = uminus \\<circ> g \\<Longrightarrow> f = g\"", "lemma conjugate_unique:\n  \"conjugate f g \\<Longrightarrow> conjugate f h \\<Longrightarrow> g = h\"", "lemma dual_additive_additive:\n  \"dual_additive (uminus \\<circ> f) \\<Longrightarrow> additive f\"", "lemma conjugate_additive:\n  \"conjugate f g \\<Longrightarrow> additive f\"", "lemma conjugate_isotone:\n  \"conjugate f g \\<Longrightarrow> isotone f\"", "lemma conjugate_char_1:\n  \"conjugate f g \\<longleftrightarrow> (\\<forall>x y . f(x \\<sqinter> -(g y)) \\<le> f x \\<sqinter> -y \\<and> g(y \\<sqinter> -(f x)) \\<le> g y \\<sqinter> -x)\"", "lemma conjugate_char_2:\n  \"conjugate f g \\<longleftrightarrow> f bot = bot \\<and> g bot = bot \\<and> (\\<forall>x y . f x \\<sqinter> y \\<le> f(x \\<sqinter> g y) \\<and> g y \\<sqinter> x \\<le> g(y \\<sqinter> f x))\"", "lemma shunting:\n  \"x \\<sqinter> y \\<le> z \\<longleftrightarrow> x \\<le> z \\<squnion> -y\"", "lemma shunting_var:\n  \"x \\<sqinter> -y \\<le> z \\<longleftrightarrow> x \\<le> z \\<squnion> y\""], "translations": [["", "lemma p_bot [simp]:\n  \"-bot = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - bot = top", "using inf_top.left_neutral pseudo_complement top_unique"], ["proof (prove)\nusing this:\n  top \\<sqinter> ?a = ?a\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n  (top \\<le> ?a) = (?a = top)\n\ngoal (1 subgoal):\n 1. - bot = top", "by blast"], ["", "lemma p_top [simp]:\n  \"-top = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense top", "by (metis eq_refl inf_top.comm_neutral pseudo_complement)"], ["", "text \\<open>\nThe pseudocomplement satisfies the following half of the requirements of a complement.\n\\<close>"], ["", "lemma inf_p [simp]:\n  \"x \\<sqinter> -x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - x = bot", "using inf.commute pseudo_complement"], ["proof (prove)\nusing this:\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - x = bot", "by fastforce"], ["", "lemma p_inf [simp]:\n  \"-x \\<sqinter> x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<sqinter> x = bot", "by (simp add: inf_commute)"], ["", "lemma pp_inf_p:\n  \"--x \\<sqinter> -x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x \\<sqinter> - x = bot", "by simp"], ["", "text \\<open>\nThe double complement is a closure operation.\n\\<close>"], ["", "lemma pp_increasing:\n  \"x \\<le> --x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - - x", "using inf_p pseudo_complement"], ["proof (prove)\nusing this:\n  ?x \\<sqinter> - ?x = bot\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. x \\<le> - - x", "by blast"], ["", "lemma ppp [simp]:\n  \"---x = -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - - x = - x", "by (metis antisym inf.commute order_trans pseudo_complement pp_increasing)"], ["", "lemma pp_idempotent:\n  \"----x = --x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - - - x = - - x", "by simp"], ["", "lemma regular_in_p_image_iff:\n  \"regular x \\<longleftrightarrow> in_p_image x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular x = in_p_image x", "by auto"], ["", "lemma pseudo_complement_pp:\n  \"x \\<sqinter> y = bot \\<longleftrightarrow> --x \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y = bot) = (- - x \\<le> - y)", "by (metis inf_commute pseudo_complement ppp)"], ["", "lemma p_antitone:\n  \"x \\<le> y \\<Longrightarrow> -y \\<le> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> - y \\<le> - x", "by (metis inf_commute order_trans pseudo_complement pp_increasing)"], ["", "lemma p_antitone_sup:\n  \"-(x \\<squnion> y) \\<le> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) \\<le> - x", "by (simp add: p_antitone)"], ["", "lemma p_antitone_inf:\n  \"-x \\<le> -(x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<le> - (x \\<sqinter> y)", "by (simp add: p_antitone)"], ["", "lemma p_antitone_iff:\n  \"x \\<le> -y \\<longleftrightarrow> y \\<le> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> - y) = (y \\<le> - x)", "using order_lesseq_imp p_antitone pp_increasing"], ["proof (prove)\nusing this:\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  ?x \\<le> ?y \\<Longrightarrow> - ?y \\<le> - ?x\n  ?x \\<le> - - ?x\n\ngoal (1 subgoal):\n 1. (x \\<le> - y) = (y \\<le> - x)", "by blast"], ["", "lemma pp_isotone:\n  \"x \\<le> y \\<Longrightarrow> --x \\<le> --y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> - - x \\<le> - - y", "by (simp add: p_antitone)"], ["", "lemma pp_isotone_sup:\n  \"--x \\<le> --(x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x \\<le> - - (x \\<squnion> y)", "by (simp add: p_antitone)"], ["", "lemma pp_isotone_inf:\n  \"--(x \\<sqinter> y) \\<le> --x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - (x \\<sqinter> y) \\<le> - - x", "by (simp add: p_antitone)"], ["", "text \\<open>\nOne of De Morgan's laws holds in pseudocomplemented lattices.\n\\<close>"], ["", "lemma p_dist_sup [simp]:\n  \"-(x \\<squnion> y) = -x \\<sqinter> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) = - x \\<sqinter> - y", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - (x \\<squnion> y) \\<le> - x \\<sqinter> - y\n 2. - x \\<sqinter> - y \\<le> - (x \\<squnion> y)", "apply (simp add: p_antitone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<sqinter> - y \\<le> - (x \\<squnion> y)", "using inf_le1 inf_le2 le_sup_iff p_antitone_iff"], ["proof (prove)\nusing this:\n  ?x \\<sqinter> ?y \\<le> ?x\n  ?x \\<sqinter> ?y \\<le> ?y\n  (?x \\<squnion> ?y \\<le> ?z) = (?x \\<le> ?z \\<and> ?y \\<le> ?z)\n  (?x \\<le> - ?y) = (?y \\<le> - ?x)\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> - y \\<le> - (x \\<squnion> y)", "by blast"], ["", "lemma p_supdist_inf:\n  \"-x \\<squnion> -y \\<le> -(x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<squnion> - y \\<le> - (x \\<sqinter> y)", "by (simp add: p_antitone)"], ["", "lemma pp_dist_pp_sup [simp]:\n  \"--(--x \\<squnion> --y) = --(x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - (- - x \\<squnion> - - y) = - - (x \\<squnion> y)", "by simp"], ["", "lemma p_sup_p [simp]:\n  \"-(x \\<squnion> -x) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense (x \\<squnion> - x)", "by simp"], ["", "lemma pp_sup_p [simp]:\n  \"--(x \\<squnion> -x) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - (x \\<squnion> - x) = top", "by simp"], ["", "lemma dense_pp:\n  \"dense x \\<longleftrightarrow> --x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense x = (- - x = top)", "by (metis p_bot p_top ppp)"], ["", "lemma dense_sup_p:\n  \"dense (x \\<squnion> -x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense (x \\<squnion> - x)", "by simp"], ["", "lemma regular_char:\n  \"regular x \\<longleftrightarrow> (\\<exists>y . x = -y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular x = in_p_image x", "by auto"], ["", "lemma pp_inf_bot_iff:\n  \"x \\<sqinter> y = bot \\<longleftrightarrow> --x \\<sqinter> y = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y = bot) = (- - x \\<sqinter> y = bot)", "by (simp add: pseudo_complement_pp)"], ["", "text \\<open>\nWeak forms of the shunting property hold.\nMost require a pseudocomplemented element on the right-hand side.\n\\<close>"], ["", "lemma p_shunting_swap:\n  \"x \\<sqinter> y \\<le> -z \\<longleftrightarrow> x \\<sqinter> z \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y \\<le> - z) = (x \\<sqinter> z \\<le> - y)", "by (metis inf_assoc inf_commute pseudo_complement)"], ["", "lemma pp_inf_below_iff:\n  \"x \\<sqinter> y \\<le> -z \\<longleftrightarrow> --x \\<sqinter> y \\<le> -z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y \\<le> - z) = (- - x \\<sqinter> y \\<le> - z)", "by (simp add: inf_commute p_shunting_swap)"], ["", "lemma p_inf_pp [simp]:\n  \"-(x \\<sqinter> --y) = -(x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<sqinter> - - y) = - (x \\<sqinter> y)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - (x \\<sqinter> - - y) \\<le> - (x \\<sqinter> y)\n 2. - (x \\<sqinter> y) \\<le> - (x \\<sqinter> - - y)", "apply (simp add: inf.coboundedI2 p_antitone pp_increasing)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<sqinter> y) \\<le> - (x \\<sqinter> - - y)", "using inf_commute p_antitone_iff pp_inf_below_iff"], ["proof (prove)\nusing this:\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n  (?x \\<le> - ?y) = (?y \\<le> - ?x)\n  (?x \\<sqinter> ?y \\<le> - ?z) = (- - ?x \\<sqinter> ?y \\<le> - ?z)\n\ngoal (1 subgoal):\n 1. - (x \\<sqinter> y) \\<le> - (x \\<sqinter> - - y)", "by auto"], ["", "lemma p_inf_pp_pp [simp]:\n  \"-(--x \\<sqinter> --y) = -(x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (- - x \\<sqinter> - - y) = - (x \\<sqinter> y)", "by (simp add: inf_commute)"], ["", "lemma regular_closed_inf:\n  \"regular x \\<Longrightarrow> regular y \\<Longrightarrow> regular (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>regular x; regular y\\<rbrakk>\n    \\<Longrightarrow> regular (x \\<sqinter> y)", "by (metis p_dist_sup ppp)"], ["", "lemma regular_closed_p:\n  \"regular (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (- x)", "by simp"], ["", "lemma regular_closed_pp:\n  \"regular (--x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (- - x)", "by simp"], ["", "lemma regular_closed_bot:\n  \"regular bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular bot", "by simp"], ["", "lemma regular_closed_top:\n  \"regular top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular top", "by simp"], ["", "lemma pp_dist_inf [simp]:\n  \"--(x \\<sqinter> y) = --x \\<sqinter> --y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - (x \\<sqinter> y) = - - x \\<sqinter> - - y", "by (metis p_dist_sup p_inf_pp_pp ppp)"], ["", "lemma inf_import_p [simp]:\n  \"x \\<sqinter> -(x \\<sqinter> y) = x \\<sqinter> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - (x \\<sqinter> y) = x \\<sqinter> - y", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<sqinter> - (x \\<sqinter> y) \\<le> x \\<sqinter> - y\n 2. x \\<sqinter> - y \\<le> x \\<sqinter> - (x \\<sqinter> y)", "using p_shunting_swap"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y \\<le> - ?z) = (?x \\<sqinter> ?z \\<le> - ?y)\n\ngoal (2 subgoals):\n 1. x \\<sqinter> - (x \\<sqinter> y) \\<le> x \\<sqinter> - y\n 2. x \\<sqinter> - y \\<le> x \\<sqinter> - (x \\<sqinter> y)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<le> x \\<sqinter> - (x \\<sqinter> y)", "using inf.sup_right_isotone p_antitone"], ["proof (prove)\nusing this:\n  ?y \\<le> ?x \\<Longrightarrow> ?z \\<sqinter> ?y \\<le> ?z \\<sqinter> ?x\n  ?x \\<le> ?y \\<Longrightarrow> - ?y \\<le> - ?x\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<le> x \\<sqinter> - (x \\<sqinter> y)", "by auto"], ["", "text \\<open>\nPseudocomplements are unique.\n\\<close>"], ["", "lemma p_unique:\n  \"(\\<forall>x . x \\<sqinter> y = bot \\<longleftrightarrow> x \\<le> z) \\<Longrightarrow> z = -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (x \\<sqinter> y = bot) = (x \\<le> z) \\<Longrightarrow>\n    z = - y", "using inf.eq_iff pseudo_complement"], ["proof (prove)\nusing this:\n  (?x = ?y) = (?y \\<le> ?x \\<and> ?x \\<le> ?y)\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x \\<sqinter> y = bot) = (x \\<le> z) \\<Longrightarrow>\n    z = - y", "by auto"], ["", "lemma maddux_3_5:\n  \"x \\<squnion> x = x \\<squnion> -(y \\<squnion> -y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> x = x \\<squnion> - (y \\<squnion> - y)", "by simp"], ["", "lemma shunting_1_pp:\n  \"x \\<le> --y \\<longleftrightarrow> x \\<sqinter> -y = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> - - y) = (x \\<sqinter> - y = bot)", "by (simp add: pseudo_complement)"], ["", "lemma pp_pp_inf_bot_iff:\n  \"x \\<sqinter> y = bot \\<longleftrightarrow> --x \\<sqinter> --y = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y = bot) = (- - x \\<sqinter> - - y = bot)", "by (simp add: pseudo_complement_pp)"], ["", "lemma inf_pp_semi_commute:\n  \"x \\<sqinter> --y \\<le> --(x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - - y \\<le> - - (x \\<sqinter> y)", "using inf.eq_refl p_antitone_iff p_inf_pp"], ["proof (prove)\nusing this:\n  ?x = ?y \\<Longrightarrow> ?y \\<le> ?x\n  (?x \\<le> - ?y) = (?y \\<le> - ?x)\n  - (?x \\<sqinter> - - ?y) = - (?x \\<sqinter> ?y)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - - y \\<le> - - (x \\<sqinter> y)", "by presburger"], ["", "lemma inf_pp_commute:\n  \"--(--x \\<sqinter> y) = --x \\<sqinter> --y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - (- - x \\<sqinter> y) = - - x \\<sqinter> - - y", "by simp"], ["", "lemma sup_pp_semi_commute:\n  \"x \\<squnion> --y \\<le> --(x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> - - y \\<le> - - (x \\<squnion> y)", "by (simp add: p_antitone_iff)"], ["", "lemma regular_sup:\n  \"regular z \\<Longrightarrow> (x \\<le> z \\<and> y \\<le> z \\<longleftrightarrow> --(x \\<squnion> y) \\<le> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular z \\<Longrightarrow>\n    (x \\<le> z \\<and> y \\<le> z) = (- - (x \\<squnion> y) \\<le> z)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>regular z; x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> - - (x \\<squnion> y) \\<le> z\n 2. \\<lbrakk>regular z; - - (x \\<squnion> y) \\<le> z\\<rbrakk>\n    \\<Longrightarrow> x \\<le> z \\<and> y \\<le> z", "apply (metis le_supI pp_isotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>regular z; - - (x \\<squnion> y) \\<le> z\\<rbrakk>\n    \\<Longrightarrow> x \\<le> z \\<and> y \\<le> z", "using dual_order.trans sup_ge2 pp_increasing pp_isotone_sup"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  ?y \\<le> ?x \\<squnion> ?y\n  ?x \\<le> - - ?x\n  - - ?x \\<le> - - (?x \\<squnion> ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>regular z; - - (x \\<squnion> y) \\<le> z\\<rbrakk>\n    \\<Longrightarrow> x \\<le> z \\<and> y \\<le> z", "by blast"], ["", "lemma dense_closed_inf:\n  \"dense x \\<Longrightarrow> dense y \\<Longrightarrow> dense (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dense x; dense y\\<rbrakk>\n    \\<Longrightarrow> dense (x \\<sqinter> y)", "by (simp add: dense_pp)"], ["", "lemma dense_closed_sup:\n  \"dense x \\<Longrightarrow> dense y \\<Longrightarrow> dense (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dense x; dense y\\<rbrakk>\n    \\<Longrightarrow> dense (x \\<squnion> y)", "by simp"], ["", "lemma dense_closed_pp:\n  \"dense x \\<Longrightarrow> dense (--x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense x \\<Longrightarrow> dense (- - x)", "by simp"], ["", "lemma dense_closed_top:\n  \"dense top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense top", "by simp"], ["", "lemma dense_up_closed:\n  \"dense x \\<Longrightarrow> x \\<le> y \\<Longrightarrow> dense y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dense x; x \\<le> y\\<rbrakk> \\<Longrightarrow> dense y", "using dense_pp top_le pp_isotone"], ["proof (prove)\nusing this:\n  dense ?x = (- - ?x = top)\n  top \\<le> ?a \\<Longrightarrow> ?a = top\n  ?x \\<le> ?y \\<Longrightarrow> - - ?x \\<le> - - ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dense x; x \\<le> y\\<rbrakk> \\<Longrightarrow> dense y", "by auto"], ["", "lemma regular_dense_top:\n  \"regular x \\<Longrightarrow> dense x \\<Longrightarrow> x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>regular x; dense x\\<rbrakk> \\<Longrightarrow> x = top", "using p_bot"], ["proof (prove)\nusing this:\n  - bot = top\n\ngoal (1 subgoal):\n 1. \\<lbrakk>regular x; dense x\\<rbrakk> \\<Longrightarrow> x = top", "by blast"], ["", "lemma selection_char:\n  \"selection s x \\<longleftrightarrow> (\\<exists>y . s = -y \\<sqinter> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. selection s x = (\\<exists>y. s = - y \\<sqinter> x)", "by (metis inf_import_p inf_commute regular_closed_p)"], ["", "lemma selection_closed_inf:\n  \"selection s x \\<Longrightarrow> selection t x \\<Longrightarrow> selection (s \\<sqinter> t) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>selection s x; selection t x\\<rbrakk>\n    \\<Longrightarrow> selection (s \\<sqinter> t) x", "by (metis inf_assoc inf_commute inf_idem pp_dist_inf)"], ["", "lemma selection_closed_pp:\n  \"regular x \\<Longrightarrow> selection s x \\<Longrightarrow> selection (--s) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>regular x; selection s x\\<rbrakk>\n    \\<Longrightarrow> selection (- - s) x", "by (metis pp_dist_inf)"], ["", "lemma selection_closed_bot:\n  \"selection bot x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. selection bot x", "by simp"], ["", "lemma selection_closed_id:\n  \"selection x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. selection x x", "using inf.le_iff_sup pp_increasing"], ["proof (prove)\nusing this:\n  (?y \\<le> ?x) = (?x \\<sqinter> ?y = ?y)\n  ?x \\<le> - - ?x\n\ngoal (1 subgoal):\n 1. selection x x", "by auto"], ["", "text \\<open>\nConjugates are usually studied for Boolean algebras, however, some of their properties generalise to pseudocomplemented algebras.\n\\<close>"], ["", "lemma conjugate_unique_p:\n  assumes \"conjugate f g\"\n      and \"conjugate f h\"\n    shows \"uminus \\<circ> g = uminus \\<circ> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uminus \\<circ> g = uminus \\<circ> h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. uminus \\<circ> g = uminus \\<circ> h", "have \"\\<forall>x y . x \\<sqinter> g y = bot \\<longleftrightarrow> x \\<sqinter> h y = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (x \\<sqinter> g y = bot) = (x \\<sqinter> h y = bot)", "using assms conjugate_def inf.commute"], ["proof (prove)\nusing this:\n  conjugate f g\n  conjugate f h\n  conjugate ?f ?g \\<equiv>\n  \\<forall>x y. (?f x \\<sqinter> y = bot) = (x \\<sqinter> ?g y = bot)\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n\ngoal (1 subgoal):\n 1. \\<forall>x y. (x \\<sqinter> g y = bot) = (x \\<sqinter> h y = bot)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x y. (x \\<sqinter> g y = bot) = (x \\<sqinter> h y = bot)\n\ngoal (1 subgoal):\n 1. uminus \\<circ> g = uminus \\<circ> h", "hence \"\\<forall>x y . x \\<le> -(g y) \\<longleftrightarrow> x \\<le> -(h y)\""], ["proof (prove)\nusing this:\n  \\<forall>x y. (x \\<sqinter> g y = bot) = (x \\<sqinter> h y = bot)\n\ngoal (1 subgoal):\n 1. \\<forall>x y. (x \\<le> - g y) = (x \\<le> - h y)", "using inf.commute pseudo_complement"], ["proof (prove)\nusing this:\n  \\<forall>x y. (x \\<sqinter> g y = bot) = (x \\<sqinter> h y = bot)\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. \\<forall>x y. (x \\<le> - g y) = (x \\<le> - h y)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x y. (x \\<le> - g y) = (x \\<le> - h y)\n\ngoal (1 subgoal):\n 1. uminus \\<circ> g = uminus \\<circ> h", "hence \"\\<forall>y . -(g y) = -(h y)\""], ["proof (prove)\nusing this:\n  \\<forall>x y. (x \\<le> - g y) = (x \\<le> - h y)\n\ngoal (1 subgoal):\n 1. \\<forall>y. - g y = - h y", "using eq_iff"], ["proof (prove)\nusing this:\n  \\<forall>x y. (x \\<le> - g y) = (x \\<le> - h y)\n  (?x = ?y) = (?x \\<le> ?y \\<and> ?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>y. - g y = - h y", "by blast"], ["proof (state)\nthis:\n  \\<forall>y. - g y = - h y\n\ngoal (1 subgoal):\n 1. uminus \\<circ> g = uminus \\<circ> h", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y. - g y = - h y\n\ngoal (1 subgoal):\n 1. uminus \\<circ> g = uminus \\<circ> h", "by auto"], ["proof (state)\nthis:\n  uminus \\<circ> g = uminus \\<circ> h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conjugate_symmetric:\n  \"conjugate f g \\<Longrightarrow> conjugate g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate f g \\<Longrightarrow> conjugate g f", "by (simp add: conjugate_def inf_commute)"], ["", "lemma additive_isotone:\n  \"additive f \\<Longrightarrow> isotone f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. additive f \\<Longrightarrow> isotone f", "by (metis additive_def isotone_def le_iff_sup)"], ["", "lemma dual_additive_antitone:\n  assumes \"dual_additive f\"\n    shows \"isotone (uminus \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isotone (uminus \\<circ> f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isotone (uminus \\<circ> f)", "have \"\\<forall>x y . f (x \\<squnion> y) \\<le> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. f (x \\<squnion> y) \\<le> f x", "using assms dual_additive_def"], ["proof (prove)\nusing this:\n  dual_additive f\n  dual_additive ?f \\<equiv>\n  \\<forall>x y. ?f (x \\<squnion> y) = ?f x \\<sqinter> ?f y\n\ngoal (1 subgoal):\n 1. \\<forall>x y. f (x \\<squnion> y) \\<le> f x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x y. f (x \\<squnion> y) \\<le> f x\n\ngoal (1 subgoal):\n 1. isotone (uminus \\<circ> f)", "hence \"\\<forall>x y . x \\<le> y \\<longrightarrow> f y \\<le> f x\""], ["proof (prove)\nusing this:\n  \\<forall>x y. f (x \\<squnion> y) \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<forall>x y. x \\<le> y \\<longrightarrow> f y \\<le> f x", "by (metis sup_absorb2)"], ["proof (state)\nthis:\n  \\<forall>x y. x \\<le> y \\<longrightarrow> f y \\<le> f x\n\ngoal (1 subgoal):\n 1. isotone (uminus \\<circ> f)", "hence \"\\<forall>x y . x \\<le> y \\<longrightarrow> -(f x) \\<le> -(f y)\""], ["proof (prove)\nusing this:\n  \\<forall>x y. x \\<le> y \\<longrightarrow> f y \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<forall>x y. x \\<le> y \\<longrightarrow> - f x \\<le> - f y", "by (simp add: p_antitone)"], ["proof (state)\nthis:\n  \\<forall>x y. x \\<le> y \\<longrightarrow> - f x \\<le> - f y\n\ngoal (1 subgoal):\n 1. isotone (uminus \\<circ> f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x y. x \\<le> y \\<longrightarrow> - f x \\<le> - f y\n\ngoal (1 subgoal):\n 1. isotone (uminus \\<circ> f)", "by (simp add: isotone_def)"], ["proof (state)\nthis:\n  isotone (uminus \\<circ> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conjugate_dual_additive:\n  assumes \"conjugate f g\"\n    shows \"dual_additive (uminus \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_additive (uminus \\<circ> f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dual_additive (uminus \\<circ> f)", "have 1: \"\\<forall>x y z . -z \\<le> -(f (x \\<squnion> y)) \\<longleftrightarrow> -z \\<le> -(f x) \\<and> -z \\<le> -(f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "have \"(-z \\<le> -(f (x \\<squnion> y))) = (f (x \\<squnion> y) \\<sqinter> -z = bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- z \\<le> - f (x \\<squnion> y)) =\n    (f (x \\<squnion> y) \\<sqinter> - z = bot)", "by (simp add: p_antitone_iff pseudo_complement)"], ["proof (state)\nthis:\n  (- z \\<le> - f (x \\<squnion> y)) =\n  (f (x \\<squnion> y) \\<sqinter> - z = bot)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "also"], ["proof (state)\nthis:\n  (- z \\<le> - f (x \\<squnion> y)) =\n  (f (x \\<squnion> y) \\<sqinter> - z = bot)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "have \"... = ((x \\<squnion> y) \\<sqinter> g(-z) = bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f (x \\<squnion> y) \\<sqinter> - z = bot) =\n    ((x \\<squnion> y) \\<sqinter> g (- z) = bot)", "using assms conjugate_def"], ["proof (prove)\nusing this:\n  conjugate f g\n  conjugate ?f ?g \\<equiv>\n  \\<forall>x y. (?f x \\<sqinter> y = bot) = (x \\<sqinter> ?g y = bot)\n\ngoal (1 subgoal):\n 1. (f (x \\<squnion> y) \\<sqinter> - z = bot) =\n    ((x \\<squnion> y) \\<sqinter> g (- z) = bot)", "by auto"], ["proof (state)\nthis:\n  (f (x \\<squnion> y) \\<sqinter> - z = bot) =\n  ((x \\<squnion> y) \\<sqinter> g (- z) = bot)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "also"], ["proof (state)\nthis:\n  (f (x \\<squnion> y) \\<sqinter> - z = bot) =\n  ((x \\<squnion> y) \\<sqinter> g (- z) = bot)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "have \"... = (x \\<squnion> y \\<le> -(g(-z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x \\<squnion> y) \\<sqinter> g (- z) = bot) =\n    (x \\<squnion> y \\<le> - g (- z))", "by (simp add: pseudo_complement)"], ["proof (state)\nthis:\n  ((x \\<squnion> y) \\<sqinter> g (- z) = bot) =\n  (x \\<squnion> y \\<le> - g (- z))\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "also"], ["proof (state)\nthis:\n  ((x \\<squnion> y) \\<sqinter> g (- z) = bot) =\n  (x \\<squnion> y \\<le> - g (- z))\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "have \"... = (x \\<le> -(g(-z)) \\<and> y \\<le> -(g(-z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y \\<le> - g (- z)) =\n    (x \\<le> - g (- z) \\<and> y \\<le> - g (- z))", "by (simp add: le_sup_iff)"], ["proof (state)\nthis:\n  (x \\<squnion> y \\<le> - g (- z)) =\n  (x \\<le> - g (- z) \\<and> y \\<le> - g (- z))\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "also"], ["proof (state)\nthis:\n  (x \\<squnion> y \\<le> - g (- z)) =\n  (x \\<le> - g (- z) \\<and> y \\<le> - g (- z))\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "have \"... = (x \\<sqinter> g(-z) = bot \\<and> y \\<sqinter> g(-z) = bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> - g (- z) \\<and> y \\<le> - g (- z)) =\n    (x \\<sqinter> g (- z) = bot \\<and> y \\<sqinter> g (- z) = bot)", "by (simp add: pseudo_complement)"], ["proof (state)\nthis:\n  (x \\<le> - g (- z) \\<and> y \\<le> - g (- z)) =\n  (x \\<sqinter> g (- z) = bot \\<and> y \\<sqinter> g (- z) = bot)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "also"], ["proof (state)\nthis:\n  (x \\<le> - g (- z) \\<and> y \\<le> - g (- z)) =\n  (x \\<sqinter> g (- z) = bot \\<and> y \\<sqinter> g (- z) = bot)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "have \"... = (f x \\<sqinter> -z = bot \\<and> f y \\<sqinter> -z = bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> g (- z) = bot \\<and> y \\<sqinter> g (- z) = bot) =\n    (f x \\<sqinter> - z = bot \\<and> f y \\<sqinter> - z = bot)", "using assms conjugate_def"], ["proof (prove)\nusing this:\n  conjugate f g\n  conjugate ?f ?g \\<equiv>\n  \\<forall>x y. (?f x \\<sqinter> y = bot) = (x \\<sqinter> ?g y = bot)\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> g (- z) = bot \\<and> y \\<sqinter> g (- z) = bot) =\n    (f x \\<sqinter> - z = bot \\<and> f y \\<sqinter> - z = bot)", "by auto"], ["proof (state)\nthis:\n  (x \\<sqinter> g (- z) = bot \\<and> y \\<sqinter> g (- z) = bot) =\n  (f x \\<sqinter> - z = bot \\<and> f y \\<sqinter> - z = bot)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "also"], ["proof (state)\nthis:\n  (x \\<sqinter> g (- z) = bot \\<and> y \\<sqinter> g (- z) = bot) =\n  (f x \\<sqinter> - z = bot \\<and> f y \\<sqinter> - z = bot)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "have \"... = (-z \\<le> -(f x) \\<and> -z \\<le> -(f y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x \\<sqinter> - z = bot \\<and> f y \\<sqinter> - z = bot) =\n    (- z \\<le> - f x \\<and> - z \\<le> - f y)", "by (simp add: p_antitone_iff pseudo_complement)"], ["proof (state)\nthis:\n  (f x \\<sqinter> - z = bot \\<and> f y \\<sqinter> - z = bot) =\n  (- z \\<le> - f x \\<and> - z \\<le> - f y)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (- z \\<le> - f (x \\<squnion> y)) =\n       (- z \\<le> - f x \\<and> - z \\<le> - f y)", "finally"], ["proof (chain)\npicking this:\n  (- z \\<le> - f (x \\<squnion> y)) =\n  (- z \\<le> - f x \\<and> - z \\<le> - f y)", "show \"-z \\<le> -(f (x \\<squnion> y)) \\<longleftrightarrow> -z \\<le> -(f x) \\<and> -z \\<le> -(f y)\""], ["proof (prove)\nusing this:\n  (- z \\<le> - f (x \\<squnion> y)) =\n  (- z \\<le> - f x \\<and> - z \\<le> - f y)\n\ngoal (1 subgoal):\n 1. (- z \\<le> - f (x \\<squnion> y)) =\n    (- z \\<le> - f x \\<and> - z \\<le> - f y)", "by simp"], ["proof (state)\nthis:\n  (- z \\<le> - f (x \\<squnion> y)) =\n  (- z \\<le> - f x \\<and> - z \\<le> - f y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y z.\n     (- z \\<le> - f (x \\<squnion> y)) =\n     (- z \\<le> - f x \\<and> - z \\<le> - f y)\n\ngoal (1 subgoal):\n 1. dual_additive (uminus \\<circ> f)", "have \"\\<forall>x y . -(f (x \\<squnion> y)) = -(f x) \\<sqinter> -(f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. - f (x \\<squnion> y) = - f x \\<sqinter> - f y", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. - f (x \\<squnion> y) = - f x \\<sqinter> - f y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. - f (x \\<squnion> y) = - f x \\<sqinter> - f y", "have \"-(f x) \\<sqinter> -(f y) = --(-(f x) \\<sqinter> -(f y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (- f x \\<sqinter> - f y)", "by simp"], ["proof (state)\nthis:\n  regular (- f x \\<sqinter> - f y)\n\ngoal (1 subgoal):\n 1. \\<And>x y. - f (x \\<squnion> y) = - f x \\<sqinter> - f y", "hence \"-(f x) \\<sqinter> -(f y) \\<le> -(f (x \\<squnion> y))\""], ["proof (prove)\nusing this:\n  regular (- f x \\<sqinter> - f y)\n\ngoal (1 subgoal):\n 1. - f x \\<sqinter> - f y \\<le> - f (x \\<squnion> y)", "using 1"], ["proof (prove)\nusing this:\n  regular (- f x \\<sqinter> - f y)\n  \\<forall>x y z.\n     (- z \\<le> - f (x \\<squnion> y)) =\n     (- z \\<le> - f x \\<and> - z \\<le> - f y)\n\ngoal (1 subgoal):\n 1. - f x \\<sqinter> - f y \\<le> - f (x \\<squnion> y)", "by (metis inf_le1 inf_le2)"], ["proof (state)\nthis:\n  - f x \\<sqinter> - f y \\<le> - f (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. \\<And>x y. - f (x \\<squnion> y) = - f x \\<sqinter> - f y", "thus \"-(f (x \\<squnion> y)) = -(f x) \\<sqinter> -(f y)\""], ["proof (prove)\nusing this:\n  - f x \\<sqinter> - f y \\<le> - f (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. - f (x \\<squnion> y) = - f x \\<sqinter> - f y", "using 1 antisym"], ["proof (prove)\nusing this:\n  - f x \\<sqinter> - f y \\<le> - f (x \\<squnion> y)\n  \\<forall>x y z.\n     (- z \\<le> - f (x \\<squnion> y)) =\n     (- z \\<le> - f x \\<and> - z \\<le> - f y)\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. - f (x \\<squnion> y) = - f x \\<sqinter> - f y", "by fastforce"], ["proof (state)\nthis:\n  - f (x \\<squnion> y) = - f x \\<sqinter> - f y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y. - f (x \\<squnion> y) = - f x \\<sqinter> - f y\n\ngoal (1 subgoal):\n 1. dual_additive (uminus \\<circ> f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x y. - f (x \\<squnion> y) = - f x \\<sqinter> - f y\n\ngoal (1 subgoal):\n 1. dual_additive (uminus \\<circ> f)", "using dual_additive_def"], ["proof (prove)\nusing this:\n  \\<forall>x y. - f (x \\<squnion> y) = - f x \\<sqinter> - f y\n  dual_additive ?f \\<equiv>\n  \\<forall>x y. ?f (x \\<squnion> y) = ?f x \\<sqinter> ?f y\n\ngoal (1 subgoal):\n 1. dual_additive (uminus \\<circ> f)", "by simp"], ["proof (state)\nthis:\n  dual_additive (uminus \\<circ> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conjugate_isotone_pp:\n  \"conjugate f g \\<Longrightarrow> isotone (uminus \\<circ> uminus \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate f g \\<Longrightarrow>\n    isotone (uminus \\<circ> uminus \\<circ> f)", "by (simp add: comp_assoc conjugate_dual_additive dual_additive_antitone)"], ["", "lemma conjugate_char_1_pp:\n  \"conjugate f g \\<longleftrightarrow> (\\<forall>x y . f(x \\<sqinter> -(g y)) \\<le> --f x \\<sqinter> -y \\<and> g(y \\<sqinter> -(f x)) \\<le> --g y \\<sqinter> -x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate f g =\n    (\\<forall>x y.\n        f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n        g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. conjugate f g \\<Longrightarrow>\n    \\<forall>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x\n 2. \\<forall>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x \\<Longrightarrow>\n    conjugate f g", "assume 1: \"conjugate f g\""], ["proof (state)\nthis:\n  conjugate f g\n\ngoal (2 subgoals):\n 1. conjugate f g \\<Longrightarrow>\n    \\<forall>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x\n 2. \\<forall>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x \\<Longrightarrow>\n    conjugate f g", "show \"\\<forall>x y . f(x \\<sqinter> -(g y)) \\<le> --f x \\<sqinter> -y \\<and> g(y \\<sqinter> -(f x)) \\<le> --g y \\<sqinter> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "have 2: \"f(x \\<sqinter> -(g y)) \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x \\<sqinter> - g y) \\<le> - y", "using 1"], ["proof (prove)\nusing this:\n  conjugate f g\n\ngoal (1 subgoal):\n 1. f (x \\<sqinter> - g y) \\<le> - y", "by (simp add: conjugate_def pseudo_complement)"], ["proof (state)\nthis:\n  f (x \\<sqinter> - g y) \\<le> - y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "have \"f(x \\<sqinter> -(g y)) \\<le> --f(x \\<sqinter> -(g y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x \\<sqinter> - g y) \\<le> - - f (x \\<sqinter> - g y)", "by (simp add: pp_increasing)"], ["proof (state)\nthis:\n  f (x \\<sqinter> - g y) \\<le> - - f (x \\<sqinter> - g y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "also"], ["proof (state)\nthis:\n  f (x \\<sqinter> - g y) \\<le> - - f (x \\<sqinter> - g y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "have \"... \\<le> --f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - f (x \\<sqinter> - g y) \\<le> - - f x", "using 1 conjugate_isotone_pp isotone_def"], ["proof (prove)\nusing this:\n  conjugate f g\n  conjugate ?f ?g \\<Longrightarrow>\n  isotone (uminus \\<circ> uminus \\<circ> ?f)\n  isotone ?f \\<equiv>\n  \\<forall>x y. x \\<le> y \\<longrightarrow> ?f x \\<le> ?f y\n\ngoal (1 subgoal):\n 1. - - f (x \\<sqinter> - g y) \\<le> - - f x", "by simp"], ["proof (state)\nthis:\n  - - f (x \\<sqinter> - g y) \\<le> - - f x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "finally"], ["proof (chain)\npicking this:\n  f (x \\<sqinter> - g y) \\<le> - - f x", "have 3: \"f(x \\<sqinter> -(g y)) \\<le> --f x \\<sqinter> -y\""], ["proof (prove)\nusing this:\n  f (x \\<sqinter> - g y) \\<le> - - f x\n\ngoal (1 subgoal):\n 1. f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y", "using 2"], ["proof (prove)\nusing this:\n  f (x \\<sqinter> - g y) \\<le> - - f x\n  f (x \\<sqinter> - g y) \\<le> - y\n\ngoal (1 subgoal):\n 1. f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y", "by simp"], ["proof (state)\nthis:\n  f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "have 4: \"isotone (uminus \\<circ> uminus \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isotone (uminus \\<circ> uminus \\<circ> g)", "using 1 conjugate_isotone_pp conjugate_symmetric"], ["proof (prove)\nusing this:\n  conjugate f g\n  conjugate ?f ?g \\<Longrightarrow>\n  isotone (uminus \\<circ> uminus \\<circ> ?f)\n  conjugate ?f ?g \\<Longrightarrow> conjugate ?g ?f\n\ngoal (1 subgoal):\n 1. isotone (uminus \\<circ> uminus \\<circ> g)", "by auto"], ["proof (state)\nthis:\n  isotone (uminus \\<circ> uminus \\<circ> g)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "have 5: \"g(y \\<sqinter> -(f x)) \\<le> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (y \\<sqinter> - f x) \\<le> - x", "using 1"], ["proof (prove)\nusing this:\n  conjugate f g\n\ngoal (1 subgoal):\n 1. g (y \\<sqinter> - f x) \\<le> - x", "by (metis conjugate_def inf.cobounded2 inf_commute pseudo_complement)"], ["proof (state)\nthis:\n  g (y \\<sqinter> - f x) \\<le> - x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "have \"g(y \\<sqinter> -(f x)) \\<le> --g(y \\<sqinter> -(f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (y \\<sqinter> - f x) \\<le> - - g (y \\<sqinter> - f x)", "by (simp add: pp_increasing)"], ["proof (state)\nthis:\n  g (y \\<sqinter> - f x) \\<le> - - g (y \\<sqinter> - f x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "also"], ["proof (state)\nthis:\n  g (y \\<sqinter> - f x) \\<le> - - g (y \\<sqinter> - f x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "have \"... \\<le> --g y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - g (y \\<sqinter> - f x) \\<le> - - g y", "using 4 isotone_def"], ["proof (prove)\nusing this:\n  isotone (uminus \\<circ> uminus \\<circ> g)\n  isotone ?f \\<equiv>\n  \\<forall>x y. x \\<le> y \\<longrightarrow> ?f x \\<le> ?f y\n\ngoal (1 subgoal):\n 1. - - g (y \\<sqinter> - f x) \\<le> - - g y", "by auto"], ["proof (state)\nthis:\n  - - g (y \\<sqinter> - f x) \\<le> - - g y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "finally"], ["proof (chain)\npicking this:\n  g (y \\<sqinter> - f x) \\<le> - - g y", "have \"g(y \\<sqinter> -(f x)) \\<le> --g y \\<sqinter> -x\""], ["proof (prove)\nusing this:\n  g (y \\<sqinter> - f x) \\<le> - - g y\n\ngoal (1 subgoal):\n 1. g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "using 5"], ["proof (prove)\nusing this:\n  g (y \\<sqinter> - f x) \\<le> - - g y\n  g (y \\<sqinter> - f x) \\<le> - x\n\ngoal (1 subgoal):\n 1. g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "by simp"], ["proof (state)\nthis:\n  g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "thus \"f(x \\<sqinter> -(g y)) \\<le> --f x \\<sqinter> -y \\<and> g(y \\<sqinter> -(f x)) \\<le> --g y \\<sqinter> -x\""], ["proof (prove)\nusing this:\n  g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x\n\ngoal (1 subgoal):\n 1. f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n    g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "using 3"], ["proof (prove)\nusing this:\n  g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x\n  f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n    g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x", "by simp"], ["proof (state)\nthis:\n  f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n  g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y.\n     f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n     g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x \\<Longrightarrow>\n    conjugate f g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x \\<Longrightarrow>\n    conjugate f g", "assume 6: \"\\<forall>x y . f(x \\<sqinter> -(g y)) \\<le> --f x \\<sqinter> -y \\<and> g(y \\<sqinter> -(f x)) \\<le> --g y \\<sqinter> -x\""], ["proof (state)\nthis:\n  \\<forall>x y.\n     f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n     g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x \\<Longrightarrow>\n    conjugate f g", "hence 7: \"\\<forall>x y . f x \\<sqinter> y = bot \\<longrightarrow> x \\<sqinter> g y = bot\""], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n     g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       f x \\<sqinter> y = bot \\<longrightarrow> x \\<sqinter> g y = bot", "by (metis inf.le_iff_sup inf.le_sup_iff inf_commute pseudo_complement)"], ["proof (state)\nthis:\n  \\<forall>x y.\n     f x \\<sqinter> y = bot \\<longrightarrow> x \\<sqinter> g y = bot\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x \\<Longrightarrow>\n    conjugate f g", "have \"\\<forall>x y . x \\<sqinter> g y = bot \\<longrightarrow> f x \\<sqinter> y = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<sqinter> g y = bot \\<longrightarrow> f x \\<sqinter> y = bot", "using 6"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n     g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<sqinter> g y = bot \\<longrightarrow> f x \\<sqinter> y = bot", "by (metis inf.le_iff_sup inf.le_sup_iff inf_commute pseudo_complement)"], ["proof (state)\nthis:\n  \\<forall>x y.\n     x \\<sqinter> g y = bot \\<longrightarrow> f x \\<sqinter> y = bot\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       f (x \\<sqinter> - g y) \\<le> - - f x \\<sqinter> - y \\<and>\n       g (y \\<sqinter> - f x) \\<le> - - g y \\<sqinter> - x \\<Longrightarrow>\n    conjugate f g", "thus \"conjugate f g\""], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     x \\<sqinter> g y = bot \\<longrightarrow> f x \\<sqinter> y = bot\n\ngoal (1 subgoal):\n 1. conjugate f g", "using 7 conjugate_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     x \\<sqinter> g y = bot \\<longrightarrow> f x \\<sqinter> y = bot\n  \\<forall>x y.\n     f x \\<sqinter> y = bot \\<longrightarrow> x \\<sqinter> g y = bot\n  conjugate ?f ?g \\<equiv>\n  \\<forall>x y. (?f x \\<sqinter> y = bot) = (x \\<sqinter> ?g y = bot)\n\ngoal (1 subgoal):\n 1. conjugate f g", "by auto"], ["proof (state)\nthis:\n  conjugate f g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conjugate_char_1_isotone:\n  \"conjugate f g \\<Longrightarrow> isotone f \\<Longrightarrow> isotone g \\<Longrightarrow> f(x \\<sqinter> -(g y)) \\<le> f x \\<sqinter> -y \\<and> g(y \\<sqinter> -(f x)) \\<le> g y \\<sqinter> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>conjugate f g; isotone f; isotone g\\<rbrakk>\n    \\<Longrightarrow> f (x \\<sqinter> - g y) \\<le> f x \\<sqinter> - y \\<and>\n                      g (y \\<sqinter> - f x) \\<le> g y \\<sqinter> - x", "by (simp add: conjugate_char_1_pp ord.isotone_def)"], ["", "lemma dense_lattice_char_1:\n  \"(\\<forall>x y . x \\<sqinter> y = bot \\<longrightarrow> x = bot \\<or> y = bot) \\<longleftrightarrow> (\\<forall>x . x \\<noteq> bot \\<longrightarrow> dense x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y.\n        x \\<sqinter> y = bot \\<longrightarrow> x = bot \\<or> y = bot) =\n    (\\<forall>x. x \\<noteq> bot \\<longrightarrow> dense x)", "by (metis inf_top.left_neutral p_bot p_inf pp_inf_bot_iff)"], ["", "lemma dense_lattice_char_2:\n  \"(\\<forall>x y . x \\<sqinter> y = bot \\<longrightarrow> x = bot \\<or> y = bot) \\<longleftrightarrow> (\\<forall>x . regular x \\<longrightarrow> x = bot \\<or> x = top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y.\n        x \\<sqinter> y = bot \\<longrightarrow> x = bot \\<or> y = bot) =\n    (\\<forall>x. regular x \\<longrightarrow> x = bot \\<or> x = top)", "by (metis dense_lattice_char_1 inf_top.left_neutral p_inf regular_closed_p regular_closed_top)"], ["", "lemma restrict_below_Rep_eq:\n  \"x \\<sqinter> --y \\<le> z \\<Longrightarrow> x \\<sqinter> y = x \\<sqinter> z \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - - y \\<le> z \\<Longrightarrow>\n    x \\<sqinter> y = x \\<sqinter> z \\<sqinter> y", "by (metis inf.absorb2 inf.commute inf.left_commute pp_increasing)"], ["", "(*\nlemma p_inf_sup_below: \"-x \\<sqinter> (x \\<squnion> y) \\<le> y\" nitpick [expect=genuine] oops\nlemma complement_p: \"x \\<sqinter> y = bot \\<and> x \\<squnion> y = top \\<longrightarrow> -x = y\" nitpick [expect=genuine] oops\nlemma complemented_regular: \"complemented x \\<longrightarrow> regular x\" nitpick [expect=genuine] oops\n*)"], ["", "end"], ["", "text \\<open>\nThe following class gives equational axioms for the pseudocomplement operation.\n\\<close>"], ["", "class p_algebra_eq = bounded_lattice + uminus +\n  assumes p_bot_eq: \"-bot = top\"\n      and p_top_eq: \"-top = bot\"\n      and inf_import_p_eq: \"x \\<sqinter> -(x \\<sqinter> y) = x \\<sqinter> -y\"\nbegin"], ["", "lemma inf_p_eq:\n  \"x \\<sqinter> -x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - x = bot", "by (metis inf_bot_right inf_import_p_eq inf_top_right p_top_eq)"], ["", "subclass p_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.p_algebra uminus (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot top", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<sqinter> y = bot \\<Longrightarrow> x \\<le> - y\n 2. \\<And>x y. x \\<le> - y \\<Longrightarrow> x \\<sqinter> y = bot", "apply (metis inf.orderI inf_import_p_eq inf_top.right_neutral p_bot_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> - y \\<Longrightarrow> x \\<sqinter> y = bot", "by (metis (full_types) inf.left_commute inf.orderE inf_bot_right inf_commute inf_p_eq)"], ["", "end"], ["", "subsubsection \\<open>Pseudocomplemented Distributive Lattices\\<close>"], ["", "text \\<open>\nWe obtain further properties if we assume that the lattice operations are distributive.\n\\<close>"], ["", "class pd_algebra = p_algebra + bounded_distrib_lattice\nbegin"], ["", "lemma p_inf_sup_below:\n  \"-x \\<sqinter> (x \\<squnion> y) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<sqinter> (x \\<squnion> y) \\<le> y", "by (simp add: inf_sup_distrib1)"], ["", "lemma pp_inf_sup_p [simp]:\n  \"--x \\<sqinter> (x \\<squnion> -x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x \\<sqinter> (x \\<squnion> - x) = x", "using inf.absorb2 inf_sup_distrib1 pp_increasing"], ["proof (prove)\nusing this:\n  ?b \\<le> ?a \\<Longrightarrow> ?a \\<sqinter> ?b = ?b\n  ?x \\<sqinter> (?y \\<squnion> ?z) =\n  ?x \\<sqinter> ?y \\<squnion> ?x \\<sqinter> ?z\n  ?x \\<le> - - ?x\n\ngoal (1 subgoal):\n 1. - - x \\<sqinter> (x \\<squnion> - x) = x", "by auto"], ["", "lemma complement_p:\n  \"x \\<sqinter> y = bot \\<Longrightarrow> x \\<squnion> y = top \\<Longrightarrow> -x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sqinter> y = bot; x \\<squnion> y = top\\<rbrakk>\n    \\<Longrightarrow> - x = y", "by (metis pseudo_complement inf.commute inf_top.left_neutral sup.absorb_iff1 sup.commute sup_bot.right_neutral sup_inf_distrib2 p_inf)"], ["", "lemma complemented_regular:\n  \"complemented x \\<Longrightarrow> regular x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complemented x \\<Longrightarrow> regular x", "using complement_p inf.commute sup.commute"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<sqinter> ?y = bot; ?x \\<squnion> ?y = top\\<rbrakk>\n  \\<Longrightarrow> - ?x = ?y\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n  ?a \\<squnion> ?b = ?b \\<squnion> ?a\n\ngoal (1 subgoal):\n 1. complemented x \\<Longrightarrow> regular x", "by fastforce"], ["", "lemma regular_inf_dense:\n  \"\\<exists>y z . regular y \\<and> dense z \\<and> x = y \\<sqinter> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y z. regular y \\<and> dense z \\<and> x = y \\<sqinter> z", "by (metis pp_inf_sup_p dense_sup_p ppp)"], ["", "lemma maddux_3_12 [simp]:\n  \"(x \\<squnion> -y) \\<sqinter> (x \\<squnion> y) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> - y) \\<sqinter> (x \\<squnion> y) = x", "by (metis p_inf sup_bot_right sup_inf_distrib1)"], ["", "lemma maddux_3_13 [simp]:\n  \"(x \\<squnion> y) \\<sqinter> -x = y \\<sqinter> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y) \\<sqinter> - x = y \\<sqinter> - x", "by (simp add: inf_sup_distrib2)"], ["", "lemma maddux_3_20:\n  \"((v \\<sqinter> w) \\<squnion> (-v \\<sqinter> x)) \\<sqinter> -((v \\<sqinter> y) \\<squnion> (-v \\<sqinter> z)) = (v \\<sqinter> w \\<sqinter> -y) \\<squnion> (-v \\<sqinter> x \\<sqinter> -z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "have \"v \\<sqinter> w \\<sqinter> -(v \\<sqinter> y) \\<sqinter> -(-v \\<sqinter> z) = v \\<sqinter> w \\<sqinter> -(v \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n    - (- v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y)", "by (meson inf.cobounded1 inf_absorb1 le_infI1 p_antitone_iff)"], ["proof (state)\nthis:\n  v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) =\n  v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "also"], ["proof (state)\nthis:\n  v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) =\n  v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "have \"... = v \\<sqinter> w \\<sqinter> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) =\n    v \\<sqinter> w \\<sqinter> - y", "using inf.sup_relative_same_increasing inf_import_p inf_le1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<le> ?x; ?x \\<sqinter> ?z = ?x \\<sqinter> ?w\\<rbrakk>\n  \\<Longrightarrow> ?y \\<sqinter> ?z = ?y \\<sqinter> ?w\n  ?x \\<sqinter> - (?x \\<sqinter> ?y) = ?x \\<sqinter> - ?y\n  ?x \\<sqinter> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) =\n    v \\<sqinter> w \\<sqinter> - y", "by blast"], ["proof (state)\nthis:\n  v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) =\n  v \\<sqinter> w \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "finally"], ["proof (chain)\npicking this:\n  v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) =\n  v \\<sqinter> w \\<sqinter> - y", "have 1: \"v \\<sqinter> w \\<sqinter> -(v \\<sqinter> y) \\<sqinter> -(-v \\<sqinter> z) = v \\<sqinter> w \\<sqinter> -y\""], ["proof (prove)\nusing this:\n  v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) =\n  v \\<sqinter> w \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n    - (- v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y", "."], ["proof (state)\nthis:\n  v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) =\n  v \\<sqinter> w \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "have \"-v \\<sqinter> x \\<sqinter> -(v \\<sqinter> y) \\<sqinter> -(-v \\<sqinter> z) = -v \\<sqinter> x \\<sqinter> -(-v \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - v \\<sqinter> x \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n    - (- v \\<sqinter> z) =\n    - v \\<sqinter> x \\<sqinter> - (- v \\<sqinter> z)", "by (simp add: inf.absorb1 le_infI1 p_antitone_inf)"], ["proof (state)\nthis:\n  - v \\<sqinter> x \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) =\n  - v \\<sqinter> x \\<sqinter> - (- v \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "also"], ["proof (state)\nthis:\n  - v \\<sqinter> x \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) =\n  - v \\<sqinter> x \\<sqinter> - (- v \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "have \"... = -v \\<sqinter> x \\<sqinter> -z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - v \\<sqinter> x \\<sqinter> - (- v \\<sqinter> z) =\n    - v \\<sqinter> x \\<sqinter> - z", "by (simp add: inf.assoc inf_left_commute)"], ["proof (state)\nthis:\n  - v \\<sqinter> x \\<sqinter> - (- v \\<sqinter> z) =\n  - v \\<sqinter> x \\<sqinter> - z\n\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "finally"], ["proof (chain)\npicking this:\n  - v \\<sqinter> x \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) =\n  - v \\<sqinter> x \\<sqinter> - z", "have 2: \"-v \\<sqinter> x \\<sqinter> -(v \\<sqinter> y) \\<sqinter> -(-v \\<sqinter> z) = -v \\<sqinter> x \\<sqinter> -z\""], ["proof (prove)\nusing this:\n  - v \\<sqinter> x \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) =\n  - v \\<sqinter> x \\<sqinter> - z\n\ngoal (1 subgoal):\n 1. - v \\<sqinter> x \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n    - (- v \\<sqinter> z) =\n    - v \\<sqinter> x \\<sqinter> - z", "."], ["proof (state)\nthis:\n  - v \\<sqinter> x \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) =\n  - v \\<sqinter> x \\<sqinter> - z\n\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "have \"((v \\<sqinter> w) \\<squnion> (-v \\<sqinter> x)) \\<sqinter> -((v \\<sqinter> y) \\<squnion> (-v \\<sqinter> z)) = (v \\<sqinter> w \\<sqinter> -(v \\<sqinter> y) \\<sqinter> -(-v \\<sqinter> z)) \\<squnion> (-v \\<sqinter> x \\<sqinter> -(v \\<sqinter> y) \\<sqinter> -(-v \\<sqinter> z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n    - (- v \\<sqinter> z) \\<squnion>\n    - v \\<sqinter> x \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n    - (- v \\<sqinter> z)", "by (simp add: inf_assoc inf_sup_distrib2)"], ["proof (state)\nthis:\n  (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n  - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n  v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) \\<squnion>\n  - v \\<sqinter> x \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "also"], ["proof (state)\nthis:\n  (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n  - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n  v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) \\<squnion>\n  - v \\<sqinter> x \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "have \"... = (v \\<sqinter> w \\<sqinter> -y) \\<squnion> (-v \\<sqinter> x \\<sqinter> -z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n    - (- v \\<sqinter> z) \\<squnion>\n    - v \\<sqinter> x \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n    - (- v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "using 1 2"], ["proof (prove)\nusing this:\n  v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) =\n  v \\<sqinter> w \\<sqinter> - y\n  - v \\<sqinter> x \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) =\n  - v \\<sqinter> x \\<sqinter> - z\n\ngoal (1 subgoal):\n 1. v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n    - (- v \\<sqinter> z) \\<squnion>\n    - v \\<sqinter> x \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n    - (- v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "by simp"], ["proof (state)\nthis:\n  v \\<sqinter> w \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) \\<squnion>\n  - v \\<sqinter> x \\<sqinter> - (v \\<sqinter> y) \\<sqinter>\n  - (- v \\<sqinter> z) =\n  v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z\n\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "finally"], ["proof (chain)\npicking this:\n  (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n  - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n  v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "show ?thesis"], ["proof (prove)\nusing this:\n  (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n  - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n  v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z\n\ngoal (1 subgoal):\n 1. (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n    - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n    v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z", "."], ["proof (state)\nthis:\n  (v \\<sqinter> w \\<squnion> - v \\<sqinter> x) \\<sqinter>\n  - (v \\<sqinter> y \\<squnion> - v \\<sqinter> z) =\n  v \\<sqinter> w \\<sqinter> - y \\<squnion> - v \\<sqinter> x \\<sqinter> - z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_char_1:\n  \"x \\<le> y \\<longleftrightarrow> x \\<le> y \\<squnion> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x \\<le> y \\<squnion> - x)", "by (metis inf.sup_left_isotone inf_sup_absorb le_supI1 maddux_3_12 sup_commute)"], ["", "lemma order_char_2:\n  \"x \\<le> y \\<longleftrightarrow> x \\<squnion> -x \\<le> y \\<squnion> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x \\<squnion> - x \\<le> y \\<squnion> - x)", "using order_char_1"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (?x \\<le> ?y \\<squnion> - ?x)\n\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x \\<squnion> - x \\<le> y \\<squnion> - x)", "by auto"], ["", "(*\nlemma pp_dist_sup [simp]: \"--(x \\<squnion> y) = --x \\<squnion> --y\" nitpick [expect=genuine] oops\nlemma regular_closed_sup: \"regular x \\<and> regular y \\<longrightarrow> regular (x \\<squnion> y)\" nitpick [expect=genuine] oops\nlemma regular_complemented_iff: \"regular x \\<longleftrightarrow> complemented x\" nitpick [expect=genuine] oops\nlemma selection_closed_sup: \"selection s x \\<and> selection t x \\<longrightarrow> selection (s \\<squnion> t) x\" nitpick [expect=genuine] oops\nlemma stone [simp]: \"-x \\<squnion> --x = top\" nitpick [expect=genuine] oops\n*)"], ["", "end"], ["", "subsection \\<open>Stone Algebras\\<close>"], ["", "text \\<open>\nA Stone algebra is a distributive lattice with a pseudocomplement that satisfies the following equation.\nWe thus obtain the other half of the requirements of a complement at least for the regular elements.\n\\<close>"], ["", "class stone_algebra = pd_algebra +\n  assumes stone [simp]: \"-x \\<squnion> --x = top\"\nbegin"], ["", "text \\<open>\nAs a consequence, we obtain both De Morgan's laws for all elements.\n\\<close>"], ["", "lemma p_dist_inf [simp]:\n  \"-(x \\<sqinter> y) = -x \\<squnion> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<sqinter> y) = - x \\<squnion> - y", "proof (rule p_unique[THEN sym], rule allI, rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<sqinter> (x \\<sqinter> y) = bot \\<Longrightarrow>\n       xa \\<le> - x \\<squnion> - y\n 2. \\<And>xa.\n       xa \\<le> - x \\<squnion> - y \\<Longrightarrow>\n       xa \\<sqinter> (x \\<sqinter> y) = bot", "fix w"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<sqinter> (x \\<sqinter> y) = bot \\<Longrightarrow>\n       xa \\<le> - x \\<squnion> - y\n 2. \\<And>xa.\n       xa \\<le> - x \\<squnion> - y \\<Longrightarrow>\n       xa \\<sqinter> (x \\<sqinter> y) = bot", "assume \"w \\<sqinter> (x \\<sqinter> y) = bot\""], ["proof (state)\nthis:\n  w \\<sqinter> (x \\<sqinter> y) = bot\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<sqinter> (x \\<sqinter> y) = bot \\<Longrightarrow>\n       xa \\<le> - x \\<squnion> - y\n 2. \\<And>xa.\n       xa \\<le> - x \\<squnion> - y \\<Longrightarrow>\n       xa \\<sqinter> (x \\<sqinter> y) = bot", "hence \"w \\<sqinter> --x \\<sqinter> y = bot\""], ["proof (prove)\nusing this:\n  w \\<sqinter> (x \\<sqinter> y) = bot\n\ngoal (1 subgoal):\n 1. w \\<sqinter> - - x \\<sqinter> y = bot", "using inf_commute inf_left_commute pseudo_complement"], ["proof (prove)\nusing this:\n  w \\<sqinter> (x \\<sqinter> y) = bot\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n  ?x \\<sqinter> (?y \\<sqinter> ?z) = ?y \\<sqinter> (?x \\<sqinter> ?z)\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. w \\<sqinter> - - x \\<sqinter> y = bot", "by auto"], ["proof (state)\nthis:\n  w \\<sqinter> - - x \\<sqinter> y = bot\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<sqinter> (x \\<sqinter> y) = bot \\<Longrightarrow>\n       xa \\<le> - x \\<squnion> - y\n 2. \\<And>xa.\n       xa \\<le> - x \\<squnion> - y \\<Longrightarrow>\n       xa \\<sqinter> (x \\<sqinter> y) = bot", "hence 1: \"w \\<sqinter> --x \\<le> -y\""], ["proof (prove)\nusing this:\n  w \\<sqinter> - - x \\<sqinter> y = bot\n\ngoal (1 subgoal):\n 1. w \\<sqinter> - - x \\<le> - y", "by (simp add: pseudo_complement)"], ["proof (state)\nthis:\n  w \\<sqinter> - - x \\<le> - y\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<sqinter> (x \\<sqinter> y) = bot \\<Longrightarrow>\n       xa \\<le> - x \\<squnion> - y\n 2. \\<And>xa.\n       xa \\<le> - x \\<squnion> - y \\<Longrightarrow>\n       xa \\<sqinter> (x \\<sqinter> y) = bot", "have \"w = (w \\<sqinter> -x) \\<squnion> (w \\<sqinter> --x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = w \\<sqinter> - x \\<squnion> w \\<sqinter> - - x", "using distrib_imp2 sup_inf_distrib1"], ["proof (prove)\nusing this:\n  (\\<And>x y z.\n      x \\<squnion> y \\<sqinter> z =\n      (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)) \\<Longrightarrow>\n  ?x \\<sqinter> (?y \\<squnion> ?z) =\n  ?x \\<sqinter> ?y \\<squnion> ?x \\<sqinter> ?z\n  ?x \\<squnion> ?y \\<sqinter> ?z =\n  (?x \\<squnion> ?y) \\<sqinter> (?x \\<squnion> ?z)\n\ngoal (1 subgoal):\n 1. w = w \\<sqinter> - x \\<squnion> w \\<sqinter> - - x", "by auto"], ["proof (state)\nthis:\n  w = w \\<sqinter> - x \\<squnion> w \\<sqinter> - - x\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<sqinter> (x \\<sqinter> y) = bot \\<Longrightarrow>\n       xa \\<le> - x \\<squnion> - y\n 2. \\<And>xa.\n       xa \\<le> - x \\<squnion> - y \\<Longrightarrow>\n       xa \\<sqinter> (x \\<sqinter> y) = bot", "thus \"w \\<le> -x \\<squnion> -y\""], ["proof (prove)\nusing this:\n  w = w \\<sqinter> - x \\<squnion> w \\<sqinter> - - x\n\ngoal (1 subgoal):\n 1. w \\<le> - x \\<squnion> - y", "using 1"], ["proof (prove)\nusing this:\n  w = w \\<sqinter> - x \\<squnion> w \\<sqinter> - - x\n  w \\<sqinter> - - x \\<le> - y\n\ngoal (1 subgoal):\n 1. w \\<le> - x \\<squnion> - y", "by (metis inf_le2 sup.mono)"], ["proof (state)\nthis:\n  w \\<le> - x \\<squnion> - y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<le> - x \\<squnion> - y \\<Longrightarrow>\n       xa \\<sqinter> (x \\<sqinter> y) = bot", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<le> - x \\<squnion> - y \\<Longrightarrow>\n       xa \\<sqinter> (x \\<sqinter> y) = bot", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<le> - x \\<squnion> - y \\<Longrightarrow>\n       xa \\<sqinter> (x \\<sqinter> y) = bot", "assume \"w \\<le> -x \\<squnion> -y\""], ["proof (state)\nthis:\n  w \\<le> - x \\<squnion> - y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<le> - x \\<squnion> - y \\<Longrightarrow>\n       xa \\<sqinter> (x \\<sqinter> y) = bot", "thus \"w \\<sqinter> (x \\<sqinter> y) = bot\""], ["proof (prove)\nusing this:\n  w \\<le> - x \\<squnion> - y\n\ngoal (1 subgoal):\n 1. w \\<sqinter> (x \\<sqinter> y) = bot", "using order_trans p_supdist_inf pseudo_complement"], ["proof (prove)\nusing this:\n  w \\<le> - x \\<squnion> - y\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  - ?x \\<squnion> - ?y \\<le> - (?x \\<sqinter> ?y)\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. w \\<sqinter> (x \\<sqinter> y) = bot", "by blast"], ["proof (state)\nthis:\n  w \\<sqinter> (x \\<sqinter> y) = bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pp_dist_sup [simp]:\n  \"--(x \\<squnion> y) = --x \\<squnion> --y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - (x \\<squnion> y) = - - x \\<squnion> - - y", "by simp"], ["", "lemma regular_closed_sup:\n  \"regular x \\<Longrightarrow> regular y \\<Longrightarrow> regular (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>regular x; regular y\\<rbrakk>\n    \\<Longrightarrow> regular (x \\<squnion> y)", "by simp"], ["", "text \\<open>\nThe regular elements are precisely the ones having a complement.\n\\<close>"], ["", "lemma regular_complemented_iff:\n  \"regular x \\<longleftrightarrow> complemented x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular x = complemented x", "by (metis inf_p stone complemented_regular)"], ["", "lemma selection_closed_sup:\n  \"selection s x \\<Longrightarrow> selection t x \\<Longrightarrow> selection (s \\<squnion> t) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>selection s x; selection t x\\<rbrakk>\n    \\<Longrightarrow> selection (s \\<squnion> t) x", "by (simp add: inf_sup_distrib2)"], ["", "lemma huntington_3_pp [simp]:\n  \"-(-x \\<squnion> -y) \\<squnion> -(-x \\<squnion> y) = --x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (- x \\<squnion> - y) \\<squnion> - (- x \\<squnion> y) = - - x", "by (metis p_dist_inf p_inf sup.commute sup_bot_left sup_inf_distrib1)"], ["", "lemma maddux_3_3 [simp]:\n  \"-(x \\<squnion> y) \\<squnion> -(x \\<squnion> -y) = -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) \\<squnion> - (x \\<squnion> - y) = - x", "by (simp add: sup_commute sup_inf_distrib1)"], ["", "lemma maddux_3_11_pp:\n  \"(x \\<sqinter> -y) \\<squnion> (x \\<sqinter> --y) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<squnion> x \\<sqinter> - - y = x", "by (metis inf_sup_distrib1 inf_top_right stone)"], ["", "lemma maddux_3_19_pp:\n  \"(-x \\<sqinter> y) \\<squnion> (--x \\<sqinter> z) = (--x \\<squnion> y) \\<sqinter> (-x \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n    (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n    (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "have \"(--x \\<squnion> y) \\<sqinter> (-x \\<squnion> z) = (--x \\<sqinter> z) \\<squnion> (y \\<sqinter> -x) \\<squnion> (y \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z) =\n    - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion> y \\<sqinter> z", "by (simp add: inf.commute inf_sup_distrib1 sup.assoc)"], ["proof (state)\nthis:\n  (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z) =\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion> y \\<sqinter> z\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n    (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "also"], ["proof (state)\nthis:\n  (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z) =\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion> y \\<sqinter> z\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n    (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "have \"... = (--x \\<sqinter> z) \\<squnion> (y \\<sqinter> -x) \\<squnion> (y \\<sqinter> z \\<sqinter> (-x \\<squnion> --x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion>\n    y \\<sqinter> z =\n    - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion>\n    y \\<sqinter> z \\<sqinter> (- x \\<squnion> - - x)", "by simp"], ["proof (state)\nthis:\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion> y \\<sqinter> z =\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion>\n  y \\<sqinter> z \\<sqinter> (- x \\<squnion> - - x)\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n    (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "also"], ["proof (state)\nthis:\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion> y \\<sqinter> z =\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion>\n  y \\<sqinter> z \\<sqinter> (- x \\<squnion> - - x)\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n    (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "have \"... = (--x \\<sqinter> z) \\<squnion> ((y \\<sqinter> -x) \\<squnion> (y \\<sqinter> -x \\<sqinter> z)) \\<squnion> (y \\<sqinter> z \\<sqinter> --x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion>\n    y \\<sqinter> z \\<sqinter> (- x \\<squnion> - - x) =\n    - - x \\<sqinter> z \\<squnion>\n    (y \\<sqinter> - x \\<squnion> y \\<sqinter> - x \\<sqinter> z) \\<squnion>\n    y \\<sqinter> z \\<sqinter> - - x", "using inf_sup_distrib1 sup_assoc inf_commute inf_assoc"], ["proof (prove)\nusing this:\n  ?x \\<sqinter> (?y \\<squnion> ?z) =\n  ?x \\<sqinter> ?y \\<squnion> ?x \\<sqinter> ?z\n  ?x \\<squnion> ?y \\<squnion> ?z = ?x \\<squnion> (?y \\<squnion> ?z)\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n  ?x \\<sqinter> ?y \\<sqinter> ?z = ?x \\<sqinter> (?y \\<sqinter> ?z)\n\ngoal (1 subgoal):\n 1. - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion>\n    y \\<sqinter> z \\<sqinter> (- x \\<squnion> - - x) =\n    - - x \\<sqinter> z \\<squnion>\n    (y \\<sqinter> - x \\<squnion> y \\<sqinter> - x \\<sqinter> z) \\<squnion>\n    y \\<sqinter> z \\<sqinter> - - x", "by presburger"], ["proof (state)\nthis:\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion>\n  y \\<sqinter> z \\<sqinter> (- x \\<squnion> - - x) =\n  - - x \\<sqinter> z \\<squnion>\n  (y \\<sqinter> - x \\<squnion> y \\<sqinter> - x \\<sqinter> z) \\<squnion>\n  y \\<sqinter> z \\<sqinter> - - x\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n    (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "also"], ["proof (state)\nthis:\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion>\n  y \\<sqinter> z \\<sqinter> (- x \\<squnion> - - x) =\n  - - x \\<sqinter> z \\<squnion>\n  (y \\<sqinter> - x \\<squnion> y \\<sqinter> - x \\<sqinter> z) \\<squnion>\n  y \\<sqinter> z \\<sqinter> - - x\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n    (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "have \"... = (--x \\<sqinter> z) \\<squnion> (y \\<sqinter> -x) \\<squnion> (y \\<sqinter> z \\<sqinter> --x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x \\<sqinter> z \\<squnion>\n    (y \\<sqinter> - x \\<squnion> y \\<sqinter> - x \\<sqinter> z) \\<squnion>\n    y \\<sqinter> z \\<sqinter> - - x =\n    - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion>\n    y \\<sqinter> z \\<sqinter> - - x", "by simp"], ["proof (state)\nthis:\n  - - x \\<sqinter> z \\<squnion>\n  (y \\<sqinter> - x \\<squnion> y \\<sqinter> - x \\<sqinter> z) \\<squnion>\n  y \\<sqinter> z \\<sqinter> - - x =\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion>\n  y \\<sqinter> z \\<sqinter> - - x\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n    (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "also"], ["proof (state)\nthis:\n  - - x \\<sqinter> z \\<squnion>\n  (y \\<sqinter> - x \\<squnion> y \\<sqinter> - x \\<sqinter> z) \\<squnion>\n  y \\<sqinter> z \\<sqinter> - - x =\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion>\n  y \\<sqinter> z \\<sqinter> - - x\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n    (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "have \"... = ((--x \\<sqinter> z) \\<squnion> (--x \\<sqinter> z \\<sqinter> y)) \\<squnion> (y \\<sqinter> -x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion>\n    y \\<sqinter> z \\<sqinter> - - x =\n    - - x \\<sqinter> z \\<squnion> - - x \\<sqinter> z \\<sqinter> y \\<squnion>\n    y \\<sqinter> - x", "by (simp add: inf_assoc inf_commute sup.left_commute sup_commute)"], ["proof (state)\nthis:\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion>\n  y \\<sqinter> z \\<sqinter> - - x =\n  - - x \\<sqinter> z \\<squnion> - - x \\<sqinter> z \\<sqinter> y \\<squnion>\n  y \\<sqinter> - x\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n    (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "also"], ["proof (state)\nthis:\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x \\<squnion>\n  y \\<sqinter> z \\<sqinter> - - x =\n  - - x \\<sqinter> z \\<squnion> - - x \\<sqinter> z \\<sqinter> y \\<squnion>\n  y \\<sqinter> - x\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n    (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "have \"... = (--x \\<sqinter> z) \\<squnion> (y \\<sqinter> -x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x \\<sqinter> z \\<squnion> - - x \\<sqinter> z \\<sqinter> y \\<squnion>\n    y \\<sqinter> - x =\n    - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x", "by simp"], ["proof (state)\nthis:\n  - - x \\<sqinter> z \\<squnion> - - x \\<sqinter> z \\<sqinter> y \\<squnion>\n  y \\<sqinter> - x =\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n    (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "finally"], ["proof (chain)\npicking this:\n  (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z) =\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x", "show ?thesis"], ["proof (prove)\nusing this:\n  (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z) =\n  - - x \\<sqinter> z \\<squnion> y \\<sqinter> - x\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n    (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "by (simp add: inf_commute sup_commute)"], ["proof (state)\nthis:\n  - x \\<sqinter> y \\<squnion> - - x \\<sqinter> z =\n  (- - x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compl_inter_eq_pp:\n  \"--x \\<sqinter> y = --x \\<sqinter> z \\<Longrightarrow> -x \\<sqinter> y = -x \\<sqinter> z \\<Longrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- - x \\<sqinter> y = - - x \\<sqinter> z;\n     - x \\<sqinter> y = - x \\<sqinter> z\\<rbrakk>\n    \\<Longrightarrow> y = z", "by (metis inf_commute inf_p inf_sup_distrib1 inf_top.right_neutral p_bot p_dist_inf)"], ["", "lemma maddux_3_21_pp [simp]:\n  \"--x \\<squnion> (-x \\<sqinter> y) = --x \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x \\<squnion> - x \\<sqinter> y = - - x \\<squnion> y", "by (simp add: sup.commute sup_inf_distrib1)"], ["", "lemma shunting_2_pp:\n  \"x \\<le> --y \\<longleftrightarrow> -x \\<squnion> --y = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> - - y) = (- x \\<squnion> - - y = top)", "by (metis inf_top_left p_bot p_dist_inf pseudo_complement)"], ["", "lemma shunting_p:\n  \"x \\<sqinter> y \\<le> -z \\<longleftrightarrow> x \\<le> -z \\<squnion> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y \\<le> - z) = (x \\<le> - z \\<squnion> - y)", "by (metis inf.assoc p_dist_inf p_shunting_swap pseudo_complement)"], ["", "text \\<open>\nThe following weak shunting property is interesting as it does not require the element \\<open>z\\<close> on the right-hand side to be regular.\n\\<close>"], ["", "lemma shunting_var_p:\n  \"x \\<sqinter> -y \\<le> z \\<longleftrightarrow> x \\<le> z \\<squnion> --y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> - y \\<le> z) = (x \\<le> z \\<squnion> - - y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<sqinter> - y \\<le> z \\<Longrightarrow> x \\<le> z \\<squnion> - - y\n 2. x \\<le> z \\<squnion> - - y \\<Longrightarrow> x \\<sqinter> - y \\<le> z", "assume \"x \\<sqinter> -y \\<le> z\""], ["proof (state)\nthis:\n  x \\<sqinter> - y \\<le> z\n\ngoal (2 subgoals):\n 1. x \\<sqinter> - y \\<le> z \\<Longrightarrow> x \\<le> z \\<squnion> - - y\n 2. x \\<le> z \\<squnion> - - y \\<Longrightarrow> x \\<sqinter> - y \\<le> z", "hence \"z \\<squnion> --y = --y \\<squnion> (z \\<squnion> x \\<sqinter> -y)\""], ["proof (prove)\nusing this:\n  x \\<sqinter> - y \\<le> z\n\ngoal (1 subgoal):\n 1. z \\<squnion> - - y = - - y \\<squnion> (z \\<squnion> x \\<sqinter> - y)", "by (simp add: sup.absorb1 sup.commute)"], ["proof (state)\nthis:\n  z \\<squnion> - - y = - - y \\<squnion> (z \\<squnion> x \\<sqinter> - y)\n\ngoal (2 subgoals):\n 1. x \\<sqinter> - y \\<le> z \\<Longrightarrow> x \\<le> z \\<squnion> - - y\n 2. x \\<le> z \\<squnion> - - y \\<Longrightarrow> x \\<sqinter> - y \\<le> z", "thus \"x \\<le> z \\<squnion> --y\""], ["proof (prove)\nusing this:\n  z \\<squnion> - - y = - - y \\<squnion> (z \\<squnion> x \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. x \\<le> z \\<squnion> - - y", "by (metis inf_commute maddux_3_21_pp sup.commute sup.left_commute sup_left_divisibility)"], ["proof (state)\nthis:\n  x \\<le> z \\<squnion> - - y\n\ngoal (1 subgoal):\n 1. x \\<le> z \\<squnion> - - y \\<Longrightarrow> x \\<sqinter> - y \\<le> z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> z \\<squnion> - - y \\<Longrightarrow> x \\<sqinter> - y \\<le> z", "assume \"x \\<le> z \\<squnion> --y\""], ["proof (state)\nthis:\n  x \\<le> z \\<squnion> - - y\n\ngoal (1 subgoal):\n 1. x \\<le> z \\<squnion> - - y \\<Longrightarrow> x \\<sqinter> - y \\<le> z", "thus \"x \\<sqinter> -y \\<le> z\""], ["proof (prove)\nusing this:\n  x \\<le> z \\<squnion> - - y\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<le> z", "by (metis inf.mono maddux_3_12 sup_ge2)"], ["proof (state)\nthis:\n  x \\<sqinter> - y \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Whether conjugate_char_2_pp can be proved in pd_algebra or in p_algebra is unknown. *)"], ["", "lemma conjugate_char_2_pp:\n  \"conjugate f g \\<longleftrightarrow> f bot = bot \\<and> g bot = bot \\<and> (\\<forall>x y . f x \\<sqinter> y \\<le> --(f(x \\<sqinter> --(g y))) \\<and> g y \\<sqinter> x \\<le> --(g(y \\<sqinter> --(f x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate f g =\n    (f bot = bot \\<and>\n     g bot = bot \\<and>\n     (\\<forall>x y.\n         f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n         g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. conjugate f g \\<Longrightarrow>\n    f bot = bot \\<and>\n    g bot = bot \\<and>\n    (\\<forall>x y.\n        f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n        g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x))\n 2. f bot = bot \\<and>\n    g bot = bot \\<and>\n    (\\<forall>x y.\n        f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n        g y \\<sqinter> x\n        \\<le> - - g (y \\<sqinter> - - f x)) \\<Longrightarrow>\n    conjugate f g", "assume 1: \"conjugate f g\""], ["proof (state)\nthis:\n  conjugate f g\n\ngoal (2 subgoals):\n 1. conjugate f g \\<Longrightarrow>\n    f bot = bot \\<and>\n    g bot = bot \\<and>\n    (\\<forall>x y.\n        f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n        g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x))\n 2. f bot = bot \\<and>\n    g bot = bot \\<and>\n    (\\<forall>x y.\n        f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n        g y \\<sqinter> x\n        \\<le> - - g (y \\<sqinter> - - f x)) \\<Longrightarrow>\n    conjugate f g", "hence 2: \"dual_additive (uminus \\<circ> g)\""], ["proof (prove)\nusing this:\n  conjugate f g\n\ngoal (1 subgoal):\n 1. dual_additive (uminus \\<circ> g)", "using conjugate_symmetric conjugate_dual_additive"], ["proof (prove)\nusing this:\n  conjugate f g\n  conjugate ?f ?g \\<Longrightarrow> conjugate ?g ?f\n  conjugate ?f ?g \\<Longrightarrow> dual_additive (uminus \\<circ> ?f)\n\ngoal (1 subgoal):\n 1. dual_additive (uminus \\<circ> g)", "by auto"], ["proof (state)\nthis:\n  dual_additive (uminus \\<circ> g)\n\ngoal (2 subgoals):\n 1. conjugate f g \\<Longrightarrow>\n    f bot = bot \\<and>\n    g bot = bot \\<and>\n    (\\<forall>x y.\n        f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n        g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x))\n 2. f bot = bot \\<and>\n    g bot = bot \\<and>\n    (\\<forall>x y.\n        f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n        g y \\<sqinter> x\n        \\<le> - - g (y \\<sqinter> - - f x)) \\<Longrightarrow>\n    conjugate f g", "show \"f bot = bot \\<and> g bot = bot \\<and> (\\<forall>x y . f x \\<sqinter> y \\<le> --(f(x \\<sqinter> --(g y))) \\<and> g y \\<sqinter> x \\<le> --(g(y \\<sqinter> --(f x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f bot = bot \\<and>\n    g bot = bot \\<and>\n    (\\<forall>x y.\n        f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n        g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x))", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. f bot = bot\n 2. g bot = bot\n 3. \\<forall>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "show \"f bot = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f bot = bot", "using 1"], ["proof (prove)\nusing this:\n  conjugate f g\n\ngoal (1 subgoal):\n 1. f bot = bot", "by (metis conjugate_def inf_idem inf_bot_left)"], ["proof (state)\nthis:\n  f bot = bot\n\ngoal (2 subgoals):\n 1. g bot = bot\n 2. \\<forall>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. g bot = bot\n 2. \\<forall>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "show \"g bot = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g bot = bot", "using 1"], ["proof (prove)\nusing this:\n  conjugate f g\n\ngoal (1 subgoal):\n 1. g bot = bot", "by (metis conjugate_def inf_idem inf_bot_right)"], ["proof (state)\nthis:\n  g bot = bot\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "show \"\\<forall>x y . f x \\<sqinter> y \\<le> --(f(x \\<sqinter> --(g y))) \\<and> g y \\<sqinter> x \\<le> --(g(y \\<sqinter> --(f x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "have 3: \"y \\<le> -(f(x \\<sqinter> -(g y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> - f (x \\<sqinter> - g y)", "using 1"], ["proof (prove)\nusing this:\n  conjugate f g\n\ngoal (1 subgoal):\n 1. y \\<le> - f (x \\<sqinter> - g y)", "by (simp add: conjugate_def pseudo_complement inf_commute)"], ["proof (state)\nthis:\n  y \\<le> - f (x \\<sqinter> - g y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "have 4: \"x \\<le> -(g(y \\<sqinter> -(f x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - g (y \\<sqinter> - f x)", "using 1 conjugate_def inf.commute pseudo_complement"], ["proof (prove)\nusing this:\n  conjugate f g\n  conjugate ?f ?g \\<equiv>\n  \\<forall>x y. (?f x \\<sqinter> y = bot) = (x \\<sqinter> ?g y = bot)\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. x \\<le> - g (y \\<sqinter> - f x)", "by fastforce"], ["proof (state)\nthis:\n  x \\<le> - g (y \\<sqinter> - f x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "have \"y \\<sqinter> -(f(x \\<sqinter> --(g y))) = y \\<sqinter> -(f(x \\<sqinter> -(g y))) \\<sqinter> -(f(x \\<sqinter> --(g y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> - f (x \\<sqinter> - - g y) =\n    y \\<sqinter> - f (x \\<sqinter> - g y) \\<sqinter>\n    - f (x \\<sqinter> - - g y)", "using 3"], ["proof (prove)\nusing this:\n  y \\<le> - f (x \\<sqinter> - g y)\n\ngoal (1 subgoal):\n 1. y \\<sqinter> - f (x \\<sqinter> - - g y) =\n    y \\<sqinter> - f (x \\<sqinter> - g y) \\<sqinter>\n    - f (x \\<sqinter> - - g y)", "by (simp add: inf.le_iff_sup inf_commute)"], ["proof (state)\nthis:\n  y \\<sqinter> - f (x \\<sqinter> - - g y) =\n  y \\<sqinter> - f (x \\<sqinter> - g y) \\<sqinter>\n  - f (x \\<sqinter> - - g y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "also"], ["proof (state)\nthis:\n  y \\<sqinter> - f (x \\<sqinter> - - g y) =\n  y \\<sqinter> - f (x \\<sqinter> - g y) \\<sqinter>\n  - f (x \\<sqinter> - - g y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "have \"... = y \\<sqinter> -(f((x \\<sqinter> -(g y)) \\<squnion> (x \\<sqinter> --(g y))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> - f (x \\<sqinter> - g y) \\<sqinter>\n    - f (x \\<sqinter> - - g y) =\n    y \\<sqinter> - f (x \\<sqinter> - g y \\<squnion> x \\<sqinter> - - g y)", "using 1 conjugate_dual_additive dual_additive_def inf_assoc"], ["proof (prove)\nusing this:\n  conjugate f g\n  conjugate ?f ?g \\<Longrightarrow> dual_additive (uminus \\<circ> ?f)\n  dual_additive ?f \\<equiv>\n  \\<forall>x y. ?f (x \\<squnion> y) = ?f x \\<sqinter> ?f y\n  ?x \\<sqinter> ?y \\<sqinter> ?z = ?x \\<sqinter> (?y \\<sqinter> ?z)\n\ngoal (1 subgoal):\n 1. y \\<sqinter> - f (x \\<sqinter> - g y) \\<sqinter>\n    - f (x \\<sqinter> - - g y) =\n    y \\<sqinter> - f (x \\<sqinter> - g y \\<squnion> x \\<sqinter> - - g y)", "by auto"], ["proof (state)\nthis:\n  y \\<sqinter> - f (x \\<sqinter> - g y) \\<sqinter>\n  - f (x \\<sqinter> - - g y) =\n  y \\<sqinter> - f (x \\<sqinter> - g y \\<squnion> x \\<sqinter> - - g y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "also"], ["proof (state)\nthis:\n  y \\<sqinter> - f (x \\<sqinter> - g y) \\<sqinter>\n  - f (x \\<sqinter> - - g y) =\n  y \\<sqinter> - f (x \\<sqinter> - g y \\<squnion> x \\<sqinter> - - g y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "have \"... = y \\<sqinter> -(f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> - f (x \\<sqinter> - g y \\<squnion> x \\<sqinter> - - g y) =\n    y \\<sqinter> - f x", "by (simp add: maddux_3_11_pp)"], ["proof (state)\nthis:\n  y \\<sqinter> - f (x \\<sqinter> - g y \\<squnion> x \\<sqinter> - - g y) =\n  y \\<sqinter> - f x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "also"], ["proof (state)\nthis:\n  y \\<sqinter> - f (x \\<sqinter> - g y \\<squnion> x \\<sqinter> - - g y) =\n  y \\<sqinter> - f x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "have \"... \\<le> -(f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> - f x \\<le> - f x", "by simp"], ["proof (state)\nthis:\n  y \\<sqinter> - f x \\<le> - f x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "finally"], ["proof (chain)\npicking this:\n  y \\<sqinter> - f (x \\<sqinter> - - g y) \\<le> - f x", "have 5: \"f x \\<sqinter> y \\<le> --(f(x \\<sqinter> --(g y)))\""], ["proof (prove)\nusing this:\n  y \\<sqinter> - f (x \\<sqinter> - - g y) \\<le> - f x\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y)", "by (simp add: inf_commute p_shunting_swap)"], ["proof (state)\nthis:\n  f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "have \"x \\<sqinter> -(g(y \\<sqinter> --(f x))) = x \\<sqinter> -(g(y \\<sqinter> -(f x))) \\<sqinter> -(g(y \\<sqinter> --(f x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - g (y \\<sqinter> - - f x) =\n    x \\<sqinter> - g (y \\<sqinter> - f x) \\<sqinter>\n    - g (y \\<sqinter> - - f x)", "using 4"], ["proof (prove)\nusing this:\n  x \\<le> - g (y \\<sqinter> - f x)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - g (y \\<sqinter> - - f x) =\n    x \\<sqinter> - g (y \\<sqinter> - f x) \\<sqinter>\n    - g (y \\<sqinter> - - f x)", "by (simp add: inf.le_iff_sup inf_commute)"], ["proof (state)\nthis:\n  x \\<sqinter> - g (y \\<sqinter> - - f x) =\n  x \\<sqinter> - g (y \\<sqinter> - f x) \\<sqinter>\n  - g (y \\<sqinter> - - f x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "also"], ["proof (state)\nthis:\n  x \\<sqinter> - g (y \\<sqinter> - - f x) =\n  x \\<sqinter> - g (y \\<sqinter> - f x) \\<sqinter>\n  - g (y \\<sqinter> - - f x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "have \"... = x \\<sqinter> -(g((y \\<sqinter> -(f x)) \\<squnion> (y \\<sqinter> --(f x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - g (y \\<sqinter> - f x) \\<sqinter>\n    - g (y \\<sqinter> - - f x) =\n    x \\<sqinter> - g (y \\<sqinter> - f x \\<squnion> y \\<sqinter> - - f x)", "using 2"], ["proof (prove)\nusing this:\n  dual_additive (uminus \\<circ> g)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - g (y \\<sqinter> - f x) \\<sqinter>\n    - g (y \\<sqinter> - - f x) =\n    x \\<sqinter> - g (y \\<sqinter> - f x \\<squnion> y \\<sqinter> - - f x)", "by (simp add: dual_additive_def inf_assoc)"], ["proof (state)\nthis:\n  x \\<sqinter> - g (y \\<sqinter> - f x) \\<sqinter>\n  - g (y \\<sqinter> - - f x) =\n  x \\<sqinter> - g (y \\<sqinter> - f x \\<squnion> y \\<sqinter> - - f x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "also"], ["proof (state)\nthis:\n  x \\<sqinter> - g (y \\<sqinter> - f x) \\<sqinter>\n  - g (y \\<sqinter> - - f x) =\n  x \\<sqinter> - g (y \\<sqinter> - f x \\<squnion> y \\<sqinter> - - f x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "have \"... = x \\<sqinter> -(g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - g (y \\<sqinter> - f x \\<squnion> y \\<sqinter> - - f x) =\n    x \\<sqinter> - g y", "by (simp add: maddux_3_11_pp)"], ["proof (state)\nthis:\n  x \\<sqinter> - g (y \\<sqinter> - f x \\<squnion> y \\<sqinter> - - f x) =\n  x \\<sqinter> - g y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "also"], ["proof (state)\nthis:\n  x \\<sqinter> - g (y \\<sqinter> - f x \\<squnion> y \\<sqinter> - - f x) =\n  x \\<sqinter> - g y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "have \"... \\<le> -(g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - g y \\<le> - g y", "by simp"], ["proof (state)\nthis:\n  x \\<sqinter> - g y \\<le> - g y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "finally"], ["proof (chain)\npicking this:\n  x \\<sqinter> - g (y \\<sqinter> - - f x) \\<le> - g y", "have \"g y \\<sqinter> x \\<le> --(g(y \\<sqinter> --(f x)))\""], ["proof (prove)\nusing this:\n  x \\<sqinter> - g (y \\<sqinter> - - f x) \\<le> - g y\n\ngoal (1 subgoal):\n 1. g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "by (simp add: inf_commute p_shunting_swap)"], ["proof (state)\nthis:\n  g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n       g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "thus \"f x \\<sqinter> y \\<le> --(f(x \\<sqinter> --(g y))) \\<and> g y \\<sqinter> x \\<le> --(g(y \\<sqinter> --(f x)))\""], ["proof (prove)\nusing this:\n  g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "using 5"], ["proof (prove)\nusing this:\n  g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)\n  f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y)\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)", "by simp"], ["proof (state)\nthis:\n  f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n  g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y.\n     f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n     g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f bot = bot \\<and>\n  g bot = bot \\<and>\n  (\\<forall>x y.\n      f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n      g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x))\n\ngoal (1 subgoal):\n 1. f bot = bot \\<and>\n    g bot = bot \\<and>\n    (\\<forall>x y.\n        f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n        g y \\<sqinter> x\n        \\<le> - - g (y \\<sqinter> - - f x)) \\<Longrightarrow>\n    conjugate f g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f bot = bot \\<and>\n    g bot = bot \\<and>\n    (\\<forall>x y.\n        f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n        g y \\<sqinter> x\n        \\<le> - - g (y \\<sqinter> - - f x)) \\<Longrightarrow>\n    conjugate f g", "assume \"f bot = bot \\<and> g bot = bot \\<and> (\\<forall>x y . f x \\<sqinter> y \\<le> --(f(x \\<sqinter> --(g y))) \\<and> g y \\<sqinter> x \\<le> --(g(y \\<sqinter> --(f x))))\""], ["proof (state)\nthis:\n  f bot = bot \\<and>\n  g bot = bot \\<and>\n  (\\<forall>x y.\n      f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n      g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x))\n\ngoal (1 subgoal):\n 1. f bot = bot \\<and>\n    g bot = bot \\<and>\n    (\\<forall>x y.\n        f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n        g y \\<sqinter> x\n        \\<le> - - g (y \\<sqinter> - - f x)) \\<Longrightarrow>\n    conjugate f g", "thus \"conjugate f g\""], ["proof (prove)\nusing this:\n  f bot = bot \\<and>\n  g bot = bot \\<and>\n  (\\<forall>x y.\n      f x \\<sqinter> y \\<le> - - f (x \\<sqinter> - - g y) \\<and>\n      g y \\<sqinter> x \\<le> - - g (y \\<sqinter> - - f x))\n\ngoal (1 subgoal):\n 1. conjugate f g", "by (unfold conjugate_def, metis inf_commute le_bot pp_inf_bot_iff regular_closed_bot)"], ["proof (state)\nthis:\n  conjugate f g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conjugate_char_2_pp_additive:\n  assumes \"conjugate f g\"\n      and \"additive f\"\n      and \"additive g\"\n    shows \"f x \\<sqinter> y \\<le> f(x \\<sqinter> --(g y)) \\<and> g y \\<sqinter> x \\<le> g(y \\<sqinter> --(f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "have \"f x \\<sqinter> y = f ((x \\<sqinter> --g y) \\<squnion> (x \\<sqinter> -g y)) \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<sqinter> y =\n    f (x \\<sqinter> - - g y \\<squnion> x \\<sqinter> - g y) \\<sqinter> y", "by (simp add: sup.commute sup_inf_distrib1)"], ["proof (state)\nthis:\n  f x \\<sqinter> y =\n  f (x \\<sqinter> - - g y \\<squnion> x \\<sqinter> - g y) \\<sqinter> y\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "also"], ["proof (state)\nthis:\n  f x \\<sqinter> y =\n  f (x \\<sqinter> - - g y \\<squnion> x \\<sqinter> - g y) \\<sqinter> y\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "have \"... = (f (x \\<sqinter> --g y) \\<sqinter> y) \\<squnion> (f (x \\<sqinter> -g y) \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x \\<sqinter> - - g y \\<squnion> x \\<sqinter> - g y) \\<sqinter> y =\n    f (x \\<sqinter> - - g y) \\<sqinter> y \\<squnion>\n    f (x \\<sqinter> - g y) \\<sqinter> y", "using assms(2) additive_def inf_sup_distrib2"], ["proof (prove)\nusing this:\n  additive f\n  additive ?f \\<equiv>\n  \\<forall>x y. ?f (x \\<squnion> y) = ?f x \\<squnion> ?f y\n  (?y \\<squnion> ?z) \\<sqinter> ?x =\n  ?y \\<sqinter> ?x \\<squnion> ?z \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. f (x \\<sqinter> - - g y \\<squnion> x \\<sqinter> - g y) \\<sqinter> y =\n    f (x \\<sqinter> - - g y) \\<sqinter> y \\<squnion>\n    f (x \\<sqinter> - g y) \\<sqinter> y", "by auto"], ["proof (state)\nthis:\n  f (x \\<sqinter> - - g y \\<squnion> x \\<sqinter> - g y) \\<sqinter> y =\n  f (x \\<sqinter> - - g y) \\<sqinter> y \\<squnion>\n  f (x \\<sqinter> - g y) \\<sqinter> y\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "also"], ["proof (state)\nthis:\n  f (x \\<sqinter> - - g y \\<squnion> x \\<sqinter> - g y) \\<sqinter> y =\n  f (x \\<sqinter> - - g y) \\<sqinter> y \\<squnion>\n  f (x \\<sqinter> - g y) \\<sqinter> y\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "have \"... = f (x \\<sqinter> --g y) \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x \\<sqinter> - - g y) \\<sqinter> y \\<squnion>\n    f (x \\<sqinter> - g y) \\<sqinter> y =\n    f (x \\<sqinter> - - g y) \\<sqinter> y", "by (metis assms(1) conjugate_def inf_le2 pseudo_complement sup_bot.right_neutral)"], ["proof (state)\nthis:\n  f (x \\<sqinter> - - g y) \\<sqinter> y \\<squnion>\n  f (x \\<sqinter> - g y) \\<sqinter> y =\n  f (x \\<sqinter> - - g y) \\<sqinter> y\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "finally"], ["proof (chain)\npicking this:\n  f x \\<sqinter> y = f (x \\<sqinter> - - g y) \\<sqinter> y", "have 2: \"f x \\<sqinter> y \\<le> f (x \\<sqinter> --g y)\""], ["proof (prove)\nusing this:\n  f x \\<sqinter> y = f (x \\<sqinter> - - g y) \\<sqinter> y\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y)", "by simp"], ["proof (state)\nthis:\n  f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y)\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "have \"g y \\<sqinter> x = g ((y \\<sqinter> --f x) \\<squnion> (y \\<sqinter> -f x)) \\<sqinter> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g y \\<sqinter> x =\n    g (y \\<sqinter> - - f x \\<squnion> y \\<sqinter> - f x) \\<sqinter> x", "by (simp add: sup.commute sup_inf_distrib1)"], ["proof (state)\nthis:\n  g y \\<sqinter> x =\n  g (y \\<sqinter> - - f x \\<squnion> y \\<sqinter> - f x) \\<sqinter> x\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "also"], ["proof (state)\nthis:\n  g y \\<sqinter> x =\n  g (y \\<sqinter> - - f x \\<squnion> y \\<sqinter> - f x) \\<sqinter> x\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "have \"... = (g (y \\<sqinter> --f x) \\<sqinter> x) \\<squnion> (g (y \\<sqinter> -f x) \\<sqinter> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (y \\<sqinter> - - f x \\<squnion> y \\<sqinter> - f x) \\<sqinter> x =\n    g (y \\<sqinter> - - f x) \\<sqinter> x \\<squnion>\n    g (y \\<sqinter> - f x) \\<sqinter> x", "using assms(3) additive_def inf_sup_distrib2"], ["proof (prove)\nusing this:\n  additive g\n  additive ?f \\<equiv>\n  \\<forall>x y. ?f (x \\<squnion> y) = ?f x \\<squnion> ?f y\n  (?y \\<squnion> ?z) \\<sqinter> ?x =\n  ?y \\<sqinter> ?x \\<squnion> ?z \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. g (y \\<sqinter> - - f x \\<squnion> y \\<sqinter> - f x) \\<sqinter> x =\n    g (y \\<sqinter> - - f x) \\<sqinter> x \\<squnion>\n    g (y \\<sqinter> - f x) \\<sqinter> x", "by auto"], ["proof (state)\nthis:\n  g (y \\<sqinter> - - f x \\<squnion> y \\<sqinter> - f x) \\<sqinter> x =\n  g (y \\<sqinter> - - f x) \\<sqinter> x \\<squnion>\n  g (y \\<sqinter> - f x) \\<sqinter> x\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "also"], ["proof (state)\nthis:\n  g (y \\<sqinter> - - f x \\<squnion> y \\<sqinter> - f x) \\<sqinter> x =\n  g (y \\<sqinter> - - f x) \\<sqinter> x \\<squnion>\n  g (y \\<sqinter> - f x) \\<sqinter> x\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "have \"... = g (y \\<sqinter> --f x) \\<sqinter> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (y \\<sqinter> - - f x) \\<sqinter> x \\<squnion>\n    g (y \\<sqinter> - f x) \\<sqinter> x =\n    g (y \\<sqinter> - - f x) \\<sqinter> x", "by (metis assms(1) conjugate_def inf.cobounded2 pseudo_complement sup_bot.right_neutral inf_commute)"], ["proof (state)\nthis:\n  g (y \\<sqinter> - - f x) \\<sqinter> x \\<squnion>\n  g (y \\<sqinter> - f x) \\<sqinter> x =\n  g (y \\<sqinter> - - f x) \\<sqinter> x\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "finally"], ["proof (chain)\npicking this:\n  g y \\<sqinter> x = g (y \\<sqinter> - - f x) \\<sqinter> x", "have \"g y \\<sqinter> x \\<le> g (y \\<sqinter> --f x)\""], ["proof (prove)\nusing this:\n  g y \\<sqinter> x = g (y \\<sqinter> - - f x) \\<sqinter> x\n\ngoal (1 subgoal):\n 1. g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "by simp"], ["proof (state)\nthis:\n  g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "using 2"], ["proof (prove)\nusing this:\n  g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)\n  f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y)\n\ngoal (1 subgoal):\n 1. f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n    g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)", "by simp"], ["proof (state)\nthis:\n  f x \\<sqinter> y \\<le> f (x \\<sqinter> - - g y) \\<and>\n  g y \\<sqinter> x \\<le> g (y \\<sqinter> - - f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma compl_le_swap2_iff: \"-x \\<le> y \\<longleftrightarrow> -y \\<le> x\" nitpick [expect=genuine] oops\nlemma huntington_3: \"x = -(-x \\<squnion> -y) \\<squnion> -(-x \\<squnion> y)\" nitpick [expect=genuine] oops\nlemma maddux_3_1: \"x \\<squnion> -x = y \\<squnion> -y\" nitpick [expect=genuine] oops\nlemma maddux_3_4: \"x \\<squnion> (y \\<squnion> -y) = z \\<squnion> -z\" nitpick [expect=genuine] oops\nlemma maddux_3_11: \"x = (x \\<sqinter> y) \\<squnion> (x \\<sqinter> -y)\" nitpick [expect=genuine] oops\nlemma maddux_3_19: \"(-x \\<sqinter> y) \\<squnion> (x \\<sqinter> z) = (x \\<squnion> y) \\<sqinter> (-x \\<squnion> z)\" nitpick [expect=genuine] oops\nlemma compl_inter_eq: \"x \\<sqinter> y = x \\<sqinter> z \\<and> -x \\<sqinter> y = -x \\<sqinter> z \\<longrightarrow> y = z\" nitpick [expect=genuine] oops\nlemma maddux_3_21: \"x \\<squnion> y = x \\<squnion> (-x \\<sqinter> y)\" nitpick [expect=genuine] oops\nlemma shunting_1: \"x \\<le> y \\<longleftrightarrow> x \\<sqinter> -y = bot\" nitpick [expect=genuine] oops\nlemma shunting_2: \"x \\<le> y \\<longleftrightarrow> -x \\<squnion> y = top\" nitpick [expect=genuine] oops\nlemma conjugate_unique: \"conjugate f g \\<and> conjugate f h \\<longrightarrow> g = h\" nitpick [expect=genuine] oops\nlemma conjugate_isotone_pp: \"conjugate f g \\<longrightarrow> isotone f\" nitpick [expect=genuine] oops\nlemma conjugate_char_1: \"conjugate f g \\<longleftrightarrow> (\\<forall>x y . f(x \\<sqinter> -(g y)) \\<le> f x \\<sqinter> -y \\<and> g(y \\<sqinter> -(f x)) \\<le> g y \\<sqinter> -x)\" nitpick [expect=genuine] oops\nlemma conjugate_char_2: \"conjugate f g \\<longleftrightarrow> f bot = bot \\<and> g bot = bot \\<and> (\\<forall>x y . f x \\<sqinter> y \\<le> f(x \\<sqinter> g y) \\<and> g y \\<sqinter> x \\<le> g(y \\<sqinter> f x))\" nitpick [expect=genuine] oops\nlemma shunting: \"x \\<sqinter> y \\<le> z \\<longleftrightarrow> x \\<le> z \\<squnion> -y\" nitpick [expect=genuine] oops\nlemma shunting_var: \"x \\<sqinter> -y \\<le> z \\<longleftrightarrow> x \\<le> z \\<squnion> y\" nitpick [expect=genuine] oops\nlemma sup_compl_top: \"x \\<squnion> -x = top\" nitpick [expect=genuine] oops\nlemma selection_closed_p: \"selection s x \\<longrightarrow> selection (-s) x\" nitpick [expect=genuine] oops\nlemma selection_closed_pp: \"selection s x \\<longrightarrow> selection (--s) x\" nitpick [expect=genuine] oops\n*)"], ["", "end"], ["", "abbreviation stone_algebra_isomorphism :: \"('a::stone_algebra \\<Rightarrow> 'b::stone_algebra) \\<Rightarrow> bool\"\n  where \"stone_algebra_isomorphism f \\<equiv> sup_inf_top_bot_uminus_isomorphism f\""], ["", "text \\<open>\nEvery bounded linear order can be expanded to a Stone algebra.\nThe pseudocomplement takes \\<open>bot\\<close> to the \\<open>top\\<close> and every other element to \\<open>bot\\<close>.\n\\<close>"], ["", "class linorder_stone_algebra_expansion = linorder_lattice_expansion + uminus +\n  assumes uminus_def [simp]: \"-x = (if x = bot then top else bot)\"\nbegin"], ["", "subclass stone_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.stone_algebra (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot top uminus", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "using bot_unique min_def top_le"], ["proof (prove)\nusing this:\n  (?a \\<le> bot) = (?a = bot)\n  min ?a ?b = (if ?a \\<le> ?b then ?a else ?b)\n  top \\<le> ?a \\<Longrightarrow> ?a = top\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "by auto"], ["", "text \\<open>\nThe regular elements are the least and greatest elements.\nAll elements except the least element are dense.\n\\<close>"], ["", "lemma regular_bot_top:\n  \"regular x \\<longleftrightarrow> x = bot \\<or> x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular x = (x = bot \\<or> x = top)", "by simp"], ["", "lemma not_bot_dense:\n  \"x \\<noteq> bot \\<Longrightarrow> --x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> bot \\<Longrightarrow> - - x = top", "by simp"], ["", "end"], ["", "subsection \\<open>Heyting Algebras\\<close>"], ["", "text \\<open>\nIn this section we add a relative pseudocomplement operation to semilattices and to lattices.\n\\<close>"], ["", "subsubsection \\<open>Heyting Semilattices\\<close>"], ["", "text \\<open>\nThe pseudocomplement of an element \\<open>y\\<close> relative to an element \\<open>z\\<close> is the least element whose meet with \\<open>y\\<close> is below \\<open>z\\<close>.\nThis can be stated as a Galois connection.\nSpecialising \\<open>z = bot\\<close> gives (non-relative) pseudocomplements.\nMany properties can already be shown if the underlying structure is just a semilattice.\n\\<close>"], ["", "class implies =\n  fixes implies :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\" (infixl \"\\<leadsto>\" 65)"], ["", "class heyting_semilattice = semilattice_inf + implies +\n  assumes implies_galois: \"x \\<sqinter> y \\<le> z \\<longleftrightarrow> x \\<le> y \\<leadsto> z\"\nbegin"], ["", "lemma implies_below_eq [simp]:\n  \"y \\<sqinter> (x \\<leadsto> y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> (x \\<leadsto> y) = y", "using implies_galois inf.absorb_iff1 inf.cobounded1"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y \\<le> ?z) = (?x \\<le> ?y \\<leadsto> ?z)\n  (?a \\<le> ?b) = (?a \\<sqinter> ?b = ?a)\n  ?a \\<sqinter> ?b \\<le> ?a\n\ngoal (1 subgoal):\n 1. y \\<sqinter> (x \\<leadsto> y) = y", "by blast"], ["", "lemma implies_increasing:\n  \"x \\<le> y \\<leadsto> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<leadsto> x", "by (simp add: inf.orderI)"], ["", "lemma implies_galois_swap:\n  \"x \\<le> y \\<leadsto> z \\<longleftrightarrow> y \\<le> x \\<leadsto> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y \\<leadsto> z) = (y \\<le> x \\<leadsto> z)", "by (metis implies_galois inf_commute)"], ["", "lemma implies_galois_var:\n  \"x \\<sqinter> y \\<le> z \\<longleftrightarrow> y \\<le> x \\<leadsto> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y \\<le> z) = (y \\<le> x \\<leadsto> z)", "by (simp add: implies_galois_swap implies_galois)"], ["", "lemma implies_galois_increasing:\n  \"x \\<le> y \\<leadsto> (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<leadsto> x \\<sqinter> y", "using implies_galois"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y \\<le> ?z) = (?x \\<le> ?y \\<leadsto> ?z)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<leadsto> x \\<sqinter> y", "by blast"], ["", "lemma implies_galois_decreasing:\n  \"(y \\<leadsto> x) \\<sqinter> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<leadsto> x) \\<sqinter> y \\<le> x", "using implies_galois"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y \\<le> ?z) = (?x \\<le> ?y \\<leadsto> ?z)\n\ngoal (1 subgoal):\n 1. (y \\<leadsto> x) \\<sqinter> y \\<le> x", "by blast"], ["", "lemma implies_mp_below:\n  \"x \\<sqinter> (x \\<leadsto> y) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (x \\<leadsto> y) \\<le> y", "using implies_galois_decreasing inf_commute"], ["proof (prove)\nusing this:\n  (?y \\<leadsto> ?x) \\<sqinter> ?y \\<le> ?x\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. x \\<sqinter> (x \\<leadsto> y) \\<le> y", "by auto"], ["", "lemma implies_isotone:\n  \"x \\<le> y \\<Longrightarrow> z \\<leadsto> x \\<le> z \\<leadsto> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<leadsto> x \\<le> z \\<leadsto> y", "using implies_galois order_trans"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y \\<le> ?z) = (?x \\<le> ?y \\<leadsto> ?z)\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<leadsto> x \\<le> z \\<leadsto> y", "by blast"], ["", "lemma implies_antitone:\n  \"x \\<le> y \\<Longrightarrow> y \\<leadsto> z \\<le> x \\<leadsto> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> y \\<leadsto> z \\<le> x \\<leadsto> z", "by (meson implies_galois_swap order_lesseq_imp)"], ["", "lemma implies_isotone_inf:\n  \"x \\<leadsto> (y \\<sqinter> z) \\<le> x \\<leadsto> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<sqinter> z \\<le> x \\<leadsto> y", "by (simp add: implies_isotone)"], ["", "lemma implies_antitone_inf:\n  \"x \\<leadsto> z \\<le> (x \\<sqinter> y) \\<leadsto> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> z \\<le> x \\<sqinter> y \\<leadsto> z", "by (simp add: implies_antitone)"], ["", "lemma implies_curry:\n  \"x \\<leadsto> (y \\<leadsto> z) = (x \\<sqinter> y) \\<leadsto> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> (y \\<leadsto> z) = x \\<sqinter> y \\<leadsto> z", "by (metis implies_galois_decreasing implies_galois inf_assoc antisym)"], ["", "lemma implies_curry_flip:\n  \"x \\<leadsto> (y \\<leadsto> z) = y \\<leadsto> (x \\<leadsto> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> (y \\<leadsto> z) = y \\<leadsto> (x \\<leadsto> z)", "by (simp add: implies_curry inf_commute)"], ["", "lemma triple_implies [simp]:\n  \"((x \\<leadsto> y) \\<leadsto> y) \\<leadsto> y = x \\<leadsto> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<leadsto> y \\<leadsto> y = x \\<leadsto> y", "using implies_antitone implies_galois_swap eq_iff"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?y \\<leadsto> ?z \\<le> ?x \\<leadsto> ?z\n  (?x \\<le> ?y \\<leadsto> ?z) = (?y \\<le> ?x \\<leadsto> ?z)\n  (?x = ?y) = (?x \\<le> ?y \\<and> ?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<leadsto> y \\<leadsto> y = x \\<leadsto> y", "by auto"], ["", "lemma implies_mp_eq [simp]:\n  \"x \\<sqinter> (x \\<leadsto> y) = x \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (x \\<leadsto> y) = x \\<sqinter> y", "by (metis implies_below_eq implies_mp_below inf_left_commute inf.absorb2)"], ["", "lemma implies_dist_implies:\n  \"x \\<leadsto> (y \\<leadsto> z) \\<le> (x \\<leadsto> y) \\<leadsto> (x \\<leadsto> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> (y \\<leadsto> z)\n    \\<le> x \\<leadsto> y \\<leadsto> (x \\<leadsto> z)", "using implies_curry implies_curry_flip"], ["proof (prove)\nusing this:\n  ?x \\<leadsto> (?y \\<leadsto> ?z) = ?x \\<sqinter> ?y \\<leadsto> ?z\n  ?x \\<leadsto> (?y \\<leadsto> ?z) = ?y \\<leadsto> (?x \\<leadsto> ?z)\n\ngoal (1 subgoal):\n 1. x \\<leadsto> (y \\<leadsto> z)\n    \\<le> x \\<leadsto> y \\<leadsto> (x \\<leadsto> z)", "by auto"], ["", "lemma implies_import_inf [simp]:\n  \"x \\<sqinter> ((x \\<sqinter> y) \\<leadsto> (x \\<leadsto> z)) = x \\<sqinter> (y \\<leadsto> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (x \\<sqinter> y \\<leadsto> (x \\<leadsto> z)) =\n    x \\<sqinter> (y \\<leadsto> z)", "by (metis implies_curry implies_mp_eq inf_commute)"], ["", "lemma implies_dist_inf:\n  \"x \\<leadsto> (y \\<sqinter> z) = (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<sqinter> z =\n    (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<sqinter> z =\n    (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z)", "have \"(x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z) \\<sqinter> x \\<le> y \\<sqinter> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z) \\<sqinter> x\n    \\<le> y \\<sqinter> z", "by (simp add: implies_galois)"], ["proof (state)\nthis:\n  (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z) \\<sqinter> x\n  \\<le> y \\<sqinter> z\n\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<sqinter> z =\n    (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z)", "hence \"(x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z) \\<le> x \\<leadsto> (y \\<sqinter> z)\""], ["proof (prove)\nusing this:\n  (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z) \\<sqinter> x\n  \\<le> y \\<sqinter> z\n\ngoal (1 subgoal):\n 1. (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z)\n    \\<le> x \\<leadsto> y \\<sqinter> z", "using implies_galois"], ["proof (prove)\nusing this:\n  (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z) \\<sqinter> x\n  \\<le> y \\<sqinter> z\n  (?x \\<sqinter> ?y \\<le> ?z) = (?x \\<le> ?y \\<leadsto> ?z)\n\ngoal (1 subgoal):\n 1. (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z)\n    \\<le> x \\<leadsto> y \\<sqinter> z", "by blast"], ["proof (state)\nthis:\n  (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z)\n  \\<le> x \\<leadsto> y \\<sqinter> z\n\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<sqinter> z =\n    (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z)\n  \\<le> x \\<leadsto> y \\<sqinter> z\n\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<sqinter> z =\n    (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z)", "by (simp add: implies_isotone eq_iff)"], ["proof (state)\nthis:\n  x \\<leadsto> y \\<sqinter> z = (x \\<leadsto> y) \\<sqinter> (x \\<leadsto> z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma implies_itself_top:\n  \"y \\<le> x \\<leadsto> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<leadsto> x", "by (simp add: implies_galois_swap implies_increasing)"], ["", "lemma inf_implies_top:\n  \"z \\<le> (x \\<sqinter> y) \\<leadsto> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> x \\<sqinter> y \\<leadsto> x", "using implies_galois_var le_infI1"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y \\<le> ?z) = (?y \\<le> ?x \\<leadsto> ?z)\n  ?a \\<le> ?x \\<Longrightarrow> ?a \\<sqinter> ?b \\<le> ?x\n\ngoal (1 subgoal):\n 1. z \\<le> x \\<sqinter> y \\<leadsto> x", "by blast"], ["", "lemma inf_inf_implies [simp]:\n  \"z \\<sqinter> ((x \\<sqinter> y) \\<leadsto> x) = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<sqinter> (x \\<sqinter> y \\<leadsto> x) = z", "by (simp add: inf_implies_top inf_absorb1)"], ["", "lemma le_implies_top:\n  \"x \\<le> y \\<Longrightarrow> z \\<le> x \\<leadsto> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<le> x \\<leadsto> y", "using implies_antitone implies_itself_top order.trans"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?y \\<leadsto> ?z \\<le> ?x \\<leadsto> ?z\n  ?y \\<le> ?x \\<leadsto> ?x\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z \\<le> x \\<leadsto> y", "by blast"], ["", "lemma le_iff_le_implies:\n  \"x \\<le> y \\<longleftrightarrow> x \\<le> x \\<leadsto> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x \\<le> x \\<leadsto> y)", "using implies_galois inf_idem"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y \\<le> ?z) = (?x \\<le> ?y \\<leadsto> ?z)\n  ?x \\<sqinter> ?x = ?x\n\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x \\<le> x \\<leadsto> y)", "by force"], ["", "lemma implies_inf_isotone:\n  \"x \\<leadsto> y \\<le> (x \\<sqinter> z) \\<leadsto> (y \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<le> x \\<sqinter> z \\<leadsto> y \\<sqinter> z", "by (metis implies_curry implies_galois_increasing implies_isotone)"], ["", "lemma implies_transitive:\n  \"(x \\<leadsto> y) \\<sqinter> (y \\<leadsto> z) \\<le> x \\<leadsto> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<leadsto> y) \\<sqinter> (y \\<leadsto> z) \\<le> x \\<leadsto> z", "using implies_dist_implies implies_galois_var implies_increasing order_lesseq_imp"], ["proof (prove)\nusing this:\n  ?x \\<leadsto> (?y \\<leadsto> ?z)\n  \\<le> ?x \\<leadsto> ?y \\<leadsto> (?x \\<leadsto> ?z)\n  (?x \\<sqinter> ?y \\<le> ?z) = (?y \\<le> ?x \\<leadsto> ?z)\n  ?x \\<le> ?y \\<leadsto> ?x\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. (x \\<leadsto> y) \\<sqinter> (y \\<leadsto> z) \\<le> x \\<leadsto> z", "by blast"], ["", "lemma implies_inf_absorb [simp]:\n  \"x \\<leadsto> (x \\<sqinter> y) = x \\<leadsto> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> x \\<sqinter> y = x \\<leadsto> y", "using implies_dist_inf implies_itself_top inf.absorb_iff2"], ["proof (prove)\nusing this:\n  ?x \\<leadsto> ?y \\<sqinter> ?z =\n  (?x \\<leadsto> ?y) \\<sqinter> (?x \\<leadsto> ?z)\n  ?y \\<le> ?x \\<leadsto> ?x\n  (?b \\<le> ?a) = (?a \\<sqinter> ?b = ?b)\n\ngoal (1 subgoal):\n 1. x \\<leadsto> x \\<sqinter> y = x \\<leadsto> y", "by auto"], ["", "lemma implies_implies_absorb [simp]:\n  \"x \\<leadsto> (x \\<leadsto> y) = x \\<leadsto> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> (x \\<leadsto> y) = x \\<leadsto> y", "by (simp add: implies_curry)"], ["", "lemma implies_inf_identity:\n  \"(x \\<leadsto> y) \\<sqinter> y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<leadsto> y) \\<sqinter> y = y", "by (simp add: inf_commute)"], ["", "lemma implies_itself_same:\n  \"x \\<leadsto> x = y \\<leadsto> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> x = y \\<leadsto> y", "by (simp add: le_implies_top eq_iff)"], ["", "end"], ["", "text \\<open>\nThe following class gives equational axioms for the relative pseudocomplement operation (inequalities can be written as equations).\n\\<close>"], ["", "class heyting_semilattice_eq = semilattice_inf + implies +\n  assumes implies_mp_below: \"x \\<sqinter> (x \\<leadsto> y) \\<le> y\"\n      and implies_galois_increasing: \"x \\<le> y \\<leadsto> (x \\<sqinter> y)\"\n      and implies_isotone_inf: \"x \\<leadsto> (y \\<sqinter> z) \\<le> x \\<leadsto> y\"\nbegin"], ["", "subclass heyting_semilattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.heyting_semilattice (\\<sqinter>) (\\<le>) (<) (\\<leadsto>)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z. (x \\<sqinter> y \\<le> z) = (x \\<le> y \\<leadsto> z)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       x \\<sqinter> y \\<le> z \\<Longrightarrow> x \\<le> y \\<leadsto> z\n 2. \\<And>x y z.\n       x \\<le> y \\<leadsto> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "apply (metis implies_galois_increasing implies_isotone_inf inf.absorb2 order_lesseq_imp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       x \\<le> y \\<leadsto> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "by (metis implies_mp_below inf_commute order_trans inf_mono order_refl)"], ["", "end"], ["", "text \\<open>\nThe following class allows us to explicitly give the pseudocomplement of an element relative to itself.\n\\<close>"], ["", "class bounded_heyting_semilattice = bounded_semilattice_inf_top + heyting_semilattice\nbegin"], ["", "lemma implies_itself [simp]:\n  \"x \\<leadsto> x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> x = top", "using implies_galois inf_le2 top_le"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y \\<le> ?z) = (?x \\<le> ?y \\<leadsto> ?z)\n  ?x \\<sqinter> ?y \\<le> ?y\n  top \\<le> ?a \\<Longrightarrow> ?a = top\n\ngoal (1 subgoal):\n 1. x \\<leadsto> x = top", "by blast"], ["", "lemma implies_order:\n  \"x \\<le> y \\<longleftrightarrow> x \\<leadsto> y = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x \\<leadsto> y = top)", "by (metis implies_galois inf_top.left_neutral top_unique)"], ["", "lemma inf_implies [simp]:\n  \"(x \\<sqinter> y) \\<leadsto> x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<leadsto> x = top", "using implies_order inf_le1"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (?x \\<leadsto> ?y = top)\n  ?x \\<sqinter> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<leadsto> x = top", "by blast"], ["", "lemma top_implies [simp]:\n  \"top \\<leadsto> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top \\<leadsto> x = x", "by (metis implies_mp_eq inf_top.left_neutral)"], ["", "end"], ["", "subsubsection \\<open>Heyting Lattices\\<close>"], ["", "text \\<open>\nWe obtain further properties if the underlying structure is a lattice.\nIn particular, the lattice operations are automatically distributive in this case.\n\\<close>"], ["", "class heyting_lattice = lattice + heyting_semilattice\nbegin"], ["", "lemma sup_distrib_inf_le:\n  \"(x \\<squnion> y) \\<sqinter> (x \\<squnion> z) \\<le> x \\<squnion> (y \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n    \\<le> x \\<squnion> y \\<sqinter> z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n    \\<le> x \\<squnion> y \\<sqinter> z", "have \"x \\<squnion> z \\<le> y \\<leadsto> (x \\<squnion> (y \\<sqinter> z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<le> y \\<leadsto> (x \\<squnion> y \\<sqinter> z)", "using implies_galois_var implies_increasing sup.bounded_iff sup.cobounded2"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y \\<le> ?z) = (?y \\<le> ?x \\<leadsto> ?z)\n  ?x \\<le> ?y \\<leadsto> ?x\n  (?b \\<squnion> ?c \\<le> ?a) = (?b \\<le> ?a \\<and> ?c \\<le> ?a)\n  ?b \\<le> ?a \\<squnion> ?b\n\ngoal (1 subgoal):\n 1. x \\<squnion> z \\<le> y \\<leadsto> (x \\<squnion> y \\<sqinter> z)", "by blast"], ["proof (state)\nthis:\n  x \\<squnion> z \\<le> y \\<leadsto> (x \\<squnion> y \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n    \\<le> x \\<squnion> y \\<sqinter> z", "hence \"x \\<squnion> y \\<le> (x \\<squnion> z) \\<leadsto> (x \\<squnion> (y \\<sqinter> z))\""], ["proof (prove)\nusing this:\n  x \\<squnion> z \\<le> y \\<leadsto> (x \\<squnion> y \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. x \\<squnion> y\n    \\<le> x \\<squnion> z \\<leadsto> (x \\<squnion> y \\<sqinter> z)", "using implies_galois_swap implies_increasing le_sup_iff"], ["proof (prove)\nusing this:\n  x \\<squnion> z \\<le> y \\<leadsto> (x \\<squnion> y \\<sqinter> z)\n  (?x \\<le> ?y \\<leadsto> ?z) = (?y \\<le> ?x \\<leadsto> ?z)\n  ?x \\<le> ?y \\<leadsto> ?x\n  (?x \\<squnion> ?y \\<le> ?z) = (?x \\<le> ?z \\<and> ?y \\<le> ?z)\n\ngoal (1 subgoal):\n 1. x \\<squnion> y\n    \\<le> x \\<squnion> z \\<leadsto> (x \\<squnion> y \\<sqinter> z)", "by blast"], ["proof (state)\nthis:\n  x \\<squnion> y\n  \\<le> x \\<squnion> z \\<leadsto> (x \\<squnion> y \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n    \\<le> x \\<squnion> y \\<sqinter> z", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<squnion> y\n  \\<le> x \\<squnion> z \\<leadsto> (x \\<squnion> y \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n    \\<le> x \\<squnion> y \\<sqinter> z", "by (simp add: implies_galois)"], ["proof (state)\nthis:\n  (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n  \\<le> x \\<squnion> y \\<sqinter> z\n\ngoal:\nNo subgoals!", "qed"], ["", "subclass distrib_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.distrib_lattice (\\<sqinter>) (\\<le>) (<) (\\<squnion>)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "using distrib_sup_le eq_iff sup_distrib_inf_le"], ["proof (prove)\nusing this:\n  ?x \\<squnion> ?y \\<sqinter> ?z\n  \\<le> (?x \\<squnion> ?y) \\<sqinter> (?x \\<squnion> ?z)\n  (?x = ?y) = (?x \\<le> ?y \\<and> ?y \\<le> ?x)\n  (?x \\<squnion> ?y) \\<sqinter> (?x \\<squnion> ?z)\n  \\<le> ?x \\<squnion> ?y \\<sqinter> ?z\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "by auto"], ["", "lemma implies_isotone_sup:\n  \"x \\<leadsto> y \\<le> x \\<leadsto> (y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<le> x \\<leadsto> (y \\<squnion> z)", "by (simp add: implies_isotone)"], ["", "lemma implies_antitone_sup:\n  \"(x \\<squnion> y) \\<leadsto> z \\<le> x \\<leadsto> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<leadsto> z \\<le> x \\<leadsto> z", "by (simp add: implies_antitone)"], ["", "lemma implies_sup:\n  \"x \\<leadsto> z \\<le> (y \\<leadsto> z) \\<leadsto> ((x \\<squnion> y) \\<leadsto> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> z\n    \\<le> y \\<leadsto> z \\<leadsto> (x \\<squnion> y \\<leadsto> z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<leadsto> z\n    \\<le> y \\<leadsto> z \\<leadsto> (x \\<squnion> y \\<leadsto> z)", "have \"(x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z) \\<sqinter> y \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z) \\<sqinter> y \\<le> z", "by (simp add: implies_galois)"], ["proof (state)\nthis:\n  (x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z) \\<sqinter> y \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<leadsto> z\n    \\<le> y \\<leadsto> z \\<leadsto> (x \\<squnion> y \\<leadsto> z)", "hence \"(x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z) \\<sqinter> (x \\<squnion> y) \\<le> z\""], ["proof (prove)\nusing this:\n  (x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z) \\<sqinter> y \\<le> z\n\ngoal (1 subgoal):\n 1. (x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z) \\<sqinter> (x \\<squnion> y)\n    \\<le> z", "using implies_galois_swap implies_galois_var"], ["proof (prove)\nusing this:\n  (x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z) \\<sqinter> y \\<le> z\n  (?x \\<le> ?y \\<leadsto> ?z) = (?y \\<le> ?x \\<leadsto> ?z)\n  (?x \\<sqinter> ?y \\<le> ?z) = (?y \\<le> ?x \\<leadsto> ?z)\n\ngoal (1 subgoal):\n 1. (x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z) \\<sqinter> (x \\<squnion> y)\n    \\<le> z", "by fastforce"], ["proof (state)\nthis:\n  (x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z) \\<sqinter> (x \\<squnion> y)\n  \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<leadsto> z\n    \\<le> y \\<leadsto> z \\<leadsto> (x \\<squnion> y \\<leadsto> z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z) \\<sqinter> (x \\<squnion> y)\n  \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<leadsto> z\n    \\<le> y \\<leadsto> z \\<leadsto> (x \\<squnion> y \\<leadsto> z)", "by (simp add: implies_galois)"], ["proof (state)\nthis:\n  x \\<leadsto> z\n  \\<le> y \\<leadsto> z \\<leadsto> (x \\<squnion> y \\<leadsto> z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma implies_dist_sup:\n  \"(x \\<squnion> y) \\<leadsto> z = (x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<leadsto> z =\n    (x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<squnion> y \\<leadsto> z\n    \\<le> (x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z)\n 2. (x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z)\n    \\<le> x \\<squnion> y \\<leadsto> z", "apply (simp add: implies_antitone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<leadsto> z) \\<sqinter> (y \\<leadsto> z)\n    \\<le> x \\<squnion> y \\<leadsto> z", "by (simp add: implies_sup implies_galois)"], ["", "lemma implies_antitone_isotone:\n  \"(x \\<squnion> y) \\<leadsto> (x \\<sqinter> y) \\<le> x \\<leadsto> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<leadsto> x \\<sqinter> y \\<le> x \\<leadsto> y", "by (simp add: implies_antitone_sup implies_dist_inf le_infI2)"], ["", "lemma implies_antisymmetry:\n  \"(x \\<leadsto> y) \\<sqinter> (y \\<leadsto> x) = (x \\<squnion> y) \\<leadsto> (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<leadsto> y) \\<sqinter> (y \\<leadsto> x) =\n    x \\<squnion> y \\<leadsto> x \\<sqinter> y", "by (metis implies_dist_sup implies_inf_absorb inf.commute)"], ["", "lemma sup_inf_implies [simp]:\n  \"(x \\<squnion> y) \\<sqinter> (x \\<leadsto> y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y) \\<sqinter> (x \\<leadsto> y) = y", "by (simp add: inf_sup_distrib2 sup.absorb2)"], ["", "lemma implies_subdist_sup:\n  \"(x \\<leadsto> y) \\<squnion> (x \\<leadsto> z) \\<le> x \\<leadsto> (y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<squnion> (x \\<leadsto> z)\n    \\<le> x \\<leadsto> (y \\<squnion> z)", "by (simp add: implies_isotone)"], ["", "lemma implies_subdist_inf:\n  \"(x \\<leadsto> z) \\<squnion> (y \\<leadsto> z) \\<le> (x \\<sqinter> y) \\<leadsto> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> z \\<squnion> (y \\<leadsto> z)\n    \\<le> x \\<sqinter> y \\<leadsto> z", "by (simp add: implies_antitone)"], ["", "lemma implies_sup_absorb:\n  \"(x \\<leadsto> y) \\<squnion> z \\<le> (x \\<squnion> z) \\<leadsto> (y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<squnion> z\n    \\<le> x \\<squnion> z \\<leadsto> (y \\<squnion> z)", "by (metis implies_dist_sup implies_isotone_sup implies_increasing inf_inf_implies le_sup_iff sup_inf_implies)"], ["", "lemma sup_below_implies_implies:\n  \"x \\<squnion> y \\<le> (x \\<leadsto> y) \\<leadsto> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<le> x \\<leadsto> y \\<leadsto> y", "by (simp add: implies_dist_sup implies_galois_swap implies_increasing)"], ["", "end"], ["", "class bounded_heyting_lattice = bounded_lattice + heyting_lattice\nbegin"], ["", "subclass bounded_heyting_semilattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_heyting_semilattice (\\<sqinter>) (\\<le>) (<) top\n     (\\<leadsto>)", ".."], ["", "lemma implies_bot [simp]:\n  \"bot \\<leadsto> x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot \\<leadsto> x = top", "using implies_galois top_unique"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y \\<le> ?z) = (?x \\<le> ?y \\<leadsto> ?z)\n  (top \\<le> ?a) = (?a = top)\n\ngoal (1 subgoal):\n 1. bot \\<leadsto> x = top", "by fastforce"], ["", "end"], ["", "subsubsection \\<open>Heyting Algebras\\<close>"], ["", "text \\<open>\nThe pseudocomplement operation can be defined in Heyting algebras, but it is typically not part of their signature.\nWe add the definition as an axiom so that we can use the class hierarchy, for example, to inherit results from the class \\<open>pd_algebra\\<close>.\n\\<close>"], ["", "class heyting_algebra = bounded_heyting_lattice + uminus +\n  assumes uminus_eq: \"-x = x \\<leadsto> bot\"\nbegin"], ["", "subclass pd_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.pd_algebra (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot top uminus", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)", "using bot_unique implies_galois uminus_eq"], ["proof (prove)\nusing this:\n  (?a \\<le> bot) = (?a = bot)\n  (?x \\<sqinter> ?y \\<le> ?z) = (?x \\<le> ?y \\<leadsto> ?z)\n  - ?x = ?x \\<leadsto> bot\n\ngoal (1 subgoal):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)", "by auto"], ["", "lemma boolean_implies_below:\n  \"-x \\<squnion> y \\<le> x \\<leadsto> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<squnion> y \\<le> x \\<leadsto> y", "by (simp add: implies_increasing implies_isotone uminus_eq)"], ["", "lemma negation_implies:\n  \"-(x \\<leadsto> y) = --x \\<sqinter> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<leadsto> y) = - - x \\<sqinter> - y", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. - (x \\<leadsto> y) \\<le> - - x \\<sqinter> - y\n 2. - - x \\<sqinter> - y \\<le> - (x \\<leadsto> y)", "show \"-(x \\<leadsto> y) \\<le> --x \\<sqinter> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<leadsto> y) \\<le> - - x \\<sqinter> - y", "using boolean_implies_below p_antitone"], ["proof (prove)\nusing this:\n  - ?x \\<squnion> ?y \\<le> ?x \\<leadsto> ?y\n  ?x \\<le> ?y \\<Longrightarrow> - ?y \\<le> - ?x\n\ngoal (1 subgoal):\n 1. - (x \\<leadsto> y) \\<le> - - x \\<sqinter> - y", "by auto"], ["proof (state)\nthis:\n  - (x \\<leadsto> y) \\<le> - - x \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. - - x \\<sqinter> - y \\<le> - (x \\<leadsto> y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. - - x \\<sqinter> - y \\<le> - (x \\<leadsto> y)", "have \"x \\<sqinter> -y \\<sqinter> (x \\<leadsto> y) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<sqinter> (x \\<leadsto> y) = bot", "by (metis implies_mp_eq inf_p inf_bot_left inf_commute inf_left_commute)"], ["proof (state)\nthis:\n  x \\<sqinter> - y \\<sqinter> (x \\<leadsto> y) = bot\n\ngoal (1 subgoal):\n 1. - - x \\<sqinter> - y \\<le> - (x \\<leadsto> y)", "hence \"--x \\<sqinter> -y \\<sqinter> (x \\<leadsto> y) = bot\""], ["proof (prove)\nusing this:\n  x \\<sqinter> - y \\<sqinter> (x \\<leadsto> y) = bot\n\ngoal (1 subgoal):\n 1. - - x \\<sqinter> - y \\<sqinter> (x \\<leadsto> y) = bot", "using pp_inf_bot_iff inf_assoc"], ["proof (prove)\nusing this:\n  x \\<sqinter> - y \\<sqinter> (x \\<leadsto> y) = bot\n  (?x \\<sqinter> ?y = bot) = (- - ?x \\<sqinter> ?y = bot)\n  ?x \\<sqinter> ?y \\<sqinter> ?z = ?x \\<sqinter> (?y \\<sqinter> ?z)\n\ngoal (1 subgoal):\n 1. - - x \\<sqinter> - y \\<sqinter> (x \\<leadsto> y) = bot", "by auto"], ["proof (state)\nthis:\n  - - x \\<sqinter> - y \\<sqinter> (x \\<leadsto> y) = bot\n\ngoal (1 subgoal):\n 1. - - x \\<sqinter> - y \\<le> - (x \\<leadsto> y)", "thus \"--x \\<sqinter> -y \\<le> -(x \\<leadsto> y)\""], ["proof (prove)\nusing this:\n  - - x \\<sqinter> - y \\<sqinter> (x \\<leadsto> y) = bot\n\ngoal (1 subgoal):\n 1. - - x \\<sqinter> - y \\<le> - (x \\<leadsto> y)", "by (simp add: pseudo_complement)"], ["proof (state)\nthis:\n  - - x \\<sqinter> - y \\<le> - (x \\<leadsto> y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma double_negation_dist_implies:\n  \"--(x \\<leadsto> y) = --x \\<leadsto> --y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - (x \\<leadsto> y) = - - x \\<leadsto> - - y", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - - (x \\<leadsto> y) \\<le> - - x \\<leadsto> - - y\n 2. - - x \\<leadsto> - - y \\<le> - - (x \\<leadsto> y)", "apply (metis pp_inf_below_iff implies_galois_decreasing implies_galois negation_implies ppp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x \\<leadsto> - - y \\<le> - - (x \\<leadsto> y)", "by (simp add: p_antitone_iff negation_implies)"], ["", "(*\nlemma stone: \"-x \\<squnion> --x = top\" nitpick [expect=genuine] oops\n*)"], ["", "end"], ["", "text \\<open>\nThe following class gives equational axioms for Heyting algebras.\n\\<close>"], ["", "class heyting_algebra_eq = bounded_lattice + implies + uminus +\n  assumes implies_mp_eq: \"x \\<sqinter> (x \\<leadsto> y) = x \\<sqinter> y\"\n      and implies_import_inf: \"x \\<sqinter> ((x \\<sqinter> y) \\<leadsto> (x \\<leadsto> z)) = x \\<sqinter> (y \\<leadsto> z)\"\n      and inf_inf_implies: \"z \\<sqinter> ((x \\<sqinter> y) \\<leadsto> x) = z\"\n      and uminus_eq_eq: \"-x = x \\<leadsto> bot\"\nbegin"], ["", "subclass heyting_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.heyting_algebra uminus (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot\n     top (\\<leadsto>)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z. (x \\<sqinter> y \\<le> z) = (x \\<le> y \\<leadsto> z)\n 2. \\<And>x. - x = x \\<leadsto> bot", "apply (rule iffI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<sqinter> y \\<le> z \\<Longrightarrow> x \\<le> y \\<leadsto> z\n 2. \\<And>x y z.\n       x \\<le> y \\<leadsto> z \\<Longrightarrow> x \\<sqinter> y \\<le> z\n 3. \\<And>x. - x = x \\<leadsto> bot", "apply (metis implies_import_inf inf.sup_left_divisibility inf_inf_implies le_iff_inf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       x \\<le> y \\<leadsto> z \\<Longrightarrow> x \\<sqinter> y \\<le> z\n 2. \\<And>x. - x = x \\<leadsto> bot", "apply (metis implies_mp_eq inf.commute inf.le_sup_iff inf.sup_right_isotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. - x = x \\<leadsto> bot", "by (simp add: uminus_eq_eq)"], ["", "end"], ["", "text \\<open>\nA relative pseudocomplement is not enough to obtain the Stone equation, so we add it in the following class.\n\\<close>"], ["", "class heyting_stone_algebra = heyting_algebra +\n  assumes heyting_stone: \"-x \\<squnion> --x = top\"\nbegin"], ["", "subclass stone_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.stone_algebra (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot top uminus", "by unfold_locales (simp add: heyting_stone)"], ["", "(*\nlemma pre_linear: \"(x \\<leadsto> y) \\<squnion> (y \\<leadsto> x) = top\" nitpick [expect=genuine] oops\n*)"], ["", "end"], ["", "subsubsection \\<open>Brouwer Algebras\\<close>"], ["", "text \\<open>\nBrouwer algebras are dual to Heyting algebras.\nThe dual pseudocomplement of an element \\<open>y\\<close> relative to an element \\<open>x\\<close> is the least element whose join with \\<open>y\\<close> is above \\<open>x\\<close>.\nWe can now use the binary operation provided by Boolean algebras in Isabelle/HOL because it is compatible with dual relative pseudocomplements (not relative pseudocomplements).\n\\<close>"], ["", "class brouwer_algebra = bounded_lattice + minus + uminus +\n  assumes minus_galois: \"x \\<le> y \\<squnion> z \\<longleftrightarrow> x - y \\<le> z\"\n      and uminus_eq_minus: \"-x = top - x\"\nbegin"], ["", "sublocale brouwer: heyting_algebra where inf = sup and less_eq = greater_eq and less = greater and sup = inf and bot = top and top = bot and implies = \"\\<lambda>x y . y - x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.heyting_algebra uminus (\\<squnion>) (\\<lambda>x y. y \\<le> x)\n     (\\<lambda>x y. y < x) (\\<sqinter>) top bot (\\<lambda>x y. y - x)", "apply unfold_locales"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>x y. y \\<le> x \\<squnion> y\n 3. \\<And>x y z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. bot \\<le> a\n 5. \\<And>x y z. (z \\<le> x \\<squnion> y) = (z - y \\<le> x)\n 6. \\<And>x. - x = top - x", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. y \\<le> x \\<squnion> y\n 2. \\<And>x y z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. bot \\<le> a\n 4. \\<And>x y z. (z \\<le> x \\<squnion> y) = (z - y \\<le> x)\n 5. \\<And>x. - x = top - x", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. bot \\<le> a\n 3. \\<And>x y z. (z \\<le> x \\<squnion> y) = (z - y \\<le> x)\n 4. \\<And>x. - x = top - x", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>x y z. (z \\<le> x \\<squnion> y) = (z - y \\<le> x)\n 3. \\<And>x. - x = top - x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z. (z \\<le> x \\<squnion> y) = (z - y \\<le> x)\n 2. \\<And>x. - x = top - x", "apply (metis minus_galois sup_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. - x = top - x", "by (simp add: uminus_eq_minus)"], ["", "lemma curry_minus:\n  \"x - (y \\<squnion> z) = (x - y) - z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - (y \\<squnion> z) = x - y - z", "by (simp add: brouwer.implies_curry sup_commute)"], ["", "lemma minus_subdist_sup:\n  \"(x - z) \\<squnion> (y - z) \\<le> (x \\<squnion> y) - z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - z \\<squnion> (y - z) \\<le> x \\<squnion> y - z", "by (simp add: brouwer.implies_dist_inf)"], ["", "lemma inf_sup_minus:\n  \"(x \\<sqinter> y) \\<squnion> (x - y) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<squnion> (x - y) = x", "by (simp add: inf.absorb1 brouwer.inf_sup_distrib2)"], ["", "end"], ["", "subsection \\<open>Boolean Algebras\\<close>"], ["", "text \\<open>\nThis section integrates Boolean algebras in the above hierarchy.\nIn particular, we strengthen several results shown above.\n\\<close>"], ["", "context boolean_algebra\nbegin"], ["", "text \\<open>\nEvery Boolean algebra is a Stone algebra, a Heyting algebra and a Brouwer algebra.\n\\<close>"], ["", "subclass stone_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.stone_algebra (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot top uminus", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "apply (rule iffI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<sqinter> y = bot \\<Longrightarrow> x \\<le> - y\n 2. \\<And>x y. x \\<le> - y \\<Longrightarrow> x \\<sqinter> y = bot\n 3. \\<And>x. - x \\<squnion> - - x = top", "apply (metis compl_sup_top inf.orderI inf_bot_right inf_sup_distrib1 inf_top_right sup_inf_absorb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<le> - y \\<Longrightarrow> x \\<sqinter> y = bot\n 2. \\<And>x. - x \\<squnion> - - x = top", "using inf.commute inf.sup_right_divisibility"], ["proof (prove)\nusing this:\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n  (?y \\<le> ?x) = (\\<exists>z. z \\<sqinter> ?x = ?y)\n\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<le> - y \\<Longrightarrow> x \\<sqinter> y = bot\n 2. \\<And>x. - x \\<squnion> - - x = top", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "by simp"], ["", "sublocale heyting: heyting_algebra where implies = \"\\<lambda>x y . -x \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.heyting_algebra uminus (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot\n     top (\\<lambda>x. (\\<squnion>) (- x))", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z. (x \\<sqinter> y \\<le> z) = (x \\<le> - y \\<squnion> z)\n 2. \\<And>x. - x = - x \\<squnion> bot", "apply (rule iffI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<sqinter> y \\<le> z \\<Longrightarrow> x \\<le> - y \\<squnion> z\n 2. \\<And>x y z.\n       x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z\n 3. \\<And>x. - x = - x \\<squnion> bot", "using shunting_var_p sup_commute"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> - ?y \\<le> ?z) = (?x \\<le> ?z \\<squnion> - - ?y)\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<sqinter> y \\<le> z \\<Longrightarrow> x \\<le> - y \\<squnion> z\n 2. \\<And>x y z.\n       x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z\n 3. \\<And>x. - x = - x \\<squnion> bot", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z\n 2. \\<And>x. - x = - x \\<squnion> bot", "using shunting_var_p sup_commute"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> - ?y \\<le> ?z) = (?x \\<le> ?z \\<squnion> - - ?y)\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z\n 2. \\<And>x. - x = - x \\<squnion> bot", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. - x = - x \\<squnion> bot", "by simp"], ["", "subclass brouwer_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.brouwer_algebra (-) uminus (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n     bot top", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z. (x \\<le> y \\<squnion> z) = (x - y \\<le> z)\n 2. \\<And>x. - x = top - x", "apply (simp add: diff_eq shunting_var_p sup.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. - x = top - x", "by (simp add: diff_eq)"], ["", "lemma huntington_3 [simp]:\n  \"-(-x \\<squnion> -y) \\<squnion> -(-x \\<squnion> y) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (- x \\<squnion> - y) \\<squnion> - (- x \\<squnion> y) = x", "using huntington_3_pp"], ["proof (prove)\nusing this:\n  - (- ?x \\<squnion> - ?y) \\<squnion> - (- ?x \\<squnion> ?y) = - - ?x\n\ngoal (1 subgoal):\n 1. - (- x \\<squnion> - y) \\<squnion> - (- x \\<squnion> y) = x", "by auto"], ["", "lemma maddux_3_1:\n  \"x \\<squnion> -x = y \\<squnion> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> - x = y \\<squnion> - y", "by simp"], ["", "lemma maddux_3_4:\n  \"x \\<squnion> (y \\<squnion> -y) = z \\<squnion> -z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> (y \\<squnion> - y) = z \\<squnion> - z", "by simp"], ["", "lemma maddux_3_11 [simp]:\n  \"(x \\<sqinter> y) \\<squnion> (x \\<sqinter> -y) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<squnion> x \\<sqinter> - y = x", "using brouwer.maddux_3_12 sup.commute"], ["proof (prove)\nusing this:\n  ?x \\<sqinter> - ?y \\<squnion> ?x \\<sqinter> ?y = ?x\n  ?a \\<squnion> ?b = ?b \\<squnion> ?a\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<squnion> x \\<sqinter> - y = x", "by auto"], ["", "lemma maddux_3_19:\n  \"(-x \\<sqinter> y) \\<squnion> (x \\<sqinter> z) = (x \\<squnion> y) \\<sqinter> (-x \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> x \\<sqinter> z =\n    (x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "using maddux_3_19_pp"], ["proof (prove)\nusing this:\n  - ?x \\<sqinter> ?y \\<squnion> - - ?x \\<sqinter> ?z =\n  (- - ?x \\<squnion> ?y) \\<sqinter> (- ?x \\<squnion> ?z)\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> y \\<squnion> x \\<sqinter> z =\n    (x \\<squnion> y) \\<sqinter> (- x \\<squnion> z)", "by auto"], ["", "lemma compl_inter_eq:\n  \"x \\<sqinter> y = x \\<sqinter> z \\<Longrightarrow> -x \\<sqinter> y = -x \\<sqinter> z \\<Longrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sqinter> y = x \\<sqinter> z;\n     - x \\<sqinter> y = - x \\<sqinter> z\\<rbrakk>\n    \\<Longrightarrow> y = z", "by (metis inf_commute maddux_3_11)"], ["", "lemma maddux_3_21 [simp]:\n  \"x \\<squnion> (-x \\<sqinter> y) = x \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> - x \\<sqinter> y = x \\<squnion> y", "by (simp add: sup_inf_distrib1)"], ["", "lemma shunting_1:\n  \"x \\<le> y \\<longleftrightarrow> x \\<sqinter> -y = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x \\<sqinter> - y = bot)", "by (simp add: pseudo_complement)"], ["", "lemma uminus_involutive:\n  \"uminus \\<circ> uminus = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uminus \\<circ> uminus = id", "by auto"], ["", "lemma uminus_injective:\n  \"uminus \\<circ> f = uminus \\<circ> g \\<Longrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uminus \\<circ> f = uminus \\<circ> g \\<Longrightarrow> f = g", "by (metis comp_assoc id_o minus_comp_minus)"], ["", "lemma conjugate_unique:\n  \"conjugate f g \\<Longrightarrow> conjugate f h \\<Longrightarrow> g = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>conjugate f g; conjugate f h\\<rbrakk> \\<Longrightarrow> g = h", "using conjugate_unique_p uminus_injective"], ["proof (prove)\nusing this:\n  \\<lbrakk>conjugate ?f ?g; conjugate ?f ?h\\<rbrakk>\n  \\<Longrightarrow> uminus \\<circ> ?g = uminus \\<circ> ?h\n  uminus \\<circ> ?f = uminus \\<circ> ?g \\<Longrightarrow> ?f = ?g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>conjugate f g; conjugate f h\\<rbrakk> \\<Longrightarrow> g = h", "by blast"], ["", "lemma dual_additive_additive:\n  \"dual_additive (uminus \\<circ> f) \\<Longrightarrow> additive f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_additive (uminus \\<circ> f) \\<Longrightarrow> additive f", "by (metis additive_def compl_eq_compl_iff dual_additive_def p_dist_sup o_def)"], ["", "lemma conjugate_additive:\n  \"conjugate f g \\<Longrightarrow> additive f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate f g \\<Longrightarrow> additive f", "by (simp add: conjugate_dual_additive dual_additive_additive)"], ["", "lemma conjugate_isotone:\n  \"conjugate f g \\<Longrightarrow> isotone f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate f g \\<Longrightarrow> isotone f", "by (simp add: conjugate_additive additive_isotone)"], ["", "lemma conjugate_char_1:\n  \"conjugate f g \\<longleftrightarrow> (\\<forall>x y . f(x \\<sqinter> -(g y)) \\<le> f x \\<sqinter> -y \\<and> g(y \\<sqinter> -(f x)) \\<le> g y \\<sqinter> -x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate f g =\n    (\\<forall>x y.\n        f (x \\<sqinter> - g y) \\<le> f x \\<sqinter> - y \\<and>\n        g (y \\<sqinter> - f x) \\<le> g y \\<sqinter> - x)", "by (simp add: conjugate_char_1_pp)"], ["", "lemma conjugate_char_2:\n  \"conjugate f g \\<longleftrightarrow> f bot = bot \\<and> g bot = bot \\<and> (\\<forall>x y . f x \\<sqinter> y \\<le> f(x \\<sqinter> g y) \\<and> g y \\<sqinter> x \\<le> g(y \\<sqinter> f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate f g =\n    (f bot = bot \\<and>\n     g bot = bot \\<and>\n     (\\<forall>x y.\n         f x \\<sqinter> y \\<le> f (x \\<sqinter> g y) \\<and>\n         g y \\<sqinter> x \\<le> g (y \\<sqinter> f x)))", "by (simp add: conjugate_char_2_pp)"], ["", "lemma shunting:\n  \"x \\<sqinter> y \\<le> z \\<longleftrightarrow> x \\<le> z \\<squnion> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y \\<le> z) = (x \\<le> z \\<squnion> - y)", "by (simp add: heyting.implies_galois sup.commute)"], ["", "lemma shunting_var:\n  \"x \\<sqinter> -y \\<le> z \\<longleftrightarrow> x \\<le> z \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> - y \\<le> z) = (x \\<le> z \\<squnion> y)", "by (simp add: shunting)"], ["", "end"], ["", "class non_trivial_stone_algebra = non_trivial_bounded_order + stone_algebra"], ["", "class non_trivial_boolean_algebra = non_trivial_stone_algebra + boolean_algebra"], ["", "end"]]}