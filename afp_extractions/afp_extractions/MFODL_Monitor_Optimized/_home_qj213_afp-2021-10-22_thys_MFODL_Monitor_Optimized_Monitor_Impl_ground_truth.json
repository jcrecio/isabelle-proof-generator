{"file_name": "/home/qj213/afp-2021-10-22/thys/MFODL_Monitor_Optimized/Monitor_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFODL_Monitor_Optimized", "problem_names": ["lemma [code_unfold del, symmetric, code_post del]: \"card \\<equiv> Cardinality.card'\"", "lemma image_these: \"f ` Option.these X = Option.these (map_option f ` X)\"", "lemma meval_MPred: \"meval n t db (MPred e ts) =\n  (case Mapping.lookup db e of None \\<Rightarrow> [{}] | Some Xs \\<Rightarrow> map (\\<lambda>X. \\<Union>v \\<in> X.\n  (set_option (map_option (\\<lambda>f. Table.tabulate f 0 n) (match ts v)))) Xs, MPred e ts)\"", "lemmas meval_code[code] = default_maux.meval.simps(1) meval_MPred default_maux.meval.simps(3-)", "lemma saturate_commute:\n  assumes \"\\<And>s. r \\<in> g s\" \"\\<And>s. g (insert r s) = g s\" \"\\<And>s. r \\<in> s \\<Longrightarrow> h s = g s\"\n  and terminates: \"mono g\" \"\\<And>X. X \\<subseteq> C \\<Longrightarrow> g X \\<subseteq> C\" \"finite C\"\nshows \"saturate g {} = saturate h {r}\"", "lemma RPDs_aux_code[code]:\n  \"RPDs_aux S = (let S' = S \\<union> Set.bind S RPD in if S' \\<subseteq> S then S else RPDs_aux S')\"", "lemma RPDs_code[code]: \"RPDs r = RPDs_aux {r}\"", "lemma LPDs_aux_code[code]:\n  \"LPDs_aux S = (let S' = S \\<union> Set.bind S LPD in if S' \\<subseteq> S then S else LPDs_aux S')\"", "lemma LPDs_code[code]: \"LPDs r = LPDs_aux {r}\"", "lemma is_empty_table_unfold [code_unfold]:\n  \"X = empty_table \\<longleftrightarrow> Set.is_empty X\"\n  \"empty_table = X \\<longleftrightarrow> Set.is_empty X\"\n  \"Cardinality.eq_set X empty_table \\<longleftrightarrow> Set.is_empty X\"\n  \"Cardinality.eq_set empty_table X \\<longleftrightarrow> Set.is_empty X\"\n  \"set_eq X empty_table \\<longleftrightarrow> Set.is_empty X\"\n  \"set_eq empty_table X \\<longleftrightarrow> Set.is_empty X\"\n  \"X = (set_empty impl) \\<longleftrightarrow> Set.is_empty X\"\n  \"(set_empty impl) = X \\<longleftrightarrow> Set.is_empty X\"\n  \"Cardinality.eq_set X (set_empty impl) \\<longleftrightarrow> Set.is_empty X\"\n  \"Cardinality.eq_set (set_empty impl) X \\<longleftrightarrow> Set.is_empty X\"\n  \"set_eq X (set_empty impl) \\<longleftrightarrow> Set.is_empty X\"\n  \"set_eq (set_empty impl) X \\<longleftrightarrow> Set.is_empty X\"", "lemma tabulate_rbt_code[code]: \"Monitor.mrtabulate (xs :: mregex list) f =\n  (case ID CCOMPARE(mregex) of None \\<Rightarrow> Code.abort (STR ''tabulate RBT_Mapping: ccompare = None'') (\\<lambda>_. Monitor.mrtabulate (xs :: mregex list) f)\n  | _ \\<Rightarrow> RBT_Mapping (RBT_Mapping2.bulkload (List.map_filter (\\<lambda>k. let fk = f k in if fk = empty_table then None else Some (k, fk)) xs)))\"", "lemma combine_Mapping[code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.combine f (RBT_Mapping t) (RBT_Mapping u) = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''combine RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.combine f (RBT_Mapping t) (RBT_Mapping u))\n                     | Some _ \\<Rightarrow> RBT_Mapping (RBT_Mapping2.join (\\<lambda>_. f) t u))\"", "lemma upd_set_empty[simp]: \"upd_set m f {} = m\"", "lemma upd_set_insert[simp]: \"upd_set m f (insert x A) = Mapping.update x (f x) (upd_set m f A)\"", "lemma upd_set_fold:\n  assumes \"finite A\"\n  shows \"upd_set m f A = Finite_Set.fold (\\<lambda>a. Mapping.update a (f a)) m A\"", "lemma upd_set_code[code]:\n  \"upd_set m f A = (if finite A then set_fold_cfi (upd_cfi f) m A else Code.abort (STR ''upd_set: infinite'') (\\<lambda>_. upd_set m f A))\"", "lemma lexordp_eq_code[code]: \"lexordp_eq xs ys \\<longleftrightarrow> (case xs of [] \\<Rightarrow> True\n  | x # xs \\<Rightarrow> (case ys of [] \\<Rightarrow> False\n    | y # ys \\<Rightarrow> if x < y then True else if x > y then False else lexordp_eq xs ys))\"", "lemma upd_set'_empty[simp]: \"upd_set' m d f {} = m\"", "lemma upd_set'_insert: \"d = f d \\<Longrightarrow> (\\<And>x. f (f x) = f x) \\<Longrightarrow> upd_set' m d f (insert x A) =\n  (let m' = (upd_set' m d f A) in case Mapping.lookup m' x of None \\<Rightarrow> Mapping.update x d m'\n  | Some v \\<Rightarrow> Mapping.update x (f v) m')\"", "lemma upd_set'_aux1: \"upd_set' Mapping.empty d f {b. b = k \\<or> (a, b) \\<in> A} =\n  Mapping.update k d (upd_set' Mapping.empty d f {b. (a, b) \\<in> A})\"", "lemma upd_set'_aux2: \"Mapping.lookup m k = None \\<Longrightarrow> upd_set' m d f {b. b = k \\<or> (a, b) \\<in> A} =\n  Mapping.update k d (upd_set' m d f {b. (a, b) \\<in> A})\"", "lemma upd_set'_aux3: \"Mapping.lookup m k = Some v \\<Longrightarrow> upd_set' m d f {b. b = k \\<or> (a, b) \\<in> A} =\n  Mapping.update k (f v) (upd_set' m d f {b. (a, b) \\<in> A})\"", "lemma upd_set'_aux4: \"k \\<notin> fst ` A \\<Longrightarrow> upd_set' Mapping.empty d f {b. (k, b) \\<in> A} = Mapping.empty\"", "lemma upd_nested_empty[simp]: \"upd_nested m d f {} = m\"", "lemma upd_nested_insert:\n  \"d = f d \\<Longrightarrow> (\\<And>x. f (f x) = f x) \\<Longrightarrow> upd_nested m d f (insert x A) =\n  upd_nested_step d f x (upd_nested m d f A)\"", "lemma upd_nested_max_tstp_fold:\n  assumes \"finite X\"\n  shows \"upd_nested_max_tstp m d X = Finite_Set.fold (upd_nested_step d (max_tstp d)) m X\"", "lemma upd_nested_max_tstp_code[code]:\n  \"upd_nested_max_tstp m d X = (if finite X then set_fold_cfi (upd_nested_max_tstp_cfi d) m X\n    else Code.abort (STR ''upd_nested_max_tstp: infinite'') (\\<lambda>_. upd_nested_max_tstp m d X))\"", "lemma filter_set_empty[simp]: \"filter_set m {} t = m\"", "lemma filter_set_insert[simp]: \"filter_set m (insert x A) t = (let m' = filter_set m A t in\n  case Mapping.lookup m' x of Some u \\<Rightarrow> if t = u then Mapping.delete x m' else m' | _ \\<Rightarrow> m')\"", "lemma filter_set_fold:\n  assumes \"finite A\"\n  shows \"filter_set m A t = Finite_Set.fold (\\<lambda>a m.\n    case Mapping.lookup m a of Some u \\<Rightarrow> if t = u then Mapping.delete a m else m | _ \\<Rightarrow> m) m A\"", "lemma filter_set_code[code]:\n  \"filter_set m A t = (if finite A then set_fold_cfi (filter_cfi t) m A else Code.abort (STR ''upd_set: infinite'') (\\<lambda>_. filter_set m A t))\"", "lemma filter_Mapping[code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.filter P (RBT_Mapping t) = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''filter RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.filter P (RBT_Mapping t))\n                     | Some _ \\<Rightarrow> RBT_Mapping (RBT_Mapping2.filter (case_prod P) t))\"", "lemma filter_join_False_empty: \"filter_join False {} m = m\"", "lemma filter_join_False_insert: \"filter_join False (insert a A) m =\n  filter_join False A (Mapping.delete a m)\"", "lemma filter_join_False:\n  assumes \"finite A\"\n  shows \"filter_join False A m = Finite_Set.fold Mapping.delete m A\"", "lemma filter_join_code[code]:\n  \"filter_join pos A m =\n    (if \\<not>pos \\<and> finite A \\<and> card A < Mapping.size m then set_fold_cfi filter_not_in_cfi m A\n    else Mapping.filter (join_filter_cond pos A) m)\"", "lemma set_minus_finite:\n  assumes fin: \"finite Y\"\n  shows \"set_minus X Y = Finite_Set.fold (\\<lambda>a X. X - {a}) X Y\"", "lemma set_minus_code[code]: \"set_minus X Y =\n  (if finite Y \\<and> card Y < card X then set_fold_cfi remove_cfi X Y else X - Y)\"", "lemma remove_Union_finite: \n  assumes \"finite X\"\n  shows \"remove_Union A X B = Finite_Set.fold (\\<lambda>x A. A - B x) A X\"", "lemma remove_Union_code[code]: \"remove_Union A X B =\n  (if finite X then set_fold_cfi (remove_Union_cfi B) A X else A - (\\<Union>x \\<in> X. B x))\"", "lemma tabulate_remdups: \"Mapping.tabulate xs f = Mapping.tabulate (remdups xs) f\"", "lemma map_filter_snd_map_filter: \"List.map_filter (\\<lambda>(a, b). if P b then None else Some (f a b)) xs =\n    map (\\<lambda>(a, b). f a b) (filter (\\<lambda>x. \\<not> P (snd x)) xs)\"", "lemma mk_db_code_alist:\n  \"mk_db t = Assoc_List_Mapping (clearjunk t)\"", "lemma mk_db_code[code]:\n  \"mk_db t = Mapping.of_alist (List.map_filter (\\<lambda>(p, X). if X = {} then None else Some (p, [X])) (AList.clearjunk t))\""], "translations": [["", "lemma [code_unfold del, symmetric, code_post del]: \"card \\<equiv> Cardinality.card'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card \\<equiv> Cardinality.card'", "by simp"], ["", "declare [[code drop: card]] Set_Impl.card_code[code]"], ["", "instantiation enat :: set_impl begin"], ["", "definition set_impl_enat :: \"(enat, set_impl) phantom\" where\n  \"set_impl_enat = phantom set_RBT\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(enat, set_impl_class)", ".."], ["", "end"], ["", "derive ccompare Formula.trm"], ["", "derive (eq) ceq Formula.trm"], ["", "derive (rbt) set_impl Formula.trm"], ["", "derive (eq) ceq Monitor.mregex"], ["", "derive ccompare Monitor.mregex"], ["", "derive (rbt) set_impl Monitor.mregex"], ["", "derive (rbt) mapping_impl Monitor.mregex"], ["", "derive (no) cenum Monitor.mregex"], ["", "derive (rbt) set_impl event_data"], ["", "derive (rbt) mapping_impl event_data"], ["", "definition add_new_mmuaux' :: \"args \\<Rightarrow> event_data table \\<Rightarrow> event_data table \\<Rightarrow> ts \\<Rightarrow> event_data mmuaux \\<Rightarrow>\n  event_data mmuaux\" where\n  \"add_new_mmuaux' = add_new_mmuaux\""], ["", "interpretation muaux valid_mmuaux init_mmuaux add_new_mmuaux' length_mmuaux eval_mmuaux"], ["proof (prove)\ngoal (1 subgoal):\n 1. muaux valid_mmuaux init_mmuaux add_new_mmuaux' length_mmuaux eval_mmuaux", "using valid_init_mmuaux valid_add_new_mmuaux valid_length_mmuaux valid_eval_mmuaux"], ["proof (prove)\nusing this:\n  ?L \\<subseteq> ?R \\<Longrightarrow>\n  valid_mmuaux (init_args ?I ?n ?L ?R ?b) 0\n   (init_mmuaux (init_args ?I ?n ?L ?R ?b)) []\n  \\<lbrakk>valid_mmuaux ?args ?cur ?aux ?auxlist;\n   table (args_n ?args) (args_L ?args) ?rel1.0;\n   table (args_n ?args) (args_R ?args) ?rel2.0; ?cur \\<le> ?nt\\<rbrakk>\n  \\<Longrightarrow> valid_mmuaux ?args ?nt\n                     (add_new_mmuaux ?args ?rel1.0 ?rel2.0 ?nt ?aux)\n                     (update_until ?args ?rel1.0 ?rel2.0 ?nt ?auxlist)\n  valid_mmuaux ?args ?cur ?aux ?auxlist \\<Longrightarrow>\n  length_mmuaux ?args ?aux = length ?auxlist\n  \\<lbrakk>valid_mmuaux ?args ?cur ?aux ?auxlist; ?cur \\<le> ?nt;\n   eval_mmuaux ?args ?nt ?aux = (?res, ?aux');\n   eval_until (args_ivl ?args) ?nt ?auxlist = (?res', ?auxlist')\\<rbrakk>\n  \\<Longrightarrow> ?res = ?res' \\<and>\n                    valid_mmuaux ?args ?cur ?aux' ?auxlist'\n\ngoal (1 subgoal):\n 1. muaux valid_mmuaux init_mmuaux add_new_mmuaux' length_mmuaux eval_mmuaux", "unfolding add_new_mmuaux'_def"], ["proof (prove)\nusing this:\n  ?L \\<subseteq> ?R \\<Longrightarrow>\n  valid_mmuaux (init_args ?I ?n ?L ?R ?b) 0\n   (init_mmuaux (init_args ?I ?n ?L ?R ?b)) []\n  \\<lbrakk>valid_mmuaux ?args ?cur ?aux ?auxlist;\n   table (args_n ?args) (args_L ?args) ?rel1.0;\n   table (args_n ?args) (args_R ?args) ?rel2.0; ?cur \\<le> ?nt\\<rbrakk>\n  \\<Longrightarrow> valid_mmuaux ?args ?nt\n                     (add_new_mmuaux ?args ?rel1.0 ?rel2.0 ?nt ?aux)\n                     (update_until ?args ?rel1.0 ?rel2.0 ?nt ?auxlist)\n  valid_mmuaux ?args ?cur ?aux ?auxlist \\<Longrightarrow>\n  length_mmuaux ?args ?aux = length ?auxlist\n  \\<lbrakk>valid_mmuaux ?args ?cur ?aux ?auxlist; ?cur \\<le> ?nt;\n   eval_mmuaux ?args ?nt ?aux = (?res, ?aux');\n   eval_until (args_ivl ?args) ?nt ?auxlist = (?res', ?auxlist')\\<rbrakk>\n  \\<Longrightarrow> ?res = ?res' \\<and>\n                    valid_mmuaux ?args ?cur ?aux' ?auxlist'\n\ngoal (1 subgoal):\n 1. muaux valid_mmuaux init_mmuaux add_new_mmuaux length_mmuaux eval_mmuaux", "by unfold_locales assumption+"], ["", "type_synonym 'a vmsaux = \"nat \\<times> (nat \\<times> 'a table) list\""], ["", "definition valid_vmsaux :: \"args \\<Rightarrow> nat \\<Rightarrow> event_data vmsaux \\<Rightarrow>\n  (nat \\<times> event_data table) list \\<Rightarrow> bool\" where\n  \"valid_vmsaux = (\\<lambda>_ cur (t, aux) auxlist. t = cur \\<and> aux = auxlist)\""], ["", "definition init_vmsaux :: \"args \\<Rightarrow> event_data vmsaux\" where\n  \"init_vmsaux = (\\<lambda>_. (0, []))\""], ["", "definition add_new_ts_vmsaux :: \"args \\<Rightarrow> nat \\<Rightarrow> event_data vmsaux \\<Rightarrow> event_data vmsaux\" where\n  \"add_new_ts_vmsaux = (\\<lambda>args nt (t, auxlist). (nt, filter (\\<lambda>(t, rel).\n    enat (nt - t) \\<le> right (args_ivl args)) auxlist))\""], ["", "definition join_vmsaux :: \"args \\<Rightarrow> event_data table \\<Rightarrow> event_data vmsaux \\<Rightarrow> event_data vmsaux\" where\n  \"join_vmsaux = (\\<lambda>args rel1 (t, auxlist). (t, map (\\<lambda>(t, rel).\n    (t, join rel (args_pos args) rel1)) auxlist))\""], ["", "definition add_new_table_vmsaux :: \"args \\<Rightarrow> event_data table \\<Rightarrow> event_data vmsaux \\<Rightarrow>\n  event_data vmsaux\" where\n  \"add_new_table_vmsaux = (\\<lambda>args rel2 (cur, auxlist). (cur, (case auxlist of\n    [] => [(cur, rel2)]\n  | ((t, y) # ts) \\<Rightarrow> if t = cur then (t, y \\<union> rel2) # ts else (cur, rel2) # auxlist)))\""], ["", "definition result_vmsaux :: \"args \\<Rightarrow> event_data vmsaux \\<Rightarrow> event_data table\" where\n  \"result_vmsaux = (\\<lambda>args (cur, auxlist).\n    foldr (\\<union>) [rel. (t, rel) \\<leftarrow> auxlist, left (args_ivl args) \\<le> cur - t] {})\""], ["", "type_synonym 'a vmuaux = \"nat \\<times> (nat \\<times> 'a table \\<times> 'a table) list\""], ["", "definition valid_vmuaux :: \"args \\<Rightarrow> nat \\<Rightarrow> event_data vmuaux \\<Rightarrow>\n  (nat \\<times> event_data table \\<times> event_data table) list \\<Rightarrow> bool\" where\n  \"valid_vmuaux = (\\<lambda>_ cur (t, aux) auxlist. t = cur \\<and> aux = auxlist)\""], ["", "definition init_vmuaux :: \"args \\<Rightarrow> event_data vmuaux\" where\n  \"init_vmuaux = (\\<lambda>_. (0, []))\""], ["", "definition add_new_vmuaux ::  \"args \\<Rightarrow> event_data table \\<Rightarrow> event_data table \\<Rightarrow> nat \\<Rightarrow>\n  event_data vmuaux \\<Rightarrow> event_data vmuaux\" where\n  \"add_new_vmuaux = (\\<lambda>args rel1 rel2 nt (t, auxlist). (nt, update_until args rel1 rel2 nt auxlist))\""], ["", "definition length_vmuaux :: \"args \\<Rightarrow> event_data vmuaux \\<Rightarrow> nat\" where\n  \"length_vmuaux = (\\<lambda>_ (_, auxlist). length auxlist)\""], ["", "definition eval_vmuaux :: \"args \\<Rightarrow> nat \\<Rightarrow> event_data vmuaux \\<Rightarrow>\n  event_data table list \\<times> event_data vmuaux\" where\n  \"eval_vmuaux = (\\<lambda>args nt (t, auxlist).\n    (let (res, auxlist') = eval_until (args_ivl args) nt auxlist in (res, (t, auxlist'))))\""], ["", "global_interpretation verimon_maux: maux valid_vmsaux init_vmsaux add_new_ts_vmsaux join_vmsaux\n  add_new_table_vmsaux result_vmsaux valid_vmuaux init_vmuaux add_new_vmuaux length_vmuaux\n  eval_vmuaux\n  defines vminit0 = \"maux.minit0 (init_vmsaux :: _ \\<Rightarrow> event_data vmsaux) (init_vmuaux :: _ \\<Rightarrow> event_data vmuaux) :: _ \\<Rightarrow> Formula.formula \\<Rightarrow> _\"\n  and vminit = \"maux.minit (init_vmsaux :: _ \\<Rightarrow> event_data vmsaux) (init_vmuaux :: _ \\<Rightarrow> event_data vmuaux) :: Formula.formula \\<Rightarrow> _\"\n  and vminit_safe = \"maux.minit_safe (init_vmsaux :: _ \\<Rightarrow> event_data vmsaux) (init_vmuaux :: _ \\<Rightarrow> event_data vmuaux) :: Formula.formula \\<Rightarrow> _\"\n  and vmupdate_since = \"maux.update_since add_new_ts_vmsaux join_vmsaux add_new_table_vmsaux (result_vmsaux :: _ \\<Rightarrow> event_data vmsaux \\<Rightarrow> event_data table)\"\n  and vmeval = \"maux.meval add_new_ts_vmsaux join_vmsaux add_new_table_vmsaux (result_vmsaux :: _ \\<Rightarrow> event_data vmsaux \\<Rightarrow> _) add_new_vmuaux (eval_vmuaux :: _ \\<Rightarrow> _ \\<Rightarrow> event_data vmuaux \\<Rightarrow> _)\"\n  and vmstep = \"maux.mstep add_new_ts_vmsaux join_vmsaux add_new_table_vmsaux (result_vmsaux :: _ \\<Rightarrow> event_data vmsaux \\<Rightarrow> _) add_new_vmuaux (eval_vmuaux :: _ \\<Rightarrow> _ \\<Rightarrow> event_data vmuaux \\<Rightarrow> _)\"\n  and vmsteps0_stateless = \"maux.msteps0_stateless add_new_ts_vmsaux join_vmsaux add_new_table_vmsaux (result_vmsaux :: _ \\<Rightarrow> event_data vmsaux \\<Rightarrow> _) add_new_vmuaux (eval_vmuaux :: _ \\<Rightarrow> _ \\<Rightarrow> event_data vmuaux \\<Rightarrow> _)\"\n  and vmsteps_stateless = \"maux.msteps_stateless add_new_ts_vmsaux join_vmsaux add_new_table_vmsaux (result_vmsaux :: _ \\<Rightarrow> event_data vmsaux \\<Rightarrow> _) add_new_vmuaux (eval_vmuaux :: _ \\<Rightarrow> _ \\<Rightarrow> event_data vmuaux \\<Rightarrow> _)\"\n  and vmonitor = \"maux.monitor init_vmsaux add_new_ts_vmsaux join_vmsaux add_new_table_vmsaux (result_vmsaux :: _ \\<Rightarrow> event_data vmsaux \\<Rightarrow> _) init_vmuaux add_new_vmuaux (eval_vmuaux :: _ \\<Rightarrow> _ \\<Rightarrow> event_data vmuaux \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maux valid_vmsaux init_vmsaux add_new_ts_vmsaux join_vmsaux\n     add_new_table_vmsaux result_vmsaux valid_vmuaux init_vmuaux\n     add_new_vmuaux length_vmuaux eval_vmuaux", "unfolding valid_vmsaux_def init_vmsaux_def add_new_ts_vmsaux_def join_vmsaux_def\n    add_new_table_vmsaux_def result_vmsaux_def valid_vmuaux_def init_vmuaux_def add_new_vmuaux_def\n    length_vmuaux_def eval_vmuaux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. maux (\\<lambda>_ cur (t, aux) auxlist. t = cur \\<and> aux = auxlist)\n     (\\<lambda>_. (0, []))\n     (\\<lambda>args nt (t, auxlist).\n         (nt,\n          filter\n           (\\<lambda>(t, rel). enat (nt - t) \\<le> right (args_ivl args))\n           auxlist))\n     (\\<lambda>args rel1 (t, auxlist).\n         (t, map (\\<lambda>(t, rel). (t, join rel (args_pos args) rel1))\n              auxlist))\n     (\\<lambda>args rel2 (cur, auxlist).\n         (cur,\n          case auxlist of [] \\<Rightarrow> [(cur, rel2)]\n          | (t, y) # ts \\<Rightarrow>\n              if t = cur then (t, y \\<union> rel2) # ts\n              else (cur, rel2) # auxlist))\n     (\\<lambda>args (cur, auxlist).\n         foldr (\\<union>)\n          (concat\n            (map (\\<lambda>(t, rel).\n                     if left (args_ivl args) \\<le> cur - t then [rel]\n                     else [])\n              auxlist))\n          {})\n     (\\<lambda>_ cur (t, aux) auxlist. t = cur \\<and> aux = auxlist)\n     (\\<lambda>_. (0, []))\n     (\\<lambda>args rel1 rel2 nt (t, auxlist).\n         (nt, update_until args rel1 rel2 nt auxlist))\n     (\\<lambda>_ (uu_, y). length y)\n     (\\<lambda>args nt (t, auxlist).\n         let (res, auxlist') = eval_until (args_ivl args) nt auxlist\n         in (res, t, auxlist'))", "by unfold_locales auto"], ["", "global_interpretation default_maux: maux valid_mmsaux \"init_mmsaux :: _ \\<Rightarrow> event_data mmsaux\" add_new_ts_mmsaux gc_join_mmsaux add_new_table_mmsaux result_mmsaux\n  valid_mmuaux \"init_mmuaux :: _ \\<Rightarrow> event_data mmuaux\" add_new_mmuaux' length_mmuaux eval_mmuaux\n  defines minit0 = \"maux.minit0 (init_mmsaux :: _ \\<Rightarrow> event_data mmsaux) (init_mmuaux :: _ \\<Rightarrow> event_data mmuaux) :: _ \\<Rightarrow> Formula.formula \\<Rightarrow> _\"\n  and minit = \"maux.minit (init_mmsaux :: _ \\<Rightarrow> event_data mmsaux) (init_mmuaux :: _ \\<Rightarrow> event_data mmuaux) :: Formula.formula \\<Rightarrow> _\"\n  and minit_safe = \"maux.minit_safe (init_mmsaux :: _ \\<Rightarrow> event_data mmsaux) (init_mmuaux :: _ \\<Rightarrow> event_data mmuaux) :: Formula.formula \\<Rightarrow> _\"\n  and mupdate_since = \"maux.update_since add_new_ts_mmsaux gc_join_mmsaux add_new_table_mmsaux (result_mmsaux :: _ \\<Rightarrow> event_data mmsaux \\<Rightarrow> event_data table)\"\n  and meval = \"maux.meval add_new_ts_mmsaux gc_join_mmsaux add_new_table_mmsaux (result_mmsaux :: _ \\<Rightarrow> event_data mmsaux \\<Rightarrow> _) add_new_mmuaux' (eval_mmuaux :: _ \\<Rightarrow> _ \\<Rightarrow> event_data mmuaux \\<Rightarrow> _)\"\n  and mstep = \"maux.mstep add_new_ts_mmsaux gc_join_mmsaux add_new_table_mmsaux (result_mmsaux :: _ \\<Rightarrow> event_data mmsaux \\<Rightarrow> _) add_new_mmuaux' (eval_mmuaux :: _ \\<Rightarrow> _ \\<Rightarrow> event_data mmuaux \\<Rightarrow> _)\"\n  and msteps0_stateless = \"maux.msteps0_stateless add_new_ts_mmsaux gc_join_mmsaux add_new_table_mmsaux (result_mmsaux :: _ \\<Rightarrow> event_data mmsaux \\<Rightarrow> _) add_new_mmuaux' (eval_mmuaux :: _ \\<Rightarrow> _ \\<Rightarrow> event_data mmuaux \\<Rightarrow> _)\"\n  and msteps_stateless = \"maux.msteps_stateless add_new_ts_mmsaux gc_join_mmsaux add_new_table_mmsaux (result_mmsaux :: _ \\<Rightarrow> event_data mmsaux \\<Rightarrow> _) add_new_mmuaux' (eval_mmuaux :: _ \\<Rightarrow> _ \\<Rightarrow> event_data mmuaux \\<Rightarrow> _)\"\n  and monitor = \"maux.monitor init_mmsaux add_new_ts_mmsaux gc_join_mmsaux add_new_table_mmsaux (result_mmsaux :: _ \\<Rightarrow> event_data mmsaux \\<Rightarrow> _) init_mmuaux add_new_mmuaux' (eval_mmuaux :: _ \\<Rightarrow> _ \\<Rightarrow> event_data mmuaux \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maux valid_mmsaux init_mmsaux add_new_ts_mmsaux gc_join_mmsaux\n     add_new_table_mmsaux result_mmsaux valid_mmuaux init_mmuaux\n     add_new_mmuaux' length_mmuaux eval_mmuaux", "by unfold_locales"], ["", "lemma image_these: \"f ` Option.these X = Option.these (map_option f ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` Option.these X = Option.these (map_option f ` X)", "by (force simp: in_these_eq Bex_def image_iff map_option_case split: option.splits)"], ["", "thm default_maux.meval.simps(2)"], ["", "lemma meval_MPred: \"meval n t db (MPred e ts) =\n  (case Mapping.lookup db e of None \\<Rightarrow> [{}] | Some Xs \\<Rightarrow> map (\\<lambda>X. \\<Union>v \\<in> X.\n  (set_option (map_option (\\<lambda>f. Table.tabulate f 0 n) (match ts v)))) Xs, MPred e ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. meval n t db (MPred e ts) =\n    (case Mapping.lookup db e of None \\<Rightarrow> [{}]\n     | Some Xs \\<Rightarrow>\n         map (\\<lambda>X.\n                 \\<Union>v\\<in>X.\n                    set_option\n                     (map_option (\\<lambda>f. tabulate f 0 n) (match ts v)))\n          Xs,\n     MPred e ts)", "by (force split: option.splits simp: Option.these_def image_iff)"], ["", "lemmas meval_code[code] = default_maux.meval.simps(1) meval_MPred default_maux.meval.simps(3-)"], ["", "definition mk_db :: \"(Formula.name \\<times> event_data list set) list \\<Rightarrow> _\" where\n  \"mk_db t = Monitor.mk_db (\\<Union>n \\<in> set (map fst t). (\\<lambda>v. (n, v)) ` the (map_of t n))\""], ["", "definition rbt_fold :: \"_ \\<Rightarrow> event_data tuple set_rbt \\<Rightarrow> _ \\<Rightarrow> _\" where\n  \"rbt_fold = RBT_Set2.fold\""], ["", "definition rbt_empty :: \"event_data list set_rbt\" where\n  \"rbt_empty = RBT_Set2.empty\""], ["", "definition rbt_insert :: \"_ \\<Rightarrow> _ \\<Rightarrow> event_data list set_rbt\" where\n  \"rbt_insert = RBT_Set2.insert\""], ["", "lemma saturate_commute:\n  assumes \"\\<And>s. r \\<in> g s\" \"\\<And>s. g (insert r s) = g s\" \"\\<And>s. r \\<in> s \\<Longrightarrow> h s = g s\"\n  and terminates: \"mono g\" \"\\<And>X. X \\<subseteq> C \\<Longrightarrow> g X \\<subseteq> C\" \"finite C\"\nshows \"saturate g {} = saturate h {r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. saturate g {} = saturate h {r}", "proof (cases \"g {} = {r}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. g {} = {r} \\<Longrightarrow> saturate g {} = saturate h {r}\n 2. g {} \\<noteq> {r} \\<Longrightarrow> saturate g {} = saturate h {r}", "case True"], ["proof (state)\nthis:\n  g {} = {r}\n\ngoal (2 subgoals):\n 1. g {} = {r} \\<Longrightarrow> saturate g {} = saturate h {r}\n 2. g {} \\<noteq> {r} \\<Longrightarrow> saturate g {} = saturate h {r}", "with assms"], ["proof (chain)\npicking this:\n  r \\<in> g ?s\n  g (insert r ?s) = g ?s\n  r \\<in> ?s \\<Longrightarrow> h ?s = g ?s\n  mono g\n  ?X \\<subseteq> C \\<Longrightarrow> g ?X \\<subseteq> C\n  finite C\n  g {} = {r}", "have \"g {r} = {r}\" \"h {r} = {r}\""], ["proof (prove)\nusing this:\n  r \\<in> g ?s\n  g (insert r ?s) = g ?s\n  r \\<in> ?s \\<Longrightarrow> h ?s = g ?s\n  mono g\n  ?X \\<subseteq> C \\<Longrightarrow> g ?X \\<subseteq> C\n  finite C\n  g {} = {r}\n\ngoal (1 subgoal):\n 1. g {r} = {r} &&& h {r} = {r}", "by auto"], ["proof (state)\nthis:\n  g {r} = {r}\n  h {r} = {r}\n\ngoal (2 subgoals):\n 1. g {} = {r} \\<Longrightarrow> saturate g {} = saturate h {r}\n 2. g {} \\<noteq> {r} \\<Longrightarrow> saturate g {} = saturate h {r}", "with True"], ["proof (chain)\npicking this:\n  g {} = {r}\n  g {r} = {r}\n  h {r} = {r}", "show ?thesis"], ["proof (prove)\nusing this:\n  g {} = {r}\n  g {r} = {r}\n  h {r} = {r}\n\ngoal (1 subgoal):\n 1. saturate g {} = saturate h {r}", "by (subst (1 2) saturate_code; subst saturate_code) (simp add: Let_def)"], ["proof (state)\nthis:\n  saturate g {} = saturate h {r}\n\ngoal (1 subgoal):\n 1. g {} \\<noteq> {r} \\<Longrightarrow> saturate g {} = saturate h {r}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. g {} \\<noteq> {r} \\<Longrightarrow> saturate g {} = saturate h {r}", "case False"], ["proof (state)\nthis:\n  g {} \\<noteq> {r}\n\ngoal (1 subgoal):\n 1. g {} \\<noteq> {r} \\<Longrightarrow> saturate g {} = saturate h {r}", "then"], ["proof (chain)\npicking this:\n  g {} \\<noteq> {r}", "show ?thesis"], ["proof (prove)\nusing this:\n  g {} \\<noteq> {r}\n\ngoal (1 subgoal):\n 1. saturate g {} = saturate h {r}", "unfolding saturate_def while_def"], ["proof (prove)\nusing this:\n  g {} \\<noteq> {r}\n\ngoal (1 subgoal):\n 1. the (while_option (\\<lambda>S. g S \\<noteq> S) g {}) =\n    the (while_option (\\<lambda>S. h S \\<noteq> S) h {r})", "using while_option_finite_subset_Some[OF terminates] assms(1-3)"], ["proof (prove)\nusing this:\n  g {} \\<noteq> {r}\n  (\\<And>X.\n      X \\<subseteq> C \\<Longrightarrow> X \\<subseteq> C) \\<Longrightarrow>\n  \\<exists>P. while_option (\\<lambda>A. g A \\<noteq> A) g {} = Some P\n  r \\<in> g ?s\n  g (insert r ?s) = g ?s\n  r \\<in> ?s \\<Longrightarrow> h ?s = g ?s\n\ngoal (1 subgoal):\n 1. the (while_option (\\<lambda>S. g S \\<noteq> S) g {}) =\n    the (while_option (\\<lambda>S. h S \\<noteq> S) h {r})", "by (subst while_option_commute_invariant[of \"\\<lambda>S. S = {} \\<or> r \\<in> S\" \"\\<lambda>S. g S \\<noteq> S\" g \"\\<lambda>S. h S \\<noteq> S\" \"insert r\" h \"{}\", symmetric])\n      (auto 4 4 dest: while_option_stop[of \"\\<lambda>S. g S \\<noteq> S\" g \"{}\"])"], ["proof (state)\nthis:\n  saturate g {} = saturate h {r}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"RPDs_aux = saturate (\\<lambda>S. S \\<union> \\<Union> (RPD ` S))\""], ["", "lemma RPDs_aux_code[code]:\n  \"RPDs_aux S = (let S' = S \\<union> Set.bind S RPD in if S' \\<subseteq> S then S else RPDs_aux S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RPDs_aux S =\n    (let S' = S \\<union> (S \\<bind> RPD)\n     in if S' \\<subseteq> S then S else RPDs_aux S')", "unfolding RPDs_aux_def bind_UNION"], ["proof (prove)\ngoal (1 subgoal):\n 1. saturate (\\<lambda>S. S \\<union> \\<Union> (RPD ` S)) S =\n    (let S' = S \\<union> \\<Union> (RPD ` S)\n     in if S' \\<subseteq> S then S\n        else saturate (\\<lambda>S. S \\<union> \\<Union> (RPD ` S)) S')", "by (subst saturate_code) auto"], ["", "declare RPDs_code[code del]"], ["", "lemma RPDs_code[code]: \"RPDs r = RPDs_aux {r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RPDs r = RPDs_aux {r}", "unfolding RPDs_aux_def RPDs_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. saturate (\\<lambda>S. insert r S \\<union> (insert r S \\<bind> RPD)) {} =\n    saturate (\\<lambda>S. S \\<union> \\<Union> (RPD ` S)) {r}", "by (rule saturate_commute[where C=\"RPDs r\"])\n     (auto 0 3 simp: mono_def subset_singleton_iff RPDs_refl RPDs_trans finite_RPDs)"], ["", "definition \"LPDs_aux = saturate (\\<lambda>S. S \\<union> \\<Union> (LPD ` S))\""], ["", "lemma LPDs_aux_code[code]:\n  \"LPDs_aux S = (let S' = S \\<union> Set.bind S LPD in if S' \\<subseteq> S then S else LPDs_aux S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LPDs_aux S =\n    (let S' = S \\<union> (S \\<bind> LPD)\n     in if S' \\<subseteq> S then S else LPDs_aux S')", "unfolding LPDs_aux_def bind_UNION"], ["proof (prove)\ngoal (1 subgoal):\n 1. saturate (\\<lambda>S. S \\<union> \\<Union> (LPD ` S)) S =\n    (let S' = S \\<union> \\<Union> (LPD ` S)\n     in if S' \\<subseteq> S then S\n        else saturate (\\<lambda>S. S \\<union> \\<Union> (LPD ` S)) S')", "by (subst saturate_code) auto"], ["", "declare LPDs_code[code del]"], ["", "lemma LPDs_code[code]: \"LPDs r = LPDs_aux {r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LPDs r = LPDs_aux {r}", "unfolding LPDs_aux_def LPDs_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. saturate (\\<lambda>S. insert r S \\<union> (insert r S \\<bind> LPD)) {} =\n    saturate (\\<lambda>S. S \\<union> \\<Union> (LPD ` S)) {r}", "by (rule saturate_commute[where C=\"LPDs r\"])\n     (auto 0 3 simp: mono_def subset_singleton_iff LPDs_refl LPDs_trans finite_LPDs)"], ["", "lemma is_empty_table_unfold [code_unfold]:\n  \"X = empty_table \\<longleftrightarrow> Set.is_empty X\"\n  \"empty_table = X \\<longleftrightarrow> Set.is_empty X\"\n  \"Cardinality.eq_set X empty_table \\<longleftrightarrow> Set.is_empty X\"\n  \"Cardinality.eq_set empty_table X \\<longleftrightarrow> Set.is_empty X\"\n  \"set_eq X empty_table \\<longleftrightarrow> Set.is_empty X\"\n  \"set_eq empty_table X \\<longleftrightarrow> Set.is_empty X\"\n  \"X = (set_empty impl) \\<longleftrightarrow> Set.is_empty X\"\n  \"(set_empty impl) = X \\<longleftrightarrow> Set.is_empty X\"\n  \"Cardinality.eq_set X (set_empty impl) \\<longleftrightarrow> Set.is_empty X\"\n  \"Cardinality.eq_set (set_empty impl) X \\<longleftrightarrow> Set.is_empty X\"\n  \"set_eq X (set_empty impl) \\<longleftrightarrow> Set.is_empty X\"\n  \"set_eq (set_empty impl) X \\<longleftrightarrow> Set.is_empty X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((X = empty_table) = Set.is_empty X &&&\n      (empty_table = X) = Set.is_empty X &&&\n      Cardinality.eq_set X empty_table = Set.is_empty X) &&&\n     Cardinality.eq_set empty_table X = Set.is_empty X &&&\n     set_eq X empty_table = Set.is_empty X &&&\n     set_eq empty_table X = Set.is_empty X) &&&\n    ((X = set_empty impl) = Set.is_empty X &&&\n     (set_empty impl = X) = Set.is_empty X &&&\n     Cardinality.eq_set X (set_empty impl) = Set.is_empty X) &&&\n    Cardinality.eq_set (set_empty impl) X = Set.is_empty X &&&\n    set_eq X (set_empty impl) = Set.is_empty X &&&\n    set_eq (set_empty impl) X = Set.is_empty X", "unfolding set_eq_def set_empty_def empty_table_def Set.is_empty_def Cardinality.eq_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((X = {}) = (X = {}) &&&\n      ({} = X) = (X = {}) &&& (X = {}) = (X = {})) &&&\n     ({} = X) = (X = {}) &&&\n     (X = {}) = (X = {}) &&& ({} = X) = (X = {})) &&&\n    ((X = {}) = (X = {}) &&&\n     ({} = X) = (X = {}) &&& (X = {}) = (X = {})) &&&\n    ({} = X) = (X = {}) &&& (X = {}) = (X = {}) &&& ({} = X) = (X = {})", "by auto"], ["", "lemma tabulate_rbt_code[code]: \"Monitor.mrtabulate (xs :: mregex list) f =\n  (case ID CCOMPARE(mregex) of None \\<Rightarrow> Code.abort (STR ''tabulate RBT_Mapping: ccompare = None'') (\\<lambda>_. Monitor.mrtabulate (xs :: mregex list) f)\n  | _ \\<Rightarrow> RBT_Mapping (RBT_Mapping2.bulkload (List.map_filter (\\<lambda>k. let fk = f k in if fk = empty_table then None else Some (k, fk)) xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mrtabulate xs f =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''tabulate RBT_Mapping: ccompare = None''\n        (\\<lambda>_. mrtabulate xs f)\n     | Some a \\<Rightarrow>\n         RBT_Mapping\n          (RBT_Mapping2.bulkload\n            (List.map_filter\n              (\\<lambda>k.\n                  let fk = f k\n                  in if fk = empty_table then None else Some (k, fk))\n              xs)))", "unfolding mrtabulate.abs_eq RBT_Mapping_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping\n     (map_of\n       (List.map_filter\n         (\\<lambda>k.\n             let fk = f k\n             in if fk = empty_table then None else Some (k, fk))\n         xs)) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''tabulate RBT_Mapping: ccompare = None''\n        (\\<lambda>_.\n            Mapping\n             (map_of\n               (List.map_filter\n                 (\\<lambda>k.\n                     let fk = f k\n                     in if fk = empty_table then None else Some (k, fk))\n                 xs)))\n     | Some a \\<Rightarrow>\n         Mapping\n          (RBT_Mapping2.lookup\n            (RBT_Mapping2.bulkload\n              (List.map_filter\n                (\\<lambda>k.\n                    let fk = f k\n                    in if fk = empty_table then None else Some (k, fk))\n                xs))))", "by (auto split: option.splits)"], ["", "lemma combine_Mapping[code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.combine f (RBT_Mapping t) (RBT_Mapping u) = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''combine RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.combine f (RBT_Mapping t) (RBT_Mapping u))\n                     | Some _ \\<Rightarrow> RBT_Mapping (RBT_Mapping2.join (\\<lambda>_. f) t u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.combine f (RBT_Mapping t) (RBT_Mapping u) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''combine RBT_Mapping: ccompare = None''\n        (\\<lambda>_. Mapping.combine f (RBT_Mapping t) (RBT_Mapping u))\n     | Some x \\<Rightarrow>\n         RBT_Mapping (RBT_Mapping2.join (\\<lambda>_. f) t u))", "by (auto simp add: Mapping.combine.abs_eq Mapping_inject lookup_join split: option.split)"], ["", "lemma upd_set_empty[simp]: \"upd_set m f {} = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_set m f {} = m", "by transfer auto"], ["", "lemma upd_set_insert[simp]: \"upd_set m f (insert x A) = Mapping.update x (f x) (upd_set m f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_set m f (insert x A) = Mapping.update x (f x) (upd_set m f A)", "by (rule mapping_eqI) (auto simp: Mapping_lookup_upd_set Mapping.lookup_update')"], ["", "lemma upd_set_fold:\n  assumes \"finite A\"\n  shows \"upd_set m f A = Finite_Set.fold (\\<lambda>a. Mapping.update a (f a)) m A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_set m f A = Finite_Set.fold (\\<lambda>a. Mapping.update a (f a)) m A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. upd_set m f A = Finite_Set.fold (\\<lambda>a. Mapping.update a (f a)) m A", "interpret comp_fun_idem \"\\<lambda>a. Mapping.update a (f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem (\\<lambda>a. Mapping.update a (f a))", "by unfold_locales (transfer; auto simp: fun_eq_iff)+"], ["proof (state)\ngoal (1 subgoal):\n 1. upd_set m f A = Finite_Set.fold (\\<lambda>a. Mapping.update a (f a)) m A", "from assms"], ["proof (chain)\npicking this:\n  finite A", "show ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. upd_set m f A = Finite_Set.fold (\\<lambda>a. Mapping.update a (f a)) m A", "by (induct A arbitrary: m rule: finite.induct) auto"], ["proof (state)\nthis:\n  upd_set m f A = Finite_Set.fold (\\<lambda>a. Mapping.update a (f a)) m A\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition upd_cfi :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a, ('a, 'b) mapping) comp_fun_idem\"\n  is \"\\<lambda>f a m. Mapping.update a (f a) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. comp_fun_idem (\\<lambda>a. Mapping.update a (fun a))", "by unfold_locales (transfer; auto simp: fun_eq_iff)+"], ["", "lemma upd_set_code[code]:\n  \"upd_set m f A = (if finite A then set_fold_cfi (upd_cfi f) m A else Code.abort (STR ''upd_set: infinite'') (\\<lambda>_. upd_set m f A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_set m f A =\n    (if finite A then set_fold_cfi (upd_cfi f) m A\n     else Code.abort STR ''upd_set: infinite'' (\\<lambda>_. upd_set m f A))", "by (transfer fixing: m) (auto simp: upd_set_fold)"], ["", "lemma lexordp_eq_code[code]: \"lexordp_eq xs ys \\<longleftrightarrow> (case xs of [] \\<Rightarrow> True\n  | x # xs \\<Rightarrow> (case ys of [] \\<Rightarrow> False\n    | y # ys \\<Rightarrow> if x < y then True else if x > y then False else lexordp_eq xs ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lexordp_eq xs ys =\n    (case xs of [] \\<Rightarrow> True\n     | x # xs \\<Rightarrow>\n         case ys of [] \\<Rightarrow> False\n         | y # ys \\<Rightarrow>\n             if x < y then True\n             else if y < x then False else lexordp_eq xs ys)", "by (subst lexordp_eq.simps) (auto split: list.split)"], ["", "definition \"filter_set m X t = Mapping.filter (filter_cond X m t) m\""], ["", "declare [[code drop: shift_end]]"], ["", "declare shift_end.simps[folded filter_set_def, code]"], ["", "lemma upd_set'_empty[simp]: \"upd_set' m d f {} = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_set' m d f {} = m", "by (rule mapping_eqI) (auto simp add: upd_set'_lookup)"], ["", "lemma upd_set'_insert: \"d = f d \\<Longrightarrow> (\\<And>x. f (f x) = f x) \\<Longrightarrow> upd_set' m d f (insert x A) =\n  (let m' = (upd_set' m d f A) in case Mapping.lookup m' x of None \\<Rightarrow> Mapping.update x d m'\n  | Some v \\<Rightarrow> Mapping.update x (f v) m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = f d; \\<And>x. f (f x) = f x\\<rbrakk>\n    \\<Longrightarrow> upd_set' m d f (insert x A) =\n                      (let m' = upd_set' m d f A\n                       in case Mapping.lookup m' x of\n                          None \\<Rightarrow> Mapping.update x d m'\n                          | Some v \\<Rightarrow> Mapping.update x (f v) m')", "by (rule mapping_eqI) (auto simp: upd_set'_lookup Mapping.lookup_update' split: option.splits)"], ["", "lemma upd_set'_aux1: \"upd_set' Mapping.empty d f {b. b = k \\<or> (a, b) \\<in> A} =\n  Mapping.update k d (upd_set' Mapping.empty d f {b. (a, b) \\<in> A})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_set' Mapping.empty d f {b. b = k \\<or> (a, b) \\<in> A} =\n    Mapping.update k d (upd_set' Mapping.empty d f {b. (a, b) \\<in> A})", "by (rule mapping_eqI) (auto simp add: Let_def upd_set'_lookup Mapping.lookup_update'\n      Mapping.lookup_empty split: option.splits)"], ["", "lemma upd_set'_aux2: \"Mapping.lookup m k = None \\<Longrightarrow> upd_set' m d f {b. b = k \\<or> (a, b) \\<in> A} =\n  Mapping.update k d (upd_set' m d f {b. (a, b) \\<in> A})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup m k = None \\<Longrightarrow>\n    upd_set' m d f {b. b = k \\<or> (a, b) \\<in> A} =\n    Mapping.update k d (upd_set' m d f {b. (a, b) \\<in> A})", "by (rule mapping_eqI) (auto simp add: upd_set'_lookup Mapping.lookup_update' split: option.splits)"], ["", "lemma upd_set'_aux3: \"Mapping.lookup m k = Some v \\<Longrightarrow> upd_set' m d f {b. b = k \\<or> (a, b) \\<in> A} =\n  Mapping.update k (f v) (upd_set' m d f {b. (a, b) \\<in> A})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup m k = Some v \\<Longrightarrow>\n    upd_set' m d f {b. b = k \\<or> (a, b) \\<in> A} =\n    Mapping.update k (f v) (upd_set' m d f {b. (a, b) \\<in> A})", "by (rule mapping_eqI) (auto simp add: upd_set'_lookup Mapping.lookup_update' split: option.splits)"], ["", "lemma upd_set'_aux4: \"k \\<notin> fst ` A \\<Longrightarrow> upd_set' Mapping.empty d f {b. (k, b) \\<in> A} = Mapping.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<notin> fst ` A \\<Longrightarrow>\n    upd_set' Mapping.empty d f {b. (k, b) \\<in> A} = Mapping.empty", "by (rule mapping_eqI) (auto simp add: upd_set'_lookup Mapping.lookup_update' Domain.DomainI fst_eq_Domain\n      split: option.splits)"], ["", "lemma upd_nested_empty[simp]: \"upd_nested m d f {} = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_nested m d f {} = m", "by (rule mapping_eqI) (auto simp add: upd_nested_lookup split: option.splits)"], ["", "definition upd_nested_step :: \"'c \\<Rightarrow> ('c \\<Rightarrow> 'c) \\<Rightarrow> 'a \\<times> 'b \\<Rightarrow> ('a, ('b, 'c) mapping) mapping \\<Rightarrow>\n  ('a, ('b, 'c) mapping) mapping\" where\n  \"upd_nested_step d f x m = (case x of (k, k') \\<Rightarrow>\n    (case Mapping.lookup m k of Some m' \\<Rightarrow>\n      (case Mapping.lookup m' k' of Some v \\<Rightarrow> Mapping.update k (Mapping.update k' (f v) m') m\n      | None \\<Rightarrow> Mapping.update k (Mapping.update k' d m') m)\n    | None \\<Rightarrow> Mapping.update k (Mapping.update k' d Mapping.empty) m))\""], ["", "lemma upd_nested_insert:\n  \"d = f d \\<Longrightarrow> (\\<And>x. f (f x) = f x) \\<Longrightarrow> upd_nested m d f (insert x A) =\n  upd_nested_step d f x (upd_nested m d f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = f d; \\<And>x. f (f x) = f x\\<rbrakk>\n    \\<Longrightarrow> upd_nested m d f (insert x A) =\n                      upd_nested_step d f x (upd_nested m d f A)", "unfolding upd_nested_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = f d; \\<And>x. f (f x) = f x\\<rbrakk>\n    \\<Longrightarrow> upd_nested m d f (insert x A) =\n                      (case x of\n                       (k, k') \\<Rightarrow>\n                         case Mapping.lookup (upd_nested m d f A) k of\n                         None \\<Rightarrow>\n                           Mapping.update k\n                            (Mapping.update k' d Mapping.empty)\n                            (upd_nested m d f A)\n                         | Some m' \\<Rightarrow>\n                             case Mapping.lookup m' k' of\n                             None \\<Rightarrow>\n                               Mapping.update k (Mapping.update k' d m')\n                                (upd_nested m d f A)\n                             | Some v \\<Rightarrow>\n                                 Mapping.update k\n                                  (Mapping.update k' (f v) m')\n                                  (upd_nested m d f A))", "using upd_set'_aux1[of d f _ _ A] upd_set'_aux2[of _ _ d f _ A] upd_set'_aux3[of _ _ _ d f _ A]\n    upd_set'_aux4[of _ A d f]"], ["proof (prove)\nusing this:\n  upd_set' Mapping.empty d f {b. b = ?k \\<or> (?a, b) \\<in> A} =\n  Mapping.update ?k d (upd_set' Mapping.empty d f {b. (?a, b) \\<in> A})\n  Mapping.lookup ?m ?k = None \\<Longrightarrow>\n  upd_set' ?m d f {b. b = ?k \\<or> (?a, b) \\<in> A} =\n  Mapping.update ?k d (upd_set' ?m d f {b. (?a, b) \\<in> A})\n  Mapping.lookup ?m ?k = Some ?v \\<Longrightarrow>\n  upd_set' ?m d f {b. b = ?k \\<or> (?a, b) \\<in> A} =\n  Mapping.update ?k (f ?v) (upd_set' ?m d f {b. (?a, b) \\<in> A})\n  ?k \\<notin> fst ` A \\<Longrightarrow>\n  upd_set' Mapping.empty d f {b. (?k, b) \\<in> A} = Mapping.empty\n\ngoal (1 subgoal):\n 1. \\<lbrakk>d = f d; \\<And>x. f (f x) = f x\\<rbrakk>\n    \\<Longrightarrow> upd_nested m d f (insert x A) =\n                      (case x of\n                       (k, k') \\<Rightarrow>\n                         case Mapping.lookup (upd_nested m d f A) k of\n                         None \\<Rightarrow>\n                           Mapping.update k\n                            (Mapping.update k' d Mapping.empty)\n                            (upd_nested m d f A)\n                         | Some m' \\<Rightarrow>\n                             case Mapping.lookup m' k' of\n                             None \\<Rightarrow>\n                               Mapping.update k (Mapping.update k' d m')\n                                (upd_nested m d f A)\n                             | Some v \\<Rightarrow>\n                                 Mapping.update k\n                                  (Mapping.update k' (f v) m')\n                                  (upd_nested m d f A))", "by (auto simp add: Let_def upd_nested_lookup upd_set'_lookup Mapping.lookup_update'\n      Mapping.lookup_empty split: option.splits prod.splits if_splits intro!: mapping_eqI)"], ["", "definition upd_nested_max_tstp where\n  \"upd_nested_max_tstp m d X = upd_nested m d (max_tstp d) X\""], ["", "lemma upd_nested_max_tstp_fold:\n  assumes \"finite X\"\n  shows \"upd_nested_max_tstp m d X = Finite_Set.fold (upd_nested_step d (max_tstp d)) m X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_nested_max_tstp m d X =\n    Finite_Set.fold (upd_nested_step d (max_tstp d)) m X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. upd_nested_max_tstp m d X =\n    Finite_Set.fold (upd_nested_step d (max_tstp d)) m X", "interpret comp_fun_idem \"upd_nested_step d (max_tstp d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem (upd_nested_step d (max_tstp d))", "by (unfold_locales; rule ext)\n      (auto simp add: comp_def upd_nested_step_def Mapping.lookup_update' Mapping.lookup_empty\n       update_update max_tstp_d_d max_tstp_idem' split: option.splits)"], ["proof (state)\ngoal (1 subgoal):\n 1. upd_nested_max_tstp m d X =\n    Finite_Set.fold (upd_nested_step d (max_tstp d)) m X", "note upd_nested_insert' = upd_nested_insert[of d \"max_tstp d\",\n    OF max_tstp_d_d[symmetric] max_tstp_idem']"], ["proof (state)\nthis:\n  upd_nested ?m d (max_tstp d) (insert ?x ?A) =\n  upd_nested_step d (max_tstp d) ?x (upd_nested ?m d (max_tstp d) ?A)\n\ngoal (1 subgoal):\n 1. upd_nested_max_tstp m d X =\n    Finite_Set.fold (upd_nested_step d (max_tstp d)) m X", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_nested_max_tstp m d X =\n    Finite_Set.fold (upd_nested_step d (max_tstp d)) m X", "using assms"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. upd_nested_max_tstp m d X =\n    Finite_Set.fold (upd_nested_step d (max_tstp d)) m X", "by (induct X arbitrary: m rule: finite.induct)\n       (auto simp add: upd_nested_max_tstp_def upd_nested_insert')"], ["proof (state)\nthis:\n  upd_nested_max_tstp m d X =\n  Finite_Set.fold (upd_nested_step d (max_tstp d)) m X\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition upd_nested_max_tstp_cfi ::\n  \"ts + tp \\<Rightarrow> ('a \\<times> 'b, ('a, ('b, ts + tp) mapping) mapping) comp_fun_idem\"\n  is \"\\<lambda>d. upd_nested_step d (max_tstp d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sum. comp_fun_idem (upd_nested_step sum (max_tstp sum))", "by (unfold_locales; rule ext)\n    (auto simp add: comp_def upd_nested_step_def Mapping.lookup_update' Mapping.lookup_empty\n      update_update max_tstp_d_d max_tstp_idem' split: option.splits)"], ["", "lemma upd_nested_max_tstp_code[code]:\n  \"upd_nested_max_tstp m d X = (if finite X then set_fold_cfi (upd_nested_max_tstp_cfi d) m X\n    else Code.abort (STR ''upd_nested_max_tstp: infinite'') (\\<lambda>_. upd_nested_max_tstp m d X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_nested_max_tstp m d X =\n    (if finite X then set_fold_cfi (upd_nested_max_tstp_cfi d) m X\n     else Code.abort STR ''upd_nested_max_tstp: infinite''\n           (\\<lambda>_. upd_nested_max_tstp m d X))", "by transfer (auto simp add: upd_nested_max_tstp_fold)"], ["", "declare [[code drop: add_new_mmuaux']]"], ["", "declare add_new_mmuaux'_def[unfolded add_new_mmuaux.simps, folded upd_nested_max_tstp_def, code]"], ["", "lemma filter_set_empty[simp]: \"filter_set m {} t = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_set m {} t = m", "unfolding filter_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.filter (filter_cond {} m t) m = m", "by transfer (auto simp: fun_eq_iff split: option.splits)"], ["", "lemma filter_set_insert[simp]: \"filter_set m (insert x A) t = (let m' = filter_set m A t in\n  case Mapping.lookup m' x of Some u \\<Rightarrow> if t = u then Mapping.delete x m' else m' | _ \\<Rightarrow> m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_set m (insert x A) t =\n    (let m' = filter_set m A t\n     in case Mapping.lookup m' x of None \\<Rightarrow> m'\n        | Some u \\<Rightarrow> if t = u then Mapping.delete x m' else m')", "unfolding filter_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.filter (filter_cond (insert x A) m t) m =\n    (let m' = Mapping.filter (filter_cond A m t) m\n     in case Mapping.lookup m' x of None \\<Rightarrow> m'\n        | Some u \\<Rightarrow> if t = u then Mapping.delete x m' else m')", "by transfer (auto simp: fun_eq_iff Let_def Map_To_Mapping.map_apply_def split: option.splits)"], ["", "lemma filter_set_fold:\n  assumes \"finite A\"\n  shows \"filter_set m A t = Finite_Set.fold (\\<lambda>a m.\n    case Mapping.lookup m a of Some u \\<Rightarrow> if t = u then Mapping.delete a m else m | _ \\<Rightarrow> m) m A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_set m A t =\n    Finite_Set.fold\n     (\\<lambda>a m.\n         case Mapping.lookup m a of None \\<Rightarrow> m\n         | Some u \\<Rightarrow> if t = u then Mapping.delete a m else m)\n     m A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter_set m A t =\n    Finite_Set.fold\n     (\\<lambda>a m.\n         case Mapping.lookup m a of None \\<Rightarrow> m\n         | Some u \\<Rightarrow> if t = u then Mapping.delete a m else m)\n     m A", "interpret comp_fun_idem \"\\<lambda>a m.\n    case Mapping.lookup m a of Some u \\<Rightarrow> if t = u then Mapping.delete a m else m | _ \\<Rightarrow> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem\n     (\\<lambda>a m.\n         case Mapping.lookup m a of None \\<Rightarrow> m\n         | Some u \\<Rightarrow> if t = u then Mapping.delete a m else m)", "by unfold_locales\n      (transfer; auto simp: fun_eq_iff Map_To_Mapping.map_apply_def split: option.splits)+"], ["proof (state)\ngoal (1 subgoal):\n 1. filter_set m A t =\n    Finite_Set.fold\n     (\\<lambda>a m.\n         case Mapping.lookup m a of None \\<Rightarrow> m\n         | Some u \\<Rightarrow> if t = u then Mapping.delete a m else m)\n     m A", "from assms"], ["proof (chain)\npicking this:\n  finite A", "show ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. filter_set m A t =\n    Finite_Set.fold\n     (\\<lambda>a m.\n         case Mapping.lookup m a of None \\<Rightarrow> m\n         | Some u \\<Rightarrow> if t = u then Mapping.delete a m else m)\n     m A", "by (induct A arbitrary: m rule: finite.induct) (auto simp: Let_def)"], ["proof (state)\nthis:\n  filter_set m A t =\n  Finite_Set.fold\n   (\\<lambda>a m.\n       case Mapping.lookup m a of None \\<Rightarrow> m\n       | Some u \\<Rightarrow> if t = u then Mapping.delete a m else m)\n   m A\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition filter_cfi :: \"'b \\<Rightarrow> ('a, ('a, 'b) mapping) comp_fun_idem\"\n  is \"\\<lambda>t a m.\n    case Mapping.lookup m a of Some u \\<Rightarrow> if t = u then Mapping.delete a m else m | _ \\<Rightarrow> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       comp_fun_idem\n        (\\<lambda>a m.\n            case Mapping.lookup m a of None \\<Rightarrow> m\n            | Some u \\<Rightarrow> if b = u then Mapping.delete a m else m)", "by unfold_locales\n    (transfer; auto simp: fun_eq_iff Map_To_Mapping.map_apply_def split: option.splits)+"], ["", "lemma filter_set_code[code]:\n  \"filter_set m A t = (if finite A then set_fold_cfi (filter_cfi t) m A else Code.abort (STR ''upd_set: infinite'') (\\<lambda>_. filter_set m A t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_set m A t =\n    (if finite A then set_fold_cfi (filter_cfi t) m A\n     else Code.abort STR ''upd_set: infinite''\n           (\\<lambda>_. filter_set m A t))", "by (transfer fixing: m) (auto simp: filter_set_fold)"], ["", "lemma filter_Mapping[code]:\n  fixes t :: \"('a :: ccompare, 'b) mapping_rbt\" shows\n  \"Mapping.filter P (RBT_Mapping t) = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''filter RBT_Mapping: ccompare = None'') (\\<lambda>_. Mapping.filter P (RBT_Mapping t))\n                     | Some _ \\<Rightarrow> RBT_Mapping (RBT_Mapping2.filter (case_prod P) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.filter P (RBT_Mapping t) =\n    (case ID ccompare of\n     None \\<Rightarrow>\n       Code.abort STR ''filter RBT_Mapping: ccompare = None''\n        (\\<lambda>_. Mapping.filter P (RBT_Mapping t))\n     | Some x \\<Rightarrow>\n         RBT_Mapping (RBT_Mapping2.filter (\\<lambda>(x, y). P x y) t))", "by (auto simp add: Mapping.filter.abs_eq Mapping_inject split: option.split)"], ["", "definition \"filter_join pos X m = Mapping.filter (join_filter_cond pos X) m\""], ["", "declare [[code drop: join_mmsaux]]"], ["", "declare join_mmsaux.simps[folded filter_join_def, code]"], ["", "lemma filter_join_False_empty: \"filter_join False {} m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_join False {} m = m", "unfolding filter_join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.filter (join_filter_cond False {}) m = m", "by transfer (auto split: option.splits)"], ["", "lemma filter_join_False_insert: \"filter_join False (insert a A) m =\n  filter_join False A (Mapping.delete a m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_join False (insert a A) m =\n    filter_join False A (Mapping.delete a m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter_join False (insert a A) m =\n    filter_join False A (Mapping.delete a m)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. filter_join False (insert a A) m =\n    filter_join False A (Mapping.delete a m)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. filter_join False (insert a A) m =\n    filter_join False A (Mapping.delete a m)", "have \"Mapping.lookup (filter_join False (insert a A) m) x =\n      Mapping.lookup (filter_join False A (Mapping.delete a m)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (filter_join False (insert a A) m) x =\n    Mapping.lookup (filter_join False A (Mapping.delete a m)) x", "by (auto simp add: filter_join_def Mapping.lookup_filter Mapping_lookup_delete\n          split: option.splits)"], ["proof (state)\nthis:\n  Mapping.lookup (filter_join False (insert a A) m) x =\n  Mapping.lookup (filter_join False A (Mapping.delete a m)) x\n\ngoal (1 subgoal):\n 1. filter_join False (insert a A) m =\n    filter_join False A (Mapping.delete a m)", "}"], ["proof (state)\nthis:\n  Mapping.lookup (filter_join False (insert a A) m) ?x2 =\n  Mapping.lookup (filter_join False A (Mapping.delete a m)) ?x2\n\ngoal (1 subgoal):\n 1. filter_join False (insert a A) m =\n    filter_join False A (Mapping.delete a m)", "then"], ["proof (chain)\npicking this:\n  Mapping.lookup (filter_join False (insert a A) m) ?x2 =\n  Mapping.lookup (filter_join False A (Mapping.delete a m)) ?x2", "show ?thesis"], ["proof (prove)\nusing this:\n  Mapping.lookup (filter_join False (insert a A) m) ?x2 =\n  Mapping.lookup (filter_join False A (Mapping.delete a m)) ?x2\n\ngoal (1 subgoal):\n 1. filter_join False (insert a A) m =\n    filter_join False A (Mapping.delete a m)", "by (simp add: mapping_eqI)"], ["proof (state)\nthis:\n  filter_join False (insert a A) m =\n  filter_join False A (Mapping.delete a m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_join_False:\n  assumes \"finite A\"\n  shows \"filter_join False A m = Finite_Set.fold Mapping.delete m A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_join False A m = Finite_Set.fold Mapping.delete m A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter_join False A m = Finite_Set.fold Mapping.delete m A", "interpret comp_fun_idem \"Mapping.delete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem Mapping.delete", "by (unfold_locales; transfer) (fastforce simp add: comp_def)+"], ["proof (state)\ngoal (1 subgoal):\n 1. filter_join False A m = Finite_Set.fold Mapping.delete m A", "from assms"], ["proof (chain)\npicking this:\n  finite A", "show ?thesis"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. filter_join False A m = Finite_Set.fold Mapping.delete m A", "by (induction A arbitrary: m rule: finite.induct)\n       (auto simp add: filter_join_False_empty filter_join_False_insert fold_fun_left_comm)"], ["proof (state)\nthis:\n  filter_join False A m = Finite_Set.fold Mapping.delete m A\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition filter_not_in_cfi :: \"('a, ('a, 'b) mapping) comp_fun_idem\" is \"Mapping.delete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem Mapping.delete", "by (unfold_locales; transfer) (fastforce simp add: comp_def)+"], ["", "lemma filter_join_code[code]:\n  \"filter_join pos A m =\n    (if \\<not>pos \\<and> finite A \\<and> card A < Mapping.size m then set_fold_cfi filter_not_in_cfi m A\n    else Mapping.filter (join_filter_cond pos A) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_join pos A m =\n    (if \\<not> pos \\<and> finite A \\<and> card A < Mapping.size m\n     then set_fold_cfi filter_not_in_cfi m A\n     else Mapping.filter (join_filter_cond pos A) m)", "unfolding filter_join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.filter (join_filter_cond pos A) m =\n    (if \\<not> pos \\<and> finite A \\<and> card A < Mapping.size m\n     then set_fold_cfi filter_not_in_cfi m A\n     else Mapping.filter (join_filter_cond pos A) m)", "by (transfer fixing: m) (use filter_join_False in \\<open>auto simp add: filter_join_def\\<close>)"], ["", "definition set_minus :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set\" where\n  \"set_minus X Y = X - Y\""], ["", "lift_definition remove_cfi :: \"('a, 'a set) comp_fun_idem\"\n  is \"\\<lambda>b a. a - {b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem (\\<lambda>b a. a - {b})", "by unfold_locales auto"], ["", "lemma set_minus_finite:\n  assumes fin: \"finite Y\"\n  shows \"set_minus X Y = Finite_Set.fold (\\<lambda>a X. X - {a}) X Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_minus X Y = Finite_Set.fold (\\<lambda>a X. X - {a}) X Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_minus X Y = Finite_Set.fold (\\<lambda>a X. X - {a}) X Y", "interpret comp_fun_idem \"\\<lambda>a X. X - {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem (\\<lambda>a X. X - {a})", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. set_minus X Y = Finite_Set.fold (\\<lambda>a X. X - {a}) X Y", "from assms"], ["proof (chain)\npicking this:\n  finite Y", "show ?thesis"], ["proof (prove)\nusing this:\n  finite Y\n\ngoal (1 subgoal):\n 1. set_minus X Y = Finite_Set.fold (\\<lambda>a X. X - {a}) X Y", "by (induction Y arbitrary: X rule: finite.induct) (auto simp add: set_minus_def)"], ["proof (state)\nthis:\n  set_minus X Y = Finite_Set.fold (\\<lambda>a X. X - {a}) X Y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_minus_code[code]: \"set_minus X Y =\n  (if finite Y \\<and> card Y < card X then set_fold_cfi remove_cfi X Y else X - Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_minus X Y =\n    (if finite Y \\<and> card Y < card X then set_fold_cfi remove_cfi X Y\n     else X - Y)", "by transfer (use set_minus_finite in \\<open>auto simp add: set_minus_def\\<close>)"], ["", "declare [[code drop: bin_join]]"], ["", "declare bin_join.simps[folded set_minus_def, code]"], ["", "definition remove_Union where\n  \"remove_Union A X B = A - (\\<Union>x \\<in> X. B x)\""], ["", "lemma remove_Union_finite: \n  assumes \"finite X\"\n  shows \"remove_Union A X B = Finite_Set.fold (\\<lambda>x A. A - B x) A X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_Union A X B = Finite_Set.fold (\\<lambda>x A. A - B x) A X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. remove_Union A X B = Finite_Set.fold (\\<lambda>x A. A - B x) A X", "interpret comp_fun_idem \"\\<lambda>x A. A - B x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem (\\<lambda>x A. A - B x)", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. remove_Union A X B = Finite_Set.fold (\\<lambda>x A. A - B x) A X", "from assms"], ["proof (chain)\npicking this:\n  finite X", "show ?thesis"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. remove_Union A X B = Finite_Set.fold (\\<lambda>x A. A - B x) A X", "by (induct X arbitrary: A rule: finite_induct) (auto simp: remove_Union_def)"], ["proof (state)\nthis:\n  remove_Union A X B = Finite_Set.fold (\\<lambda>x A. A - B x) A X\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition remove_Union_cfi :: \"('a \\<Rightarrow> 'b set) \\<Rightarrow> ('a, 'b set) comp_fun_idem\" is \"\\<lambda>B x A. A - B x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. comp_fun_idem (\\<lambda>x A. A - fun x)", "by unfold_locales auto"], ["", "lemma remove_Union_code[code]: \"remove_Union A X B =\n  (if finite X then set_fold_cfi (remove_Union_cfi B) A X else A - (\\<Union>x \\<in> X. B x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_Union A X B =\n    (if finite X then set_fold_cfi (remove_Union_cfi B) A X\n     else A - \\<Union> (B ` X))", "by (transfer fixing: A X B) (use remove_Union_finite[of X A B] in \\<open>auto simp add: remove_Union_def\\<close>)"], ["", "lemma tabulate_remdups: \"Mapping.tabulate xs f = Mapping.tabulate (remdups xs) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.tabulate xs f = Mapping.tabulate (remdups xs) f", "by (transfer fixing: xs f) (auto simp: map_of_map_restrict)"], ["", "lift_definition clearjunk :: \"(String.literal \\<times> event_data list set) list \\<Rightarrow> (String.literal, event_data list set list) alist\" is\n  \"\\<lambda>t. List.map_filter (\\<lambda>(p, X). if X = {} then None else Some (p, [X])) (AList.clearjunk t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       (distinct \\<circ> map fst)\n        (List.map_filter\n          (\\<lambda>(p, X). if X = {} then None else Some (p, [X]))\n          (AList.clearjunk list))", "unfolding map_filter_def o_def list.map_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       distinct\n        (map (\\<lambda>x.\n                 fst (the (case x of\n                           (p, X) \\<Rightarrow>\n                             if X = {} then None else Some (p, [X]))))\n          (filter\n            (\\<lambda>x.\n                (case x of\n                 (p, X) \\<Rightarrow>\n                   if X = {} then None else Some (p, [X])) \\<noteq>\n                None)\n            (AList.clearjunk list)))", "by (subst map_cong[OF refl, of _ _ fst]) (auto simp: map_filter_def distinct_map_fst_filter split: if_splits)"], ["", "lemma map_filter_snd_map_filter: \"List.map_filter (\\<lambda>(a, b). if P b then None else Some (f a b)) xs =\n    map (\\<lambda>(a, b). f a b) (filter (\\<lambda>x. \\<not> P (snd x)) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_filter (\\<lambda>(a, b). if P b then None else Some (f a b))\n     xs =\n    map (\\<lambda>(a, b). f a b) (filter (\\<lambda>x. \\<not> P (snd x)) xs)", "by (simp add: map_filter_def prod.case_eq_if)"], ["", "lemma mk_db_code_alist:\n  \"mk_db t = Assoc_List_Mapping (clearjunk t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor_Impl.mk_db t = Assoc_List_Mapping (clearjunk t)", "unfolding mk_db_def Assoc_List_Mapping_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor.mk_db\n     (\\<Union>n\\<in>set (map fst t). Pair n ` the (map_of t n)) =\n    Mapping (DAList.lookup (clearjunk t))", "by (transfer' fixing: t)\n    (auto simp: map_filter_snd_map_filter fun_eq_iff map_of_map image_iff map_of_clearjunk\n      map_of_filter_apply dest: weak_map_of_SomeI intro!: bexI[rotated, OF map_of_SomeD]\n      split: if_splits option.splits)"], ["", "lemma mk_db_code[code]:\n  \"mk_db t = Mapping.of_alist (List.map_filter (\\<lambda>(p, X). if X = {} then None else Some (p, [X])) (AList.clearjunk t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor_Impl.mk_db t =\n    Mapping.of_alist\n     (List.map_filter\n       (\\<lambda>(p, X). if X = {} then None else Some (p, [X]))\n       (AList.clearjunk t))", "unfolding mk_db_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor.mk_db\n     (\\<Union>n\\<in>set (map fst t). Pair n ` the (map_of t n)) =\n    Mapping.of_alist\n     (List.map_filter\n       (\\<lambda>(p, X). if X = {} then None else Some (p, [X]))\n       (AList.clearjunk t))", "by (transfer' fixing: t) (auto simp: map_filter_snd_map_filter fun_eq_iff map_of_map image_iff\n      map_of_clearjunk map_of_filter_apply dest: weak_map_of_SomeI intro!: bexI[rotated, OF map_of_SomeD]\n      split: if_splits option.splits)"], ["", "declare [[code drop: New_max_getIJ_genericJoin New_max_getIJ_wrapperGenericJoin]]"], ["", "declare New_max.genericJoin.simps[folded remove_Union_def, code]"], ["", "declare New_max.wrapperGenericJoin.simps[folded remove_Union_def, code]"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}