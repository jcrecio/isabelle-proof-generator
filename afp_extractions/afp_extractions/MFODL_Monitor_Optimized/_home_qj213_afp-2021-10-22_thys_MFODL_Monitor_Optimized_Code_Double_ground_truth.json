{"file_name": "/home/qj213/afp-2021-10-22/thys/MFODL_Monitor_Optimized/Code_Double.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFODL_Monitor_Optimized", "problem_names": ["lemma is_nan_copysign[simp]: \"is_nan (copysign x y) \\<longleftrightarrow> is_nan x\"", "lemma is_nan_some_nan[simp]: \"is_nan (some_nan :: ('e, 'f) float)\"", "lemma not_is_nan_0[simp]: \"\\<not> is_nan 0\"", "lemma not_is_nan_1[simp]: \"\\<not> is_nan 1\"", "lemma is_nan_plus: \"is_nan x \\<or> is_nan y \\<Longrightarrow> is_nan (x + y)\"", "lemma is_nan_minus: \"is_nan x \\<or> is_nan y \\<Longrightarrow> is_nan (x - y)\"", "lemma is_nan_times: \"is_nan x \\<or> is_nan y \\<Longrightarrow> is_nan (x * y)\"", "lemma is_nan_divide: \"is_nan x \\<or> is_nan y \\<Longrightarrow> is_nan (x / y)\"", "lemma is_nan_float_sqrt: \"is_nan x \\<Longrightarrow> is_nan (float_sqrt x)\"", "lemma nan_fcompare: \"is_nan x \\<or> is_nan y \\<Longrightarrow> fcompare x y = Und\"", "lemma nan_not_le: \"is_nan x \\<or> is_nan y \\<Longrightarrow> \\<not> x \\<le> y\"", "lemma nan_not_less: \"is_nan x \\<or> is_nan y \\<Longrightarrow> \\<not> x < y\"", "lemma nan_not_zero: \"is_nan x \\<Longrightarrow> \\<not> is_zero x\"", "lemma nan_not_infinity: \"is_nan x \\<Longrightarrow> \\<not> is_infinity x\"", "lemma zero_not_infinity: \"is_zero x \\<Longrightarrow> \\<not> is_infinity x\"", "lemma zero_not_nan: \"is_zero x \\<Longrightarrow> \\<not> is_nan x\"", "lemma minus_one_power_one_word: \"(-1 :: real) ^ unat (x :: 1 word) = (if unat x = 0 then 1 else -1)\"", "lemma valof_alt: \"valof x = (if exponent x = 0 then\n    if sign x = 0 then valofd x else - valofd x\n  else if sign x = 0 then valofn x else - valofn x)\"", "lemma fraction_less_2p: \"fraction (x :: ('e, 'f) float) < 2^LENGTH('f)\"", "lemma valofn_ge_0: \"0 \\<le> valofn x\"", "lemma valofn_ge_2p: \"2^exponent (x :: ('e, 'f) float) / 2^bias TYPE(('e, 'f) float) \\<le> valofn x\"", "lemma valofn_less_2p:\n  fixes x :: \"('e, 'f) float\"\n  assumes \"exponent x < e\"\n  shows \"valofn x < 2^e / 2^bias TYPE(('e, 'f) float)\"", "lemma valofd_ge_0: \"0 \\<le> valofd x\"", "lemma valofd_less_2p: \"valofd (x :: ('e, 'f) float) < 2 / 2^bias TYPE(('e, 'f) float)\"", "lemma valofn_le_imp_exponent_le:\n  fixes x y :: \"('e, 'f) float\"\n  assumes \"valofn x \\<le> valofn y\"\n  shows \"exponent x \\<le> exponent y\"", "lemma valofn_eq:\n  fixes x y :: \"('e, 'f) float\"\n  assumes \"valofn x = valofn y\"\n  shows \"exponent x = exponent y\" \"fraction x = fraction y\"", "lemma valofd_eq:\n  fixes x y :: \"('e, 'f) float\"\n  assumes \"valofd x = valofd y\"\n  shows \"fraction x = fraction y\"", "lemma is_zero_valof_conv: \"is_zero x \\<longleftrightarrow> valof x = 0\"", "lemma valofd_neq_valofn:\n  fixes x y :: \"('e, 'f) float\"\n  assumes \"exponent y \\<noteq> 0\"\n  shows \"valofd x \\<noteq> valofn y\" \"valofn y \\<noteq> valofd x\"", "lemma sign_gt_0_conv: \"0 < sign x \\<longleftrightarrow> sign x = 1\"", "lemma valof_eq:\n  assumes \"\\<not> is_zero x \\<or> \\<not> is_zero y\"\n  shows \"valof x = valof y \\<longleftrightarrow> x = y\"", "lemma zero_fcompare: \"is_zero x \\<Longrightarrow> is_zero y \\<Longrightarrow> fcompare x y = ccode.Eq\"", "lemma is_nan_conv: \"is_nan x \\<longleftrightarrow> x = nan\"", "lemma nan_fcompare_double: \"is_nan x \\<or> is_nan y \\<Longrightarrow> fcompare_double x y = Und\"", "lemmas compare_double_simps = compare_double_less compare_double_eq compare_double_greater", "lemma compare_double_le_0: \"compare_double x y \\<le> 0 \\<longleftrightarrow>\n  is_nan x \\<or> fcompare_double x y \\<in> {ccode.Eq, ccode.Lt}\"", "lemma [code]: \"double_of_int (int_of_integer x) = double_of_integer x\"", "lemma fcompare_double_swap: \"fcompare_double x y = ccode.Gt \\<longleftrightarrow> fcompare_double y x = ccode.Lt\"", "lemma fcompare_double_refl: \"\\<not> is_nan x \\<Longrightarrow> fcompare_double x x = ccode.Eq\"", "lemma fcompare_double_Eq1: \"fcompare_double x y = ccode.Eq \\<Longrightarrow> fcompare_double y z = c \\<Longrightarrow> fcompare_double x z = c\"", "lemma fcompare_double_Eq2: \"fcompare_double y z = ccode.Eq \\<Longrightarrow> fcompare_double x y = c \\<Longrightarrow> fcompare_double x z = c\"", "lemma fcompare_double_Lt_trans: \"fcompare_double x y = ccode.Lt \\<Longrightarrow> fcompare_double y z = ccode.Lt \\<Longrightarrow> fcompare_double x z = ccode.Lt\"", "lemma fcompare_double_eq: \"\\<not> is_zero x \\<or> \\<not> is_zero y \\<Longrightarrow> fcompare_double x y = ccode.Eq \\<Longrightarrow> x = y\"", "lemma fcompare_double_Lt_asym: \"fcompare_double x y = ccode.Lt \\<Longrightarrow> fcompare_double y x = ccode.Lt \\<Longrightarrow> False\"", "lemma compare_double_swap: \"0 < compare_double x y \\<longleftrightarrow> compare_double y x < 0\"", "lemma compare_double_refl: \"compare_double x x = 0\"", "lemma compare_double_trans: \"compare_double x y \\<le> 0 \\<Longrightarrow> compare_double y z \\<le> 0 \\<Longrightarrow> compare_double x z \\<le> 0\"", "lemma compare_double_antisym: \"compare_double x y \\<le> 0 \\<Longrightarrow> compare_double y x \\<le> 0 \\<Longrightarrow>\n  \\<not> is_zero x \\<or> \\<not> is_zero y \\<Longrightarrow> x = y\"", "lemma zero_compare_double_copysign: \"compare_double (copysign_double 1 x) (copysign_double 1 y) \\<le> 0 \\<Longrightarrow>\n  is_zero x \\<Longrightarrow> is_zero y \\<Longrightarrow> compare_double x y \\<le> 0\"", "lemma is_zero_double_cases: \"is_zero x \\<Longrightarrow> (x = 0 \\<Longrightarrow> P) \\<Longrightarrow> (x = -0 \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma copysign_1_0[simp]: \"copysign_double 1 0 = 1\" \"copysign_double 1 (-0) = -1\"", "lemma is_zero_uminus_double[simp]: \"is_zero (- x) \\<longleftrightarrow> is_zero x\"", "lemma not_is_zero_one_double[simp]: \"\\<not> is_zero 1\"", "lemma uminus_one_neq_one_double[simp]: \"- 1 \\<noteq> (1 :: double)\"", "lemma lcompare_double_ge_0: \"lcompare_double x y \\<ge> 0 \\<longleftrightarrow> lle_double y x\"", "lemma lcompare_double_gt_0: \"lcompare_double x y > 0 \\<longleftrightarrow> lless_double y x\"", "lemma lcompare_double_eq_0: \"lcompare_double x y = 0 \\<longleftrightarrow> x = y\"", "lemmas lcompare_double_0_folds = lle_double_def[symmetric] lless_double_def[symmetric]\n  lcompare_double_ge_0 lcompare_double_gt_0 lcompare_double_eq_0", "lemma comparator_double: \"comparator comparator_double\""], "translations": [["", "lemma is_nan_copysign[simp]: \"is_nan (copysign x y) \\<longleftrightarrow> is_nan x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan (copysign x y) = is_nan x", "unfolding is_nan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (IEEE.exponent (copysign x y) = emax TYPE(('a, 'b) IEEE.float) \\<and>\n     fraction (copysign x y) \\<noteq> 0) =\n    (IEEE.exponent x = emax TYPE(('a, 'b) IEEE.float) \\<and>\n     fraction x \\<noteq> 0)", "by transfer auto"], ["", "subsection \\<open>Additional lemmas about generic floats\\<close>"], ["", "lemma is_nan_some_nan[simp]: \"is_nan (some_nan :: ('e, 'f) float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan some_nan", "unfolding some_nan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan (Eps is_nan)", "by (rule someI[where x=\"Abs_float (0, max_word :: 'e word, 1)\"])\n    (auto simp add: is_nan_def exponent_def fraction_def emax_def Abs_float_inverse[simplified])"], ["", "lemma not_is_nan_0[simp]: \"\\<not> is_nan 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_nan 0", "unfolding is_nan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (IEEE.exponent 0 = emax TYPE(('a, 'b) IEEE.float) \\<and>\n            fraction 0 \\<noteq> 0)", "by (simp add: zero_simps)"], ["", "lemma not_is_nan_1[simp]: \"\\<not> is_nan 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_nan 1", "unfolding is_nan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (IEEE.exponent 1 = emax TYPE(('a, 'b) IEEE.float) \\<and>\n            fraction 1 \\<noteq> 0)", "by transfer simp"], ["", "lemma is_nan_plus: \"is_nan x \\<or> is_nan y \\<Longrightarrow> is_nan (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<or> is_nan y \\<Longrightarrow> is_nan (x + y)", "unfolding plus_float_def fadd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<or> is_nan y \\<Longrightarrow>\n    is_nan\n     (if is_nan x \\<or>\n         is_nan y \\<or>\n         is_infinity x \\<and> is_infinity y \\<and> sign x \\<noteq> sign y\n      then some_nan\n      else if is_infinity x then x\n           else if is_infinity y then y\n                else zerosign\n                      (if is_zero x \\<and> is_zero y \\<and> sign x = sign y\n                       then sign x\n                       else if To_nearest = To_ninfinity then 1 else 0)\n                      (IEEE.round To_nearest (valof x + valof y)))", "by auto"], ["", "lemma is_nan_minus: \"is_nan x \\<or> is_nan y \\<Longrightarrow> is_nan (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<or> is_nan y \\<Longrightarrow> is_nan (x - y)", "unfolding minus_float_def fsub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<or> is_nan y \\<Longrightarrow>\n    is_nan\n     (if is_nan x \\<or>\n         is_nan y \\<or>\n         is_infinity x \\<and> is_infinity y \\<and> sign x = sign y\n      then some_nan\n      else if is_infinity x then x\n           else if is_infinity y then - y\n                else zerosign\n                      (if is_zero x \\<and>\n                          is_zero y \\<and> sign x \\<noteq> sign y\n                       then sign x\n                       else if To_nearest = To_ninfinity then 1 else 0)\n                      (IEEE.round To_nearest (valof x - valof y)))", "by auto"], ["", "lemma is_nan_times: \"is_nan x \\<or> is_nan y \\<Longrightarrow> is_nan (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<or> is_nan y \\<Longrightarrow> is_nan (x * y)", "unfolding times_float_def fmul_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<or> is_nan y \\<Longrightarrow>\n    is_nan\n     (if is_nan x \\<or>\n         is_nan y \\<or>\n         is_zero x \\<and> is_infinity y \\<or> is_infinity x \\<and> is_zero y\n      then some_nan\n      else if is_infinity x \\<or> is_infinity y\n           then if sign x = sign y then \\<infinity> else - \\<infinity>\n           else zerosign (if sign x = sign y then 0 else 1)\n                 (IEEE.round To_nearest (valof x * valof y)))", "by auto"], ["", "lemma is_nan_divide: \"is_nan x \\<or> is_nan y \\<Longrightarrow> is_nan (x / y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<or> is_nan y \\<Longrightarrow> is_nan (x / y)", "unfolding divide_float_def fdiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<or> is_nan y \\<Longrightarrow>\n    is_nan\n     (if is_nan x \\<or>\n         is_nan y \\<or>\n         is_zero x \\<and> is_zero y \\<or> is_infinity x \\<and> is_infinity y\n      then some_nan\n      else if is_infinity x \\<or> is_zero y\n           then if sign x = sign y then \\<infinity> else - \\<infinity>\n           else if is_infinity y then if sign x = sign y then 0 else - 0\n                else zerosign (if sign x = sign y then 0 else 1)\n                      (IEEE.round To_nearest (valof x / valof y)))", "by auto"], ["", "lemma is_nan_float_sqrt: \"is_nan x \\<Longrightarrow> is_nan (float_sqrt x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<Longrightarrow> is_nan (float_sqrt x)", "unfolding float_sqrt_def fsqrt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<Longrightarrow>\n    is_nan\n     (if is_nan x then some_nan\n      else if is_zero x \\<or> is_infinity x \\<and> sign x = 0 then x\n           else if sign x = 1 then some_nan\n                else zerosign (sign x)\n                      (IEEE.round To_nearest (sqrt (valof x))))", "by simp"], ["", "lemma nan_fcompare: \"is_nan x \\<or> is_nan y \\<Longrightarrow> fcompare x y = Und\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<or> is_nan y \\<Longrightarrow> fcompare x y = Und", "unfolding fcompare_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<or> is_nan y \\<Longrightarrow>\n    (if is_nan x \\<or> is_nan y then Und\n     else if is_infinity x \\<and> sign x = 1\n          then if is_infinity y \\<and> sign y = 1 then ccode.Eq\n               else ccode.Lt\n          else if is_infinity x \\<and> sign x = 0\n               then if is_infinity y \\<and> sign y = 0 then ccode.Eq\n                    else ccode.Gt\n               else if is_infinity y \\<and> sign y = 1 then ccode.Gt\n                    else if is_infinity y \\<and> sign y = 0 then ccode.Lt\n                         else if valof x < valof y then ccode.Lt\n                              else if valof x = valof y then ccode.Eq\n                                   else ccode.Gt) =\n    Und", "by simp"], ["", "lemma nan_not_le: \"is_nan x \\<or> is_nan y \\<Longrightarrow> \\<not> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<or> is_nan y \\<Longrightarrow> \\<not> x \\<le> y", "unfolding less_eq_float_def fle_def fcompare_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<or> is_nan y \\<Longrightarrow>\n    \\<not> ((if is_nan x \\<or> is_nan y then Und\n             else if is_infinity x \\<and> sign x = 1\n                  then if is_infinity y \\<and> sign y = 1 then ccode.Eq\n                       else ccode.Lt\n                  else if is_infinity x \\<and> sign x = 0\n                       then if is_infinity y \\<and> sign y = 0 then ccode.Eq\n                            else ccode.Gt\n                       else if is_infinity y \\<and> sign y = 1 then ccode.Gt\n                            else if is_infinity y \\<and> sign y = 0\n                                 then ccode.Lt\n                                 else if valof x < valof y then ccode.Lt\nelse if valof x = valof y then ccode.Eq else ccode.Gt) =\n            ccode.Lt \\<or>\n            (if is_nan x \\<or> is_nan y then Und\n             else if is_infinity x \\<and> sign x = 1\n                  then if is_infinity y \\<and> sign y = 1 then ccode.Eq\n                       else ccode.Lt\n                  else if is_infinity x \\<and> sign x = 0\n                       then if is_infinity y \\<and> sign y = 0 then ccode.Eq\n                            else ccode.Gt\n                       else if is_infinity y \\<and> sign y = 1 then ccode.Gt\n                            else if is_infinity y \\<and> sign y = 0\n                                 then ccode.Lt\n                                 else if valof x < valof y then ccode.Lt\nelse if valof x = valof y then ccode.Eq else ccode.Gt) =\n            ccode.Eq)", "by simp"], ["", "lemma nan_not_less: \"is_nan x \\<or> is_nan y \\<Longrightarrow> \\<not> x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<or> is_nan y \\<Longrightarrow> \\<not> x < y", "unfolding less_float_def flt_def fcompare_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<or> is_nan y \\<Longrightarrow>\n    (if is_nan x \\<or> is_nan y then Und\n     else if is_infinity x \\<and> sign x = 1\n          then if is_infinity y \\<and> sign y = 1 then ccode.Eq\n               else ccode.Lt\n          else if is_infinity x \\<and> sign x = 0\n               then if is_infinity y \\<and> sign y = 0 then ccode.Eq\n                    else ccode.Gt\n               else if is_infinity y \\<and> sign y = 1 then ccode.Gt\n                    else if is_infinity y \\<and> sign y = 0 then ccode.Lt\n                         else if valof x < valof y then ccode.Lt\n                              else if valof x = valof y then ccode.Eq\n                                   else ccode.Gt) \\<noteq>\n    ccode.Lt", "by simp"], ["", "lemma nan_not_zero: \"is_nan x \\<Longrightarrow> \\<not> is_zero x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<Longrightarrow> \\<not> is_zero x", "unfolding is_nan_def is_zero_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent x = emax TYPE(('a, 'b) IEEE.float) \\<and>\n    fraction x \\<noteq> 0 \\<Longrightarrow>\n    \\<not> (IEEE.exponent x = 0 \\<and> fraction x = 0)", "by simp"], ["", "lemma nan_not_infinity: \"is_nan x \\<Longrightarrow> \\<not> is_infinity x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<Longrightarrow> \\<not> is_infinity x", "unfolding is_nan_def is_infinity_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent x = emax TYPE(('a, 'b) IEEE.float) \\<and>\n    fraction x \\<noteq> 0 \\<Longrightarrow>\n    \\<not> (IEEE.exponent x = emax TYPE(('a, 'b) IEEE.float) \\<and>\n            fraction x = 0)", "by simp"], ["", "lemma zero_not_infinity: \"is_zero x \\<Longrightarrow> \\<not> is_infinity x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero x \\<Longrightarrow> \\<not> is_infinity x", "unfolding is_zero_def is_infinity_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent x = 0 \\<and> fraction x = 0 \\<Longrightarrow>\n    \\<not> (IEEE.exponent x = emax TYPE(('a, 'b) IEEE.float) \\<and>\n            fraction x = 0)", "by simp"], ["", "lemma zero_not_nan: \"is_zero x \\<Longrightarrow> \\<not> is_nan x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero x \\<Longrightarrow> \\<not> is_nan x", "unfolding is_zero_def is_nan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent x = 0 \\<and> fraction x = 0 \\<Longrightarrow>\n    \\<not> (IEEE.exponent x = emax TYPE(('a, 'b) IEEE.float) \\<and>\n            fraction x \\<noteq> 0)", "by simp"], ["", "lemma minus_one_power_one_word: \"(-1 :: real) ^ unat (x :: 1 word) = (if unat x = 0 then 1 else -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ unat x = (if unat x = 0 then 1 else - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (- 1) ^ unat x = (if unat x = 0 then 1 else - 1)", "have \"unat x = 0 \\<or> unat x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat x = 0 \\<or> unat x = 1", "using le_SucE[OF unat_one_word_le]"], ["proof (prove)\nusing this:\n  \\<lbrakk>unat ?a1 \\<le> 0 \\<Longrightarrow> ?R;\n   unat ?a1 = Suc 0 \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. unat x = 0 \\<or> unat x = 1", "by auto"], ["proof (state)\nthis:\n  unat x = 0 \\<or> unat x = 1\n\ngoal (1 subgoal):\n 1. (- 1) ^ unat x = (if unat x = 0 then 1 else - 1)", "then"], ["proof (chain)\npicking this:\n  unat x = 0 \\<or> unat x = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  unat x = 0 \\<or> unat x = 1\n\ngoal (1 subgoal):\n 1. (- 1) ^ unat x = (if unat x = 0 then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  (- 1) ^ unat x = (if unat x = 0 then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition valofn :: \"('e, 'f) float \\<Rightarrow> real\" where\n  \"valofn x = (2^exponent x / 2^bias TYPE(('e, 'f) float)) *\n      (1 + real (fraction x) / 2^LENGTH('f))\""], ["", "definition valofd :: \"('e, 'f) float \\<Rightarrow> real\" where\n  \"valofd x = (2 / 2^bias TYPE(('e, 'f) float)) * (real (fraction x) / 2^LENGTH('f))\""], ["", "lemma valof_alt: \"valof x = (if exponent x = 0 then\n    if sign x = 0 then valofd x else - valofd x\n  else if sign x = 0 then valofn x else - valofn x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof x =\n    (if IEEE.exponent x = 0 then if sign x = 0 then valofd x else - valofd x\n     else if sign x = 0 then valofn x else - valofn x)", "unfolding valofn_def valofd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valof x =\n    (if IEEE.exponent x = 0\n     then if sign x = 0\n          then 2 / 2 ^ bias TYPE(('a, 'b) IEEE.float) *\n               (real (fraction x) / 2 ^ LENGTH('b))\n          else - (2 / 2 ^ bias TYPE(('a, 'b) IEEE.float) *\n                  (real (fraction x) / 2 ^ LENGTH('b)))\n     else if sign x = 0\n          then 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('a, 'b) IEEE.float) *\n               (1 + real (fraction x) / 2 ^ LENGTH('b))\n          else - (2 ^ IEEE.exponent x / 2 ^ bias TYPE(('a, 'b) IEEE.float) *\n                  (1 + real (fraction x) / 2 ^ LENGTH('b))))", "by transfer (auto simp: minus_one_power_one_word unat_eq_0 field_simps)"], ["", "lemma fraction_less_2p: \"fraction (x :: ('e, 'f) float) < 2^LENGTH('f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction x < 2 ^ LENGTH('f)", "by transfer auto"], ["", "lemma valofn_ge_0: \"0 \\<le> valofn x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> valofn x", "unfolding valofn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('a, 'b) IEEE.float) *\n            (1 + real (fraction x) / 2 ^ LENGTH('b))", "by simp"], ["", "lemma valofn_ge_2p: \"2^exponent (x :: ('e, 'f) float) / 2^bias TYPE(('e, 'f) float) \\<le> valofn x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float) \\<le> valofn x", "unfolding valofn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n    \\<le> 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float) *\n          (1 + real (fraction x) / 2 ^ LENGTH('f))", "by (simp add: field_simps)"], ["", "lemma valofn_less_2p:\n  fixes x :: \"('e, 'f) float\"\n  assumes \"exponent x < e\"\n  shows \"valofn x < 2^e / 2^bias TYPE(('e, 'f) float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valofn x < 2 ^ e / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valofn x < 2 ^ e / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "have \"1 + real (fraction x) / 2^LENGTH('f) < 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + real (fraction x) / 2 ^ LENGTH('f) < 2", "by (simp add: fraction_less_2p)"], ["proof (state)\nthis:\n  1 + real (fraction x) / 2 ^ LENGTH('f) < 2\n\ngoal (1 subgoal):\n 1. valofn x < 2 ^ e / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "then"], ["proof (chain)\npicking this:\n  1 + real (fraction x) / 2 ^ LENGTH('f) < 2", "have \"valofn x < (2^exponent x / 2^bias TYPE(('e, 'f) float)) * 2\""], ["proof (prove)\nusing this:\n  1 + real (fraction x) / 2 ^ LENGTH('f) < 2\n\ngoal (1 subgoal):\n 1. valofn x < 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float) * 2", "unfolding valofn_def"], ["proof (prove)\nusing this:\n  1 + real (fraction x) / 2 ^ LENGTH('f) < 2\n\ngoal (1 subgoal):\n 1. 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float) *\n    (1 + real (fraction x) / 2 ^ LENGTH('f))\n    < 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float) * 2", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  valofn x < 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float) * 2\n\ngoal (1 subgoal):\n 1. valofn x < 2 ^ e / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "also"], ["proof (state)\nthis:\n  valofn x < 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float) * 2\n\ngoal (1 subgoal):\n 1. valofn x < 2 ^ e / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "have \"... \\<le> 2^e / 2^bias TYPE(('e, 'f) float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float) * 2\n    \\<le> 2 ^ e / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "using assms"], ["proof (prove)\nusing this:\n  IEEE.exponent x < e\n\ngoal (1 subgoal):\n 1. 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float) * 2\n    \\<le> 2 ^ e / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "by (auto simp: less_eq_Suc_le field_simps elim: order_trans[rotated, OF exp_less])"], ["proof (state)\nthis:\n  2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float) * 2\n  \\<le> 2 ^ e / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. valofn x < 2 ^ e / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "finally"], ["proof (chain)\npicking this:\n  valofn x < 2 ^ e / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "show ?thesis"], ["proof (prove)\nusing this:\n  valofn x < 2 ^ e / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. valofn x < 2 ^ e / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "."], ["proof (state)\nthis:\n  valofn x < 2 ^ e / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valofd_ge_0: \"0 \\<le> valofd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> valofd x", "unfolding valofd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 2 / 2 ^ bias TYPE(('a, 'b) IEEE.float) *\n            (real (fraction x) / 2 ^ LENGTH('b))", "by simp"], ["", "lemma valofd_less_2p: \"valofd (x :: ('e, 'f) float) < 2 / 2^bias TYPE(('e, 'f) float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valofd x < 2 / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "unfolding valofd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 / 2 ^ bias TYPE(('e, 'f) IEEE.float) *\n    (real (fraction x) / 2 ^ LENGTH('f))\n    < 2 / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "by (simp add: fraction_less_2p field_simps)"], ["", "lemma valofn_le_imp_exponent_le:\n  fixes x y :: \"('e, 'f) float\"\n  assumes \"valofn x \\<le> valofn y\"\n  shows \"exponent x \\<le> exponent y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent x \\<le> IEEE.exponent y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> IEEE.exponent x \\<le> IEEE.exponent y \\<Longrightarrow> False", "assume \"\\<not> exponent x \\<le> exponent y\""], ["proof (state)\nthis:\n  \\<not> IEEE.exponent x \\<le> IEEE.exponent y\n\ngoal (1 subgoal):\n 1. \\<not> IEEE.exponent x \\<le> IEEE.exponent y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> IEEE.exponent x \\<le> IEEE.exponent y", "have \"valofn y < 2^exponent x / 2^bias TYPE(('e, 'f) float)\""], ["proof (prove)\nusing this:\n  \\<not> IEEE.exponent x \\<le> IEEE.exponent y\n\ngoal (1 subgoal):\n 1. valofn y < 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "using valofn_less_2p[of y]"], ["proof (prove)\nusing this:\n  \\<not> IEEE.exponent x \\<le> IEEE.exponent y\n  IEEE.exponent y < ?e \\<Longrightarrow>\n  valofn y < 2 ^ ?e / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. valofn y < 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "by auto"], ["proof (state)\nthis:\n  valofn y < 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. \\<not> IEEE.exponent x \\<le> IEEE.exponent y \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  valofn y < 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. \\<not> IEEE.exponent x \\<le> IEEE.exponent y \\<Longrightarrow> False", "have \"... \\<le> valofn x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float) \\<le> valofn x", "by (rule valofn_ge_2p)"], ["proof (state)\nthis:\n  2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float) \\<le> valofn x\n\ngoal (1 subgoal):\n 1. \\<not> IEEE.exponent x \\<le> IEEE.exponent y \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  valofn y < valofn x", "show False"], ["proof (prove)\nusing this:\n  valofn y < valofn x\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  valofn y < valofn x\n  valofn x \\<le> valofn y\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valofn_eq:\n  fixes x y :: \"('e, 'f) float\"\n  assumes \"valofn x = valofn y\"\n  shows \"exponent x = exponent y\" \"fraction x = fraction y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent x = IEEE.exponent y &&& fraction x = fraction y", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. IEEE.exponent x = IEEE.exponent y\n 2. fraction x = fraction y", "from assms"], ["proof (chain)\npicking this:\n  valofn x = valofn y", "show \"exponent x = exponent y\""], ["proof (prove)\nusing this:\n  valofn x = valofn y\n\ngoal (1 subgoal):\n 1. IEEE.exponent x = IEEE.exponent y", "by (auto intro!: antisym valofn_le_imp_exponent_le)"], ["proof (state)\nthis:\n  IEEE.exponent x = IEEE.exponent y\n\ngoal (1 subgoal):\n 1. fraction x = fraction y", "with assms"], ["proof (chain)\npicking this:\n  valofn x = valofn y\n  IEEE.exponent x = IEEE.exponent y", "show \"fraction x = fraction y\""], ["proof (prove)\nusing this:\n  valofn x = valofn y\n  IEEE.exponent x = IEEE.exponent y\n\ngoal (1 subgoal):\n 1. fraction x = fraction y", "unfolding valofn_def"], ["proof (prove)\nusing this:\n  2 ^ IEEE.exponent x / 2 ^ bias TYPE(('e, 'f) IEEE.float) *\n  (1 + real (fraction x) / 2 ^ LENGTH('f)) =\n  2 ^ IEEE.exponent y / 2 ^ bias TYPE(('e, 'f) IEEE.float) *\n  (1 + real (fraction y) / 2 ^ LENGTH('f))\n  IEEE.exponent x = IEEE.exponent y\n\ngoal (1 subgoal):\n 1. fraction x = fraction y", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  fraction x = fraction y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valofd_eq:\n  fixes x y :: \"('e, 'f) float\"\n  assumes \"valofd x = valofd y\"\n  shows \"fraction x = fraction y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction x = fraction y", "using assms"], ["proof (prove)\nusing this:\n  valofd x = valofd y\n\ngoal (1 subgoal):\n 1. fraction x = fraction y", "unfolding valofd_def"], ["proof (prove)\nusing this:\n  2 / 2 ^ bias TYPE(('e, 'f) IEEE.float) *\n  (real (fraction x) / 2 ^ LENGTH('f)) =\n  2 / 2 ^ bias TYPE(('e, 'f) IEEE.float) *\n  (real (fraction y) / 2 ^ LENGTH('f))\n\ngoal (1 subgoal):\n 1. fraction x = fraction y", "by (simp add: field_simps)"], ["", "lemma is_zero_valof_conv: \"is_zero x \\<longleftrightarrow> valof x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero x = (valof x = 0)", "unfolding is_zero_def valof_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (IEEE.exponent x = 0 \\<and> fraction x = 0) =\n    ((if IEEE.exponent x = 0\n      then if sign x = 0 then valofd x else - valofd x\n      else if sign x = 0 then valofn x else - valofn x) =\n     0)", "using valofn_ge_2p[of x]"], ["proof (prove)\nusing this:\n  2 ^ IEEE.exponent x / 2 ^ bias TYPE(('a, 'b) IEEE.float) \\<le> valofn x\n\ngoal (1 subgoal):\n 1. (IEEE.exponent x = 0 \\<and> fraction x = 0) =\n    ((if IEEE.exponent x = 0\n      then if sign x = 0 then valofd x else - valofd x\n      else if sign x = 0 then valofn x else - valofn x) =\n     0)", "by (auto simp: valofd_def field_simps dest: order.antisym)"], ["", "lemma valofd_neq_valofn:\n  fixes x y :: \"('e, 'f) float\"\n  assumes \"exponent y \\<noteq> 0\"\n  shows \"valofd x \\<noteq> valofn y\" \"valofn y \\<noteq> valofd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valofd x \\<noteq> valofn y &&& valofn y \\<noteq> valofd x", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. valofd x \\<noteq> valofn y\n 2. valofn y \\<noteq> valofd x", "have \"valofd x < 2 / 2^bias TYPE(('e, 'f) float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valofd x < 2 / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "by (rule valofd_less_2p)"], ["proof (state)\nthis:\n  valofd x < 2 / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n\ngoal (2 subgoals):\n 1. valofd x \\<noteq> valofn y\n 2. valofn y \\<noteq> valofd x", "also"], ["proof (state)\nthis:\n  valofd x < 2 / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n\ngoal (2 subgoals):\n 1. valofd x \\<noteq> valofn y\n 2. valofn y \\<noteq> valofd x", "have \"... \\<le> 2 ^ IEEE.exponent y / 2 ^ bias TYPE(('e, 'f) IEEE.float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n    \\<le> 2 ^ IEEE.exponent y / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "using assms"], ["proof (prove)\nusing this:\n  IEEE.exponent y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n    \\<le> 2 ^ IEEE.exponent y / 2 ^ bias TYPE(('e, 'f) IEEE.float)", "by (simp add: self_le_power field_simps)"], ["proof (state)\nthis:\n  2 / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n  \\<le> 2 ^ IEEE.exponent y / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n\ngoal (2 subgoals):\n 1. valofd x \\<noteq> valofn y\n 2. valofn y \\<noteq> valofd x", "also"], ["proof (state)\nthis:\n  2 / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n  \\<le> 2 ^ IEEE.exponent y / 2 ^ bias TYPE(('e, 'f) IEEE.float)\n\ngoal (2 subgoals):\n 1. valofd x \\<noteq> valofn y\n 2. valofn y \\<noteq> valofd x", "have \"... \\<le> valofn y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ IEEE.exponent y / 2 ^ bias TYPE(('e, 'f) IEEE.float) \\<le> valofn y", "by (rule valofn_ge_2p)"], ["proof (state)\nthis:\n  2 ^ IEEE.exponent y / 2 ^ bias TYPE(('e, 'f) IEEE.float) \\<le> valofn y\n\ngoal (2 subgoals):\n 1. valofd x \\<noteq> valofn y\n 2. valofn y \\<noteq> valofd x", "finally"], ["proof (chain)\npicking this:\n  valofd x < valofn y", "show \"valofd x \\<noteq> valofn y\" \"valofn y \\<noteq> valofd x\""], ["proof (prove)\nusing this:\n  valofd x < valofn y\n\ngoal (1 subgoal):\n 1. valofd x \\<noteq> valofn y &&& valofn y \\<noteq> valofd x", "by simp_all"], ["proof (state)\nthis:\n  valofd x \\<noteq> valofn y\n  valofn y \\<noteq> valofd x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_gt_0_conv: \"0 < sign x \\<longleftrightarrow> sign x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < sign x) = (sign x = 1)", "by (cases x rule: sign_cases) simp_all"], ["", "lemma valof_eq:\n  assumes \"\\<not> is_zero x \\<or> \\<not> is_zero y\"\n  shows \"valof x = valof y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (valof x = valof y) = (x = y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. valof x = valof y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> valof x = valof y", "assume *: \"valof x = valof y\""], ["proof (state)\nthis:\n  valof x = valof y\n\ngoal (2 subgoals):\n 1. valof x = valof y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> valof x = valof y", "with assms"], ["proof (chain)\npicking this:\n  \\<not> is_zero x \\<or> \\<not> is_zero y\n  valof x = valof y", "have \"valof y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> is_zero x \\<or> \\<not> is_zero y\n  valof x = valof y\n\ngoal (1 subgoal):\n 1. valof y \\<noteq> 0", "by (simp add: is_zero_valof_conv)"], ["proof (state)\nthis:\n  valof y \\<noteq> 0\n\ngoal (2 subgoals):\n 1. valof x = valof y \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> valof x = valof y", "with *"], ["proof (chain)\npicking this:\n  valof x = valof y\n  valof y \\<noteq> 0", "show \"x = y\""], ["proof (prove)\nusing this:\n  valof x = valof y\n  valof y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x = y", "unfolding valof_alt"], ["proof (prove)\nusing this:\n  (if IEEE.exponent x = 0 then if sign x = 0 then valofd x else - valofd x\n   else if sign x = 0 then valofn x else - valofn x) =\n  (if IEEE.exponent y = 0 then if sign y = 0 then valofd y else - valofd y\n   else if sign y = 0 then valofn y else - valofn y)\n  (if IEEE.exponent y = 0 then if sign y = 0 then valofd y else - valofd y\n   else if sign y = 0 then valofn y else - valofn y) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. x = y", "using valofd_ge_0[of x] valofd_ge_0[of y] valofn_ge_0[of x] valofn_ge_0[of y]"], ["proof (prove)\nusing this:\n  (if IEEE.exponent x = 0 then if sign x = 0 then valofd x else - valofd x\n   else if sign x = 0 then valofn x else - valofn x) =\n  (if IEEE.exponent y = 0 then if sign y = 0 then valofd y else - valofd y\n   else if sign y = 0 then valofn y else - valofn y)\n  (if IEEE.exponent y = 0 then if sign y = 0 then valofd y else - valofd y\n   else if sign y = 0 then valofn y else - valofn y) \\<noteq>\n  0\n  0 \\<le> valofd x\n  0 \\<le> valofd y\n  0 \\<le> valofn x\n  0 \\<le> valofn y\n\ngoal (1 subgoal):\n 1. x = y", "by (auto simp: valofd_neq_valofn sign_gt_0_conv split: if_splits\n        intro!: float_eqI elim: valofn_eq valofd_eq)"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> valof x = valof y", "qed simp"], ["", "lemma zero_fcompare: \"is_zero x \\<Longrightarrow> is_zero y \\<Longrightarrow> fcompare x y = ccode.Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_zero x; is_zero y\\<rbrakk>\n    \\<Longrightarrow> fcompare x y = ccode.Eq", "unfolding fcompare_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_zero x; is_zero y\\<rbrakk>\n    \\<Longrightarrow> (if is_nan x \\<or> is_nan y then Und\n                       else if is_infinity x \\<and> sign x = 1\n                            then if is_infinity y \\<and> sign y = 1\n                                 then ccode.Eq else ccode.Lt\n                            else if is_infinity x \\<and> sign x = 0\n                                 then if is_infinity y \\<and> sign y = 0\nthen ccode.Eq else ccode.Gt\n                                 else if is_infinity y \\<and> sign y = 1\nthen ccode.Gt\nelse if is_infinity y \\<and> sign y = 0 then ccode.Lt\n     else if valof x < valof y then ccode.Lt\n          else if valof x = valof y then ccode.Eq else ccode.Gt) =\n                      ccode.Eq", "by (simp add: zero_not_infinity zero_not_nan is_zero_valof_conv)"], ["", "subsection \\<open>Doubles with a unified NaN value\\<close>"], ["", "quotient_type double = \"(11, 52) float\" / \"\\<lambda>x y. is_nan x \\<and> is_nan y \\<or> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivp (\\<lambda>x y. is_nan x \\<and> is_nan y \\<or> x = y)", "by (auto intro!: equivpI reflpI sympI transpI)"], ["", "instantiation double :: \"{zero, one, plus, minus, uminus, times, ord}\"\nbegin"], ["", "lift_definition zero_double :: \"double\" is \"0\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition one_double :: \"double\" is \"1\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition plus_double :: \"double \\<Rightarrow> double \\<Rightarrow> double\" is plus"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>float1 float2 float3 float4.\n       \\<lbrakk>is_nan float1 \\<and> is_nan float2 \\<or> float1 = float2;\n        is_nan float3 \\<and> is_nan float4 \\<or> float3 = float4\\<rbrakk>\n       \\<Longrightarrow> is_nan (float1 + float3) \\<and>\n                         is_nan (float2 + float4) \\<or>\n                         float1 + float3 = float2 + float4", "by (auto simp: is_nan_plus)"], ["", "lift_definition minus_double :: \"double \\<Rightarrow> double \\<Rightarrow> double\" is minus"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>float1 float2 float3 float4.\n       \\<lbrakk>is_nan float1 \\<and> is_nan float2 \\<or> float1 = float2;\n        is_nan float3 \\<and> is_nan float4 \\<or> float3 = float4\\<rbrakk>\n       \\<Longrightarrow> is_nan (float1 - float3) \\<and>\n                         is_nan (float2 - float4) \\<or>\n                         float1 - float3 = float2 - float4", "by (auto simp: is_nan_minus)"], ["", "lift_definition uminus_double :: \"double \\<Rightarrow> double\" is uminus"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>float1 float2.\n       is_nan float1 \\<and> is_nan float2 \\<or>\n       float1 = float2 \\<Longrightarrow>\n       is_nan (- float1) \\<and> is_nan (- float2) \\<or> - float1 = - float2", "by auto"], ["", "lift_definition times_double :: \"double \\<Rightarrow> double \\<Rightarrow> double\" is times"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>float1 float2 float3 float4.\n       \\<lbrakk>is_nan float1 \\<and> is_nan float2 \\<or> float1 = float2;\n        is_nan float3 \\<and> is_nan float4 \\<or> float3 = float4\\<rbrakk>\n       \\<Longrightarrow> is_nan (float1 * float3) \\<and>\n                         is_nan (float2 * float4) \\<or>\n                         float1 * float3 = float2 * float4", "by (auto simp: is_nan_times)"], ["", "lift_definition less_eq_double :: \"double \\<Rightarrow> double \\<Rightarrow> bool\" is \"(\\<le>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>float1 float2 float3 float4.\n       \\<lbrakk>is_nan float1 \\<and> is_nan float2 \\<or> float1 = float2;\n        is_nan float3 \\<and> is_nan float4 \\<or> float3 = float4\\<rbrakk>\n       \\<Longrightarrow> (float1 \\<le> float3) = (float2 \\<le> float4)", "by (auto simp: nan_not_le)"], ["", "lift_definition less_double :: \"double \\<Rightarrow> double \\<Rightarrow> bool\" is \"(<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>float1 float2 float3 float4.\n       \\<lbrakk>is_nan float1 \\<and> is_nan float2 \\<or> float1 = float2;\n        is_nan float3 \\<and> is_nan float4 \\<or> float3 = float4\\<rbrakk>\n       \\<Longrightarrow> (float1 < float3) = (float2 < float4)", "by (auto simp: nan_not_less)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. (OFCLASS(double, minus_class) &&&\n     OFCLASS(double, one_class) &&& OFCLASS(double, plus_class)) &&&\n    (OFCLASS(double, times_class) &&& OFCLASS(double, uminus_class)) &&&\n    OFCLASS(double, zero_class) &&& OFCLASS(double, ord_class)", ".."], ["", "end"], ["", "instantiation double :: inverse\nbegin"], ["", "lift_definition divide_double :: \"double \\<Rightarrow> double \\<Rightarrow> double\" is divide"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>float1 float2 float3 float4.\n       \\<lbrakk>is_nan float1 \\<and> is_nan float2 \\<or> float1 = float2;\n        is_nan float3 \\<and> is_nan float4 \\<or> float3 = float4\\<rbrakk>\n       \\<Longrightarrow> is_nan (float1 / float3) \\<and>\n                         is_nan (float2 / float4) \\<or>\n                         float1 / float3 = float2 / float4", "by (auto simp: is_nan_divide)"], ["", "definition inverse_double :: \"double \\<Rightarrow> double\" where\n  \"inverse_double x = 1 div x\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(double, inverse_class)", ".."], ["", "end"], ["", "lift_definition sqrt_double :: \"double \\<Rightarrow> double\" is float_sqrt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>float1 float2.\n       is_nan float1 \\<and> is_nan float2 \\<or>\n       float1 = float2 \\<Longrightarrow>\n       is_nan (float_sqrt float1) \\<and> is_nan (float_sqrt float2) \\<or>\n       float_sqrt float1 = float_sqrt float2", "by (auto simp: is_nan_float_sqrt)"], ["", "no_notation plus_infinity (\"\\<infinity>\")"], ["", "lift_definition infinity :: \"double\" is plus_infinity"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition nan :: \"double\" is some_nan"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition is_zero :: \"double \\<Rightarrow> bool\" is IEEE.is_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>float1 float2.\n       is_nan float1 \\<and> is_nan float2 \\<or>\n       float1 = float2 \\<Longrightarrow>\n       is_zero float1 = is_zero float2", "by (auto simp: nan_not_zero)"], ["", "lift_definition is_infinite :: \"double \\<Rightarrow> bool\" is IEEE.is_infinity"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>float1 float2.\n       is_nan float1 \\<and> is_nan float2 \\<or>\n       float1 = float2 \\<Longrightarrow>\n       is_infinity float1 = is_infinity float2", "by (auto simp: nan_not_infinity)"], ["", "lift_definition is_nan :: \"double \\<Rightarrow> bool\" is IEEE.is_nan"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>float1 float2.\n       is_nan float1 \\<and> is_nan float2 \\<or>\n       float1 = float2 \\<Longrightarrow>\n       is_nan float1 = is_nan float2", "by auto"], ["", "lemma is_nan_conv: \"is_nan x \\<longleftrightarrow> x = nan\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Code_Double.is_nan x = (x = nan)", "by transfer auto"], ["", "lift_definition copysign_double :: \"double \\<Rightarrow> double \\<Rightarrow> double\" is\n  \"\\<lambda>x y. if IEEE.is_nan y then some_nan else copysign x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>float1 float2 float3 float4.\n       \\<lbrakk>IEEE.is_nan float1 \\<and> IEEE.is_nan float2 \\<or>\n                float1 = float2;\n        IEEE.is_nan float3 \\<and> IEEE.is_nan float4 \\<or>\n        float3 = float4\\<rbrakk>\n       \\<Longrightarrow> IEEE.is_nan\n                          (if IEEE.is_nan float3 then some_nan\n                           else copysign float1 float3) \\<and>\n                         IEEE.is_nan\n                          (if IEEE.is_nan float4 then some_nan\n                           else copysign float2 float4) \\<or>\n                         (if IEEE.is_nan float3 then some_nan\n                          else copysign float1 float3) =\n                         (if IEEE.is_nan float4 then some_nan\n                          else copysign float2 float4)", "by auto"], ["", "text \\<open>Note: @{const copysign_double} deviates from the IEEE standard in cases where\n  the second argument is a NaN.\\<close>"], ["", "lift_definition fcompare_double :: \"double \\<Rightarrow> double \\<Rightarrow> ccode\" is fcompare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>float1 float2 float3 float4.\n       \\<lbrakk>IEEE.is_nan float1 \\<and> IEEE.is_nan float2 \\<or>\n                float1 = float2;\n        IEEE.is_nan float3 \\<and> IEEE.is_nan float4 \\<or>\n        float3 = float4\\<rbrakk>\n       \\<Longrightarrow> fcompare float1 float3 = fcompare float2 float4", "by (auto simp: nan_fcompare)"], ["", "lemma nan_fcompare_double: \"is_nan x \\<or> is_nan y \\<Longrightarrow> fcompare_double x y = Und\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Code_Double.is_nan x \\<or> Code_Double.is_nan y \\<Longrightarrow>\n    fcompare_double x y = Und", "by transfer (rule nan_fcompare)"], ["", "consts compare_double :: \"double \\<Rightarrow> double \\<Rightarrow> integer\""], ["", "specification (compare_double)\n  compare_double_less: \"compare_double x y < 0 \\<longleftrightarrow> is_nan x \\<and> \\<not> is_nan y \\<or> fcompare_double x y = ccode.Lt\"\n  compare_double_eq: \"compare_double x y = 0 \\<longleftrightarrow> is_nan x \\<and> is_nan y \\<or> fcompare_double x y = ccode.Eq\"\n  compare_double_greater: \"compare_double x y > 0 \\<longleftrightarrow> \\<not> is_nan x \\<and> is_nan y \\<or> fcompare_double x y = ccode.Gt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>compare_double.\n       (\\<forall>x y.\n           (compare_double x y < 0) =\n           (Code_Double.is_nan x \\<and> \\<not> Code_Double.is_nan y \\<or>\n            fcompare_double x y = ccode.Lt)) \\<and>\n       (\\<forall>x y.\n           (compare_double x y = 0) =\n           (Code_Double.is_nan x \\<and> Code_Double.is_nan y \\<or>\n            fcompare_double x y = ccode.Eq)) \\<and>\n       (\\<forall>x y.\n           (0 < compare_double x y) =\n           (\\<not> Code_Double.is_nan x \\<and> Code_Double.is_nan y \\<or>\n            fcompare_double x y = ccode.Gt))", "by (rule exI[where x=\"\\<lambda>x y. if is_nan x then if is_nan y then 0 else -1\n    else if is_nan y then 1 else (case fcompare_double x y of ccode.Eq \\<Rightarrow> 0 | ccode.Lt \\<Rightarrow> -1 | ccode.Gt \\<Rightarrow> 1)\"],\n        transfer, auto simp: fcompare_def)"], ["", "lemmas compare_double_simps = compare_double_less compare_double_eq compare_double_greater"], ["", "lemma compare_double_le_0: \"compare_double x y \\<le> 0 \\<longleftrightarrow>\n  is_nan x \\<or> fcompare_double x y \\<in> {ccode.Eq, ccode.Lt}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (compare_double x y \\<le> 0) =\n    (Code_Double.is_nan x \\<or>\n     fcompare_double x y \\<in> {ccode.Eq, ccode.Lt})", "by (rule linorder_cases[of \"compare_double x y\" 0]; simp)\n    (auto simp: compare_double_simps nan_fcompare_double)"], ["", "lift_definition double_of_integer :: \"integer \\<Rightarrow> double\" is\n  \"\\<lambda>x. zerosign 0 (intround To_nearest (int_of_integer x))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition double_of_int where [code del]: \"double_of_int x = double_of_integer (integer_of_int x)\""], ["", "lemma [code]: \"double_of_int (int_of_integer x) = double_of_integer x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. double_of_int (int_of_integer x) = double_of_integer x", "unfolding double_of_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. double_of_integer (integer_of_int (int_of_integer x)) =\n    double_of_integer x", "by simp"], ["", "lift_definition integer_of_double :: \"double \\<Rightarrow> integer\" is\n  \"\\<lambda>x. if IEEE.is_nan x \\<or> IEEE.is_infinity x then undefined\n     else integer_of_int \\<lfloor>valof (intround float_To_zero (valof x) :: (11, 52) float)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>float1 float2.\n       IEEE.is_nan float1 \\<and> IEEE.is_nan float2 \\<or>\n       float1 = float2 \\<Longrightarrow>\n       (if IEEE.is_nan float1 \\<or> is_infinity float1 then undefined\n        else integer_of_int\n              \\<lfloor>valof\n                        (intround float_To_zero (valof float1))\\<rfloor>) =\n       (if IEEE.is_nan float2 \\<or> is_infinity float2 then undefined\n        else integer_of_int\n              \\<lfloor>valof\n                        (intround float_To_zero (valof float2))\\<rfloor>)", "by auto"], ["", "definition int_of_double: \"int_of_double x = int_of_integer (integer_of_double x)\""], ["", "subsection \\<open>Linear ordering\\<close>"], ["", "definition lcompare_double :: \"double \\<Rightarrow> double \\<Rightarrow> integer\" where\n  \"lcompare_double x y = (if is_zero x \\<and> is_zero y then\n      compare_double (copysign_double 1 x) (copysign_double 1 y)\n    else compare_double x y)\""], ["", "lemma fcompare_double_swap: \"fcompare_double x y = ccode.Gt \\<longleftrightarrow> fcompare_double y x = ccode.Lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fcompare_double x y = ccode.Gt) = (fcompare_double y x = ccode.Lt)", "by transfer (auto simp: fcompare_def)"], ["", "lemma fcompare_double_refl: \"\\<not> is_nan x \\<Longrightarrow> fcompare_double x x = ccode.Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Code_Double.is_nan x \\<Longrightarrow>\n    fcompare_double x x = ccode.Eq", "by transfer (auto simp: fcompare_def)"], ["", "lemma fcompare_double_Eq1: \"fcompare_double x y = ccode.Eq \\<Longrightarrow> fcompare_double y z = c \\<Longrightarrow> fcompare_double x z = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fcompare_double x y = ccode.Eq;\n     fcompare_double y z = c\\<rbrakk>\n    \\<Longrightarrow> fcompare_double x z = c", "by transfer (auto simp: fcompare_def split: if_splits)"], ["", "lemma fcompare_double_Eq2: \"fcompare_double y z = ccode.Eq \\<Longrightarrow> fcompare_double x y = c \\<Longrightarrow> fcompare_double x z = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fcompare_double y z = ccode.Eq;\n     fcompare_double x y = c\\<rbrakk>\n    \\<Longrightarrow> fcompare_double x z = c", "by transfer (auto simp: fcompare_def split: if_splits)"], ["", "lemma fcompare_double_Lt_trans: \"fcompare_double x y = ccode.Lt \\<Longrightarrow> fcompare_double y z = ccode.Lt \\<Longrightarrow> fcompare_double x z = ccode.Lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fcompare_double x y = ccode.Lt;\n     fcompare_double y z = ccode.Lt\\<rbrakk>\n    \\<Longrightarrow> fcompare_double x z = ccode.Lt", "by transfer (auto simp: fcompare_def split: if_splits)"], ["", "lemma fcompare_double_eq: \"\\<not> is_zero x \\<or> \\<not> is_zero y \\<Longrightarrow> fcompare_double x y = ccode.Eq \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> Code_Double.is_zero x \\<or>\n             \\<not> Code_Double.is_zero y;\n     fcompare_double x y = ccode.Eq\\<rbrakk>\n    \\<Longrightarrow> x = y", "by transfer (auto simp: fcompare_def valof_eq IEEE.is_infinity_def split: if_splits intro!: float_eqI)"], ["", "lemma fcompare_double_Lt_asym: \"fcompare_double x y = ccode.Lt \\<Longrightarrow> fcompare_double y x = ccode.Lt \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fcompare_double x y = ccode.Lt;\n     fcompare_double y x = ccode.Lt\\<rbrakk>\n    \\<Longrightarrow> False", "by transfer (auto simp: fcompare_def split: if_splits)"], ["", "lemma compare_double_swap: \"0 < compare_double x y \\<longleftrightarrow> compare_double y x < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < compare_double x y) = (compare_double y x < 0)", "by (auto simp: compare_double_simps fcompare_double_swap)"], ["", "lemma compare_double_refl: \"compare_double x x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_double x x = 0", "by (auto simp: compare_double_eq intro!: fcompare_double_refl)"], ["", "lemma compare_double_trans: \"compare_double x y \\<le> 0 \\<Longrightarrow> compare_double y z \\<le> 0 \\<Longrightarrow> compare_double x z \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>compare_double x y \\<le> 0; compare_double y z \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> compare_double x z \\<le> 0", "by (fastforce simp: compare_double_le_0 nan_fcompare_double\n      dest: fcompare_double_Eq1 fcompare_double_Eq2 fcompare_double_Lt_trans)"], ["", "lemma compare_double_antisym: \"compare_double x y \\<le> 0 \\<Longrightarrow> compare_double y x \\<le> 0 \\<Longrightarrow>\n  \\<not> is_zero x \\<or> \\<not> is_zero y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>compare_double x y \\<le> 0; compare_double y x \\<le> 0;\n     \\<not> Code_Double.is_zero x \\<or>\n     \\<not> Code_Double.is_zero y\\<rbrakk>\n    \\<Longrightarrow> x = y", "unfolding compare_double_le_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Code_Double.is_nan x \\<or>\n             fcompare_double x y \\<in> {ccode.Eq, ccode.Lt};\n     Code_Double.is_nan y \\<or>\n     fcompare_double y x \\<in> {ccode.Eq, ccode.Lt};\n     \\<not> Code_Double.is_zero x \\<or>\n     \\<not> Code_Double.is_zero y\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (auto simp: nan_fcompare_double is_nan_conv\n      intro: fcompare_double_eq fcompare_double_eq[symmetric]\n      dest: fcompare_double_Lt_asym)"], ["", "lemma zero_compare_double_copysign: \"compare_double (copysign_double 1 x) (copysign_double 1 y) \\<le> 0 \\<Longrightarrow>\n  is_zero x \\<Longrightarrow> is_zero y \\<Longrightarrow> compare_double x y \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>compare_double (copysign_double 1 x) (copysign_double 1 y)\n             \\<le> 0;\n     Code_Double.is_zero x; Code_Double.is_zero y\\<rbrakk>\n    \\<Longrightarrow> compare_double x y \\<le> 0", "unfolding compare_double_le_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Code_Double.is_nan (copysign_double 1 x) \\<or>\n             fcompare_double (copysign_double 1 x) (copysign_double 1 y)\n             \\<in> {ccode.Eq, ccode.Lt};\n     Code_Double.is_zero x; Code_Double.is_zero y\\<rbrakk>\n    \\<Longrightarrow> Code_Double.is_nan x \\<or>\n                      fcompare_double x y \\<in> {ccode.Eq, ccode.Lt}", "by transfer (auto simp: nan_not_zero zero_fcompare split: if_splits)"], ["", "lemma is_zero_double_cases: \"is_zero x \\<Longrightarrow> (x = 0 \\<Longrightarrow> P) \\<Longrightarrow> (x = -0 \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Code_Double.is_zero x; x = 0 \\<Longrightarrow> P;\n     x = - 0 \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by transfer (auto elim!: is_zero_cases)"], ["", "lemma copysign_1_0[simp]: \"copysign_double 1 0 = 1\" \"copysign_double 1 (-0) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. copysign_double 1 0 = 1 &&& copysign_double 1 (- 0) = - 1", "by (transfer, simp, transfer, auto)+"], ["", "lemma is_zero_uminus_double[simp]: \"is_zero (- x) \\<longleftrightarrow> is_zero x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Code_Double.is_zero (- x) = Code_Double.is_zero x", "by transfer simp"], ["", "lemma not_is_zero_one_double[simp]: \"\\<not> is_zero 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Code_Double.is_zero 1", "by (transfer, unfold IEEE.is_zero_def, transfer, simp)"], ["", "lemma uminus_one_neq_one_double[simp]: \"- 1 \\<noteq> (1 :: double)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 \\<noteq> 1", "by (transfer, transfer, simp)"], ["", "definition lle_double :: \"double \\<Rightarrow> double \\<Rightarrow> bool\" where\n  \"lle_double x y \\<longleftrightarrow> lcompare_double x y \\<le> 0\""], ["", "definition lless_double :: \"double \\<Rightarrow> double \\<Rightarrow> bool\" where\n  \"lless_double x y \\<longleftrightarrow> lcompare_double x y < 0\""], ["", "lemma lcompare_double_ge_0: \"lcompare_double x y \\<ge> 0 \\<longleftrightarrow> lle_double y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> lcompare_double x y) = lle_double y x", "unfolding lle_double_def lcompare_double_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> (if Code_Double.is_zero x \\<and> Code_Double.is_zero y\n              then compare_double (copysign_double 1 x)\n                    (copysign_double 1 y)\n              else compare_double x y)) =\n    ((if Code_Double.is_zero y \\<and> Code_Double.is_zero x\n      then compare_double (copysign_double 1 y) (copysign_double 1 x)\n      else compare_double y x)\n     \\<le> 0)", "using compare_double_swap not_less"], ["proof (prove)\nusing this:\n  (0 < compare_double ?x ?y) = (compare_double ?y ?x < 0)\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. (0 \\<le> (if Code_Double.is_zero x \\<and> Code_Double.is_zero y\n              then compare_double (copysign_double 1 x)\n                    (copysign_double 1 y)\n              else compare_double x y)) =\n    ((if Code_Double.is_zero y \\<and> Code_Double.is_zero x\n      then compare_double (copysign_double 1 y) (copysign_double 1 x)\n      else compare_double y x)\n     \\<le> 0)", "by auto"], ["", "lemma lcompare_double_gt_0: \"lcompare_double x y > 0 \\<longleftrightarrow> lless_double y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < lcompare_double x y) = lless_double y x", "unfolding lless_double_def lcompare_double_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < (if Code_Double.is_zero x \\<and> Code_Double.is_zero y\n          then compare_double (copysign_double 1 x) (copysign_double 1 y)\n          else compare_double x y)) =\n    ((if Code_Double.is_zero y \\<and> Code_Double.is_zero x\n      then compare_double (copysign_double 1 y) (copysign_double 1 x)\n      else compare_double y x)\n     < 0)", "using compare_double_swap"], ["proof (prove)\nusing this:\n  (0 < compare_double ?x ?y) = (compare_double ?y ?x < 0)\n\ngoal (1 subgoal):\n 1. (0 < (if Code_Double.is_zero x \\<and> Code_Double.is_zero y\n          then compare_double (copysign_double 1 x) (copysign_double 1 y)\n          else compare_double x y)) =\n    ((if Code_Double.is_zero y \\<and> Code_Double.is_zero x\n      then compare_double (copysign_double 1 y) (copysign_double 1 x)\n      else compare_double y x)\n     < 0)", "by auto"], ["", "lemma lcompare_double_eq_0: \"lcompare_double x y = 0 \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lcompare_double x y = 0) = (x = y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lcompare_double x y = 0 \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> lcompare_double x y = 0", "assume *: \"lcompare_double x y = 0\""], ["proof (state)\nthis:\n  lcompare_double x y = 0\n\ngoal (2 subgoals):\n 1. lcompare_double x y = 0 \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> lcompare_double x y = 0", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (cases \"is_zero x \\<and> is_zero y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Code_Double.is_zero x \\<and> Code_Double.is_zero y \\<Longrightarrow>\n    x = y\n 2. \\<not> (Code_Double.is_zero x \\<and>\n            Code_Double.is_zero y) \\<Longrightarrow>\n    x = y", "case True"], ["proof (state)\nthis:\n  Code_Double.is_zero x \\<and> Code_Double.is_zero y\n\ngoal (2 subgoals):\n 1. Code_Double.is_zero x \\<and> Code_Double.is_zero y \\<Longrightarrow>\n    x = y\n 2. \\<not> (Code_Double.is_zero x \\<and>\n            Code_Double.is_zero y) \\<Longrightarrow>\n    x = y", "with *"], ["proof (chain)\npicking this:\n  lcompare_double x y = 0\n  Code_Double.is_zero x \\<and> Code_Double.is_zero y", "show ?thesis"], ["proof (prove)\nusing this:\n  lcompare_double x y = 0\n  Code_Double.is_zero x \\<and> Code_Double.is_zero y\n\ngoal (1 subgoal):\n 1. x = y", "by (fastforce simp: lcompare_double_def compare_double_simps is_nan_conv\n          elim: is_zero_double_cases dest!: fcompare_double_eq[rotated])"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<not> (Code_Double.is_zero x \\<and>\n            Code_Double.is_zero y) \\<Longrightarrow>\n    x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (Code_Double.is_zero x \\<and>\n            Code_Double.is_zero y) \\<Longrightarrow>\n    x = y", "case False"], ["proof (state)\nthis:\n  \\<not> (Code_Double.is_zero x \\<and> Code_Double.is_zero y)\n\ngoal (1 subgoal):\n 1. \\<not> (Code_Double.is_zero x \\<and>\n            Code_Double.is_zero y) \\<Longrightarrow>\n    x = y", "with *"], ["proof (chain)\npicking this:\n  lcompare_double x y = 0\n  \\<not> (Code_Double.is_zero x \\<and> Code_Double.is_zero y)", "show ?thesis"], ["proof (prove)\nusing this:\n  lcompare_double x y = 0\n  \\<not> (Code_Double.is_zero x \\<and> Code_Double.is_zero y)\n\ngoal (1 subgoal):\n 1. x = y", "by (auto simp: lcompare_double_def linorder_not_less[symmetric] compare_double_swap\n          intro!: compare_double_antisym)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> lcompare_double x y = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> lcompare_double x y = 0", "assume \"x = y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> lcompare_double x y = 0", "then"], ["proof (chain)\npicking this:\n  x = y", "show \"lcompare_double x y = 0\""], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. lcompare_double x y = 0", "by (simp add: lcompare_double_def compare_double_refl)"], ["proof (state)\nthis:\n  lcompare_double x y = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas lcompare_double_0_folds = lle_double_def[symmetric] lless_double_def[symmetric]\n  lcompare_double_ge_0 lcompare_double_gt_0 lcompare_double_eq_0"], ["", "interpretation double_linorder: linorder lle_double lless_double"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder lle_double lless_double", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       lless_double x y = (lle_double x y \\<and> \\<not> lle_double y x)\n 2. \\<And>x. lle_double x x\n 3. \\<And>x y z.\n       \\<lbrakk>lle_double x y; lle_double y z\\<rbrakk>\n       \\<Longrightarrow> lle_double x z\n 4. \\<And>x y.\n       \\<lbrakk>lle_double x y; lle_double y x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y. lle_double x y \\<or> lle_double y x", "fix x y z :: double"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       lless_double x y = (lle_double x y \\<and> \\<not> lle_double y x)\n 2. \\<And>x. lle_double x x\n 3. \\<And>x y z.\n       \\<lbrakk>lle_double x y; lle_double y z\\<rbrakk>\n       \\<Longrightarrow> lle_double x z\n 4. \\<And>x y.\n       \\<lbrakk>lle_double x y; lle_double y x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y. lle_double x y \\<or> lle_double y x", "show \"lless_double x y \\<longleftrightarrow> lle_double x y \\<and> \\<not> lle_double y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lless_double x y = (lle_double x y \\<and> \\<not> lle_double y x)", "unfolding lless_double_def lle_double_def lcompare_double_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if Code_Double.is_zero x \\<and> Code_Double.is_zero y\n      then compare_double (copysign_double 1 x) (copysign_double 1 y)\n      else compare_double x y)\n     < 0) =\n    ((if Code_Double.is_zero x \\<and> Code_Double.is_zero y\n      then compare_double (copysign_double 1 x) (copysign_double 1 y)\n      else compare_double x y)\n     \\<le> 0 \\<and>\n     \\<not> (if Code_Double.is_zero y \\<and> Code_Double.is_zero x\n             then compare_double (copysign_double 1 y) (copysign_double 1 x)\n             else compare_double y x)\n            \\<le> 0)", "by (auto simp: compare_double_swap not_le)"], ["proof (state)\nthis:\n  lless_double x y = (lle_double x y \\<and> \\<not> lle_double y x)\n\ngoal (4 subgoals):\n 1. \\<And>x. lle_double x x\n 2. \\<And>x y z.\n       \\<lbrakk>lle_double x y; lle_double y z\\<rbrakk>\n       \\<Longrightarrow> lle_double x z\n 3. \\<And>x y.\n       \\<lbrakk>lle_double x y; lle_double y x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y. lle_double x y \\<or> lle_double y x", "show \"lle_double x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lle_double x x", "unfolding lle_double_def lcompare_double_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Code_Double.is_zero x \\<and> Code_Double.is_zero x\n     then compare_double (copysign_double 1 x) (copysign_double 1 x)\n     else compare_double x x)\n    \\<le> 0", "by (auto simp: compare_double_refl)"], ["proof (state)\nthis:\n  lle_double x x\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>lle_double x y; lle_double y z\\<rbrakk>\n       \\<Longrightarrow> lle_double x z\n 2. \\<And>x y.\n       \\<lbrakk>lle_double x y; lle_double y x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y. lle_double x y \\<or> lle_double y x", "show \"lle_double x z\" if \"lle_double x y\" and \"lle_double y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lle_double x z", "using that"], ["proof (prove)\nusing this:\n  lle_double x y\n  lle_double y z\n\ngoal (1 subgoal):\n 1. lle_double x z", "by (auto 0 3 simp: lle_double_def lcompare_double_def not_le compare_double_swap\n        split: if_splits dest: compare_double_trans zero_compare_double_copysign\n        zero_compare_double_copysign[OF less_imp_le] compare_double_antisym)"], ["proof (state)\nthis:\n  \\<lbrakk>lle_double x y; lle_double y z\\<rbrakk>\n  \\<Longrightarrow> lle_double x z\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>lle_double x y; lle_double y x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y. lle_double x y \\<or> lle_double y x", "show \"x = y\" if \"lle_double x y\" and \"lle_double y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (cases \"is_zero x \\<and> is_zero y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Code_Double.is_zero x \\<and> Code_Double.is_zero y \\<Longrightarrow>\n    x = y\n 2. \\<not> (Code_Double.is_zero x \\<and>\n            Code_Double.is_zero y) \\<Longrightarrow>\n    x = y", "case True"], ["proof (state)\nthis:\n  Code_Double.is_zero x \\<and> Code_Double.is_zero y\n\ngoal (2 subgoals):\n 1. Code_Double.is_zero x \\<and> Code_Double.is_zero y \\<Longrightarrow>\n    x = y\n 2. \\<not> (Code_Double.is_zero x \\<and>\n            Code_Double.is_zero y) \\<Longrightarrow>\n    x = y", "with that"], ["proof (chain)\npicking this:\n  lle_double x y\n  lle_double y x\n  Code_Double.is_zero x \\<and> Code_Double.is_zero y", "show ?thesis"], ["proof (prove)\nusing this:\n  lle_double x y\n  lle_double y x\n  Code_Double.is_zero x \\<and> Code_Double.is_zero y\n\ngoal (1 subgoal):\n 1. x = y", "by (auto 0 3 simp: lle_double_def lcompare_double_def elim: is_zero_double_cases\n          dest!: compare_double_antisym)"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<not> (Code_Double.is_zero x \\<and>\n            Code_Double.is_zero y) \\<Longrightarrow>\n    x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (Code_Double.is_zero x \\<and>\n            Code_Double.is_zero y) \\<Longrightarrow>\n    x = y", "case False"], ["proof (state)\nthis:\n  \\<not> (Code_Double.is_zero x \\<and> Code_Double.is_zero y)\n\ngoal (1 subgoal):\n 1. \\<not> (Code_Double.is_zero x \\<and>\n            Code_Double.is_zero y) \\<Longrightarrow>\n    x = y", "with that"], ["proof (chain)\npicking this:\n  lle_double x y\n  lle_double y x\n  \\<not> (Code_Double.is_zero x \\<and> Code_Double.is_zero y)", "show ?thesis"], ["proof (prove)\nusing this:\n  lle_double x y\n  lle_double y x\n  \\<not> (Code_Double.is_zero x \\<and> Code_Double.is_zero y)\n\ngoal (1 subgoal):\n 1. x = y", "by (auto simp: lle_double_def lcompare_double_def elim!: compare_double_antisym)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>lle_double x y; lle_double y x\\<rbrakk> \\<Longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<And>x y. lle_double x y \\<or> lle_double y x", "show \"lle_double x y \\<or> lle_double y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lle_double x y \\<or> lle_double y x", "unfolding lle_double_def lcompare_double_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Code_Double.is_zero x \\<and> Code_Double.is_zero y\n     then compare_double (copysign_double 1 x) (copysign_double 1 y)\n     else compare_double x y)\n    \\<le> 0 \\<or>\n    (if Code_Double.is_zero y \\<and> Code_Double.is_zero x\n     then compare_double (copysign_double 1 y) (copysign_double 1 x)\n     else compare_double y x)\n    \\<le> 0", "by (auto simp: compare_double_swap not_le)"], ["proof (state)\nthis:\n  lle_double x y \\<or> lle_double y x\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation double :: equal\nbegin"], ["", "definition equal_double :: \"double \\<Rightarrow> double \\<Rightarrow> bool\" where\n  \"equal_double x y \\<longleftrightarrow> lcompare_double x y = 0\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(double, equal_class)", "by intro_classes (simp add: equal_double_def lcompare_double_eq_0)"], ["", "end"], ["", "derive (eq) ceq double"], ["", "definition comparator_double :: \"double comparator\" where\n  \"comparator_double x y = (let c = lcompare_double x y in\n    if c = 0 then order.Eq else if c < 0 then order.Lt else order.Gt)\""], ["", "lemma comparator_double: \"comparator comparator_double\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator comparator_double", "unfolding comparator_double_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator\n     (\\<lambda>x y.\n         let c = lcompare_double x y\n         in if c = 0 then order.Eq\n            else if c < 0 then order.Lt else order.Gt)", "by (auto simp: lcompare_double_0_folds split: if_splits intro!: comparator.intro)"], ["", "local_setup \\<open>\n  Comparator_Generator.register_foreign_comparator @{typ double}\n    @{term comparator_double}\n    @{thm comparator_double}\n\\<close>"], ["", "derive ccompare double"], ["", "subsubsection \\<open>Code setup\\<close>"], ["", "declare [[code drop:\n      \"0 :: double\"\n      \"1 :: double\"\n      \"plus :: double \\<Rightarrow> _\"\n      \"minus :: double \\<Rightarrow> _\"\n      \"uminus :: double \\<Rightarrow> _\"\n      \"times :: double \\<Rightarrow> _\"\n      \"less_eq :: double \\<Rightarrow> _\"\n      \"less :: double \\<Rightarrow> _\"\n      \"divide :: double \\<Rightarrow> _\"\n      sqrt_double infinity nan is_zero is_infinite is_nan copysign_double fcompare_double\n      double_of_integer integer_of_double\n      ]]"], ["", "code_printing\n  code_module FloatUtil \\<rightharpoonup> (OCaml)\n\\<open>module FloatUtil : sig\n  val iszero : float -> bool\n  val isinfinite : float -> bool\n  val isnan : float -> bool\n  val copysign : float -> float -> float\n  val compare : float -> float -> Z.t\nend = struct\n  let iszero x = (Pervasives.classify_float x = Pervasives.FP_zero);;\n  let isinfinite x = (Pervasives.classify_float x = Pervasives.FP_infinite);;\n  let isnan x = (Pervasives.classify_float x = Pervasives.FP_nan);;\n  let copysign x y = if isnan y then Pervasives.nan else Pervasives.copysign x y;;\n  let compare x y = Z.of_int (Pervasives.compare x y);;\nend;;\\<close>"], ["", "code_reserved OCaml Pervasives FloatUtil"], ["", "code_printing\n  type_constructor double \\<rightharpoonup> (OCaml) \"float\"\n  | constant \"uminus :: double \\<Rightarrow> double\" \\<rightharpoonup> (OCaml) \"Pervasives.(~-.)\"\n  | constant \"(+) :: double \\<Rightarrow> double \\<Rightarrow> double\" \\<rightharpoonup> (OCaml) \"Pervasives.(+.)\"\n  | constant \"(*) :: double \\<Rightarrow> double \\<Rightarrow> double\" \\<rightharpoonup> (OCaml) \"Pervasives.( *. )\"\n  | constant \"(/) :: double \\<Rightarrow> double \\<Rightarrow> double\" \\<rightharpoonup> (OCaml) \"Pervasives.('/.)\"\n  | constant \"(-) :: double \\<Rightarrow> double \\<Rightarrow> double\" \\<rightharpoonup> (OCaml) \"Pervasives.(-.)\"\n  | constant \"0 :: double\" \\<rightharpoonup> (OCaml) \"0.0\"\n  | constant \"1 :: double\" \\<rightharpoonup> (OCaml) \"1.0\"\n  | constant \"(\\<le>) :: double \\<Rightarrow> double \\<Rightarrow> bool\" \\<rightharpoonup> (OCaml) \"Pervasives.(<=)\"\n  | constant \"(<) :: double \\<Rightarrow> double \\<Rightarrow> bool\" \\<rightharpoonup> (OCaml) \"Pervasives.(<)\"\n  | constant \"sqrt_double :: double \\<Rightarrow> double\" \\<rightharpoonup> (OCaml) \"Pervasives.sqrt\"\n  | constant \"infinity :: double\" \\<rightharpoonup> (OCaml) \"Pervasives.infinity\"\n  | constant \"nan :: double\" \\<rightharpoonup> (OCaml) \"Pervasives.nan\"\n  | constant \"is_zero :: double \\<Rightarrow> bool\" \\<rightharpoonup> (OCaml) \"FloatUtil.iszero\"\n  | constant \"is_infinite :: double \\<Rightarrow> bool\" \\<rightharpoonup> (OCaml) \"FloatUtil.isinfinite\"\n  | constant \"is_nan :: double \\<Rightarrow> bool\" \\<rightharpoonup> (OCaml) \"FloatUtil.isnan\"\n  | constant \"copysign_double :: double \\<Rightarrow> double \\<Rightarrow> double\" \\<rightharpoonup> (OCaml) \"FloatUtil.copysign\"\n  | constant \"compare_double :: double \\<Rightarrow> double \\<Rightarrow> integer\" \\<rightharpoonup> (OCaml) \"FloatUtil.compare\"\n  | constant \"double_of_integer :: integer \\<Rightarrow> double\" \\<rightharpoonup> (OCaml) \"Z.to'_float\"\n  | constant \"integer_of_double :: double \\<Rightarrow> integer\" \\<rightharpoonup> (OCaml) \"Z.of'_float\""], ["", "hide_const (open) fcompare_double"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}