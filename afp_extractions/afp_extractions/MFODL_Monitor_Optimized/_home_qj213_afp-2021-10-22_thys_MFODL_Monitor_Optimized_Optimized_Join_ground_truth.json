{"file_name": "/home/qj213/afp-2021-10-22/thys/MFODL_Monitor_Optimized/Optimized_Join.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFODL_Monitor_Optimized", "problem_names": ["lemma proj_tuple_replicate: \"(\\<And>i. i \\<in> set bs \\<Longrightarrow> \\<not>i) \\<Longrightarrow> length bs = length as \\<Longrightarrow>\n  proj_tuple bs as = replicate (length bs) None\"", "lemma proj_tuple_join_mask_empty: \"length as = n \\<Longrightarrow>\n  proj_tuple (join_mask n {}) as = replicate n None\"", "lemma proj_tuple_alt: \"proj_tuple bs as = map2 (\\<lambda>b a. if b then a else None) bs as\"", "lemma map2_map: \"map2 f (map g [0..<length as]) as = map (\\<lambda>i. f (g i) (as ! i)) [0..<length as]\"", "lemma proj_tuple_join_mask_restrict: \"length as = n \\<Longrightarrow>\n  proj_tuple (join_mask n X) as = restrict X as\"", "lemma wf_tuple_proj_idle:\n  assumes wf: \"wf_tuple n X as\"\n  shows \"proj_tuple (join_mask n X) as = as\"", "lemma wf_tuple_change_base:\n  assumes wf: \"wf_tuple n X as\"\n  and mask: \"join_mask n X = join_mask n Y\"\n  shows \"wf_tuple n Y as\"", "lemma proj_tuple_in_join_mask_idle:\n  assumes wf: \"wf_tuple n X as\"\n  shows \"proj_tuple_in_join pos (join_mask n X) as t \\<longleftrightarrow> join_cond pos t as\"", "lemma join_sub:\n  assumes \"L \\<subseteq> R\" \"table n L t1\" \"table n R t2\"\n  shows \"join t2 pos t1 = {as \\<in> t2. proj_tuple_in_join pos (join_mask n L) as t1}\"", "lemma join_sub':\n  assumes \"R \\<subseteq> L\" \"table n L t1\" \"table n R t2\"\n  shows \"join t2 True t1 = {as \\<in> t1. proj_tuple_in_join True (join_mask n R) as t2}\"", "lemma join_eq:\n  assumes tab: \"table n R t1\" \"table n R t2\"\n  shows \"join t2 pos t1 = (if pos then t2 \\<inter> t1 else t2 - t1)\"", "lemma join_no_cols:\n  assumes tab: \"table n {} t1\" \"table n R t2\"\n  shows \"join t2 pos t1 = (if (pos \\<longleftrightarrow> replicate n None \\<in> t1) then t2 else {})\"", "lemma join_empty_left: \"join {} pos t = {}\"", "lemma join_empty_right: \"join t pos {} = (if pos then {} else t)\"", "lemma bin_join_table:\n  assumes tab: \"table n A t\" \"table n A' t'\"\n  shows \"bin_join n A t pos A' t' = join t pos t'\"", "lemma mmulti_join'_correct:\n  assumes \"A_pos \\<noteq> []\"\n      and \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L\"\n  shows \"z \\<in> mmulti_join' A_pos A_neg L \\<longleftrightarrow> wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n    list_all2 (\\<lambda>A X. restrict A z \\<in> X) A_pos (take (length A_pos) L) \\<and>\n    list_all2 (\\<lambda>A X. restrict A z \\<notin> X) A_neg (drop (length A_pos) L)\"", "lemmas restrict_nested = New_max.restrict_nested", "lemma list_all2_opt_True:\n  assumes \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) ((A_zs @ A_x # A_xs @ A_y # A_ys) @ A_neg)\n    ((zs @ x # xs @ y # ys) @ L_neg)\"\n    \"length A_xs = length xs\" \"length A_ys = length ys\" \"length A_zs = length zs\"\n  shows \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n    ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg) ((zs @ join x True y # xs @ ys) @ L_neg)\"", "lemma mmulti_join'_opt_True:\n  assumes \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) ((A_zs @ A_x # A_xs @ A_y # A_ys) @ A_neg)\n    ((zs @ x # xs @ y # ys) @ L_neg)\"\n    \"length A_xs = length xs\" \"length A_ys = length ys\" \"length A_zs = length zs\"\n  shows \"mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg ((zs @ x # xs @ y # ys) @ L_neg) =\n    mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n    ((zs @ join x True y # xs @ ys) @ L_neg)\"", "lemma list_all2_opt_False:\n  assumes \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n    ((A_zs @ A_x # A_xs) @ (A_ws @ A_y # A_ys)) ((zs @ x # xs) @ (ws @ y # ys))\"\n    \"length A_ws = length ws\" \"length A_xs = length xs\"\n    \"length A_ys = length ys\" \"length A_zs = length zs\"\n    \"A_y \\<subseteq> A_x\"\n  shows \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n    ((A_zs @ A_x # A_xs) @ (A_ws @ A_ys)) ((zs @ join x False y # xs) @ (ws @ ys))\"", "lemma mmulti_join'_opt_False:\n  assumes \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n    ((A_zs @ A_x # A_xs) @ (A_ws @ A_y # A_ys)) ((zs @ x # xs) @ (ws @ y # ys))\"\n    \"length A_ws = length ws\" \"length A_xs = length xs\"\n    \"length A_ys = length ys\" \"length A_zs = length zs\"\n    \"A_y \\<subseteq> A_x\"\n  shows \"mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys) ((zs @ x # xs) @ (ws @ y # ys)) =\n    mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys) ((zs @ join x False y # xs) @ (ws @ ys))\"", "lemma find_sub_in_sound: \"find_sub_in X xs b = Some (ys, z, zs) \\<Longrightarrow>\n  xs = ys @ z # zs \\<and> (z \\<subseteq> X \\<or> (b \\<and> X \\<subseteq> z))\"", "lemma find_sub_True_sound: \"find_sub_True xs = Some (ys, w, ws, z, zs) \\<Longrightarrow>\n  xs = ys @ w # ws @ z # zs \\<and> (z \\<subseteq> w \\<or> w \\<subseteq> z)\"", "lemma find_sub_False_sound: \"find_sub_False xs ns = Some ((rs, w, ws), (ys, z, zs)) \\<Longrightarrow>\n  xs = rs @ w # ws \\<and> ns = ys @ z # zs \\<and> (z \\<subseteq> w)\"", "lemma proj_list_3_same:\n  assumes \"proj_list_3 xs (ys, z, zs) = (ys', z', zs')\"\n    \"length xs = length ys + 1 + length zs\"\n  shows \"xs = ys' @ z' # zs'\"", "lemma proj_list_3_length:\n  assumes \"proj_list_3 xs (ys, z, zs) = (ys', z', zs')\"\n    \"length xs = length ys + 1 + length zs\"\n  shows \"length ys = length ys'\" \"length zs = length zs'\"", "lemma proj_list_5_same:\n  assumes \"proj_list_5 xs (ys, w, ws, z, zs) = (ys', w', ws', z', zs')\"\n    \"length xs = length ys + 1 + length ws + 1 + length zs\"\n  shows \"xs = ys' @ w' # ws' @ z' # zs'\"", "lemma proj_list_5_length:\n  assumes \"proj_list_5 xs (ys, w, ws, z, zs) = (ys', w', ws', z', zs')\"\n    \"length xs = length ys + 1 + length ws + 1 + length zs\"\n  shows \"length ys = length ys'\" \"length ws = length ws'\"\n    \"length zs = length zs'\"", "lemma find_sub_True_proj_list_5_same:\n  assumes \"find_sub_True xs = Some (ys, w, ws, z, zs)\" \"length xs = length xs'\"\n    \"proj_list_5 xs' (ys, w, ws, z, zs) = (ys', w', ws', z', zs')\"\n  shows \"xs' = ys' @ w' # ws' @ z' # zs'\"", "lemma find_sub_True_proj_list_5_length:\n  assumes \"find_sub_True xs = Some (ys, w, ws, z, zs)\" \"length xs = length xs'\"\n    \"proj_list_5 xs' (ys, w, ws, z, zs) = (ys', w', ws', z', zs')\"\n  shows \"length ys = length ys'\" \"length ws = length ws'\"\n    \"length zs = length zs'\"", "lemma dominate_True_sound:\n  assumes \"dominate_True A_pos L_pos = Some ((A_zs, A_x, A_xs, A_y, A_ys), (zs, x, xs, y, ys))\"\n    \"length A_pos = length L_pos\"\n  shows \"A_pos = A_zs @ A_x # A_xs @ A_y # A_ys\" \"L_pos = zs @ x # xs @ y # ys\"\n    \"length A_xs = length xs\" \"length A_ys = length ys\" \"length A_zs = length zs\"", "lemma find_sub_False_proj_list_3_same_left:\n  assumes \"find_sub_False xs ns = Some ((rs, w, ws), (ys, z, zs))\"\n    \"length xs = length xs'\" \"proj_list_3 xs' (rs, w, ws) = (rs', w', ws')\"\n  shows \"xs' = rs' @ w' # ws'\"", "lemma find_sub_False_proj_list_3_length_left:\n  assumes \"find_sub_False xs ns = Some ((rs, w, ws), (ys, z, zs))\"\n    \"length xs = length xs'\" \"proj_list_3 xs' (rs, w, ws) = (rs', w', ws')\"\n  shows \"length rs = length rs'\" \"length ws = length ws'\"", "lemma find_sub_False_proj_list_3_same_right:\n  assumes \"find_sub_False xs ns = Some ((rs, w, ws), (ys, z, zs))\"\n    \"length ns = length ns'\" \"proj_list_3 ns' (ys, z, zs) = (ys', z', zs')\"\n  shows \"ns' = ys' @ z' # zs'\"", "lemma find_sub_False_proj_list_3_length_right:\n  assumes \"find_sub_False xs ns = Some ((rs, w, ws), (ys, z, zs))\"\n    \"length ns = length ns'\" \"proj_list_3 ns' (ys, z, zs) = (ys', z', zs')\"\n  shows \"length ys = length ys'\" \"length zs = length zs'\"", "lemma dominate_False_sound:\n  assumes \"dominate_False A_pos L_pos A_neg L_neg =\n    Some (((A_zs, A_x, A_xs), A_ws, A_y, A_ys), ((zs, x, xs), ws, y, ys))\"\n    \"length A_pos = length L_pos\" \"length A_neg = length L_neg\"\n  shows \"A_pos = (A_zs @ A_x # A_xs)\" \"A_neg = A_ws @ A_y # A_ys\"\n    \"L_pos = (zs @ x # xs)\" \"L_neg = ws @ y # ys\"\n    \"length A_ws = length ws\" \"length A_xs = length xs\"\n    \"length A_ys = length ys\" \"length A_zs = length zs\"\n    \"A_y \\<subseteq> A_x\"", "lemma mmulti_join_link:\n  assumes \"A_pos \\<noteq> []\"\n      and \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L\"\n    shows \"mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L\"", "lemma mmulti_join_correct:\n  assumes \"A_pos \\<noteq> []\"\n      and \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L\"\n  shows \"z \\<in> mmulti_join n A_pos A_neg L \\<longleftrightarrow> wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n    list_all2 (\\<lambda>A X. restrict A z \\<in> X) A_pos (take (length A_pos) L) \\<and>\n    list_all2 (\\<lambda>A X. restrict A z \\<notin> X) A_neg (drop (length A_pos) L)\""], "translations": [["", "lemma proj_tuple_replicate: \"(\\<And>i. i \\<in> set bs \\<Longrightarrow> \\<not>i) \\<Longrightarrow> length bs = length as \\<Longrightarrow>\n  proj_tuple bs as = replicate (length bs) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i. i \\<in> set bs \\<Longrightarrow> \\<not> i;\n     length bs = length as\\<rbrakk>\n    \\<Longrightarrow> proj_tuple bs as = replicate (length bs) None", "by (induction bs as rule: proj_tuple.induct) fastforce+"], ["", "lemma proj_tuple_join_mask_empty: \"length as = n \\<Longrightarrow>\n  proj_tuple (join_mask n {}) as = replicate n None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as = n \\<Longrightarrow>\n    proj_tuple (join_mask n {}) as = replicate n None", "using proj_tuple_replicate[of \"join_mask n {}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i. i \\<in> set (join_mask n {}) \\<Longrightarrow> \\<not> i;\n   length (join_mask n {}) = length ?as\\<rbrakk>\n  \\<Longrightarrow> proj_tuple (join_mask n {}) ?as =\n                    replicate (length (join_mask n {})) None\n\ngoal (1 subgoal):\n 1. length as = n \\<Longrightarrow>\n    proj_tuple (join_mask n {}) as = replicate n None", "by (auto simp add: join_mask_def)"], ["", "lemma proj_tuple_alt: \"proj_tuple bs as = map2 (\\<lambda>b a. if b then a else None) bs as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_tuple bs as = map2 (\\<lambda>x y. if x then y else None) bs as", "by (induction bs as rule: proj_tuple.induct) auto"], ["", "lemma map2_map: \"map2 f (map g [0..<length as]) as = map (\\<lambda>i. f (g i) (as ! i)) [0..<length as]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 f (map g [0..<length as]) as =\n    map (\\<lambda>i. f (g i) (as ! i)) [0..<length as]", "by (rule nth_equalityI) auto"], ["", "lemma proj_tuple_join_mask_restrict: \"length as = n \\<Longrightarrow>\n  proj_tuple (join_mask n X) as = restrict X as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as = n \\<Longrightarrow>\n    proj_tuple (join_mask n X) as = restrict X as", "by (auto simp add: restrict_def proj_tuple_alt join_mask_def map2_map)"], ["", "lemma wf_tuple_proj_idle:\n  assumes wf: \"wf_tuple n X as\"\n  shows \"proj_tuple (join_mask n X) as = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_tuple (join_mask n X) as = as", "using proj_tuple_join_mask_restrict[of as n X, unfolded restrict_idle[OF wf]] wf"], ["proof (prove)\nusing this:\n  length as = n \\<Longrightarrow> proj_tuple (join_mask n X) as = as\n  wf_tuple n X as\n\ngoal (1 subgoal):\n 1. proj_tuple (join_mask n X) as = as", "by (auto simp add: wf_tuple_def)"], ["", "lemma wf_tuple_change_base:\n  assumes wf: \"wf_tuple n X as\"\n  and mask: \"join_mask n X = join_mask n Y\"\n  shows \"wf_tuple n Y as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n Y as", "using wf mask"], ["proof (prove)\nusing this:\n  wf_tuple n X as\n  join_mask n X = join_mask n Y\n\ngoal (1 subgoal):\n 1. wf_tuple n Y as", "by (auto simp add: wf_tuple_def join_mask_def)"], ["", "definition proj_tuple_in_join :: \"bool \\<Rightarrow> bool list \\<Rightarrow> 'a tuple \\<Rightarrow> 'a table \\<Rightarrow> bool\" where\n  \"proj_tuple_in_join pos bs as t = (if pos then proj_tuple bs as \\<in> t else proj_tuple bs as \\<notin> t)\""], ["", "abbreviation \"join_cond pos t \\<equiv> (\\<lambda>as. if pos then as \\<in> t else as \\<notin> t)\""], ["", "abbreviation \"join_filter_cond pos t \\<equiv> (\\<lambda>as _. join_cond pos t as)\""], ["", "lemma proj_tuple_in_join_mask_idle:\n  assumes wf: \"wf_tuple n X as\"\n  shows \"proj_tuple_in_join pos (join_mask n X) as t \\<longleftrightarrow> join_cond pos t as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_tuple_in_join pos (join_mask n X) as t = join_cond pos t as", "using wf_tuple_proj_idle[OF wf]"], ["proof (prove)\nusing this:\n  proj_tuple (join_mask n X) as = as\n\ngoal (1 subgoal):\n 1. proj_tuple_in_join pos (join_mask n X) as t = join_cond pos t as", "by (auto simp add: proj_tuple_in_join_def)"], ["", "lemma join_sub:\n  assumes \"L \\<subseteq> R\" \"table n L t1\" \"table n R t2\"\n  shows \"join t2 pos t1 = {as \\<in> t2. proj_tuple_in_join pos (join_mask n L) as t1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join t2 pos t1 =\n    {as \\<in> t2. proj_tuple_in_join pos (join_mask n L) as t1}", "using assms proj_tuple_join_mask_restrict[of _ n L] join_restrict[of t2 n R t1 L pos]\n    wf_tuple_length restrict_idle"], ["proof (prove)\nusing this:\n  L \\<subseteq> R\n  table n L t1\n  table n R t2\n  length ?as = n \\<Longrightarrow>\n  proj_tuple (join_mask n L) ?as = restrict L ?as\n  \\<lbrakk>\\<And>v. v \\<in> t2 \\<Longrightarrow> wf_tuple n R v;\n   \\<And>v. v \\<in> t1 \\<Longrightarrow> wf_tuple n L v;\n   \\<not> pos \\<Longrightarrow> L \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> (?v \\<in> join t2 pos t1) =\n                    (wf_tuple n (R \\<union> L) ?v \\<and>\n                     restrict R ?v \\<in> t2 \\<and>\n                     join_cond pos t1 (restrict L ?v))\n  wf_tuple ?n ?V ?x \\<Longrightarrow> length ?x = ?n\n  wf_tuple ?n ?A ?v \\<Longrightarrow> restrict ?A ?v = ?v\n\ngoal (1 subgoal):\n 1. join t2 pos t1 =\n    {as \\<in> t2. proj_tuple_in_join pos (join_mask n L) as t1}", "by (auto simp add: table_def proj_tuple_in_join_def sup.absorb1) fastforce+"], ["", "lemma join_sub':\n  assumes \"R \\<subseteq> L\" \"table n L t1\" \"table n R t2\"\n  shows \"join t2 True t1 = {as \\<in> t1. proj_tuple_in_join True (join_mask n R) as t2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join t2 True t1 =\n    {as \\<in> t1. proj_tuple_in_join True (join_mask n R) as t2}", "using assms proj_tuple_join_mask_restrict[of _ n R] join_restrict[of t2 n R t1 L True]\n    wf_tuple_length restrict_idle"], ["proof (prove)\nusing this:\n  R \\<subseteq> L\n  table n L t1\n  table n R t2\n  length ?as = n \\<Longrightarrow>\n  proj_tuple (join_mask n R) ?as = restrict R ?as\n  \\<lbrakk>\\<And>v. v \\<in> t2 \\<Longrightarrow> wf_tuple n R v;\n   \\<And>v. v \\<in> t1 \\<Longrightarrow> wf_tuple n L v;\n   \\<not> True \\<Longrightarrow> L \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> (?v \\<in> join t2 True t1) =\n                    (wf_tuple n (R \\<union> L) ?v \\<and>\n                     restrict R ?v \\<in> t2 \\<and>\n                     join_cond True t1 (restrict L ?v))\n  wf_tuple ?n ?V ?x \\<Longrightarrow> length ?x = ?n\n  wf_tuple ?n ?A ?v \\<Longrightarrow> restrict ?A ?v = ?v\n\ngoal (1 subgoal):\n 1. join t2 True t1 =\n    {as \\<in> t1. proj_tuple_in_join True (join_mask n R) as t2}", "by (auto simp add: table_def proj_tuple_in_join_def sup.absorb1 Un_absorb1) fastforce+"], ["", "lemma join_eq:\n  assumes tab: \"table n R t1\" \"table n R t2\"\n  shows \"join t2 pos t1 = (if pos then t2 \\<inter> t1 else t2 - t1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join t2 pos t1 = (if pos then t2 \\<inter> t1 else t2 - t1)", "using join_sub[OF _ tab, of pos] tab(2) proj_tuple_in_join_mask_idle[of n R _ pos t1]"], ["proof (prove)\nusing this:\n  R \\<subseteq> R \\<Longrightarrow>\n  join t2 pos t1 =\n  {as \\<in> t2. proj_tuple_in_join pos (join_mask n R) as t1}\n  table n R t2\n  wf_tuple n R ?as \\<Longrightarrow>\n  proj_tuple_in_join pos (join_mask n R) ?as t1 = join_cond pos t1 ?as\n\ngoal (1 subgoal):\n 1. join t2 pos t1 = (if pos then t2 \\<inter> t1 else t2 - t1)", "by (auto simp add: table_def)"], ["", "lemma join_no_cols:\n  assumes tab: \"table n {} t1\" \"table n R t2\"\n  shows \"join t2 pos t1 = (if (pos \\<longleftrightarrow> replicate n None \\<in> t1) then t2 else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join t2 pos t1 = (if pos = (replicate n None \\<in> t1) then t2 else {})", "using join_sub[OF _ tab, of pos] tab(2)"], ["proof (prove)\nusing this:\n  {} \\<subseteq> R \\<Longrightarrow>\n  join t2 pos t1 =\n  {as \\<in> t2. proj_tuple_in_join pos (join_mask n {}) as t1}\n  table n R t2\n\ngoal (1 subgoal):\n 1. join t2 pos t1 = (if pos = (replicate n None \\<in> t1) then t2 else {})", "by (auto simp add: table_def proj_tuple_in_join_def wf_tuple_length proj_tuple_join_mask_empty)"], ["", "lemma join_empty_left: \"join {} pos t = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join {} pos t = {}", "by (auto simp add: join_def)"], ["", "lemma join_empty_right: \"join t pos {} = (if pos then {} else t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join t pos {} = (if pos then {} else t)", "by (auto simp add: join_def)"], ["", "fun bin_join :: \"nat \\<Rightarrow> nat set \\<Rightarrow> 'a table \\<Rightarrow> bool \\<Rightarrow> nat set \\<Rightarrow> 'a table \\<Rightarrow> 'a table\" where\n  \"bin_join n A t pos A' t' =\n    (if t = {} then {}\n    else if t' = {} then (if pos then {} else t)\n    else if A' = {} then (if (pos \\<longleftrightarrow> replicate n None \\<in> t') then t else {})\n    else if A' = A then (if pos then t \\<inter> t' else t - t')\n    else if A' \\<subseteq> A then {as \\<in> t. proj_tuple_in_join pos (join_mask n A') as t'}\n    else if A \\<subseteq> A' \\<and> pos then {as \\<in> t'. proj_tuple_in_join pos (join_mask n A) as t}\n    else join t pos t')\""], ["", "lemma bin_join_table:\n  assumes tab: \"table n A t\" \"table n A' t'\"\n  shows \"bin_join n A t pos A' t' = join t pos t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_join n A t pos A' t' = join t pos t'", "using assms join_empty_left[of pos t'] join_empty_right[of t pos]\n    join_no_cols[OF _ assms(1), of t' pos] join_eq[of n A t' t pos] join_sub[OF _ assms(2,1)]\n    join_sub'[OF _ assms(2,1)]"], ["proof (prove)\nusing this:\n  table n A t\n  table n A' t'\n  join {} pos t' = {}\n  join t pos {} = (if pos then {} else t)\n  table n {} t' \\<Longrightarrow>\n  join t pos t' = (if pos = (replicate n None \\<in> t') then t else {})\n  \\<lbrakk>table n A t'; table n A t\\<rbrakk>\n  \\<Longrightarrow> join t pos t' = (if pos then t \\<inter> t' else t - t')\n  A' \\<subseteq> A \\<Longrightarrow>\n  join t ?pos t' =\n  {as \\<in> t. proj_tuple_in_join ?pos (join_mask n A') as t'}\n  A \\<subseteq> A' \\<Longrightarrow>\n  join t True t' =\n  {as \\<in> t'. proj_tuple_in_join True (join_mask n A) as t}\n\ngoal (1 subgoal):\n 1. bin_join n A t pos A' t' = join t pos t'", "by auto+"], ["", "subsection \\<open>Multi-way join\\<close>"], ["", "fun mmulti_join' :: \"(nat set list \\<Rightarrow> nat set list \\<Rightarrow> 'a table list \\<Rightarrow> 'a table)\" where\n  \"mmulti_join' A_pos A_neg L = (\n    let Q = set (zip A_pos L) in\n    let Q_neg = set (zip A_neg (drop (length A_pos) L)) in\n    New_max_getIJ_wrapperGenericJoin Q Q_neg)\""], ["", "lemma mmulti_join'_correct:\n  assumes \"A_pos \\<noteq> []\"\n      and \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L\"\n  shows \"z \\<in> mmulti_join' A_pos A_neg L \\<longleftrightarrow> wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n    list_all2 (\\<lambda>A X. restrict A z \\<in> X) A_pos (take (length A_pos) L) \\<and>\n    list_all2 (\\<lambda>A X. restrict A z \\<notin> X) A_neg (drop (length A_pos) L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "define Q where \"Q = set (zip A_pos L)\""], ["proof (state)\nthis:\n  Q = set (zip A_pos L)\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "have Q_alt: \"Q = set (zip A_pos (take (length A_pos) L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q = set (zip A_pos (take (length A_pos) L))", "unfolding Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (zip A_pos L) = set (zip A_pos (take (length A_pos) L))", "by (fastforce simp: in_set_zip)"], ["proof (state)\nthis:\n  Q = set (zip A_pos (take (length A_pos) L))\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "define Q_neg where \"Q_neg = set (zip A_neg (drop (length A_pos) L))\""], ["proof (state)\nthis:\n  Q_neg = set (zip A_neg (drop (length A_pos) L))\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "let ?r = \"mmulti_join' A_pos A_neg L\""], ["proof (state)\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "have \"?r = New_max_getIJ_wrapperGenericJoin Q Q_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join' A_pos A_neg L = New_max_getIJ_wrapperGenericJoin Q Q_neg", "unfolding Q_def Q_neg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join' A_pos A_neg L =\n    New_max_getIJ_wrapperGenericJoin (set (zip A_pos L))\n     (set (zip A_neg (drop (length A_pos) L)))", "by (simp del: New_max.wrapperGenericJoin.simps)"], ["proof (state)\nthis:\n  mmulti_join' A_pos A_neg L = New_max_getIJ_wrapperGenericJoin Q Q_neg\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "moreover"], ["proof (state)\nthis:\n  mmulti_join' A_pos A_neg L = New_max_getIJ_wrapperGenericJoin Q Q_neg\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "have \"card Q \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card Q", "unfolding Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card (set (zip A_pos L))", "using assms(1,2)"], ["proof (prove)\nusing this:\n  A_pos \\<noteq> []\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L\n\ngoal (1 subgoal):\n 1. 1 \\<le> card (set (zip A_pos L))", "by (auto simp: Suc_le_eq card_gt_0_iff zip_eq_Nil_iff)"], ["proof (state)\nthis:\n  1 \\<le> card Q\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "moreover"], ["proof (state)\nthis:\n  1 \\<le> card Q\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "have \"\\<forall>(A, X)\\<in>(Q \\<union> Q_neg). table n A X \\<and> wf_set n A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>Q \\<union> Q_neg. table n A X \\<and> wf_set n A", "unfolding Q_alt Q_neg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\n             \\<in>set (zip A_pos (take (length A_pos) L)) \\<union>\n                  set (zip A_neg (drop (length A_pos) L)).\n       table n A X \\<and> wf_set n A", "using assms(2)"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L\n\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\n             \\<in>set (zip A_pos (take (length A_pos) L)) \\<union>\n                  set (zip A_neg (drop (length A_pos) L)).\n       table n A X \\<and> wf_set n A", "by (simp add: zip_append1 list_all2_iff)"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>Q \\<union> Q_neg. table n A X \\<and> wf_set n A\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "ultimately"], ["proof (chain)\npicking this:\n  mmulti_join' A_pos A_neg L = New_max_getIJ_wrapperGenericJoin Q Q_neg\n  1 \\<le> card Q\n  \\<forall>(A, X)\\<in>Q \\<union> Q_neg. table n A X \\<and> wf_set n A", "have \"z \\<in> ?r \\<longleftrightarrow> wf_tuple n (\\<Union>(A, X)\\<in>Q. A) z \\<and>\n      (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\""], ["proof (prove)\nusing this:\n  mmulti_join' A_pos A_neg L = New_max_getIJ_wrapperGenericJoin Q Q_neg\n  1 \\<le> card Q\n  \\<forall>(A, X)\\<in>Q \\<union> Q_neg. table n A X \\<and> wf_set n A\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "using New_max.wrapper_correctness case_prod_beta'"], ["proof (prove)\nusing this:\n  mmulti_join' A_pos A_neg L = New_max_getIJ_wrapperGenericJoin Q Q_neg\n  1 \\<le> card Q\n  \\<forall>(A, X)\\<in>Q \\<union> Q_neg. table n A X \\<and> wf_set n A\n  \\<lbrakk>1 \\<le> card ?Q_pos;\n   \\<forall>(A, X)\\<in>?Q_pos \\<union> ?Q_neg.\n      table ?n A X \\<and> wf_set ?n A\\<rbrakk>\n  \\<Longrightarrow> (?z \\<in> New_max_getIJ_wrapperGenericJoin ?Q_pos\n                               ?Q_neg) =\n                    (wf_tuple ?n (\\<Union>(A, X)\\<in>?Q_pos. A) ?z \\<and>\n                     (\\<forall>(A, X)\\<in>?Q_pos.\n                         restrict A ?z \\<in> X) \\<and>\n                     (\\<forall>(A, X)\\<in>?Q_neg. restrict A ?z \\<notin> X))\n  (\\<lambda>(x, y). ?f x y) = (\\<lambda>x. ?f (fst x) (snd x))\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "by blast"], ["proof (state)\nthis:\n  (z \\<in> mmulti_join' A_pos A_neg L) =\n  (wf_tuple n (\\<Union>(A, X)\\<in>Q. A) z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "moreover"], ["proof (state)\nthis:\n  (z \\<in> mmulti_join' A_pos A_neg L) =\n  (wf_tuple n (\\<Union>(A, X)\\<in>Q. A) z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "have \"(\\<Union>A\\<in>set A_pos. A) = (\\<Union>(A, X)\\<in>Q. A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>A\\<in>set A_pos. A) = (\\<Union>(A, X)\\<in>Q. A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>A\\<in>set A_pos. A) = (\\<Union>(A, X)\\<in>Q. A)", "from assms(2)"], ["proof (chain)\npicking this:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L", "have \"length A_pos \\<le> length L\""], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L\n\ngoal (1 subgoal):\n 1. length A_pos \\<le> length L", "by (auto dest!: list_all2_lengthD)"], ["proof (state)\nthis:\n  length A_pos \\<le> length L\n\ngoal (1 subgoal):\n 1. (\\<Union>A\\<in>set A_pos. A) = (\\<Union>(A, X)\\<in>Q. A)", "then"], ["proof (chain)\npicking this:\n  length A_pos \\<le> length L", "show ?thesis"], ["proof (prove)\nusing this:\n  length A_pos \\<le> length L\n\ngoal (1 subgoal):\n 1. (\\<Union>A\\<in>set A_pos. A) = (\\<Union>(A, X)\\<in>Q. A)", "unfolding Q_alt"], ["proof (prove)\nusing this:\n  length A_pos \\<le> length L\n\ngoal (1 subgoal):\n 1. (\\<Union>A\\<in>set A_pos. A) =\n    (\\<Union>(A, X)\\<in>set (zip A_pos (take (length A_pos) L)). A)", "by (auto elim: in_set_impl_in_set_zip1[rotated, where ys=\"take (length A_pos) L\"]\n          dest: set_zip_leftD)"], ["proof (state)\nthis:\n  (\\<Union>A\\<in>set A_pos. A) = (\\<Union>(A, X)\\<in>Q. A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>A\\<in>set A_pos. A) = (\\<Union>(A, X)\\<in>Q. A)\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "moreover"], ["proof (state)\nthis:\n  (\\<Union>A\\<in>set A_pos. A) = (\\<Union>(A, X)\\<in>Q. A)\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "have \"\\<And>z. (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<longleftrightarrow>\n    list_all2 (\\<lambda>A X. restrict A z \\<in> X) A_pos (take (length A_pos) L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) =\n       list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n        (take (length A_pos) L)", "unfolding Q_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       (\\<forall>(A, X)\\<in>set (zip A_pos (take (length A_pos) L)).\n           restrict A z \\<in> X) =\n       list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n        (take (length A_pos) L)", "using assms(2)"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       (\\<forall>(A, X)\\<in>set (zip A_pos (take (length A_pos) L)).\n           restrict A z \\<in> X) =\n       list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n        (take (length A_pos) L)", "by (auto simp add: list_all2_iff)"], ["proof (state)\nthis:\n  (\\<forall>(A, X)\\<in>Q. restrict A ?z \\<in> X) =\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A ?z)) A_pos\n   (take (length A_pos) L)\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "moreover"], ["proof (state)\nthis:\n  (\\<forall>(A, X)\\<in>Q. restrict A ?z \\<in> X) =\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A ?z)) A_pos\n   (take (length A_pos) L)\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "have \"\\<And>z. (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<longleftrightarrow>\n    list_all2 (\\<lambda>A X. restrict A z \\<notin> X) A_neg (drop (length A_pos) L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) =\n       list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n        (drop (length A_pos) L)", "unfolding Q_neg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       (\\<forall>(A, X)\\<in>set (zip A_neg (drop (length A_pos) L)).\n           restrict A z \\<notin> X) =\n       list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n        (drop (length A_pos) L)", "using assms(2)"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       (\\<forall>(A, X)\\<in>set (zip A_neg (drop (length A_pos) L)).\n           restrict A z \\<notin> X) =\n       list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n        (drop (length A_pos) L)", "by (auto simp add: list_all2_iff)"], ["proof (state)\nthis:\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A ?z \\<notin> X) =\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A ?z)) A_neg\n   (drop (length A_pos) L)\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "ultimately"], ["proof (chain)\npicking this:\n  (z \\<in> mmulti_join' A_pos A_neg L) =\n  (wf_tuple n (\\<Union>(A, X)\\<in>Q. A) z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n  (\\<Union>A\\<in>set A_pos. A) = (\\<Union>(A, X)\\<in>Q. A)\n  (\\<forall>(A, X)\\<in>Q. restrict A ?z \\<in> X) =\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A ?z)) A_pos\n   (take (length A_pos) L)\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A ?z \\<notin> X) =\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A ?z)) A_neg\n   (drop (length A_pos) L)", "show ?thesis"], ["proof (prove)\nusing this:\n  (z \\<in> mmulti_join' A_pos A_neg L) =\n  (wf_tuple n (\\<Union>(A, X)\\<in>Q. A) z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n  (\\<Union>A\\<in>set A_pos. A) = (\\<Union>(A, X)\\<in>Q. A)\n  (\\<forall>(A, X)\\<in>Q. restrict A ?z \\<in> X) =\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A ?z)) A_pos\n   (take (length A_pos) L)\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A ?z \\<notin> X) =\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A ?z)) A_neg\n   (drop (length A_pos) L)\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "unfolding Q_def Q_neg_def"], ["proof (prove)\nusing this:\n  (z \\<in> mmulti_join' A_pos A_neg L) =\n  (wf_tuple n (\\<Union>(A, X)\\<in>set (zip A_pos L). A) z \\<and>\n   (\\<forall>(A, X)\\<in>set (zip A_pos L). restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>set (zip A_neg (drop (length A_pos) L)).\n       restrict A z \\<notin> X))\n  (\\<Union>A\\<in>set A_pos. A) = (\\<Union>(A, X)\\<in>set (zip A_pos L). A)\n  (\\<forall>(A, X)\\<in>set (zip A_pos L). restrict A ?z \\<in> X) =\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A ?z)) A_pos\n   (take (length A_pos) L)\n  (\\<forall>(A, X)\\<in>set (zip A_neg (drop (length A_pos) L)).\n      restrict A ?z \\<notin> X) =\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A ?z)) A_neg\n   (drop (length A_pos) L)\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "using assms(2)"], ["proof (prove)\nusing this:\n  (z \\<in> mmulti_join' A_pos A_neg L) =\n  (wf_tuple n (\\<Union>(A, X)\\<in>set (zip A_pos L). A) z \\<and>\n   (\\<forall>(A, X)\\<in>set (zip A_pos L). restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>set (zip A_neg (drop (length A_pos) L)).\n       restrict A z \\<notin> X))\n  (\\<Union>A\\<in>set A_pos. A) = (\\<Union>(A, X)\\<in>set (zip A_pos L). A)\n  (\\<forall>(A, X)\\<in>set (zip A_pos L). restrict A ?z \\<in> X) =\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A ?z)) A_pos\n   (take (length A_pos) L)\n  (\\<forall>(A, X)\\<in>set (zip A_neg (drop (length A_pos) L)).\n      restrict A ?z \\<notin> X) =\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A ?z)) A_neg\n   (drop (length A_pos) L)\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "by simp"], ["proof (state)\nthis:\n  (z \\<in> mmulti_join' A_pos A_neg L) =\n  (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n   list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n    (take (length A_pos) L) \\<and>\n   list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n    (drop (length A_pos) L))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas restrict_nested = New_max.restrict_nested"], ["", "lemma list_all2_opt_True:\n  assumes \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) ((A_zs @ A_x # A_xs @ A_y # A_ys) @ A_neg)\n    ((zs @ x # xs @ y # ys) @ L_neg)\"\n    \"length A_xs = length xs\" \"length A_ys = length ys\" \"length A_zs = length zs\"\n  shows \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n    ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg) ((zs @ join x True y # xs @ ys) @ L_neg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg)\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg)\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "have assms_dest: \"table n A_x x\" \"table n A_y y\" \"wf_set n A_x\" \"wf_set n A_y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (table n A_x x &&& table n A_y y) &&& wf_set n A_x &&& wf_set n A_y", "using assms"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs @ A_y # A_ys) @ A_neg)\n   ((zs @ x # xs @ y # ys) @ L_neg)\n  length A_xs = length xs\n  length A_ys = length ys\n  length A_zs = length zs\n\ngoal (1 subgoal):\n 1. (table n A_x x &&& table n A_y y) &&& wf_set n A_x &&& wf_set n A_y", "by (auto simp del: mmulti_join'.simps simp add: list_all2_append1 dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  table n A_x x\n  table n A_y y\n  wf_set n A_x\n  wf_set n A_y\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg)\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "then"], ["proof (chain)\npicking this:\n  table n A_x x\n  table n A_y y\n  wf_set n A_x\n  wf_set n A_y", "have tabs: \"table n (A_x \\<union> A_y) (join x True y)\" \"wf_set n (A_x \\<union> A_y)\""], ["proof (prove)\nusing this:\n  table n A_x x\n  table n A_y y\n  wf_set n A_x\n  wf_set n A_y\n\ngoal (1 subgoal):\n 1. table n (A_x \\<union> A_y) (join x True y) &&&\n    wf_set n (A_x \\<union> A_y)", "using join_table[of n A_x x A_y y True \"A_x \\<union> A_y\", OF assms_dest(1,2)] assms_dest(3,4)"], ["proof (prove)\nusing this:\n  table n A_x x\n  table n A_y y\n  wf_set n A_x\n  wf_set n A_y\n  \\<lbrakk>\\<not> True \\<Longrightarrow> A_y \\<subseteq> A_x;\n   A_x \\<union> A_y = A_x \\<union> A_y\\<rbrakk>\n  \\<Longrightarrow> table n (A_x \\<union> A_y) (join x True y)\n  wf_set n A_x\n  wf_set n A_y\n\ngoal (1 subgoal):\n 1. table n (A_x \\<union> A_y) (join x True y) &&&\n    wf_set n (A_x \\<union> A_y)", "by (auto simp add: wf_set_def)"], ["proof (state)\nthis:\n  table n (A_x \\<union> A_y) (join x True y)\n  wf_set n (A_x \\<union> A_y)\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg)\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "then"], ["proof (chain)\npicking this:\n  table n (A_x \\<union> A_y) (join x True y)\n  wf_set n (A_x \\<union> A_y)", "show \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n    ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg) ((zs @ join x True y # xs @ ys) @ L_neg)\""], ["proof (prove)\nusing this:\n  table n (A_x \\<union> A_y) (join x True y)\n  wf_set n (A_x \\<union> A_y)\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg)\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "using assms"], ["proof (prove)\nusing this:\n  table n (A_x \\<union> A_y) (join x True y)\n  wf_set n (A_x \\<union> A_y)\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs @ A_y # A_ys) @ A_neg)\n   ((zs @ x # xs @ y # ys) @ L_neg)\n  length A_xs = length xs\n  length A_ys = length ys\n  length A_zs = length zs\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg)\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "by (auto simp del: mmulti_join'.simps simp add: list_all2_append1 list_all2_append2\n        list_all2_Cons1 list_all2_Cons2 dest: list_all2_lengthD) fastforce"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg)\n   ((zs @ join x True y # xs @ ys) @ L_neg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mmulti_join'_opt_True:\n  assumes \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) ((A_zs @ A_x # A_xs @ A_y # A_ys) @ A_neg)\n    ((zs @ x # xs @ y # ys) @ L_neg)\"\n    \"length A_xs = length xs\" \"length A_ys = length ys\" \"length A_zs = length zs\"\n  shows \"mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg ((zs @ x # xs @ y # ys) @ L_neg) =\n    mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n    ((zs @ join x True y # xs @ ys) @ L_neg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n     ((zs @ x # xs @ y # ys) @ L_neg) =\n    mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n     ((zs @ x # xs @ y # ys) @ L_neg) =\n    mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "have assms_dest: \"table n A_x x\" \"table n A_y y\" \"wf_set n A_x\" \"wf_set n A_y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (table n A_x x &&& table n A_y y) &&& wf_set n A_x &&& wf_set n A_y", "using assms"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs @ A_y # A_ys) @ A_neg)\n   ((zs @ x # xs @ y # ys) @ L_neg)\n  length A_xs = length xs\n  length A_ys = length ys\n  length A_zs = length zs\n\ngoal (1 subgoal):\n 1. (table n A_x x &&& table n A_y y) &&& wf_set n A_x &&& wf_set n A_y", "by (auto simp del: mmulti_join'.simps simp add: list_all2_append1 dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  table n A_x x\n  table n A_y y\n  wf_set n A_x\n  wf_set n A_y\n\ngoal (1 subgoal):\n 1. mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n     ((zs @ x # xs @ y # ys) @ L_neg) =\n    mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "then"], ["proof (chain)\npicking this:\n  table n A_x x\n  table n A_y y\n  wf_set n A_x\n  wf_set n A_y", "have tabs: \"table n (A_x \\<union> A_y) (join x True y)\" \"wf_set n (A_x \\<union> A_y)\""], ["proof (prove)\nusing this:\n  table n A_x x\n  table n A_y y\n  wf_set n A_x\n  wf_set n A_y\n\ngoal (1 subgoal):\n 1. table n (A_x \\<union> A_y) (join x True y) &&&\n    wf_set n (A_x \\<union> A_y)", "using join_table[of n A_x x A_y y True \"A_x \\<union> A_y\", OF assms_dest(1,2)] assms_dest(3,4)"], ["proof (prove)\nusing this:\n  table n A_x x\n  table n A_y y\n  wf_set n A_x\n  wf_set n A_y\n  \\<lbrakk>\\<not> True \\<Longrightarrow> A_y \\<subseteq> A_x;\n   A_x \\<union> A_y = A_x \\<union> A_y\\<rbrakk>\n  \\<Longrightarrow> table n (A_x \\<union> A_y) (join x True y)\n  wf_set n A_x\n  wf_set n A_y\n\ngoal (1 subgoal):\n 1. table n (A_x \\<union> A_y) (join x True y) &&&\n    wf_set n (A_x \\<union> A_y)", "by (auto simp add: wf_set_def)"], ["proof (state)\nthis:\n  table n (A_x \\<union> A_y) (join x True y)\n  wf_set n (A_x \\<union> A_y)\n\ngoal (1 subgoal):\n 1. mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n     ((zs @ x # xs @ y # ys) @ L_neg) =\n    mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "then"], ["proof (chain)\npicking this:\n  table n (A_x \\<union> A_y) (join x True y)\n  wf_set n (A_x \\<union> A_y)", "have list_all2': \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n    ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg) ((zs @ join x True y # xs @ ys) @ L_neg)\""], ["proof (prove)\nusing this:\n  table n (A_x \\<union> A_y) (join x True y)\n  wf_set n (A_x \\<union> A_y)\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg)\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "using assms"], ["proof (prove)\nusing this:\n  table n (A_x \\<union> A_y) (join x True y)\n  wf_set n (A_x \\<union> A_y)\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs @ A_y # A_ys) @ A_neg)\n   ((zs @ x # xs @ y # ys) @ L_neg)\n  length A_xs = length xs\n  length A_ys = length ys\n  length A_zs = length zs\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg)\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "by (auto simp del: mmulti_join'.simps simp add: list_all2_append1 list_all2_append2\n        list_all2_Cons1 list_all2_Cons2 dest: list_all2_lengthD) fastforce"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg)\n   ((zs @ join x True y # xs @ ys) @ L_neg)\n\ngoal (1 subgoal):\n 1. mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n     ((zs @ x # xs @ y # ys) @ L_neg) =\n    mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "have res: \"\\<And>z Z. wf_tuple n Z z \\<Longrightarrow> A_x \\<union> A_y \\<subseteq> Z \\<Longrightarrow>\n    restrict (A_x \\<union> A_y) z \\<in> join x True y \\<longleftrightarrow> restrict A_x z \\<in> x \\<and> restrict A_y z \\<in> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z Z.\n       \\<lbrakk>wf_tuple n Z z; A_x \\<union> A_y \\<subseteq> Z\\<rbrakk>\n       \\<Longrightarrow> (restrict (A_x \\<union> A_y) z\n                          \\<in> join x True y) =\n                         (restrict A_x z \\<in> x \\<and>\n                          restrict A_y z \\<in> y)", "using join_restrict[of x n A_x y A_y True] wf_tuple_restrict_simple[of n _ _ \"A_x \\<union> A_y\"]\n      assms_dest(1,2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>v. v \\<in> x \\<Longrightarrow> wf_tuple n A_x v;\n   \\<And>v. v \\<in> y \\<Longrightarrow> wf_tuple n A_y v;\n   \\<not> True \\<Longrightarrow> A_y \\<subseteq> A_x\\<rbrakk>\n  \\<Longrightarrow> (?v \\<in> join x True y) =\n                    (wf_tuple n (A_x \\<union> A_y) ?v \\<and>\n                     restrict A_x ?v \\<in> x \\<and>\n                     join_cond True y (restrict A_y ?v))\n  \\<lbrakk>wf_tuple n ?B ?v; A_x \\<union> A_y \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> wf_tuple n (A_x \\<union> A_y)\n                     (restrict (A_x \\<union> A_y) ?v)\n  table n A_x x\n  table n A_y y\n\ngoal (1 subgoal):\n 1. \\<And>z Z.\n       \\<lbrakk>wf_tuple n Z z; A_x \\<union> A_y \\<subseteq> Z\\<rbrakk>\n       \\<Longrightarrow> (restrict (A_x \\<union> A_y) z\n                          \\<in> join x True y) =\n                         (restrict A_x z \\<in> x \\<and>\n                          restrict A_y z \\<in> y)", "by (auto simp add: table_def restrict_nested Int_absorb2)"], ["proof (state)\nthis:\n  \\<lbrakk>wf_tuple n ?Z ?z; A_x \\<union> A_y \\<subseteq> ?Z\\<rbrakk>\n  \\<Longrightarrow> (restrict (A_x \\<union> A_y) ?z \\<in> join x True y) =\n                    (restrict A_x ?z \\<in> x \\<and> restrict A_y ?z \\<in> y)\n\ngoal (1 subgoal):\n 1. mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n     ((zs @ x # xs @ y # ys) @ L_neg) =\n    mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n     ((zs @ x # xs @ y # ys) @ L_neg) =\n    mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "proof (rule set_eqI, rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n                 ((zs @ x # xs @ y # ys) @ L_neg) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n                 ((zs @ join x True y # xs @ ys) @ L_neg)\n 2. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n                 ((zs @ join x True y # xs @ ys) @ L_neg) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n                 ((zs @ x # xs @ y # ys) @ L_neg)", "fix z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n                 ((zs @ x # xs @ y # ys) @ L_neg) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n                 ((zs @ join x True y # xs @ ys) @ L_neg)\n 2. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n                 ((zs @ join x True y # xs @ ys) @ L_neg) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n                 ((zs @ x # xs @ y # ys) @ L_neg)", "assume \"z \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n      ((zs @ x # xs @ y # ys) @ L_neg)\""], ["proof (state)\nthis:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n           ((zs @ x # xs @ y # ys) @ L_neg)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n                 ((zs @ x # xs @ y # ys) @ L_neg) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n                 ((zs @ join x True y # xs @ ys) @ L_neg)\n 2. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n                 ((zs @ join x True y # xs @ ys) @ L_neg) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n                 ((zs @ x # xs @ y # ys) @ L_neg)", "then"], ["proof (chain)\npicking this:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n           ((zs @ x # xs @ y # ys) @ L_neg)", "have z_in_dest: \"wf_tuple n (\\<Union>(set (A_zs @ A_x # A_xs @ A_y # A_ys))) z\"\n      \"list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\"\n      \"restrict A_x z \\<in> x\"\n      \"list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_ys ys\"\n      \"restrict A_y z \\<in> y\"\n      \"list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\"\n      \"list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg L_neg\""], ["proof (prove)\nusing this:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n           ((zs @ x # xs @ y # ys) @ L_neg)\n\ngoal (1 subgoal):\n 1. (wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs @ A_y # A_ys))) z &&&\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs &&&\n     restrict A_x z \\<in> x) &&&\n    (list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_ys ys &&&\n     restrict A_y z \\<in> y) &&&\n    list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs &&&\n    list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg L_neg", "using mmulti_join'_correct[OF _ assms(1), of z]"], ["proof (prove)\nusing this:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n           ((zs @ x # xs @ y # ys) @ L_neg)\n  A_zs @ A_x # A_xs @ A_y # A_ys \\<noteq> [] \\<Longrightarrow>\n  (z \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n            ((zs @ x # xs @ y # ys) @ L_neg)) =\n  (wf_tuple n (\\<Union>A\\<in>set (A_zs @ A_x # A_xs @ A_y # A_ys). A)\n    z \\<and>\n   list_all2 (\\<lambda>A. (\\<in>) (restrict A z))\n    (A_zs @ A_x # A_xs @ A_y # A_ys)\n    (take (length (A_zs @ A_x # A_xs @ A_y # A_ys))\n      ((zs @ x # xs @ y # ys) @ L_neg)) \\<and>\n   list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n    (drop (length (A_zs @ A_x # A_xs @ A_y # A_ys))\n      ((zs @ x # xs @ y # ys) @ L_neg)))\n\ngoal (1 subgoal):\n 1. (wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs @ A_y # A_ys))) z &&&\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs &&&\n     restrict A_x z \\<in> x) &&&\n    (list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_ys ys &&&\n     restrict A_y z \\<in> y) &&&\n    list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs &&&\n    list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg L_neg", "by (auto simp del: mmulti_join'.simps simp add: assms list_all2_append1\n          dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs @ A_y # A_ys))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict A_x z \\<in> x\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_ys ys\n  restrict A_y z \\<in> y\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg L_neg\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n                 ((zs @ x # xs @ y # ys) @ L_neg) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n                 ((zs @ join x True y # xs @ ys) @ L_neg)\n 2. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n                 ((zs @ join x True y # xs @ ys) @ L_neg) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n                 ((zs @ x # xs @ y # ys) @ L_neg)", "then"], ["proof (chain)\npicking this:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs @ A_y # A_ys))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict A_x z \\<in> x\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_ys ys\n  restrict A_y z \\<in> y\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg L_neg", "show \"z \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n      ((zs @ join x True y # xs @ ys) @ L_neg)\""], ["proof (prove)\nusing this:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs @ A_y # A_ys))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict A_x z \\<in> x\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_ys ys\n  restrict A_y z \\<in> y\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg L_neg\n\ngoal (1 subgoal):\n 1. z \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n             ((zs @ join x True y # xs @ ys) @ L_neg)", "using mmulti_join'_correct[OF _ list_all2', of z] res[OF z_in_dest(1)]"], ["proof (prove)\nusing this:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs @ A_y # A_ys))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict A_x z \\<in> x\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_ys ys\n  restrict A_y z \\<in> y\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg L_neg\n  A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys \\<noteq> [] \\<Longrightarrow>\n  (z \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n            ((zs @ join x True y # xs @ ys) @ L_neg)) =\n  (wf_tuple n\n    (\\<Union>A\\<in>set (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys). A)\n    z \\<and>\n   list_all2 (\\<lambda>A. (\\<in>) (restrict A z))\n    (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys)\n    (take (length (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys))\n      ((zs @ join x True y # xs @ ys) @ L_neg)) \\<and>\n   list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n    (drop (length (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys))\n      ((zs @ join x True y # xs @ ys) @ L_neg)))\n  A_x \\<union> A_y\n  \\<subseteq> \\<Union>\n               (set (A_zs @ A_x # A_xs @ A_y # A_ys)) \\<Longrightarrow>\n  (restrict (A_x \\<union> A_y) z \\<in> join x True y) =\n  (restrict A_x z \\<in> x \\<and> restrict A_y z \\<in> y)\n\ngoal (1 subgoal):\n 1. z \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n             ((zs @ join x True y # xs @ ys) @ L_neg)", "by (auto simp add: assms list_all2_appendI le_supI2 Un_assoc simp del: mmulti_join'.simps\n          dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  z \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n           ((zs @ join x True y # xs @ ys) @ L_neg)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n                 ((zs @ join x True y # xs @ ys) @ L_neg) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n                 ((zs @ x # xs @ y # ys) @ L_neg)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n                 ((zs @ join x True y # xs @ ys) @ L_neg) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n                 ((zs @ x # xs @ y # ys) @ L_neg)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n                 ((zs @ join x True y # xs @ ys) @ L_neg) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n                 ((zs @ x # xs @ y # ys) @ L_neg)", "assume \"z \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n      ((zs @ join x True y # xs @ ys) @ L_neg)\""], ["proof (state)\nthis:\n  z \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n           ((zs @ join x True y # xs @ ys) @ L_neg)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n                 ((zs @ join x True y # xs @ ys) @ L_neg) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n                 ((zs @ x # xs @ y # ys) @ L_neg)", "then"], ["proof (chain)\npicking this:\n  z \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n           ((zs @ join x True y # xs @ ys) @ L_neg)", "have z_in_dest: \"wf_tuple n (\\<Union>(set (A_zs @ A_x # A_xs @ A_y # A_ys))) z\"\n      \"list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\"\n      \"restrict (A_x \\<union> A_y) z \\<in> join x True y\"\n      \"list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_ys ys\"\n      \"list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\"\n      \"list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg L_neg\""], ["proof (prove)\nusing this:\n  z \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n           ((zs @ join x True y # xs @ ys) @ L_neg)\n\ngoal (1 subgoal):\n 1. (wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs @ A_y # A_ys))) z &&&\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs &&&\n     restrict (A_x \\<union> A_y) z \\<in> join x True y) &&&\n    list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_ys ys &&&\n    list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs &&&\n    list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg L_neg", "using mmulti_join'_correct[OF _ list_all2', of z]"], ["proof (prove)\nusing this:\n  z \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n           ((zs @ join x True y # xs @ ys) @ L_neg)\n  A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys \\<noteq> [] \\<Longrightarrow>\n  (z \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n            ((zs @ join x True y # xs @ ys) @ L_neg)) =\n  (wf_tuple n\n    (\\<Union>A\\<in>set (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys). A)\n    z \\<and>\n   list_all2 (\\<lambda>A. (\\<in>) (restrict A z))\n    (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys)\n    (take (length (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys))\n      ((zs @ join x True y # xs @ ys) @ L_neg)) \\<and>\n   list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n    (drop (length (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys))\n      ((zs @ join x True y # xs @ ys) @ L_neg)))\n\ngoal (1 subgoal):\n 1. (wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs @ A_y # A_ys))) z &&&\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs &&&\n     restrict (A_x \\<union> A_y) z \\<in> join x True y) &&&\n    list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_ys ys &&&\n    list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs &&&\n    list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg L_neg", "by (auto simp del: mmulti_join'.simps simp add: assms list_all2_append Un_assoc\n          dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs @ A_y # A_ys))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict (A_x \\<union> A_y) z \\<in> join x True y\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_ys ys\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg L_neg\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n                 ((zs @ join x True y # xs @ ys) @ L_neg) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n                 ((zs @ x # xs @ y # ys) @ L_neg)", "then"], ["proof (chain)\npicking this:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs @ A_y # A_ys))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict (A_x \\<union> A_y) z \\<in> join x True y\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_ys ys\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg L_neg", "show \"z \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n      ((zs @ x # xs @ y # ys) @ L_neg)\""], ["proof (prove)\nusing this:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs @ A_y # A_ys))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict (A_x \\<union> A_y) z \\<in> join x True y\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_ys ys\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg L_neg\n\ngoal (1 subgoal):\n 1. z \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n             ((zs @ x # xs @ y # ys) @ L_neg)", "using mmulti_join'_correct[OF _ assms(1), of z] res[OF z_in_dest(1)]"], ["proof (prove)\nusing this:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs @ A_y # A_ys))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict (A_x \\<union> A_y) z \\<in> join x True y\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_ys ys\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg L_neg\n  A_zs @ A_x # A_xs @ A_y # A_ys \\<noteq> [] \\<Longrightarrow>\n  (z \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n            ((zs @ x # xs @ y # ys) @ L_neg)) =\n  (wf_tuple n (\\<Union>A\\<in>set (A_zs @ A_x # A_xs @ A_y # A_ys). A)\n    z \\<and>\n   list_all2 (\\<lambda>A. (\\<in>) (restrict A z))\n    (A_zs @ A_x # A_xs @ A_y # A_ys)\n    (take (length (A_zs @ A_x # A_xs @ A_y # A_ys))\n      ((zs @ x # xs @ y # ys) @ L_neg)) \\<and>\n   list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n    (drop (length (A_zs @ A_x # A_xs @ A_y # A_ys))\n      ((zs @ x # xs @ y # ys) @ L_neg)))\n  A_x \\<union> A_y\n  \\<subseteq> \\<Union>\n               (set (A_zs @ A_x # A_xs @ A_y # A_ys)) \\<Longrightarrow>\n  (restrict (A_x \\<union> A_y) z \\<in> join x True y) =\n  (restrict A_x z \\<in> x \\<and> restrict A_y z \\<in> y)\n\ngoal (1 subgoal):\n 1. z \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n             ((zs @ x # xs @ y # ys) @ L_neg)", "by (auto simp add: assms list_all2_appendI le_supI2 Un_assoc simp del: mmulti_join'.simps\n          dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n           ((zs @ x # xs @ y # ys) @ L_neg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n   ((zs @ x # xs @ y # ys) @ L_neg) =\n  mmulti_join' (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n   ((zs @ join x True y # xs @ ys) @ L_neg)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_all2_opt_False:\n  assumes \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n    ((A_zs @ A_x # A_xs) @ (A_ws @ A_y # A_ys)) ((zs @ x # xs) @ (ws @ y # ys))\"\n    \"length A_ws = length ws\" \"length A_xs = length xs\"\n    \"length A_ys = length ys\" \"length A_zs = length zs\"\n    \"A_y \\<subseteq> A_x\"\n  shows \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n    ((A_zs @ A_x # A_xs) @ (A_ws @ A_ys)) ((zs @ join x False y # xs) @ (ws @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ A_x # A_xs) @ A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ A_x # A_xs) @ A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "have assms_dest: \"table n A_x x\" \"table n A_y y\" \"wf_set n A_x\" \"wf_set n A_y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (table n A_x x &&& table n A_y y) &&& wf_set n A_x &&& wf_set n A_y", "using assms"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs) @ A_ws @ A_y # A_ys) ((zs @ x # xs) @ ws @ y # ys)\n  length A_ws = length ws\n  length A_xs = length xs\n  length A_ys = length ys\n  length A_zs = length zs\n  A_y \\<subseteq> A_x\n\ngoal (1 subgoal):\n 1. (table n A_x x &&& table n A_y y) &&& wf_set n A_x &&& wf_set n A_y", "by (auto simp del: mmulti_join'.simps simp add: list_all2_append dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  table n A_x x\n  table n A_y y\n  wf_set n A_x\n  wf_set n A_y\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ A_x # A_xs) @ A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "have tabs: \"table n A_x (join x False y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n A_x (join x False y)", "using join_table[of n A_x x A_y y False A_x, OF assms_dest(1,2) assms(6)] assms(6)"], ["proof (prove)\nusing this:\n  A_x \\<union> A_y = A_x \\<Longrightarrow> table n A_x (join x False y)\n  A_y \\<subseteq> A_x\n\ngoal (1 subgoal):\n 1. table n A_x (join x False y)", "by auto"], ["proof (state)\nthis:\n  table n A_x (join x False y)\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ A_x # A_xs) @ A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "then"], ["proof (chain)\npicking this:\n  table n A_x (join x False y)", "show \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n    ((A_zs @ A_x # A_xs) @ (A_ws @ A_ys)) ((zs @ join x False y # xs) @ (ws @ ys))\""], ["proof (prove)\nusing this:\n  table n A_x (join x False y)\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ A_x # A_xs) @ A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "using assms assms_dest(3)"], ["proof (prove)\nusing this:\n  table n A_x (join x False y)\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs) @ A_ws @ A_y # A_ys) ((zs @ x # xs) @ ws @ y # ys)\n  length A_ws = length ws\n  length A_xs = length xs\n  length A_ys = length ys\n  length A_zs = length zs\n  A_y \\<subseteq> A_x\n  wf_set n A_x\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ A_x # A_xs) @ A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "by (auto simp del: mmulti_join'.simps simp add: list_all2_append1 list_all2_append2\n        list_all2_Cons1 list_all2_Cons2 dest: list_all2_lengthD) fastforce"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs) @ A_ws @ A_ys)\n   ((zs @ join x False y # xs) @ ws @ ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mmulti_join'_opt_False:\n  assumes \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n    ((A_zs @ A_x # A_xs) @ (A_ws @ A_y # A_ys)) ((zs @ x # xs) @ (ws @ y # ys))\"\n    \"length A_ws = length ws\" \"length A_xs = length xs\"\n    \"length A_ys = length ys\" \"length A_zs = length zs\"\n    \"A_y \\<subseteq> A_x\"\n  shows \"mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys) ((zs @ x # xs) @ (ws @ y # ys)) =\n    mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys) ((zs @ join x False y # xs) @ (ws @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n     ((zs @ x # xs) @ ws @ y # ys) =\n    mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n     ((zs @ x # xs) @ ws @ y # ys) =\n    mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "have assms_dest: \"table n A_x x\" \"table n A_y y\" \"wf_set n A_x\" \"wf_set n A_y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (table n A_x x &&& table n A_y y) &&& wf_set n A_x &&& wf_set n A_y", "using assms"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs) @ A_ws @ A_y # A_ys) ((zs @ x # xs) @ ws @ y # ys)\n  length A_ws = length ws\n  length A_xs = length xs\n  length A_ys = length ys\n  length A_zs = length zs\n  A_y \\<subseteq> A_x\n\ngoal (1 subgoal):\n 1. (table n A_x x &&& table n A_y y) &&& wf_set n A_x &&& wf_set n A_y", "by (auto simp del: mmulti_join'.simps simp add: list_all2_append dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  table n A_x x\n  table n A_y y\n  wf_set n A_x\n  wf_set n A_y\n\ngoal (1 subgoal):\n 1. mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n     ((zs @ x # xs) @ ws @ y # ys) =\n    mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "have tabs: \"table n A_x (join x False y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n A_x (join x False y)", "using join_table[of n A_x x A_y y False A_x, OF assms_dest(1,2) assms(6)] assms(6)"], ["proof (prove)\nusing this:\n  A_x \\<union> A_y = A_x \\<Longrightarrow> table n A_x (join x False y)\n  A_y \\<subseteq> A_x\n\ngoal (1 subgoal):\n 1. table n A_x (join x False y)", "by auto"], ["proof (state)\nthis:\n  table n A_x (join x False y)\n\ngoal (1 subgoal):\n 1. mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n     ((zs @ x # xs) @ ws @ y # ys) =\n    mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "then"], ["proof (chain)\npicking this:\n  table n A_x (join x False y)", "have list_all2': \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n    ((A_zs @ A_x # A_xs) @ (A_ws @ A_ys)) ((zs @ join x False y # xs) @ (ws @ ys))\""], ["proof (prove)\nusing this:\n  table n A_x (join x False y)\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ A_x # A_xs) @ A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "using assms assms_dest(3)"], ["proof (prove)\nusing this:\n  table n A_x (join x False y)\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs) @ A_ws @ A_y # A_ys) ((zs @ x # xs) @ ws @ y # ys)\n  length A_ws = length ws\n  length A_xs = length xs\n  length A_ys = length ys\n  length A_zs = length zs\n  A_y \\<subseteq> A_x\n  wf_set n A_x\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ A_x # A_xs) @ A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "by (auto simp del: mmulti_join'.simps simp add: list_all2_append1 list_all2_append2\n        list_all2_Cons1 list_all2_Cons2 dest: list_all2_lengthD) fastforce"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs) @ A_ws @ A_ys)\n   ((zs @ join x False y # xs) @ ws @ ys)\n\ngoal (1 subgoal):\n 1. mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n     ((zs @ x # xs) @ ws @ y # ys) =\n    mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "have res: \"\\<And>z. restrict A_x z \\<in> join x False y \\<longleftrightarrow> restrict A_x z \\<in> x \\<and> restrict A_y z \\<notin> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       (restrict A_x z \\<in> join x False y) =\n       (restrict A_x z \\<in> x \\<and> restrict A_y z \\<notin> y)", "using join_restrict[of x n A_x y A_y False, OF _ _ assms(6)] assms_dest(1,2) assms(6)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>v. v \\<in> x \\<Longrightarrow> wf_tuple n A_x v;\n   \\<And>v. v \\<in> y \\<Longrightarrow> wf_tuple n A_y v\\<rbrakk>\n  \\<Longrightarrow> (?v \\<in> join x False y) =\n                    (wf_tuple n (A_x \\<union> A_y) ?v \\<and>\n                     restrict A_x ?v \\<in> x \\<and>\n                     join_cond False y (restrict A_y ?v))\n  table n A_x x\n  table n A_y y\n  A_y \\<subseteq> A_x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       (restrict A_x z \\<in> join x False y) =\n       (restrict A_x z \\<in> x \\<and> restrict A_y z \\<notin> y)", "by (auto simp add: table_def restrict_nested Int_absorb2 Un_absorb2)"], ["proof (state)\nthis:\n  (restrict A_x ?z \\<in> join x False y) =\n  (restrict A_x ?z \\<in> x \\<and> restrict A_y ?z \\<notin> y)\n\ngoal (1 subgoal):\n 1. mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n     ((zs @ x # xs) @ ws @ y # ys) =\n    mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n     ((zs @ x # xs) @ ws @ y # ys) =\n    mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "proof (rule set_eqI, rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n                 ((zs @ x # xs) @ ws @ y # ys) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n                 ((zs @ join x False y # xs) @ ws @ ys)\n 2. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n                 ((zs @ join x False y # xs) @ ws @ ys) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n                 ((zs @ x # xs) @ ws @ y # ys)", "fix z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n                 ((zs @ x # xs) @ ws @ y # ys) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n                 ((zs @ join x False y # xs) @ ws @ ys)\n 2. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n                 ((zs @ join x False y # xs) @ ws @ ys) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n                 ((zs @ x # xs) @ ws @ y # ys)", "assume \"z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n      ((zs @ x # xs) @ ws @ y # ys)\""], ["proof (state)\nthis:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n           ((zs @ x # xs) @ ws @ y # ys)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n                 ((zs @ x # xs) @ ws @ y # ys) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n                 ((zs @ join x False y # xs) @ ws @ ys)\n 2. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n                 ((zs @ join x False y # xs) @ ws @ ys) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n                 ((zs @ x # xs) @ ws @ y # ys)", "then"], ["proof (chain)\npicking this:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n           ((zs @ x # xs) @ ws @ y # ys)", "have z_in_dest: \"wf_tuple n (\\<Union>(set (A_zs @ A_x # A_xs))) z\"\n      \"list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\"\n      \"restrict A_x z \\<in> x\"\n      \"list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\"\n      \"list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ws ws\"\n      \"restrict A_y z \\<notin> y\"\n      \"list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ys ys\""], ["proof (prove)\nusing this:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n           ((zs @ x # xs) @ ws @ y # ys)\n\ngoal (1 subgoal):\n 1. (wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs))) z &&&\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs &&&\n     restrict A_x z \\<in> x) &&&\n    (list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs &&&\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ws ws) &&&\n    restrict A_y z \\<notin> y &&&\n    list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ys ys", "using mmulti_join'_correct[OF _ assms(1), of z]"], ["proof (prove)\nusing this:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n           ((zs @ x # xs) @ ws @ y # ys)\n  A_zs @ A_x # A_xs \\<noteq> [] \\<Longrightarrow>\n  (z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n            ((zs @ x # xs) @ ws @ y # ys)) =\n  (wf_tuple n (\\<Union>A\\<in>set (A_zs @ A_x # A_xs). A) z \\<and>\n   list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) (A_zs @ A_x # A_xs)\n    (take (length (A_zs @ A_x # A_xs)) ((zs @ x # xs) @ ws @ y # ys)) \\<and>\n   list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) (A_ws @ A_y # A_ys)\n    (drop (length (A_zs @ A_x # A_xs)) ((zs @ x # xs) @ ws @ y # ys)))\n\ngoal (1 subgoal):\n 1. (wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs))) z &&&\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs &&&\n     restrict A_x z \\<in> x) &&&\n    (list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs &&&\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ws ws) &&&\n    restrict A_y z \\<notin> y &&&\n    list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ys ys", "by (auto simp del: mmulti_join'.simps simp add: assms list_all2_append1\n          dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict A_x z \\<in> x\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ws ws\n  restrict A_y z \\<notin> y\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ys ys\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n                 ((zs @ x # xs) @ ws @ y # ys) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n                 ((zs @ join x False y # xs) @ ws @ ys)\n 2. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n                 ((zs @ join x False y # xs) @ ws @ ys) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n                 ((zs @ x # xs) @ ws @ y # ys)", "then"], ["proof (chain)\npicking this:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict A_x z \\<in> x\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ws ws\n  restrict A_y z \\<notin> y\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ys ys", "show \"z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n      ((zs @ join x False y # xs) @ ws @ ys)\""], ["proof (prove)\nusing this:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict A_x z \\<in> x\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ws ws\n  restrict A_y z \\<notin> y\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ys ys\n\ngoal (1 subgoal):\n 1. z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n             ((zs @ join x False y # xs) @ ws @ ys)", "using mmulti_join'_correct[OF _ list_all2', of z] res"], ["proof (prove)\nusing this:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict A_x z \\<in> x\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ws ws\n  restrict A_y z \\<notin> y\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ys ys\n  A_zs @ A_x # A_xs \\<noteq> [] \\<Longrightarrow>\n  (z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n            ((zs @ join x False y # xs) @ ws @ ys)) =\n  (wf_tuple n (\\<Union>A\\<in>set (A_zs @ A_x # A_xs). A) z \\<and>\n   list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) (A_zs @ A_x # A_xs)\n    (take (length (A_zs @ A_x # A_xs))\n      ((zs @ join x False y # xs) @ ws @ ys)) \\<and>\n   list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) (A_ws @ A_ys)\n    (drop (length (A_zs @ A_x # A_xs))\n      ((zs @ join x False y # xs) @ ws @ ys)))\n  (restrict A_x ?z \\<in> join x False y) =\n  (restrict A_x ?z \\<in> x \\<and> restrict A_y ?z \\<notin> y)\n\ngoal (1 subgoal):\n 1. z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n             ((zs @ join x False y # xs) @ ws @ ys)", "by (auto simp add: assms list_all2_appendI Un_assoc simp del: mmulti_join'.simps\n          dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n           ((zs @ join x False y # xs) @ ws @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n                 ((zs @ join x False y # xs) @ ws @ ys) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n                 ((zs @ x # xs) @ ws @ y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n                 ((zs @ join x False y # xs) @ ws @ ys) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n                 ((zs @ x # xs) @ ws @ y # ys)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n                 ((zs @ join x False y # xs) @ ws @ ys) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n                 ((zs @ x # xs) @ ws @ y # ys)", "assume \"z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n      ((zs @ join x False y # xs) @ ws @ ys)\""], ["proof (state)\nthis:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n           ((zs @ join x False y # xs) @ ws @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n                 ((zs @ join x False y # xs) @ ws @ ys) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n                 ((zs @ x # xs) @ ws @ y # ys)", "then"], ["proof (chain)\npicking this:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n           ((zs @ join x False y # xs) @ ws @ ys)", "have z_in_dest: \"wf_tuple n (\\<Union>(set (A_zs @ A_x # A_xs))) z\"\n      \"list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\"\n      \"restrict A_x z \\<in> join x False y\"\n      \"list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\"\n      \"list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ws ws\"\n      \"list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ys ys\""], ["proof (prove)\nusing this:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n           ((zs @ join x False y # xs) @ ws @ ys)\n\ngoal (1 subgoal):\n 1. (wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs))) z &&&\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs &&&\n     restrict A_x z \\<in> join x False y) &&&\n    list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs &&&\n    list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ws ws &&&\n    list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ys ys", "using mmulti_join'_correct[OF _ list_all2', of z]"], ["proof (prove)\nusing this:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n           ((zs @ join x False y # xs) @ ws @ ys)\n  A_zs @ A_x # A_xs \\<noteq> [] \\<Longrightarrow>\n  (z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n            ((zs @ join x False y # xs) @ ws @ ys)) =\n  (wf_tuple n (\\<Union>A\\<in>set (A_zs @ A_x # A_xs). A) z \\<and>\n   list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) (A_zs @ A_x # A_xs)\n    (take (length (A_zs @ A_x # A_xs))\n      ((zs @ join x False y # xs) @ ws @ ys)) \\<and>\n   list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) (A_ws @ A_ys)\n    (drop (length (A_zs @ A_x # A_xs))\n      ((zs @ join x False y # xs) @ ws @ ys)))\n\ngoal (1 subgoal):\n 1. (wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs))) z &&&\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs &&&\n     restrict A_x z \\<in> join x False y) &&&\n    list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs &&&\n    list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ws ws &&&\n    list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ys ys", "by (auto simp del: mmulti_join'.simps simp add: assms list_all2_append1\n          dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict A_x z \\<in> join x False y\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ws ws\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ys ys\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n                 ((zs @ join x False y # xs) @ ws @ ys) \\<Longrightarrow>\n       xa \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n                 ((zs @ x # xs) @ ws @ y # ys)", "then"], ["proof (chain)\npicking this:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict A_x z \\<in> join x False y\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ws ws\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ys ys", "show \"z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n      ((zs @ x # xs) @ ws @ y # ys)\""], ["proof (prove)\nusing this:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict A_x z \\<in> join x False y\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ws ws\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ys ys\n\ngoal (1 subgoal):\n 1. z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n             ((zs @ x # xs) @ ws @ y # ys)", "using mmulti_join'_correct[OF _ assms(1), of z] res"], ["proof (prove)\nusing this:\n  wf_tuple n (\\<Union> (set (A_zs @ A_x # A_xs))) z\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_zs zs\n  restrict A_x z \\<in> join x False y\n  list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_xs xs\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ws ws\n  list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_ys ys\n  A_zs @ A_x # A_xs \\<noteq> [] \\<Longrightarrow>\n  (z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n            ((zs @ x # xs) @ ws @ y # ys)) =\n  (wf_tuple n (\\<Union>A\\<in>set (A_zs @ A_x # A_xs). A) z \\<and>\n   list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) (A_zs @ A_x # A_xs)\n    (take (length (A_zs @ A_x # A_xs)) ((zs @ x # xs) @ ws @ y # ys)) \\<and>\n   list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) (A_ws @ A_y # A_ys)\n    (drop (length (A_zs @ A_x # A_xs)) ((zs @ x # xs) @ ws @ y # ys)))\n  (restrict A_x ?z \\<in> join x False y) =\n  (restrict A_x ?z \\<in> x \\<and> restrict A_y ?z \\<notin> y)\n\ngoal (1 subgoal):\n 1. z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n             ((zs @ x # xs) @ ws @ y # ys)", "by (auto simp add: assms list_all2_appendI Un_assoc simp del: mmulti_join'.simps\n          dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  z \\<in> mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n           ((zs @ x # xs) @ ws @ y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n   ((zs @ x # xs) @ ws @ y # ys) =\n  mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n   ((zs @ join x False y # xs) @ ws @ ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun find_sub_in :: \"'a set \\<Rightarrow> 'a set list \\<Rightarrow> bool \\<Rightarrow>\n  ('a set list \\<times> 'a set \\<times> 'a set list) option\" where\n  \"find_sub_in X [] b = None\"\n| \"find_sub_in X (x # xs) b = (if (x \\<subseteq> X \\<or> (b \\<and> X \\<subseteq> x)) then Some ([], x, xs)\n    else (case find_sub_in X xs b of None \\<Rightarrow> None | Some (ys, z, zs) \\<Rightarrow> Some (x # ys, z, zs)))\""], ["", "lemma find_sub_in_sound: \"find_sub_in X xs b = Some (ys, z, zs) \\<Longrightarrow>\n  xs = ys @ z # zs \\<and> (z \\<subseteq> X \\<or> (b \\<and> X \\<subseteq> z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_sub_in X xs b = Some (ys, z, zs) \\<Longrightarrow>\n    xs = ys @ z # zs \\<and> (z \\<subseteq> X \\<or> b \\<and> X \\<subseteq> z)", "by (induction X xs b arbitrary: ys z zs rule: find_sub_in.induct)\n     (fastforce split: if_splits option.splits)+"], ["", "fun find_sub_True :: \"'a set list \\<Rightarrow>\n  ('a set list \\<times> 'a set \\<times> 'a set list \\<times> 'a set \\<times> 'a set list) option\" where\n  \"find_sub_True [] = None\"\n| \"find_sub_True (x # xs) = (case find_sub_in x xs True of None \\<Rightarrow>\n    (case find_sub_True xs of None \\<Rightarrow> None\n    | Some (ys, w, ws, z, zs) \\<Rightarrow> Some (x # ys, w, ws, z, zs))\n  | Some (ys, z, zs) \\<Rightarrow> Some ([], x, ys, z, zs))\""], ["", "lemma find_sub_True_sound: \"find_sub_True xs = Some (ys, w, ws, z, zs) \\<Longrightarrow>\n  xs = ys @ w # ws @ z # zs \\<and> (z \\<subseteq> w \\<or> w \\<subseteq> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_sub_True xs = Some (ys, w, ws, z, zs) \\<Longrightarrow>\n    xs = ys @ w # ws @ z # zs \\<and> (z \\<subseteq> w \\<or> w \\<subseteq> z)", "using find_sub_in_sound"], ["proof (prove)\nusing this:\n  find_sub_in ?X ?xs ?b = Some (?ys, ?z, ?zs) \\<Longrightarrow>\n  ?xs = ?ys @ ?z # ?zs \\<and>\n  (?z \\<subseteq> ?X \\<or> ?b \\<and> ?X \\<subseteq> ?z)\n\ngoal (1 subgoal):\n 1. find_sub_True xs = Some (ys, w, ws, z, zs) \\<Longrightarrow>\n    xs = ys @ w # ws @ z # zs \\<and> (z \\<subseteq> w \\<or> w \\<subseteq> z)", "by (induction xs arbitrary: ys w ws z zs rule: find_sub_True.induct)\n     (fastforce split: option.splits)+"], ["", "fun find_sub_False :: \"'a set list \\<Rightarrow> 'a set list \\<Rightarrow>\n  (('a set list \\<times> 'a set \\<times> 'a set list) \\<times> ('a set list \\<times> 'a set \\<times> 'a set list)) option\" where\n  \"find_sub_False [] ns = None\"\n| \"find_sub_False (x # xs) ns = (case find_sub_in x ns False of None \\<Rightarrow>\n    (case find_sub_False xs ns of None \\<Rightarrow> None\n    | Some ((rs, w, ws), (ys, z, zs)) \\<Rightarrow> Some ((x # rs, w, ws), (ys, z, zs)))\n  | Some (ys, z, zs) \\<Rightarrow> Some (([], x, xs), (ys, z, zs)))\""], ["", "lemma find_sub_False_sound: \"find_sub_False xs ns = Some ((rs, w, ws), (ys, z, zs)) \\<Longrightarrow>\n  xs = rs @ w # ws \\<and> ns = ys @ z # zs \\<and> (z \\<subseteq> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_sub_False xs ns = Some ((rs, w, ws), ys, z, zs) \\<Longrightarrow>\n    xs = rs @ w # ws \\<and> ns = ys @ z # zs \\<and> z \\<subseteq> w", "using find_sub_in_sound"], ["proof (prove)\nusing this:\n  find_sub_in ?X ?xs ?b = Some (?ys, ?z, ?zs) \\<Longrightarrow>\n  ?xs = ?ys @ ?z # ?zs \\<and>\n  (?z \\<subseteq> ?X \\<or> ?b \\<and> ?X \\<subseteq> ?z)\n\ngoal (1 subgoal):\n 1. find_sub_False xs ns = Some ((rs, w, ws), ys, z, zs) \\<Longrightarrow>\n    xs = rs @ w # ws \\<and> ns = ys @ z # zs \\<and> z \\<subseteq> w", "by (induction xs ns arbitrary: rs w ws ys z zs rule: find_sub_False.induct)\n     (fastforce split: option.splits)+"], ["", "fun proj_list_3 :: \"'a list \\<Rightarrow> ('b list \\<times> 'b \\<times> 'b list) \\<Rightarrow> ('a list \\<times> 'a \\<times> 'a list)\" where\n  \"proj_list_3 xs (ys, z, zs) = (take (length ys) xs, xs ! (length ys),\n    take (length zs) (drop (length ys + 1) xs))\""], ["", "lemma proj_list_3_same:\n  assumes \"proj_list_3 xs (ys, z, zs) = (ys', z', zs')\"\n    \"length xs = length ys + 1 + length zs\"\n  shows \"xs = ys' @ z' # zs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys' @ z' # zs'", "using assms"], ["proof (prove)\nusing this:\n  proj_list_3 xs (ys, z, zs) = (ys', z', zs')\n  length xs = length ys + 1 + length zs\n\ngoal (1 subgoal):\n 1. xs = ys' @ z' # zs'", "by (auto simp add: id_take_nth_drop)"], ["", "lemma proj_list_3_length:\n  assumes \"proj_list_3 xs (ys, z, zs) = (ys', z', zs')\"\n    \"length xs = length ys + 1 + length zs\"\n  shows \"length ys = length ys'\" \"length zs = length zs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys = length ys' &&& length zs = length zs'", "using assms"], ["proof (prove)\nusing this:\n  proj_list_3 xs (ys, z, zs) = (ys', z', zs')\n  length xs = length ys + 1 + length zs\n\ngoal (1 subgoal):\n 1. length ys = length ys' &&& length zs = length zs'", "by auto"], ["", "fun proj_list_5 :: \"'a list \\<Rightarrow>\n  ('b list \\<times> 'b \\<times> 'b list \\<times> 'b \\<times> 'b list) \\<Rightarrow>\n  ('a list \\<times> 'a \\<times> 'a list \\<times> 'a \\<times> 'a list)\" where\n  \"proj_list_5 xs (ys, w, ws, z, zs) = (take (length ys) xs, xs ! (length ys),\n    take (length ws) (drop (length ys + 1) xs), xs ! (length ys + 1 + length ws),\n    drop (length ys + 1 + length ws + 1) xs)\""], ["", "lemma proj_list_5_same:\n  assumes \"proj_list_5 xs (ys, w, ws, z, zs) = (ys', w', ws', z', zs')\"\n    \"length xs = length ys + 1 + length ws + 1 + length zs\"\n  shows \"xs = ys' @ w' # ws' @ z' # zs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys' @ w' # ws' @ z' # zs'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = ys' @ w' # ws' @ z' # zs'", "have \"xs ! length ys # take (length ws) (drop (Suc (length ys)) xs) = take (Suc (length ws)) (drop (length ys) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! length ys # take (length ws) (drop (Suc (length ys)) xs) =\n    take (Suc (length ws)) (drop (length ys) xs)", "using assms(2)"], ["proof (prove)\nusing this:\n  length xs = length ys + 1 + length ws + 1 + length zs\n\ngoal (1 subgoal):\n 1. xs ! length ys # take (length ws) (drop (Suc (length ys)) xs) =\n    take (Suc (length ws)) (drop (length ys) xs)", "by (simp add: list_eq_iff_nth_eq nth_Cons split: nat.split)"], ["proof (state)\nthis:\n  xs ! length ys # take (length ws) (drop (Suc (length ys)) xs) =\n  take (Suc (length ws)) (drop (length ys) xs)\n\ngoal (1 subgoal):\n 1. xs = ys' @ w' # ws' @ z' # zs'", "moreover"], ["proof (state)\nthis:\n  xs ! length ys # take (length ws) (drop (Suc (length ys)) xs) =\n  take (Suc (length ws)) (drop (length ys) xs)\n\ngoal (1 subgoal):\n 1. xs = ys' @ w' # ws' @ z' # zs'", "have \"take (Suc (length ws)) (drop (length ys) xs) @ drop (Suc (length ys + length ws)) xs =\n      drop (length ys) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc (length ws)) (drop (length ys) xs) @\n    drop (Suc (length ys + length ws)) xs =\n    drop (length ys) xs", "unfolding Suc_eq_plus1 add.assoc[of _ _ 1] add.commute[of _ \"length ws + 1\"]\n      drop_drop[symmetric, of \"length ws + 1\"] append_take_drop_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (length ys) xs = drop (length ys) xs", ".."], ["proof (state)\nthis:\n  take (Suc (length ws)) (drop (length ys) xs) @\n  drop (Suc (length ys + length ws)) xs =\n  drop (length ys) xs\n\ngoal (1 subgoal):\n 1. xs = ys' @ w' # ws' @ z' # zs'", "ultimately"], ["proof (chain)\npicking this:\n  xs ! length ys # take (length ws) (drop (Suc (length ys)) xs) =\n  take (Suc (length ws)) (drop (length ys) xs)\n  take (Suc (length ws)) (drop (length ys) xs) @\n  drop (Suc (length ys + length ws)) xs =\n  drop (length ys) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  xs ! length ys # take (length ws) (drop (Suc (length ys)) xs) =\n  take (Suc (length ws)) (drop (length ys) xs)\n  take (Suc (length ws)) (drop (length ys) xs) @\n  drop (Suc (length ys + length ws)) xs =\n  drop (length ys) xs\n\ngoal (1 subgoal):\n 1. xs = ys' @ w' # ws' @ z' # zs'", "using assms"], ["proof (prove)\nusing this:\n  xs ! length ys # take (length ws) (drop (Suc (length ys)) xs) =\n  take (Suc (length ws)) (drop (length ys) xs)\n  take (Suc (length ws)) (drop (length ys) xs) @\n  drop (Suc (length ys + length ws)) xs =\n  drop (length ys) xs\n  proj_list_5 xs (ys, w, ws, z, zs) = (ys', w', ws', z', zs')\n  length xs = length ys + 1 + length ws + 1 + length zs\n\ngoal (1 subgoal):\n 1. xs = ys' @ w' # ws' @ z' # zs'", "by (auto simp: Cons_nth_drop_Suc append_Cons[symmetric])"], ["proof (state)\nthis:\n  xs = ys' @ w' # ws' @ z' # zs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_list_5_length:\n  assumes \"proj_list_5 xs (ys, w, ws, z, zs) = (ys', w', ws', z', zs')\"\n    \"length xs = length ys + 1 + length ws + 1 + length zs\"\n  shows \"length ys = length ys'\" \"length ws = length ws'\"\n    \"length zs = length zs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys = length ys' &&&\n    length ws = length ws' &&& length zs = length zs'", "using assms"], ["proof (prove)\nusing this:\n  proj_list_5 xs (ys, w, ws, z, zs) = (ys', w', ws', z', zs')\n  length xs = length ys + 1 + length ws + 1 + length zs\n\ngoal (1 subgoal):\n 1. length ys = length ys' &&&\n    length ws = length ws' &&& length zs = length zs'", "by auto"], ["", "fun dominate_True :: \"nat set list \\<Rightarrow> 'a table list \\<Rightarrow>\n  ((nat set list \\<times> nat set \\<times> nat set list \\<times> nat set \\<times> nat set list) \\<times>\n  ('a table list \\<times> 'a table \\<times> 'a table list \\<times> 'a table \\<times> 'a table list)) option\" where\n  \"dominate_True A_pos L_pos = (case find_sub_True A_pos of None \\<Rightarrow> None\n  | Some split \\<Rightarrow> Some (split, proj_list_5 L_pos split))\""], ["", "lemma find_sub_True_proj_list_5_same:\n  assumes \"find_sub_True xs = Some (ys, w, ws, z, zs)\" \"length xs = length xs'\"\n    \"proj_list_5 xs' (ys, w, ws, z, zs) = (ys', w', ws', z', zs')\"\n  shows \"xs' = ys' @ w' # ws' @ z' # zs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = ys' @ w' # ws' @ z' # zs'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs' = ys' @ w' # ws' @ z' # zs'", "have len: \"length xs' = length ys + 1 + length ws + 1 + length zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs' = length ys + 1 + length ws + 1 + length zs", "using find_sub_True_sound[OF assms(1)]"], ["proof (prove)\nusing this:\n  xs = ys @ w # ws @ z # zs \\<and> (z \\<subseteq> w \\<or> w \\<subseteq> z)\n\ngoal (1 subgoal):\n 1. length xs' = length ys + 1 + length ws + 1 + length zs", "by (auto simp add: assms(2)[symmetric])"], ["proof (state)\nthis:\n  length xs' = length ys + 1 + length ws + 1 + length zs\n\ngoal (1 subgoal):\n 1. xs' = ys' @ w' # ws' @ z' # zs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = ys' @ w' # ws' @ z' # zs'", "using proj_list_5_same[OF assms(3) len]"], ["proof (prove)\nusing this:\n  xs' = ys' @ w' # ws' @ z' # zs'\n\ngoal (1 subgoal):\n 1. xs' = ys' @ w' # ws' @ z' # zs'", "."], ["proof (state)\nthis:\n  xs' = ys' @ w' # ws' @ z' # zs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_sub_True_proj_list_5_length:\n  assumes \"find_sub_True xs = Some (ys, w, ws, z, zs)\" \"length xs = length xs'\"\n    \"proj_list_5 xs' (ys, w, ws, z, zs) = (ys', w', ws', z', zs')\"\n  shows \"length ys = length ys'\" \"length ws = length ws'\"\n    \"length zs = length zs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys = length ys' &&&\n    length ws = length ws' &&& length zs = length zs'", "using find_sub_True_sound[OF assms(1)] proj_list_5_length[OF assms(3)] assms(2)"], ["proof (prove)\nusing this:\n  xs = ys @ w # ws @ z # zs \\<and> (z \\<subseteq> w \\<or> w \\<subseteq> z)\n  length xs' = length ys + 1 + length ws + 1 + length zs \\<Longrightarrow>\n  length ys = length ys'\n  length xs' = length ys + 1 + length ws + 1 + length zs \\<Longrightarrow>\n  length ws = length ws'\n  length xs' = length ys + 1 + length ws + 1 + length zs \\<Longrightarrow>\n  length zs = length zs'\n  length xs = length xs'\n\ngoal (1 subgoal):\n 1. length ys = length ys' &&&\n    length ws = length ws' &&& length zs = length zs'", "by auto"], ["", "lemma dominate_True_sound:\n  assumes \"dominate_True A_pos L_pos = Some ((A_zs, A_x, A_xs, A_y, A_ys), (zs, x, xs, y, ys))\"\n    \"length A_pos = length L_pos\"\n  shows \"A_pos = A_zs @ A_x # A_xs @ A_y # A_ys\" \"L_pos = zs @ x # xs @ y # ys\"\n    \"length A_xs = length xs\" \"length A_ys = length ys\" \"length A_zs = length zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A_pos = A_zs @ A_x # A_xs @ A_y # A_ys &&&\n     L_pos = zs @ x # xs @ y # ys) &&&\n    length A_xs = length xs &&&\n    length A_ys = length ys &&& length A_zs = length zs", "using assms find_sub_True_sound find_sub_True_proj_list_5_same find_sub_True_proj_list_5_length"], ["proof (prove)\nusing this:\n  dominate_True A_pos L_pos =\n  Some ((A_zs, A_x, A_xs, A_y, A_ys), zs, x, xs, y, ys)\n  length A_pos = length L_pos\n  find_sub_True ?xs = Some (?ys, ?w, ?ws, ?z, ?zs) \\<Longrightarrow>\n  ?xs = ?ys @ ?w # ?ws @ ?z # ?zs \\<and>\n  (?z \\<subseteq> ?w \\<or> ?w \\<subseteq> ?z)\n  \\<lbrakk>find_sub_True ?xs = Some (?ys, ?w, ?ws, ?z, ?zs);\n   length ?xs = length ?xs';\n   proj_list_5 ?xs' (?ys, ?w, ?ws, ?z, ?zs) =\n   (?ys', ?w', ?ws', ?z', ?zs')\\<rbrakk>\n  \\<Longrightarrow> ?xs' = ?ys' @ ?w' # ?ws' @ ?z' # ?zs'\n  \\<lbrakk>find_sub_True ?xs = Some (?ys, ?w, ?ws, ?z, ?zs);\n   length ?xs = length ?xs';\n   proj_list_5 ?xs' (?ys, ?w, ?ws, ?z, ?zs) =\n   (?ys', ?w', ?ws', ?z', ?zs')\\<rbrakk>\n  \\<Longrightarrow> length ?ys = length ?ys'\n  \\<lbrakk>find_sub_True ?xs = Some (?ys, ?w, ?ws, ?z, ?zs);\n   length ?xs = length ?xs';\n   proj_list_5 ?xs' (?ys, ?w, ?ws, ?z, ?zs) =\n   (?ys', ?w', ?ws', ?z', ?zs')\\<rbrakk>\n  \\<Longrightarrow> length ?ws = length ?ws'\n  \\<lbrakk>find_sub_True ?xs = Some (?ys, ?w, ?ws, ?z, ?zs);\n   length ?xs = length ?xs';\n   proj_list_5 ?xs' (?ys, ?w, ?ws, ?z, ?zs) =\n   (?ys', ?w', ?ws', ?z', ?zs')\\<rbrakk>\n  \\<Longrightarrow> length ?zs = length ?zs'\n\ngoal (1 subgoal):\n 1. (A_pos = A_zs @ A_x # A_xs @ A_y # A_ys &&&\n     L_pos = zs @ x # xs @ y # ys) &&&\n    length A_xs = length xs &&&\n    length A_ys = length ys &&& length A_zs = length zs", "by (auto simp del: proj_list_5.simps split: option.splits) fast+"], ["", "fun dominate_False :: \"nat set list \\<Rightarrow> 'a table list \\<Rightarrow> nat set list \\<Rightarrow> 'a table list \\<Rightarrow>\n  (((nat set list \\<times> nat set \\<times> nat set list) \\<times> nat set list \\<times> nat set \\<times> nat set list) \\<times>\n  (('a table list \\<times> 'a table \\<times> 'a table list) \\<times>\n  'a table list \\<times> 'a table \\<times> 'a table list)) option\" where\n  \"dominate_False A_pos L_pos A_neg L_neg = (case find_sub_False A_pos A_neg of None \\<Rightarrow> None\n  | Some (pos_split, neg_split) \\<Rightarrow>\n    Some ((pos_split, neg_split), (proj_list_3 L_pos pos_split, proj_list_3 L_neg neg_split)))\""], ["", "lemma find_sub_False_proj_list_3_same_left:\n  assumes \"find_sub_False xs ns = Some ((rs, w, ws), (ys, z, zs))\"\n    \"length xs = length xs'\" \"proj_list_3 xs' (rs, w, ws) = (rs', w', ws')\"\n  shows \"xs' = rs' @ w' # ws'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = rs' @ w' # ws'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs' = rs' @ w' # ws'", "have len: \"length xs' = length rs + 1 + length ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs' = length rs + 1 + length ws", "using find_sub_False_sound[OF assms(1)]"], ["proof (prove)\nusing this:\n  xs = rs @ w # ws \\<and> ns = ys @ z # zs \\<and> z \\<subseteq> w\n\ngoal (1 subgoal):\n 1. length xs' = length rs + 1 + length ws", "by (auto simp add: assms(2)[symmetric])"], ["proof (state)\nthis:\n  length xs' = length rs + 1 + length ws\n\ngoal (1 subgoal):\n 1. xs' = rs' @ w' # ws'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = rs' @ w' # ws'", "using proj_list_3_same[OF assms(3) len]"], ["proof (prove)\nusing this:\n  xs' = rs' @ w' # ws'\n\ngoal (1 subgoal):\n 1. xs' = rs' @ w' # ws'", "."], ["proof (state)\nthis:\n  xs' = rs' @ w' # ws'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_sub_False_proj_list_3_length_left:\n  assumes \"find_sub_False xs ns = Some ((rs, w, ws), (ys, z, zs))\"\n    \"length xs = length xs'\" \"proj_list_3 xs' (rs, w, ws) = (rs', w', ws')\"\n  shows \"length rs = length rs'\" \"length ws = length ws'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length rs = length rs' &&& length ws = length ws'", "using find_sub_False_sound[OF assms(1)] proj_list_3_length[OF assms(3)] assms(2)"], ["proof (prove)\nusing this:\n  xs = rs @ w # ws \\<and> ns = ys @ z # zs \\<and> z \\<subseteq> w\n  length xs' = length rs + 1 + length ws \\<Longrightarrow>\n  length rs = length rs'\n  length xs' = length rs + 1 + length ws \\<Longrightarrow>\n  length ws = length ws'\n  length xs = length xs'\n\ngoal (1 subgoal):\n 1. length rs = length rs' &&& length ws = length ws'", "by auto"], ["", "lemma find_sub_False_proj_list_3_same_right:\n  assumes \"find_sub_False xs ns = Some ((rs, w, ws), (ys, z, zs))\"\n    \"length ns = length ns'\" \"proj_list_3 ns' (ys, z, zs) = (ys', z', zs')\"\n  shows \"ns' = ys' @ z' # zs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns' = ys' @ z' # zs'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ns' = ys' @ z' # zs'", "have len: \"length ns' = length ys + 1 + length zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ns' = length ys + 1 + length zs", "using find_sub_False_sound[OF assms(1)]"], ["proof (prove)\nusing this:\n  xs = rs @ w # ws \\<and> ns = ys @ z # zs \\<and> z \\<subseteq> w\n\ngoal (1 subgoal):\n 1. length ns' = length ys + 1 + length zs", "by (auto simp add: assms(2)[symmetric])"], ["proof (state)\nthis:\n  length ns' = length ys + 1 + length zs\n\ngoal (1 subgoal):\n 1. ns' = ys' @ z' # zs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ns' = ys' @ z' # zs'", "using proj_list_3_same[OF assms(3) len]"], ["proof (prove)\nusing this:\n  ns' = ys' @ z' # zs'\n\ngoal (1 subgoal):\n 1. ns' = ys' @ z' # zs'", "."], ["proof (state)\nthis:\n  ns' = ys' @ z' # zs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_sub_False_proj_list_3_length_right:\n  assumes \"find_sub_False xs ns = Some ((rs, w, ws), (ys, z, zs))\"\n    \"length ns = length ns'\" \"proj_list_3 ns' (ys, z, zs) = (ys', z', zs')\"\n  shows \"length ys = length ys'\" \"length zs = length zs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys = length ys' &&& length zs = length zs'", "using find_sub_False_sound[OF assms(1)] proj_list_3_length[OF assms(3)] assms(2)"], ["proof (prove)\nusing this:\n  xs = rs @ w # ws \\<and> ns = ys @ z # zs \\<and> z \\<subseteq> w\n  length ns' = length ys + 1 + length zs \\<Longrightarrow>\n  length ys = length ys'\n  length ns' = length ys + 1 + length zs \\<Longrightarrow>\n  length zs = length zs'\n  length ns = length ns'\n\ngoal (1 subgoal):\n 1. length ys = length ys' &&& length zs = length zs'", "by auto"], ["", "lemma dominate_False_sound:\n  assumes \"dominate_False A_pos L_pos A_neg L_neg =\n    Some (((A_zs, A_x, A_xs), A_ws, A_y, A_ys), ((zs, x, xs), ws, y, ys))\"\n    \"length A_pos = length L_pos\" \"length A_neg = length L_neg\"\n  shows \"A_pos = (A_zs @ A_x # A_xs)\" \"A_neg = A_ws @ A_y # A_ys\"\n    \"L_pos = (zs @ x # xs)\" \"L_neg = ws @ y # ys\"\n    \"length A_ws = length ws\" \"length A_xs = length xs\"\n    \"length A_ys = length ys\" \"length A_zs = length zs\"\n    \"A_y \\<subseteq> A_x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A_pos = A_zs @ A_x # A_xs &&& A_neg = A_ws @ A_y # A_ys) &&&\n     L_pos = zs @ x # xs &&& L_neg = ws @ y # ys) &&&\n    (length A_ws = length ws &&& length A_xs = length xs) &&&\n    length A_ys = length ys &&&\n    length A_zs = length zs &&& A_y \\<subseteq> A_x", "using assms find_sub_False_proj_list_3_same_left find_sub_False_proj_list_3_same_right\n    find_sub_False_proj_list_3_length_left find_sub_False_proj_list_3_length_right\n    find_sub_False_sound"], ["proof (prove)\nusing this:\n  dominate_False A_pos L_pos A_neg L_neg =\n  Some (((A_zs, A_x, A_xs), A_ws, A_y, A_ys), (zs, x, xs), ws, y, ys)\n  length A_pos = length L_pos\n  length A_neg = length L_neg\n  \\<lbrakk>find_sub_False ?xs ?ns = Some ((?rs, ?w, ?ws), ?ys, ?z, ?zs);\n   length ?xs = length ?xs';\n   proj_list_3 ?xs' (?rs, ?w, ?ws) = (?rs', ?w', ?ws')\\<rbrakk>\n  \\<Longrightarrow> ?xs' = ?rs' @ ?w' # ?ws'\n  \\<lbrakk>find_sub_False ?xs ?ns = Some ((?rs, ?w, ?ws), ?ys, ?z, ?zs);\n   length ?ns = length ?ns';\n   proj_list_3 ?ns' (?ys, ?z, ?zs) = (?ys', ?z', ?zs')\\<rbrakk>\n  \\<Longrightarrow> ?ns' = ?ys' @ ?z' # ?zs'\n  \\<lbrakk>find_sub_False ?xs ?ns = Some ((?rs, ?w, ?ws), ?ys, ?z, ?zs);\n   length ?xs = length ?xs';\n   proj_list_3 ?xs' (?rs, ?w, ?ws) = (?rs', ?w', ?ws')\\<rbrakk>\n  \\<Longrightarrow> length ?rs = length ?rs'\n  \\<lbrakk>find_sub_False ?xs ?ns = Some ((?rs, ?w, ?ws), ?ys, ?z, ?zs);\n   length ?xs = length ?xs';\n   proj_list_3 ?xs' (?rs, ?w, ?ws) = (?rs', ?w', ?ws')\\<rbrakk>\n  \\<Longrightarrow> length ?ws = length ?ws'\n  \\<lbrakk>find_sub_False ?xs ?ns = Some ((?rs, ?w, ?ws), ?ys, ?z, ?zs);\n   length ?ns = length ?ns';\n   proj_list_3 ?ns' (?ys, ?z, ?zs) = (?ys', ?z', ?zs')\\<rbrakk>\n  \\<Longrightarrow> length ?ys = length ?ys'\n  \\<lbrakk>find_sub_False ?xs ?ns = Some ((?rs, ?w, ?ws), ?ys, ?z, ?zs);\n   length ?ns = length ?ns';\n   proj_list_3 ?ns' (?ys, ?z, ?zs) = (?ys', ?z', ?zs')\\<rbrakk>\n  \\<Longrightarrow> length ?zs = length ?zs'\n  find_sub_False ?xs ?ns =\n  Some ((?rs, ?w, ?ws), ?ys, ?z, ?zs) \\<Longrightarrow>\n  ?xs = ?rs @ ?w # ?ws \\<and> ?ns = ?ys @ ?z # ?zs \\<and> ?z \\<subseteq> ?w\n\ngoal (1 subgoal):\n 1. ((A_pos = A_zs @ A_x # A_xs &&& A_neg = A_ws @ A_y # A_ys) &&&\n     L_pos = zs @ x # xs &&& L_neg = ws @ y # ys) &&&\n    (length A_ws = length ws &&& length A_xs = length xs) &&&\n    length A_ys = length ys &&&\n    length A_zs = length zs &&& A_y \\<subseteq> A_x", "by (auto simp del: proj_list_3.simps split: option.splits) fast+"], ["", "function mmulti_join :: \"(nat \\<Rightarrow> nat set list \\<Rightarrow> nat set list \\<Rightarrow> 'a table list \\<Rightarrow> 'a table)\" where\n  \"mmulti_join n A_pos A_neg L = (if length A_pos + length A_neg \\<noteq> length L then {} else\n    let L_pos = take (length A_pos) L; L_neg = drop (length A_pos) L in\n    (case dominate_True A_pos L_pos of None \\<Rightarrow>\n      (case dominate_False A_pos L_pos A_neg L_neg of None \\<Rightarrow> mmulti_join' A_pos A_neg L\n      | Some (((A_zs, A_x, A_xs), A_ws, A_y, A_ys), ((zs, x, xs), ws, y, ys)) \\<Rightarrow>\n        mmulti_join n (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n        ((zs @ bin_join n A_x x False A_y y # xs) @ (ws @ ys)))\n    | Some ((A_zs, A_x, A_xs, A_y, A_ys), (zs, x, xs, y, ys)) \\<Rightarrow>\n      mmulti_join n (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n      ((zs @ bin_join n A_x x True A_y y # xs @ ys) @ L_neg)))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>n A_pos A_neg L.\n           x = (n, A_pos, A_neg, L) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>n A_pos A_neg L na A_posa A_nega La.\n       (n, A_pos, A_neg, L) = (na, A_posa, A_nega, La) \\<Longrightarrow>\n       (if length A_pos + length A_neg \\<noteq> length L then {}\n        else let L_pos = take (length A_pos) L;\n                 L_neg = drop (length A_pos) L\n             in case dominate_True A_pos L_pos of\n                None \\<Rightarrow>\n                  case dominate_False A_pos L_pos A_neg L_neg of\n                  None \\<Rightarrow> mmulti_join' A_pos A_neg L\n                  | Some\n                     (((A_zs, A_x, A_xs), A_ws, A_y, A_ys), (zs, xa, xs),\n                      ws, y, ys) \\<Rightarrow>\n                      mmulti_join_sumC\n                       (n, A_zs @ A_x # A_xs, A_ws @ A_ys,\n                        (zs @ bin_join n A_x xa False A_y y # xs) @ ws @ ys)\n                | Some\n                   ((A_zs, A_x, A_xs, A_y, A_ys), zs, xa, xs, y,\n                    ys) \\<Rightarrow>\n                    mmulti_join_sumC\n                     (n, A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys, A_neg,\n                      (zs @ bin_join n A_x xa True A_y y # xs @ ys) @\n                      L_neg)) =\n       (if length A_posa + length A_nega \\<noteq> length La then {}\n        else let L_pos = take (length A_posa) La;\n                 L_neg = drop (length A_posa) La\n             in case dominate_True A_posa L_pos of\n                None \\<Rightarrow>\n                  case dominate_False A_posa L_pos A_nega L_neg of\n                  None \\<Rightarrow> mmulti_join' A_posa A_nega La\n                  | Some\n                     (((A_zs, A_x, A_xs), A_ws, A_y, A_ys), (zs, xa, xs),\n                      ws, y, ys) \\<Rightarrow>\n                      mmulti_join_sumC\n                       (na, A_zs @ A_x # A_xs, A_ws @ A_ys,\n                        (zs @ bin_join na A_x xa False A_y y # xs) @\n                        ws @ ys)\n                | Some\n                   ((A_zs, A_x, A_xs, A_y, A_ys), zs, xa, xs, y,\n                    ys) \\<Rightarrow>\n                    mmulti_join_sumC\n                     (na, A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys, A_nega,\n                      (zs @ bin_join na A_x xa True A_y y # xs @ ys) @\n                      L_neg))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All mmulti_join_dom", "by (relation \"measure (\\<lambda>(n, A_pos, A_neg, L). length A_pos + length A_neg)\")\n    (use find_sub_True_sound find_sub_False_sound in \\<open>fastforce split: option.splits\\<close>)+"], ["", "lemma mmulti_join_link:\n  assumes \"A_pos \\<noteq> []\"\n      and \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L\"\n    shows \"mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "using assms"], ["proof (prove)\nusing this:\n  A_pos \\<noteq> []\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L\n\ngoal (1 subgoal):\n 1. mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "proof (induction A_pos A_neg L rule: mmulti_join.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A_pos A_neg L.\n       \\<lbrakk>\\<And>x xa x2 xb y xc ya xd yb xe yc xf yba xg yaa xh yab xi\n                   yd xj ye xk yf xl yg.\n                   \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq>\n                                   length L;\n                    x = take (length A_pos) L; xa = drop (length A_pos) L;\n                    dominate_True A_pos x = None;\n                    dominate_False A_pos x A_neg xa = Some x2; (xb, y) = x2;\n                    (xc, ya) = xb; (xd, yb) = xc; (xe, yc) = yb;\n                    (xf, yba) = ya; (xg, yaa) = yba; (xh, yab) = y;\n                    (xi, yd) = xh; (xj, ye) = yd; (xk, yf) = yab;\n                    (xl, yg) = yf; xd @ xe # yc \\<noteq> [];\n                    list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n                     ((xd @ xe # yc) @ xf @ yaa)\n                     ((xi @ bin_join n xe xj False xg xl # ye) @\n                      xk @ yg)\\<rbrakk>\n                   \\<Longrightarrow> mmulti_join n (xd @ xe # yc) (xf @ yaa)\n((xi @ bin_join n xe xj False xg xl # ye) @ xk @ yg) =\n                                     mmulti_join' (xd @ xe # yc) (xf @ yaa)\n((xi @ bin_join n xe xj False xg xl # ye) @ xk @ yg);\n        \\<And>x xa x2 xb y xc ya xd yb xe yaa xf yab xg yac xh yc xi yd xj\n           ye.\n           \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq> length L;\n            x = take (length A_pos) L; xa = drop (length A_pos) L;\n            dominate_True A_pos x = Some x2; (xb, y) = x2; (xc, ya) = xb;\n            (xd, yb) = ya; (xe, yaa) = yb; (xf, yab) = yaa; (xg, yac) = y;\n            (xh, yc) = yac; (xi, yd) = yc; (xj, ye) = yd;\n            xc @ (xd \\<union> xf) # xe @ yab \\<noteq> [];\n            list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n             ((xc @ (xd \\<union> xf) # xe @ yab) @ A_neg)\n             ((xg @ bin_join n xd xh True xf xj # xi @ ye) @ xa)\\<rbrakk>\n           \\<Longrightarrow> mmulti_join n\n                              (xc @ (xd \\<union> xf) # xe @ yab) A_neg\n                              ((xg @\n                                bin_join n xd xh True xf xj # xi @ ye) @\n                               xa) =\n                             mmulti_join' (xc @ (xd \\<union> xf) # xe @ yab)\n                              A_neg\n                              ((xg @\n                                bin_join n xd xh True xf xj # xi @ ye) @\n                               xa);\n        A_pos \\<noteq> [];\n        list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n         (A_pos @ A_neg) L\\<rbrakk>\n       \\<Longrightarrow> mmulti_join n A_pos A_neg L =\n                         mmulti_join' A_pos A_neg L", "case (1 n A_pos A_neg L)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq> length L;\n   ?x = take (length A_pos) L; ?xa = drop (length A_pos) L;\n   dominate_True A_pos ?x = None;\n   dominate_False A_pos ?x A_neg ?xa = Some ?x2.0; (?xb, ?y) = ?x2.0;\n   (?xc, ?ya) = ?xb; (?xd, ?yb) = ?xc; (?xe, ?yc) = ?yb; (?xf, ?yba) = ?ya;\n   (?xg, ?yaa) = ?yba; (?xh, ?yab) = ?y; (?xi, ?yd) = ?xh; (?xj, ?ye) = ?yd;\n   (?xk, ?yf) = ?yab; (?xl, ?yg) = ?yf; ?xd @ ?xe # ?yc \\<noteq> [];\n   list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n    ((?xd @ ?xe # ?yc) @ ?xf @ ?yaa)\n    ((?xi @ bin_join n ?xe ?xj False ?xg ?xl # ?ye) @ ?xk @ ?yg)\\<rbrakk>\n  \\<Longrightarrow> mmulti_join n (?xd @ ?xe # ?yc) (?xf @ ?yaa)\n                     ((?xi @ bin_join n ?xe ?xj False ?xg ?xl # ?ye) @\n                      ?xk @ ?yg) =\n                    mmulti_join' (?xd @ ?xe # ?yc) (?xf @ ?yaa)\n                     ((?xi @ bin_join n ?xe ?xj False ?xg ?xl # ?ye) @\n                      ?xk @ ?yg)\n  \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq> length L;\n   ?x = take (length A_pos) L; ?xa = drop (length A_pos) L;\n   dominate_True A_pos ?x = Some ?x2.0; (?xb, ?y) = ?x2.0; (?xc, ?ya) = ?xb;\n   (?xd, ?yb) = ?ya; (?xe, ?yaa) = ?yb; (?xf, ?yab) = ?yaa;\n   (?xg, ?yac) = ?y; (?xh, ?yc) = ?yac; (?xi, ?yd) = ?yc; (?xj, ?ye) = ?yd;\n   ?xc @ (?xd \\<union> ?xf) # ?xe @ ?yab \\<noteq> [];\n   list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n    ((?xc @ (?xd \\<union> ?xf) # ?xe @ ?yab) @ A_neg)\n    ((?xg @ bin_join n ?xd ?xh True ?xf ?xj # ?xi @ ?ye) @ ?xa)\\<rbrakk>\n  \\<Longrightarrow> mmulti_join n (?xc @ (?xd \\<union> ?xf) # ?xe @ ?yab)\n                     A_neg\n                     ((?xg @ bin_join n ?xd ?xh True ?xf ?xj # ?xi @ ?ye) @\n                      ?xa) =\n                    mmulti_join' (?xc @ (?xd \\<union> ?xf) # ?xe @ ?yab)\n                     A_neg\n                     ((?xg @ bin_join n ?xd ?xh True ?xf ?xj # ?xi @ ?ye) @\n                      ?xa)\n  A_pos \\<noteq> []\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L\n\ngoal (1 subgoal):\n 1. \\<And>n A_pos A_neg L.\n       \\<lbrakk>\\<And>x xa x2 xb y xc ya xd yb xe yc xf yba xg yaa xh yab xi\n                   yd xj ye xk yf xl yg.\n                   \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq>\n                                   length L;\n                    x = take (length A_pos) L; xa = drop (length A_pos) L;\n                    dominate_True A_pos x = None;\n                    dominate_False A_pos x A_neg xa = Some x2; (xb, y) = x2;\n                    (xc, ya) = xb; (xd, yb) = xc; (xe, yc) = yb;\n                    (xf, yba) = ya; (xg, yaa) = yba; (xh, yab) = y;\n                    (xi, yd) = xh; (xj, ye) = yd; (xk, yf) = yab;\n                    (xl, yg) = yf; xd @ xe # yc \\<noteq> [];\n                    list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n                     ((xd @ xe # yc) @ xf @ yaa)\n                     ((xi @ bin_join n xe xj False xg xl # ye) @\n                      xk @ yg)\\<rbrakk>\n                   \\<Longrightarrow> mmulti_join n (xd @ xe # yc) (xf @ yaa)\n((xi @ bin_join n xe xj False xg xl # ye) @ xk @ yg) =\n                                     mmulti_join' (xd @ xe # yc) (xf @ yaa)\n((xi @ bin_join n xe xj False xg xl # ye) @ xk @ yg);\n        \\<And>x xa x2 xb y xc ya xd yb xe yaa xf yab xg yac xh yc xi yd xj\n           ye.\n           \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq> length L;\n            x = take (length A_pos) L; xa = drop (length A_pos) L;\n            dominate_True A_pos x = Some x2; (xb, y) = x2; (xc, ya) = xb;\n            (xd, yb) = ya; (xe, yaa) = yb; (xf, yab) = yaa; (xg, yac) = y;\n            (xh, yc) = yac; (xi, yd) = yc; (xj, ye) = yd;\n            xc @ (xd \\<union> xf) # xe @ yab \\<noteq> [];\n            list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n             ((xc @ (xd \\<union> xf) # xe @ yab) @ A_neg)\n             ((xg @ bin_join n xd xh True xf xj # xi @ ye) @ xa)\\<rbrakk>\n           \\<Longrightarrow> mmulti_join n\n                              (xc @ (xd \\<union> xf) # xe @ yab) A_neg\n                              ((xg @\n                                bin_join n xd xh True xf xj # xi @ ye) @\n                               xa) =\n                             mmulti_join' (xc @ (xd \\<union> xf) # xe @ yab)\n                              A_neg\n                              ((xg @\n                                bin_join n xd xh True xf xj # xi @ ye) @\n                               xa);\n        A_pos \\<noteq> [];\n        list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n         (A_pos @ A_neg) L\\<rbrakk>\n       \\<Longrightarrow> mmulti_join n A_pos A_neg L =\n                         mmulti_join' A_pos A_neg L", "define L_pos where \"L_pos = take (length A_pos) L\""], ["proof (state)\nthis:\n  L_pos = take (length A_pos) L\n\ngoal (1 subgoal):\n 1. \\<And>n A_pos A_neg L.\n       \\<lbrakk>\\<And>x xa x2 xb y xc ya xd yb xe yc xf yba xg yaa xh yab xi\n                   yd xj ye xk yf xl yg.\n                   \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq>\n                                   length L;\n                    x = take (length A_pos) L; xa = drop (length A_pos) L;\n                    dominate_True A_pos x = None;\n                    dominate_False A_pos x A_neg xa = Some x2; (xb, y) = x2;\n                    (xc, ya) = xb; (xd, yb) = xc; (xe, yc) = yb;\n                    (xf, yba) = ya; (xg, yaa) = yba; (xh, yab) = y;\n                    (xi, yd) = xh; (xj, ye) = yd; (xk, yf) = yab;\n                    (xl, yg) = yf; xd @ xe # yc \\<noteq> [];\n                    list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n                     ((xd @ xe # yc) @ xf @ yaa)\n                     ((xi @ bin_join n xe xj False xg xl # ye) @\n                      xk @ yg)\\<rbrakk>\n                   \\<Longrightarrow> mmulti_join n (xd @ xe # yc) (xf @ yaa)\n((xi @ bin_join n xe xj False xg xl # ye) @ xk @ yg) =\n                                     mmulti_join' (xd @ xe # yc) (xf @ yaa)\n((xi @ bin_join n xe xj False xg xl # ye) @ xk @ yg);\n        \\<And>x xa x2 xb y xc ya xd yb xe yaa xf yab xg yac xh yc xi yd xj\n           ye.\n           \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq> length L;\n            x = take (length A_pos) L; xa = drop (length A_pos) L;\n            dominate_True A_pos x = Some x2; (xb, y) = x2; (xc, ya) = xb;\n            (xd, yb) = ya; (xe, yaa) = yb; (xf, yab) = yaa; (xg, yac) = y;\n            (xh, yc) = yac; (xi, yd) = yc; (xj, ye) = yd;\n            xc @ (xd \\<union> xf) # xe @ yab \\<noteq> [];\n            list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n             ((xc @ (xd \\<union> xf) # xe @ yab) @ A_neg)\n             ((xg @ bin_join n xd xh True xf xj # xi @ ye) @ xa)\\<rbrakk>\n           \\<Longrightarrow> mmulti_join n\n                              (xc @ (xd \\<union> xf) # xe @ yab) A_neg\n                              ((xg @\n                                bin_join n xd xh True xf xj # xi @ ye) @\n                               xa) =\n                             mmulti_join' (xc @ (xd \\<union> xf) # xe @ yab)\n                              A_neg\n                              ((xg @\n                                bin_join n xd xh True xf xj # xi @ ye) @\n                               xa);\n        A_pos \\<noteq> [];\n        list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n         (A_pos @ A_neg) L\\<rbrakk>\n       \\<Longrightarrow> mmulti_join n A_pos A_neg L =\n                         mmulti_join' A_pos A_neg L", "define L_neg where \"L_neg = drop (length A_pos) L\""], ["proof (state)\nthis:\n  L_neg = drop (length A_pos) L\n\ngoal (1 subgoal):\n 1. \\<And>n A_pos A_neg L.\n       \\<lbrakk>\\<And>x xa x2 xb y xc ya xd yb xe yc xf yba xg yaa xh yab xi\n                   yd xj ye xk yf xl yg.\n                   \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq>\n                                   length L;\n                    x = take (length A_pos) L; xa = drop (length A_pos) L;\n                    dominate_True A_pos x = None;\n                    dominate_False A_pos x A_neg xa = Some x2; (xb, y) = x2;\n                    (xc, ya) = xb; (xd, yb) = xc; (xe, yc) = yb;\n                    (xf, yba) = ya; (xg, yaa) = yba; (xh, yab) = y;\n                    (xi, yd) = xh; (xj, ye) = yd; (xk, yf) = yab;\n                    (xl, yg) = yf; xd @ xe # yc \\<noteq> [];\n                    list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n                     ((xd @ xe # yc) @ xf @ yaa)\n                     ((xi @ bin_join n xe xj False xg xl # ye) @\n                      xk @ yg)\\<rbrakk>\n                   \\<Longrightarrow> mmulti_join n (xd @ xe # yc) (xf @ yaa)\n((xi @ bin_join n xe xj False xg xl # ye) @ xk @ yg) =\n                                     mmulti_join' (xd @ xe # yc) (xf @ yaa)\n((xi @ bin_join n xe xj False xg xl # ye) @ xk @ yg);\n        \\<And>x xa x2 xb y xc ya xd yb xe yaa xf yab xg yac xh yc xi yd xj\n           ye.\n           \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq> length L;\n            x = take (length A_pos) L; xa = drop (length A_pos) L;\n            dominate_True A_pos x = Some x2; (xb, y) = x2; (xc, ya) = xb;\n            (xd, yb) = ya; (xe, yaa) = yb; (xf, yab) = yaa; (xg, yac) = y;\n            (xh, yc) = yac; (xi, yd) = yc; (xj, ye) = yd;\n            xc @ (xd \\<union> xf) # xe @ yab \\<noteq> [];\n            list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n             ((xc @ (xd \\<union> xf) # xe @ yab) @ A_neg)\n             ((xg @ bin_join n xd xh True xf xj # xi @ ye) @ xa)\\<rbrakk>\n           \\<Longrightarrow> mmulti_join n\n                              (xc @ (xd \\<union> xf) # xe @ yab) A_neg\n                              ((xg @\n                                bin_join n xd xh True xf xj # xi @ ye) @\n                               xa) =\n                             mmulti_join' (xc @ (xd \\<union> xf) # xe @ yab)\n                              A_neg\n                              ((xg @\n                                bin_join n xd xh True xf xj # xi @ ye) @\n                               xa);\n        A_pos \\<noteq> [];\n        list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n         (A_pos @ A_neg) L\\<rbrakk>\n       \\<Longrightarrow> mmulti_join n A_pos A_neg L =\n                         mmulti_join' A_pos A_neg L", "have L_def: \"L = L_pos @ L_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L = L_pos @ L_neg", "using L_pos_def L_neg_def"], ["proof (prove)\nusing this:\n  L_pos = take (length A_pos) L\n  L_neg = drop (length A_pos) L\n\ngoal (1 subgoal):\n 1. L = L_pos @ L_neg", "by auto"], ["proof (state)\nthis:\n  L = L_pos @ L_neg\n\ngoal (1 subgoal):\n 1. \\<And>n A_pos A_neg L.\n       \\<lbrakk>\\<And>x xa x2 xb y xc ya xd yb xe yc xf yba xg yaa xh yab xi\n                   yd xj ye xk yf xl yg.\n                   \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq>\n                                   length L;\n                    x = take (length A_pos) L; xa = drop (length A_pos) L;\n                    dominate_True A_pos x = None;\n                    dominate_False A_pos x A_neg xa = Some x2; (xb, y) = x2;\n                    (xc, ya) = xb; (xd, yb) = xc; (xe, yc) = yb;\n                    (xf, yba) = ya; (xg, yaa) = yba; (xh, yab) = y;\n                    (xi, yd) = xh; (xj, ye) = yd; (xk, yf) = yab;\n                    (xl, yg) = yf; xd @ xe # yc \\<noteq> [];\n                    list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n                     ((xd @ xe # yc) @ xf @ yaa)\n                     ((xi @ bin_join n xe xj False xg xl # ye) @\n                      xk @ yg)\\<rbrakk>\n                   \\<Longrightarrow> mmulti_join n (xd @ xe # yc) (xf @ yaa)\n((xi @ bin_join n xe xj False xg xl # ye) @ xk @ yg) =\n                                     mmulti_join' (xd @ xe # yc) (xf @ yaa)\n((xi @ bin_join n xe xj False xg xl # ye) @ xk @ yg);\n        \\<And>x xa x2 xb y xc ya xd yb xe yaa xf yab xg yac xh yc xi yd xj\n           ye.\n           \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq> length L;\n            x = take (length A_pos) L; xa = drop (length A_pos) L;\n            dominate_True A_pos x = Some x2; (xb, y) = x2; (xc, ya) = xb;\n            (xd, yb) = ya; (xe, yaa) = yb; (xf, yab) = yaa; (xg, yac) = y;\n            (xh, yc) = yac; (xi, yd) = yc; (xj, ye) = yd;\n            xc @ (xd \\<union> xf) # xe @ yab \\<noteq> [];\n            list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n             ((xc @ (xd \\<union> xf) # xe @ yab) @ A_neg)\n             ((xg @ bin_join n xd xh True xf xj # xi @ ye) @ xa)\\<rbrakk>\n           \\<Longrightarrow> mmulti_join n\n                              (xc @ (xd \\<union> xf) # xe @ yab) A_neg\n                              ((xg @\n                                bin_join n xd xh True xf xj # xi @ ye) @\n                               xa) =\n                             mmulti_join' (xc @ (xd \\<union> xf) # xe @ yab)\n                              A_neg\n                              ((xg @\n                                bin_join n xd xh True xf xj # xi @ ye) @\n                               xa);\n        A_pos \\<noteq> [];\n        list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n         (A_pos @ A_neg) L\\<rbrakk>\n       \\<Longrightarrow> mmulti_join n A_pos A_neg L =\n                         mmulti_join' A_pos A_neg L", "have lens_match: \"length A_pos = length L_pos\" \"length A_neg = length L_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length A_pos = length L_pos &&& length A_neg = length L_neg", "using L_pos_def L_neg_def 1(4)[unfolded L_def]"], ["proof (prove)\nusing this:\n  L_pos = take (length A_pos) L\n  L_neg = drop (length A_pos) L\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg)\n   (L_pos @ L_neg)\n\ngoal (1 subgoal):\n 1. length A_pos = length L_pos &&& length A_neg = length L_neg", "by (auto dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  length A_pos = length L_pos\n  length A_neg = length L_neg\n\ngoal (1 subgoal):\n 1. \\<And>n A_pos A_neg L.\n       \\<lbrakk>\\<And>x xa x2 xb y xc ya xd yb xe yc xf yba xg yaa xh yab xi\n                   yd xj ye xk yf xl yg.\n                   \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq>\n                                   length L;\n                    x = take (length A_pos) L; xa = drop (length A_pos) L;\n                    dominate_True A_pos x = None;\n                    dominate_False A_pos x A_neg xa = Some x2; (xb, y) = x2;\n                    (xc, ya) = xb; (xd, yb) = xc; (xe, yc) = yb;\n                    (xf, yba) = ya; (xg, yaa) = yba; (xh, yab) = y;\n                    (xi, yd) = xh; (xj, ye) = yd; (xk, yf) = yab;\n                    (xl, yg) = yf; xd @ xe # yc \\<noteq> [];\n                    list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n                     ((xd @ xe # yc) @ xf @ yaa)\n                     ((xi @ bin_join n xe xj False xg xl # ye) @\n                      xk @ yg)\\<rbrakk>\n                   \\<Longrightarrow> mmulti_join n (xd @ xe # yc) (xf @ yaa)\n((xi @ bin_join n xe xj False xg xl # ye) @ xk @ yg) =\n                                     mmulti_join' (xd @ xe # yc) (xf @ yaa)\n((xi @ bin_join n xe xj False xg xl # ye) @ xk @ yg);\n        \\<And>x xa x2 xb y xc ya xd yb xe yaa xf yab xg yac xh yc xi yd xj\n           ye.\n           \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq> length L;\n            x = take (length A_pos) L; xa = drop (length A_pos) L;\n            dominate_True A_pos x = Some x2; (xb, y) = x2; (xc, ya) = xb;\n            (xd, yb) = ya; (xe, yaa) = yb; (xf, yab) = yaa; (xg, yac) = y;\n            (xh, yc) = yac; (xi, yd) = yc; (xj, ye) = yd;\n            xc @ (xd \\<union> xf) # xe @ yab \\<noteq> [];\n            list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n             ((xc @ (xd \\<union> xf) # xe @ yab) @ A_neg)\n             ((xg @ bin_join n xd xh True xf xj # xi @ ye) @ xa)\\<rbrakk>\n           \\<Longrightarrow> mmulti_join n\n                              (xc @ (xd \\<union> xf) # xe @ yab) A_neg\n                              ((xg @\n                                bin_join n xd xh True xf xj # xi @ ye) @\n                               xa) =\n                             mmulti_join' (xc @ (xd \\<union> xf) # xe @ yab)\n                              A_neg\n                              ((xg @\n                                bin_join n xd xh True xf xj # xi @ ye) @\n                               xa);\n        A_pos \\<noteq> [];\n        list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n         (A_pos @ A_neg) L\\<rbrakk>\n       \\<Longrightarrow> mmulti_join n A_pos A_neg L =\n                         mmulti_join' A_pos A_neg L", "then"], ["proof (chain)\npicking this:\n  length A_pos = length L_pos\n  length A_neg = length L_neg", "have lens_sum: \"length A_pos + length A_neg = length L\""], ["proof (prove)\nusing this:\n  length A_pos = length L_pos\n  length A_neg = length L_neg\n\ngoal (1 subgoal):\n 1. length A_pos + length A_neg = length L", "by (auto simp add: L_def)"], ["proof (state)\nthis:\n  length A_pos + length A_neg = length L\n\ngoal (1 subgoal):\n 1. \\<And>n A_pos A_neg L.\n       \\<lbrakk>\\<And>x xa x2 xb y xc ya xd yb xe yc xf yba xg yaa xh yab xi\n                   yd xj ye xk yf xl yg.\n                   \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq>\n                                   length L;\n                    x = take (length A_pos) L; xa = drop (length A_pos) L;\n                    dominate_True A_pos x = None;\n                    dominate_False A_pos x A_neg xa = Some x2; (xb, y) = x2;\n                    (xc, ya) = xb; (xd, yb) = xc; (xe, yc) = yb;\n                    (xf, yba) = ya; (xg, yaa) = yba; (xh, yab) = y;\n                    (xi, yd) = xh; (xj, ye) = yd; (xk, yf) = yab;\n                    (xl, yg) = yf; xd @ xe # yc \\<noteq> [];\n                    list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n                     ((xd @ xe # yc) @ xf @ yaa)\n                     ((xi @ bin_join n xe xj False xg xl # ye) @\n                      xk @ yg)\\<rbrakk>\n                   \\<Longrightarrow> mmulti_join n (xd @ xe # yc) (xf @ yaa)\n((xi @ bin_join n xe xj False xg xl # ye) @ xk @ yg) =\n                                     mmulti_join' (xd @ xe # yc) (xf @ yaa)\n((xi @ bin_join n xe xj False xg xl # ye) @ xk @ yg);\n        \\<And>x xa x2 xb y xc ya xd yb xe yaa xf yab xg yac xh yc xi yd xj\n           ye.\n           \\<lbrakk>\\<not> length A_pos + length A_neg \\<noteq> length L;\n            x = take (length A_pos) L; xa = drop (length A_pos) L;\n            dominate_True A_pos x = Some x2; (xb, y) = x2; (xc, ya) = xb;\n            (xd, yb) = ya; (xe, yaa) = yb; (xf, yab) = yaa; (xg, yac) = y;\n            (xh, yc) = yac; (xi, yd) = yc; (xj, ye) = yd;\n            xc @ (xd \\<union> xf) # xe @ yab \\<noteq> [];\n            list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n             ((xc @ (xd \\<union> xf) # xe @ yab) @ A_neg)\n             ((xg @ bin_join n xd xh True xf xj # xi @ ye) @ xa)\\<rbrakk>\n           \\<Longrightarrow> mmulti_join n\n                              (xc @ (xd \\<union> xf) # xe @ yab) A_neg\n                              ((xg @\n                                bin_join n xd xh True xf xj # xi @ ye) @\n                               xa) =\n                             mmulti_join' (xc @ (xd \\<union> xf) # xe @ yab)\n                              A_neg\n                              ((xg @\n                                bin_join n xd xh True xf xj # xi @ ye) @\n                               xa);\n        A_pos \\<noteq> [];\n        list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n         (A_pos @ A_neg) L\\<rbrakk>\n       \\<Longrightarrow> mmulti_join n A_pos A_neg L =\n                         mmulti_join' A_pos A_neg L", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "proof (cases \"dominate_True A_pos L_pos\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dominate_True A_pos L_pos = None \\<Longrightarrow>\n    mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L\n 2. \\<And>a.\n       dominate_True A_pos L_pos = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "case None"], ["proof (state)\nthis:\n  dominate_True A_pos L_pos = None\n\ngoal (2 subgoals):\n 1. dominate_True A_pos L_pos = None \\<Longrightarrow>\n    mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L\n 2. \\<And>a.\n       dominate_True A_pos L_pos = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "note dom_True = None"], ["proof (state)\nthis:\n  dominate_True A_pos L_pos = None\n\ngoal (2 subgoals):\n 1. dominate_True A_pos L_pos = None \\<Longrightarrow>\n    mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L\n 2. \\<And>a.\n       dominate_True A_pos L_pos = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "proof (cases \"dominate_False A_pos L_pos A_neg L_neg\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dominate_False A_pos L_pos A_neg L_neg = None \\<Longrightarrow>\n    mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L\n 2. \\<And>a.\n       dominate_False A_pos L_pos A_neg L_neg = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "case None"], ["proof (state)\nthis:\n  dominate_False A_pos L_pos A_neg L_neg = None\n\ngoal (2 subgoals):\n 1. dominate_False A_pos L_pos A_neg L_neg = None \\<Longrightarrow>\n    mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L\n 2. \\<And>a.\n       dominate_False A_pos L_pos A_neg L_neg = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "by (subst mmulti_join.simps)\n           (simp del: dominate_True.simps dominate_False.simps mmulti_join.simps\n            mmulti_join'.simps add: Let_def dom_True L_pos_def[symmetric] None\n            L_neg_def[symmetric] lens_sum split: option.splits)"], ["proof (state)\nthis:\n  mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_False A_pos L_pos A_neg L_neg = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_False A_pos L_pos A_neg L_neg = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "case (Some a)"], ["proof (state)\nthis:\n  dominate_False A_pos L_pos A_neg L_neg = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_False A_pos L_pos A_neg L_neg = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "then"], ["proof (chain)\npicking this:\n  dominate_False A_pos L_pos A_neg L_neg = Some a", "obtain A_zs A_x A_xs A_ws A_y A_ys zs x xs ws y ys where\n        dom_False: \"dominate_False A_pos L_pos A_neg L_neg =\n        Some (((A_zs, A_x, A_xs), A_ws, A_y, A_ys), ((zs, x, xs), ws, y, ys))\""], ["proof (prove)\nusing this:\n  dominate_False A_pos L_pos A_neg L_neg = Some a\n\ngoal (1 subgoal):\n 1. (\\<And>A_zs A_x A_xs A_ws A_y A_ys zs x xs ws y ys.\n        dominate_False A_pos L_pos A_neg L_neg =\n        Some\n         (((A_zs, A_x, A_xs), A_ws, A_y, A_ys), (zs, x, xs), ws, y,\n          ys) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases a) auto"], ["proof (state)\nthis:\n  dominate_False A_pos L_pos A_neg L_neg =\n  Some (((A_zs, A_x, A_xs), A_ws, A_y, A_ys), (zs, x, xs), ws, y, ys)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_False A_pos L_pos A_neg L_neg = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "note list_all2 = 1(4)[unfolded L_def dominate_False_sound[OF dom_False lens_match]]"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs) @ A_ws @ A_y # A_ys) ((zs @ x # xs) @ ws @ y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_False A_pos L_pos A_neg L_neg = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "have lens: \"length A_ws = length ws\" \"length A_xs = length xs\"\n        \"length A_ys = length ys\" \"length A_zs = length zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length A_ws = length ws &&& length A_xs = length xs) &&&\n    length A_ys = length ys &&& length A_zs = length zs", "using dominate_False_sound[OF dom_False lens_match]"], ["proof (prove)\nusing this:\n  A_pos = A_zs @ A_x # A_xs\n  A_neg = A_ws @ A_y # A_ys\n  L_pos = zs @ x # xs\n  L_neg = ws @ y # ys\n  length A_ws = length ws\n  length A_xs = length xs\n  length A_ys = length ys\n  length A_zs = length zs\n  A_y \\<subseteq> A_x\n\ngoal (1 subgoal):\n 1. (length A_ws = length ws &&& length A_xs = length xs) &&&\n    length A_ys = length ys &&& length A_zs = length zs", "by auto"], ["proof (state)\nthis:\n  length A_ws = length ws\n  length A_xs = length xs\n  length A_ys = length ys\n  length A_zs = length zs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_False A_pos L_pos A_neg L_neg = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "have sub: \"A_y \\<subseteq> A_x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A_y \\<subseteq> A_x", "using dominate_False_sound[OF dom_False lens_match]"], ["proof (prove)\nusing this:\n  A_pos = A_zs @ A_x # A_xs\n  A_neg = A_ws @ A_y # A_ys\n  L_pos = zs @ x # xs\n  L_neg = ws @ y # ys\n  length A_ws = length ws\n  length A_xs = length xs\n  length A_ys = length ys\n  length A_zs = length zs\n  A_y \\<subseteq> A_x\n\ngoal (1 subgoal):\n 1. A_y \\<subseteq> A_x", "by auto"], ["proof (state)\nthis:\n  A_y \\<subseteq> A_x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_False A_pos L_pos A_neg L_neg = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "have list_all2': \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n        ((A_zs @ A_x # A_xs) @ (A_ws @ A_ys)) ((zs @ join x False y # xs) @ (ws @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ A_x # A_xs) @ A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "using list_all2_opt_False[OF list_all2 lens sub]"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs) @ A_ws @ A_ys)\n   ((zs @ join x False y # xs) @ ws @ ys)\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ A_x # A_xs) @ A_ws @ A_ys)\n     ((zs @ join x False y # xs) @ ws @ ys)", "."], ["proof (state)\nthis:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs) @ A_ws @ A_ys)\n   ((zs @ join x False y # xs) @ ws @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_False A_pos L_pos A_neg L_neg = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "have tabs: \"table n A_x x\" \"table n A_y y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n A_x x &&& table n A_y y", "using list_all2"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs) @ A_ws @ A_y # A_ys) ((zs @ x # xs) @ ws @ y # ys)\n\ngoal (1 subgoal):\n 1. table n A_x x &&& table n A_y y", "by (auto simp add: lens list_all2_append)"], ["proof (state)\nthis:\n  table n A_x x\n  table n A_y y\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_False A_pos L_pos A_neg L_neg = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "have bin_join_conv: \"join x False y = bin_join n A_x x False A_y y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join x False y = bin_join n A_x x False A_y y", "using bin_join_table[OF tabs, symmetric]"], ["proof (prove)\nusing this:\n  join x ?pos y = bin_join n A_x x ?pos A_y y\n\ngoal (1 subgoal):\n 1. join x False y = bin_join n A_x x False A_y y", "."], ["proof (state)\nthis:\n  join x False y = bin_join n A_x x False A_y y\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_False A_pos L_pos A_neg L_neg = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "have mmulti: \"mmulti_join n A_pos A_neg L = mmulti_join n (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n        ((zs @ bin_join n A_x x False A_y y # xs) @ (ws @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join n A_pos A_neg L =\n    mmulti_join n (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n     ((zs @ bin_join n A_x x False A_y y # xs) @ ws @ ys)", "by (subst mmulti_join.simps)\n           (simp del: dominate_True.simps dominate_False.simps mmulti_join.simps\n            add: Let_def dom_True L_pos_def[symmetric] L_neg_def[symmetric] dom_False lens_sum)"], ["proof (state)\nthis:\n  mmulti_join n A_pos A_neg L =\n  mmulti_join n (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n   ((zs @ bin_join n A_x x False A_y y # xs) @ ws @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_False A_pos L_pos A_neg L_neg = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "unfolding mmulti"], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join n (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n     ((zs @ bin_join n A_x x False A_y y # xs) @ ws @ ys) =\n    mmulti_join' A_pos A_neg L", "unfolding L_def dominate_False_sound[OF dom_False lens_match]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join n (A_zs @ A_x # A_xs) (A_ws @ A_ys)\n     ((zs @ bin_join n A_x x False A_y y # xs) @ ws @ ys) =\n    mmulti_join' (A_zs @ A_x # A_xs) (A_ws @ A_y # A_ys)\n     ((zs @ x # xs) @ ws @ y # ys)", "by (rule 1(1)[OF _ L_pos_def L_neg_def dom_True dom_False,\n            OF _ _ _ _ _ _ _ _ _ _ _ _ _ list_all2'[unfolded bin_join_conv],\n            unfolded mmulti_join'_opt_False[OF list_all2 lens sub, symmetric,\n            unfolded bin_join_conv]])\n           (auto simp add: lens_sum)"], ["proof (state)\nthis:\n  mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_True A_pos L_pos = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_True A_pos L_pos = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "case (Some a)"], ["proof (state)\nthis:\n  dominate_True A_pos L_pos = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_True A_pos L_pos = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "then"], ["proof (chain)\npicking this:\n  dominate_True A_pos L_pos = Some a", "obtain A_zs A_x A_xs A_y A_ys zs x xs y ys where dom_True: \"dominate_True A_pos L_pos =\n      Some ((A_zs, A_x, A_xs, A_y, A_ys), (zs, x, xs, y, ys))\""], ["proof (prove)\nusing this:\n  dominate_True A_pos L_pos = Some a\n\ngoal (1 subgoal):\n 1. (\\<And>A_zs A_x A_xs A_y A_ys zs x xs y ys.\n        dominate_True A_pos L_pos =\n        Some\n         ((A_zs, A_x, A_xs, A_y, A_ys), zs, x, xs, y, ys) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases a) auto"], ["proof (state)\nthis:\n  dominate_True A_pos L_pos =\n  Some ((A_zs, A_x, A_xs, A_y, A_ys), zs, x, xs, y, ys)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_True A_pos L_pos = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "note list_all2 = 1(4)[unfolded L_def dominate_True_sound[OF dom_True lens_match(1)]]"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs @ A_y # A_ys) @ A_neg)\n   ((zs @ x # xs @ y # ys) @ L_neg)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_True A_pos L_pos = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "have lens: \"length A_xs = length xs\" \"length A_ys = length ys\" \"length A_zs = length zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length A_xs = length xs &&&\n    length A_ys = length ys &&& length A_zs = length zs", "using dominate_True_sound[OF dom_True lens_match(1)]"], ["proof (prove)\nusing this:\n  A_pos = A_zs @ A_x # A_xs @ A_y # A_ys\n  L_pos = zs @ x # xs @ y # ys\n  length A_xs = length xs\n  length A_ys = length ys\n  length A_zs = length zs\n\ngoal (1 subgoal):\n 1. length A_xs = length xs &&&\n    length A_ys = length ys &&& length A_zs = length zs", "by auto"], ["proof (state)\nthis:\n  length A_xs = length xs\n  length A_ys = length ys\n  length A_zs = length zs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_True A_pos L_pos = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "have list_all2': \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n      ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg) ((zs @ join x True y # xs @ ys) @ L_neg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg)\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "using list_all2_opt_True[OF list_all2 lens]"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg)\n   ((zs @ join x True y # xs @ ys) @ L_neg)\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n     ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg)\n     ((zs @ join x True y # xs @ ys) @ L_neg)", "."], ["proof (state)\nthis:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) @ A_neg)\n   ((zs @ join x True y # xs @ ys) @ L_neg)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_True A_pos L_pos = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "have tabs: \"table n A_x x\" \"table n A_y y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n A_x x &&& table n A_y y", "using list_all2"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A)\n   ((A_zs @ A_x # A_xs @ A_y # A_ys) @ A_neg)\n   ((zs @ x # xs @ y # ys) @ L_neg)\n\ngoal (1 subgoal):\n 1. table n A_x x &&& table n A_y y", "by (auto simp add: lens list_all2_append)"], ["proof (state)\nthis:\n  table n A_x x\n  table n A_y y\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_True A_pos L_pos = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "have bin_join_conv: \"join x True y = bin_join n A_x x True A_y y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join x True y = bin_join n A_x x True A_y y", "using bin_join_table[OF tabs, symmetric]"], ["proof (prove)\nusing this:\n  join x ?pos y = bin_join n A_x x ?pos A_y y\n\ngoal (1 subgoal):\n 1. join x True y = bin_join n A_x x True A_y y", "."], ["proof (state)\nthis:\n  join x True y = bin_join n A_x x True A_y y\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_True A_pos L_pos = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "have mmulti: \"mmulti_join n A_pos A_neg L = mmulti_join n (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys)\n      A_neg ((zs @ bin_join n A_x x True A_y y # xs @ ys) @ L_neg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join n A_pos A_neg L =\n    mmulti_join n (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n     ((zs @ bin_join n A_x x True A_y y # xs @ ys) @ L_neg)", "by (subst mmulti_join.simps)\n         (simp del: dominate_True.simps dominate_False.simps mmulti_join.simps\n          add: Let_def dom_True L_pos_def[symmetric] L_neg_def lens_sum)"], ["proof (state)\nthis:\n  mmulti_join n A_pos A_neg L =\n  mmulti_join n (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n   ((zs @ bin_join n A_x x True A_y y # xs @ ys) @ L_neg)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       dominate_True A_pos L_pos = Some a \\<Longrightarrow>\n       mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L", "unfolding mmulti"], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join n (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n     ((zs @ bin_join n A_x x True A_y y # xs @ ys) @ L_neg) =\n    mmulti_join' A_pos A_neg L", "unfolding L_def dominate_True_sound[OF dom_True lens_match(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mmulti_join n (A_zs @ (A_x \\<union> A_y) # A_xs @ A_ys) A_neg\n     ((zs @ bin_join n A_x x True A_y y # xs @ ys) @ L_neg) =\n    mmulti_join' (A_zs @ A_x # A_xs @ A_y # A_ys) A_neg\n     ((zs @ x # xs @ y # ys) @ L_neg)", "by (rule 1(2)[OF _ L_pos_def L_neg_def dom_True,\n          OF _ _ _ _ _ _ _ _ _ _ _ list_all2'[unfolded bin_join_conv],\n          unfolded mmulti_join'_opt_True[OF list_all2 lens, symmetric,\n          unfolded bin_join_conv]])\n         (auto simp add: lens_sum)"], ["proof (state)\nthis:\n  mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mmulti_join n A_pos A_neg L = mmulti_join' A_pos A_neg L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mmulti_join_correct:\n  assumes \"A_pos \\<noteq> []\"\n      and \"list_all2 (\\<lambda>A X. table n A X \\<and> wf_set n A) (A_pos @ A_neg) L\"\n  shows \"z \\<in> mmulti_join n A_pos A_neg L \\<longleftrightarrow> wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n    list_all2 (\\<lambda>A X. restrict A z \\<in> X) A_pos (take (length A_pos) L) \\<and>\n    list_all2 (\\<lambda>A X. restrict A z \\<notin> X) A_neg (drop (length A_pos) L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join n A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "unfolding mmulti_join_link[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "using mmulti_join'_correct[OF assms]"], ["proof (prove)\nusing this:\n  (?z \\<in> mmulti_join' A_pos A_neg L) =\n  (wf_tuple n (\\<Union>A\\<in>set A_pos. A) ?z \\<and>\n   list_all2 (\\<lambda>A. (\\<in>) (restrict A ?z)) A_pos\n    (take (length A_pos) L) \\<and>\n   list_all2 (\\<lambda>A. (\\<notin>) (restrict A ?z)) A_neg\n    (drop (length A_pos) L))\n\ngoal (1 subgoal):\n 1. (z \\<in> mmulti_join' A_pos A_neg L) =\n    (wf_tuple n (\\<Union>A\\<in>set A_pos. A) z \\<and>\n     list_all2 (\\<lambda>A. (\\<in>) (restrict A z)) A_pos\n      (take (length A_pos) L) \\<and>\n     list_all2 (\\<lambda>A. (\\<notin>) (restrict A z)) A_neg\n      (drop (length A_pos) L))", "."], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}