{"file_name": "/home/qj213/afp-2021-10-22/thys/Hidden_Markov_Models/HMM_Implementation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Hidden_Markov_Models", "problem_names": ["lemma (in HMM3) forward_ix_drop_one:\n  \"forward_ix (o # os) s t (n + 1) = forward_ix os s t n\"", "lemma (in HMM4) forward_ix_forward:\n  \"forward_ix os s t 0 = forward s t os\"", "lemma (in HMM4) forward_code [code]:\n  \"forward s t os = fst (run_state (forward_ix\\<^sub>m' (IArray os) s t 0) Mapping.empty)\"", "theorem (in HMM4) likelihood_compute:\n  \"likelihood_compute s os = Some x \\<longleftrightarrow> s \\<in> \\<S> \\<and> x = likelihood s os\"", "lemma viterbi_ix_drop_one:\n  \"viterbi_ix (o # os) s t (n + 1) = viterbi_ix os s t n\"", "lemma viterbi_ix_viterbi:\n  \"viterbi_ix os s t 0 = viterbi s t os\"", "lemma viterbi_code [code]:\n  \"viterbi s t os = fst (run_state (viterbi_ix\\<^sub>m' (IArray os) s t 0) Mapping.empty)\"", "lemma pmf_of_alist_support_aux_1:\n  assumes \"\\<forall> (_, p) \\<in> set \\<mu>. p \\<ge> 0\"\n  shows \"(0 :: real) \\<le> (case map_of \\<mu> x of None \\<Rightarrow> 0 | Some p \\<Rightarrow> p)\"", "lemma pmf_of_alist_support_aux_2:\n  assumes \"\\<forall> (_, p) \\<in> set \\<mu>. p \\<ge> 0\"\n    and \"sum_list (map snd \\<mu>) = 1\"\n    and \"distinct (map fst \\<mu>)\"\n  shows \"\\<integral>\\<^sup>+ x. ennreal (case map_of \\<mu> x of None \\<Rightarrow> 0 | Some p \\<Rightarrow> p) \\<partial>count_space UNIV = 1\"", "lemma pmf_of_alist_support:\n  assumes \"\\<forall> (_, p) \\<in> set \\<mu>. p \\<ge> 0\"\n    and \"sum_list (map snd \\<mu>) = 1\"\n    and \"distinct (map fst \\<mu>)\"\n  shows \"set_pmf (pmf_of_alist \\<mu>) \\<subseteq> fst ` set \\<mu>\"", "lemma pmf_of_alist_aux:\n  assumes \"(s, \\<mu>) \\<in> set K\"\n  shows\n    \"pmf (pmf_of_alist \\<mu>) t = (case map_of \\<mu> t of\n      None \\<Rightarrow> 0\n    | Some p \\<Rightarrow> p)\"", "lemma unique: \"\\<mu> = \\<mu>'\" if \"(s, \\<mu>) \\<in> set K\" \"(s, \\<mu>') \\<in> set K\"", "lemma (in -) map_of_NoneD:\n  \"x \\<notin> fst ` set M\" if \"map_of M x = None\"", "lemma K'_code [code_post]:\n  \"pmf (K' s) t = (case K1 s of\n      None \\<Rightarrow> (if t = hd S then 1 else 0)\n    | Some \\<mu> \\<Rightarrow> case \\<mu> t of\n        None \\<Rightarrow> 0\n      | Some p \\<Rightarrow> p\n  )\"", "lemmas O_code = O.K'_code O.K1_def", "lemmas K_code = K.K'_code K.K1_def"], "translations": [["", "lemma (in HMM3) forward_ix_drop_one:\n  \"forward_ix (o # os) s t (n + 1) = forward_ix os s t n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forward_ix (o # os) s t (n + 1) = forward_ix os s t n", "by (induction \"length os - n\" arbitrary: s n; simp add: forward_ix_def)"], ["", "lemma (in HMM4) forward_ix_forward:\n  \"forward_ix os s t 0 = forward s t os\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forward_ix os s t 0 = forward s t os", "unfolding forward_ix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. forward_ix_rec (IArray os) s t 0 = forward s t os", "proof (induction os arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. forward_ix_rec (IArray []) s t 0 = forward s t []\n 2. \\<And>a os s.\n       (\\<And>s.\n           forward_ix_rec (IArray os) s t 0 =\n           forward s t os) \\<Longrightarrow>\n       forward_ix_rec (IArray (a # os)) s t 0 = forward s t (a # os)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. forward_ix_rec (IArray []) s t 0 = forward s t []\n 2. \\<And>a os s.\n       (\\<And>s.\n           forward_ix_rec (IArray os) s t 0 =\n           forward s t os) \\<Longrightarrow>\n       forward_ix_rec (IArray (a # os)) s t 0 = forward s t (a # os)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. forward_ix_rec (IArray []) s t 0 = forward s t []", "by simp"], ["proof (state)\nthis:\n  forward_ix_rec (IArray []) s t 0 = forward s t []\n\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       (\\<And>s.\n           forward_ix_rec (IArray os) s t 0 =\n           forward s t os) \\<Longrightarrow>\n       forward_ix_rec (IArray (a # os)) s t 0 = forward s t (a # os)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       (\\<And>s.\n           forward_ix_rec (IArray os) s t 0 =\n           forward s t os) \\<Longrightarrow>\n       forward_ix_rec (IArray (a # os)) s t 0 = forward s t (a # os)", "case (Cons o os)"], ["proof (state)\nthis:\n  forward_ix_rec (IArray os) ?s2 t 0 = forward ?s2 t os\n\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       (\\<And>s.\n           forward_ix_rec (IArray os) s t 0 =\n           forward s t os) \\<Longrightarrow>\n       forward_ix_rec (IArray (a # os)) s t 0 = forward s t (a # os)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. forward_ix_rec (IArray (o # os)) s t 0 = forward s t (o # os)", "using forward_ix_drop_one[unfolded forward_ix_def] states_distinct"], ["proof (prove)\nusing this:\n  forward_ix_rec (IArray (?o # ?os)) ?s ?t (?n + 1) =\n  forward_ix_rec (IArray ?os) ?s ?t ?n\n  distinct state_list\n\ngoal (1 subgoal):\n 1. forward_ix_rec (IArray (o # os)) s t 0 = forward s t (o # os)", "by (subst forward.simps, subst forward_ix_rec.simps)\n       (simp add: Cons.IH state_list_\\<S> sum_list_distinct_conv_sum_set\n             del: forward_ix_rec.simps forward.simps\n       )"], ["proof (state)\nthis:\n  forward_ix_rec (IArray (o # os)) s t 0 = forward s t (o # os)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Instructs the code generator to use this equation instead to execute \\<open>forward\\<close>.\n  Uses the memoized version of \\<open>forward_ix\\<close>.\n\\<close>"], ["", "lemma (in HMM4) forward_code [code]:\n  \"forward s t os = fst (run_state (forward_ix\\<^sub>m' (IArray os) s t 0) Mapping.empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forward s t os =\n    fst (run_state (forward_ix\\<^sub>m' (IArray os) s t 0) Mapping.empty)", "by (simp only:\n      forward_ix_def forward_ix\\<^sub>m.memoized_correct forward_ix_forward[symmetric]\n      states_distinct\n     )"], ["", "theorem (in HMM4) likelihood_compute:\n  \"likelihood_compute s os = Some x \\<longleftrightarrow> s \\<in> \\<S> \\<and> x = likelihood s os\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (likelihood_compute s os = Some x) =\n    (s \\<in> \\<S> \\<and> x = likelihood s os)", "unfolding likelihood_compute_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if s \\<in> set state_list\n      then Some (\\<Sum>t\\<leftarrow>state_list. forward s t os) else None) =\n     Some x) =\n    (s \\<in> \\<S> \\<and> x = likelihood s os)", "by (auto simp: states_distinct state_list_\\<S> sum_list_distinct_conv_sum_set likelihood_forward)"], ["", "subsection \\<open>The Viterbi Algorithm\\<close>"], ["", "context HMM3_defs\nbegin"], ["", "context\n  fixes os :: \"'t iarray\"\nbegin"], ["", "text \\<open>\n  Alternative definition using indices into the list of states.\n  The list of states is implemented as an immutable array for better performance.\n\\<close>"], ["", "function viterbi_ix_rec where\n  \"viterbi_ix_rec s t_end n = (if n \\<ge> IArray.length os then ([], indicator {t_end} s) else\n  fst (\n    argmax snd (map\n      (\\<lambda>t. let (xs, v) = viterbi_ix_rec t t_end (n + 1) in\n        (t # xs, ennreal (pmf (\\<O> t) (os !! n) * pmf (\\<K> s) t) * v))\n    state_list)))\n  \""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>s t_end n.\n           x = (s, t_end, n) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>s t_end n sa t_enda na.\n       (s, t_end, n) = (sa, t_enda, na) \\<Longrightarrow>\n       (if IArray.length os \\<le> n then ([], indicator {t_end} s)\n        else fst (argmax snd\n                   (map (\\<lambda>t.\n                            let (xs, v) =\n                                  viterbi_ix_rec_sumC (t, t_end, n + 1)\n                            in (t # xs,\n                                ennreal\n                                 (pmf (\\<O> t) (os !! n) * pmf (\\<K> s) t) *\n                                v))\n                     state_list))) =\n       (if IArray.length os \\<le> na then ([], indicator {t_enda} sa)\n        else fst (argmax snd\n                   (map (\\<lambda>t.\n                            let (xs, v) =\n                                  viterbi_ix_rec_sumC (t, t_enda, na + 1)\n                            in (t # xs,\n                                ennreal\n                                 (pmf (\\<O> t) (os !! na) *\n                                  pmf (\\<K> sa) t) *\n                                v))\n                     state_list)))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All viterbi_ix_rec_dom", "by (relation \"Wellfounded.measure (\\<lambda>(_,_,n). IArray.length os - n)\") auto"], ["", "text \\<open>Memoization\\<close>"], ["", "memoize_fun viterbi_ix\\<^sub>m: viterbi_ix_rec\n  with_memory dp_consistency_mapping"], ["", "monadifies (state) viterbi_ix_rec.simps[unfolded Let_def]"], ["", "memoize_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. dp_consistency.consistentDP\n     (\\<lambda>k.\n         State_Monad.get \\<bind>\n         (\\<lambda>m. State_Monad.return (Mapping.lookup m k)))\n     (\\<lambda>_. True) (\\<lambda>(a, b, c). viterbi_ix_rec a b c)\n     (\\<lambda>(a, b, c). viterbi_ix\\<^sub>m' a b c)", "by memoize_prover"], ["", "text \\<open>The main theorems generated by memoization.\\<close>"], ["", "context\n  includes state_monad_syntax\nbegin"], ["", "thm viterbi_ix\\<^sub>m'.simps viterbi_ix\\<^sub>m_def"], ["", "thm viterbi_ix\\<^sub>m.memoized_correct"], ["", "end"], ["", "end"], ["", "(* Fixed IArray *)"], ["", "definition\n  \"viterbi_ix os = viterbi_ix_rec (IArray os)\""], ["", "end"], ["", "(* HMM3 Defs *)"], ["", "context HMM3\nbegin"], ["", "lemma viterbi_ix_drop_one:\n  \"viterbi_ix (o # os) s t (n + 1) = viterbi_ix os s t n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. viterbi_ix (o # os) s t (n + 1) = viterbi_ix os s t n", "by (induction \"length os - n\" arbitrary: s n; simp add: viterbi_ix_def)"], ["", "lemma viterbi_ix_viterbi:\n  \"viterbi_ix os s t 0 = viterbi s t os\""], ["proof (prove)\ngoal (1 subgoal):\n 1. viterbi_ix os s t 0 = viterbi s t os", "unfolding viterbi_ix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. viterbi_ix_rec (IArray os) s t 0 = viterbi s t os", "proof (induction os arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. viterbi_ix_rec (IArray []) s t 0 = viterbi s t []\n 2. \\<And>a os s.\n       (\\<And>s.\n           viterbi_ix_rec (IArray os) s t 0 =\n           viterbi s t os) \\<Longrightarrow>\n       viterbi_ix_rec (IArray (a # os)) s t 0 = viterbi s t (a # os)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. viterbi_ix_rec (IArray []) s t 0 = viterbi s t []\n 2. \\<And>a os s.\n       (\\<And>s.\n           viterbi_ix_rec (IArray os) s t 0 =\n           viterbi s t os) \\<Longrightarrow>\n       viterbi_ix_rec (IArray (a # os)) s t 0 = viterbi s t (a # os)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. viterbi_ix_rec (IArray []) s t 0 = viterbi s t []", "by simp"], ["proof (state)\nthis:\n  viterbi_ix_rec (IArray []) s t 0 = viterbi s t []\n\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       (\\<And>s.\n           viterbi_ix_rec (IArray os) s t 0 =\n           viterbi s t os) \\<Longrightarrow>\n       viterbi_ix_rec (IArray (a # os)) s t 0 = viterbi s t (a # os)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       (\\<And>s.\n           viterbi_ix_rec (IArray os) s t 0 =\n           viterbi s t os) \\<Longrightarrow>\n       viterbi_ix_rec (IArray (a # os)) s t 0 = viterbi s t (a # os)", "case (Cons o os)"], ["proof (state)\nthis:\n  viterbi_ix_rec (IArray os) ?s3 t 0 = viterbi ?s3 t os\n\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       (\\<And>s.\n           viterbi_ix_rec (IArray os) s t 0 =\n           viterbi s t os) \\<Longrightarrow>\n       viterbi_ix_rec (IArray (a # os)) s t 0 = viterbi s t (a # os)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. viterbi_ix_rec (IArray (o # os)) s t 0 = viterbi s t (o # os)", "using viterbi_ix_drop_one[unfolded viterbi_ix_def]"], ["proof (prove)\nusing this:\n  viterbi_ix_rec (IArray (?o # ?os)) ?s ?t (?n + 1) =\n  viterbi_ix_rec (IArray ?os) ?s ?t ?n\n\ngoal (1 subgoal):\n 1. viterbi_ix_rec (IArray (o # os)) s t 0 = viterbi s t (o # os)", "by (subst viterbi.simps, subst viterbi_ix_rec.simps)\n       (simp add: Cons.IH del: viterbi_ix_rec.simps viterbi.simps)"], ["proof (state)\nthis:\n  viterbi_ix_rec (IArray (o # os)) s t 0 = viterbi s t (o # os)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma viterbi_code [code]:\n  \"viterbi s t os = fst (run_state (viterbi_ix\\<^sub>m' (IArray os) s t 0) Mapping.empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. viterbi s t os =\n    fst (run_state (viterbi_ix\\<^sub>m' (IArray os) s t 0) Mapping.empty)", "by (simp only: viterbi_ix_def viterbi_ix\\<^sub>m.memoized_correct viterbi_ix_viterbi[symmetric])"], ["", "end"], ["", "(* Hidden Markov Model 3 *)"], ["", "subsection \\<open>Misc\\<close>"], ["", "lemma pmf_of_alist_support_aux_1:\n  assumes \"\\<forall> (_, p) \\<in> set \\<mu>. p \\<ge> 0\"\n  shows \"(0 :: real) \\<le> (case map_of \\<mu> x of None \\<Rightarrow> 0 | Some p \\<Rightarrow> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (case map_of \\<mu> x of None \\<Rightarrow> 0\n             | Some p \\<Rightarrow> p)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p\n\ngoal (1 subgoal):\n 1. 0 \\<le> (case map_of \\<mu> x of None \\<Rightarrow> 0\n             | Some p \\<Rightarrow> p)", "by (auto split: option.split dest: map_of_SomeD)"], ["", "lemma pmf_of_alist_support_aux_2:\n  assumes \"\\<forall> (_, p) \\<in> set \\<mu>. p \\<ge> 0\"\n    and \"sum_list (map snd \\<mu>) = 1\"\n    and \"distinct (map fst \\<mu>)\"\n  shows \"\\<integral>\\<^sup>+ x. ennreal (case map_of \\<mu> x of None \\<Rightarrow> 0 | Some p \\<Rightarrow> p) \\<partial>count_space UNIV = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (case map_of \\<mu> x of None \\<Rightarrow> 0\n                             | Some p \\<Rightarrow> p)\n                       \\<partial>count_space UNIV =\n    1", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p\n  sum_list (map snd \\<mu>) = 1\n  distinct (map fst \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (case map_of \\<mu> x of None \\<Rightarrow> 0\n                             | Some p \\<Rightarrow> p)\n                       \\<partial>count_space UNIV =\n    1", "apply (subst nn_integral_count_space)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {a \\<in> UNIV.\n                        0 < ennreal\n                             (case map_of \\<mu> a of None \\<Rightarrow> 0\n                              | Some p \\<Rightarrow> p)}\n 2. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>a | a \\<in> UNIV \\<and>\n                                 0 < ennreal\n(case map_of \\<mu> a of None \\<Rightarrow> 0 | Some p \\<Rightarrow> p).\n                         ennreal\n                          (case map_of \\<mu> a of None \\<Rightarrow> 0\n                           | Some p \\<Rightarrow> p)) =\n                      1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {a \\<in> UNIV.\n                        0 < ennreal\n                             (case map_of \\<mu> a of None \\<Rightarrow> 0\n                              | Some p \\<Rightarrow> p)}", "by (rule finite_subset[where B = \"fst ` set \\<mu>\"];\n        force split: option.split_asm simp: image_iff dest: map_of_SomeD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>a | a \\<in> UNIV \\<and>\n                                 0 < ennreal\n(case map_of \\<mu> a of None \\<Rightarrow> 0 | Some p \\<Rightarrow> p).\n                         ennreal\n                          (case map_of \\<mu> a of None \\<Rightarrow> 0\n                           | Some p \\<Rightarrow> p)) =\n                      1", "apply (subst sum.mono_neutral_left[where T = \"fst ` set \\<mu>\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> finite (fst ` set \\<mu>)\n 2. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> {a \\<in> UNIV.\n                       0 < ennreal\n                            (case map_of \\<mu> a of None \\<Rightarrow> 0\n                             | Some p \\<Rightarrow> p)}\n                      \\<subseteq> fst ` set \\<mu>\n 3. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>fst ` set \\<mu> -\n                                     {a \\<in> UNIV.\n0 < ennreal\n     (case map_of \\<mu> a of None \\<Rightarrow> 0\n      | Some p \\<Rightarrow> p)}.\n                         ennreal\n                          (case map_of \\<mu> i of None \\<Rightarrow> 0\n                           | Some p \\<Rightarrow> p) =\n                         0\n 4. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>a\\<in>fst ` set \\<mu>.\n                         ennreal\n                          (case map_of \\<mu> a of None \\<Rightarrow> 0\n                           | Some p \\<Rightarrow> p)) =\n                      1", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> {a \\<in> UNIV.\n                       0 < ennreal\n                            (case map_of \\<mu> a of None \\<Rightarrow> 0\n                             | Some p \\<Rightarrow> p)}\n                      \\<subseteq> fst ` set \\<mu>\n 2. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>fst ` set \\<mu> -\n                                     {a \\<in> UNIV.\n0 < ennreal\n     (case map_of \\<mu> a of None \\<Rightarrow> 0\n      | Some p \\<Rightarrow> p)}.\n                         ennreal\n                          (case map_of \\<mu> i of None \\<Rightarrow> 0\n                           | Some p \\<Rightarrow> p) =\n                         0\n 3. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>a\\<in>fst ` set \\<mu>.\n                         ennreal\n                          (case map_of \\<mu> a of None \\<Rightarrow> 0\n                           | Some p \\<Rightarrow> p)) =\n                      1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> {a \\<in> UNIV.\n                       0 < ennreal\n                            (case map_of \\<mu> a of None \\<Rightarrow> 0\n                             | Some p \\<Rightarrow> p)}\n                      \\<subseteq> fst ` set \\<mu>", "by (smt ennreal_less_zero_iff map_of_eq_None_iff mem_Collect_eq option.case(1) subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>fst ` set \\<mu> -\n                                     {a \\<in> UNIV.\n0 < ennreal\n     (case map_of \\<mu> a of None \\<Rightarrow> 0\n      | Some p \\<Rightarrow> p)}.\n                         ennreal\n                          (case map_of \\<mu> i of None \\<Rightarrow> 0\n                           | Some p \\<Rightarrow> p) =\n                         0\n 2. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>a\\<in>fst ` set \\<mu>.\n                         ennreal\n                          (case map_of \\<mu> a of None \\<Rightarrow> 0\n                           | Some p \\<Rightarrow> p)) =\n                      1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>fst ` set \\<mu> -\n                                     {a \\<in> UNIV.\n0 < ennreal\n     (case map_of \\<mu> a of None \\<Rightarrow> 0\n      | Some p \\<Rightarrow> p)}.\n                         ennreal\n                          (case map_of \\<mu> i of None \\<Rightarrow> 0\n                           | Some p \\<Rightarrow> p) =\n                         0", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p;\n     sum_list (map snd \\<mu>) = 1; distinct (map fst \\<mu>)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>a\\<in>fst ` set \\<mu>.\n                         ennreal\n                          (case map_of \\<mu> a of None \\<Rightarrow> 0\n                           | Some p \\<Rightarrow> p)) =\n                      1", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>fst ` set \\<mu>.\n       ennreal\n        (case map_of \\<mu> a of None \\<Rightarrow> 0\n         | Some p \\<Rightarrow> p)) =\n    1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>fst ` set \\<mu>.\n       ennreal\n        (case map_of \\<mu> a of None \\<Rightarrow> 0\n         | Some p \\<Rightarrow> p)) =\n    1", "have \"(\\<Sum>x = 0..<length \\<mu>. snd (\\<mu> ! x))\n      = sum (\\<lambda> x. case map_of \\<mu> x of None \\<Rightarrow> 0 | Some v \\<Rightarrow> v) (fst ` set \\<mu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 0..<length \\<mu>. snd (\\<mu> ! x)) =\n    (\\<Sum>x\\<in>fst ` set \\<mu>.\n       case map_of \\<mu> x of None \\<Rightarrow> 0 | Some v \\<Rightarrow> v)", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>fst ` set \\<mu>.\n       case map_of \\<mu> x of None \\<Rightarrow> 0\n       | Some v \\<Rightarrow> v) =\n    (\\<Sum>x = 0..<length \\<mu>. snd (\\<mu> ! x))", "apply (rule sum.reindex_cong[where l = \"\\<lambda> i. fst (\\<mu> ! i)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on (\\<lambda>i. fst (\\<mu> ! i)) {0..<length \\<mu>}\n 2. fst ` set \\<mu> = (\\<lambda>i. fst (\\<mu> ! i)) ` {0..<length \\<mu>}\n 3. \\<And>x.\n       x \\<in> {0..<length \\<mu>} \\<Longrightarrow>\n       (case map_of \\<mu> (fst (\\<mu> ! x)) of None \\<Rightarrow> 0\n        | Some v \\<Rightarrow> v) =\n       snd (\\<mu> ! x)", "apply (auto split: option.split)"], ["proof (prove)\ngoal (4 subgoals):\n 1. inj_on (\\<lambda>i. fst (\\<mu> ! i)) {0..<length \\<mu>}\n 2. \\<And>a b.\n       (a, b) \\<in> set \\<mu> \\<Longrightarrow>\n       a \\<in> (\\<lambda>i. fst (\\<mu> ! i)) ` {0..<length \\<mu>}\n 3. \\<And>x.\n       \\<lbrakk>x < length \\<mu>;\n        map_of \\<mu> (fst (\\<mu> ! x)) = None\\<rbrakk>\n       \\<Longrightarrow> snd (\\<mu> ! x) = 0\n 4. \\<And>x x2.\n       \\<lbrakk>x < length \\<mu>;\n        map_of \\<mu> (fst (\\<mu> ! x)) = Some x2\\<rbrakk>\n       \\<Longrightarrow> x2 = snd (\\<mu> ! x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>i. fst (\\<mu> ! i)) {0..<length \\<mu>}", "using prems(3)"], ["proof (prove)\nusing this:\n  distinct (map fst \\<mu>)\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>i. fst (\\<mu> ! i)) {0..<length \\<mu>}", "by (intro inj_onI, auto simp: distinct_conv_nth)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set \\<mu> \\<Longrightarrow>\n       a \\<in> (\\<lambda>i. fst (\\<mu> ! i)) ` {0..<length \\<mu>}\n 2. \\<And>x.\n       \\<lbrakk>x < length \\<mu>;\n        map_of \\<mu> (fst (\\<mu> ! x)) = None\\<rbrakk>\n       \\<Longrightarrow> snd (\\<mu> ! x) = 0\n 3. \\<And>x x2.\n       \\<lbrakk>x < length \\<mu>;\n        map_of \\<mu> (fst (\\<mu> ! x)) = Some x2\\<rbrakk>\n       \\<Longrightarrow> x2 = snd (\\<mu> ! x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a_, b_) \\<in> set \\<mu> \\<Longrightarrow>\n    a_ \\<in> (\\<lambda>i. fst (\\<mu> ! i)) ` {0..<length \\<mu>}", "by (auto simp: in_set_conv_nth rev_image_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x < length \\<mu>;\n        map_of \\<mu> (fst (\\<mu> ! x)) = None\\<rbrakk>\n       \\<Longrightarrow> snd (\\<mu> ! x) = 0\n 2. \\<And>x x2.\n       \\<lbrakk>x < length \\<mu>;\n        map_of \\<mu> (fst (\\<mu> ! x)) = Some x2\\<rbrakk>\n       \\<Longrightarrow> x2 = snd (\\<mu> ! x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ < length \\<mu>;\n     map_of \\<mu> (fst (\\<mu> ! x_)) = None\\<rbrakk>\n    \\<Longrightarrow> snd (\\<mu> ! x_) = 0", "by (simp add: map_of_eq_None_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       \\<lbrakk>x < length \\<mu>;\n        map_of \\<mu> (fst (\\<mu> ! x)) = Some x2\\<rbrakk>\n       \\<Longrightarrow> x2 = snd (\\<mu> ! x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ < length \\<mu>;\n     map_of \\<mu> (fst (\\<mu> ! x_)) = Some x2_\\<rbrakk>\n    \\<Longrightarrow> x2_ = snd (\\<mu> ! x_)", "using map_of_eq_Some_iff[OF prems(3)]"], ["proof (prove)\nusing this:\n  (map_of \\<mu> ?x = Some ?y) = ((?x, ?y) \\<in> set \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ < length \\<mu>;\n     map_of \\<mu> (fst (\\<mu> ! x_)) = Some x2_\\<rbrakk>\n    \\<Longrightarrow> x2_ = snd (\\<mu> ! x_)", "by (metis fst_conv nth_mem option.inject prod_eqI snd_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>x = 0..<length \\<mu>. snd (\\<mu> ! x)) =\n  (\\<Sum>x\\<in>fst ` set \\<mu>.\n     case map_of \\<mu> x of None \\<Rightarrow> 0 | Some v \\<Rightarrow> v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>fst ` set \\<mu>.\n       ennreal\n        (case map_of \\<mu> a of None \\<Rightarrow> 0\n         | Some p \\<Rightarrow> p)) =\n    1", "with prems(2)"], ["proof (chain)\npicking this:\n  sum_list (map snd \\<mu>) = 1\n  (\\<Sum>x = 0..<length \\<mu>. snd (\\<mu> ! x)) =\n  (\\<Sum>x\\<in>fst ` set \\<mu>.\n     case map_of \\<mu> x of None \\<Rightarrow> 0 | Some v \\<Rightarrow> v)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map snd \\<mu>) = 1\n  (\\<Sum>x = 0..<length \\<mu>. snd (\\<mu> ! x)) =\n  (\\<Sum>x\\<in>fst ` set \\<mu>.\n     case map_of \\<mu> x of None \\<Rightarrow> 0 | Some v \\<Rightarrow> v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>fst ` set \\<mu>.\n       ennreal\n        (case map_of \\<mu> a of None \\<Rightarrow> 0\n         | Some p \\<Rightarrow> p)) =\n    1", "by (smt pmf_of_alist_support_aux_1[OF assms(1)] atLeastLessThan_iff ennreal_1\n          length_map nth_map sum.cong sum_ennreal sum_list_sum_nth\n          )"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>fst ` set \\<mu>.\n     ennreal\n      (case map_of \\<mu> a of None \\<Rightarrow> 0\n       | Some p \\<Rightarrow> p)) =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pmf_of_alist_support:\n  assumes \"\\<forall> (_, p) \\<in> set \\<mu>. p \\<ge> 0\"\n    and \"sum_list (map snd \\<mu>) = 1\"\n    and \"distinct (map fst \\<mu>)\"\n  shows \"set_pmf (pmf_of_alist \\<mu>) \\<subseteq> fst ` set \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf (pmf_of_alist \\<mu>) \\<subseteq> fst ` set \\<mu>", "unfolding pmf_of_alist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf\n     (embed_pmf\n       (\\<lambda>x.\n           case map_of \\<mu> x of None \\<Rightarrow> 0\n           | Some p \\<Rightarrow> p))\n    \\<subseteq> fst ` set \\<mu>", "apply (subst set_embed_pmf)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       0 \\<le> (case map_of \\<mu> x of None \\<Rightarrow> 0\n                | Some p \\<Rightarrow> p)\n 2. \\<integral>\\<^sup>+ x. ennreal\n                            (case map_of \\<mu> x of None \\<Rightarrow> 0\n                             | Some p \\<Rightarrow> p)\n                       \\<partial>count_space UNIV =\n    1\n 3. {x. (case map_of \\<mu> x of None \\<Rightarrow> 0\n         | Some p \\<Rightarrow> p) \\<noteq>\n        0}\n    \\<subseteq> fst ` set \\<mu>", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (case map_of \\<mu> x of None \\<Rightarrow> 0\n             | Some p \\<Rightarrow> p)", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p\n\ngoal (1 subgoal):\n 1. 0 \\<le> (case map_of \\<mu> x of None \\<Rightarrow> 0\n             | Some p \\<Rightarrow> p)", "by (auto split: option.split dest: map_of_SomeD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (case map_of \\<mu> x of None \\<Rightarrow> 0\n                             | Some p \\<Rightarrow> p)\n                       \\<partial>count_space UNIV =\n    1\n 2. {x. (case map_of \\<mu> x of None \\<Rightarrow> 0\n         | Some p \\<Rightarrow> p) \\<noteq>\n        0}\n    \\<subseteq> fst ` set \\<mu>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (case map_of \\<mu> x of None \\<Rightarrow> 0\n                             | Some p \\<Rightarrow> p)\n                       \\<partial>count_space UNIV =\n    1", "using pmf_of_alist_support_aux_2[OF assms]"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (case map_of \\<mu> x of None \\<Rightarrow> 0\n                           | Some p \\<Rightarrow> p)\n                     \\<partial>count_space UNIV =\n  1\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (case map_of \\<mu> x of None \\<Rightarrow> 0\n                             | Some p \\<Rightarrow> p)\n                       \\<partial>count_space UNIV =\n    1", "."], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. (case map_of \\<mu> x of None \\<Rightarrow> 0\n         | Some p \\<Rightarrow> p) \\<noteq>\n        0}\n    \\<subseteq> fst ` set \\<mu>", "apply (force split: option.split_asm simp: image_iff dest: map_of_SomeD)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Defining a Markov kernel from an association list.\\<close>"], ["", "locale Closed_Kernel_From =\n  fixes K :: \"('s \\<times> ('t \\<times> real) list) list\"\n    and S :: \"'t list\"\n  assumes wellformed: \"S \\<noteq> []\"\n      and closed: \"\\<forall> (s, \\<mu>) \\<in> set K. \\<forall> (t, _) \\<in> set \\<mu>. t \\<in> set S\"\n      and is_pmf:\n        \"\\<forall> (_, \\<mu>) \\<in> set K. \\<forall> (_, p) \\<in> set \\<mu>. p \\<ge> 0\"\n        \"\\<forall> (_, \\<mu>) \\<in> set K. distinct (map fst \\<mu>)\"\n        \"\\<forall> (s, \\<mu>) \\<in> set K. sum_list (map snd \\<mu>) = 1\"\n      and is_unique:\n        \"distinct (map fst K)\"\nbegin"], ["", "definition\n  \"K' s \\<equiv> case map_of (map (\\<lambda> (s, \\<mu>). (s, PMF_Impl.pmf_of_alist \\<mu>)) K) s of\n  None \\<Rightarrow> return_pmf (hd S) |\n  Some s \\<Rightarrow> s\""], ["", "sublocale Closed_Kernel K' \"set S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Closed_Kernel K' (set S)", "using wellformed closed is_pmf pmf_of_alist_support"], ["proof (prove)\nusing this:\n  S \\<noteq> []\n  \\<forall>(s, \\<mu>)\\<in>set K.\n     \\<forall>(t, uu_)\\<in>set \\<mu>. t \\<in> set S\n  \\<forall>(uu_, \\<mu>)\\<in>set K.\n     \\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p\n  \\<forall>(uu_, \\<mu>)\\<in>set K. distinct (map fst \\<mu>)\n  \\<forall>(s, \\<mu>)\\<in>set K. sum_list (map snd \\<mu>) = 1\n  \\<lbrakk>\\<forall>(uu_, p)\\<in>set ?\\<mu>. 0 \\<le> p;\n   sum_list (map snd ?\\<mu>) = 1; distinct (map fst ?\\<mu>)\\<rbrakk>\n  \\<Longrightarrow> set_pmf (pmf_of_alist ?\\<mu>)\n                    \\<subseteq> fst ` set ?\\<mu>\n\ngoal (1 subgoal):\n 1. Closed_Kernel K' (set S)", "unfolding K'_def"], ["proof (prove)\nusing this:\n  S \\<noteq> []\n  \\<forall>(s, \\<mu>)\\<in>set K.\n     \\<forall>(t, uu_)\\<in>set \\<mu>. t \\<in> set S\n  \\<forall>(uu_, \\<mu>)\\<in>set K.\n     \\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p\n  \\<forall>(uu_, \\<mu>)\\<in>set K. distinct (map fst \\<mu>)\n  \\<forall>(s, \\<mu>)\\<in>set K. sum_list (map snd \\<mu>) = 1\n  \\<lbrakk>\\<forall>(uu_, p)\\<in>set ?\\<mu>. 0 \\<le> p;\n   sum_list (map snd ?\\<mu>) = 1; distinct (map fst ?\\<mu>)\\<rbrakk>\n  \\<Longrightarrow> set_pmf (pmf_of_alist ?\\<mu>)\n                    \\<subseteq> fst ` set ?\\<mu>\n\ngoal (1 subgoal):\n 1. Closed_Kernel\n     (\\<lambda>s.\n         case map_of (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K)\n               s of\n         None \\<Rightarrow> return_pmf (hd S) | Some s \\<Rightarrow> s)\n     (set S)", "by - (standard; fastforce split: option.split_asm dest: map_of_SomeD)"], ["", "definition [code]:\n  \"K1 = map_of (map (\\<lambda> (s, \\<mu>). (s, map_of \\<mu>)) K)\""], ["", "lemma pmf_of_alist_aux:\n  assumes \"(s, \\<mu>) \\<in> set K\"\n  shows\n    \"pmf (pmf_of_alist \\<mu>) t = (case map_of \\<mu> t of\n      None \\<Rightarrow> 0\n    | Some p \\<Rightarrow> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (pmf_of_alist \\<mu>) t =\n    (case map_of \\<mu> t of None \\<Rightarrow> 0 | Some p \\<Rightarrow> p)", "using assms is_pmf"], ["proof (prove)\nusing this:\n  (s, \\<mu>) \\<in> set K\n  \\<forall>(uu_, \\<mu>)\\<in>set K.\n     \\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p\n  \\<forall>(uu_, \\<mu>)\\<in>set K. distinct (map fst \\<mu>)\n  \\<forall>(s, \\<mu>)\\<in>set K. sum_list (map snd \\<mu>) = 1\n\ngoal (1 subgoal):\n 1. pmf (pmf_of_alist \\<mu>) t =\n    (case map_of \\<mu> t of None \\<Rightarrow> 0 | Some p \\<Rightarrow> p)", "unfolding pmf_of_alist_def"], ["proof (prove)\nusing this:\n  (s, \\<mu>) \\<in> set K\n  \\<forall>(uu_, \\<mu>)\\<in>set K.\n     \\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p\n  \\<forall>(uu_, \\<mu>)\\<in>set K. distinct (map fst \\<mu>)\n  \\<forall>(s, \\<mu>)\\<in>set K. sum_list (map snd \\<mu>) = 1\n\ngoal (1 subgoal):\n 1. pmf (embed_pmf\n          (\\<lambda>x.\n              case map_of \\<mu> x of None \\<Rightarrow> 0\n              | Some p \\<Rightarrow> p))\n     t =\n    (case map_of \\<mu> t of None \\<Rightarrow> 0 | Some p \\<Rightarrow> p)", "by (intro pmf_embed_pmf pmf_of_alist_support_aux_2) \n     (auto 4 3 split: option.split dest: map_of_SomeD)"], ["", "lemma unique: \"\\<mu> = \\<mu>'\" if \"(s, \\<mu>) \\<in> set K\" \"(s, \\<mu>') \\<in> set K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> = \\<mu>'", "using that is_unique"], ["proof (prove)\nusing this:\n  (s, \\<mu>) \\<in> set K\n  (s, \\<mu>') \\<in> set K\n  distinct (map fst K)\n\ngoal (1 subgoal):\n 1. \\<mu> = \\<mu>'", "by (smt Pair_inject distinct_conv_nth fst_conv in_set_conv_nth length_map nth_map)"], ["", "lemma (in -) map_of_NoneD:\n  \"x \\<notin> fst ` set M\" if \"map_of M x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set M", "using that"], ["proof (prove)\nusing this:\n  map_of M x = None\n\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set M", "by (auto dest: weak_map_of_SomeI)"], ["", "lemma K'_code [code_post]:\n  \"pmf (K' s) t = (case K1 s of\n      None \\<Rightarrow> (if t = hd S then 1 else 0)\n    | Some \\<mu> \\<Rightarrow> case \\<mu> t of\n        None \\<Rightarrow> 0\n      | Some p \\<Rightarrow> p\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (K' s) t =\n    (case K1 s of None \\<Rightarrow> if t = hd S then 1 else 0\n     | Some \\<mu> \\<Rightarrow>\n         case \\<mu> t of None \\<Rightarrow> 0 | Some p \\<Rightarrow> p)", "unfolding K'_def K1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (case map_of (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K)\n               s of\n         None \\<Rightarrow> return_pmf (hd S) | Some s \\<Rightarrow> s)\n     t =\n    (case map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s of\n     None \\<Rightarrow> if t = hd S then 1 else 0\n     | Some \\<mu> \\<Rightarrow>\n         case \\<mu> t of None \\<Rightarrow> 0 | Some p \\<Rightarrow> p)", "apply (clarsimp split: option.split, safe)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                None;\n        x2 (hd S) = None; x2 (hd S) = None;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s = Some x2;\n        t = hd S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x2 x2a.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                None;\n        x2 (hd S) = None; x2 (hd S) = Some x2a;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s = Some x2;\n        t = hd S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x2 x2a.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                None;\n        x2 (hd S) = None; x2 t = Some x2a;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s = Some x2;\n        t \\<noteq> hd S\\<rbrakk>\n       \\<Longrightarrow> x2a = 0\n 4. \\<And>x2 x2a.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                None;\n        x2 (hd S) = Some x2a; x2 (hd S) = None;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s = Some x2;\n        t = hd S\\<rbrakk>\n       \\<Longrightarrow> x2a = 1\n 5. \\<And>x2 x2a x2b.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                None;\n        x2 (hd S) = Some x2a; x2 (hd S) = Some x2b;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s = Some x2;\n        t = hd S\\<rbrakk>\n       \\<Longrightarrow> x2a = 1\n 6. \\<And>x2 x2a x2b.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                None;\n        x2 (hd S) = Some x2a; x2 t = Some x2b;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s = Some x2;\n        t \\<noteq> hd S\\<rbrakk>\n       \\<Longrightarrow> x2b = 0\n 7. \\<And>x2.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                Some x2;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s = None;\n        t = hd S\\<rbrakk>\n       \\<Longrightarrow> pmf x2 (hd S) = 1\n 8. \\<And>x2.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                Some x2;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s = None;\n        t \\<noteq> hd S\\<rbrakk>\n       \\<Longrightarrow> pmf x2 t = 0\n 9. \\<And>x2 x2a.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                Some x2;\n        x2a (hd S) = None; x2a (hd S) = None;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s =\n        Some x2a;\n        t = hd S\\<rbrakk>\n       \\<Longrightarrow> pmf x2 (hd S) = 0\n 10. \\<And>x2 x2a.\n        \\<lbrakk>map_of\n                  (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                 Some x2;\n         x2a (hd S) = None; x2a t = None;\n         map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s =\n         Some x2a;\n         t \\<noteq> hd S\\<rbrakk>\n        \\<Longrightarrow> pmf x2 t = 0\nA total of 16 subgoals...", "apply (drule map_of_SomeD, drule map_of_NoneD, force)+"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x2 x2a.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                Some x2;\n        x2a (hd S) = None; x2a (hd S) = None;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s =\n        Some x2a;\n        t = hd S\\<rbrakk>\n       \\<Longrightarrow> pmf x2 (hd S) = 0\n 2. \\<And>x2 x2a.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                Some x2;\n        x2a (hd S) = None; x2a t = None;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s =\n        Some x2a;\n        t \\<noteq> hd S\\<rbrakk>\n       \\<Longrightarrow> pmf x2 t = 0\n 3. \\<And>x2 x2a x2b.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                Some x2;\n        x2a (hd S) = None; x2a (hd S) = Some x2b;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s =\n        Some x2a;\n        t = hd S\\<rbrakk>\n       \\<Longrightarrow> pmf x2 (hd S) = 0\n 4. \\<And>x2 x2a x2b.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                Some x2;\n        x2a (hd S) = None; x2a t = Some x2b;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s =\n        Some x2a;\n        t \\<noteq> hd S\\<rbrakk>\n       \\<Longrightarrow> pmf x2 t = x2b\n 5. \\<And>x2 x2a x2b.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                Some x2;\n        x2a (hd S) = Some x2b; x2a (hd S) = None;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s =\n        Some x2a;\n        t = hd S\\<rbrakk>\n       \\<Longrightarrow> pmf x2 (hd S) = x2b\n 6. \\<And>x2 x2a x2b.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                Some x2;\n        x2a (hd S) = Some x2b; x2a t = None;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s =\n        Some x2a;\n        t \\<noteq> hd S\\<rbrakk>\n       \\<Longrightarrow> pmf x2 t = 0\n 7. \\<And>x2 x2a x2b x2c.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                Some x2;\n        x2a (hd S) = Some x2b; x2a (hd S) = Some x2c;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s =\n        Some x2a;\n        t = hd S\\<rbrakk>\n       \\<Longrightarrow> pmf x2 (hd S) = x2b\n 8. \\<And>x2 x2a x2b x2c.\n       \\<lbrakk>map_of\n                 (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) K) s =\n                Some x2;\n        x2a (hd S) = Some x2b; x2a t = Some x2c;\n        map_of (map (\\<lambda>(s, \\<mu>). (s, map_of \\<mu>)) K) s =\n        Some x2a;\n        t \\<noteq> hd S\\<rbrakk>\n       \\<Longrightarrow> pmf x2 t = x2c", "apply (fastforce dest: unique map_of_SomeD simp: pmf_of_alist_aux)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Executing Concrete HMMs\\<close>"], ["", "locale Concrete_HMM_defs =\n  fixes \\<K> :: \"('s \\<times> ('s \\<times> real) list) list\"\n    and \\<O> :: \"('s \\<times> ('t \\<times> real) list) list\"\n    and \\<O>\\<^sub>s :: \"'t list\"\n    and \\<K>\\<^sub>s :: \"'s list\"\nbegin"], ["", "definition\n  \"\\<K>' s \\<equiv> case map_of (map (\\<lambda> (s, \\<mu>). (s, PMF_Impl.pmf_of_alist \\<mu>)) \\<K>) s of\n    None \\<Rightarrow> return_pmf (hd \\<K>\\<^sub>s) |\n    Some s \\<Rightarrow> s\""], ["", "definition\n  \"\\<O>' s \\<equiv> case map_of (map (\\<lambda> (s, \\<mu>). (s, PMF_Impl.pmf_of_alist \\<mu>)) \\<O>) s of\n    None \\<Rightarrow> return_pmf (hd \\<O>\\<^sub>s) |\n    Some s \\<Rightarrow> s\""], ["", "end"], ["", "locale Concrete_HMM = Concrete_HMM_defs +\n  assumes observations_wellformed': \"\\<O>\\<^sub>s \\<noteq> []\"\n      and observations_closed': \"\\<forall> (s, \\<mu>) \\<in> set \\<O>. \\<forall> (t, _) \\<in> set \\<mu>. t \\<in> set \\<O>\\<^sub>s\"\n      and observations_form_pmf':\n        \"\\<forall> (_, \\<mu>) \\<in> set \\<O>. \\<forall> (_, p) \\<in> set \\<mu>. p \\<ge> 0\"\n        \"\\<forall> (_, \\<mu>) \\<in> set \\<O>. distinct (map fst \\<mu>)\"\n        \"\\<forall> (s, \\<mu>) \\<in> set \\<O>. sum_list (map snd \\<mu>) = 1\"\n      and observations_unique:\n        \"distinct (map fst \\<O>)\"\n  assumes states_wellformed: \"\\<K>\\<^sub>s \\<noteq> []\"\n      and states_closed: \"\\<forall> (s, \\<mu>) \\<in> set \\<K>. \\<forall> (t, _) \\<in> set \\<mu>. t \\<in> set \\<K>\\<^sub>s\"\n      and states_form_pmf:\n        \"\\<forall> (_, \\<mu>) \\<in> set \\<K>. \\<forall> (_, p) \\<in> set \\<mu>. p \\<ge> 0\"\n        \"\\<forall> (_, \\<mu>) \\<in> set \\<K>. distinct (map fst \\<mu>)\"\n        \"\\<forall> (s, \\<mu>) \\<in> set \\<K>. sum_list (map snd \\<mu>) = 1\"\n      and states_unique:\n        \"distinct (map fst \\<K>)\" \"distinct \\<K>\\<^sub>s\"\nbegin"], ["", "interpretation O: Closed_Kernel_From \\<O> \\<O>\\<^sub>s\n  rewrites \"O.K' = \\<O>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Closed_Kernel_From \\<O> \\<O>\\<^sub>s &&&\n    Closed_Kernel_From.K' \\<O> \\<O>\\<^sub>s = \\<O>'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Closed_Kernel_From \\<O> \\<O>\\<^sub>s\n 2. Closed_Kernel_From.K' \\<O> \\<O>\\<^sub>s = \\<O>'", "show \\<open>Closed_Kernel_From \\<O> \\<O>\\<^sub>s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Closed_Kernel_From \\<O> \\<O>\\<^sub>s", "using observations_wellformed' observations_closed' observations_form_pmf' observations_unique"], ["proof (prove)\nusing this:\n  \\<O>\\<^sub>s \\<noteq> []\n  \\<forall>(s, \\<mu>)\\<in>set \\<O>.\n     \\<forall>(t, uu_)\\<in>set \\<mu>. t \\<in> set \\<O>\\<^sub>s\n  \\<forall>(uu_, \\<mu>)\\<in>set \\<O>.\n     \\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p\n  \\<forall>(uu_, \\<mu>)\\<in>set \\<O>. distinct (map fst \\<mu>)\n  \\<forall>(s, \\<mu>)\\<in>set \\<O>. sum_list (map snd \\<mu>) = 1\n  distinct (map fst \\<O>)\n\ngoal (1 subgoal):\n 1. Closed_Kernel_From \\<O> \\<O>\\<^sub>s", "by unfold_locales auto"], ["proof (state)\nthis:\n  Closed_Kernel_From \\<O> \\<O>\\<^sub>s\n\ngoal (1 subgoal):\n 1. Closed_Kernel_From.K' \\<O> \\<O>\\<^sub>s = \\<O>'", "show \\<open>Closed_Kernel_From.K' \\<O> \\<O>\\<^sub>s = \\<O>'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Closed_Kernel_From.K' \\<O> \\<O>\\<^sub>s = \\<O>'", "unfolding Closed_Kernel_From.K'_def[OF \\<open>Closed_Kernel_From \\<O> \\<O>\\<^sub>s\\<close>] \\<O>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        case map_of\n              (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) \\<O>) s of\n        None \\<Rightarrow> return_pmf (hd \\<O>\\<^sub>s)\n        | Some s \\<Rightarrow> s) =\n    (\\<lambda>s.\n        case map_of\n              (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) \\<O>) s of\n        None \\<Rightarrow> return_pmf (hd \\<O>\\<^sub>s)\n        | Some s \\<Rightarrow> s)", "by auto"], ["proof (state)\nthis:\n  Closed_Kernel_From.K' \\<O> \\<O>\\<^sub>s = \\<O>'\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation K: Closed_Kernel_From \\<K> \\<K>\\<^sub>s\n  rewrites \"K.K' = \\<K>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Closed_Kernel_From \\<K> \\<K>\\<^sub>s &&&\n    Closed_Kernel_From.K' \\<K> \\<K>\\<^sub>s = \\<K>'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Closed_Kernel_From \\<K> \\<K>\\<^sub>s\n 2. Closed_Kernel_From.K' \\<K> \\<K>\\<^sub>s = \\<K>'", "show \\<open>Closed_Kernel_From \\<K> \\<K>\\<^sub>s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Closed_Kernel_From \\<K> \\<K>\\<^sub>s", "using states_wellformed states_closed states_form_pmf states_unique"], ["proof (prove)\nusing this:\n  \\<K>\\<^sub>s \\<noteq> []\n  \\<forall>(s, \\<mu>)\\<in>set \\<K>.\n     \\<forall>(t, uu_)\\<in>set \\<mu>. t \\<in> set \\<K>\\<^sub>s\n  \\<forall>(uu_, \\<mu>)\\<in>set \\<K>.\n     \\<forall>(uu_, p)\\<in>set \\<mu>. 0 \\<le> p\n  \\<forall>(uu_, \\<mu>)\\<in>set \\<K>. distinct (map fst \\<mu>)\n  \\<forall>(s, \\<mu>)\\<in>set \\<K>. sum_list (map snd \\<mu>) = 1\n  distinct (map fst \\<K>)\n  distinct \\<K>\\<^sub>s\n\ngoal (1 subgoal):\n 1. Closed_Kernel_From \\<K> \\<K>\\<^sub>s", "by unfold_locales auto"], ["proof (state)\nthis:\n  Closed_Kernel_From \\<K> \\<K>\\<^sub>s\n\ngoal (1 subgoal):\n 1. Closed_Kernel_From.K' \\<K> \\<K>\\<^sub>s = \\<K>'", "show \\<open>Closed_Kernel_From.K' \\<K> \\<K>\\<^sub>s = \\<K>'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Closed_Kernel_From.K' \\<K> \\<K>\\<^sub>s = \\<K>'", "unfolding Closed_Kernel_From.K'_def[OF \\<open>Closed_Kernel_From \\<K> \\<K>\\<^sub>s\\<close>] \\<K>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        case map_of\n              (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) \\<K>) s of\n        None \\<Rightarrow> return_pmf (hd \\<K>\\<^sub>s)\n        | Some s \\<Rightarrow> s) =\n    (\\<lambda>s.\n        case map_of\n              (map (\\<lambda>(s, \\<mu>). (s, pmf_of_alist \\<mu>)) \\<K>) s of\n        None \\<Rightarrow> return_pmf (hd \\<K>\\<^sub>s)\n        | Some s \\<Rightarrow> s)", "by auto"], ["proof (state)\nthis:\n  Closed_Kernel_From.K' \\<K> \\<K>\\<^sub>s = \\<K>'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas O_code = O.K'_code O.K1_def"], ["", "lemmas K_code = K.K'_code K.K1_def"], ["", "sublocale HMM_interp: HMM4 \\<O>' \"set \\<K>\\<^sub>s\" \\<K>\\<^sub>s \"set \\<O>\\<^sub>s\" \\<K>'"], ["proof (prove)\ngoal (1 subgoal):\n 1. HMM4 \\<O>' (set \\<K>\\<^sub>s) \\<K>\\<^sub>s (set \\<O>\\<^sub>s) \\<K>'", "using O.Closed_Kernel_axioms K.Closed_Kernel_axioms states_unique(2)"], ["proof (prove)\nusing this:\n  Closed_Kernel \\<O>' (set \\<O>\\<^sub>s)\n  Closed_Kernel \\<K>' (set \\<K>\\<^sub>s)\n  distinct \\<K>\\<^sub>s\n\ngoal (1 subgoal):\n 1. HMM4 \\<O>' (set \\<K>\\<^sub>s) \\<K>\\<^sub>s (set \\<O>\\<^sub>s) \\<K>'", "by (intro_locales; intro HMM4_axioms.intro HMM3_axioms.intro HOL.refl)"], ["", "end"], ["", "(* Concrete HMM *)"], ["", "end"]]}