{"file_name": "/home/qj213/afp-2021-10-22/thys/Hidden_Markov_Models/Hidden_Markov_Model.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Hidden_Markov_Models", "problem_names": ["lemma observations_finite: \"finite \\<O>\\<^sub>s\"\n  and observations_wellformed: \"\\<O>\\<^sub>s \\<noteq> {}\"\n  and observations_closed: \"\\<forall> s. \\<O> s \\<subseteq> \\<O>\\<^sub>s\"", "lemma states_finite: \"finite \\<S>\"\n  and states_wellformed: \"\\<S> \\<noteq> {}\"\n  and states_closed: \"\\<forall> s. \\<K> s \\<subseteq> \\<S>\"", "lemma (in HMM) obs:\n  \"obs \\<in> \\<O>\\<^sub>s\"", "lemma likelihood_alt_def: \"likelihood s os = T' (I s) {(s, o) ## xs @- \\<omega>' |o xs \\<omega>'. map snd xs = os}\"", "lemma L_Nil:\n  \"L [] \\<omega> = True\"", "lemma emeasure_T_observation_Nil:\n  \"T (s, o\\<^sub>0) {\\<omega> \\<in> space S. L [] \\<omega>} = 1\"", "lemma L_Cons:\n  \"L (o # os) \\<omega> \\<longleftrightarrow> snd (shd \\<omega>) = o \\<and> L os (stl \\<omega>)\"", "lemma L_measurable[measurable]:\n  \"Measurable.pred S (L os)\"", "lemma init_measurable[measurable]:\n  \"Measurable.pred S (\\<lambda>x. \\<exists>o\\<^sub>0 xs \\<omega>'. x = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and> map snd xs = os)\"\n  (is \"Measurable.pred S ?f\")", "lemma T_init_observation_eq:\n  \"T (s, o) {\\<omega> \\<in> space S. L os \\<omega>} = T (s, o') {\\<omega> \\<in> space S. L os \\<omega>}\"", "lemma (in HMM) likelihood_init:\n  \"likelihood s os = T (s, obs) {\\<omega> \\<in> space S. L os \\<omega>}\"", "lemma emeasure_T_observation_Cons:\n  \"T (s, o\\<^sub>0) {\\<omega> \\<in> space S. L (o\\<^sub>1 # os) \\<omega>} =\n   (\\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) * T (t, o\\<^sub>1) {\\<omega> \\<in> space S. L os \\<omega>} \\<partial>(\\<K> s))\" (is \"?l = ?r\")", "lemma emeasure_T_observation_backward:\n  \"emeasure (T (s, o)) {\\<omega> \\<in> space S. L os \\<omega>} = backward s os\"", "lemma (in HMM) likelihood_backward:\n  \"likelihood s os = backward s os\"", "lemma forward_split:\n  \"forward s t (os1 @ os2) = (\\<Sum>t' \\<in> \\<S>. forward s t' os1 * forward t' t os2)\"\n  if \"s \\<in> \\<S>\"", "lemma (in -)\n  \"(\\<Sum>t \\<in> S. f t) = f t\" if \"finite S\" \"t \\<in> S\" \"\\<forall> s \\<in> S - {t}. f s = 0\"", "lemma forward_backward:\n  \"(\\<Sum>t \\<in> \\<S>. forward s t os) = backward s os\" if \"s \\<in> \\<S>\"", "theorem likelihood_forward:\n  \"likelihood s os = (\\<Sum>t \\<in> \\<S>. forward s t os)\" if \\<open>s \\<in> \\<S>\\<close>", "lemma emeasure_T_state_Nil:\n  \"T (s, o\\<^sub>0) {\\<omega> \\<in> space S. V [] as \\<omega>} = 1\"", "lemma max_prob_T_state_Nil:\n  \"Max {T (s, o) {\\<omega> \\<in> space S. V [] as \\<omega>} | as. length as = length [] \\<and> set as \\<subseteq> \\<S>} = 1\"", "lemma V_Cons: \"V (o # os) (a # as) \\<omega> \\<longleftrightarrow> fst (shd \\<omega>) = a \\<and> snd (shd \\<omega>) = o \\<and> V os as (stl \\<omega>)\"", "lemma measurable_V[measurable]:\n  \"Measurable.pred S (\\<lambda>\\<omega>. V os as \\<omega>)\"", "lemma init_V_measurable[measurable]:\n  \"Measurable.pred S (\\<lambda>x. \\<exists>o \\<omega>'. x = (s, o) ## zip as os @- \\<omega>')\" (is \"Measurable.pred S ?f\")", "lemma max_prob_Cons':\n  \"Max {T (s, o\\<^sub>1) {\\<omega> \\<in> space S. V (o # os) as \\<omega>} | as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n  (\n    MAX t \\<in> \\<S>. ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n      (MAX as \\<in> {as. length as = length os \\<and> set as \\<subseteq> \\<S>}. T (t, o) {\\<omega> \\<in> space S. V os as \\<omega>})\n  )\" (is \"?l = ?r\")\n  and T_V_Cons:\n  \"T (s, o\\<^sub>1) {\\<omega> \\<in> space S. V (o # os) (t # as) \\<omega>}\n  = ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * T (t, o) {\\<omega> \\<in> space S. V os as \\<omega>}\"\n  (is \"?l' = ?r'\")\n  if \"length as = length os\"", "lemmas max_prob_Cons = max_prob_Cons'[OF length_replicate]", "lemma T_init_V_eq:\n  \"T (s, o) {\\<omega> \\<in> space S. V os as \\<omega>} = T (s, o') {\\<omega> \\<in> space S. V os as \\<omega>}\"", "lemma T'_I_T:\n  \"T' (I s) {\\<omega> \\<in> space S. \\<exists>o \\<omega>'. \\<omega> = (s, o) ## zip as os @- \\<omega>'} = T (s,o) {\\<omega> \\<in> space S. V os as \\<omega>}\"", "lemma max_prob_init:\n  \"max_prob s os = Max {T (s,o) {\\<omega> \\<in> space S. V os as \\<omega>} | as. length as = length os \\<and> set as \\<subseteq> \\<S>}\"", "lemma max_prob_Nil[simp]:\n  \"max_prob s [] = 1\"", "lemma Max_start:\n  \"(MAX t\\<in>\\<S>. (indicator {t} s :: ennreal)) = 1\" if \"s \\<in> \\<S>\"", "lemma Max_V_viterbi:\n  \"(MAX t \\<in> \\<S>. viterbi_prob s t os) =\n   Max {T (s, o) {\\<omega> \\<in> space S. V os as \\<omega>} | as. length as = length os \\<and> set as \\<subseteq> \\<S>}\" if \"s \\<in> \\<S>\"", "lemma max_prob_viterbi:\n  \"(MAX t \\<in> \\<S>. viterbi_prob s t os) = max_prob s os\" if \"s \\<in> \\<S>\"", "lemma state_list_nonempty:\n  \"state_list \\<noteq> []\"", "lemma viterbi_viterbi_prob:\n  \"snd (viterbi s t_end os) = viterbi_prob s t_end os\"", "lemma val_of_T:\n  \"val_of s as os = T (s, o\\<^sub>1) {\\<omega> \\<in> space S. V os as \\<omega>}\" if \"length as = length os\"", "lemma viterbi_sequence:\n  \"snd (viterbi s t_end os) = val_of s (fst (viterbi s t_end os)) os\"\n  if \"snd (viterbi s t_end os) > 0\"", "lemma viterbi_valid_path:\n  \"length as = length os \\<and> set as \\<subseteq> \\<S>\" if \"viterbi s t_end os = (as, v)\"", "lemma viterbi_finalE:\n  obtains t where\n    \"t \\<in> \\<S>\" \"viterbi_final s os = viterbi s t os\"\n    \"snd (viterbi s t os) = Max ((\\<lambda>t. snd (viterbi s t os)) ` \\<S>)\"", "theorem viterbi_final_max_prob:\n  assumes \"viterbi_final s os = (as, v)\" \"s \\<in> \\<S>\"\n  shows \"v = max_prob s os\"", "theorem viterbi_final_is_decoding:\n  assumes \"viterbi_final s os = (as, v)\" \"v > 0\" \"s \\<in> \\<S>\"\n  shows \"is_decoding s os as\""], "translations": [["", "lemma observations_finite: \"finite \\<O>\\<^sub>s\"\n  and observations_wellformed: \"\\<O>\\<^sub>s \\<noteq> {}\"\n  and observations_closed: \"\\<forall> s. \\<O> s \\<subseteq> \\<O>\\<^sub>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<O>\\<^sub>s &&&\n    \\<O>\\<^sub>s \\<noteq> {} &&&\n    \\<forall>s. set_pmf (\\<O> s) \\<subseteq> \\<O>\\<^sub>s", "using O.finite O.wellformed O.closed"], ["proof (prove)\nusing this:\n  finite \\<O>\\<^sub>s\n  \\<O>\\<^sub>s \\<noteq> {}\n  \\<forall>s. set_pmf (\\<O> s) \\<subseteq> \\<O>\\<^sub>s\n\ngoal (1 subgoal):\n 1. finite \\<O>\\<^sub>s &&&\n    \\<O>\\<^sub>s \\<noteq> {} &&&\n    \\<forall>s. set_pmf (\\<O> s) \\<subseteq> \\<O>\\<^sub>s", "by -"], ["", "end"], ["", "text \\<open>Fixed set of internal states.\\<close>"], ["", "locale HMM2_defs = HMM_defs \\<K> \\<O> for \\<K> :: \"'s \\<Rightarrow> 's pmf\" and \\<O> :: \"'s \\<Rightarrow> 't pmf\" +\n  fixes \\<S> :: \"'s set\""], ["", "locale HMM2 = HMM2_defs + HMM + K: Closed_Kernel \\<K> \\<S>\nbegin"], ["", "lemma states_finite: \"finite \\<S>\"\n  and states_wellformed: \"\\<S> \\<noteq> {}\"\n  and states_closed: \"\\<forall> s. \\<K> s \\<subseteq> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<S> &&&\n    \\<S> \\<noteq> {} &&& \\<forall>s. set_pmf (\\<K> s) \\<subseteq> \\<S>", "using K.finite K.wellformed K.closed"], ["proof (prove)\nusing this:\n  finite \\<S>\n  \\<S> \\<noteq> {}\n  \\<forall>s. set_pmf (\\<K> s) \\<subseteq> \\<S>\n\ngoal (1 subgoal):\n 1. finite \\<S> &&&\n    \\<S> \\<noteq> {} &&& \\<forall>s. set_pmf (\\<K> s) \\<subseteq> \\<S>", "by -"], ["", "end"], ["", "text \\<open>\n  The set of internal states is now given as a list to iterate over.\n  This is needed for the computations on HMMs.\n\\<close>"], ["", "locale HMM3_defs = HMM2_defs \\<O>\\<^sub>s \\<K> for \\<O>\\<^sub>s :: \"'t set\" and \\<K> :: \"'s \\<Rightarrow> 's pmf\" +\n  fixes state_list :: \"'s list\""], ["", "locale HMM3 = HMM3_defs _ _ \\<O>\\<^sub>s \\<K> + HMM2 \\<O>\\<^sub>s \\<K> for \\<O>\\<^sub>s :: \"'t set\" and \\<K> :: \"'s \\<Rightarrow> 's pmf\" +\n  assumes state_list_\\<S>: \"set state_list = \\<S>\""], ["", "context HMM_defs\nbegin"], ["", "no_notation (ASCII) comp  (infixl \"o\" 55)"], ["", "text \\<open>The ``default'' observation.\\<close>"], ["", "definition\n  \"obs \\<equiv> SOME x. x \\<in> \\<O>\\<^sub>s\""], ["", "lemma (in HMM) obs:\n  \"obs \\<in> \\<O>\\<^sub>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs \\<in> \\<O>\\<^sub>s", "unfolding obs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> \\<O>\\<^sub>s) \\<in> \\<O>\\<^sub>s", "using observations_wellformed"], ["proof (prove)\nusing this:\n  \\<O>\\<^sub>s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> \\<O>\\<^sub>s) \\<in> \\<O>\\<^sub>s", "by (auto intro: someI_ex)"], ["", "text \\<open>\n  The HMM is encoded as a Markov chain over pairs of states and observations.\n  This is the Markov chain's defining Markov kernel.\n\\<close>"], ["", "definition\n  \"K \\<equiv> \\<lambda> (s\\<^sub>1, o\\<^sub>1 :: 't). bind_pmf (\\<K> s\\<^sub>1) (\\<lambda> s\\<^sub>2. map_pmf (\\<lambda> o\\<^sub>2. (s\\<^sub>2, o\\<^sub>2)) (\\<O> s\\<^sub>2))\""], ["", "sublocale MC_syntax K"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>\n  Uniform distribution of the pairs \\<open>(s, o)\\<close> for a fixed state \\<open>s\\<close>.\n\\<close>"], ["", "definition \"I (s :: 's) = map_pmf (\\<lambda> x. (s, x)) (pmf_of_set \\<O>\\<^sub>s)\""], ["", "text \\<open>\n  The likelihood of an observation sequence given a starting state \\<open>s\\<close> is defined in terms of\n  the trace space of the Markov kernel given the uniform distribution of pairs for \\<open>s\\<close>.\n\\<close>"], ["", "definition\n  \"likelihood s os = T' (I s) {\\<omega> \\<in> space S. \\<exists> o\\<^sub>0 xs \\<omega>'. \\<omega> = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and> map snd xs = os}\""], ["", "abbreviation (input) \"L os \\<omega> \\<equiv> \\<exists> xs \\<omega>'. \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os\""], ["", "lemma likelihood_alt_def: \"likelihood s os = T' (I s) {(s, o) ## xs @- \\<omega>' |o xs \\<omega>'. map snd xs = os}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. likelihood s os =\n    emeasure (T' (I s))\n     {(s, o) ## xs @- \\<omega>' |o xs \\<omega>'. map snd xs = os}", "unfolding likelihood_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T' (I s))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>o\\<^sub>0 xs \\<omega>'.\n         \\<omega> = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and>\n         map snd xs = os} =\n    emeasure (T' (I s))\n     {(s, o) ## xs @- \\<omega>' |o xs \\<omega>'. map snd xs = os}", "by (simp add: in_S)"], ["", "subsection \\<open>Iteration Rule For Likelihood\\<close>"], ["", "lemma L_Nil:\n  \"L [] \\<omega> = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs \\<omega>'.\n        \\<omega> = xs @- \\<omega>' \\<and> map snd xs = []) =\n    True", "by simp"], ["", "lemma emeasure_T_observation_Nil:\n  \"T (s, o\\<^sub>0) {\\<omega> \\<in> space S. L [] \\<omega>} = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>0))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = []} =\n    1", "by simp"], ["", "lemma L_Cons:\n  \"L (o # os) \\<omega> \\<longleftrightarrow> snd (shd \\<omega>) = o \\<and> L os (stl \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xs \\<omega>'.\n        \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o # os) =\n    (snd (shd \\<omega>) = o \\<and>\n     (\\<exists>xs \\<omega>'.\n         stl \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os))", "apply (cases \\<omega>; cases \"shd \\<omega>\"; safe; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a \\<omega>' zs.\n       \\<lbrakk>\\<omega> = (a, o) ## zs @- \\<omega>';\n        os = map snd zs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            (\\<exists>\\<omega>''.\n                                zs @- \\<omega>' = xs @- \\<omega>'') \\<and>\n                            map snd xs = map snd zs\n 2. \\<And>aa xs \\<omega>'.\n       \\<lbrakk>\\<omega> = (aa, o) ## xs @- \\<omega>';\n        os = map snd xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            (\\<exists>\\<omega>''.\n                                (aa, o) ## xs @- \\<omega>' =\n                                xsa @- \\<omega>'') \\<and>\n                            map snd xsa = o # map snd xs", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa xs \\<omega>'.\n       \\<lbrakk>\\<omega> = (aa, o) ## xs @- \\<omega>';\n        os = map snd xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsa.\n                            (\\<exists>\\<omega>''.\n                                (aa, o) ## xs @- \\<omega>' =\n                                xsa @- \\<omega>'') \\<and>\n                            map snd xsa = o # map snd xs", "subgoal for x xs \\<omega>'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<omega> = (x, o) ## xs @- \\<omega>'; os = map snd xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xsa.\n                         (\\<exists>\\<omega>''.\n                             (x, o) ## xs @- \\<omega>' =\n                             xsa @- \\<omega>'') \\<and>\n                         map snd xsa = o # map snd xs", "by (force intro: exI[where x = \"(x, o) # xs\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma L_measurable[measurable]:\n  \"Measurable.pred S (L os)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>\\<omega>.\n         \\<exists>xs \\<omega>'.\n            \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os)", "apply (induction os)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>\\<omega>.\n         \\<exists>xs \\<omega>'.\n            \\<omega> = xs @- \\<omega>' \\<and> map snd xs = [])\n 2. \\<And>a os.\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            \\<exists>xs \\<omega>'.\n               \\<omega> = xs @- \\<omega>' \\<and>\n               map snd xs = os) \\<Longrightarrow>\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            \\<exists>xs \\<omega>'.\n               \\<omega> = xs @- \\<omega>' \\<and> map snd xs = a # os)", "apply (simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a os.\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            \\<exists>xs \\<omega>'.\n               \\<omega> = xs @- \\<omega>' \\<and>\n               map snd xs = os) \\<Longrightarrow>\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            \\<exists>xs \\<omega>'.\n               \\<omega> = xs @- \\<omega>' \\<and> map snd xs = a # os)", "subgoal premises that for o os"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>\\<omega>.\n         \\<exists>xs \\<omega>'.\n            \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o # os)", "by(subst L_Cons)\n      (intro Measurable.pred_intros_logic\n        measurable_compose[OF measurable_shd] measurable_compose[OF measurable_stl that];\n        measurable)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma init_measurable[measurable]:\n  \"Measurable.pred S (\\<lambda>x. \\<exists>o\\<^sub>0 xs \\<omega>'. x = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and> map snd xs = os)\"\n  (is \"Measurable.pred S ?f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>x.\n         \\<exists>o\\<^sub>0 xs \\<omega>'.\n            x = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and> map snd xs = os)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>x.\n         \\<exists>o\\<^sub>0 xs \\<omega>'.\n            x = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and> map snd xs = os)", "have *: \"?f \\<omega> \\<longleftrightarrow> fst (shd \\<omega>) = s \\<and> L os (stl \\<omega>)\" for \\<omega>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>o\\<^sub>0 xs \\<omega>'.\n        \\<omega> = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and>\n        map snd xs = os) =\n    (fst (shd \\<omega>) = s \\<and>\n     (\\<exists>xs \\<omega>'.\n         stl \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os))", "by (cases \\<omega>) auto"], ["proof (state)\nthis:\n  (\\<exists>o\\<^sub>0 xs \\<omega>'.\n      ?\\<omega>1 = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and>\n      map snd xs = os) =\n  (fst (shd ?\\<omega>1) = s \\<and>\n   (\\<exists>xs \\<omega>'.\n       stl ?\\<omega>1 = xs @- \\<omega>' \\<and> map snd xs = os))\n\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>x.\n         \\<exists>o\\<^sub>0 xs \\<omega>'.\n            x = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and> map snd xs = os)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>x.\n         \\<exists>o\\<^sub>0 xs \\<omega>'.\n            x = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and> map snd xs = os)", "by (subst *)\n       (intro Measurable.pred_intros_logic measurable_compose[OF measurable_shd]; measurable)"], ["proof (state)\nthis:\n  Measurable.pred (stream_space (count_space UNIV))\n   (\\<lambda>x.\n       \\<exists>o\\<^sub>0 xs \\<omega>'.\n          x = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and> map snd xs = os)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma T_init_observation_eq:\n  \"T (s, o) {\\<omega> \\<in> space S. L os \\<omega>} = T (s, o') {\\<omega> \\<in> space S. L os \\<omega>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T (s, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os} =\n    emeasure (T (s, o'))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}", "apply (subst emeasure_Collect_T[unfolded space_T], (measurable; fail))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. emeasure (T t)\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                t ## x = xs @- \\<omega>' \\<and>\n                                map snd xs = os}\n                       \\<partial>measure_pmf (K (s, o)) =\n    emeasure (T (s, o'))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}", "apply (subst (2) emeasure_Collect_T[unfolded space_T], (measurable; fail))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. emeasure (T t)\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                t ## x = xs @- \\<omega>' \\<and>\n                                map snd xs = os}\n                       \\<partial>measure_pmf (K (s, o)) =\n    \\<integral>\\<^sup>+ t. emeasure (T t)\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                t ## x = xs @- \\<omega>' \\<and>\n                                map snd xs = os}\n                       \\<partial>measure_pmf (K (s, o'))", "apply (simp add: K_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  Shows that it is equivalent to define likelihood in terms of the trace space starting at a single\n  pair of an internal state \\<open>s\\<close> and the default observation @{term obs}.\n\\<close>"], ["", "lemma (in HMM) likelihood_init:\n  \"likelihood s os = T (s, obs) {\\<omega> \\<in> space S. L os \\<omega>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. likelihood s os =\n    emeasure (T (s, obs))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. likelihood s os =\n    emeasure (T (s, obs))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}", "have *: \"(\\<Sum>o\\<in>\\<O>\\<^sub>s. emeasure (T (s, o)) {\\<omega> \\<in> space S. L os \\<omega>}) =\n    of_nat (card \\<O>\\<^sub>s) * emeasure (T (s, obs)) {\\<omega> \\<in> space S. L os \\<omega>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n       emeasure (T (s, o))\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         \\<exists>xs \\<omega>'.\n            \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}) =\n    of_nat (card \\<O>\\<^sub>s) *\n    emeasure (T (s, obs))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}", "by (subst sum_constant[symmetric]) (fastforce intro: sum.cong T_init_observation_eq[simplified])"], ["proof (state)\nthis:\n  (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n     emeasure (T (s, o))\n      {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n       \\<exists>xs \\<omega>'.\n          \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}) =\n  of_nat (card \\<O>\\<^sub>s) *\n  emeasure (T (s, obs))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs \\<omega>'.\n       \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}\n\ngoal (1 subgoal):\n 1. likelihood s os =\n    emeasure (T (s, obs))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. likelihood s os =\n    emeasure (T (s, obs))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}", "unfolding likelihood_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T' (I s))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>o\\<^sub>0 xs \\<omega>'.\n         \\<omega> = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and>\n         map snd xs = os} =\n    emeasure (T (s, obs))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}", "apply (subst emeasure_T')"], ["proof (prove)\ngoal (2 subgoals):\n 1. {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n     \\<exists>o\\<^sub>0 xs \\<omega>'.\n        \\<omega> = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and> map snd xs = os}\n    \\<in> sets (stream_space (count_space UNIV))\n 2. \\<integral>\\<^sup>+ sa. emeasure (T sa)\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              sa ## \\<omega>\n                              \\<in> {\\<omega>\n                                     \\<in> space\n      (stream_space (count_space UNIV)).\n                                     \\<exists>o\\<^sub>0 xs \\<omega>'.\n  \\<omega> = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and> map snd xs = os}}\n                       \\<partial>measure_pmf (I s) =\n    emeasure (T (s, obs))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n     \\<exists>o\\<^sub>0 xs \\<omega>'.\n        \\<omega> = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and> map snd xs = os}\n    \\<in> sets (stream_space (count_space UNIV))", "by measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ sa. emeasure (T sa)\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              sa ## \\<omega>\n                              \\<in> {\\<omega>\n                                     \\<in> space\n      (stream_space (count_space UNIV)).\n                                     \\<exists>o\\<^sub>0 xs \\<omega>'.\n  \\<omega> = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and> map snd xs = os}}\n                       \\<partial>measure_pmf (I s) =\n    emeasure (T (s, obs))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}", "using *"], ["proof (prove)\nusing this:\n  (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n     emeasure (T (s, o))\n      {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n       \\<exists>xs \\<omega>'.\n          \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}) =\n  of_nat (card \\<O>\\<^sub>s) *\n  emeasure (T (s, obs))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs \\<omega>'.\n       \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ sa. emeasure (T sa)\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              sa ## \\<omega>\n                              \\<in> {\\<omega>\n                                     \\<in> space\n      (stream_space (count_space UNIV)).\n                                     \\<exists>o\\<^sub>0 xs \\<omega>'.\n  \\<omega> = (s, o\\<^sub>0) ## xs @- \\<omega>' \\<and> map snd xs = os}}\n                       \\<partial>measure_pmf (I s) =\n    emeasure (T (s, obs))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}", "apply (simp add: I_def in_S observations_finite observations_wellformed nn_integral_pmf_of_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n       emeasure (T (s, o))\n        {\\<omega>.\n         \\<exists>xs.\n            (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n            map snd xs = os}) =\n    of_nat (card \\<O>\\<^sub>s) *\n    emeasure (T (s, obs))\n     {\\<omega>.\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os} \\<Longrightarrow>\n    of_nat (card \\<O>\\<^sub>s) *\n    emeasure (T (s, obs))\n     {\\<omega>.\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os} /\n    of_nat (card \\<O>\\<^sub>s) =\n    emeasure (T (s, obs))\n     {\\<omega>.\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os}", "apply (subst mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n       emeasure (T (s, o))\n        {\\<omega>.\n         \\<exists>xs.\n            (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n            map snd xs = os}) =\n    of_nat (card \\<O>\\<^sub>s) *\n    emeasure (T (s, obs))\n     {\\<omega>.\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os} \\<Longrightarrow>\n    emeasure (T (s, obs))\n     {\\<omega>.\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os} *\n    of_nat (card \\<O>\\<^sub>s) /\n    of_nat (card \\<O>\\<^sub>s) =\n    emeasure (T (s, obs))\n     {\\<omega>.\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os}", "apply (simp add: observations_finite observations_wellformed mult_divide_eq_ennreal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  likelihood s os =\n  emeasure (T (s, obs))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs \\<omega>'.\n       \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emeasure_T_observation_Cons:\n  \"T (s, o\\<^sub>0) {\\<omega> \\<in> space S. L (o\\<^sub>1 # os) \\<omega>} =\n   (\\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) * T (t, o\\<^sub>1) {\\<omega> \\<in> space S. L os \\<omega>} \\<partial>(\\<K> s))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>0))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o\\<^sub>1 # os} =\n    \\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) *\n                           emeasure (T (t, o\\<^sub>1))\n                            {\\<omega>\n                             \\<in> space (stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                \\<omega> = xs @- \\<omega>' \\<and>\n                                map snd xs = os}\n                       \\<partial>measure_pmf (\\<K> s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>0))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o\\<^sub>1 # os} =\n    \\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) *\n                           emeasure (T (t, o\\<^sub>1))\n                            {\\<omega>\n                             \\<in> space (stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                \\<omega> = xs @- \\<omega>' \\<and>\n                                map snd xs = os}\n                       \\<partial>measure_pmf (\\<K> s)", "have *:\n    \"\\<integral>\\<^sup>+ y. T (s', y) {x \\<in> space S. \\<exists>xs. (\\<exists>\\<omega>'. (s', y) ## x = xs @- \\<omega>') \\<and> map snd xs = o\\<^sub>1 # os}\n       \\<partial>measure_pmf (\\<O> s') =\n    ennreal (pmf (\\<O> s') o\\<^sub>1) * T (s', o\\<^sub>1) {\\<omega> \\<in> space S. \\<exists>xs. (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and> map snd xs = os}\"\n    (is \"?L = ?R\") for s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs.\n                                (\\<exists>\\<omega>'.\n                                    (s', y) ## x = xs @- \\<omega>') \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>measure_pmf (\\<O> s') =\n    ennreal (pmf (\\<O> s') o\\<^sub>1) *\n    emeasure (T (s', o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs.\n                                (\\<exists>\\<omega>'.\n                                    (s', y) ## x = xs @- \\<omega>') \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>measure_pmf (\\<O> s') =\n    ennreal (pmf (\\<O> s') o\\<^sub>1) *\n    emeasure (T (s', o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os}", "have \"?L = \\<integral>\\<^sup>+ x. ennreal (pmf (\\<O> s') x) *\n            T (s', x) {\\<omega> \\<in> space S. \\<exists>xs. (\\<exists>\\<omega>'. (s', x) ## \\<omega> = xs @- \\<omega>') \\<and> map snd xs = o\\<^sub>1 # os}\n          \\<partial>count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs.\n                                (\\<exists>\\<omega>'.\n                                    (s', y) ## x = xs @- \\<omega>') \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>measure_pmf (\\<O> s') =\n    \\<integral>\\<^sup>+ x. ennreal (pmf (\\<O> s') x) *\n                           emeasure (T (s', x))\n                            {\\<omega>\n                             \\<in> space (stream_space (count_space UNIV)).\n                             \\<exists>xs.\n                                (\\<exists>\\<omega>'.\n                                    (s', x) ## \\<omega> =\n                                    xs @- \\<omega>') \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>count_space UNIV", "by (rule nn_integral_measure_pmf)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                          {x \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs.\n                              (\\<exists>\\<omega>'.\n                                  (s', y) ## x = xs @- \\<omega>') \\<and>\n                              map snd xs = o\\<^sub>1 # os}\n                     \\<partial>measure_pmf (\\<O> s') =\n  \\<integral>\\<^sup>+ x. ennreal (pmf (\\<O> s') x) *\n                         emeasure (T (s', x))\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs.\n                              (\\<exists>\\<omega>'.\n                                  (s', x) ## \\<omega> =\n                                  xs @- \\<omega>') \\<and>\n                              map snd xs = o\\<^sub>1 # os}\n                     \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs.\n                                (\\<exists>\\<omega>'.\n                                    (s', y) ## x = xs @- \\<omega>') \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>measure_pmf (\\<O> s') =\n    ennreal (pmf (\\<O> s') o\\<^sub>1) *\n    emeasure (T (s', o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os}", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                          {x \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs.\n                              (\\<exists>\\<omega>'.\n                                  (s', y) ## x = xs @- \\<omega>') \\<and>\n                              map snd xs = o\\<^sub>1 # os}\n                     \\<partial>measure_pmf (\\<O> s') =\n  \\<integral>\\<^sup>+ x. ennreal (pmf (\\<O> s') x) *\n                         emeasure (T (s', x))\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs.\n                              (\\<exists>\\<omega>'.\n                                  (s', x) ## \\<omega> =\n                                  xs @- \\<omega>') \\<and>\n                              map snd xs = o\\<^sub>1 # os}\n                     \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs.\n                                (\\<exists>\\<omega>'.\n                                    (s', y) ## x = xs @- \\<omega>') \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>measure_pmf (\\<O> s') =\n    ennreal (pmf (\\<O> s') o\\<^sub>1) *\n    emeasure (T (s', o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os}", "have \"\\<dots> =\n      \\<integral>\\<^sup>+ o\\<^sub>2. (if o\\<^sub>2 = o\\<^sub>1\n              then ennreal (pmf (\\<O> s') o\\<^sub>1) * T (s', o\\<^sub>1) {\\<omega> \\<in> space S. L os \\<omega>}\n              else 0)\n       \\<partial>count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (pmf (\\<O> s') x) *\n                           emeasure (T (s', x))\n                            {\\<omega>\n                             \\<in> space (stream_space (count_space UNIV)).\n                             \\<exists>xs.\n                                (\\<exists>\\<omega>'.\n                                    (s', x) ## \\<omega> =\n                                    xs @- \\<omega>') \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+ o\\<^sub>2.\n                         (if o\\<^sub>2 = o\\<^sub>1\n                          then ennreal (pmf (\\<O> s') o\\<^sub>1) *\n                               emeasure (T (s', o\\<^sub>1))\n                                {\\<omega>\n                                 \\<in> space\n  (stream_space (count_space UNIV)).\n                                 \\<exists>xs \\<omega>'.\n                                    \\<omega> = xs @- \\<omega>' \\<and>\n                                    map snd xs = os}\n                          else 0)\n                       \\<partial>count_space UNIV", "apply (rule nn_integral_cong_AE\n          [where v = \"\\<lambda> o\\<^sub>2. if o\\<^sub>2 = o\\<^sub>1\n            then ennreal (pmf (\\<O> s') o\\<^sub>1) * T (s', o\\<^sub>1) {\\<omega> \\<in> space S. L os \\<omega>} else 0\"]\n          )"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in count_space\n             UNIV. ennreal (pmf (\\<O> s') x) *\n                   emeasure (T (s', x))\n                    {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n                     \\<exists>xs.\n                        (\\<exists>\\<omega>'.\n                            (s', x) ## \\<omega> = xs @- \\<omega>') \\<and>\n                        map snd xs = o\\<^sub>1 # os} =\n                   (if x = o\\<^sub>1\n                    then ennreal (pmf (\\<O> s') o\\<^sub>1) *\n                         emeasure (T (s', o\\<^sub>1))\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs \\<omega>'.\n                              \\<omega> = xs @- \\<omega>' \\<and>\n                              map snd xs = os}\n                    else 0)", "apply (rule AE_I2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (count_space UNIV) \\<Longrightarrow>\n       ennreal (pmf (\\<O> s') x) *\n       emeasure (T (s', x))\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         \\<exists>xs.\n            (\\<exists>\\<omega>'.\n                (s', x) ## \\<omega> = xs @- \\<omega>') \\<and>\n            map snd xs = o\\<^sub>1 # os} =\n       (if x = o\\<^sub>1\n        then ennreal (pmf (\\<O> s') o\\<^sub>1) *\n             emeasure (T (s', o\\<^sub>1))\n              {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n               \\<exists>xs \\<omega>'.\n                  \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}\n        else 0)", "apply (split if_split, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       o\\<^sub>1 \\<in> space (count_space UNIV) \\<Longrightarrow>\n       ennreal (pmf (\\<O> s') o\\<^sub>1) *\n       emeasure (T (s', o\\<^sub>1))\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         \\<exists>xs.\n            (\\<exists>\\<omega>'.\n                (s', o\\<^sub>1) ## \\<omega> = xs @- \\<omega>') \\<and>\n            map snd xs = o\\<^sub>1 # os} =\n       ennreal (pmf (\\<O> s') o\\<^sub>1) *\n       emeasure (T (s', o\\<^sub>1))\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         \\<exists>xs \\<omega>'.\n            \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> space (count_space UNIV);\n        x \\<noteq> o\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (\\<O> s') x) *\n                         emeasure (T (s', x))\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs.\n                              (\\<exists>\\<omega>'.\n                                  (s', x) ## \\<omega> =\n                                  xs @- \\<omega>') \\<and>\n                              map snd xs = o\\<^sub>1 # os} =\n                         0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. o\\<^sub>1 \\<in> space (count_space UNIV) \\<Longrightarrow>\n    ennreal (pmf (\\<O> s') o\\<^sub>1) *\n    emeasure (T (s', o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs.\n         (\\<exists>\\<omega>'.\n             (s', o\\<^sub>1) ## \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = o\\<^sub>1 # os} =\n    ennreal (pmf (\\<O> s') o\\<^sub>1) *\n    emeasure (T (s', o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os}", "by (auto intro!: arg_cong2[where f = times, OF HOL.refl] arg_cong2[where f = emeasure];\n            metis list.simps(9) shift.simps(2) snd_conv\n           )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (count_space UNIV);\n        x \\<noteq> o\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (\\<O> s') x) *\n                         emeasure (T (s', x))\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs.\n                              (\\<exists>\\<omega>'.\n                                  (s', x) ## \\<omega> =\n                                  xs @- \\<omega>') \\<and>\n                              map snd xs = o\\<^sub>1 # os} =\n                         0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<in> space (count_space UNIV);\n     x_ \\<noteq> o\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> ennreal (pmf (\\<O> s') x_) *\n                      emeasure (T (s', x_))\n                       {\\<omega>\n                        \\<in> space (stream_space (count_space UNIV)).\n                        \\<exists>xs.\n                           (\\<exists>\\<omega>'.\n                               (s', x_) ## \\<omega> =\n                               xs @- \\<omega>') \\<and>\n                           map snd xs = o\\<^sub>1 # os} =\n                      0", "by (subst arg_cong2[where f = emeasure and d = \"{}\", OF HOL.refl]) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (pmf (\\<O> s') x) *\n                         emeasure (T (s', x))\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs.\n                              (\\<exists>\\<omega>'.\n                                  (s', x) ## \\<omega> =\n                                  xs @- \\<omega>') \\<and>\n                              map snd xs = o\\<^sub>1 # os}\n                     \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+ o\\<^sub>2.\n                       (if o\\<^sub>2 = o\\<^sub>1\n                        then ennreal (pmf (\\<O> s') o\\<^sub>1) *\n                             emeasure (T (s', o\\<^sub>1))\n                              {\\<omega>\n                               \\<in> space\n(stream_space (count_space UNIV)).\n                               \\<exists>xs \\<omega>'.\n                                  \\<omega> = xs @- \\<omega>' \\<and>\n                                  map snd xs = os}\n                        else 0)\n                     \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs.\n                                (\\<exists>\\<omega>'.\n                                    (s', y) ## x = xs @- \\<omega>') \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>measure_pmf (\\<O> s') =\n    ennreal (pmf (\\<O> s') o\\<^sub>1) *\n    emeasure (T (s', o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os}", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (pmf (\\<O> s') x) *\n                         emeasure (T (s', x))\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs.\n                              (\\<exists>\\<omega>'.\n                                  (s', x) ## \\<omega> =\n                                  xs @- \\<omega>') \\<and>\n                              map snd xs = o\\<^sub>1 # os}\n                     \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+ o\\<^sub>2.\n                       (if o\\<^sub>2 = o\\<^sub>1\n                        then ennreal (pmf (\\<O> s') o\\<^sub>1) *\n                             emeasure (T (s', o\\<^sub>1))\n                              {\\<omega>\n                               \\<in> space\n(stream_space (count_space UNIV)).\n                               \\<exists>xs \\<omega>'.\n                                  \\<omega> = xs @- \\<omega>' \\<and>\n                                  map snd xs = os}\n                        else 0)\n                     \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs.\n                                (\\<exists>\\<omega>'.\n                                    (s', y) ## x = xs @- \\<omega>') \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>measure_pmf (\\<O> s') =\n    ennreal (pmf (\\<O> s') o\\<^sub>1) *\n    emeasure (T (s', o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os}", "have \"\\<dots> = \\<integral>\\<^sup>+o\\<^sub>2\\<in>{o\\<^sub>1}.\n       (ennreal (pmf (\\<O> s') o\\<^sub>1) * T (s', o\\<^sub>1) {\\<omega> \\<in> space S. L os \\<omega>})\n      \\<partial>count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ o\\<^sub>2.\n                         (if o\\<^sub>2 = o\\<^sub>1\n                          then ennreal (pmf (\\<O> s') o\\<^sub>1) *\n                               emeasure (T (s', o\\<^sub>1))\n                                {\\<omega>\n                                 \\<in> space\n  (stream_space (count_space UNIV)).\n                                 \\<exists>xs \\<omega>'.\n                                    \\<omega> = xs @- \\<omega>' \\<and>\n                                    map snd xs = os}\n                          else 0)\n                       \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{o\\<^sub>1}.\n                       (ennreal (pmf (\\<O> s') o\\<^sub>1) *\n                        emeasure (T (s', o\\<^sub>1))\n                         {\\<omega>\n                          \\<in> space (stream_space (count_space UNIV)).\n                          \\<exists>xs \\<omega>'.\n                             \\<omega> = xs @- \\<omega>' \\<and>\n                             map snd xs = os})\n    \\<partial>count_space UNIV", "by (rule nn_integral_cong_AE) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ o\\<^sub>2.\n                       (if o\\<^sub>2 = o\\<^sub>1\n                        then ennreal (pmf (\\<O> s') o\\<^sub>1) *\n                             emeasure (T (s', o\\<^sub>1))\n                              {\\<omega>\n                               \\<in> space\n(stream_space (count_space UNIV)).\n                               \\<exists>xs \\<omega>'.\n                                  \\<omega> = xs @- \\<omega>' \\<and>\n                                  map snd xs = os}\n                        else 0)\n                     \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+x\\<in>{o\\<^sub>1}.\n                     (ennreal (pmf (\\<O> s') o\\<^sub>1) *\n                      emeasure (T (s', o\\<^sub>1))\n                       {\\<omega>\n                        \\<in> space (stream_space (count_space UNIV)).\n                        \\<exists>xs \\<omega>'.\n                           \\<omega> = xs @- \\<omega>' \\<and>\n                           map snd xs = os})\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs.\n                                (\\<exists>\\<omega>'.\n                                    (s', y) ## x = xs @- \\<omega>') \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>measure_pmf (\\<O> s') =\n    ennreal (pmf (\\<O> s') o\\<^sub>1) *\n    emeasure (T (s', o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os}", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ o\\<^sub>2.\n                       (if o\\<^sub>2 = o\\<^sub>1\n                        then ennreal (pmf (\\<O> s') o\\<^sub>1) *\n                             emeasure (T (s', o\\<^sub>1))\n                              {\\<omega>\n                               \\<in> space\n(stream_space (count_space UNIV)).\n                               \\<exists>xs \\<omega>'.\n                                  \\<omega> = xs @- \\<omega>' \\<and>\n                                  map snd xs = os}\n                        else 0)\n                     \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+x\\<in>{o\\<^sub>1}.\n                     (ennreal (pmf (\\<O> s') o\\<^sub>1) *\n                      emeasure (T (s', o\\<^sub>1))\n                       {\\<omega>\n                        \\<in> space (stream_space (count_space UNIV)).\n                        \\<exists>xs \\<omega>'.\n                           \\<omega> = xs @- \\<omega>' \\<and>\n                           map snd xs = os})\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs.\n                                (\\<exists>\\<omega>'.\n                                    (s', y) ## x = xs @- \\<omega>') \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>measure_pmf (\\<O> s') =\n    ennreal (pmf (\\<O> s') o\\<^sub>1) *\n    emeasure (T (s', o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os}", "have \"\\<dots> = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{o\\<^sub>1}.\n                       (ennreal (pmf (\\<O> s') o\\<^sub>1) *\n                        emeasure (T (s', o\\<^sub>1))\n                         {\\<omega>\n                          \\<in> space (stream_space (count_space UNIV)).\n                          \\<exists>xs \\<omega>'.\n                             \\<omega> = xs @- \\<omega>' \\<and>\n                             map snd xs = os})\n    \\<partial>count_space UNIV =\n    ennreal (pmf (\\<O> s') o\\<^sub>1) *\n    emeasure (T (s', o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os}", "by simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{o\\<^sub>1}.\n                     (ennreal (pmf (\\<O> s') o\\<^sub>1) *\n                      emeasure (T (s', o\\<^sub>1))\n                       {\\<omega>\n                        \\<in> space (stream_space (count_space UNIV)).\n                        \\<exists>xs \\<omega>'.\n                           \\<omega> = xs @- \\<omega>' \\<and>\n                           map snd xs = os})\n  \\<partial>count_space UNIV =\n  ennreal (pmf (\\<O> s') o\\<^sub>1) *\n  emeasure (T (s', o\\<^sub>1))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs.\n       (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n       map snd xs = os}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs.\n                                (\\<exists>\\<omega>'.\n                                    (s', y) ## x = xs @- \\<omega>') \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>measure_pmf (\\<O> s') =\n    ennreal (pmf (\\<O> s') o\\<^sub>1) *\n    emeasure (T (s', o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os}", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                          {x \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs.\n                              (\\<exists>\\<omega>'.\n                                  (s', y) ## x = xs @- \\<omega>') \\<and>\n                              map snd xs = o\\<^sub>1 # os}\n                     \\<partial>measure_pmf (\\<O> s') =\n  ennreal (pmf (\\<O> s') o\\<^sub>1) *\n  emeasure (T (s', o\\<^sub>1))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs.\n       (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n       map snd xs = os}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                          {x \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs.\n                              (\\<exists>\\<omega>'.\n                                  (s', y) ## x = xs @- \\<omega>') \\<and>\n                              map snd xs = o\\<^sub>1 # os}\n                     \\<partial>measure_pmf (\\<O> s') =\n  ennreal (pmf (\\<O> s') o\\<^sub>1) *\n  emeasure (T (s', o\\<^sub>1))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs.\n       (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n       map snd xs = os}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs.\n                                (\\<exists>\\<omega>'.\n                                    (s', y) ## x = xs @- \\<omega>') \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>measure_pmf (\\<O> s') =\n    ennreal (pmf (\\<O> s') o\\<^sub>1) *\n    emeasure (T (s', o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs.\n         (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n         map snd xs = os}", "."], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure (T (s', y))\n                          {x \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs.\n                              (\\<exists>\\<omega>'.\n                                  (s', y) ## x = xs @- \\<omega>') \\<and>\n                              map snd xs = o\\<^sub>1 # os}\n                     \\<partial>measure_pmf (\\<O> s') =\n  ennreal (pmf (\\<O> s') o\\<^sub>1) *\n  emeasure (T (s', o\\<^sub>1))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs.\n       (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n       map snd xs = os}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure (T (?s'1, y))\n                          {x \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs.\n                              (\\<exists>\\<omega>'.\n                                  (?s'1, y) ## x = xs @- \\<omega>') \\<and>\n                              map snd xs = o\\<^sub>1 # os}\n                     \\<partial>measure_pmf (\\<O> ?s'1) =\n  ennreal (pmf (\\<O> ?s'1) o\\<^sub>1) *\n  emeasure (T (?s'1, o\\<^sub>1))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs.\n       (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n       map snd xs = os}\n\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>0))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o\\<^sub>1 # os} =\n    \\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) *\n                           emeasure (T (t, o\\<^sub>1))\n                            {\\<omega>\n                             \\<in> space (stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                \\<omega> = xs @- \\<omega>' \\<and>\n                                map snd xs = os}\n                       \\<partial>measure_pmf (\\<K> s)", "have \"?l = \\<integral>\\<^sup>+ t. T t {x \\<in> space S. \\<exists>xs \\<omega>'. t ## x = xs @- \\<omega>' \\<and> map snd xs = o\\<^sub>1 # os} \\<partial> (K (s, o\\<^sub>0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>0))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o\\<^sub>1 # os} =\n    \\<integral>\\<^sup>+ t. emeasure (T t)\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                t ## x = xs @- \\<omega>' \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>measure_pmf (K (s, o\\<^sub>0))", "by (subst emeasure_Collect_T[unfolded space_T], measurable)"], ["proof (state)\nthis:\n  emeasure (T (s, o\\<^sub>0))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs \\<omega>'.\n       \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o\\<^sub>1 # os} =\n  \\<integral>\\<^sup>+ t. emeasure (T t)\n                          {x \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs \\<omega>'.\n                              t ## x = xs @- \\<omega>' \\<and>\n                              map snd xs = o\\<^sub>1 # os}\n                     \\<partial>measure_pmf (K (s, o\\<^sub>0))\n\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>0))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o\\<^sub>1 # os} =\n    \\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) *\n                           emeasure (T (t, o\\<^sub>1))\n                            {\\<omega>\n                             \\<in> space (stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                \\<omega> = xs @- \\<omega>' \\<and>\n                                map snd xs = os}\n                       \\<partial>measure_pmf (\\<K> s)", "also"], ["proof (state)\nthis:\n  emeasure (T (s, o\\<^sub>0))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs \\<omega>'.\n       \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o\\<^sub>1 # os} =\n  \\<integral>\\<^sup>+ t. emeasure (T t)\n                          {x \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs \\<omega>'.\n                              t ## x = xs @- \\<omega>' \\<and>\n                              map snd xs = o\\<^sub>1 # os}\n                     \\<partial>measure_pmf (K (s, o\\<^sub>0))\n\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>0))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o\\<^sub>1 # os} =\n    \\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) *\n                           emeasure (T (t, o\\<^sub>1))\n                            {\\<omega>\n                             \\<in> space (stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                \\<omega> = xs @- \\<omega>' \\<and>\n                                map snd xs = os}\n                       \\<partial>measure_pmf (\\<K> s)", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. emeasure (T t)\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                t ## x = xs @- \\<omega>' \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>measure_pmf (K (s, o\\<^sub>0)) =\n    \\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) *\n                           emeasure (T (t, o\\<^sub>1))\n                            {\\<omega>\n                             \\<in> space (stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                \\<omega> = xs @- \\<omega>' \\<and>\n                                map snd xs = os}\n                       \\<partial>measure_pmf (\\<K> s)", "using *"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ y. emeasure (T (?s'1, y))\n                          {x \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs.\n                              (\\<exists>\\<omega>'.\n                                  (?s'1, y) ## x = xs @- \\<omega>') \\<and>\n                              map snd xs = o\\<^sub>1 # os}\n                     \\<partial>measure_pmf (\\<O> ?s'1) =\n  ennreal (pmf (\\<O> ?s'1) o\\<^sub>1) *\n  emeasure (T (?s'1, o\\<^sub>1))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs.\n       (\\<exists>\\<omega>'. \\<omega> = xs @- \\<omega>') \\<and>\n       map snd xs = os}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. emeasure (T t)\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                t ## x = xs @- \\<omega>' \\<and>\n                                map snd xs = o\\<^sub>1 # os}\n                       \\<partial>measure_pmf (K (s, o\\<^sub>0)) =\n    \\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) *\n                           emeasure (T (t, o\\<^sub>1))\n                            {\\<omega>\n                             \\<in> space (stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                \\<omega> = xs @- \\<omega>' \\<and>\n                                map snd xs = os}\n                       \\<partial>measure_pmf (\\<K> s)", "by (simp add: K_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. emeasure (T t)\n                          {x \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs \\<omega>'.\n                              t ## x = xs @- \\<omega>' \\<and>\n                              map snd xs = o\\<^sub>1 # os}\n                     \\<partial>measure_pmf (K (s, o\\<^sub>0)) =\n  \\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) *\n                         emeasure (T (t, o\\<^sub>1))\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs \\<omega>'.\n                              \\<omega> = xs @- \\<omega>' \\<and>\n                              map snd xs = os}\n                     \\<partial>measure_pmf (\\<K> s)\n\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>0))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o\\<^sub>1 # os} =\n    \\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) *\n                           emeasure (T (t, o\\<^sub>1))\n                            {\\<omega>\n                             \\<in> space (stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                \\<omega> = xs @- \\<omega>' \\<and>\n                                map snd xs = os}\n                       \\<partial>measure_pmf (\\<K> s)", "finally"], ["proof (chain)\npicking this:\n  emeasure (T (s, o\\<^sub>0))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs \\<omega>'.\n       \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o\\<^sub>1 # os} =\n  \\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) *\n                         emeasure (T (t, o\\<^sub>1))\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs \\<omega>'.\n                              \\<omega> = xs @- \\<omega>' \\<and>\n                              map snd xs = os}\n                     \\<partial>measure_pmf (\\<K> s)", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (T (s, o\\<^sub>0))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs \\<omega>'.\n       \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o\\<^sub>1 # os} =\n  \\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) *\n                         emeasure (T (t, o\\<^sub>1))\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs \\<omega>'.\n                              \\<omega> = xs @- \\<omega>' \\<and>\n                              map snd xs = os}\n                     \\<partial>measure_pmf (\\<K> s)\n\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>0))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o\\<^sub>1 # os} =\n    \\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) *\n                           emeasure (T (t, o\\<^sub>1))\n                            {\\<omega>\n                             \\<in> space (stream_space (count_space UNIV)).\n                             \\<exists>xs \\<omega>'.\n                                \\<omega> = xs @- \\<omega>' \\<and>\n                                map snd xs = os}\n                       \\<partial>measure_pmf (\\<K> s)", "."], ["proof (state)\nthis:\n  emeasure (T (s, o\\<^sub>0))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs \\<omega>'.\n       \\<omega> = xs @- \\<omega>' \\<and> map snd xs = o\\<^sub>1 # os} =\n  \\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o\\<^sub>1) *\n                         emeasure (T (t, o\\<^sub>1))\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs \\<omega>'.\n                              \\<omega> = xs @- \\<omega>' \\<and>\n                              map snd xs = os}\n                     \\<partial>measure_pmf (\\<K> s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Computation of Likelihood\\<close>"], ["", "fun backward where\n  \"backward s [] = 1\" |\n  \"backward s (o # os) = (\\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) o) * backward t os \\<partial>measure_pmf (\\<K> s))\""], ["", "lemma emeasure_T_observation_backward:\n  \"emeasure (T (s, o)) {\\<omega> \\<in> space S. L os \\<omega>} = backward s os\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T (s, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os} =\n    backward s os", "using emeasure_T_observation_Cons"], ["proof (prove)\nusing this:\n  emeasure (T (?s, ?o\\<^sub>0))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>xs \\<omega>'.\n       \\<omega> = xs @- \\<omega>' \\<and> map snd xs = ?o\\<^sub>1 # ?os} =\n  \\<integral>\\<^sup>+ t. ennreal (pmf (\\<O> t) ?o\\<^sub>1) *\n                         emeasure (T (t, ?o\\<^sub>1))\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>xs \\<omega>'.\n                              \\<omega> = xs @- \\<omega>' \\<and>\n                              map snd xs = ?os}\n                     \\<partial>measure_pmf (\\<K> ?s)\n\ngoal (1 subgoal):\n 1. emeasure (T (s, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>xs \\<omega>'.\n         \\<omega> = xs @- \\<omega>' \\<and> map snd xs = os} =\n    backward s os", "by (induction os arbitrary: s o; simp)"], ["", "lemma (in HMM) likelihood_backward:\n  \"likelihood s os = backward s os\""], ["proof (prove)\ngoal (1 subgoal):\n 1. likelihood s os = backward s os", "unfolding likelihood_init emeasure_T_observation_backward"], ["proof (prove)\ngoal (1 subgoal):\n 1. backward s os = backward s os", ".."], ["", "end"], ["", "(* HMM Defs *)"], ["", "context HMM2\nbegin"], ["", "fun (in HMM2_defs) forward where\n  \"forward s t_end [] = indicator {t_end} s\" |\n  \"forward s t_end (o # os) =\n    (\\<Sum>t \\<in> \\<S>. ennreal (pmf (\\<O> t) o) * ennreal (pmf (\\<K> s) t) * forward t t_end os)\""], ["", "lemma forward_split:\n  \"forward s t (os1 @ os2) = (\\<Sum>t' \\<in> \\<S>. forward s t' os1 * forward t' t os2)\"\n  if \"s \\<in> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forward s t (os1 @ os2) =\n    (\\<Sum>t'\\<in>\\<S>. forward s t' os1 * forward t' t os2)", "using that"], ["proof (prove)\nusing this:\n  s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. forward s t (os1 @ os2) =\n    (\\<Sum>t'\\<in>\\<S>. forward s t' os1 * forward t' t os2)", "apply (induction os1 arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> \\<S> \\<Longrightarrow>\n       forward s t ([] @ os2) =\n       (\\<Sum>t'\\<in>\\<S>. forward s t' [] * forward t' t os2)\n 2. \\<And>a os1 s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> \\<S> \\<Longrightarrow>\n                   forward s t (os1 @ os2) =\n                   (\\<Sum>t'\\<in>\\<S>. forward s t' os1 * forward t' t os2);\n        s \\<in> \\<S>\\<rbrakk>\n       \\<Longrightarrow> forward s t ((a # os1) @ os2) =\n                         (\\<Sum>t'\\<in>\\<S>.\n                            forward s t' (a # os1) * forward t' t os2)", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> \\<S> \\<Longrightarrow>\n    forward s t ([] @ os2) =\n    (\\<Sum>t'\\<in>\\<S>. forward s t' [] * forward t' t os2)", "apply (simp add: sum_indicator_mult[OF states_finite])"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> \\<S> \\<Longrightarrow>\n    forward s t os2 =\n    (\\<Sum>t' | s = t' \\<and> t' \\<in> \\<S>. forward t' t os2)", "apply (subst sum.cong[where B = \"{s}\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. s \\<in> \\<S> \\<Longrightarrow> {t'. s = t' \\<and> t' \\<in> \\<S>} = {s}\n 2. \\<And>x.\n       \\<lbrakk>s \\<in> \\<S>; x \\<in> {s}\\<rbrakk>\n       \\<Longrightarrow> forward x t os2 = ?h9 x\n 3. s \\<in> \\<S> \\<Longrightarrow> forward s t os2 = sum ?h9 {s}", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a os1 s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> \\<S> \\<Longrightarrow>\n                   forward s t (os1 @ os2) =\n                   (\\<Sum>t'\\<in>\\<S>. forward s t' os1 * forward t' t os2);\n        s \\<in> \\<S>\\<rbrakk>\n       \\<Longrightarrow> forward s t ((a # os1) @ os2) =\n                         (\\<Sum>t'\\<in>\\<S>.\n                            forward s t' (a # os1) * forward t' t os2)", "subgoal for a os1 s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                s \\<in> \\<S> \\<Longrightarrow>\n                forward s t (os1 @ os2) =\n                (\\<Sum>t'\\<in>\\<S>. forward s t' os1 * forward t' t os2);\n     s \\<in> \\<S>\\<rbrakk>\n    \\<Longrightarrow> forward s t ((a # os1) @ os2) =\n                      (\\<Sum>t'\\<in>\\<S>.\n                         forward s t' (a # os1) * forward t' t os2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                s \\<in> \\<S> \\<Longrightarrow>\n                forward s t (os1 @ os2) =\n                (\\<Sum>t'\\<in>\\<S>. forward s t' os1 * forward t' t os2);\n     s \\<in> \\<S>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>ta\\<in>\\<S>.\n                         ennreal (pmf (\\<O> ta) a) *\n                         ennreal (pmf (\\<K> s) ta) *\n                         (\\<Sum>t'\\<in>\\<S>.\n                            forward ta t' os1 * forward t' t os2)) =\n                      (\\<Sum>t'\\<in>\\<S>.\n                         (\\<Sum>t\\<in>\\<S>.\n                            ennreal (pmf (\\<O> t) a) *\n                            ennreal (pmf (\\<K> s) t) *\n                            forward t t' os1) *\n                         forward t' t os2)", "apply (subst sum_distrib_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                s \\<in> \\<S> \\<Longrightarrow>\n                forward s t (os1 @ os2) =\n                (\\<Sum>t'\\<in>\\<S>. forward s t' os1 * forward t' t os2);\n     s \\<in> \\<S>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>ta\\<in>\\<S>.\n                         ennreal (pmf (\\<O> ta) a) *\n                         ennreal (pmf (\\<K> s) ta) *\n                         (\\<Sum>t'\\<in>\\<S>.\n                            forward ta t' os1 * forward t' t os2)) =\n                      (\\<Sum>t'\\<in>\\<S>.\n                         \\<Sum>n\\<in>\\<S>.\n                           ennreal (pmf (\\<O> n) a) *\n                           ennreal (pmf (\\<K> s) n) *\n                           forward n t' os1 *\n                           forward t' t os2)", "apply (subst sum.swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                s \\<in> \\<S> \\<Longrightarrow>\n                forward s t (os1 @ os2) =\n                (\\<Sum>t'\\<in>\\<S>. forward s t' os1 * forward t' t os2);\n     s \\<in> \\<S>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>ta\\<in>\\<S>.\n                         ennreal (pmf (\\<O> ta) a) *\n                         ennreal (pmf (\\<K> s) ta) *\n                         (\\<Sum>t'\\<in>\\<S>.\n                            forward ta t' os1 * forward t' t os2)) =\n                      (\\<Sum>j\\<in>\\<S>.\n                         \\<Sum>i\\<in>\\<S>.\n                           ennreal (pmf (\\<O> j) a) *\n                           ennreal (pmf (\\<K> s) j) *\n                           forward j i os1 *\n                           forward i t os2)", "apply (simp add: sum_distrib_left algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in -)\n  \"(\\<Sum>t \\<in> S. f t) = f t\" if \"finite S\" \"t \\<in> S\" \"\\<forall> s \\<in> S - {t}. f s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f S = f t", "thm sum.empty sum.insert sum.mono_neutral_right[of S \"{t}\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f S = f t", "apply (subst sum.mono_neutral_right[of S \"{t}\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite S\n 2. {t} \\<subseteq> S\n 3. \\<forall>i\\<in>S - {t}. f i = (0::'b)\n 4. sum f {t} = f t", "using that"], ["proof (prove)\nusing this:\n  finite S\n  t \\<in> S\n  \\<forall>s\\<in>S - {t}. f s = (0::'b)\n\ngoal (4 subgoals):\n 1. finite S\n 2. {t} \\<subseteq> S\n 3. \\<forall>i\\<in>S - {t}. f i = (0::'b)\n 4. sum f {t} = f t", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*\n  oops\n  by (metis add.right_neutral empty_iff finite.intros(1) insert_iff subsetI sum.empty sum.insert sum.mono_neutral_right that)\n\n  using that\n  apply auto\n*)"], ["", "lemma forward_backward:\n  \"(\\<Sum>t \\<in> \\<S>. forward s t os) = backward s os\" if \"s \\<in> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>\\<S>. forward s t os) = backward s os", "using \\<open>s \\<in> \\<S>\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>\\<S>. forward s t os) = backward s os", "apply (induction os arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> \\<S> \\<Longrightarrow>\n       (\\<Sum>t\\<in>\\<S>. forward s t []) = backward s []\n 2. \\<And>a os s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> \\<S> \\<Longrightarrow>\n                   (\\<Sum>t\\<in>\\<S>. forward s t os) = backward s os;\n        s \\<in> \\<S>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>t\\<in>\\<S>. forward s t (a # os)) =\n                         backward s (a # os)", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> \\<S> \\<Longrightarrow>\n    (\\<Sum>t\\<in>\\<S>. forward s t []) = backward s []", "by (subst sum.mono_neutral_right[of \\<S> \"{s}\", OF states_finite])\n       (auto split: if_split_asm simp: indicator_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> \\<S> \\<Longrightarrow>\n                   (\\<Sum>t\\<in>\\<S>. forward s t os) = backward s os;\n        s \\<in> \\<S>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>t\\<in>\\<S>. forward s t (a # os)) =\n                         backward s (a # os)", "subgoal for a os s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                s \\<in> \\<S> \\<Longrightarrow>\n                (\\<Sum>t\\<in>\\<S>. forward s t os) = backward s os;\n     s \\<in> \\<S>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>t\\<in>\\<S>. forward s t (a # os)) =\n                      backward s (a # os)", "apply (simp add: sum.swap sum_distrib_left[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s.\n                s \\<in> \\<S> \\<Longrightarrow>\n                (\\<Sum>t\\<in>\\<S>. forward s t os) = backward s os;\n     s \\<in> \\<S>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>j\\<in>\\<S>.\n                         ennreal (pmf (\\<O> j) a) *\n                         ennreal (pmf (\\<K> s) j) *\n                         backward j os) =\n                      \\<integral>\\<^sup>+ t.\n     ennreal (pmf (\\<O> t) a) * backward t os\n   \\<partial>measure_pmf (\\<K> s)", "apply (subst nn_integral_measure_pmf_support[where A = \\<S>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>s.\n                s \\<in> \\<S> \\<Longrightarrow>\n                (\\<Sum>t\\<in>\\<S>. forward s t os) = backward s os;\n     s \\<in> \\<S>\\<rbrakk>\n    \\<Longrightarrow> finite \\<S>\n 2. \\<And>x.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> \\<S> \\<Longrightarrow>\n                   (\\<Sum>t\\<in>\\<S>. forward s t os) = backward s os;\n        s \\<in> \\<S>; x \\<in> \\<S>\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ennreal (pmf (\\<O> x) a) * backward x os\n 3. \\<And>x.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> \\<S> \\<Longrightarrow>\n                   (\\<Sum>t\\<in>\\<S>. forward s t os) = backward s os;\n        s \\<in> \\<S>; x \\<in> set_pmf (\\<K> s); x \\<notin> \\<S>\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (\\<O> x) a) * backward x os = 0\n 4. \\<lbrakk>\\<And>s.\n                s \\<in> \\<S> \\<Longrightarrow>\n                (\\<Sum>t\\<in>\\<S>. forward s t os) = backward s os;\n     s \\<in> \\<S>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>j\\<in>\\<S>.\n                         ennreal (pmf (\\<O> j) a) *\n                         ennreal (pmf (\\<K> s) j) *\n                         backward j os) =\n                      (\\<Sum>x\\<in>\\<S>.\n                         ennreal (pmf (\\<O> x) a) * backward x os *\n                         ennreal (pmf (\\<K> s) x))", "using states_finite states_closed"], ["proof (prove)\nusing this:\n  finite \\<S>\n  \\<forall>s. set_pmf (\\<K> s) \\<subseteq> \\<S>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>s.\n                s \\<in> \\<S> \\<Longrightarrow>\n                (\\<Sum>t\\<in>\\<S>. forward s t os) = backward s os;\n     s \\<in> \\<S>\\<rbrakk>\n    \\<Longrightarrow> finite \\<S>\n 2. \\<And>x.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> \\<S> \\<Longrightarrow>\n                   (\\<Sum>t\\<in>\\<S>. forward s t os) = backward s os;\n        s \\<in> \\<S>; x \\<in> \\<S>\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ennreal (pmf (\\<O> x) a) * backward x os\n 3. \\<And>x.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> \\<S> \\<Longrightarrow>\n                   (\\<Sum>t\\<in>\\<S>. forward s t os) = backward s os;\n        s \\<in> \\<S>; x \\<in> set_pmf (\\<K> s); x \\<notin> \\<S>\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (\\<O> x) a) * backward x os = 0\n 4. \\<lbrakk>\\<And>s.\n                s \\<in> \\<S> \\<Longrightarrow>\n                (\\<Sum>t\\<in>\\<S>. forward s t os) = backward s os;\n     s \\<in> \\<S>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>j\\<in>\\<S>.\n                         ennreal (pmf (\\<O> j) a) *\n                         ennreal (pmf (\\<K> s) j) *\n                         backward j os) =\n                      (\\<Sum>x\\<in>\\<S>.\n                         ennreal (pmf (\\<O> x) a) * backward x os *\n                         ennreal (pmf (\\<K> s) x))", "by (auto simp: algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem likelihood_forward:\n  \"likelihood s os = (\\<Sum>t \\<in> \\<S>. forward s t os)\" if \\<open>s \\<in> \\<S>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. likelihood s os = (\\<Sum>t\\<in>\\<S>. forward s t os)", "unfolding likelihood_backward forward_backward[symmetric, OF \\<open>s \\<in> \\<S>\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>\\<S>. forward s t os) = (\\<Sum>t\\<in>\\<S>. forward s t os)", ".."], ["", "subsection \\<open>Definition of Maximum Probabilities\\<close>"], ["", "abbreviation (input) \"V os as \\<omega> \\<equiv> (\\<exists> \\<omega>'. \\<omega> = zip as os @- \\<omega>')\""], ["", "definition\n  \"max_prob s os =\n  Max {T' (I s) {\\<omega> \\<in> space S. \\<exists>o \\<omega>'. \\<omega> = (s, o) ## zip as os @- \\<omega>'}\n       | as. length as = length os \\<and> set as \\<subseteq> \\<S>}\""], ["", "fun viterbi_prob where\n  \"viterbi_prob s t_end [] = indicator {t_end} s\" |\n  \"viterbi_prob s t_end (o # os) =\n    (MAX t \\<in> \\<S>. ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * viterbi_prob t t_end os)\""], ["", "definition\n  \"is_decoding s os as \\<equiv>\n    T' (I s) {\\<omega> \\<in> space S. \\<exists>o \\<omega>'. \\<omega> = (s, o) ## zip as os @- \\<omega>'} = max_prob s os \\<and>\n    length as = length os \\<and> set as \\<subseteq> \\<S>\""], ["", "subsection \\<open>Iteration Rule For Maximum Probabilities\\<close>"], ["", "lemma emeasure_T_state_Nil:\n  \"T (s, o\\<^sub>0) {\\<omega> \\<in> space S. V [] as \\<omega>} = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>0))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as [] @- \\<omega>'} =\n    1", "by simp"], ["", "lemma max_prob_T_state_Nil:\n  \"Max {T (s, o) {\\<omega> \\<in> space S. V [] as \\<omega>} | as. length as = length [] \\<and> set as \\<subseteq> \\<S>} = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {emeasure (T (s, o))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as [] @- \\<omega>'} |\n         as. length as = length [] \\<and> set as \\<subseteq> \\<S>} =\n    1", "by (simp add: emeasure_T_state_Nil)"], ["", "lemma V_Cons: \"V (o # os) (a # as) \\<omega> \\<longleftrightarrow> fst (shd \\<omega>) = a \\<and> snd (shd \\<omega>) = o \\<and> V os as (stl \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<omega>'. \\<omega> = zip (a # as) (o # os) @- \\<omega>') =\n    (fst (shd \\<omega>) = a \\<and>\n     snd (shd \\<omega>) = o \\<and>\n     (\\<exists>\\<omega>'. stl \\<omega> = zip as os @- \\<omega>'))", "by (cases \\<omega>) auto"], ["", "lemma measurable_V[measurable]:\n  \"Measurable.pred S (\\<lambda>\\<omega>. V os as \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>\\<omega>.\n         \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>')", "proof (induction os as rule: list_induct2')"], ["proof (state)\ngoal (4 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>\\<omega>.\n         \\<exists>\\<omega>'. \\<omega> = zip [] [] @- \\<omega>')\n 2. \\<And>x xs.\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            \\<exists>\\<omega>'. \\<omega> = zip [] (x # xs) @- \\<omega>')\n 3. \\<And>y ys.\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            \\<exists>\\<omega>'. \\<omega> = zip (y # ys) [] @- \\<omega>')\n 4. \\<And>x xs y ys.\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            \\<exists>\\<omega>'.\n               \\<omega> = zip ys xs @- \\<omega>') \\<Longrightarrow>\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            \\<exists>\\<omega>'.\n               \\<omega> = zip (y # ys) (x # xs) @- \\<omega>')", "case (4 x xs y ys)"], ["proof (state)\nthis:\n  Measurable.pred (stream_space (count_space UNIV))\n   (\\<lambda>\\<omega>.\n       \\<exists>\\<omega>'. \\<omega> = zip ys xs @- \\<omega>')\n\ngoal (4 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>\\<omega>.\n         \\<exists>\\<omega>'. \\<omega> = zip [] [] @- \\<omega>')\n 2. \\<And>x xs.\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            \\<exists>\\<omega>'. \\<omega> = zip [] (x # xs) @- \\<omega>')\n 3. \\<And>y ys.\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            \\<exists>\\<omega>'. \\<omega> = zip (y # ys) [] @- \\<omega>')\n 4. \\<And>x xs y ys.\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            \\<exists>\\<omega>'.\n               \\<omega> = zip ys xs @- \\<omega>') \\<Longrightarrow>\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            \\<exists>\\<omega>'.\n               \\<omega> = zip (y # ys) (x # xs) @- \\<omega>')", "then"], ["proof (chain)\npicking this:\n  Measurable.pred (stream_space (count_space UNIV))\n   (\\<lambda>\\<omega>.\n       \\<exists>\\<omega>'. \\<omega> = zip ys xs @- \\<omega>')", "show ?case"], ["proof (prove)\nusing this:\n  Measurable.pred (stream_space (count_space UNIV))\n   (\\<lambda>\\<omega>.\n       \\<exists>\\<omega>'. \\<omega> = zip ys xs @- \\<omega>')\n\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>\\<omega>.\n         \\<exists>\\<omega>'. \\<omega> = zip (y # ys) (x # xs) @- \\<omega>')", "by (subst V_Cons)\n       (intro Measurable.pred_intros_logic\n          measurable_compose[OF measurable_shd] measurable_compose[OF measurable_stl];\n        measurable)"], ["proof (state)\nthis:\n  Measurable.pred (stream_space (count_space UNIV))\n   (\\<lambda>\\<omega>.\n       \\<exists>\\<omega>'. \\<omega> = zip (y # ys) (x # xs) @- \\<omega>')\n\ngoal (3 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>\\<omega>.\n         \\<exists>\\<omega>'. \\<omega> = zip [] [] @- \\<omega>')\n 2. \\<And>x xs.\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            \\<exists>\\<omega>'. \\<omega> = zip [] (x # xs) @- \\<omega>')\n 3. \\<And>y ys.\n       Measurable.pred (stream_space (count_space UNIV))\n        (\\<lambda>\\<omega>.\n            \\<exists>\\<omega>'. \\<omega> = zip (y # ys) [] @- \\<omega>')", "qed simp+"], ["", "lemma init_V_measurable[measurable]:\n  \"Measurable.pred S (\\<lambda>x. \\<exists>o \\<omega>'. x = (s, o) ## zip as os @- \\<omega>')\" (is \"Measurable.pred S ?f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>x.\n         \\<exists>o \\<omega>'. x = (s, o) ## zip as os @- \\<omega>')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>x.\n         \\<exists>o \\<omega>'. x = (s, o) ## zip as os @- \\<omega>')", "have *: \"?f \\<omega> \\<longleftrightarrow> fst (shd \\<omega>) = s \\<and> V os as (stl \\<omega>)\" for \\<omega>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>o \\<omega>'. \\<omega> = (s, o) ## zip as os @- \\<omega>') =\n    (fst (shd \\<omega>) = s \\<and>\n     (\\<exists>\\<omega>'. stl \\<omega> = zip as os @- \\<omega>'))", "by (cases \\<omega>) auto"], ["proof (state)\nthis:\n  (\\<exists>o \\<omega>'. ?\\<omega>1 = (s, o) ## zip as os @- \\<omega>') =\n  (fst (shd ?\\<omega>1) = s \\<and>\n   (\\<exists>\\<omega>'. stl ?\\<omega>1 = zip as os @- \\<omega>'))\n\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>x.\n         \\<exists>o \\<omega>'. x = (s, o) ## zip as os @- \\<omega>')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>x.\n         \\<exists>o \\<omega>'. x = (s, o) ## zip as os @- \\<omega>')", "by (subst *)\n       (intro Measurable.pred_intros_logic measurable_compose[OF measurable_shd]; measurable)"], ["proof (state)\nthis:\n  Measurable.pred (stream_space (count_space UNIV))\n   (\\<lambda>x. \\<exists>o \\<omega>'. x = (s, o) ## zip as os @- \\<omega>')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_prob_Cons':\n  \"Max {T (s, o\\<^sub>1) {\\<omega> \\<in> space S. V (o # os) as \\<omega>} | as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n  (\n    MAX t \\<in> \\<S>. ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n      (MAX as \\<in> {as. length as = length os \\<and> set as \\<subseteq> \\<S>}. T (t, o) {\\<omega> \\<in> space S. V os as \\<omega>})\n  )\" (is \"?l = ?r\")\n  and T_V_Cons:\n  \"T (s, o\\<^sub>1) {\\<omega> \\<in> space S. V (o # os) (t # as) \\<omega>}\n  = ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * T (t, o) {\\<omega> \\<in> space S. V os as \\<omega>}\"\n  (is \"?l' = ?r'\")\n  if \"length as = length os\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'})) &&&\n    emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "let ?S = \"\\<lambda> os. {as. length as = length os \\<and> set as \\<subseteq> \\<S>}\""], ["proof (state)\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "have S_finite: \"finite (?S os)\" for os :: \"'t list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {as. length as = length os \\<and> set as \\<subseteq> \\<S>}", "using finite_lists_length_eq[OF states_finite]"], ["proof (prove)\nusing this:\n  finite {xs. set xs \\<subseteq> \\<S> \\<and> length xs = ?n}\n\ngoal (1 subgoal):\n 1. finite {as. length as = length os \\<and> set as \\<subseteq> \\<S>}", "by (rule finite_subset[rotated]) auto"], ["proof (state)\nthis:\n  finite {as. length as = length ?os3 \\<and> set as \\<subseteq> \\<S>}\n\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "have S_nonempty: \"?S os \\<noteq> {}\" for os :: \"'t list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {as. length as = length os \\<and> set as \\<subseteq> \\<S>} \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {as. length as = length os \\<and> set as \\<subseteq> \\<S>} \\<noteq> {}", "let ?a = \"SOME a. a \\<in> \\<S>\""], ["proof (state)\ngoal (1 subgoal):\n 1. {as. length as = length os \\<and> set as \\<subseteq> \\<S>} \\<noteq> {}", "let ?as = \"replicate (length os) ?a\""], ["proof (state)\ngoal (1 subgoal):\n 1. {as. length as = length os \\<and> set as \\<subseteq> \\<S>} \\<noteq> {}", "from states_wellformed"], ["proof (chain)\npicking this:\n  \\<S> \\<noteq> {}", "have \"?a \\<in> \\<S>\""], ["proof (prove)\nusing this:\n  \\<S> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (SOME a. a \\<in> \\<S>) \\<in> \\<S>", "by (auto intro: someI_ex)"], ["proof (state)\nthis:\n  (SOME a. a \\<in> \\<S>) \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. {as. length as = length os \\<and> set as \\<subseteq> \\<S>} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  (SOME a. a \\<in> \\<S>) \\<in> \\<S>", "have \"?as \\<in> ?S os\""], ["proof (prove)\nusing this:\n  (SOME a. a \\<in> \\<S>) \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. replicate (length os) (SOME a. a \\<in> \\<S>)\n    \\<in> {as. length as = length os \\<and> set as \\<subseteq> \\<S>}", "by auto"], ["proof (state)\nthis:\n  replicate (length os) (SOME a. a \\<in> \\<S>)\n  \\<in> {as. length as = length os \\<and> set as \\<subseteq> \\<S>}\n\ngoal (1 subgoal):\n 1. {as. length as = length os \\<and> set as \\<subseteq> \\<S>} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  replicate (length os) (SOME a. a \\<in> \\<S>)\n  \\<in> {as. length as = length os \\<and> set as \\<subseteq> \\<S>}", "show ?thesis"], ["proof (prove)\nusing this:\n  replicate (length os) (SOME a. a \\<in> \\<S>)\n  \\<in> {as. length as = length os \\<and> set as \\<subseteq> \\<S>}\n\ngoal (1 subgoal):\n 1. {as. length as = length os \\<and> set as \\<subseteq> \\<S>} \\<noteq> {}", "by force"], ["proof (state)\nthis:\n  {as. length as = length os \\<and> set as \\<subseteq> \\<S>} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {as. length as = length ?os4 \\<and> set as \\<subseteq> \\<S>} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "let ?f = \"\\<lambda>t as os. T t {\\<omega> \\<in> space S. V os as (t ## \\<omega>)}\""], ["proof (state)\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "let ?g = \"\\<lambda>t as os. T t {\\<omega> \\<in> space S. V os as \\<omega>}\""], ["proof (state)\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "have *: \"?f t as (o # os) = ?g t (tl as) os * indicator {(hd as, o)} t\"\n    if \"length as = Suc n\" for t as n"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T t)\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. t ## \\<omega> = zip as (o # os) @- \\<omega>'} =\n    emeasure (T t)\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (tl as) os @- \\<omega>'} *\n    indicator {(hd as, o)} t", "unfolding indicator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T t)\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. t ## \\<omega> = zip as (o # os) @- \\<omega>'} =\n    emeasure (T t)\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (tl as) os @- \\<omega>'} *\n    (if t \\<in> {(hd as, o)} then 1 else 0)", "using that"], ["proof (prove)\nusing this:\n  length as = Suc n\n\ngoal (1 subgoal):\n 1. emeasure (T t)\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. t ## \\<omega> = zip as (o # os) @- \\<omega>'} =\n    emeasure (T t)\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (tl as) os @- \\<omega>'} *\n    (if t \\<in> {(hd as, o)} then 1 else 0)", "by (cases as) auto"], ["proof (state)\nthis:\n  length ?as4 = Suc ?n4 \\<Longrightarrow>\n  emeasure (T ?t4)\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. ?t4 ## \\<omega> = zip ?as4 (o # os) @- \\<omega>'} =\n  emeasure (T ?t4)\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip (tl ?as4) os @- \\<omega>'} *\n  indicator {(hd ?as4, o)} ?t4\n\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "have **: \"K (s, o\\<^sub>1) {(t, o)} = pmf (\\<O> t) o * pmf (\\<K> s) t\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (K (s, o\\<^sub>1))) {(t, o)} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t)", "unfolding K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure\n     (measure_pmf\n       (case (s, o\\<^sub>1) of\n        (s\\<^sub>1, o\\<^sub>1) \\<Rightarrow>\n          \\<K> s\\<^sub>1 \\<bind>\n          (\\<lambda>s\\<^sub>2. map_pmf (Pair s\\<^sub>2) (\\<O> s\\<^sub>2))))\n     {(t, o)} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t)", "apply (simp add: vimage_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure (measure_pmf (\\<O> x))\n                            {xa. xa = o \\<and> x = t}\n                       \\<partial>measure_pmf (\\<K> s) =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t)", "apply (subst arg_cong2[where\n          f = nn_integral and d = \"\\<lambda> x. \\<O> x {xa. xa = o \\<and> x = t} * indicator {t} x\",\n          OF HOL.refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x.\n        emeasure (measure_pmf (\\<O> x)) {xa. xa = o \\<and> x = t}) =\n    (\\<lambda>x.\n        emeasure (measure_pmf (\\<O> x)) {xa. xa = o \\<and> x = t} *\n        indicator {t} x)\n 2. \\<integral>\\<^sup>+x\\<in>{t}.\n                       emeasure (measure_pmf (\\<O> x))\n                        {xa. xa = o \\<and> x = t}\n    \\<partial>measure_pmf (\\<K> s) =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        emeasure (measure_pmf (\\<O> x)) {xa. xa = o \\<and> x = t}) =\n    (\\<lambda>x.\n        emeasure (measure_pmf (\\<O> x)) {xa. xa = o \\<and> x = t} *\n        indicator {t} x)", "by (auto simp: indicator_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{t}.\n                       emeasure (measure_pmf (\\<O> x))\n                        {xa. xa = o \\<and> x = t}\n    \\<partial>measure_pmf (\\<K> s) =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t)", "by (simp add: emeasure_pmf_single ennreal_mult')"], ["proof (state)\nthis:\n  emeasure (measure_pmf (K (s, o\\<^sub>1))) {(?t4, o)} =\n  ennreal (pmf (\\<O> ?t4) o * pmf (\\<K> s) ?t4)\n\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "have \"?l = (MAX as \\<in> ?S (o # os). \\<integral>\\<^sup>+ t. ?f t as (o # os) \\<partial>K (s, o\\<^sub>1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX as\\<in>{as.\n                 length as = length (o # os) \\<and>\n                 set as \\<subseteq> \\<S>}.\n        \\<integral>\\<^sup>+ t. emeasure (T t)\n                                {\\<omega>\n                                 \\<in> space\n  (stream_space (count_space UNIV)).\n                                 \\<exists>\\<omega>'.\n                                    t ## \\<omega> =\n                                    zip as (o # os) @- \\<omega>'}\n                           \\<partial>measure_pmf (K (s, o\\<^sub>1)))", "by (subst Max_to_image2; subst emeasure_Collect_T[unfolded space_T]; rule measurable_V HOL.refl)"], ["proof (state)\nthis:\n  Max {emeasure (T (s, o\\<^sub>1))\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n       as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n  (MAX as\\<in>{as.\n               length as = length (o # os) \\<and> set as \\<subseteq> \\<S>}.\n      \\<integral>\\<^sup>+ t. emeasure (T t)\n                              {\\<omega>\n                               \\<in> space\n(stream_space (count_space UNIV)).\n                               \\<exists>\\<omega>'.\n                                  t ## \\<omega> =\n                                  zip as (o # os) @- \\<omega>'}\n                         \\<partial>measure_pmf (K (s, o\\<^sub>1)))\n\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "also"], ["proof (state)\nthis:\n  Max {emeasure (T (s, o\\<^sub>1))\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n       as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n  (MAX as\\<in>{as.\n               length as = length (o # os) \\<and> set as \\<subseteq> \\<S>}.\n      \\<integral>\\<^sup>+ t. emeasure (T t)\n                              {\\<omega>\n                               \\<in> space\n(stream_space (count_space UNIV)).\n                               \\<exists>\\<omega>'.\n                                  t ## \\<omega> =\n                                  zip as (o # os) @- \\<omega>'}\n                         \\<partial>measure_pmf (K (s, o\\<^sub>1)))\n\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "have \"\\<dots> = (MAX as \\<in> ?S (o # os). \\<integral>\\<^sup>+ t. ?g t (tl as) os * indicator {(hd as,o)} t \\<partial>K (s,o\\<^sub>1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MAX as\\<in>{as.\n                 length as = length (o # os) \\<and>\n                 set as \\<subseteq> \\<S>}.\n        \\<integral>\\<^sup>+ t. emeasure (T t)\n                                {\\<omega>\n                                 \\<in> space\n  (stream_space (count_space UNIV)).\n                                 \\<exists>\\<omega>'.\n                                    t ## \\<omega> =\n                                    zip as (o # os) @- \\<omega>'}\n                           \\<partial>measure_pmf (K (s, o\\<^sub>1))) =\n    (MAX as\\<in>{as.\n                 length as = length (o # os) \\<and>\n                 set as \\<subseteq> \\<S>}.\n        \\<integral>\\<^sup>+t\\<in>{(hd as, o)}.\n                           emeasure (T t)\n                            {\\<omega>\n                             \\<in> space (stream_space (count_space UNIV)).\n                             \\<exists>\\<omega>'.\n                                \\<omega> = zip (tl as) os @- \\<omega>'}\n        \\<partial>measure_pmf (K (s, o\\<^sub>1)))", "by (simp cong: Max_image_cong_simp add: *)"], ["proof (state)\nthis:\n  (MAX as\\<in>{as.\n               length as = length (o # os) \\<and> set as \\<subseteq> \\<S>}.\n      \\<integral>\\<^sup>+ t. emeasure (T t)\n                              {\\<omega>\n                               \\<in> space\n(stream_space (count_space UNIV)).\n                               \\<exists>\\<omega>'.\n                                  t ## \\<omega> =\n                                  zip as (o # os) @- \\<omega>'}\n                         \\<partial>measure_pmf (K (s, o\\<^sub>1))) =\n  (MAX as\\<in>{as.\n               length as = length (o # os) \\<and> set as \\<subseteq> \\<S>}.\n      \\<integral>\\<^sup>+t\\<in>{(hd as, o)}.\n                         emeasure (T t)\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>\\<omega>'.\n                              \\<omega> = zip (tl as) os @- \\<omega>'}\n      \\<partial>measure_pmf (K (s, o\\<^sub>1)))\n\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "also"], ["proof (state)\nthis:\n  (MAX as\\<in>{as.\n               length as = length (o # os) \\<and> set as \\<subseteq> \\<S>}.\n      \\<integral>\\<^sup>+ t. emeasure (T t)\n                              {\\<omega>\n                               \\<in> space\n(stream_space (count_space UNIV)).\n                               \\<exists>\\<omega>'.\n                                  t ## \\<omega> =\n                                  zip as (o # os) @- \\<omega>'}\n                         \\<partial>measure_pmf (K (s, o\\<^sub>1))) =\n  (MAX as\\<in>{as.\n               length as = length (o # os) \\<and> set as \\<subseteq> \\<S>}.\n      \\<integral>\\<^sup>+t\\<in>{(hd as, o)}.\n                         emeasure (T t)\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>\\<omega>'.\n                              \\<omega> = zip (tl as) os @- \\<omega>'}\n      \\<partial>measure_pmf (K (s, o\\<^sub>1)))\n\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "have \"\\<dots> = (MAX(t, as)\\<in> \\<S> \\<times> ?S os. ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * ?g (t, o) as os)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MAX as\\<in>{as.\n                 length as = length (o # os) \\<and>\n                 set as \\<subseteq> \\<S>}.\n        \\<integral>\\<^sup>+t\\<in>{(hd as, o)}.\n                           emeasure (T t)\n                            {\\<omega>\n                             \\<in> space (stream_space (count_space UNIV)).\n                             \\<exists>\\<omega>'.\n                                \\<omega> = zip (tl as) os @- \\<omega>'}\n        \\<partial>measure_pmf (K (s, o\\<^sub>1))) =\n    (MAX (t,\n        as)\\<in>\\<S> \\<times>\n                {as. length as = length os \\<and> set as \\<subseteq> \\<S>}.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        emeasure (T (t, o))\n         {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n          \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'})", "proof ((rule Max_eq_image_if; clarsimp?), goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite {as. length as = Suc (length os) \\<and> set as \\<subseteq> \\<S>}\n 2. finite\n     (\\<S> \\<times>\n      {as. length as = length os \\<and> set as \\<subseteq> \\<S>})\n 3. \\<And>x.\n       \\<lbrakk>length x = Suc (length os); set x \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>\\<S>.\n                            \\<exists>y.\n                               length y = length os \\<and>\n                               set y \\<subseteq> \\<S> \\<and>\n                               emeasure (T (hd x, o))\n                                {\\<omega>\n                                 \\<in> space\n  (stream_space (count_space UNIV)).\n                                 \\<exists>\\<omega>'.\n                                    \\<omega> = zip (tl x) os @- \\<omega>'} *\n                               emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                {(hd x, o)}\n                               \\<le> ennreal\n(pmf (\\<O> xa) o * pmf (\\<K> s) xa) *\n                                     emeasure (T (xa, o))\n{\\<omega> \\<in> space (stream_space (count_space UNIV)).\n \\<exists>\\<omega>'. \\<omega> = zip y os @- \\<omega>'}\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<S>; length y = length os;\n        set y \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            length ya = Suc (length os) \\<and>\n                            set ya \\<subseteq> \\<S> \\<and>\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            emeasure (T (x, o))\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              \\<exists>\\<omega>'.\n                                 \\<omega> = zip y os @- \\<omega>'}\n                            \\<le> emeasure (T (hd ya, o))\n                                   {\\<omega>\n                                    \\<in> space\n     (stream_space (count_space UNIV)).\n                                    \\<exists>\\<omega>'.\n \\<omega> = zip (tl ya) os @- \\<omega>'} *\n                                  emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                   {(hd ya, o)}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. finite {as. length as = Suc (length os) \\<and> set as \\<subseteq> \\<S>}\n 2. finite\n     (\\<S> \\<times>\n      {as. length as = length os \\<and> set as \\<subseteq> \\<S>})\n 3. \\<And>x.\n       \\<lbrakk>length x = Suc (length os); set x \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>\\<S>.\n                            \\<exists>y.\n                               length y = length os \\<and>\n                               set y \\<subseteq> \\<S> \\<and>\n                               emeasure (T (hd x, o))\n                                {\\<omega>\n                                 \\<in> space\n  (stream_space (count_space UNIV)).\n                                 \\<exists>\\<omega>'.\n                                    \\<omega> = zip (tl x) os @- \\<omega>'} *\n                               emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                {(hd x, o)}\n                               \\<le> ennreal\n(pmf (\\<O> xa) o * pmf (\\<K> s) xa) *\n                                     emeasure (T (xa, o))\n{\\<omega> \\<in> space (stream_space (count_space UNIV)).\n \\<exists>\\<omega>'. \\<omega> = zip y os @- \\<omega>'}\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<S>; length y = length os;\n        set y \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            length ya = Suc (length os) \\<and>\n                            set ya \\<subseteq> \\<S> \\<and>\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            emeasure (T (x, o))\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              \\<exists>\\<omega>'.\n                                 \\<omega> = zip y os @- \\<omega>'}\n                            \\<le> emeasure (T (hd ya, o))\n                                   {\\<omega>\n                                    \\<in> space\n     (stream_space (count_space UNIV)).\n                                    \\<exists>\\<omega>'.\n \\<omega> = zip (tl ya) os @- \\<omega>'} *\n                                  emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                   {(hd ya, o)}", "from S_finite[of \"o # os\"]"], ["proof (chain)\npicking this:\n  finite {as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>}", "show ?case"], ["proof (prove)\nusing this:\n  finite {as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>}\n\ngoal (1 subgoal):\n 1. finite {as. length as = Suc (length os) \\<and> set as \\<subseteq> \\<S>}", "by simp"], ["proof (state)\nthis:\n  finite {as. length as = Suc (length os) \\<and> set as \\<subseteq> \\<S>}\n\ngoal (3 subgoals):\n 1. finite\n     (\\<S> \\<times>\n      {as. length as = length os \\<and> set as \\<subseteq> \\<S>})\n 2. \\<And>x.\n       \\<lbrakk>length x = Suc (length os); set x \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>\\<S>.\n                            \\<exists>y.\n                               length y = length os \\<and>\n                               set y \\<subseteq> \\<S> \\<and>\n                               emeasure (T (hd x, o))\n                                {\\<omega>\n                                 \\<in> space\n  (stream_space (count_space UNIV)).\n                                 \\<exists>\\<omega>'.\n                                    \\<omega> = zip (tl x) os @- \\<omega>'} *\n                               emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                {(hd x, o)}\n                               \\<le> ennreal\n(pmf (\\<O> xa) o * pmf (\\<K> s) xa) *\n                                     emeasure (T (xa, o))\n{\\<omega> \\<in> space (stream_space (count_space UNIV)).\n \\<exists>\\<omega>'. \\<omega> = zip y os @- \\<omega>'}\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<S>; length y = length os;\n        set y \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            length ya = Suc (length os) \\<and>\n                            set ya \\<subseteq> \\<S> \\<and>\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            emeasure (T (x, o))\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              \\<exists>\\<omega>'.\n                                 \\<omega> = zip y os @- \\<omega>'}\n                            \\<le> emeasure (T (hd ya, o))\n                                   {\\<omega>\n                                    \\<in> space\n     (stream_space (count_space UNIV)).\n                                    \\<exists>\\<omega>'.\n \\<omega> = zip (tl ya) os @- \\<omega>'} *\n                                  emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                   {(hd ya, o)}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. finite\n     (\\<S> \\<times>\n      {as. length as = length os \\<and> set as \\<subseteq> \\<S>})\n 2. \\<And>x.\n       \\<lbrakk>length x = Suc (length os); set x \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>\\<S>.\n                            \\<exists>y.\n                               length y = length os \\<and>\n                               set y \\<subseteq> \\<S> \\<and>\n                               emeasure (T (hd x, o))\n                                {\\<omega>\n                                 \\<in> space\n  (stream_space (count_space UNIV)).\n                                 \\<exists>\\<omega>'.\n                                    \\<omega> = zip (tl x) os @- \\<omega>'} *\n                               emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                {(hd x, o)}\n                               \\<le> ennreal\n(pmf (\\<O> xa) o * pmf (\\<K> s) xa) *\n                                     emeasure (T (xa, o))\n{\\<omega> \\<in> space (stream_space (count_space UNIV)).\n \\<exists>\\<omega>'. \\<omega> = zip y os @- \\<omega>'}\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<S>; length y = length os;\n        set y \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            length ya = Suc (length os) \\<and>\n                            set ya \\<subseteq> \\<S> \\<and>\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            emeasure (T (x, o))\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              \\<exists>\\<omega>'.\n                                 \\<omega> = zip y os @- \\<omega>'}\n                            \\<le> emeasure (T (hd ya, o))\n                                   {\\<omega>\n                                    \\<in> space\n     (stream_space (count_space UNIV)).\n                                    \\<exists>\\<omega>'.\n \\<omega> = zip (tl ya) os @- \\<omega>'} *\n                                  emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                   {(hd ya, o)}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. finite\n     (\\<S> \\<times>\n      {as. length as = length os \\<and> set as \\<subseteq> \\<S>})\n 2. \\<And>x.\n       \\<lbrakk>length x = Suc (length os); set x \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>\\<S>.\n                            \\<exists>y.\n                               length y = length os \\<and>\n                               set y \\<subseteq> \\<S> \\<and>\n                               emeasure (T (hd x, o))\n                                {\\<omega>\n                                 \\<in> space\n  (stream_space (count_space UNIV)).\n                                 \\<exists>\\<omega>'.\n                                    \\<omega> = zip (tl x) os @- \\<omega>'} *\n                               emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                {(hd x, o)}\n                               \\<le> ennreal\n(pmf (\\<O> xa) o * pmf (\\<K> s) xa) *\n                                     emeasure (T (xa, o))\n{\\<omega> \\<in> space (stream_space (count_space UNIV)).\n \\<exists>\\<omega>'. \\<omega> = zip y os @- \\<omega>'}\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<S>; length y = length os;\n        set y \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            length ya = Suc (length os) \\<and>\n                            set ya \\<subseteq> \\<S> \\<and>\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            emeasure (T (x, o))\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              \\<exists>\\<omega>'.\n                                 \\<omega> = zip y os @- \\<omega>'}\n                            \\<le> emeasure (T (hd ya, o))\n                                   {\\<omega>\n                                    \\<in> space\n     (stream_space (count_space UNIV)).\n                                    \\<exists>\\<omega>'.\n \\<omega> = zip (tl ya) os @- \\<omega>'} *\n                                  emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                   {(hd ya, o)}", "from states_finite"], ["proof (chain)\npicking this:\n  finite \\<S>", "show ?case"], ["proof (prove)\nusing this:\n  finite \\<S>\n\ngoal (1 subgoal):\n 1. finite\n     (\\<S> \\<times>\n      {as. length as = length os \\<and> set as \\<subseteq> \\<S>})", "by (blast intro: S_finite)"], ["proof (state)\nthis:\n  finite\n   (\\<S> \\<times>\n    {as. length as = length os \\<and> set as \\<subseteq> \\<S>})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length x = Suc (length os); set x \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>\\<S>.\n                            \\<exists>y.\n                               length y = length os \\<and>\n                               set y \\<subseteq> \\<S> \\<and>\n                               emeasure (T (hd x, o))\n                                {\\<omega>\n                                 \\<in> space\n  (stream_space (count_space UNIV)).\n                                 \\<exists>\\<omega>'.\n                                    \\<omega> = zip (tl x) os @- \\<omega>'} *\n                               emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                {(hd x, o)}\n                               \\<le> ennreal\n(pmf (\\<O> xa) o * pmf (\\<K> s) xa) *\n                                     emeasure (T (xa, o))\n{\\<omega> \\<in> space (stream_space (count_space UNIV)).\n \\<exists>\\<omega>'. \\<omega> = zip y os @- \\<omega>'}\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<S>; length y = length os;\n        set y \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            length ya = Suc (length os) \\<and>\n                            set ya \\<subseteq> \\<S> \\<and>\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            emeasure (T (x, o))\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              \\<exists>\\<omega>'.\n                                 \\<omega> = zip y os @- \\<omega>'}\n                            \\<le> emeasure (T (hd ya, o))\n                                   {\\<omega>\n                                    \\<in> space\n     (stream_space (count_space UNIV)).\n                                    \\<exists>\\<omega>'.\n \\<omega> = zip (tl ya) os @- \\<omega>'} *\n                                  emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                   {(hd ya, o)}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length x = Suc (length os); set x \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>\\<S>.\n                            \\<exists>y.\n                               length y = length os \\<and>\n                               set y \\<subseteq> \\<S> \\<and>\n                               emeasure (T (hd x, o))\n                                {\\<omega>\n                                 \\<in> space\n  (stream_space (count_space UNIV)).\n                                 \\<exists>\\<omega>'.\n                                    \\<omega> = zip (tl x) os @- \\<omega>'} *\n                               emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                {(hd x, o)}\n                               \\<le> ennreal\n(pmf (\\<O> xa) o * pmf (\\<K> s) xa) *\n                                     emeasure (T (xa, o))\n{\\<omega> \\<in> space (stream_space (count_space UNIV)).\n \\<exists>\\<omega>'. \\<omega> = zip y os @- \\<omega>'}\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<S>; length y = length os;\n        set y \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            length ya = Suc (length os) \\<and>\n                            set ya \\<subseteq> \\<S> \\<and>\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            emeasure (T (x, o))\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              \\<exists>\\<omega>'.\n                                 \\<omega> = zip y os @- \\<omega>'}\n                            \\<le> emeasure (T (hd ya, o))\n                                   {\\<omega>\n                                    \\<in> space\n     (stream_space (count_space UNIV)).\n                                    \\<exists>\\<omega>'.\n \\<omega> = zip (tl ya) os @- \\<omega>'} *\n                                  emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                   {(hd ya, o)}", "case (3 as)"], ["proof (state)\nthis:\n  length as = Suc (length os)\n  set as \\<subseteq> \\<S>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>length x = Suc (length os); set x \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>\\<S>.\n                            \\<exists>y.\n                               length y = length os \\<and>\n                               set y \\<subseteq> \\<S> \\<and>\n                               emeasure (T (hd x, o))\n                                {\\<omega>\n                                 \\<in> space\n  (stream_space (count_space UNIV)).\n                                 \\<exists>\\<omega>'.\n                                    \\<omega> = zip (tl x) os @- \\<omega>'} *\n                               emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                {(hd x, o)}\n                               \\<le> ennreal\n(pmf (\\<O> xa) o * pmf (\\<K> s) xa) *\n                                     emeasure (T (xa, o))\n{\\<omega> \\<in> space (stream_space (count_space UNIV)).\n \\<exists>\\<omega>'. \\<omega> = zip y os @- \\<omega>'}\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<S>; length y = length os;\n        set y \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            length ya = Suc (length os) \\<and>\n                            set ya \\<subseteq> \\<S> \\<and>\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            emeasure (T (x, o))\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              \\<exists>\\<omega>'.\n                                 \\<omega> = zip y os @- \\<omega>'}\n                            \\<le> emeasure (T (hd ya, o))\n                                   {\\<omega>\n                                    \\<in> space\n     (stream_space (count_space UNIV)).\n                                    \\<exists>\\<omega>'.\n \\<omega> = zip (tl ya) os @- \\<omega>'} *\n                                  emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                   {(hd ya, o)}", "then"], ["proof (chain)\npicking this:\n  length as = Suc (length os)\n  set as \\<subseteq> \\<S>", "show ?case"], ["proof (prove)\nusing this:\n  length as = Suc (length os)\n  set as \\<subseteq> \\<S>\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>\\<S>.\n       \\<exists>y.\n          length y = length os \\<and>\n          set y \\<subseteq> \\<S> \\<and>\n          emeasure (T (hd as, o))\n           {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n            \\<exists>\\<omega>'. \\<omega> = zip (tl as) os @- \\<omega>'} *\n          emeasure (measure_pmf (K (s, o\\<^sub>1))) {(hd as, o)}\n          \\<le> ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                emeasure (T (x, o))\n                 {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n                  \\<exists>\\<omega>'. \\<omega> = zip y os @- \\<omega>'}", "by - (rule bexI[where x = \"hd as\"]; cases as; auto simp: algebra_simps **)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>\\<S>.\n     \\<exists>y.\n        length y = length os \\<and>\n        set y \\<subseteq> \\<S> \\<and>\n        emeasure (T (hd as, o))\n         {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n          \\<exists>\\<omega>'. \\<omega> = zip (tl as) os @- \\<omega>'} *\n        emeasure (measure_pmf (K (s, o\\<^sub>1))) {(hd as, o)}\n        \\<le> ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n              emeasure (T (x, o))\n               {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n                \\<exists>\\<omega>'. \\<omega> = zip y os @- \\<omega>'}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<S>; length y = length os;\n        set y \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            length ya = Suc (length os) \\<and>\n                            set ya \\<subseteq> \\<S> \\<and>\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            emeasure (T (x, o))\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              \\<exists>\\<omega>'.\n                                 \\<omega> = zip y os @- \\<omega>'}\n                            \\<le> emeasure (T (hd ya, o))\n                                   {\\<omega>\n                                    \\<in> space\n     (stream_space (count_space UNIV)).\n                                    \\<exists>\\<omega>'.\n \\<omega> = zip (tl ya) os @- \\<omega>'} *\n                                  emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                   {(hd ya, o)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<S>; length y = length os;\n        set y \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            length ya = Suc (length os) \\<and>\n                            set ya \\<subseteq> \\<S> \\<and>\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            emeasure (T (x, o))\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              \\<exists>\\<omega>'.\n                                 \\<omega> = zip y os @- \\<omega>'}\n                            \\<le> emeasure (T (hd ya, o))\n                                   {\\<omega>\n                                    \\<in> space\n     (stream_space (count_space UNIV)).\n                                    \\<exists>\\<omega>'.\n \\<omega> = zip (tl ya) os @- \\<omega>'} *\n                                  emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                   {(hd ya, o)}", "case (4 x as)"], ["proof (state)\nthis:\n  x \\<in> \\<S>\n  length as = length os\n  set as \\<subseteq> \\<S>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<S>; length y = length os;\n        set y \\<subseteq> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            length ya = Suc (length os) \\<and>\n                            set ya \\<subseteq> \\<S> \\<and>\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            emeasure (T (x, o))\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              \\<exists>\\<omega>'.\n                                 \\<omega> = zip y os @- \\<omega>'}\n                            \\<le> emeasure (T (hd ya, o))\n                                   {\\<omega>\n                                    \\<in> space\n     (stream_space (count_space UNIV)).\n                                    \\<exists>\\<omega>'.\n \\<omega> = zip (tl ya) os @- \\<omega>'} *\n                                  emeasure (measure_pmf (K (s, o\\<^sub>1)))\n                                   {(hd ya, o)}", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<S>\n  length as = length os\n  set as \\<subseteq> \\<S>", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> \\<S>\n  length as = length os\n  set as \\<subseteq> \\<S>\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       length y = Suc (length os) \\<and>\n       set y \\<subseteq> \\<S> \\<and>\n       ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n       emeasure (T (x, o))\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}\n       \\<le> emeasure (T (hd y, o))\n              {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n               \\<exists>\\<omega>'. \\<omega> = zip (tl y) os @- \\<omega>'} *\n             emeasure (measure_pmf (K (s, o\\<^sub>1))) {(hd y, o)}", "by - (rule exI[where x = \"x # as\"], simp add: algebra_simps **)"], ["proof (state)\nthis:\n  \\<exists>y.\n     length y = Suc (length os) \\<and>\n     set y \\<subseteq> \\<S> \\<and>\n     ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n     emeasure (T (x, o))\n      {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n       \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}\n     \\<le> emeasure (T (hd y, o))\n            {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n             \\<exists>\\<omega>'. \\<omega> = zip (tl y) os @- \\<omega>'} *\n           emeasure (measure_pmf (K (s, o\\<^sub>1))) {(hd y, o)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (MAX as\\<in>{as.\n               length as = length (o # os) \\<and> set as \\<subseteq> \\<S>}.\n      \\<integral>\\<^sup>+t\\<in>{(hd as, o)}.\n                         emeasure (T t)\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>\\<omega>'.\n                              \\<omega> = zip (tl as) os @- \\<omega>'}\n      \\<partial>measure_pmf (K (s, o\\<^sub>1))) =\n  (MAX (t,\n      as)\\<in>\\<S> \\<times>\n              {as. length as = length os \\<and> set as \\<subseteq> \\<S>}.\n      ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n      emeasure (T (t, o))\n       {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n        \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'})\n\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "also"], ["proof (state)\nthis:\n  (MAX as\\<in>{as.\n               length as = length (o # os) \\<and> set as \\<subseteq> \\<S>}.\n      \\<integral>\\<^sup>+t\\<in>{(hd as, o)}.\n                         emeasure (T t)\n                          {\\<omega>\n                           \\<in> space (stream_space (count_space UNIV)).\n                           \\<exists>\\<omega>'.\n                              \\<omega> = zip (tl as) os @- \\<omega>'}\n      \\<partial>measure_pmf (K (s, o\\<^sub>1))) =\n  (MAX (t,\n      as)\\<in>\\<S> \\<times>\n              {as. length as = length os \\<and> set as \\<subseteq> \\<S>}.\n      ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n      emeasure (T (t, o))\n       {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n        \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'})\n\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MAX (t,\n        as)\\<in>\\<S> \\<times>\n                {as. length as = length os \\<and> set as \\<subseteq> \\<S>}.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        emeasure (T (t, o))\n         {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n          \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}) =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))", "by (subst Max_image_left_mult[symmetric], fact+)\n       (rule sym, rule Max_image_pair, rule states_finite, fact+)"], ["proof (state)\nthis:\n  (MAX (t,\n      as)\\<in>\\<S> \\<times>\n              {as. length as = length os \\<and> set as \\<subseteq> \\<S>}.\n      ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n      emeasure (T (t, o))\n       {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n        \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}) =\n  (MAX t\\<in>\\<S>.\n      ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n      (MAX as\\<in>{as.\n                   length as = length os \\<and> set as \\<subseteq> \\<S>}.\n          emeasure (T (t, o))\n           {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n            \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n\ngoal (2 subgoals):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n 2. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "finally"], ["proof (chain)\npicking this:\n  Max {emeasure (T (s, o\\<^sub>1))\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n       as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n  (MAX t\\<in>\\<S>.\n      ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n      (MAX as\\<in>{as.\n                   length as = length os \\<and> set as \\<subseteq> \\<S>}.\n          emeasure (T (t, o))\n           {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n            \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))", "show \"?l = ?r\""], ["proof (prove)\nusing this:\n  Max {emeasure (T (s, o\\<^sub>1))\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n       as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n  (MAX t\\<in>\\<S>.\n      ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n      (MAX as\\<in>{as.\n                   length as = length os \\<and> set as \\<subseteq> \\<S>}.\n          emeasure (T (t, o))\n           {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n            \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n\ngoal (1 subgoal):\n 1. Max {emeasure (T (s, o\\<^sub>1))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n         as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n    (MAX t\\<in>\\<S>.\n        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n        (MAX as\\<in>{as.\n                     length as = length os \\<and> set as \\<subseteq> \\<S>}.\n            emeasure (T (t, o))\n             {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n              \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))", "."], ["proof (state)\nthis:\n  Max {emeasure (T (s, o\\<^sub>1))\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         \\<exists>\\<omega>'. \\<omega> = zip as (o # os) @- \\<omega>'} |\n       as. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>} =\n  (MAX t\\<in>\\<S>.\n      ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n      (MAX as\\<in>{as.\n                   length as = length os \\<and> set as \\<subseteq> \\<S>}.\n          emeasure (T (t, o))\n           {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n            \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}))\n\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "have \"?l' = \\<integral>\\<^sup>+ t'. ?f t' (t # as) (o # os) \\<partial>K (s, o\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    \\<integral>\\<^sup>+ t'. emeasure (T t')\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              \\<exists>\\<omega>'.\n                                 t' ## \\<omega> =\n                                 zip (t # as) (o # os) @- \\<omega>'}\n                       \\<partial>measure_pmf (K (s, o\\<^sub>1))", "by (rule emeasure_Collect_T[unfolded space_T]; rule measurable_V)"], ["proof (state)\nthis:\n  emeasure (T (s, o\\<^sub>1))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n  \\<integral>\\<^sup>+ t'. emeasure (T t')\n                           {\\<omega>\n                            \\<in> space (stream_space (count_space UNIV)).\n                            \\<exists>\\<omega>'.\n                               t' ## \\<omega> =\n                               zip (t # as) (o # os) @- \\<omega>'}\n                     \\<partial>measure_pmf (K (s, o\\<^sub>1))\n\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "also"], ["proof (state)\nthis:\n  emeasure (T (s, o\\<^sub>1))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n  \\<integral>\\<^sup>+ t'. emeasure (T t')\n                           {\\<omega>\n                            \\<in> space (stream_space (count_space UNIV)).\n                            \\<exists>\\<omega>'.\n                               t' ## \\<omega> =\n                               zip (t # as) (o # os) @- \\<omega>'}\n                     \\<partial>measure_pmf (K (s, o\\<^sub>1))\n\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "from that"], ["proof (chain)\npicking this:\n  length as = length os", "have \"\\<dots> = \\<integral>\\<^sup>+ t'. ?g t' as os * indicator {(t,o)} t' \\<partial>K (s,o\\<^sub>1)\""], ["proof (prove)\nusing this:\n  length as = length os\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t'. emeasure (T t')\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              \\<exists>\\<omega>'.\n                                 t' ## \\<omega> =\n                                 zip (t # as) (o # os) @- \\<omega>'}\n                       \\<partial>measure_pmf (K (s, o\\<^sub>1)) =\n    \\<integral>\\<^sup>+t'\\<in>{(t, o)}.\n                       emeasure (T t')\n                        {\\<omega>\n                         \\<in> space (stream_space (count_space UNIV)).\n                         \\<exists>\\<omega>'.\n                            \\<omega> = zip as os @- \\<omega>'}\n    \\<partial>measure_pmf (K (s, o\\<^sub>1))", "by (subst *[of _ \"length as\"]; simp)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t'. emeasure (T t')\n                           {\\<omega>\n                            \\<in> space (stream_space (count_space UNIV)).\n                            \\<exists>\\<omega>'.\n                               t' ## \\<omega> =\n                               zip (t # as) (o # os) @- \\<omega>'}\n                     \\<partial>measure_pmf (K (s, o\\<^sub>1)) =\n  \\<integral>\\<^sup>+t'\\<in>{(t, o)}.\n                     emeasure (T t')\n                      {\\<omega>\n                       \\<in> space (stream_space (count_space UNIV)).\n                       \\<exists>\\<omega>'.\n                          \\<omega> = zip as os @- \\<omega>'}\n  \\<partial>measure_pmf (K (s, o\\<^sub>1))\n\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t'. emeasure (T t')\n                           {\\<omega>\n                            \\<in> space (stream_space (count_space UNIV)).\n                            \\<exists>\\<omega>'.\n                               t' ## \\<omega> =\n                               zip (t # as) (o # os) @- \\<omega>'}\n                     \\<partial>measure_pmf (K (s, o\\<^sub>1)) =\n  \\<integral>\\<^sup>+t'\\<in>{(t, o)}.\n                     emeasure (T t')\n                      {\\<omega>\n                       \\<in> space (stream_space (count_space UNIV)).\n                       \\<exists>\\<omega>'.\n                          \\<omega> = zip as os @- \\<omega>'}\n  \\<partial>measure_pmf (K (s, o\\<^sub>1))\n\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "have \"\\<dots> = ?r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+t'\\<in>{(t, o)}.\n                       emeasure (T t')\n                        {\\<omega>\n                         \\<in> space (stream_space (count_space UNIV)).\n                         \\<exists>\\<omega>'.\n                            \\<omega> = zip as os @- \\<omega>'}\n    \\<partial>measure_pmf (K (s, o\\<^sub>1)) =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "by (simp add: **, simp only: algebra_simps)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+t'\\<in>{(t, o)}.\n                     emeasure (T t')\n                      {\\<omega>\n                       \\<in> space (stream_space (count_space UNIV)).\n                       \\<exists>\\<omega>'.\n                          \\<omega> = zip as os @- \\<omega>'}\n  \\<partial>measure_pmf (K (s, o\\<^sub>1)) =\n  ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n  emeasure (T (t, o))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}\n\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "finally"], ["proof (chain)\npicking this:\n  emeasure (T (s, o\\<^sub>1))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n  ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n  emeasure (T (t, o))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "show \"?l' = ?r'\""], ["proof (prove)\nusing this:\n  emeasure (T (s, o\\<^sub>1))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n  ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n  emeasure (T (t, o))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}\n\ngoal (1 subgoal):\n 1. emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n    ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n    emeasure (T (t, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "."], ["proof (state)\nthis:\n  emeasure (T (s, o\\<^sub>1))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip (t # as) (o # os) @- \\<omega>'} =\n  ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n  emeasure (T (t, o))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas max_prob_Cons = max_prob_Cons'[OF length_replicate]"], ["", "subsection \\<open>Computation of Maximum Probabilities\\<close>"], ["", "lemma T_init_V_eq:\n  \"T (s, o) {\\<omega> \\<in> space S. V os as \\<omega>} = T (s, o') {\\<omega> \\<in> space S. V os as \\<omega>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T (s, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'} =\n    emeasure (T (s, o'))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "apply (subst emeasure_Collect_T[unfolded space_T], (measurable; fail))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. emeasure (T t)\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>\\<omega>'.\n                                t ## x = zip as os @- \\<omega>'}\n                       \\<partial>measure_pmf (K (s, o)) =\n    emeasure (T (s, o'))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "apply (subst (2) emeasure_Collect_T[unfolded space_T], (measurable; fail))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. emeasure (T t)\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>\\<omega>'.\n                                t ## x = zip as os @- \\<omega>'}\n                       \\<partial>measure_pmf (K (s, o)) =\n    \\<integral>\\<^sup>+ t. emeasure (T t)\n                            {x \\<in> space\n(stream_space (count_space UNIV)).\n                             \\<exists>\\<omega>'.\n                                t ## x = zip as os @- \\<omega>'}\n                       \\<partial>measure_pmf (K (s, o'))", "apply (simp add: K_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma T'_I_T:\n  \"T' (I s) {\\<omega> \\<in> space S. \\<exists>o \\<omega>'. \\<omega> = (s, o) ## zip as os @- \\<omega>'} = T (s,o) {\\<omega> \\<in> space S. V os as \\<omega>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T' (I s))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>o \\<omega>'. \\<omega> = (s, o) ## zip as os @- \\<omega>'} =\n    emeasure (T (s, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (T' (I s))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>o \\<omega>'. \\<omega> = (s, o) ## zip as os @- \\<omega>'} =\n    emeasure (T (s, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "have \"(\\<Sum>o\\<in>\\<O>\\<^sub>s. T (s, o) {\\<omega> \\<in> space S. V os as \\<omega>}) =\n    of_nat (card \\<O>\\<^sub>s) * T (s, o) {\\<omega> \\<in> space S. V os as \\<omega>}\" for as"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n       emeasure (T (s, o))\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}) =\n    of_nat (card \\<O>\\<^sub>s) *\n    emeasure (T (s, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "by (subst sum_constant[symmetric]) (fastforce intro: sum.cong T_init_V_eq[simplified])"], ["proof (state)\nthis:\n  (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n     emeasure (T (s, o))\n      {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n       \\<exists>\\<omega>'. \\<omega> = zip ?as1 os @- \\<omega>'}) =\n  of_nat (card \\<O>\\<^sub>s) *\n  emeasure (T (s, o))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip ?as1 os @- \\<omega>'}\n\ngoal (1 subgoal):\n 1. emeasure (T' (I s))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>o \\<omega>'. \\<omega> = (s, o) ## zip as os @- \\<omega>'} =\n    emeasure (T (s, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n     emeasure (T (s, o))\n      {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n       \\<exists>\\<omega>'. \\<omega> = zip ?as1 os @- \\<omega>'}) =\n  of_nat (card \\<O>\\<^sub>s) *\n  emeasure (T (s, o))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip ?as1 os @- \\<omega>'}", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n     emeasure (T (s, o))\n      {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n       \\<exists>\\<omega>'. \\<omega> = zip ?as1 os @- \\<omega>'}) =\n  of_nat (card \\<O>\\<^sub>s) *\n  emeasure (T (s, o))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip ?as1 os @- \\<omega>'}\n\ngoal (1 subgoal):\n 1. emeasure (T' (I s))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>o \\<omega>'. \\<omega> = (s, o) ## zip as os @- \\<omega>'} =\n    emeasure (T (s, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "unfolding max_prob_def"], ["proof (prove)\nusing this:\n  (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n     emeasure (T (s, o))\n      {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n       \\<exists>\\<omega>'. \\<omega> = zip ?as1 os @- \\<omega>'}) =\n  of_nat (card \\<O>\\<^sub>s) *\n  emeasure (T (s, o))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip ?as1 os @- \\<omega>'}\n\ngoal (1 subgoal):\n 1. emeasure (T' (I s))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>o \\<omega>'. \\<omega> = (s, o) ## zip as os @- \\<omega>'} =\n    emeasure (T (s, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "apply (subst emeasure_T')"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>as.\n        (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n           emeasure (T (s, o))\n            {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n             \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}) =\n        of_nat (card \\<O>\\<^sub>s) *\n        emeasure (T (s, o))\n         {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n          \\<exists>\\<omega>'.\n             \\<omega> = zip as os @- \\<omega>'}) \\<Longrightarrow>\n    {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n     \\<exists>o \\<omega>'. \\<omega> = (s, o) ## zip as os @- \\<omega>'}\n    \\<in> sets (stream_space (count_space UNIV))\n 2. (\\<And>as.\n        (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n           emeasure (T (s, o))\n            {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n             \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}) =\n        of_nat (card \\<O>\\<^sub>s) *\n        emeasure (T (s, o))\n         {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n          \\<exists>\\<omega>'.\n             \\<omega> = zip as os @- \\<omega>'}) \\<Longrightarrow>\n    \\<integral>\\<^sup>+ sa. emeasure (T sa)\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              sa ## \\<omega>\n                              \\<in> {\\<omega>\n                                     \\<in> space\n      (stream_space (count_space UNIV)).\n                                     \\<exists>o \\<omega>'.\n  \\<omega> = (s, o) ## zip as os @- \\<omega>'}}\n                       \\<partial>measure_pmf (I s) =\n    emeasure (T (s, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n           emeasure (T (s, o))\n            {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n             \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}) =\n        of_nat (card \\<O>\\<^sub>s) *\n        emeasure (T (s, o))\n         {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n          \\<exists>\\<omega>'.\n             \\<omega> = zip as os @- \\<omega>'}) \\<Longrightarrow>\n    {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n     \\<exists>o \\<omega>'. \\<omega> = (s, o) ## zip as os @- \\<omega>'}\n    \\<in> sets (stream_space (count_space UNIV))", "by measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n           emeasure (T (s, o))\n            {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n             \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}) =\n        of_nat (card \\<O>\\<^sub>s) *\n        emeasure (T (s, o))\n         {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n          \\<exists>\\<omega>'.\n             \\<omega> = zip as os @- \\<omega>'}) \\<Longrightarrow>\n    \\<integral>\\<^sup>+ sa. emeasure (T sa)\n                             {\\<omega>\n                              \\<in> space (stream_space (count_space UNIV)).\n                              sa ## \\<omega>\n                              \\<in> {\\<omega>\n                                     \\<in> space\n      (stream_space (count_space UNIV)).\n                                     \\<exists>o \\<omega>'.\n  \\<omega> = (s, o) ## zip as os @- \\<omega>'}}\n                       \\<partial>measure_pmf (I s) =\n    emeasure (T (s, o))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "apply (simp add: I_def in_S observations_finite observations_wellformed nn_integral_pmf_of_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n           emeasure (T (s, o))\n            {\\<omega>.\n             \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}) =\n        of_nat (card \\<O>\\<^sub>s) *\n        emeasure (T (s, o))\n         {\\<omega>.\n          \\<exists>\\<omega>'.\n             \\<omega> = zip as os @- \\<omega>'}) \\<Longrightarrow>\n    of_nat (card \\<O>\\<^sub>s) *\n    emeasure (T (s, o))\n     {\\<omega>. \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'} /\n    of_nat (card \\<O>\\<^sub>s) =\n    emeasure (T (s, o))\n     {\\<omega>. \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "apply (subst mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        (\\<Sum>o\\<in>\\<O>\\<^sub>s.\n           emeasure (T (s, o))\n            {\\<omega>.\n             \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}) =\n        of_nat (card \\<O>\\<^sub>s) *\n        emeasure (T (s, o))\n         {\\<omega>.\n          \\<exists>\\<omega>'.\n             \\<omega> = zip as os @- \\<omega>'}) \\<Longrightarrow>\n    emeasure (T (s, o))\n     {\\<omega>. \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'} *\n    of_nat (card \\<O>\\<^sub>s) /\n    of_nat (card \\<O>\\<^sub>s) =\n    emeasure (T (s, o))\n     {\\<omega>. \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "apply (simp add: observations_finite observations_wellformed mult_divide_eq_ennreal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure (T' (I s))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>o \\<omega>'. \\<omega> = (s, o) ## zip as os @- \\<omega>'} =\n  emeasure (T (s, o))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_prob_init:\n  \"max_prob s os = Max {T (s,o) {\\<omega> \\<in> space S. V os as \\<omega>} | as. length as = length os \\<and> set as \\<subseteq> \\<S>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_prob s os =\n    Max {emeasure (T (s, o))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'} |\n         as. length as = length os \\<and> set as \\<subseteq> \\<S>}", "unfolding max_prob_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {emeasure (T' (I s))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>o \\<omega>'.\n              \\<omega> = (s, o) ## zip as os @- \\<omega>'} |\n         as. length as = length os \\<and> set as \\<subseteq> \\<S>} =\n    Max {emeasure (T (s, o))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'} |\n         as. length as = length os \\<and> set as \\<subseteq> \\<S>}", "by (simp add: T'_I_T[symmetric])"], ["", "lemma max_prob_Nil[simp]:\n  \"max_prob s [] = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_prob s [] = 1", "unfolding max_prob_init[where o = obs]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {emeasure (T (s, obs))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as [] @- \\<omega>'} |\n         as. length as = length [] \\<and> set as \\<subseteq> \\<S>} =\n    1", "by auto"], ["", "lemma Max_start:\n  \"(MAX t\\<in>\\<S>. (indicator {t} s :: ennreal)) = 1\" if \"s \\<in> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MAX t\\<in>\\<S>. indicator {t} s) = 1", "using states_finite that"], ["proof (prove)\nusing this:\n  finite \\<S>\n  s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. (MAX t\\<in>\\<S>. indicator {t} s) = 1", "by (auto simp: indicator_def intro: Max_eqI)"], ["", "lemma Max_V_viterbi:\n  \"(MAX t \\<in> \\<S>. viterbi_prob s t os) =\n   Max {T (s, o) {\\<omega> \\<in> space S. V os as \\<omega>} | as. length as = length os \\<and> set as \\<subseteq> \\<S>}\" if \"s \\<in> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MAX t\\<in>\\<S>. viterbi_prob s t os) =\n    Max {emeasure (T (s, o))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'} |\n         as. length as = length os \\<and> set as \\<subseteq> \\<S>}", "using that states_finite states_wellformed"], ["proof (prove)\nusing this:\n  s \\<in> \\<S>\n  finite \\<S>\n  \\<S> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (MAX t\\<in>\\<S>. viterbi_prob s t os) =\n    Max {emeasure (T (s, o))\n          {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n           \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'} |\n         as. length as = length os \\<and> set as \\<subseteq> \\<S>}", "by (induction os arbitrary: s o; simp\n        add: Max_start max_prob_Cons[simplified] Max_image_commute Max_image_left_mult Max_to_image2\n        cong: Max_image_cong\n      )"], ["", "lemma max_prob_viterbi:\n  \"(MAX t \\<in> \\<S>. viterbi_prob s t os) = max_prob s os\" if \"s \\<in> \\<S>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MAX t\\<in>\\<S>. viterbi_prob s t os) = max_prob s os", "using max_prob_init[of s os] Max_V_viterbi[OF \\<open>s \\<in> \\<S>\\<close>, symmetric]"], ["proof (prove)\nusing this:\n  max_prob s os =\n  Max {emeasure (T (s, ?o))\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'} |\n       as. length as = length os \\<and> set as \\<subseteq> \\<S>}\n  Max {emeasure (T (s, ?o))\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         \\<exists>\\<omega>'. \\<omega> = zip as ?os @- \\<omega>'} |\n       as. length as = length ?os \\<and> set as \\<subseteq> \\<S>} =\n  (MAX t\\<in>\\<S>. viterbi_prob s t ?os)\n\ngoal (1 subgoal):\n 1. (MAX t\\<in>\\<S>. viterbi_prob s t os) = max_prob s os", "by simp"], ["", "end"], ["", "subsection \\<open>Decoding the Most Probable Hidden State Sequence\\<close>"], ["", "context HMM3\nbegin"], ["", "fun viterbi where\n  \"viterbi s t_end [] = ([], indicator {t_end} s)\" |\n  \"viterbi s t_end (o # os) = fst (\n    argmax snd (map\n      (\\<lambda>t. let (xs, v) = viterbi t t_end os in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n    state_list))\""], ["", "lemma state_list_nonempty:\n  \"state_list \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_list \\<noteq> []", "using state_list_\\<S> states_wellformed"], ["proof (prove)\nusing this:\n  set state_list = \\<S>\n  \\<S> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. state_list \\<noteq> []", "by auto"], ["", "lemma viterbi_viterbi_prob:\n  \"snd (viterbi s t_end os) = viterbi_prob s t_end os\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (viterbi s t_end os) = viterbi_prob s t_end os", "proof (induction os arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. snd (viterbi s t_end []) = viterbi_prob s t_end []\n 2. \\<And>a os s.\n       (\\<And>s.\n           snd (viterbi s t_end os) =\n           viterbi_prob s t_end os) \\<Longrightarrow>\n       snd (viterbi s t_end (a # os)) = viterbi_prob s t_end (a # os)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s. snd (viterbi s t_end []) = viterbi_prob s t_end []\n 2. \\<And>a os s.\n       (\\<And>s.\n           snd (viterbi s t_end os) =\n           viterbi_prob s t_end os) \\<Longrightarrow>\n       snd (viterbi s t_end (a # os)) = viterbi_prob s t_end (a # os)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (viterbi s t_end []) = viterbi_prob s t_end []", "by simp"], ["proof (state)\nthis:\n  snd (viterbi s t_end []) = viterbi_prob s t_end []\n\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       (\\<And>s.\n           snd (viterbi s t_end os) =\n           viterbi_prob s t_end os) \\<Longrightarrow>\n       snd (viterbi s t_end (a # os)) = viterbi_prob s t_end (a # os)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       (\\<And>s.\n           snd (viterbi s t_end os) =\n           viterbi_prob s t_end os) \\<Longrightarrow>\n       snd (viterbi s t_end (a # os)) = viterbi_prob s t_end (a # os)", "case (Cons o os)"], ["proof (state)\nthis:\n  snd (viterbi ?s1 t_end os) = viterbi_prob ?s1 t_end os\n\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       (\\<And>s.\n           snd (viterbi s t_end os) =\n           viterbi_prob s t_end os) \\<Longrightarrow>\n       snd (viterbi s t_end (a # os)) = viterbi_prob s t_end (a # os)", "let ?f =\n    \"\\<lambda>t. let (xs, v) = viterbi t t_end os in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       (\\<And>s.\n           snd (viterbi s t_end os) =\n           viterbi_prob s t_end os) \\<Longrightarrow>\n       snd (viterbi s t_end (a # os)) = viterbi_prob s t_end (a # os)", "let ?xs = \"map ?f state_list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       (\\<And>s.\n           snd (viterbi s t_end os) =\n           viterbi_prob s t_end os) \\<Longrightarrow>\n       snd (viterbi s t_end (a # os)) = viterbi_prob s t_end (a # os)", "from state_list_nonempty"], ["proof (chain)\npicking this:\n  state_list \\<noteq> []", "have \"map ?f state_list \\<noteq> []\""], ["proof (prove)\nusing this:\n  state_list \\<noteq> []\n\ngoal (1 subgoal):\n 1. map (\\<lambda>t.\n            let (xs, v) = viterbi t t_end os\n            in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n     state_list \\<noteq>\n    []", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>t.\n          let (xs, v) = viterbi t t_end os\n          in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n   state_list \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       (\\<And>s.\n           snd (viterbi s t_end os) =\n           viterbi_prob s t_end os) \\<Longrightarrow>\n       snd (viterbi s t_end (a # os)) = viterbi_prob s t_end (a # os)", "from argmax(2,3)[OF this, of snd]"], ["proof (chain)\npicking this:\n  snd (fst (argmax snd\n             (map (\\<lambda>t.\n                      let (xs, v) = viterbi t t_end os\n                      in (t # xs,\n                          ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n               state_list))) =\n  snd (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list))\n  snd (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list)) =\n  Max (snd `\n       set (map (\\<lambda>t.\n                    let (xs, v) = viterbi t t_end os\n                    in (t # xs,\n                        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list))", "have *:\n    \"snd (fst (argmax snd ?xs)) = snd (argmax snd ?xs)\"\n    \"snd (argmax snd ?xs) = (MAX x \\<in> set ?xs. snd x)\""], ["proof (prove)\nusing this:\n  snd (fst (argmax snd\n             (map (\\<lambda>t.\n                      let (xs, v) = viterbi t t_end os\n                      in (t # xs,\n                          ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n               state_list))) =\n  snd (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list))\n  snd (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list)) =\n  Max (snd `\n       set (map (\\<lambda>t.\n                    let (xs, v) = viterbi t t_end os\n                    in (t # xs,\n                        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list))\n\ngoal (1 subgoal):\n 1. snd (fst (argmax snd\n               (map (\\<lambda>t.\n                        let (xs, v) = viterbi t t_end os\n                        in (t # xs,\n                            ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n                 state_list))) =\n    snd (argmax snd\n          (map (\\<lambda>t.\n                   let (xs, v) = viterbi t t_end os\n                   in (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n            state_list)) &&&\n    snd (argmax snd\n          (map (\\<lambda>t.\n                   let (xs, v) = viterbi t t_end os\n                   in (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n            state_list)) =\n    Max (snd `\n         set (map (\\<lambda>t.\n                      let (xs, v) = viterbi t t_end os\n                      in (t # xs,\n                          ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n               state_list))", "."], ["proof (state)\nthis:\n  snd (fst (argmax snd\n             (map (\\<lambda>t.\n                      let (xs, v) = viterbi t t_end os\n                      in (t # xs,\n                          ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n               state_list))) =\n  snd (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list))\n  snd (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list)) =\n  Max (snd `\n       set (map (\\<lambda>t.\n                    let (xs, v) = viterbi t t_end os\n                    in (t # xs,\n                        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list))\n\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       (\\<And>s.\n           snd (viterbi s t_end os) =\n           viterbi_prob s t_end os) \\<Longrightarrow>\n       snd (viterbi s t_end (a # os)) = viterbi_prob s t_end (a # os)", "then"], ["proof (chain)\npicking this:\n  snd (fst (argmax snd\n             (map (\\<lambda>t.\n                      let (xs, v) = viterbi t t_end os\n                      in (t # xs,\n                          ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n               state_list))) =\n  snd (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list))\n  snd (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list)) =\n  Max (snd `\n       set (map (\\<lambda>t.\n                    let (xs, v) = viterbi t t_end os\n                    in (t # xs,\n                        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list))", "show ?case"], ["proof (prove)\nusing this:\n  snd (fst (argmax snd\n             (map (\\<lambda>t.\n                      let (xs, v) = viterbi t t_end os\n                      in (t # xs,\n                          ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n               state_list))) =\n  snd (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list))\n  snd (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list)) =\n  Max (snd `\n       set (map (\\<lambda>t.\n                    let (xs, v) = viterbi t t_end os\n                    in (t # xs,\n                        ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list))\n\ngoal (1 subgoal):\n 1. snd (viterbi s t_end (o # os)) = viterbi_prob s t_end (o # os)", "apply (simp add: state_list_\\<S>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>)\\<rbrakk>\n    \\<Longrightarrow> Max (snd `\n                           (\\<lambda>x.\n                               case viterbi x t_end os of\n                               (xs, v) \\<Rightarrow>\n                                 (x # xs,\n                                  ennreal\n                                   (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                                  v)) `\n                           \\<S>) =\n                      (MAX t\\<in>\\<S>.\n                          ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                          viterbi_prob t t_end os)", "apply (rule Max_eq_image_if)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>)\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>x.\n                            case viterbi x t_end os of\n                            (xs, v) \\<Rightarrow>\n                              (x # xs,\n                               ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                               v)) `\n                        \\<S>)\n 2. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>)\\<rbrakk>\n    \\<Longrightarrow> finite \\<S>\n 3. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>(\\<lambda>x.\n   case viterbi x t_end os of\n   (xs, v) \\<Rightarrow>\n     (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                                     \\<S>.\n                         \\<exists>y\\<in>\\<S>.\n                            snd x\n                            \\<le> ennreal\n                                   (pmf (\\<O> y) o * pmf (\\<K> s) y) *\n                                  viterbi_prob y t_end os\n 4. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>\\<S>.\n                         \\<exists>y\\<in>(\\<lambda>x.\n      case viterbi x t_end os of\n      (xs, v) \\<Rightarrow>\n        (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n  \\<S>.\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            viterbi_prob x t_end os\n                            \\<le> snd y", "apply (intro finite_imageI states_finite; fail)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>)\\<rbrakk>\n    \\<Longrightarrow> finite \\<S>\n 2. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>(\\<lambda>x.\n   case viterbi x t_end os of\n   (xs, v) \\<Rightarrow>\n     (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                                     \\<S>.\n                         \\<exists>y\\<in>\\<S>.\n                            snd x\n                            \\<le> ennreal\n                                   (pmf (\\<O> y) o * pmf (\\<K> s) y) *\n                                  viterbi_prob y t_end os\n 3. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>\\<S>.\n                         \\<exists>y\\<in>(\\<lambda>x.\n      case viterbi x t_end os of\n      (xs, v) \\<Rightarrow>\n        (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n  \\<S>.\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            viterbi_prob x t_end os\n                            \\<le> snd y", "apply (intro finite_imageI states_finite; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>(\\<lambda>x.\n   case viterbi x t_end os of\n   (xs, v) \\<Rightarrow>\n     (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                                     \\<S>.\n                         \\<exists>y\\<in>\\<S>.\n                            snd x\n                            \\<le> ennreal\n                                   (pmf (\\<O> y) o * pmf (\\<K> s) y) *\n                                  viterbi_prob y t_end os\n 2. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>\\<S>.\n                         \\<exists>y\\<in>(\\<lambda>x.\n      case viterbi x t_end os of\n      (xs, v) \\<Rightarrow>\n        (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n  \\<S>.\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            viterbi_prob x t_end os\n                            \\<le> snd y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>(\\<lambda>x.\n   case viterbi x t_end os of\n   (xs, v) \\<Rightarrow>\n     (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                                     \\<S>.\n                         \\<exists>y\\<in>\\<S>.\n                            snd x\n                            \\<le> ennreal\n                                   (pmf (\\<O> y) o * pmf (\\<K> s) y) *\n                                  viterbi_prob y t_end os", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>snd (fst (argmax snd\n                           (map (\\<lambda>t.\n                                    case viterbi t t_end os of\n                                    (xs, v) \\<Rightarrow>\n(t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n                             state_list))) =\n                Max (snd `\n                     (\\<lambda>x.\n                         case viterbi x t_end os of\n                         (xs, v) \\<Rightarrow>\n                           (x # xs,\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            v)) `\n                     \\<S>);\n        snd (argmax snd\n              (map (\\<lambda>t.\n                       case viterbi t t_end os of\n                       (xs, v) \\<Rightarrow>\n                         (t # xs,\n                          ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n                state_list)) =\n        Max (snd `\n             (\\<lambda>x.\n                 case viterbi x t_end os of\n                 (xs, v) \\<Rightarrow>\n                   (x # xs,\n                    ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n             \\<S>);\n        x \\<in> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>\\<S>.\n                            snd (case viterbi x t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (x # xs,\n                                    ennreal\n                                     (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                                    v))\n                            \\<le> ennreal\n                                   (pmf (\\<O> y) o * pmf (\\<K> s) y) *\n                                  viterbi_prob y t_end os", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>);\n     x \\<in> \\<S>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y\\<in>\\<S>.\n                         snd (case viterbi x t_end os of\n                              (xs, v) \\<Rightarrow>\n                                (x # xs,\n                                 ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                                 v))\n                         \\<le> ennreal (pmf (\\<O> y) o * pmf (\\<K> s) y) *\n                               viterbi_prob y t_end os", "using Cons.IH[of x]"], ["proof (prove)\nusing this:\n  snd (viterbi x t_end os) = viterbi_prob x t_end os\n\ngoal (1 subgoal):\n 1. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>);\n     x \\<in> \\<S>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y\\<in>\\<S>.\n                         snd (case viterbi x t_end os of\n                              (xs, v) \\<Rightarrow>\n                                (x # xs,\n                                 ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                                 v))\n                         \\<le> ennreal (pmf (\\<O> y) o * pmf (\\<K> s) y) *\n                               viterbi_prob y t_end os", "by (auto split: prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>\\<S>.\n                         \\<exists>y\\<in>(\\<lambda>x.\n      case viterbi x t_end os of\n      (xs, v) \\<Rightarrow>\n        (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n  \\<S>.\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            viterbi_prob x t_end os\n                            \\<le> snd y", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>snd (fst (argmax snd\n                           (map (\\<lambda>t.\n                                    case viterbi t t_end os of\n                                    (xs, v) \\<Rightarrow>\n(t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n                             state_list))) =\n                Max (snd `\n                     (\\<lambda>x.\n                         case viterbi x t_end os of\n                         (xs, v) \\<Rightarrow>\n                           (x # xs,\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            v)) `\n                     \\<S>);\n        snd (argmax snd\n              (map (\\<lambda>t.\n                       case viterbi t t_end os of\n                       (xs, v) \\<Rightarrow>\n                         (t # xs,\n                          ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n                state_list)) =\n        Max (snd `\n             (\\<lambda>x.\n                 case viterbi x t_end os of\n                 (xs, v) \\<Rightarrow>\n                   (x # xs,\n                    ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n             \\<S>);\n        x \\<in> \\<S>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>\\<S>.\n                            ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                            viterbi_prob x t_end os\n                            \\<le> snd (case viterbi y t_end os of\n (xs, v) \\<Rightarrow>\n   (y # xs, ennreal (pmf (\\<O> y) o * pmf (\\<K> s) y) * v))", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>);\n     x \\<in> \\<S>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y\\<in>\\<S>.\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                         viterbi_prob x t_end os\n                         \\<le> snd (case viterbi y t_end os of\n                                    (xs, v) \\<Rightarrow>\n(y # xs, ennreal (pmf (\\<O> y) o * pmf (\\<K> s) y) * v))", "using Cons.IH[of x]"], ["proof (prove)\nusing this:\n  snd (viterbi x t_end os) = viterbi_prob x t_end os\n\ngoal (1 subgoal):\n 1. \\<lbrakk>snd (fst (argmax snd\n                        (map (\\<lambda>t.\n                                 case viterbi t t_end os of\n                                 (xs, v) \\<Rightarrow>\n                                   (t # xs,\n                                    ennreal\n                                     (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n                                    v))\n                          state_list))) =\n             Max (snd `\n                  (\\<lambda>x.\n                      case viterbi x t_end os of\n                      (xs, v) \\<Rightarrow>\n                        (x # xs,\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n                  \\<S>);\n     snd (argmax snd\n           (map (\\<lambda>t.\n                    case viterbi t t_end os of\n                    (xs, v) \\<Rightarrow>\n                      (t # xs,\n                       ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n             state_list)) =\n     Max (snd `\n          (\\<lambda>x.\n              case viterbi x t_end os of\n              (xs, v) \\<Rightarrow>\n                (x # xs, ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) * v)) `\n          \\<S>);\n     x \\<in> \\<S>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y\\<in>\\<S>.\n                         ennreal (pmf (\\<O> x) o * pmf (\\<K> s) x) *\n                         viterbi_prob x t_end os\n                         \\<le> snd (case viterbi y t_end os of\n                                    (xs, v) \\<Rightarrow>\n(y # xs, ennreal (pmf (\\<O> y) o * pmf (\\<K> s) y) * v))", "by (force split: prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  snd (viterbi s t_end (o # os)) = viterbi_prob s t_end (o # os)\n\ngoal:\nNo subgoals!", "qed"], ["", "context\nbegin"], ["", "private"], ["", "fun val_of where\n  \"val_of s [] [] = 1\" |\n  \"val_of s (t # xs) (o # os) = ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * val_of t xs os\""], ["", "lemma val_of_T:\n  \"val_of s as os = T (s, o\\<^sub>1) {\\<omega> \\<in> space S. V os as \\<omega>}\" if \"length as = length os\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val_of s as os =\n    emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "using that"], ["proof (prove)\nusing this:\n  length as = length os\n\ngoal (1 subgoal):\n 1. val_of s as os =\n    emeasure (T (s, o\\<^sub>1))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "by (induction arbitrary: o\\<^sub>1 rule: val_of.induct; (subst T_V_Cons)?; simp)"], ["", "lemma viterbi_sequence:\n  \"snd (viterbi s t_end os) = val_of s (fst (viterbi s t_end os)) os\"\n  if \"snd (viterbi s t_end os) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (viterbi s t_end os) = val_of s (fst (viterbi s t_end os)) os", "using that"], ["proof (prove)\nusing this:\n  0 < snd (viterbi s t_end os)\n\ngoal (1 subgoal):\n 1. snd (viterbi s t_end os) = val_of s (fst (viterbi s t_end os)) os", "proof (induction os arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       0 < snd (viterbi s t_end []) \\<Longrightarrow>\n       snd (viterbi s t_end []) = val_of s (fst (viterbi s t_end [])) []\n 2. \\<And>a os s.\n       \\<lbrakk>\\<And>s.\n                   0 < snd (viterbi s t_end os) \\<Longrightarrow>\n                   snd (viterbi s t_end os) =\n                   val_of s (fst (viterbi s t_end os)) os;\n        0 < snd (viterbi s t_end (a # os))\\<rbrakk>\n       \\<Longrightarrow> snd (viterbi s t_end (a # os)) =\n                         val_of s (fst (viterbi s t_end (a # os))) (a # os)", "case Nil"], ["proof (state)\nthis:\n  0 < snd (viterbi s t_end [])\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       0 < snd (viterbi s t_end []) \\<Longrightarrow>\n       snd (viterbi s t_end []) = val_of s (fst (viterbi s t_end [])) []\n 2. \\<And>a os s.\n       \\<lbrakk>\\<And>s.\n                   0 < snd (viterbi s t_end os) \\<Longrightarrow>\n                   snd (viterbi s t_end os) =\n                   val_of s (fst (viterbi s t_end os)) os;\n        0 < snd (viterbi s t_end (a # os))\\<rbrakk>\n       \\<Longrightarrow> snd (viterbi s t_end (a # os)) =\n                         val_of s (fst (viterbi s t_end (a # os))) (a # os)", "then"], ["proof (chain)\npicking this:\n  0 < snd (viterbi s t_end [])", "show ?case"], ["proof (prove)\nusing this:\n  0 < snd (viterbi s t_end [])\n\ngoal (1 subgoal):\n 1. snd (viterbi s t_end []) = val_of s (fst (viterbi s t_end [])) []", "by (simp add: indicator_def split: if_split_asm)"], ["proof (state)\nthis:\n  snd (viterbi s t_end []) = val_of s (fst (viterbi s t_end [])) []\n\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       \\<lbrakk>\\<And>s.\n                   0 < snd (viterbi s t_end os) \\<Longrightarrow>\n                   snd (viterbi s t_end os) =\n                   val_of s (fst (viterbi s t_end os)) os;\n        0 < snd (viterbi s t_end (a # os))\\<rbrakk>\n       \\<Longrightarrow> snd (viterbi s t_end (a # os)) =\n                         val_of s (fst (viterbi s t_end (a # os))) (a # os)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       \\<lbrakk>\\<And>s.\n                   0 < snd (viterbi s t_end os) \\<Longrightarrow>\n                   snd (viterbi s t_end os) =\n                   val_of s (fst (viterbi s t_end os)) os;\n        0 < snd (viterbi s t_end (a # os))\\<rbrakk>\n       \\<Longrightarrow> snd (viterbi s t_end (a # os)) =\n                         val_of s (fst (viterbi s t_end (a # os))) (a # os)", "case (Cons o os s)"], ["proof (state)\nthis:\n  0 < snd (viterbi ?s1 t_end os) \\<Longrightarrow>\n  snd (viterbi ?s1 t_end os) = val_of ?s1 (fst (viterbi ?s1 t_end os)) os\n  0 < snd (viterbi s t_end (o # os))\n\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       \\<lbrakk>\\<And>s.\n                   0 < snd (viterbi s t_end os) \\<Longrightarrow>\n                   snd (viterbi s t_end os) =\n                   val_of s (fst (viterbi s t_end os)) os;\n        0 < snd (viterbi s t_end (a # os))\\<rbrakk>\n       \\<Longrightarrow> snd (viterbi s t_end (a # os)) =\n                         val_of s (fst (viterbi s t_end (a # os))) (a # os)", "let ?xs = \"map\n    (\\<lambda>t. let (xs, v) = viterbi t t_end os in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n    state_list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       \\<lbrakk>\\<And>s.\n                   0 < snd (viterbi s t_end os) \\<Longrightarrow>\n                   snd (viterbi s t_end os) =\n                   val_of s (fst (viterbi s t_end os)) os;\n        0 < snd (viterbi s t_end (a # os))\\<rbrakk>\n       \\<Longrightarrow> snd (viterbi s t_end (a # os)) =\n                         val_of s (fst (viterbi s t_end (a # os))) (a # os)", "from state_list_nonempty"], ["proof (chain)\npicking this:\n  state_list \\<noteq> []", "have \"?xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  state_list \\<noteq> []\n\ngoal (1 subgoal):\n 1. map (\\<lambda>t.\n            let (xs, v) = viterbi t t_end os\n            in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n     state_list \\<noteq>\n    []", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>t.\n          let (xs, v) = viterbi t t_end os\n          in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n   state_list \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       \\<lbrakk>\\<And>s.\n                   0 < snd (viterbi s t_end os) \\<Longrightarrow>\n                   snd (viterbi s t_end os) =\n                   val_of s (fst (viterbi s t_end os)) os;\n        0 < snd (viterbi s t_end (a # os))\\<rbrakk>\n       \\<Longrightarrow> snd (viterbi s t_end (a # os)) =\n                         val_of s (fst (viterbi s t_end (a # os))) (a # os)", "from argmax(1)[OF this, of snd]"], ["proof (chain)\npicking this:\n  fst (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list))\n  \\<in> set (map (\\<lambda>t.\n                     let (xs, v) = viterbi t t_end os\n                     in (t # xs,\n                         ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n              state_list)", "obtain t where\n    \"t \\<in> set state_list\"\n    \"fst (argmax snd ?xs) =\n    (t # fst (viterbi t t_end os), ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * snd (viterbi t t_end os))\""], ["proof (prove)\nusing this:\n  fst (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list))\n  \\<in> set (map (\\<lambda>t.\n                     let (xs, v) = viterbi t t_end os\n                     in (t # xs,\n                         ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n              state_list)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> set state_list;\n         fst (argmax snd\n               (map (\\<lambda>t.\n                        let (xs, v) = viterbi t t_end os\n                        in (t # xs,\n                            ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n                 state_list)) =\n         (t # fst (viterbi t t_end os),\n          ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n          snd (viterbi t t_end os))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  t \\<in> set state_list\n  fst (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list)) =\n  (t # fst (viterbi t t_end os),\n   ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * snd (viterbi t t_end os))\n\ngoal (1 subgoal):\n 1. \\<And>a os s.\n       \\<lbrakk>\\<And>s.\n                   0 < snd (viterbi s t_end os) \\<Longrightarrow>\n                   snd (viterbi s t_end os) =\n                   val_of s (fst (viterbi s t_end os)) os;\n        0 < snd (viterbi s t_end (a # os))\\<rbrakk>\n       \\<Longrightarrow> snd (viterbi s t_end (a # os)) =\n                         val_of s (fst (viterbi s t_end (a # os))) (a # os)", "with Cons"], ["proof (chain)\npicking this:\n  0 < snd (viterbi ?s1 t_end os) \\<Longrightarrow>\n  snd (viterbi ?s1 t_end os) = val_of ?s1 (fst (viterbi ?s1 t_end os)) os\n  0 < snd (viterbi s t_end (o # os))\n  t \\<in> set state_list\n  fst (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list)) =\n  (t # fst (viterbi t t_end os),\n   ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * snd (viterbi t t_end os))", "show ?case"], ["proof (prove)\nusing this:\n  0 < snd (viterbi ?s1 t_end os) \\<Longrightarrow>\n  snd (viterbi ?s1 t_end os) = val_of ?s1 (fst (viterbi ?s1 t_end os)) os\n  0 < snd (viterbi s t_end (o # os))\n  t \\<in> set state_list\n  fst (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list)) =\n  (t # fst (viterbi t t_end os),\n   ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * snd (viterbi t t_end os))\n\ngoal (1 subgoal):\n 1. snd (viterbi s t_end (o # os)) =\n    val_of s (fst (viterbi s t_end (o # os))) (o # os)", "by (auto simp: ennreal_zero_less_mult_iff)"], ["proof (state)\nthis:\n  snd (viterbi s t_end (o # os)) =\n  val_of s (fst (viterbi s t_end (o # os))) (o # os)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma viterbi_valid_path:\n  \"length as = length os \\<and> set as \\<subseteq> \\<S>\" if \"viterbi s t_end os = (as, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as = length os \\<and> set as \\<subseteq> \\<S>", "using that"], ["proof (prove)\nusing this:\n  viterbi s t_end os = (as, v)\n\ngoal (1 subgoal):\n 1. length as = length os \\<and> set as \\<subseteq> \\<S>", "proof (induction os arbitrary: s as v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s as v.\n       viterbi s t_end [] = (as, v) \\<Longrightarrow>\n       length as = length [] \\<and> set as \\<subseteq> \\<S>\n 2. \\<And>a os s as v.\n       \\<lbrakk>\\<And>s as v.\n                   viterbi s t_end os = (as, v) \\<Longrightarrow>\n                   length as = length os \\<and> set as \\<subseteq> \\<S>;\n        viterbi s t_end (a # os) = (as, v)\\<rbrakk>\n       \\<Longrightarrow> length as = length (a # os) \\<and>\n                         set as \\<subseteq> \\<S>", "case Nil"], ["proof (state)\nthis:\n  viterbi s t_end [] = (as, v)\n\ngoal (2 subgoals):\n 1. \\<And>s as v.\n       viterbi s t_end [] = (as, v) \\<Longrightarrow>\n       length as = length [] \\<and> set as \\<subseteq> \\<S>\n 2. \\<And>a os s as v.\n       \\<lbrakk>\\<And>s as v.\n                   viterbi s t_end os = (as, v) \\<Longrightarrow>\n                   length as = length os \\<and> set as \\<subseteq> \\<S>;\n        viterbi s t_end (a # os) = (as, v)\\<rbrakk>\n       \\<Longrightarrow> length as = length (a # os) \\<and>\n                         set as \\<subseteq> \\<S>", "then"], ["proof (chain)\npicking this:\n  viterbi s t_end [] = (as, v)", "show ?case"], ["proof (prove)\nusing this:\n  viterbi s t_end [] = (as, v)\n\ngoal (1 subgoal):\n 1. length as = length [] \\<and> set as \\<subseteq> \\<S>", "by simp"], ["proof (state)\nthis:\n  length as = length [] \\<and> set as \\<subseteq> \\<S>\n\ngoal (1 subgoal):\n 1. \\<And>a os s as v.\n       \\<lbrakk>\\<And>s as v.\n                   viterbi s t_end os = (as, v) \\<Longrightarrow>\n                   length as = length os \\<and> set as \\<subseteq> \\<S>;\n        viterbi s t_end (a # os) = (as, v)\\<rbrakk>\n       \\<Longrightarrow> length as = length (a # os) \\<and>\n                         set as \\<subseteq> \\<S>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a os s as v.\n       \\<lbrakk>\\<And>s as v.\n                   viterbi s t_end os = (as, v) \\<Longrightarrow>\n                   length as = length os \\<and> set as \\<subseteq> \\<S>;\n        viterbi s t_end (a # os) = (as, v)\\<rbrakk>\n       \\<Longrightarrow> length as = length (a # os) \\<and>\n                         set as \\<subseteq> \\<S>", "case (Cons o os s as v)"], ["proof (state)\nthis:\n  viterbi ?s1 t_end os = (?as1, ?v1) \\<Longrightarrow>\n  length ?as1 = length os \\<and> set ?as1 \\<subseteq> \\<S>\n  viterbi s t_end (o # os) = (as, v)\n\ngoal (1 subgoal):\n 1. \\<And>a os s as v.\n       \\<lbrakk>\\<And>s as v.\n                   viterbi s t_end os = (as, v) \\<Longrightarrow>\n                   length as = length os \\<and> set as \\<subseteq> \\<S>;\n        viterbi s t_end (a # os) = (as, v)\\<rbrakk>\n       \\<Longrightarrow> length as = length (a # os) \\<and>\n                         set as \\<subseteq> \\<S>", "let ?xs = \"map\n    (\\<lambda>t. let (xs, v) = viterbi t t_end os in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n    state_list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a os s as v.\n       \\<lbrakk>\\<And>s as v.\n                   viterbi s t_end os = (as, v) \\<Longrightarrow>\n                   length as = length os \\<and> set as \\<subseteq> \\<S>;\n        viterbi s t_end (a # os) = (as, v)\\<rbrakk>\n       \\<Longrightarrow> length as = length (a # os) \\<and>\n                         set as \\<subseteq> \\<S>", "from state_list_nonempty"], ["proof (chain)\npicking this:\n  state_list \\<noteq> []", "have \"?xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  state_list \\<noteq> []\n\ngoal (1 subgoal):\n 1. map (\\<lambda>t.\n            let (xs, v) = viterbi t t_end os\n            in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n     state_list \\<noteq>\n    []", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>t.\n          let (xs, v) = viterbi t t_end os\n          in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n   state_list \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. \\<And>a os s as v.\n       \\<lbrakk>\\<And>s as v.\n                   viterbi s t_end os = (as, v) \\<Longrightarrow>\n                   length as = length os \\<and> set as \\<subseteq> \\<S>;\n        viterbi s t_end (a # os) = (as, v)\\<rbrakk>\n       \\<Longrightarrow> length as = length (a # os) \\<and>\n                         set as \\<subseteq> \\<S>", "from argmax(1)[OF this, of snd]"], ["proof (chain)\npicking this:\n  fst (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list))\n  \\<in> set (map (\\<lambda>t.\n                     let (xs, v) = viterbi t t_end os\n                     in (t # xs,\n                         ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n              state_list)", "obtain t where \"t \\<in> \\<S>\"\n    \"fst (argmax snd ?xs) =\n    (t # fst (viterbi t t_end os), ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * snd (viterbi t t_end os))\""], ["proof (prove)\nusing this:\n  fst (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list))\n  \\<in> set (map (\\<lambda>t.\n                     let (xs, v) = viterbi t t_end os\n                     in (t # xs,\n                         ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n              state_list)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> \\<S>;\n         fst (argmax snd\n               (map (\\<lambda>t.\n                        let (xs, v) = viterbi t t_end os\n                        in (t # xs,\n                            ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n                 state_list)) =\n         (t # fst (viterbi t t_end os),\n          ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) *\n          snd (viterbi t t_end os))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: state_list_\\<S> split: prod.splits)"], ["proof (state)\nthis:\n  t \\<in> \\<S>\n  fst (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list)) =\n  (t # fst (viterbi t t_end os),\n   ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * snd (viterbi t t_end os))\n\ngoal (1 subgoal):\n 1. \\<And>a os s as v.\n       \\<lbrakk>\\<And>s as v.\n                   viterbi s t_end os = (as, v) \\<Longrightarrow>\n                   length as = length os \\<and> set as \\<subseteq> \\<S>;\n        viterbi s t_end (a # os) = (as, v)\\<rbrakk>\n       \\<Longrightarrow> length as = length (a # os) \\<and>\n                         set as \\<subseteq> \\<S>", "with Cons.prems"], ["proof (chain)\npicking this:\n  viterbi s t_end (o # os) = (as, v)\n  t \\<in> \\<S>\n  fst (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list)) =\n  (t # fst (viterbi t t_end os),\n   ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * snd (viterbi t t_end os))", "show ?case"], ["proof (prove)\nusing this:\n  viterbi s t_end (o # os) = (as, v)\n  t \\<in> \\<S>\n  fst (argmax snd\n        (map (\\<lambda>t.\n                 let (xs, v) = viterbi t t_end os\n                 in (t # xs, ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * v))\n          state_list)) =\n  (t # fst (viterbi t t_end os),\n   ennreal (pmf (\\<O> t) o * pmf (\\<K> s) t) * snd (viterbi t t_end os))\n\ngoal (1 subgoal):\n 1. length as = length (o # os) \\<and> set as \\<subseteq> \\<S>", "by (cases \"viterbi t t_end os\"; simp add: Cons.IH)"], ["proof (state)\nthis:\n  length as = length (o # os) \\<and> set as \\<subseteq> \\<S>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"viterbi_final s os = fst (argmax snd (map (\\<lambda> t. viterbi s t os) state_list))\""], ["", "lemma viterbi_finalE:\n  obtains t where\n    \"t \\<in> \\<S>\" \"viterbi_final s os = viterbi s t os\"\n    \"snd (viterbi s t os) = Max ((\\<lambda>t. snd (viterbi s t os)) ` \\<S>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> \\<S>; viterbi_final s os = viterbi s t os;\n         snd (viterbi s t os) =\n         (MAX t\\<in>\\<S>. snd (viterbi s t os))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> \\<S>; viterbi_final s os = viterbi s t os;\n         snd (viterbi s t os) =\n         (MAX t\\<in>\\<S>. snd (viterbi s t os))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from state_list_nonempty"], ["proof (chain)\npicking this:\n  state_list \\<noteq> []", "have \"map (\\<lambda> t. viterbi s t os) state_list \\<noteq> []\""], ["proof (prove)\nusing this:\n  state_list \\<noteq> []\n\ngoal (1 subgoal):\n 1. map (\\<lambda>t. viterbi s t os) state_list \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>t. viterbi s t os) state_list \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> \\<S>; viterbi_final s os = viterbi s t os;\n         snd (viterbi s t os) =\n         (MAX t\\<in>\\<S>. snd (viterbi s t os))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from argmax[OF this, of snd]"], ["proof (chain)\npicking this:\n  fst (argmax snd (map (\\<lambda>t. viterbi s t os) state_list))\n  \\<in> set (map (\\<lambda>t. viterbi s t os) state_list)\n  snd (fst (argmax snd (map (\\<lambda>t. viterbi s t os) state_list))) =\n  snd (argmax snd (map (\\<lambda>t. viterbi s t os) state_list))\n  snd (argmax snd (map (\\<lambda>t. viterbi s t os) state_list)) =\n  Max (snd ` set (map (\\<lambda>t. viterbi s t os) state_list))", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (argmax snd (map (\\<lambda>t. viterbi s t os) state_list))\n  \\<in> set (map (\\<lambda>t. viterbi s t os) state_list)\n  snd (fst (argmax snd (map (\\<lambda>t. viterbi s t os) state_list))) =\n  snd (argmax snd (map (\\<lambda>t. viterbi s t os) state_list))\n  snd (argmax snd (map (\\<lambda>t. viterbi s t os) state_list)) =\n  Max (snd ` set (map (\\<lambda>t. viterbi s t os) state_list))\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: state_list_\\<S> image_comp comp_def viterbi_final_def intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem viterbi_final_max_prob:\n  assumes \"viterbi_final s os = (as, v)\" \"s \\<in> \\<S>\"\n  shows \"v = max_prob s os\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = max_prob s os", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v = max_prob s os", "obtain t where \"t \\<in> \\<S>\" \"viterbi_final s os = viterbi s t os\"\n    \"snd (viterbi s t os) = Max ((\\<lambda>t. snd (viterbi s t os)) ` \\<S>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> \\<S>; viterbi_final s os = viterbi s t os;\n         snd (viterbi s t os) =\n         (MAX t\\<in>\\<S>. snd (viterbi s t os))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule viterbi_finalE)"], ["proof (state)\nthis:\n  t \\<in> \\<S>\n  viterbi_final s os = viterbi s t os\n  snd (viterbi s t os) = (MAX t\\<in>\\<S>. snd (viterbi s t os))\n\ngoal (1 subgoal):\n 1. v = max_prob s os", "with assms"], ["proof (chain)\npicking this:\n  viterbi_final s os = (as, v)\n  s \\<in> \\<S>\n  t \\<in> \\<S>\n  viterbi_final s os = viterbi s t os\n  snd (viterbi s t os) = (MAX t\\<in>\\<S>. snd (viterbi s t os))", "show ?thesis"], ["proof (prove)\nusing this:\n  viterbi_final s os = (as, v)\n  s \\<in> \\<S>\n  t \\<in> \\<S>\n  viterbi_final s os = viterbi s t os\n  snd (viterbi s t os) = (MAX t\\<in>\\<S>. snd (viterbi s t os))\n\ngoal (1 subgoal):\n 1. v = max_prob s os", "by (simp add: viterbi_viterbi_prob max_prob_viterbi)"], ["proof (state)\nthis:\n  v = max_prob s os\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem viterbi_final_is_decoding:\n  assumes \"viterbi_final s os = (as, v)\" \"v > 0\" \"s \\<in> \\<S>\"\n  shows \"is_decoding s os as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_decoding s os as", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_decoding s os as", "from viterbi_valid_path[of s _ os as v] assms"], ["proof (chain)\npicking this:\n  viterbi s ?t_end os = (as, v) \\<Longrightarrow>\n  length as = length os \\<and> set as \\<subseteq> \\<S>\n  viterbi_final s os = (as, v)\n  0 < v\n  s \\<in> \\<S>", "have as: \"length as = length os\" \"set as \\<subseteq> \\<S>\""], ["proof (prove)\nusing this:\n  viterbi s ?t_end os = (as, v) \\<Longrightarrow>\n  length as = length os \\<and> set as \\<subseteq> \\<S>\n  viterbi_final s os = (as, v)\n  0 < v\n  s \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. length as = length os &&& set as \\<subseteq> \\<S>", "by - (rule viterbi_finalE[of s os]; simp)+"], ["proof (state)\nthis:\n  length as = length os\n  set as \\<subseteq> \\<S>\n\ngoal (1 subgoal):\n 1. is_decoding s os as", "obtain t where \"t \\<in> \\<S>\" \"viterbi_final s os = viterbi s t os\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> \\<S>; viterbi_final s os = viterbi s t os\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule viterbi_finalE)"], ["proof (state)\nthis:\n  t \\<in> \\<S>\n  viterbi_final s os = viterbi s t os\n\ngoal (1 subgoal):\n 1. is_decoding s os as", "with assms viterbi_sequence[of s t os]"], ["proof (chain)\npicking this:\n  viterbi_final s os = (as, v)\n  0 < v\n  s \\<in> \\<S>\n  0 < snd (viterbi s t os) \\<Longrightarrow>\n  snd (viterbi s t os) = val_of s (fst (viterbi s t os)) os\n  t \\<in> \\<S>\n  viterbi_final s os = viterbi s t os", "have \"val_of s as os = v\""], ["proof (prove)\nusing this:\n  viterbi_final s os = (as, v)\n  0 < v\n  s \\<in> \\<S>\n  0 < snd (viterbi s t os) \\<Longrightarrow>\n  snd (viterbi s t os) = val_of s (fst (viterbi s t os)) os\n  t \\<in> \\<S>\n  viterbi_final s os = viterbi s t os\n\ngoal (1 subgoal):\n 1. val_of s as os = v", "by (cases \"viterbi s t os\") (auto simp: snd_def split!: prod.splits)"], ["proof (state)\nthis:\n  val_of s as os = v\n\ngoal (1 subgoal):\n 1. is_decoding s os as", "with val_of_T as"], ["proof (chain)\npicking this:\n  length ?as = length ?os \\<Longrightarrow>\n  val_of ?s ?as ?os =\n  emeasure (T (?s, ?o\\<^sub>1))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip ?as ?os @- \\<omega>'}\n  length as = length os\n  set as \\<subseteq> \\<S>\n  val_of s as os = v", "have \"max_prob s os = T (s, obs) {\\<omega> \\<in> space S. V os as \\<omega>}\""], ["proof (prove)\nusing this:\n  length ?as = length ?os \\<Longrightarrow>\n  val_of ?s ?as ?os =\n  emeasure (T (?s, ?o\\<^sub>1))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip ?as ?os @- \\<omega>'}\n  length as = length os\n  set as \\<subseteq> \\<S>\n  val_of s as os = v\n\ngoal (1 subgoal):\n 1. max_prob s os =\n    emeasure (T (s, obs))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "by (simp add: viterbi_final_max_prob[OF assms(1,3)])"], ["proof (state)\nthis:\n  max_prob s os =\n  emeasure (T (s, obs))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}\n\ngoal (1 subgoal):\n 1. is_decoding s os as", "with as"], ["proof (chain)\npicking this:\n  length as = length os\n  set as \\<subseteq> \\<S>\n  max_prob s os =\n  emeasure (T (s, obs))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}", "show ?thesis"], ["proof (prove)\nusing this:\n  length as = length os\n  set as \\<subseteq> \\<S>\n  max_prob s os =\n  emeasure (T (s, obs))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}\n\ngoal (1 subgoal):\n 1. is_decoding s os as", "unfolding is_decoding_def"], ["proof (prove)\nusing this:\n  length as = length os\n  set as \\<subseteq> \\<S>\n  max_prob s os =\n  emeasure (T (s, obs))\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    \\<exists>\\<omega>'. \\<omega> = zip as os @- \\<omega>'}\n\ngoal (1 subgoal):\n 1. emeasure (T' (I s))\n     {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n      \\<exists>o \\<omega>'. \\<omega> = (s, o) ## zip as os @- \\<omega>'} =\n    max_prob s os \\<and>\n    length as = length os \\<and> set as \\<subseteq> \\<S>", "by (simp only: T'_I_T)"], ["proof (state)\nthis:\n  is_decoding s os as\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* Anonymous context *)"], ["", "end"], ["", "(* HMM 3 *)"], ["", "end"], ["", "(* Theory *)"]]}