{"file_name": "/home/qj213/afp-2021-10-22/thys/Integration/Sigma_Algebra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Integration", "problem_names": ["theorem sigma_UNIV: \"UNIV \\<in> sigma A\"", "theorem sigma_Inter:\n  \"(\\<And>i::nat. a i \\<in> sigma A) \\<Longrightarrow> (\\<Inter>i. a i) \\<in> sigma A\"", "theorem assumes sa: \"sigma_algebra A\"\n  \\<comment> \\<open>Named premises are introduced like this.\\<close>\n\n  shows sigma_sigma_algebra: \"sigma A = A\"", "theorem assumes s: \"sigma_algebra A\" and a: \"a \\<in> A\" and b: \"b \\<in> A\"\n  shows sigma_algebra_inter: \"a \\<inter> b \\<in> A\"", "theorem sigma_INTER:\n  assumes a:\"(\\<And>i::nat. i \\<in> S \\<Longrightarrow> a i \\<in> sigma A)\"\n  shows \"(\\<Inter>i\\<in>S. a i) \\<in> sigma A\"", "lemma assumes s: \"sigma_algebra a\" shows sigma_algebra_UNIV: \"UNIV \\<in> a\""], "translations": [["", "theorem sigma_UNIV: \"UNIV \\<in> sigma A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<in> sigma A", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<in> sigma A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UNIV \\<in> sigma A", "have \"{} \\<in> sigma A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<in> sigma A", "by (rule sigma.empty)"], ["proof (state)\nthis:\n  {} \\<in> sigma A\n\ngoal (1 subgoal):\n 1. UNIV \\<in> sigma A", "hence \"-{} \\<in> sigma A\""], ["proof (prove)\nusing this:\n  {} \\<in> sigma A\n\ngoal (1 subgoal):\n 1. - {} \\<in> sigma A", "by (rule sigma.complement)"], ["proof (state)\nthis:\n  - {} \\<in> sigma A\n\ngoal (1 subgoal):\n 1. UNIV \\<in> sigma A", "also"], ["proof (state)\nthis:\n  - {} \\<in> sigma A\n\ngoal (1 subgoal):\n 1. UNIV \\<in> sigma A", "have \"-{} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - {} = UNIV", "by simp"], ["proof (state)\nthis:\n  - {} = UNIV\n\ngoal (1 subgoal):\n 1. UNIV \\<in> sigma A", "finally"], ["proof (chain)\npicking this:\n  UNIV \\<in> sigma A", "show ?thesis"], ["proof (prove)\nusing this:\n  UNIV \\<in> sigma A\n\ngoal (1 subgoal):\n 1. UNIV \\<in> sigma A", "."], ["proof (state)\nthis:\n  UNIV \\<in> sigma A\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "theorem sigma_Inter:\n  \"(\\<And>i::nat. a i \\<in> sigma A) \\<Longrightarrow> (\\<Inter>i. a i) \\<in> sigma A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. a i \\<in> sigma A) \\<Longrightarrow>\n    \\<Inter> (range a) \\<in> sigma A", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. a i \\<in> sigma A) \\<Longrightarrow>\n    \\<Inter> (range a) \\<in> sigma A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>i. a i \\<in> sigma A) \\<Longrightarrow>\n    \\<Inter> (range a) \\<in> sigma A", "assume \"\\<And>i::nat. a i \\<in> sigma A\""], ["proof (state)\nthis:\n  a ?i \\<in> sigma A\n\ngoal (1 subgoal):\n 1. (\\<And>i. a i \\<in> sigma A) \\<Longrightarrow>\n    \\<Inter> (range a) \\<in> sigma A", "hence \"\\<And>i::nat. -(a i) \\<in> sigma A\""], ["proof (prove)\nusing this:\n  a ?i \\<in> sigma A\n\ngoal (1 subgoal):\n 1. \\<And>i. - a i \\<in> sigma A", "by (rule sigma.complement)"], ["proof (state)\nthis:\n  - a ?i \\<in> sigma A\n\ngoal (1 subgoal):\n 1. (\\<And>i. a i \\<in> sigma A) \\<Longrightarrow>\n    \\<Inter> (range a) \\<in> sigma A", "hence \"(\\<Union>i. -(a i)) \\<in> sigma A\""], ["proof (prove)\nusing this:\n  - a ?i \\<in> sigma A\n\ngoal (1 subgoal):\n 1. (\\<Union>i. - a i) \\<in> sigma A", "by (rule sigma.Union)"], ["proof (state)\nthis:\n  (\\<Union>i. - a i) \\<in> sigma A\n\ngoal (1 subgoal):\n 1. (\\<And>i. a i \\<in> sigma A) \\<Longrightarrow>\n    \\<Inter> (range a) \\<in> sigma A", "hence \"-(\\<Union>i. -(a i)) \\<in> sigma A\""], ["proof (prove)\nusing this:\n  (\\<Union>i. - a i) \\<in> sigma A\n\ngoal (1 subgoal):\n 1. - (\\<Union>i. - a i) \\<in> sigma A", "by (rule sigma.complement)"], ["proof (state)\nthis:\n  - (\\<Union>i. - a i) \\<in> sigma A\n\ngoal (1 subgoal):\n 1. (\\<And>i. a i \\<in> sigma A) \\<Longrightarrow>\n    \\<Inter> (range a) \\<in> sigma A", "also"], ["proof (state)\nthis:\n  - (\\<Union>i. - a i) \\<in> sigma A\n\ngoal (1 subgoal):\n 1. (\\<And>i. a i \\<in> sigma A) \\<Longrightarrow>\n    \\<Inter> (range a) \\<in> sigma A", "have \"-(\\<Union>i. -(a i)) = (\\<Inter>i. a i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (\\<Union>i. - a i) = \\<Inter> (range a)", "by simp"], ["proof (state)\nthis:\n  - (\\<Union>i. - a i) = \\<Inter> (range a)\n\ngoal (1 subgoal):\n 1. (\\<And>i. a i \\<in> sigma A) \\<Longrightarrow>\n    \\<Inter> (range a) \\<in> sigma A", "finally"], ["proof (chain)\npicking this:\n  \\<Inter> (range a) \\<in> sigma A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Inter> (range a) \\<in> sigma A\n\ngoal (1 subgoal):\n 1. \\<Inter> (range a) \\<in> sigma A", "."], ["proof (state)\nthis:\n  \\<Inter> (range a) \\<in> sigma A\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text \\<open>It is trivial to show the connection between our first\n  definitions. We use the opportunity to introduce the proof syntax.\\<close>"], ["", "theorem assumes sa: \"sigma_algebra A\"\n  \\<comment> \\<open>Named premises are introduced like this.\\<close>\n\n  shows sigma_sigma_algebra: \"sigma A = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma A = A", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. sigma A \\<subseteq> A\n 2. A \\<subseteq> sigma A", "txt \\<open>The $\\isacommand {proof}$ command alone invokes a single standard rule to\n    simplify the goal. Here the following two subgoals emerge.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. sigma A \\<subseteq> A\n 2. A \\<subseteq> sigma A", "show \"A \\<subseteq> sigma A\"\n    \\<comment> \\<open>The $\\isacommand {show}$ command starts the proof of a subgoal.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> sigma A", "by (auto simp add: sigma.basic)"], ["proof (state)\nthis:\n  A \\<subseteq> sigma A\n\ngoal (1 subgoal):\n 1. sigma A \\<subseteq> A", "txt \\<open>This is easy enough to be solved by an automatic step,\n    indicated by the keyword $\\isacommand {by}$. The method $\\isacommand {auto}$ is stated in parentheses, with attributes to it following.  In\n    this case, the first introduction rule for the $\\isacommand {sigma}$\n    operator is given as an extra simplification rule.\\<close>"], ["proof (state)\nthis:\n  A \\<subseteq> sigma A\n\ngoal (1 subgoal):\n 1. sigma A \\<subseteq> A", "show \"sigma A \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma A \\<subseteq> A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sigma A \\<Longrightarrow> x \\<in> A", "txt \\<open>Because this goal is not quite as trivial, another proof is\n      invoked, delimiting a block as in a programming language.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sigma A \\<Longrightarrow> x \\<in> A", "fix x\n    \\<comment> \\<open>A new named variable is introduced.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sigma A \\<Longrightarrow> x \\<in> A", "assume \"x \\<in> sigma A\""], ["proof (state)\nthis:\n  x \\<in> sigma A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sigma A \\<Longrightarrow> x \\<in> A", "txt \\<open>An assumption is made that must be justified by the current proof\n      context. In this case the corresponding fact had been generated\n      by a rule automatically invoked by the inner $\\isacommand {proof}$\n      command.\\<close>"], ["proof (state)\nthis:\n  x \\<in> sigma A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sigma A \\<Longrightarrow> x \\<in> A", "from this sa"], ["proof (chain)\npicking this:\n  x \\<in> sigma A\n  sigma_algebra A", "show \"x \\<in> A\""], ["proof (prove)\nusing this:\n  x \\<in> sigma A\n  sigma_algebra A\n\ngoal (1 subgoal):\n 1. x \\<in> A", "txt \\<open>Named facts can explicitly be given to the proof methods using\n        $\\isacommand {from}$. A special name is \\<open>this\\<close>, which denotes\n        current facts generated by the last command. Usually $\\isacommand\n        {from}$ \\<open>this sa\\<close> --- remember that \\<open>sa\\<close> is an assumption from above\n        --- is abbreviated to $\\isacommand {with}$ \\<open>sa\\<close>, but in this case the order of\n        facts is relevant for the following method and $\\isacommand\n        {with}$\n        would have put the current facts last.\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> sigma A\n  sigma_algebra A\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by (induct rule: sigma.induct) (auto simp add: sigma_algebra_def)"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal:\nNo subgoals!", "txt \\<open>Two methods may be carried out at $\\isacommand {by}$. The first\n      one applies induction here via the canonical rule generated by the\n      inductive definition above, while the latter solves the\n      resulting subgoals by an automatic step involving\n      simplification.\\<close>"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sigma A \\<subseteq> A\n\ngoal:\nNo subgoals!", "qed"], ["", "text \"These two steps finish their respective proofs, checking\n  that all subgoals have been proven.\""], ["", "text \\<open>To end this theory we prove a special case of the \\<open>sigma_Inter\\<close> theorem above. It seems trivial that\n  the fact holds for two sets as well as for countably many.\n  We get a first taste of the cost of formal reasoning here, however. The\n  idea must be made precise by exhibiting a concrete sequence of\n  sets.\\<close>"], ["", "primrec trivial_series:: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> (nat \\<Rightarrow> 'a set)\"\nwhere\n  \"trivial_series a b 0 = a\"\n| \"trivial_series a b (Suc n) = b\""], ["", "text \\<open>Using $\\isacommand {primrec}$, primitive recursive functions over\n  inductively defined data types --- the natural numbers in this case ---\n  may be constructed.\\<close>"], ["", "theorem assumes s: \"sigma_algebra A\" and a: \"a \\<in> A\" and b: \"b \\<in> A\"\n  shows sigma_algebra_inter: \"a \\<inter> b \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<inter> b \\<in> A", "proof -\n    \\<comment> \\<open>This form of $\\isacommand {proof}$ foregoes the application of a rule.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<inter> b \\<in> A", "have \"a \\<inter> b = (\\<Inter>i::nat. trivial_series a b i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<inter> b = \\<Inter> (range (trivial_series a b))", "txt \\<open>Intermediate facts that do not solve any subgoals yet are established this way.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<inter> b = \\<Inter> (range (trivial_series a b))", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "txt \\<open>The  $\\isacommand {proof}$ command may also take one explicit method\n      as an argument like the single rule application in this instance.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "assume \"x \\<in> a \\<inter> b\""], ["proof (state)\nthis:\n  x \\<in> a \\<inter> b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "hence \"x \\<in> trivial_series a b i\""], ["proof (prove)\nusing this:\n  x \\<in> a \\<inter> b\n\ngoal (1 subgoal):\n 1. x \\<in> trivial_series a b i", "by (cases i) auto\n        \\<comment> \\<open>This is just an abbreviation for $\\isacommand {\"from this have\"}$.\\<close>"], ["proof (state)\nthis:\n  x \\<in> trivial_series a b i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "}"], ["proof (state)\nthis:\n  x \\<in> a \\<inter> b \\<Longrightarrow> x \\<in> trivial_series a b ?i2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "txt \\<open>Curly braces can be used to explicitly delimit\n      blocks. In conjunction with $\\isacommand {fix}$, universal\n      quantification over the fixed variable $i$ is achieved\n      for the last statement in the block, which is exported to the\n      enclosing block.\\<close>"], ["proof (state)\nthis:\n  x \\<in> a \\<inter> b \\<Longrightarrow> x \\<in> trivial_series a b ?i2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "hence \"x \\<in> a \\<inter> b \\<Longrightarrow> \\<forall>i. x \\<in> trivial_series a b i\""], ["proof (prove)\nusing this:\n  x \\<in> a \\<inter> b \\<Longrightarrow> x \\<in> trivial_series a b ?i2\n\ngoal (1 subgoal):\n 1. x \\<in> a \\<inter> b \\<Longrightarrow>\n    \\<forall>i. x \\<in> trivial_series a b i", "by fast"], ["proof (state)\nthis:\n  x \\<in> a \\<inter> b \\<Longrightarrow>\n  \\<forall>i. x \\<in> trivial_series a b i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "also"], ["proof (state)\nthis:\n  x \\<in> a \\<inter> b \\<Longrightarrow>\n  \\<forall>i. x \\<in> trivial_series a b i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "txt \\<open>The statement $\\isacommand {also}$ introduces calculational\n      reasoning. This basically amounts to collecting facts. With\n      $\\isacommand {also}$, the current fact is added to a special list of\n      theorems called the calculation and\n      an automatically selected transitivity rule\n      is additionally applied from the second collected fact on.\\<close>"], ["proof (state)\nthis:\n  x \\<in> a \\<inter> b \\<Longrightarrow>\n  \\<forall>i. x \\<in> trivial_series a b i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "{"], ["proof (state)\nthis:\n  x \\<in> a \\<inter> b \\<Longrightarrow>\n  \\<forall>i. x \\<in> trivial_series a b i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "assume \"\\<And>i. x \\<in> trivial_series a b i\""], ["proof (state)\nthis:\n  x \\<in> trivial_series a b ?i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "hence \"x \\<in> trivial_series a b 0\" and \"x \\<in> trivial_series a b 1\""], ["proof (prove)\nusing this:\n  x \\<in> trivial_series a b ?i\n\ngoal (1 subgoal):\n 1. x \\<in> trivial_series a b 0 &&& x \\<in> trivial_series a b 1", "by this+"], ["proof (state)\nthis:\n  x \\<in> trivial_series a b 0\n  x \\<in> trivial_series a b 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "hence \"x \\<in> a \\<inter> b\""], ["proof (prove)\nusing this:\n  x \\<in> trivial_series a b 0\n  x \\<in> trivial_series a b 1\n\ngoal (1 subgoal):\n 1. x \\<in> a \\<inter> b", "by simp"], ["proof (state)\nthis:\n  x \\<in> a \\<inter> b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "}"], ["proof (state)\nthis:\n  (\\<And>i. x \\<in> trivial_series a b i) \\<Longrightarrow>\n  x \\<in> a \\<inter> b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "hence \"\\<forall>i. x \\<in> trivial_series a b i \\<Longrightarrow> x \\<in> a \\<inter> b\""], ["proof (prove)\nusing this:\n  (\\<And>i. x \\<in> trivial_series a b i) \\<Longrightarrow>\n  x \\<in> a \\<inter> b\n\ngoal (1 subgoal):\n 1. \\<forall>i. x \\<in> trivial_series a b i \\<Longrightarrow>\n    x \\<in> a \\<inter> b", "by blast"], ["proof (state)\nthis:\n  \\<forall>i. x \\<in> trivial_series a b i \\<Longrightarrow>\n  x \\<in> a \\<inter> b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> a \\<inter> b \\<Longrightarrow>\n  \\<forall>i. x \\<in> trivial_series a b i\n  \\<forall>i. x \\<in> trivial_series a b i \\<Longrightarrow>\n  x \\<in> a \\<inter> b", "have \"x \\<in> a \\<inter> b = (\\<forall>i::nat. x \\<in> trivial_series a b i)\""], ["proof (prove)\nusing this:\n  x \\<in> a \\<inter> b \\<Longrightarrow>\n  \\<forall>i. x \\<in> trivial_series a b i\n  \\<forall>i. x \\<in> trivial_series a b i \\<Longrightarrow>\n  x \\<in> a \\<inter> b\n\ngoal (1 subgoal):\n 1. (x \\<in> a \\<inter> b) = (\\<forall>i. x \\<in> trivial_series a b i)", ".."], ["proof (state)\nthis:\n  (x \\<in> a \\<inter> b) = (\\<forall>i. x \\<in> trivial_series a b i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "txt \\<open>The accumulated calculational facts including the current one\n      are exposed to the next statement by  $\\isacommand {ultimately}$ and\n      the calculation list is then erased. The two dots after the\n      statement here indicate proof by a single automatically\n      selected rule.\\<close>"], ["proof (state)\nthis:\n  (x \\<in> a \\<inter> b) = (\\<forall>i. x \\<in> trivial_series a b i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "also"], ["proof (state)\nthis:\n  (x \\<in> a \\<inter> b) = (\\<forall>i. x \\<in> trivial_series a b i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "have \"\\<dots> =  (x \\<in> (\\<Inter>i::nat. trivial_series a b i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. x \\<in> trivial_series a b i) =\n    (x \\<in> \\<Inter> (range (trivial_series a b)))", "by simp"], ["proof (state)\nthis:\n  (\\<forall>i. x \\<in> trivial_series a b i) =\n  (x \\<in> \\<Inter> (range (trivial_series a b)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> a \\<inter> b) =\n       (x \\<in> \\<Inter> (range (trivial_series a b)))", "finally"], ["proof (chain)\npicking this:\n  (x \\<in> a \\<inter> b) = (x \\<in> \\<Inter> (range (trivial_series a b)))", "show \"x \\<in> a \\<inter> b = (x \\<in> (\\<Inter>i::nat. trivial_series a b i))\""], ["proof (prove)\nusing this:\n  (x \\<in> a \\<inter> b) = (x \\<in> \\<Inter> (range (trivial_series a b)))\n\ngoal (1 subgoal):\n 1. (x \\<in> a \\<inter> b) = (x \\<in> \\<Inter> (range (trivial_series a b)))", "."], ["proof (state)\nthis:\n  (x \\<in> a \\<inter> b) = (x \\<in> \\<Inter> (range (trivial_series a b)))\n\ngoal:\nNo subgoals!", "txt \\<open>The $\\isacommand {finally}$ directive behaves like $\\isacommand {ultimately}$\n      with the addition of a further transitivity rule application. A\n      single dot stands for proof by assumption.\\<close>"], ["proof (state)\nthis:\n  (x \\<in> a \\<inter> b) = (x \\<in> \\<Inter> (range (trivial_series a b)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<inter> b = \\<Inter> (range (trivial_series a b))\n\ngoal (1 subgoal):\n 1. a \\<inter> b \\<in> A", "moreover"], ["proof (state)\nthis:\n  a \\<inter> b = \\<Inter> (range (trivial_series a b))\n\ngoal (1 subgoal):\n 1. a \\<inter> b \\<in> A", "have \"(\\<Inter>i::nat. trivial_series a b i) \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter> (range (trivial_series a b)) \\<in> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Inter> (range (trivial_series a b)) \\<in> A", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Inter> (range (trivial_series a b)) \\<in> A", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Inter> (range (trivial_series a b)) \\<in> A", "from a b"], ["proof (chain)\npicking this:\n  a \\<in> A\n  b \\<in> A", "have \"trivial_series a b i \\<in> A\""], ["proof (prove)\nusing this:\n  a \\<in> A\n  b \\<in> A\n\ngoal (1 subgoal):\n 1. trivial_series a b i \\<in> A", "by (cases i) auto"], ["proof (state)\nthis:\n  trivial_series a b i \\<in> A\n\ngoal (1 subgoal):\n 1. \\<Inter> (range (trivial_series a b)) \\<in> A", "}"], ["proof (state)\nthis:\n  trivial_series a b ?i2 \\<in> A\n\ngoal (1 subgoal):\n 1. \\<Inter> (range (trivial_series a b)) \\<in> A", "hence \"\\<And>i. trivial_series a b i \\<in> sigma A\""], ["proof (prove)\nusing this:\n  trivial_series a b ?i2 \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>i. trivial_series a b i \\<in> sigma A", "by (simp only: sigma.basic)"], ["proof (state)\nthis:\n  trivial_series a b ?i \\<in> sigma A\n\ngoal (1 subgoal):\n 1. \\<Inter> (range (trivial_series a b)) \\<in> A", "hence \"(\\<Inter>i::nat. trivial_series a b i) \\<in> sigma A\""], ["proof (prove)\nusing this:\n  trivial_series a b ?i \\<in> sigma A\n\ngoal (1 subgoal):\n 1. \\<Inter> (range (trivial_series a b)) \\<in> sigma A", "by (simp only: sigma_Inter)"], ["proof (state)\nthis:\n  \\<Inter> (range (trivial_series a b)) \\<in> sigma A\n\ngoal (1 subgoal):\n 1. \\<Inter> (range (trivial_series a b)) \\<in> A", "with s"], ["proof (chain)\npicking this:\n  sigma_algebra A\n  \\<Inter> (range (trivial_series a b)) \\<in> sigma A", "show ?thesis"], ["proof (prove)\nusing this:\n  sigma_algebra A\n  \\<Inter> (range (trivial_series a b)) \\<in> sigma A\n\ngoal (1 subgoal):\n 1. \\<Inter> (range (trivial_series a b)) \\<in> A", "by (simp only: sigma_sigma_algebra)"], ["proof (state)\nthis:\n  \\<Inter> (range (trivial_series a b)) \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Inter> (range (trivial_series a b)) \\<in> A\n\ngoal (1 subgoal):\n 1. a \\<inter> b \\<in> A", "ultimately"], ["proof (chain)\npicking this:\n  a \\<inter> b = \\<Inter> (range (trivial_series a b))\n  \\<Inter> (range (trivial_series a b)) \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<inter> b = \\<Inter> (range (trivial_series a b))\n  \\<Inter> (range (trivial_series a b)) \\<in> A\n\ngoal (1 subgoal):\n 1. a \\<inter> b \\<in> A", "by simp"], ["proof (state)\nthis:\n  a \\<inter> b \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Of course, a like theorem holds for union instead of\n  intersection.  But as we will not need it in what follows, the\n  theory is finished with the following easy properties instead.\n  Note that the former is a kind of generalization of the last result and\n  could be used to  shorten its proof. Unfortunately, this one was needed ---\n  and therefore found --- only late in the development.\n\\<close>"], ["", "theorem sigma_INTER:\n  assumes a:\"(\\<And>i::nat. i \\<in> S \\<Longrightarrow> a i \\<in> sigma A)\"\n  shows \"(\\<Inter>i\\<in>S. a i) \\<in> sigma A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter> (a ` S) \\<in> sigma A", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter> (a ` S) \\<in> sigma A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Inter> (a ` S) \\<in> sigma A", "from a"], ["proof (chain)\npicking this:\n  ?i \\<in> S \\<Longrightarrow> a ?i \\<in> sigma A", "have \"\\<And>i. (if i\\<in>S then {} else UNIV) \\<union> a i \\<in> sigma A\""], ["proof (prove)\nusing this:\n  ?i \\<in> S \\<Longrightarrow> a ?i \\<in> sigma A\n\ngoal (1 subgoal):\n 1. \\<And>i. (if i \\<in> S then {} else UNIV) \\<union> a i \\<in> sigma A", "by (simp add: sigma.intros sigma_UNIV)"], ["proof (state)\nthis:\n  (if ?i \\<in> S then {} else UNIV) \\<union> a ?i \\<in> sigma A\n\ngoal (1 subgoal):\n 1. \\<Inter> (a ` S) \\<in> sigma A", "hence \"(\\<Inter>i. (if i\\<in>S then {} else UNIV) \\<union> a i) \\<in> sigma A\""], ["proof (prove)\nusing this:\n  (if ?i \\<in> S then {} else UNIV) \\<union> a ?i \\<in> sigma A\n\ngoal (1 subgoal):\n 1. (\\<Inter>i. (if i \\<in> S then {} else UNIV) \\<union> a i) \\<in> sigma A", "by (rule sigma_Inter)"], ["proof (state)\nthis:\n  (\\<Inter>i. (if i \\<in> S then {} else UNIV) \\<union> a i) \\<in> sigma A\n\ngoal (1 subgoal):\n 1. \\<Inter> (a ` S) \\<in> sigma A", "also"], ["proof (state)\nthis:\n  (\\<Inter>i. (if i \\<in> S then {} else UNIV) \\<union> a i) \\<in> sigma A\n\ngoal (1 subgoal):\n 1. \\<Inter> (a ` S) \\<in> sigma A", "have \"(\\<Inter>i. (if i\\<in>S then {} else UNIV) \\<union> a i) = (\\<Inter>i\\<in>S. a i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Inter>i. (if i \\<in> S then {} else UNIV) \\<union> a i) =\n    \\<Inter> (a ` S)", "by force"], ["proof (state)\nthis:\n  (\\<Inter>i. (if i \\<in> S then {} else UNIV) \\<union> a i) =\n  \\<Inter> (a ` S)\n\ngoal (1 subgoal):\n 1. \\<Inter> (a ` S) \\<in> sigma A", "finally"], ["proof (chain)\npicking this:\n  \\<Inter> (a ` S) \\<in> sigma A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Inter> (a ` S) \\<in> sigma A\n\ngoal (1 subgoal):\n 1. \\<Inter> (a ` S) \\<in> sigma A", "."], ["proof (state)\nthis:\n  \\<Inter> (a ` S) \\<in> sigma A\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma assumes s: \"sigma_algebra a\" shows sigma_algebra_UNIV: \"UNIV \\<in> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<in> a", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<in> a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UNIV \\<in> a", "from s"], ["proof (chain)\npicking this:\n  sigma_algebra a", "have \"{}\\<in>a\""], ["proof (prove)\nusing this:\n  sigma_algebra a\n\ngoal (1 subgoal):\n 1. {} \\<in> a", "by (unfold sigma_algebra_def) blast"], ["proof (state)\nthis:\n  {} \\<in> a\n\ngoal (1 subgoal):\n 1. UNIV \\<in> a", "with s"], ["proof (chain)\npicking this:\n  sigma_algebra a\n  {} \\<in> a", "show ?thesis"], ["proof (prove)\nusing this:\n  sigma_algebra a\n  {} \\<in> a\n\ngoal (1 subgoal):\n 1. UNIV \\<in> a", "by (unfold sigma_algebra_def) auto"], ["proof (state)\nthis:\n  UNIV \\<in> a\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "end"]]}