{"file_name": "/home/qj213/afp-2021-10-22/thys/CoreC++/Objects.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CoreC++", "problem_names": ["lemma init_obj_nonempty: \"init_obj P C (Cs,fs) \\<Longrightarrow> Cs \\<noteq> []\"", "lemma init_obj_no_Ref: \n\"\\<lbrakk>init_obj P C (Cs,fs);  fs F = Some(Ref(a',Cs'))\\<rbrakk> \\<Longrightarrow> False\"", "lemma SubobjsSet_init_objSet:\n  \"{Cs. Subobjs P C Cs} = {Cs. \\<exists>vmap. init_obj P C (Cs,vmap)}\"", "lemma [simp]: \"obj_ty (C,S) = Class C\"", "lemma new_Addr_SomeD:\n  \"new_Addr h = Some a \\<Longrightarrow> h a = None\""], "translations": [["", "lemma init_obj_nonempty: \"init_obj P C (Cs,fs) \\<Longrightarrow> Cs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_obj P C (Cs, fs) \\<Longrightarrow> Cs \\<noteq> []", "by (fastforce elim:init_obj.cases dest:Subobjs_nonempty)"], ["", "lemma init_obj_no_Ref: \n\"\\<lbrakk>init_obj P C (Cs,fs);  fs F = Some(Ref(a',Cs'))\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init_obj P C (Cs, fs);\n     fs F = \\<lfloor>Ref (a', Cs')\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> False", "by (fastforce elim:init_obj.cases default_val_no_Ref \n                  simp:init_class_fieldmap_def map_of_map)"], ["", "lemma SubobjsSet_init_objSet:\n  \"{Cs. Subobjs P C Cs} = {Cs. \\<exists>vmap. init_obj P C (Cs,vmap)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Cs. Subobjs P C Cs} = {Cs. \\<exists>vmap. init_obj P C (Cs, vmap)}", "by ( fastforce intro:init_obj.intros elim:init_obj.cases)"], ["", "definition obj_ty :: \"obj \\<Rightarrow> ty\" where\n  \"obj_ty obj  \\<equiv>  Class (fst obj)\"\n\n\n \\<comment> \\<open>a new, blank object with default values in all fields:\\<close>"], ["", "definition blank :: \"prog \\<Rightarrow> cname \\<Rightarrow> obj\" where\n  \"blank P C  \\<equiv> (C, Collect (init_obj P C))\""], ["", "lemma [simp]: \"obj_ty (C,S) = Class C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_ty (C, S) = Class C", "by (simp add: obj_ty_def)"], ["", "subsection\\<open>Heap\\<close>"], ["", "type_synonym heap  = \"addr \\<rightharpoonup> obj\""], ["", "abbreviation\n  cname_of :: \"heap \\<Rightarrow> addr \\<Rightarrow> cname\" where\n  \"cname_of hp a == fst (the (hp a))\""], ["", "definition new_Addr :: \"heap \\<Rightarrow> addr option\" where\n  \"new_Addr h  \\<equiv>  if \\<exists>a. h a = None then Some(SOME a. h a = None) else None\""], ["", "lemma new_Addr_SomeD:\n  \"new_Addr h = Some a \\<Longrightarrow> h a = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_Addr h = \\<lfloor>a\\<rfloor> \\<Longrightarrow> h a = None", "by(fastforce simp add:new_Addr_def split:if_splits intro:someI)"], ["", "end"]]}