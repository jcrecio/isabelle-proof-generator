{"file_name": "/home/qj213/afp-2021-10-22/thys/CoreC++/SmallStep.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CoreC++", "problem_names": ["lemma blocks_old_induct:\nfixes P :: \"vname list \\<Rightarrow> ty list \\<Rightarrow> val list \\<Rightarrow> expr \\<Rightarrow> bool\"\nshows\n  \"\\<lbrakk>\\<And>aj ak al. P [] [] (aj # ak) al; \\<And>ad ae a b. P [] (ad # ae) a b;\n  \\<And>V Vs a b. P (V # Vs) [] a b; \\<And>V Vs T Ts aw. P (V # Vs) (T # Ts) [] aw;\n  \\<And>V Vs T Ts v vs e. P Vs Ts vs e \\<Longrightarrow> P (V # Vs) (T # Ts) (v # vs) e; \\<And>e. P [] [] [] e\\<rbrakk>\n  \\<Longrightarrow> P u v w x\"", "lemma [simp]:\n  \"\\<lbrakk> size vs = size Vs; size Ts = size Vs \\<rbrakk> \\<Longrightarrow> fv(blocks(Vs,Ts,vs,e)) = fv e - set Vs\"", "lemmas red_reds_induct = red_reds.induct [split_format (complete)]\n  and red_reds_inducts = red_reds.inducts [split_format (complete)]", "lemma \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow> True\"\nand reds_length:\"P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>] \\<langle>es',s'\\<rangle> \\<Longrightarrow> length es = length es'\"", "lemma[simp]: \"((e,s),e',s') \\<in> Red P E = P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle>\"", "lemma[simp]: \"((es,s),es',s') \\<in> Reds P E = P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>] \\<langle>es',s'\\<rangle>\"", "lemma converse_rtrancl_induct_red[consumes 1]:\nassumes \"P,E \\<turnstile> \\<langle>e,(h,l)\\<rangle> \\<rightarrow>* \\<langle>e',(h',l')\\<rangle>\"\nand \"\\<And>e h l. R e h l e h l\"\nand \"\\<And>e\\<^sub>0 h\\<^sub>0 l\\<^sub>0 e\\<^sub>1 h\\<^sub>1 l\\<^sub>1 e' h' l'.\n       \\<lbrakk> P,E \\<turnstile> \\<langle>e\\<^sub>0,(h\\<^sub>0,l\\<^sub>0)\\<rangle> \\<rightarrow> \\<langle>e\\<^sub>1,(h\\<^sub>1,l\\<^sub>1)\\<rangle>; R e\\<^sub>1 h\\<^sub>1 l\\<^sub>1 e' h' l' \\<rbrakk> \\<Longrightarrow> R e\\<^sub>0 h\\<^sub>0 l\\<^sub>0 e' h' l'\"\nshows \"R e h l e' h' l'\"", "lemma steps_length:\"P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>]* \\<langle>es',s'\\<rangle> \\<Longrightarrow> length es = length es'\"", "lemma [iff]: \"\\<not> P,E \\<turnstile> \\<langle>[],s\\<rangle> [\\<rightarrow>] \\<langle>es',s'\\<rangle>\"", "lemma [iff]: \"\\<not> P,E \\<turnstile> \\<langle>Val v,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle>\"", "lemma [iff]: \"\\<not> P,E \\<turnstile> \\<langle>Throw r,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle>\"", "lemma red_lcl_incr: \"P,E \\<turnstile> \\<langle>e,(h\\<^sub>0,l\\<^sub>0)\\<rangle> \\<rightarrow> \\<langle>e',(h\\<^sub>1,l\\<^sub>1)\\<rangle> \\<Longrightarrow> dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1\"\nand \"P,E \\<turnstile> \\<langle>es,(h\\<^sub>0,l\\<^sub>0)\\<rangle> [\\<rightarrow>] \\<langle>es',(h\\<^sub>1,l\\<^sub>1)\\<rangle> \\<Longrightarrow> dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1\"", "lemma red_lcl_add: \"P,E \\<turnstile> \\<langle>e,(h,l)\\<rangle> \\<rightarrow> \\<langle>e',(h',l')\\<rangle> \\<Longrightarrow> (\\<And>l\\<^sub>0. P,E \\<turnstile> \\<langle>e,(h,l\\<^sub>0++l)\\<rangle> \\<rightarrow> \\<langle>e',(h',l\\<^sub>0++l')\\<rangle>)\"\nand \"P,E \\<turnstile> \\<langle>es,(h,l)\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l')\\<rangle> \\<Longrightarrow> (\\<And>l\\<^sub>0. P,E \\<turnstile> \\<langle>es,(h,l\\<^sub>0++l)\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l\\<^sub>0++l')\\<rangle>)\"", "lemma Red_lcl_add:\nassumes \"P,E \\<turnstile> \\<langle>e,(h,l)\\<rangle> \\<rightarrow>* \\<langle>e',(h',l')\\<rangle>\" shows \"P,E \\<turnstile> \\<langle>e,(h,l\\<^sub>0++l)\\<rangle> \\<rightarrow>* \\<langle>e',(h',l\\<^sub>0++l')\\<rangle>\"", "lemma \nred_preserves_obj:\"\\<lbrakk>P,E \\<turnstile> \\<langle>e,(h,l)\\<rangle> \\<rightarrow> \\<langle>e',(h',l')\\<rangle>; h a = Some(D,S)\\<rbrakk> \n  \\<Longrightarrow> \\<exists>S'. h' a = Some(D,S')\"\nand reds_preserves_obj:\"\\<lbrakk>P,E \\<turnstile> \\<langle>es,(h,l)\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l')\\<rangle>; h a = Some(D,S)\\<rbrakk> \n  \\<Longrightarrow> \\<exists>S'. h' a = Some(D,S')\""], "translations": [["", "lemma blocks_old_induct:\nfixes P :: \"vname list \\<Rightarrow> ty list \\<Rightarrow> val list \\<Rightarrow> expr \\<Rightarrow> bool\"\nshows\n  \"\\<lbrakk>\\<And>aj ak al. P [] [] (aj # ak) al; \\<And>ad ae a b. P [] (ad # ae) a b;\n  \\<And>V Vs a b. P (V # Vs) [] a b; \\<And>V Vs T Ts aw. P (V # Vs) (T # Ts) [] aw;\n  \\<And>V Vs T Ts v vs e. P Vs Ts vs e \\<Longrightarrow> P (V # Vs) (T # Ts) (v # vs) e; \\<And>e. P [] [] [] e\\<rbrakk>\n  \\<Longrightarrow> P u v w x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>aj ak al. P [] [] (aj # ak) al;\n     \\<And>ad ae a b. P [] (ad # ae) a b; \\<And>V Vs a b. P (V # Vs) [] a b;\n     \\<And>V Vs T Ts aw. P (V # Vs) (T # Ts) [] aw;\n     \\<And>V Vs T Ts v vs e.\n        P Vs Ts vs e \\<Longrightarrow> P (V # Vs) (T # Ts) (v # vs) e;\n     \\<And>e. P [] [] [] e\\<rbrakk>\n    \\<Longrightarrow> P u v w x", "by (induction_schema) (pat_completeness, lexicographic_order)"], ["", "lemma [simp]:\n  \"\\<lbrakk> size vs = size Vs; size Ts = size Vs \\<rbrakk> \\<Longrightarrow> fv(blocks(Vs,Ts,vs,e)) = fv e - set Vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length vs = length Vs; length Ts = length Vs\\<rbrakk>\n    \\<Longrightarrow> fv (blocks (Vs, Ts, vs, e)) = fv e - set Vs", "apply(induct rule:blocks_old_induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>aj ak al.\n       \\<lbrakk>length (aj # ak) = length []; length [] = length []\\<rbrakk>\n       \\<Longrightarrow> fv (blocks ([], [], aj # ak, al)) = fv al - set []\n 2. \\<And>ad ae a b.\n       \\<lbrakk>length a = length []; length (ad # ae) = length []\\<rbrakk>\n       \\<Longrightarrow> fv (blocks ([], ad # ae, a, b)) = fv b - set []\n 3. \\<And>V Vs a b.\n       \\<lbrakk>length a = length (V # Vs);\n        length [] = length (V # Vs)\\<rbrakk>\n       \\<Longrightarrow> fv (blocks (V # Vs, [], a, b)) =\n                         fv b - set (V # Vs)\n 4. \\<And>V Vs T Ts aw.\n       \\<lbrakk>length [] = length (V # Vs);\n        length (T # Ts) = length (V # Vs)\\<rbrakk>\n       \\<Longrightarrow> fv (blocks (V # Vs, T # Ts, [], aw)) =\n                         fv aw - set (V # Vs)\n 5. \\<And>V Vs T Ts v vs e.\n       \\<lbrakk>\\<lbrakk>length vs = length Vs;\n                 length Ts = length Vs\\<rbrakk>\n                \\<Longrightarrow> fv (blocks (Vs, Ts, vs, e)) =\n                                  fv e - set Vs;\n        length (v # vs) = length (V # Vs);\n        length (T # Ts) = length (V # Vs)\\<rbrakk>\n       \\<Longrightarrow> fv (blocks (V # Vs, T # Ts, v # vs, e)) =\n                         fv e - set (V # Vs)\n 6. \\<And>e.\n       \\<lbrakk>length [] = length []; length [] = length []\\<rbrakk>\n       \\<Longrightarrow> fv (blocks ([], [], [], e)) = fv e - set []", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>V Vs Ts vs e.\n       \\<lbrakk>fv (blocks (Vs, Ts, vs, e)) = fv e - set Vs;\n        length vs = length Vs; length Ts = length Vs\\<rbrakk>\n       \\<Longrightarrow> fv e - set Vs - {V} = fv e - insert V (set Vs)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition assigned :: \"vname \\<Rightarrow> expr \\<Rightarrow> bool\" where\n  \"assigned V e  \\<equiv>  \\<exists>v e'. e = (V:= Val v;; e')\""], ["", "subsection \\<open>The rules\\<close>"], ["", "inductive_set\n  red  :: \"prog \\<Rightarrow> (env \\<times> (expr \\<times> state) \\<times> (expr \\<times> state)) set\"\n  and reds  :: \"prog \\<Rightarrow> (env \\<times> (expr list \\<times> state) \\<times> (expr list \\<times> state)) set\"\n  and red' :: \"prog \\<Rightarrow> env \\<Rightarrow> expr \\<Rightarrow> state \\<Rightarrow> expr \\<Rightarrow> state \\<Rightarrow> bool\"\n          (\"_,_ \\<turnstile> ((1\\<langle>_,/_\\<rangle>) \\<rightarrow>/ (1\\<langle>_,/_\\<rangle>))\" [51,0,0,0,0] 81)\n  and reds' :: \"prog \\<Rightarrow> env \\<Rightarrow> expr list \\<Rightarrow> state \\<Rightarrow> expr list \\<Rightarrow> state \\<Rightarrow> bool\"\n          (\"_,_ \\<turnstile> ((1\\<langle>_,/_\\<rangle>) [\\<rightarrow>]/ (1\\<langle>_,/_\\<rangle>))\" [51,0,0,0,0] 81)\n  for P :: prog\nwhere\n\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<equiv> (E,(e,s), e',s') \\<in> red P\"\n| \"P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>] \\<langle>es',s'\\<rangle> \\<equiv> (E,(es,s), es',s') \\<in> reds P\"\n\n| RedNew:\n  \"\\<lbrakk> new_Addr h = Some a; h' = h(a\\<mapsto>(C,Collect (init_obj P C))) \\<rbrakk>\n  \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C, (h,l)\\<rangle> \\<rightarrow> \\<langle>ref (a,[C]), (h',l)\\<rangle>\"\n\n| RedNewFail:\n  \"new_Addr h = None \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>new C, (h,l)\\<rangle> \\<rightarrow> \\<langle>THROW OutOfMemory, (h,l)\\<rangle>\"\n\n| StaticCastRed:\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e, s\\<rangle> \\<rightarrow> \\<langle>\\<lparr>C\\<rparr>e', s'\\<rangle>\"\n\n| RedStaticCastNull:\n  \"P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null, s\\<rangle> \\<rightarrow> \\<langle>null,s\\<rangle>\"\n\n| RedStaticUpCast:\n  \"\\<lbrakk> P \\<turnstile> Path last Cs to C via Cs'; Ds = Cs@\\<^sub>pCs' \\<rbrakk>\n  \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>(ref (a,Cs)), s\\<rangle> \\<rightarrow> \\<langle>ref (a,Ds), s\\<rangle>\"\n\n| RedStaticDownCast:\n  \"P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>(ref (a,Cs@[C]@Cs')), s\\<rangle> \\<rightarrow> \\<langle>ref (a,Cs@[C]), s\\<rangle>\"\n\n| RedStaticCastFail:\n  \"\\<lbrakk>C \\<notin> set Cs; \\<not> P \\<turnstile> (last Cs) \\<preceq>\\<^sup>* C\\<rbrakk>\n  \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>(ref (a,Cs)), s\\<rangle> \\<rightarrow> \\<langle>THROW ClassCast, s\\<rangle>\"\n\n| DynCastRed:\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>Cast C e, s\\<rangle> \\<rightarrow> \\<langle>Cast C e', s'\\<rangle>\"\n\n| RedDynCastNull:\n  \"P,E \\<turnstile> \\<langle>Cast C null, s\\<rangle> \\<rightarrow> \\<langle>null,s\\<rangle>\"\n\n| RedStaticUpDynCast: (* path uniqueness not necessary for type proof but for determinism *)\n  \"\\<lbrakk> P \\<turnstile> Path last Cs to C unique; P \\<turnstile> Path last Cs to C via Cs'; Ds = Cs@\\<^sub>pCs' \\<rbrakk>\n  \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C(ref(a,Cs)),s\\<rangle> \\<rightarrow> \\<langle>ref(a,Ds),s\\<rangle>\"\n\n| RedStaticDownDynCast:\n  \"P,E \\<turnstile> \\<langle>Cast C (ref (a,Cs@[C]@Cs')), s\\<rangle> \\<rightarrow> \\<langle>ref (a,Cs@[C]), s\\<rangle>\"\n\n| RedDynCast:(* path uniqueness not necessary for type proof but for determinism *)\n \"\\<lbrakk> hp s a = Some(D,S); P \\<turnstile> Path D to C via Cs';\n    P \\<turnstile> Path D to C unique \\<rbrakk>\n  \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (a,Cs)), s\\<rangle> \\<rightarrow> \\<langle>ref (a,Cs'), s\\<rangle>\"\n\n| RedDynCastFail:(* third premise not necessary for type proof but for determinism *)\n  \"\\<lbrakk>hp s a = Some(D,S); \\<not> P \\<turnstile> Path D to C unique;\n    \\<not> P \\<turnstile> Path last Cs to C unique; C \\<notin> set Cs \\<rbrakk>\n  \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (a,Cs)), s\\<rangle> \\<rightarrow> \\<langle>null, s\\<rangle>\"\n\n| BinOpRed1:\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2, s\\<rangle> \\<rightarrow> \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2, s'\\<rangle>\"\n\n| BinOpRed2:\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>(Val v\\<^sub>1) \\<guillemotleft>bop\\<guillemotright> e, s\\<rangle> \\<rightarrow> \\<langle>(Val v\\<^sub>1) \\<guillemotleft>bop\\<guillemotright> e', s'\\<rangle>\"\n\n| RedBinOp:\n  \"binop(bop,v\\<^sub>1,v\\<^sub>2) = Some v \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>(Val v\\<^sub>1) \\<guillemotleft>bop\\<guillemotright> (Val v\\<^sub>2), s\\<rangle> \\<rightarrow> \\<langle>Val v,s\\<rangle>\"\n\n| RedVar:\n  \"lcl s V = Some v \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>Var V,s\\<rangle> \\<rightarrow> \\<langle>Val v,s\\<rangle>\"\n\n| LAssRed:\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>V:=e,s\\<rangle> \\<rightarrow> \\<langle>V:=e',s'\\<rangle>\"\n\n| RedLAss:\n  \"\\<lbrakk>E V = Some T; P \\<turnstile> T casts v to v'\\<rbrakk> \\<Longrightarrow> \n  P,E \\<turnstile> \\<langle>V:=(Val v),(h,l)\\<rangle> \\<rightarrow> \\<langle>Val v',(h,l(V\\<mapsto>v'))\\<rangle>\"\n\n| FAccRed:\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>e\\<bullet>F{Cs}, s\\<rangle> \\<rightarrow> \\<langle>e'\\<bullet>F{Cs}, s'\\<rangle>\"\n\n| RedFAcc:\n  \"\\<lbrakk> hp s a = Some(D,S); Ds = Cs'@\\<^sub>pCs; (Ds,fs) \\<in> S; fs F = Some v \\<rbrakk>\n  \\<Longrightarrow> P,E \\<turnstile> \\<langle>(ref (a,Cs'))\\<bullet>F{Cs}, s\\<rangle> \\<rightarrow> \\<langle>Val v,s\\<rangle>\"\n\n| RedFAccNull:\n  \"P,E \\<turnstile> \\<langle>null\\<bullet>F{Cs}, s\\<rangle> \\<rightarrow> \\<langle>THROW NullPointer, s\\<rangle>\"\n\n| FAssRed1:\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>e\\<bullet>F{Cs}:=e\\<^sub>2, s\\<rangle> \\<rightarrow> \\<langle>e'\\<bullet>F{Cs}:=e\\<^sub>2, s'\\<rangle>\"\n\n| FAssRed2:\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n   P,E \\<turnstile> \\<langle>Val v\\<bullet>F{Cs}:=e, s\\<rangle> \\<rightarrow> \\<langle>Val v\\<bullet>F{Cs}:=e', s'\\<rangle>\"\n\n| RedFAss:\n\"\\<lbrakk>h a = Some(D,S); P \\<turnstile> (last Cs') has least F:T via Cs;\n  P \\<turnstile> T casts v to v'; Ds = Cs'@\\<^sub>pCs; (Ds,fs) \\<in> S\\<rbrakk> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>(ref (a,Cs'))\\<bullet>F{Cs}:=(Val v), (h,l)\\<rangle> \\<rightarrow> \\<langle>Val v', (h(a \\<mapsto> (D,insert (Ds,fs(F\\<mapsto>v')) (S - {(Ds,fs)}))),l)\\<rangle>\"\n\n| RedFAssNull:\n  \"P,E \\<turnstile> \\<langle>null\\<bullet>F{Cs}:=Val v, s\\<rangle> \\<rightarrow> \\<langle>THROW NullPointer, s\\<rangle>\"\n\n| CallObj:\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>Call e Copt M es,s\\<rangle> \\<rightarrow> \\<langle>Call e' Copt M es,s'\\<rangle>\"\n\n| CallParams:\n  \"P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>] \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n   P,E \\<turnstile> \\<langle>Call (Val v) Copt M es,s\\<rangle> \\<rightarrow> \\<langle>Call (Val v) Copt M es',s'\\<rangle>\"\n\n| RedCall:\n  \"\\<lbrakk> hp s a = Some(C,S); P \\<turnstile> last Cs has least M = (Ts',T',pns',body') via Ds;\n    P \\<turnstile> (C,Cs@\\<^sub>pDs) selects M = (Ts,T,pns,body) via Cs';\n    size vs = size pns; size Ts = size pns; \n    bs = blocks(this#pns,Class(last Cs')#Ts,Ref(a,Cs')#vs,body);\n    new_body = (case T' of Class D \\<Rightarrow> \\<lparr>D\\<rparr>bs | _ \\<Rightarrow> bs)\\<rbrakk>\n  \\<Longrightarrow> P,E \\<turnstile> \\<langle>(ref (a,Cs))\\<bullet>M(map Val vs), s\\<rangle> \\<rightarrow> \\<langle>new_body, s\\<rangle>\"\n\n| RedStaticCall:\n  \"\\<lbrakk> P \\<turnstile> Path (last Cs) to C unique; P \\<turnstile> Path (last Cs) to C via Cs'';\n    P \\<turnstile> C has least M = (Ts,T,pns,body) via Cs'; Ds = (Cs@\\<^sub>pCs'')@\\<^sub>pCs';\n    size vs = size pns; size Ts = size pns \\<rbrakk>\n  \\<Longrightarrow> P,E \\<turnstile> \\<langle>(ref (a,Cs))\\<bullet>(C::)M(map Val vs), s\\<rangle> \\<rightarrow> \n            \\<langle>blocks(this#pns,Class(last Ds)#Ts,Ref(a,Ds)#vs,body), s\\<rangle>\"\n\n| RedCallNull:\n  \"P,E \\<turnstile> \\<langle>Call null Copt M (map Val vs),s\\<rangle> \\<rightarrow> \\<langle>THROW NullPointer,s\\<rangle>\"\n\n| BlockRedNone:\n  \"\\<lbrakk> P,E(V \\<mapsto> T) \\<turnstile> \\<langle>e, (h,l(V:=None))\\<rangle> \\<rightarrow> \\<langle>e', (h',l')\\<rangle>; l' V = None; \\<not> assigned V e \\<rbrakk>\n  \\<Longrightarrow> P,E \\<turnstile> \\<langle>{V:T; e}, (h,l)\\<rangle> \\<rightarrow> \\<langle>{V:T; e'}, (h',l'(V := l V))\\<rangle>\"\n\n| BlockRedSome:\n  \"\\<lbrakk> P,E(V \\<mapsto> T) \\<turnstile> \\<langle>e, (h,l(V:=None))\\<rangle> \\<rightarrow> \\<langle>e', (h',l')\\<rangle>; l' V = Some v;\n     \\<not> assigned V e \\<rbrakk>\n  \\<Longrightarrow> P,E \\<turnstile> \\<langle>{V:T; e}, (h,l)\\<rangle> \\<rightarrow> \\<langle>{V:T := Val v; e'}, (h',l'(V := l V))\\<rangle>\"\n\n| InitBlockRed:\n  \"\\<lbrakk> P,E(V \\<mapsto> T) \\<turnstile> \\<langle>e, (h,l(V\\<mapsto>v'))\\<rangle> \\<rightarrow> \\<langle>e', (h',l')\\<rangle>; l' V = Some v''; \n     P \\<turnstile> T casts v to v' \\<rbrakk>\n  \\<Longrightarrow> P,E \\<turnstile> \\<langle>{V:T := Val v; e}, (h,l)\\<rangle> \\<rightarrow> \\<langle>{V:T := Val v''; e'}, (h',l'(V := l V))\\<rangle>\"\n\n| RedBlock:\n  \"P,E \\<turnstile> \\<langle>{V:T; Val u}, s\\<rangle> \\<rightarrow> \\<langle>Val u, s\\<rangle>\"\n\n| RedInitBlock:\n  \"P \\<turnstile> T casts v to v' \\<Longrightarrow> P,E \\<turnstile> \\<langle>{V:T := Val v; Val u}, s\\<rangle> \\<rightarrow> \\<langle>Val u, s\\<rangle>\"\n\n| SeqRed:\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>e;;e\\<^sub>2, s\\<rangle> \\<rightarrow> \\<langle>e';;e\\<^sub>2, s'\\<rangle>\"\n\n| RedSeq:\n  \"P,E \\<turnstile> \\<langle>(Val v);;e\\<^sub>2, s\\<rangle> \\<rightarrow> \\<langle>e\\<^sub>2, s\\<rangle>\"\n\n| CondRed:\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>if (e) e\\<^sub>1 else e\\<^sub>2, s\\<rangle> \\<rightarrow> \\<langle>if (e') e\\<^sub>1 else e\\<^sub>2, s'\\<rangle>\"\n\n| RedCondT:\n  \"P,E \\<turnstile> \\<langle>if (true) e\\<^sub>1 else e\\<^sub>2, s\\<rangle> \\<rightarrow> \\<langle>e\\<^sub>1, s\\<rangle>\"\n\n| RedCondF:\n  \"P,E \\<turnstile> \\<langle>if (false) e\\<^sub>1 else e\\<^sub>2, s\\<rangle> \\<rightarrow> \\<langle>e\\<^sub>2, s\\<rangle>\"\n\n| RedWhile:\n  \"P,E \\<turnstile> \\<langle>while(b) c, s\\<rangle> \\<rightarrow> \\<langle>if(b) (c;;while(b) c) else unit, s\\<rangle>\"\n\n| ThrowRed:\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>throw e, s\\<rangle> \\<rightarrow> \\<langle>throw e', s'\\<rangle>\"\n\n| RedThrowNull:\n  \"P,E \\<turnstile> \\<langle>throw null, s\\<rangle> \\<rightarrow> \\<langle>THROW NullPointer, s\\<rangle>\"\n\n| ListRed1:\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>e#es,s\\<rangle> [\\<rightarrow>] \\<langle>e'#es,s'\\<rangle>\"\n\n| ListRed2:\n  \"P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>] \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>Val v # es,s\\<rangle> [\\<rightarrow>] \\<langle>Val v # es',s'\\<rangle>\"\n\n\\<comment> \\<open>Exception propagation\\<close>\n\n| DynCastThrow: \"P,E \\<turnstile> \\<langle>Cast C (Throw r), s\\<rangle> \\<rightarrow> \\<langle>Throw r, s\\<rangle>\"\n| StaticCastThrow: \"P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>(Throw r), s\\<rangle> \\<rightarrow> \\<langle>Throw r, s\\<rangle>\"\n| BinOpThrow1: \"P,E \\<turnstile> \\<langle>(Throw r) \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2, s\\<rangle> \\<rightarrow> \\<langle>Throw r, s\\<rangle>\"\n| BinOpThrow2: \"P,E \\<turnstile> \\<langle>(Val v\\<^sub>1) \\<guillemotleft>bop\\<guillemotright> (Throw r), s\\<rangle> \\<rightarrow> \\<langle>Throw r, s\\<rangle>\"\n| LAssThrow: \"P,E \\<turnstile> \\<langle>V:=(Throw r), s\\<rangle> \\<rightarrow> \\<langle>Throw r, s\\<rangle>\"\n| FAccThrow: \"P,E \\<turnstile> \\<langle>(Throw r)\\<bullet>F{Cs}, s\\<rangle> \\<rightarrow> \\<langle>Throw r, s\\<rangle>\"\n| FAssThrow1: \"P,E \\<turnstile> \\<langle>(Throw r)\\<bullet>F{Cs}:=e\\<^sub>2, s\\<rangle> \\<rightarrow> \\<langle>Throw r,s\\<rangle>\"\n| FAssThrow2: \"P,E \\<turnstile> \\<langle>Val v\\<bullet>F{Cs}:=(Throw r), s\\<rangle> \\<rightarrow> \\<langle>Throw r, s\\<rangle>\"\n| CallThrowObj: \"P,E \\<turnstile> \\<langle>Call (Throw r) Copt M es, s\\<rangle> \\<rightarrow> \\<langle>Throw r, s\\<rangle>\"\n| CallThrowParams: \"\\<lbrakk> es = map Val vs @ Throw r # es' \\<rbrakk> \n  \\<Longrightarrow> P,E \\<turnstile> \\<langle>Call (Val v) Copt M es, s\\<rangle> \\<rightarrow> \\<langle>Throw r, s\\<rangle>\"\n| BlockThrow: \"P,E \\<turnstile> \\<langle>{V:T; Throw r}, s\\<rangle> \\<rightarrow> \\<langle>Throw r, s\\<rangle>\"\n| InitBlockThrow: \"P \\<turnstile> T casts v to v' \n  \\<Longrightarrow> P,E \\<turnstile> \\<langle>{V:T := Val v; Throw r}, s\\<rangle> \\<rightarrow> \\<langle>Throw r, s\\<rangle>\"\n| SeqThrow: \"P,E \\<turnstile> \\<langle>(Throw r);;e\\<^sub>2, s\\<rangle> \\<rightarrow> \\<langle>Throw r, s\\<rangle>\"\n| CondThrow: \"P,E \\<turnstile> \\<langle>if (Throw r) e\\<^sub>1 else e\\<^sub>2, s\\<rangle> \\<rightarrow> \\<langle>Throw r, s\\<rangle>\"\n| ThrowThrow: \"P,E \\<turnstile> \\<langle>throw(Throw r), s\\<rangle> \\<rightarrow> \\<langle>Throw r, s\\<rangle>\""], ["", "lemmas red_reds_induct = red_reds.induct [split_format (complete)]\n  and red_reds_inducts = red_reds.inducts [split_format (complete)]"], ["", "inductive_cases [elim!]:\n \"P,E \\<turnstile> \\<langle>V:=e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle>\"\n \"P,E \\<turnstile> \\<langle>e1;;e2,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle>\""], ["", "declare Cons_eq_map_conv [iff]"], ["", "lemma \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle> \\<Longrightarrow> True\"\nand reds_length:\"P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>] \\<langle>es',s'\\<rangle> \\<Longrightarrow> length es = length es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow>\n                      \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n     True) &&&\n    (P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>]\n                      \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n     length es = length es')", "by (induct rule: red_reds.inducts) auto"], ["", "subsection\\<open>The reflexive transitive closure\\<close>"], ["", "definition Red :: \"prog \\<Rightarrow> env \\<Rightarrow> ((expr \\<times> state) \\<times> (expr \\<times> state)) set\"\n  where \"Red P E = {((e,s),e',s'). P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle>}\""], ["", "definition Reds :: \"prog \\<Rightarrow> env \\<Rightarrow> ((expr list \\<times> state) \\<times> (expr list \\<times> state)) set\"\n  where \"Reds P E = {((es,s),es',s'). P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>] \\<langle>es',s'\\<rangle>}\""], ["", "lemma[simp]: \"((e,s),e',s') \\<in> Red P E = P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((e, s), e', s') \\<in> Red P E) =\n    P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow>\n                     \\<langle>e',s'\\<rangle>", "by (simp add:Red_def)"], ["", "lemma[simp]: \"((es,s),es',s') \\<in> Reds P E = P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>] \\<langle>es',s'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((es, s), es', s') \\<in> Reds P E) =\n    P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>]\n                     \\<langle>es',s'\\<rangle>", "by (simp add:Reds_def)"], ["", "abbreviation\n  Step :: \"prog \\<Rightarrow> env \\<Rightarrow> expr \\<Rightarrow> state \\<Rightarrow> expr \\<Rightarrow> state \\<Rightarrow> bool\"\n          (\"_,_ \\<turnstile> ((1\\<langle>_,/_\\<rangle>) \\<rightarrow>*/ (1\\<langle>_,/_\\<rangle>))\" [51,0,0,0,0] 81) where\n  \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow>* \\<langle>e',s'\\<rangle> \\<equiv> ((e,s), e',s') \\<in> (Red P E)\\<^sup>*\""], ["", "abbreviation\n  Steps :: \"prog \\<Rightarrow> env \\<Rightarrow> expr list \\<Rightarrow> state \\<Rightarrow> expr list \\<Rightarrow> state \\<Rightarrow> bool\"\n          (\"_,_ \\<turnstile> ((1\\<langle>_,/_\\<rangle>) [\\<rightarrow>]*/ (1\\<langle>_,/_\\<rangle>))\" [51,0,0,0,0] 81) where\n  \"P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>]* \\<langle>es',s'\\<rangle> \\<equiv> ((es,s), es',s') \\<in> (Reds P E)\\<^sup>*\""], ["", "lemma converse_rtrancl_induct_red[consumes 1]:\nassumes \"P,E \\<turnstile> \\<langle>e,(h,l)\\<rangle> \\<rightarrow>* \\<langle>e',(h',l')\\<rangle>\"\nand \"\\<And>e h l. R e h l e h l\"\nand \"\\<And>e\\<^sub>0 h\\<^sub>0 l\\<^sub>0 e\\<^sub>1 h\\<^sub>1 l\\<^sub>1 e' h' l'.\n       \\<lbrakk> P,E \\<turnstile> \\<langle>e\\<^sub>0,(h\\<^sub>0,l\\<^sub>0)\\<rangle> \\<rightarrow> \\<langle>e\\<^sub>1,(h\\<^sub>1,l\\<^sub>1)\\<rangle>; R e\\<^sub>1 h\\<^sub>1 l\\<^sub>1 e' h' l' \\<rbrakk> \\<Longrightarrow> R e\\<^sub>0 h\\<^sub>0 l\\<^sub>0 e' h' l'\"\nshows \"R e h l e' h' l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R e h l e' h' l'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R e h l e' h' l'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. R e h l e' h' l'", "fix s s'"], ["proof (state)\ngoal (1 subgoal):\n 1. R e h l e' h' l'", "assume reds: \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow>* \\<langle>e',s'\\<rangle>\"\n       and base: \"\\<And>e s. R e (hp s) (lcl s) e (hp s) (lcl s)\"\n       and IH: \"\\<And>e\\<^sub>0 s\\<^sub>0 e\\<^sub>1 s\\<^sub>1 e' s'.\n           \\<lbrakk> P,E \\<turnstile> \\<langle>e\\<^sub>0,s\\<^sub>0\\<rangle> \\<rightarrow> \\<langle>e\\<^sub>1,s\\<^sub>1\\<rangle>; R e\\<^sub>1 (hp s\\<^sub>1) (lcl s\\<^sub>1) e' (hp s') (lcl s') \\<rbrakk>\n           \\<Longrightarrow> R e\\<^sub>0 (hp s\\<^sub>0) (lcl s\\<^sub>0) e' (hp s') (lcl s')\""], ["proof (state)\nthis:\n  P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow>*\n                   \\<langle>e',s'\\<rangle>\n  R ?e (hp ?s) (lcl ?s) ?e (hp ?s) (lcl ?s)\n  \\<lbrakk>P,E \\<turnstile> \\<langle>?e\\<^sub>0,\n                             ?s\\<^sub>0\\<rangle> \\<rightarrow>\n                            \\<langle>?e\\<^sub>1,?s\\<^sub>1\\<rangle>;\n   R ?e\\<^sub>1 (hp ?s\\<^sub>1) (lcl ?s\\<^sub>1) ?e' (hp ?s')\n    (lcl ?s')\\<rbrakk>\n  \\<Longrightarrow> R ?e\\<^sub>0 (hp ?s\\<^sub>0) (lcl ?s\\<^sub>0) ?e'\n                     (hp ?s') (lcl ?s')\n\ngoal (1 subgoal):\n 1. R e h l e' h' l'", "from reds"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow>*\n                   \\<langle>e',s'\\<rangle>", "have \"R e (hp s) (lcl s) e' (hp s') (lcl s')\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow>*\n                   \\<langle>e',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. R e (hp s) (lcl s) e' (hp s') (lcl s')", "proof (induct rule:converse_rtrancl_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. R e' (hp s') (lcl s') e' (hp s') (lcl s')\n 2. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Red P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> \\<rightarrow>*\n                         \\<langle>e',s'\\<rangle>;\n        R aa (hp ba) (lcl ba) e' (hp s') (lcl s')\\<rbrakk>\n       \\<Longrightarrow> R a (hp b) (lcl b) e' (hp s') (lcl s')", "case refl"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. R e' (hp s') (lcl s') e' (hp s') (lcl s')\n 2. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Red P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> \\<rightarrow>*\n                         \\<langle>e',s'\\<rangle>;\n        R aa (hp ba) (lcl ba) e' (hp s') (lcl s')\\<rbrakk>\n       \\<Longrightarrow> R a (hp b) (lcl b) e' (hp s') (lcl s')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. R e' (hp s') (lcl s') e' (hp s') (lcl s')", "by(rule base)"], ["proof (state)\nthis:\n  R e' (hp s') (lcl s') e' (hp s') (lcl s')\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Red P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> \\<rightarrow>*\n                         \\<langle>e',s'\\<rangle>;\n        R aa (hp ba) (lcl ba) e' (hp s') (lcl s')\\<rbrakk>\n       \\<Longrightarrow> R a (hp b) (lcl b) e' (hp s') (lcl s')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Red P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> \\<rightarrow>*\n                         \\<langle>e',s'\\<rangle>;\n        R aa (hp ba) (lcl ba) e' (hp s') (lcl s')\\<rbrakk>\n       \\<Longrightarrow> R a (hp b) (lcl b) e' (hp s') (lcl s')", "case (step e\\<^sub>0 s\\<^sub>0 e s)"], ["proof (state)\nthis:\n  ((e\\<^sub>0, s\\<^sub>0), e, s) \\<in> Red P E\n  P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow>*\n                   \\<langle>e',s'\\<rangle>\n  R e (hp s) (lcl s) e' (hp s') (lcl s')\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Red P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> \\<rightarrow>*\n                         \\<langle>e',s'\\<rangle>;\n        R aa (hp ba) (lcl ba) e' (hp s') (lcl s')\\<rbrakk>\n       \\<Longrightarrow> R a (hp b) (lcl b) e' (hp s') (lcl s')", "have Red:\"((e\\<^sub>0,s\\<^sub>0),e,s) \\<in> Red P E\"\n        and R:\"R e (hp s) (lcl s) e' (hp s') (lcl s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((e\\<^sub>0, s\\<^sub>0), e, s) \\<in> Red P E &&&\n    R e (hp s) (lcl s) e' (hp s') (lcl s')", "by fact+"], ["proof (state)\nthis:\n  ((e\\<^sub>0, s\\<^sub>0), e, s) \\<in> Red P E\n  R e (hp s) (lcl s) e' (hp s') (lcl s')\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Red P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> \\<rightarrow>*\n                         \\<langle>e',s'\\<rangle>;\n        R aa (hp ba) (lcl ba) e' (hp s') (lcl s')\\<rbrakk>\n       \\<Longrightarrow> R a (hp b) (lcl b) e' (hp s') (lcl s')", "from IH[OF Red[simplified] R]"], ["proof (chain)\npicking this:\n  R e\\<^sub>0 (hp s\\<^sub>0) (lcl s\\<^sub>0) e' (hp s') (lcl s')", "show ?case"], ["proof (prove)\nusing this:\n  R e\\<^sub>0 (hp s\\<^sub>0) (lcl s\\<^sub>0) e' (hp s') (lcl s')\n\ngoal (1 subgoal):\n 1. R e\\<^sub>0 (hp s\\<^sub>0) (lcl s\\<^sub>0) e' (hp s') (lcl s')", "."], ["proof (state)\nthis:\n  R e\\<^sub>0 (hp s\\<^sub>0) (lcl s\\<^sub>0) e' (hp s') (lcl s')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R e (hp s) (lcl s) e' (hp s') (lcl s')\n\ngoal (1 subgoal):\n 1. R e h l e' h' l'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P,E \\<turnstile> \\<langle>e,?s2\\<rangle> \\<rightarrow>*\n                            \\<langle>e',?s'2\\<rangle>;\n   \\<And>e s. R e (hp s) (lcl s) e (hp s) (lcl s);\n   \\<And>e\\<^sub>0 s\\<^sub>0 e\\<^sub>1 s\\<^sub>1 e' s'.\n      \\<lbrakk>P,E \\<turnstile> \\<langle>e\\<^sub>0,\n                                 s\\<^sub>0\\<rangle> \\<rightarrow>\n                                \\<langle>e\\<^sub>1,s\\<^sub>1\\<rangle>;\n       R e\\<^sub>1 (hp s\\<^sub>1) (lcl s\\<^sub>1) e' (hp s')\n        (lcl s')\\<rbrakk>\n      \\<Longrightarrow> R e\\<^sub>0 (hp s\\<^sub>0) (lcl s\\<^sub>0) e'\n                         (hp s') (lcl s')\\<rbrakk>\n  \\<Longrightarrow> R e (hp ?s2) (lcl ?s2) e' (hp ?s'2) (lcl ?s'2)\n\ngoal (1 subgoal):\n 1. R e h l e' h' l'", "with assms"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> \\<langle>e,(h, l)\\<rangle> \\<rightarrow>*\n                   \\<langle>e',(h', l')\\<rangle>\n  R ?e ?h ?l ?e ?h ?l\n  \\<lbrakk>P,E \\<turnstile> \\<langle>?e\\<^sub>0,\n                             (?h\\<^sub>0, ?l\\<^sub>0)\\<rangle> \\<rightarrow>\n                            \\<langle>?e\\<^sub>1,\n                             (?h\\<^sub>1, ?l\\<^sub>1)\\<rangle>;\n   R ?e\\<^sub>1 ?h\\<^sub>1 ?l\\<^sub>1 ?e' ?h' ?l'\\<rbrakk>\n  \\<Longrightarrow> R ?e\\<^sub>0 ?h\\<^sub>0 ?l\\<^sub>0 ?e' ?h' ?l'\n  \\<lbrakk>P,E \\<turnstile> \\<langle>e,?s2\\<rangle> \\<rightarrow>*\n                            \\<langle>e',?s'2\\<rangle>;\n   \\<And>e s. R e (hp s) (lcl s) e (hp s) (lcl s);\n   \\<And>e\\<^sub>0 s\\<^sub>0 e\\<^sub>1 s\\<^sub>1 e' s'.\n      \\<lbrakk>P,E \\<turnstile> \\<langle>e\\<^sub>0,\n                                 s\\<^sub>0\\<rangle> \\<rightarrow>\n                                \\<langle>e\\<^sub>1,s\\<^sub>1\\<rangle>;\n       R e\\<^sub>1 (hp s\\<^sub>1) (lcl s\\<^sub>1) e' (hp s')\n        (lcl s')\\<rbrakk>\n      \\<Longrightarrow> R e\\<^sub>0 (hp s\\<^sub>0) (lcl s\\<^sub>0) e'\n                         (hp s') (lcl s')\\<rbrakk>\n  \\<Longrightarrow> R e (hp ?s2) (lcl ?s2) e' (hp ?s'2) (lcl ?s'2)", "show ?thesis"], ["proof (prove)\nusing this:\n  P,E \\<turnstile> \\<langle>e,(h, l)\\<rangle> \\<rightarrow>*\n                   \\<langle>e',(h', l')\\<rangle>\n  R ?e ?h ?l ?e ?h ?l\n  \\<lbrakk>P,E \\<turnstile> \\<langle>?e\\<^sub>0,\n                             (?h\\<^sub>0, ?l\\<^sub>0)\\<rangle> \\<rightarrow>\n                            \\<langle>?e\\<^sub>1,\n                             (?h\\<^sub>1, ?l\\<^sub>1)\\<rangle>;\n   R ?e\\<^sub>1 ?h\\<^sub>1 ?l\\<^sub>1 ?e' ?h' ?l'\\<rbrakk>\n  \\<Longrightarrow> R ?e\\<^sub>0 ?h\\<^sub>0 ?l\\<^sub>0 ?e' ?h' ?l'\n  \\<lbrakk>P,E \\<turnstile> \\<langle>e,?s2\\<rangle> \\<rightarrow>*\n                            \\<langle>e',?s'2\\<rangle>;\n   \\<And>e s. R e (hp s) (lcl s) e (hp s) (lcl s);\n   \\<And>e\\<^sub>0 s\\<^sub>0 e\\<^sub>1 s\\<^sub>1 e' s'.\n      \\<lbrakk>P,E \\<turnstile> \\<langle>e\\<^sub>0,\n                                 s\\<^sub>0\\<rangle> \\<rightarrow>\n                                \\<langle>e\\<^sub>1,s\\<^sub>1\\<rangle>;\n       R e\\<^sub>1 (hp s\\<^sub>1) (lcl s\\<^sub>1) e' (hp s')\n        (lcl s')\\<rbrakk>\n      \\<Longrightarrow> R e\\<^sub>0 (hp s\\<^sub>0) (lcl s\\<^sub>0) e'\n                         (hp s') (lcl s')\\<rbrakk>\n  \\<Longrightarrow> R e (hp ?s2) (lcl ?s2) e' (hp ?s'2) (lcl ?s'2)\n\ngoal (1 subgoal):\n 1. R e h l e' h' l'", "by fastforce"], ["proof (state)\nthis:\n  R e h l e' h' l'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_length:\"P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>]* \\<langle>es',s'\\<rangle> \\<Longrightarrow> length es = length es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>]*\n                     \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n    length es = length es'", "by(induct rule:rtrancl_induct2,auto intro:reds_length)"], ["", "subsection\\<open>Some easy lemmas\\<close>"], ["", "lemma [iff]: \"\\<not> P,E \\<turnstile> \\<langle>[],s\\<rangle> [\\<rightarrow>] \\<langle>es',s'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (E, ([], s), es', s') \\<notin> reds P", "by(blast elim: reds.cases)"], ["", "lemma [iff]: \"\\<not> P,E \\<turnstile> \\<langle>Val v,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (E, (Val v, s), e', s') \\<notin> red P", "by(fastforce elim: red.cases)"], ["", "lemma [iff]: \"\\<not> P,E \\<turnstile> \\<langle>Throw r,s\\<rangle> \\<rightarrow> \\<langle>e',s'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (E, (Throw r, s), e', s') \\<notin> red P", "by(fastforce elim: red.cases)"], ["", "lemma red_lcl_incr: \"P,E \\<turnstile> \\<langle>e,(h\\<^sub>0,l\\<^sub>0)\\<rangle> \\<rightarrow> \\<langle>e',(h\\<^sub>1,l\\<^sub>1)\\<rangle> \\<Longrightarrow> dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1\"\nand \"P,E \\<turnstile> \\<langle>es,(h\\<^sub>0,l\\<^sub>0)\\<rangle> [\\<rightarrow>] \\<langle>es',(h\\<^sub>1,l\\<^sub>1)\\<rangle> \\<Longrightarrow> dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,E \\<turnstile> \\<langle>e,\n                       (h\\<^sub>0, l\\<^sub>0)\\<rangle> \\<rightarrow>\n                      \\<langle>e',\n                       (h\\<^sub>1, l\\<^sub>1)\\<rangle> \\<Longrightarrow>\n     dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1) &&&\n    (P,E \\<turnstile> \\<langle>es,\n                       (h\\<^sub>0, l\\<^sub>0)\\<rangle> [\\<rightarrow>]\n                      \\<langle>es',\n                       (h\\<^sub>1, l\\<^sub>1)\\<rangle> \\<Longrightarrow>\n     dom l\\<^sub>0 \\<subseteq> dom l\\<^sub>1)", "by (induct rule: red_reds_inducts) (auto simp del:fun_upd_apply)"], ["", "lemma red_lcl_add: \"P,E \\<turnstile> \\<langle>e,(h,l)\\<rangle> \\<rightarrow> \\<langle>e',(h',l')\\<rangle> \\<Longrightarrow> (\\<And>l\\<^sub>0. P,E \\<turnstile> \\<langle>e,(h,l\\<^sub>0++l)\\<rangle> \\<rightarrow> \\<langle>e',(h',l\\<^sub>0++l')\\<rangle>)\"\nand \"P,E \\<turnstile> \\<langle>es,(h,l)\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l')\\<rangle> \\<Longrightarrow> (\\<And>l\\<^sub>0. P,E \\<turnstile> \\<langle>es,(h,l\\<^sub>0++l)\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l\\<^sub>0++l')\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,E \\<turnstile> \\<langle>e,(h, l)\\<rangle> \\<rightarrow>\n                      \\<langle>e',(h', l')\\<rangle> \\<Longrightarrow>\n     (\\<And>l\\<^sub>0.\n         P,E \\<turnstile> \\<langle>e,\n                           (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                          \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>)) &&&\n    (P,E \\<turnstile> \\<langle>es,(h, l)\\<rangle> [\\<rightarrow>]\n                      \\<langle>es',(h', l')\\<rangle> \\<Longrightarrow>\n     (\\<And>l\\<^sub>0.\n         P,E \\<turnstile> \\<langle>es,\n                           (h, l\\<^sub>0 ++ l)\\<rangle> [\\<rightarrow>]\n                          \\<langle>es',(h', l\\<^sub>0 ++ l')\\<rangle>))", "proof (induct rule:red_reds_inducts)"], ["proof (state)\ngoal (61 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>E C a Cs Cs' aa b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref (a, Cs @ [C] @ Cs'),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>ref (a, Cs @ [C]),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 8. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 9. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n        \\<lbrakk>P \\<turnstile> Path last Cs to C unique;\n         P \\<turnstile> Path last Cs to C via Cs' ;\n         Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (a, Cs)),\n      (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\nA total of 61 subgoals...", "case RedLAss"], ["proof (state)\nthis:\n  E_ V_ = \\<lfloor>T_\\<rfloor>\n  P \\<turnstile> T_ casts v_ to v'_ \n\ngoal (61 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>E C a Cs Cs' aa b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref (a, Cs @ [C] @ Cs'),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>ref (a, Cs @ [C]),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 8. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 9. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n        \\<lbrakk>P \\<turnstile> Path last Cs to C unique;\n         P \\<turnstile> Path last Cs to C via Cs' ;\n         Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (a, Cs)),\n      (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\nA total of 61 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  E_ V_ = \\<lfloor>T_\\<rfloor>\n  P \\<turnstile> T_ casts v_ to v'_ \n\ngoal (1 subgoal):\n 1. P,E_ \\<turnstile> \\<langle>V_:=Val v_,\n                       (h_, l\\<^sub>0 ++ l_)\\<rangle> \\<rightarrow>\n                      \\<langle>Val v'_,\n                       (h_, l\\<^sub>0 ++ l_(V_ \\<mapsto> v'_))\\<rangle>", "by(auto intro:red_reds.intros simp del:fun_upd_apply)"], ["proof (state)\nthis:\n  P,E_ \\<turnstile> \\<langle>V_:=Val v_,\n                     (h_, l\\<^sub>0 ++ l_)\\<rangle> \\<rightarrow>\n                    \\<langle>Val v'_,\n                     (h_, l\\<^sub>0 ++ l_(V_ \\<mapsto> v'_))\\<rangle>\n\ngoal (60 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>E C a Cs Cs' aa b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref (a, Cs @ [C] @ Cs'),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>ref (a, Cs @ [C]),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 8. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 9. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n        \\<lbrakk>P \\<turnstile> Path last Cs to C unique;\n         P \\<turnstile> Path last Cs to C via Cs' ;\n         Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (a, Cs)),\n      (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\nA total of 60 subgoals...", "next"], ["proof (state)\ngoal (60 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>E C a Cs Cs' aa b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref (a, Cs @ [C] @ Cs'),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>ref (a, Cs @ [C]),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 8. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 9. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n        \\<lbrakk>P \\<turnstile> Path last Cs to C unique;\n         P \\<turnstile> Path last Cs to C via Cs' ;\n         Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (a, Cs)),\n      (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\nA total of 60 subgoals...", "case RedStaticDownCast"], ["proof (state)\nthis:\n  \n\ngoal (60 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>E C a Cs Cs' aa b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref (a, Cs @ [C] @ Cs'),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>ref (a, Cs @ [C]),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 8. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 9. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n        \\<lbrakk>P \\<turnstile> Path last Cs to C unique;\n         P \\<turnstile> Path last Cs to C via Cs' ;\n         Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (a, Cs)),\n      (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\nA total of 60 subgoals...", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,E_ \\<turnstile> \\<langle>\\<lparr>C_\\<rparr>ref\n            (a___, Cs_ @ [C_] @ Cs'_),\n                       (a_, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                      \\<langle>ref (a___, Cs_ @ [C_]),\n                       (a_, l\\<^sub>0 ++ b_)\\<rangle>", "by(fastforce intro:red_reds.intros)"], ["proof (state)\nthis:\n  P,E_ \\<turnstile> \\<langle>\\<lparr>C_\\<rparr>ref\n          (a___, Cs_ @ [C_] @ Cs'_),\n                     (a_, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                    \\<langle>ref (a___, Cs_ @ [C_]),\n                     (a_, l\\<^sub>0 ++ b_)\\<rangle>\n\ngoal (59 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C unique;\n        P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (a, Cs)),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>E C a Cs Cs' aa b l\\<^sub>0.\n        P,E \\<turnstile> \\<langle>Cast C (ref (a, Cs @ [C] @ Cs')),\n                          (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                         \\<langle>ref (a, Cs @ [C]),\n                          (aa, l\\<^sub>0 ++ b)\\<rangle>\nA total of 59 subgoals...", "next"], ["proof (state)\ngoal (59 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C unique;\n        P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (a, Cs)),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>E C a Cs Cs' aa b l\\<^sub>0.\n        P,E \\<turnstile> \\<langle>Cast C (ref (a, Cs @ [C] @ Cs')),\n                          (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                         \\<langle>ref (a, Cs @ [C]),\n                          (aa, l\\<^sub>0 ++ b)\\<rangle>\nA total of 59 subgoals...", "case RedStaticUpDynCast"], ["proof (state)\nthis:\n  P \\<turnstile> Path last Cs_ to C_ unique\n  P \\<turnstile> Path last Cs_ to C_ via Cs'_ \n  Ds_ = Cs_ @\\<^sub>p Cs'_\n\ngoal (59 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C unique;\n        P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (a, Cs)),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>E C a Cs Cs' aa b l\\<^sub>0.\n        P,E \\<turnstile> \\<langle>Cast C (ref (a, Cs @ [C] @ Cs')),\n                          (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                         \\<langle>ref (a, Cs @ [C]),\n                          (aa, l\\<^sub>0 ++ b)\\<rangle>\nA total of 59 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> Path last Cs_ to C_ unique\n  P \\<turnstile> Path last Cs_ to C_ via Cs'_ \n  Ds_ = Cs_ @\\<^sub>p Cs'_\n\ngoal (1 subgoal):\n 1. P,E_ \\<turnstile> \\<langle>Cast C_ (ref (a___, Cs_)),\n                       (a_, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                      \\<langle>ref (a___, Ds_),\n                       (a_, l\\<^sub>0 ++ b_)\\<rangle>", "by(fastforce intro:red_reds.intros)"], ["proof (state)\nthis:\n  P,E_ \\<turnstile> \\<langle>Cast C_ (ref (a___, Cs_)),\n                     (a_, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                    \\<langle>ref (a___, Ds_),(a_, l\\<^sub>0 ++ b_)\\<rangle>\n\ngoal (58 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E C a Cs Cs' aa b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C (ref (a, Cs @ [C] @ Cs')),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>ref (a, Cs @ [C]),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>a b aa D S C Cs' E Cs l\\<^sub>0.\n        \\<lbrakk>hp (a, b) aa = \\<lfloor>(D, S)\\<rfloor>;\n         P \\<turnstile> Path D to C via Cs' ;\n         P \\<turnstile> Path D to C unique\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (aa, Cs)),\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>ref (aa, Cs'),(a, l\\<^sub>0 ++ b)\\<rangle>\nA total of 58 subgoals...", "next"], ["proof (state)\ngoal (58 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E C a Cs Cs' aa b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C (ref (a, Cs @ [C] @ Cs')),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>ref (a, Cs @ [C]),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>a b aa D S C Cs' E Cs l\\<^sub>0.\n        \\<lbrakk>hp (a, b) aa = \\<lfloor>(D, S)\\<rfloor>;\n         P \\<turnstile> Path D to C via Cs' ;\n         P \\<turnstile> Path D to C unique\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (aa, Cs)),\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>ref (aa, Cs'),(a, l\\<^sub>0 ++ b)\\<rangle>\nA total of 58 subgoals...", "case RedStaticDownDynCast"], ["proof (state)\nthis:\n  \n\ngoal (58 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E C a Cs Cs' aa b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C (ref (a, Cs @ [C] @ Cs')),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>ref (a, Cs @ [C]),\n                         (aa, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>a b aa D S C Cs' E Cs l\\<^sub>0.\n        \\<lbrakk>hp (a, b) aa = \\<lfloor>(D, S)\\<rfloor>;\n         P \\<turnstile> Path D to C via Cs' ;\n         P \\<turnstile> Path D to C unique\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (aa, Cs)),\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>ref (aa, Cs'),(a, l\\<^sub>0 ++ b)\\<rangle>\nA total of 58 subgoals...", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,E_ \\<turnstile> \\<langle>Cast C_ (ref (a___, Cs_ @ [C_] @ Cs'_)),\n                       (a_, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                      \\<langle>ref (a___, Cs_ @ [C_]),\n                       (a_, l\\<^sub>0 ++ b_)\\<rangle>", "by(fastforce intro:red_reds.intros)"], ["proof (state)\nthis:\n  P,E_ \\<turnstile> \\<langle>Cast C_ (ref (a___, Cs_ @ [C_] @ Cs'_)),\n                     (a_, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                    \\<langle>ref (a___, Cs_ @ [C_]),\n                     (a_, l\\<^sub>0 ++ b_)\\<rangle>\n\ngoal (57 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>a b aa D S C Cs' E Cs l\\<^sub>0.\n       \\<lbrakk>hp (a, b) aa = \\<lfloor>(D, S)\\<rfloor>;\n        P \\<turnstile> Path D to C via Cs' ;\n        P \\<turnstile> Path D to C unique\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (aa, Cs)),\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (aa, Cs'),(a, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>a b aa D S C Cs E l\\<^sub>0.\n        \\<lbrakk>hp (a, b) aa = \\<lfloor>(D, S)\\<rfloor>;\n         \\<not> P \\<turnstile> Path D to C unique;\n         \\<not> P \\<turnstile> Path last Cs to C unique;\n         C \\<notin> set Cs\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (aa, Cs)),\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\nA total of 57 subgoals...", "next"], ["proof (state)\ngoal (57 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>a b aa D S C Cs' E Cs l\\<^sub>0.\n       \\<lbrakk>hp (a, b) aa = \\<lfloor>(D, S)\\<rfloor>;\n        P \\<turnstile> Path D to C via Cs' ;\n        P \\<turnstile> Path D to C unique\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (aa, Cs)),\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (aa, Cs'),(a, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>a b aa D S C Cs E l\\<^sub>0.\n        \\<lbrakk>hp (a, b) aa = \\<lfloor>(D, S)\\<rfloor>;\n         \\<not> P \\<turnstile> Path D to C unique;\n         \\<not> P \\<turnstile> Path last Cs to C unique;\n         C \\<notin> set Cs\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (aa, Cs)),\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\nA total of 57 subgoals...", "case RedDynCast"], ["proof (state)\nthis:\n  hp (a___, b_) a_ = \\<lfloor>(D_, S_)\\<rfloor>\n  P \\<turnstile> Path D_ to C_ via Cs'_ \n  P \\<turnstile> Path D_ to C_ unique\n\ngoal (57 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>a b aa D S C Cs' E Cs l\\<^sub>0.\n       \\<lbrakk>hp (a, b) aa = \\<lfloor>(D, S)\\<rfloor>;\n        P \\<turnstile> Path D to C via Cs' ;\n        P \\<turnstile> Path D to C unique\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (aa, Cs)),\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (aa, Cs'),(a, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>a b aa D S C Cs E l\\<^sub>0.\n        \\<lbrakk>hp (a, b) aa = \\<lfloor>(D, S)\\<rfloor>;\n         \\<not> P \\<turnstile> Path D to C unique;\n         \\<not> P \\<turnstile> Path last Cs to C unique;\n         C \\<notin> set Cs\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (aa, Cs)),\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\nA total of 57 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  hp (a___, b_) a_ = \\<lfloor>(D_, S_)\\<rfloor>\n  P \\<turnstile> Path D_ to C_ via Cs'_ \n  P \\<turnstile> Path D_ to C_ unique\n\ngoal (1 subgoal):\n 1. P,E_ \\<turnstile> \\<langle>Cast C_ (ref (a_, Cs_)),\n                       (a___, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                      \\<langle>ref (a_, Cs'_),\n                       (a___, l\\<^sub>0 ++ b_)\\<rangle>", "by(fastforce intro:red_reds.intros)"], ["proof (state)\nthis:\n  P,E_ \\<turnstile> \\<langle>Cast C_ (ref (a_, Cs_)),\n                     (a___, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                    \\<langle>ref (a_, Cs'_),(a___, l\\<^sub>0 ++ b_)\\<rangle>\n\ngoal (56 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>a b aa D S C Cs E l\\<^sub>0.\n       \\<lbrakk>hp (a, b) aa = \\<lfloor>(D, S)\\<rfloor>;\n        \\<not> P \\<turnstile> Path D to C unique;\n        \\<not> P \\<turnstile> Path last Cs to C unique;\n        C \\<notin> set Cs\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (aa, Cs)),\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 56 subgoals...", "next"], ["proof (state)\ngoal (56 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>a b aa D S C Cs E l\\<^sub>0.\n       \\<lbrakk>hp (a, b) aa = \\<lfloor>(D, S)\\<rfloor>;\n        \\<not> P \\<turnstile> Path D to C unique;\n        \\<not> P \\<turnstile> Path last Cs to C unique;\n        C \\<notin> set Cs\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (aa, Cs)),\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 56 subgoals...", "case RedDynCastFail"], ["proof (state)\nthis:\n  hp (a___, b_) a_ = \\<lfloor>(D_, S_)\\<rfloor>\n  \\<not> P \\<turnstile> Path D_ to C_ unique\n  \\<not> P \\<turnstile> Path last Cs_ to C_ unique\n  C_ \\<notin> set Cs_\n\ngoal (56 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>a b aa D S C Cs E l\\<^sub>0.\n       \\<lbrakk>hp (a, b) aa = \\<lfloor>(D, S)\\<rfloor>;\n        \\<not> P \\<turnstile> Path D to C unique;\n        \\<not> P \\<turnstile> Path last Cs to C unique;\n        C \\<notin> set Cs\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C (ref (aa, Cs)),\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 10. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 56 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  hp (a___, b_) a_ = \\<lfloor>(D_, S_)\\<rfloor>\n  \\<not> P \\<turnstile> Path D_ to C_ unique\n  \\<not> P \\<turnstile> Path last Cs_ to C_ unique\n  C_ \\<notin> set Cs_\n\ngoal (1 subgoal):\n 1. P,E_ \\<turnstile> \\<langle>Cast C_ (ref (a_, Cs_)),\n                       (a___, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                      \\<langle>null,(a___, l\\<^sub>0 ++ b_)\\<rangle>", "by(fastforce intro:red_reds.intros)"], ["proof (state)\nthis:\n  P,E_ \\<turnstile> \\<langle>Cast C_ (ref (a_, Cs_)),\n                     (a___, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                    \\<langle>null,(a___, l\\<^sub>0 ++ b_)\\<rangle>\n\ngoal (55 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 55 subgoals...", "next"], ["proof (state)\ngoal (55 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 55 subgoals...", "case RedFAcc"], ["proof (state)\nthis:\n  hp (a___, b_) a_ = \\<lfloor>(D_, S_)\\<rfloor>\n  Ds_ = Cs'_ @\\<^sub>p Cs_\n  (Ds_, fs_) \\<in> S_\n  fs_ F_ = \\<lfloor>v_\\<rfloor>\n\ngoal (55 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 55 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  hp (a___, b_) a_ = \\<lfloor>(D_, S_)\\<rfloor>\n  Ds_ = Cs'_ @\\<^sub>p Cs_\n  (Ds_, fs_) \\<in> S_\n  fs_ F_ = \\<lfloor>v_\\<rfloor>\n\ngoal (1 subgoal):\n 1. P,E_ \\<turnstile> \\<langle>ref (a_, Cs'_)\\<bullet>F_{Cs_},\n                       (a___, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                      \\<langle>Val v_,(a___, l\\<^sub>0 ++ b_)\\<rangle>", "by(fastforce intro:red_reds.intros)"], ["proof (state)\nthis:\n  P,E_ \\<turnstile> \\<langle>ref (a_, Cs'_)\\<bullet>F_{Cs_},\n                     (a___, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                    \\<langle>Val v_,(a___, l\\<^sub>0 ++ b_)\\<rangle>\n\ngoal (54 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 54 subgoals...", "next"], ["proof (state)\ngoal (54 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 54 subgoals...", "case RedFAss"], ["proof (state)\nthis:\n  h_ a_ = \\<lfloor>(D_, S_)\\<rfloor>\n  P \\<turnstile> last Cs'_ has least F_:T_ via Cs_\n  P \\<turnstile> T_ casts v_ to v'_ \n  Ds_ = Cs'_ @\\<^sub>p Cs_\n  (Ds_, fs_) \\<in> S_\n\ngoal (54 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 54 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  h_ a_ = \\<lfloor>(D_, S_)\\<rfloor>\n  P \\<turnstile> last Cs'_ has least F_:T_ via Cs_\n  P \\<turnstile> T_ casts v_ to v'_ \n  Ds_ = Cs'_ @\\<^sub>p Cs_\n  (Ds_, fs_) \\<in> S_\n\ngoal (1 subgoal):\n 1. P,E_ \\<turnstile> \\<langle>ref (a_, Cs'_)\\<bullet>F_{Cs_} := Val v_,\n                       (h_, l\\<^sub>0 ++ l_)\\<rangle> \\<rightarrow>\n                      \\<langle>Val v'_,\n                       (h_(a_ \\<mapsto>\n                        (D_,\n                         insert (Ds_, fs_(F_ \\<mapsto> v'_))\n                          (S_ - {(Ds_, fs_)}))),\n                        l\\<^sub>0 ++ l_)\\<rangle>", "by (fastforce intro:red_reds.intros)"], ["proof (state)\nthis:\n  P,E_ \\<turnstile> \\<langle>ref (a_, Cs'_)\\<bullet>F_{Cs_} := Val v_,\n                     (h_, l\\<^sub>0 ++ l_)\\<rangle> \\<rightarrow>\n                    \\<langle>Val v'_,\n                     (h_(a_ \\<mapsto>\n                      (D_,\n                       insert (Ds_, fs_(F_ \\<mapsto> v'_))\n                        (S_ - {(Ds_, fs_)}))),\n                      l\\<^sub>0 ++ l_)\\<rangle>\n\ngoal (53 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 53 subgoals...", "next"], ["proof (state)\ngoal (53 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 53 subgoals...", "case RedCall"], ["proof (state)\nthis:\n  hp (a___, b_) a_ = \\<lfloor>(C_, S_)\\<rfloor>\n  P \\<turnstile> last Cs_ has least M_ = (Ts'_, T'_, pns'_, body'_) via Ds_\n  P \\<turnstile> (C_,Cs_ @\\<^sub>p\n                     Ds_) selects M_ = (Ts_, T_, pns_, body_) via Cs'_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n  bs_ =\n  blocks (this # pns_, Class (last Cs'_) # Ts_, Ref (a_, Cs'_) # vs_, body_)\n  new_body_ =\n  (case T'_ of Class D \\<Rightarrow> \\<lparr>D\\<rparr>bs_\n   | _ \\<Rightarrow> bs_)\n\ngoal (53 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 53 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  hp (a___, b_) a_ = \\<lfloor>(C_, S_)\\<rfloor>\n  P \\<turnstile> last Cs_ has least M_ = (Ts'_, T'_, pns'_, body'_) via Ds_\n  P \\<turnstile> (C_,Cs_ @\\<^sub>p\n                     Ds_) selects M_ = (Ts_, T_, pns_, body_) via Cs'_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n  bs_ =\n  blocks (this # pns_, Class (last Cs'_) # Ts_, Ref (a_, Cs'_) # vs_, body_)\n  new_body_ =\n  (case T'_ of Class D \\<Rightarrow> \\<lparr>D\\<rparr>bs_\n   | _ \\<Rightarrow> bs_)\n\ngoal (1 subgoal):\n 1. P,E_ \\<turnstile> \\<langle>Call (ref (a_, Cs_)) None M_ (map Val vs_),\n                       (a___, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                      \\<langle>new_body_,(a___, l\\<^sub>0 ++ b_)\\<rangle>", "by (fastforce intro!:red_reds.RedCall)"], ["proof (state)\nthis:\n  P,E_ \\<turnstile> \\<langle>Call (ref (a_, Cs_)) None M_ (map Val vs_),\n                     (a___, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                    \\<langle>new_body_,(a___, l\\<^sub>0 ++ b_)\\<rangle>\n\ngoal (52 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 52 subgoals...", "next"], ["proof (state)\ngoal (52 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 52 subgoals...", "case RedStaticCall"], ["proof (state)\nthis:\n  P \\<turnstile> Path last Cs_ to C_ unique\n  P \\<turnstile> Path last Cs_ to C_ via Cs''_ \n  P \\<turnstile> C_ has least M_ = (Ts_, T_, pns_, body_) via Cs'_\n  Ds_ = (Cs_ @\\<^sub>p Cs''_) @\\<^sub>p Cs'_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n\ngoal (52 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 52 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> Path last Cs_ to C_ unique\n  P \\<turnstile> Path last Cs_ to C_ via Cs''_ \n  P \\<turnstile> C_ has least M_ = (Ts_, T_, pns_, body_) via Cs'_\n  Ds_ = (Cs_ @\\<^sub>p Cs''_) @\\<^sub>p Cs'_\n  length vs_ = length pns_\n  length Ts_ = length pns_\n\ngoal (1 subgoal):\n 1. P,E_ \\<turnstile> \\<langle>Call (ref (a___, Cs_)) \\<lfloor>C_\\<rfloor>\n                                M_ (map Val vs_),\n                       (a_, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                      \\<langle>blocks\n                                (this # pns_, Class (last Ds_) # Ts_,\n                                 Ref (a___, Ds_) # vs_, body_),\n                       (a_, l\\<^sub>0 ++ b_)\\<rangle>", "by(fastforce intro:red_reds.intros)"], ["proof (state)\nthis:\n  P,E_ \\<turnstile> \\<langle>Call (ref (a___, Cs_)) \\<lfloor>C_\\<rfloor> M_\n                              (map Val vs_),\n                     (a_, l\\<^sub>0 ++ b_)\\<rangle> \\<rightarrow>\n                    \\<langle>blocks\n                              (this # pns_, Class (last Ds_) # Ts_,\n                               Ref (a___, Ds_) # vs_, body_),\n                     (a_, l\\<^sub>0 ++ b_)\\<rangle>\n\ngoal (51 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 51 subgoals...", "next"], ["proof (state)\ngoal (51 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 51 subgoals...", "case (InitBlockRed E V T e h l v' e' h' l' v'' v l\\<^sub>0)"], ["proof (state)\nthis:\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,(h, l(V \\<mapsto> v'))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', l')\\<rangle>\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,\n                   (h, ?l\\<^sub>0 ++ l(V \\<mapsto>\n                       v'))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', ?l\\<^sub>0 ++ l')\\<rangle>\n  l' V = \\<lfloor>v''\\<rfloor>\n  P \\<turnstile> T casts v to v' \n\ngoal (51 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 51 subgoals...", "have IH: \"\\<And>l\\<^sub>0. P,E(V \\<mapsto> T) \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l(V \\<mapsto> v'))\\<rangle> \\<rightarrow> \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>\"\n    and l'V: \"l' V = Some v''\" and casts:\"P \\<turnstile> T casts v to v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l\\<^sub>0.\n        P,E(V \\<mapsto>\n        T) \\<turnstile> \\<langle>e,\n                         (h, l\\<^sub>0 ++ l(V \\<mapsto>\n                             v'))\\<rangle> \\<rightarrow>\n                        \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>) &&&\n    l' V = \\<lfloor>v''\\<rfloor> &&& P \\<turnstile> T casts v to v'", "by fact+"], ["proof (state)\nthis:\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,\n                   (h, ?l\\<^sub>0 ++ l(V \\<mapsto>\n                       v'))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', ?l\\<^sub>0 ++ l')\\<rangle>\n  l' V = \\<lfloor>v''\\<rfloor>\n  P \\<turnstile> T casts v to v' \n\ngoal (51 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 51 subgoals...", "from IH"], ["proof (chain)\npicking this:\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,\n                   (h, ?l\\<^sub>0 ++ l(V \\<mapsto>\n                       v'))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', ?l\\<^sub>0 ++ l')\\<rangle>", "have IH': \"P,E(V \\<mapsto> T) \\<turnstile> \\<langle>e,(h, (l\\<^sub>0 ++ l)(V \\<mapsto> v'))\\<rangle> \\<rightarrow> \\<langle>e',(h',l\\<^sub>0 ++ l')\\<rangle>\""], ["proof (prove)\nusing this:\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,\n                   (h, ?l\\<^sub>0 ++ l(V \\<mapsto>\n                       v'))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', ?l\\<^sub>0 ++ l')\\<rangle>\n\ngoal (1 subgoal):\n 1. P,E(V \\<mapsto>\n    T) \\<turnstile> \\<langle>e,\n                     (h, (l\\<^sub>0 ++ l)(V \\<mapsto>\n                      v'))\\<rangle> \\<rightarrow>\n                    \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>", "by simp"], ["proof (state)\nthis:\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,\n                   (h, (l\\<^sub>0 ++ l)(V \\<mapsto>\n                    v'))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>\n\ngoal (51 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 51 subgoals...", "have \"(l\\<^sub>0 ++ l')(V := (l\\<^sub>0 ++ l) V) = l\\<^sub>0 ++ l'(V := l V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l\\<^sub>0 ++ l')(V := (l\\<^sub>0 ++ l) V) = l\\<^sub>0 ++ l'(V := l V)", "by(rule ext)(simp add:map_add_def)"], ["proof (state)\nthis:\n  (l\\<^sub>0 ++ l')(V := (l\\<^sub>0 ++ l) V) = l\\<^sub>0 ++ l'(V := l V)\n\ngoal (51 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 51 subgoals...", "with red_reds.InitBlockRed[OF IH' _ casts] l'V"], ["proof (chain)\npicking this:\n  (l\\<^sub>0 ++ l') V = \\<lfloor>?v''\\<rfloor> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>{V:T; V:=Val v;; e},\n                    (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                   \\<langle>{V:T; V:=Val ?v'';; e'},\n                    (h', (l\\<^sub>0 ++ l')\n                     (V := (l\\<^sub>0 ++ l) V))\\<rangle>\n  l' V = \\<lfloor>v''\\<rfloor>\n  (l\\<^sub>0 ++ l')(V := (l\\<^sub>0 ++ l) V) = l\\<^sub>0 ++ l'(V := l V)", "show ?case"], ["proof (prove)\nusing this:\n  (l\\<^sub>0 ++ l') V = \\<lfloor>?v''\\<rfloor> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>{V:T; V:=Val v;; e},\n                    (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                   \\<langle>{V:T; V:=Val ?v'';; e'},\n                    (h', (l\\<^sub>0 ++ l')\n                     (V := (l\\<^sub>0 ++ l) V))\\<rangle>\n  l' V = \\<lfloor>v''\\<rfloor>\n  (l\\<^sub>0 ++ l')(V := (l\\<^sub>0 ++ l) V) = l\\<^sub>0 ++ l'(V := l V)\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> \\<langle>{V:T; V:=Val v;; e},\n                      (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                     \\<langle>{V:T; V:=Val v'';; e'},\n                      (h', l\\<^sub>0 ++ l'(V := l V))\\<rangle>", "by(simp del:fun_upd_apply)"], ["proof (state)\nthis:\n  P,E \\<turnstile> \\<langle>{V:T; V:=Val v;; e},\n                    (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                   \\<langle>{V:T; V:=Val v'';; e'},\n                    (h', l\\<^sub>0 ++ l'(V := l V))\\<rangle>\n\ngoal (50 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 50 subgoals...", "next"], ["proof (state)\ngoal (50 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 50 subgoals...", "case (BlockRedNone E V T e h l e' h' l' l\\<^sub>0)"], ["proof (state)\nthis:\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,(h, l(V := None))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', l')\\<rangle>\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,\n                   (h, ?l\\<^sub>0 ++ l(V := None))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', ?l\\<^sub>0 ++ l')\\<rangle>\n  l' V = None\n  \\<not> assigned V e\n\ngoal (50 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 50 subgoals...", "have IH: \"\\<And>l\\<^sub>0. P,E(V \\<mapsto> T) \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l(V := None))\\<rangle> \\<rightarrow> \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>\"\n    and l'V: \"l' V = None\" and unass: \"\\<not> assigned V e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l\\<^sub>0.\n        P,E(V \\<mapsto>\n        T) \\<turnstile> \\<langle>e,\n                         (h, l\\<^sub>0 ++ l\n                             (V := None))\\<rangle> \\<rightarrow>\n                        \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>) &&&\n    l' V = None &&& \\<not> assigned V e", "by fact+"], ["proof (state)\nthis:\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,\n                   (h, ?l\\<^sub>0 ++ l(V := None))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', ?l\\<^sub>0 ++ l')\\<rangle>\n  l' V = None\n  \\<not> assigned V e\n\ngoal (50 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 50 subgoals...", "have \"l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)", "by(simp add:fun_eq_iff map_add_def)"], ["proof (state)\nthis:\n  l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\n\ngoal (50 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 50 subgoals...", "hence IH': \"P,E(V \\<mapsto> T) \\<turnstile> \\<langle>e,(h, (l\\<^sub>0++l)(V := None))\\<rangle> \\<rightarrow> \\<langle>e',(h', l\\<^sub>0(V := None) ++ l')\\<rangle>\""], ["proof (prove)\nusing this:\n  l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\n\ngoal (1 subgoal):\n 1. P,E(V \\<mapsto>\n    T) \\<turnstile> \\<langle>e,\n                     (h, (l\\<^sub>0 ++ l)(V := None))\\<rangle> \\<rightarrow>\n                    \\<langle>e',(h', l\\<^sub>0(V := None) ++ l')\\<rangle>", "using IH[of \"l\\<^sub>0(V := None)\"]"], ["proof (prove)\nusing this:\n  l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,\n                   (h, l\\<^sub>0(V := None) ++ l\n                       (V := None))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', l\\<^sub>0(V := None) ++ l')\\<rangle>\n\ngoal (1 subgoal):\n 1. P,E(V \\<mapsto>\n    T) \\<turnstile> \\<langle>e,\n                     (h, (l\\<^sub>0 ++ l)(V := None))\\<rangle> \\<rightarrow>\n                    \\<langle>e',(h', l\\<^sub>0(V := None) ++ l')\\<rangle>", "by simp"], ["proof (state)\nthis:\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,\n                   (h, (l\\<^sub>0 ++ l)(V := None))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', l\\<^sub>0(V := None) ++ l')\\<rangle>\n\ngoal (50 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 50 subgoals...", "have \"(l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) = l\\<^sub>0 ++ l'(V := l V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n    l\\<^sub>0 ++ l'(V := l V)", "by(simp add:fun_eq_iff map_add_def)"], ["proof (state)\nthis:\n  (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n  l\\<^sub>0 ++ l'(V := l V)\n\ngoal (50 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 50 subgoals...", "with red_reds.BlockRedNone[OF IH' _ unass] l'V"], ["proof (chain)\npicking this:\n  (l\\<^sub>0(V := None) ++ l') V = None \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>{V:T; e},\n                    (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                   \\<langle>{V:T; e'},\n                    (h', (l\\<^sub>0(V := None) ++ l')\n                     (V := (l\\<^sub>0 ++ l) V))\\<rangle>\n  l' V = None\n  (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n  l\\<^sub>0 ++ l'(V := l V)", "show ?case"], ["proof (prove)\nusing this:\n  (l\\<^sub>0(V := None) ++ l') V = None \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>{V:T; e},\n                    (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                   \\<langle>{V:T; e'},\n                    (h', (l\\<^sub>0(V := None) ++ l')\n                     (V := (l\\<^sub>0 ++ l) V))\\<rangle>\n  l' V = None\n  (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n  l\\<^sub>0 ++ l'(V := l V)\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> \\<langle>{V:T; e},\n                      (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                     \\<langle>{V:T; e'},\n                      (h', l\\<^sub>0 ++ l'(V := l V))\\<rangle>", "by(simp add: map_add_def)"], ["proof (state)\nthis:\n  P,E \\<turnstile> \\<langle>{V:T; e},\n                    (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                   \\<langle>{V:T; e'},\n                    (h', l\\<^sub>0 ++ l'(V := l V))\\<rangle>\n\ngoal (49 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 49 subgoals...", "next"], ["proof (state)\ngoal (49 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 49 subgoals...", "case (BlockRedSome E V T e h l e' h' l' v l\\<^sub>0)"], ["proof (state)\nthis:\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,(h, l(V := None))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', l')\\<rangle>\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,\n                   (h, ?l\\<^sub>0 ++ l(V := None))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', ?l\\<^sub>0 ++ l')\\<rangle>\n  l' V = \\<lfloor>v\\<rfloor>\n  \\<not> assigned V e\n\ngoal (49 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 49 subgoals...", "have IH: \"\\<And>l\\<^sub>0. P,E(V \\<mapsto> T) \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l(V := None))\\<rangle> \\<rightarrow> \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>\"\n    and l'V: \"l' V = Some v\" and unass: \"\\<not> assigned V e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l\\<^sub>0.\n        P,E(V \\<mapsto>\n        T) \\<turnstile> \\<langle>e,\n                         (h, l\\<^sub>0 ++ l\n                             (V := None))\\<rangle> \\<rightarrow>\n                        \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>) &&&\n    l' V = \\<lfloor>v\\<rfloor> &&& \\<not> assigned V e", "by fact+"], ["proof (state)\nthis:\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,\n                   (h, ?l\\<^sub>0 ++ l(V := None))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', ?l\\<^sub>0 ++ l')\\<rangle>\n  l' V = \\<lfloor>v\\<rfloor>\n  \\<not> assigned V e\n\ngoal (49 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 49 subgoals...", "have \"l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)", "by(simp add:fun_eq_iff map_add_def)"], ["proof (state)\nthis:\n  l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\n\ngoal (49 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 49 subgoals...", "hence IH': \"P,E(V \\<mapsto> T) \\<turnstile> \\<langle>e,(h, (l\\<^sub>0++l)(V := None))\\<rangle> \\<rightarrow> \\<langle>e',(h', l\\<^sub>0(V := None) ++ l')\\<rangle>\""], ["proof (prove)\nusing this:\n  l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\n\ngoal (1 subgoal):\n 1. P,E(V \\<mapsto>\n    T) \\<turnstile> \\<langle>e,\n                     (h, (l\\<^sub>0 ++ l)(V := None))\\<rangle> \\<rightarrow>\n                    \\<langle>e',(h', l\\<^sub>0(V := None) ++ l')\\<rangle>", "using IH[of \"l\\<^sub>0(V := None)\"]"], ["proof (prove)\nusing this:\n  l\\<^sub>0(V := None) ++ l(V := None) = (l\\<^sub>0 ++ l)(V := None)\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,\n                   (h, l\\<^sub>0(V := None) ++ l\n                       (V := None))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', l\\<^sub>0(V := None) ++ l')\\<rangle>\n\ngoal (1 subgoal):\n 1. P,E(V \\<mapsto>\n    T) \\<turnstile> \\<langle>e,\n                     (h, (l\\<^sub>0 ++ l)(V := None))\\<rangle> \\<rightarrow>\n                    \\<langle>e',(h', l\\<^sub>0(V := None) ++ l')\\<rangle>", "by simp"], ["proof (state)\nthis:\n  P,E(V \\<mapsto>\n  T) \\<turnstile> \\<langle>e,\n                   (h, (l\\<^sub>0 ++ l)(V := None))\\<rangle> \\<rightarrow>\n                  \\<langle>e',(h', l\\<^sub>0(V := None) ++ l')\\<rangle>\n\ngoal (49 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 49 subgoals...", "have \"(l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) = l\\<^sub>0 ++ l'(V := l V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n    l\\<^sub>0 ++ l'(V := l V)", "by(simp add:fun_eq_iff map_add_def)"], ["proof (state)\nthis:\n  (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n  l\\<^sub>0 ++ l'(V := l V)\n\ngoal (49 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 49 subgoals...", "with red_reds.BlockRedSome[OF IH' _ unass] l'V"], ["proof (chain)\npicking this:\n  (l\\<^sub>0(V := None) ++ l') V = \\<lfloor>?v\\<rfloor> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>{V:T; e},\n                    (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                   \\<langle>{V:T; V:=Val ?v;; e'},\n                    (h', (l\\<^sub>0(V := None) ++ l')\n                     (V := (l\\<^sub>0 ++ l) V))\\<rangle>\n  l' V = \\<lfloor>v\\<rfloor>\n  (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n  l\\<^sub>0 ++ l'(V := l V)", "show ?case"], ["proof (prove)\nusing this:\n  (l\\<^sub>0(V := None) ++ l') V = \\<lfloor>?v\\<rfloor> \\<Longrightarrow>\n  P,E \\<turnstile> \\<langle>{V:T; e},\n                    (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                   \\<langle>{V:T; V:=Val ?v;; e'},\n                    (h', (l\\<^sub>0(V := None) ++ l')\n                     (V := (l\\<^sub>0 ++ l) V))\\<rangle>\n  l' V = \\<lfloor>v\\<rfloor>\n  (l\\<^sub>0(V := None) ++ l')(V := (l\\<^sub>0 ++ l) V) =\n  l\\<^sub>0 ++ l'(V := l V)\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> \\<langle>{V:T; e},\n                      (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                     \\<langle>{V:T; V:=Val v;; e'},\n                      (h', l\\<^sub>0 ++ l'(V := l V))\\<rangle>", "by(simp add:map_add_def)"], ["proof (state)\nthis:\n  P,E \\<turnstile> \\<langle>{V:T; e},\n                    (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                   \\<langle>{V:T; V:=Val v;; e'},\n                    (h', l\\<^sub>0 ++ l'(V := l V))\\<rangle>\n\ngoal (48 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 48 subgoals...", "next"], ["proof (state)\ngoal (48 subgoals):\n 1. \\<And>h a h' C E l l\\<^sub>0.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>new C,\n     (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, [C]),(h', l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>h E C l l\\<^sub>0.\n       new_Addr h = None \\<Longrightarrow>\n       P,E \\<turnstile> \\<langle>new C,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>\n                        \\<langle>Throw\n                                  (addr_of_sys_xcpt OutOfMemory,\n                                   [OutOfMemory]),\n                         (h, l\\<^sub>0 ++ l)\\<rangle>\n 3. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>\\<lparr>C\\<rparr>e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 4. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 5. \\<And>Cs C Cs' Ds E a aa b l\\<^sub>0.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>ref (a, Ds),(aa, l\\<^sub>0 ++ b)\\<rangle>\n 6. \\<And>C Cs E a aa b l\\<^sub>0.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>\\<lparr>C\\<rparr>ref\n                               (a, Cs),\n     (aa, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Throw (addr_of_sys_xcpt ClassCast, [ClassCast]),\n     (aa, l\\<^sub>0 ++ b)\\<rangle>\n 7. \\<And>E e a b e' aa ba C l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>Cast C e,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>Cast C e',(aa, l\\<^sub>0 ++ ba)\\<rangle>\n 8. \\<And>E C a b l\\<^sub>0.\n       P,E \\<turnstile> \\<langle>Cast C null,\n                         (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                        \\<langle>null,(a, l\\<^sub>0 ++ b)\\<rangle>\n 9. \\<And>E e a b e' aa ba bop e\\<^sub>2 l\\<^sub>0.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        \\<And>l\\<^sub>0.\n           P,E \\<turnstile> \\<langle>e,\n                             (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                            \\<langle>e',\n                             (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n    \\<langle>e' \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2,\n     (aa, l\\<^sub>0 ++ ba)\\<rangle>\n 10. \\<And>E e a b e' aa ba v\\<^sub>1 bop l\\<^sub>0.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                  \\<langle>e',(aa, ba)\\<rangle>;\n         \\<And>l\\<^sub>0.\n            P,E \\<turnstile> \\<langle>e,\n                              (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n                             \\<langle>e',\n                              (aa, l\\<^sub>0 ++ ba)\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> P,E \\<turnstile> \\<langle>Val\n               v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e,\n      (a, l\\<^sub>0 ++ b)\\<rangle> \\<rightarrow>\n     \\<langle>Val v\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e',\n      (aa, l\\<^sub>0 ++ ba)\\<rangle>\nA total of 48 subgoals...", "qed (simp_all add:red_reds.intros)"], ["", "lemma Red_lcl_add:\nassumes \"P,E \\<turnstile> \\<langle>e,(h,l)\\<rangle> \\<rightarrow>* \\<langle>e',(h',l')\\<rangle>\" shows \"P,E \\<turnstile> \\<langle>e,(h,l\\<^sub>0++l)\\<rangle> \\<rightarrow>* \\<langle>e',(h',l\\<^sub>0++l')\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,E \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>*\n                     \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  P,E \\<turnstile> \\<langle>e,(h, l)\\<rangle> \\<rightarrow>*\n                   \\<langle>e',(h', l')\\<rangle>\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> \\<langle>e,(h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>*\n                     \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>", "proof(induct rule:converse_rtrancl_induct_red)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e h l.\n       P,E \\<turnstile> \\<langle>e,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>*\n                        \\<langle>e,(h, l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>e\\<^sub>0 h\\<^sub>0 l\\<^sub>0' e\\<^sub>1 h\\<^sub>1 l\\<^sub>1 e' h'\n       l'.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e\\<^sub>0,\n                                  (h\\<^sub>0,\n                                   l\\<^sub>0')\\<rangle> \\<rightarrow>\n                                 \\<langle>e\\<^sub>1,\n                                  (h\\<^sub>1, l\\<^sub>1)\\<rangle>;\n        P,E \\<turnstile> \\<langle>e\\<^sub>1,\n                          (h\\<^sub>1,\n                           l\\<^sub>0 ++ l\\<^sub>1)\\<rangle> \\<rightarrow>*\n                         \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e\\<^sub>0,\n     (h\\<^sub>0, l\\<^sub>0 ++ l\\<^sub>0')\\<rangle> \\<rightarrow>*\n    \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>e h l.\n       P,E \\<turnstile> \\<langle>e,\n                         (h, l\\<^sub>0 ++ l)\\<rangle> \\<rightarrow>*\n                        \\<langle>e,(h, l\\<^sub>0 ++ l)\\<rangle>\n 2. \\<And>e\\<^sub>0 h\\<^sub>0 l\\<^sub>0' e\\<^sub>1 h\\<^sub>1 l\\<^sub>1 e' h'\n       l'.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e\\<^sub>0,\n                                  (h\\<^sub>0,\n                                   l\\<^sub>0')\\<rangle> \\<rightarrow>\n                                 \\<langle>e\\<^sub>1,\n                                  (h\\<^sub>1, l\\<^sub>1)\\<rangle>;\n        P,E \\<turnstile> \\<langle>e\\<^sub>1,\n                          (h\\<^sub>1,\n                           l\\<^sub>0 ++ l\\<^sub>1)\\<rangle> \\<rightarrow>*\n                         \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e\\<^sub>0,\n     (h\\<^sub>0, l\\<^sub>0 ++ l\\<^sub>0')\\<rangle> \\<rightarrow>*\n    \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,E \\<turnstile> \\<langle>e_,\n                      (h_, l\\<^sub>0 ++ l_)\\<rangle> \\<rightarrow>*\n                     \\<langle>e_,(h_, l\\<^sub>0 ++ l_)\\<rangle>", "by simp"], ["proof (state)\nthis:\n  P,E \\<turnstile> \\<langle>e_,(h_, l\\<^sub>0 ++ l_)\\<rangle> \\<rightarrow>*\n                   \\<langle>e_,(h_, l\\<^sub>0 ++ l_)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>e\\<^sub>0 h\\<^sub>0 l\\<^sub>0' e\\<^sub>1 h\\<^sub>1 l\\<^sub>1 e' h'\n       l'.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e\\<^sub>0,\n                                  (h\\<^sub>0,\n                                   l\\<^sub>0')\\<rangle> \\<rightarrow>\n                                 \\<langle>e\\<^sub>1,\n                                  (h\\<^sub>1, l\\<^sub>1)\\<rangle>;\n        P,E \\<turnstile> \\<langle>e\\<^sub>1,\n                          (h\\<^sub>1,\n                           l\\<^sub>0 ++ l\\<^sub>1)\\<rangle> \\<rightarrow>*\n                         \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e\\<^sub>0,\n     (h\\<^sub>0, l\\<^sub>0 ++ l\\<^sub>0')\\<rangle> \\<rightarrow>*\n    \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e\\<^sub>0 h\\<^sub>0 l\\<^sub>0' e\\<^sub>1 h\\<^sub>1 l\\<^sub>1 e' h'\n       l'.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e\\<^sub>0,\n                                  (h\\<^sub>0,\n                                   l\\<^sub>0')\\<rangle> \\<rightarrow>\n                                 \\<langle>e\\<^sub>1,\n                                  (h\\<^sub>1, l\\<^sub>1)\\<rangle>;\n        P,E \\<turnstile> \\<langle>e\\<^sub>1,\n                          (h\\<^sub>1,\n                           l\\<^sub>0 ++ l\\<^sub>1)\\<rangle> \\<rightarrow>*\n                         \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e\\<^sub>0,\n     (h\\<^sub>0, l\\<^sub>0 ++ l\\<^sub>0')\\<rangle> \\<rightarrow>*\n    \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>", "case 2"], ["proof (state)\nthis:\n  P,E \\<turnstile> \\<langle>e\\<^sub>0_,\n                    (h\\<^sub>0_, l\\<^sub>0_)\\<rangle> \\<rightarrow>\n                   \\<langle>e\\<^sub>1_,(h\\<^sub>1_, l\\<^sub>1_)\\<rangle>\n  P,E \\<turnstile> \\<langle>e\\<^sub>1_,\n                    (h\\<^sub>1_,\n                     l\\<^sub>0 ++ l\\<^sub>1_)\\<rangle> \\<rightarrow>*\n                   \\<langle>e'_,(h'_, l\\<^sub>0 ++ l'_)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>e\\<^sub>0 h\\<^sub>0 l\\<^sub>0' e\\<^sub>1 h\\<^sub>1 l\\<^sub>1 e' h'\n       l'.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e\\<^sub>0,\n                                  (h\\<^sub>0,\n                                   l\\<^sub>0')\\<rangle> \\<rightarrow>\n                                 \\<langle>e\\<^sub>1,\n                                  (h\\<^sub>1, l\\<^sub>1)\\<rangle>;\n        P,E \\<turnstile> \\<langle>e\\<^sub>1,\n                          (h\\<^sub>1,\n                           l\\<^sub>0 ++ l\\<^sub>1)\\<rangle> \\<rightarrow>*\n                         \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> P,E \\<turnstile> \\<langle>e\\<^sub>0,\n     (h\\<^sub>0, l\\<^sub>0 ++ l\\<^sub>0')\\<rangle> \\<rightarrow>*\n    \\<langle>e',(h', l\\<^sub>0 ++ l')\\<rangle>", "thus ?case"], ["proof (prove)\nusing this:\n  P,E \\<turnstile> \\<langle>e\\<^sub>0_,\n                    (h\\<^sub>0_, l\\<^sub>0_)\\<rangle> \\<rightarrow>\n                   \\<langle>e\\<^sub>1_,(h\\<^sub>1_, l\\<^sub>1_)\\<rangle>\n  P,E \\<turnstile> \\<langle>e\\<^sub>1_,\n                    (h\\<^sub>1_,\n                     l\\<^sub>0 ++ l\\<^sub>1_)\\<rangle> \\<rightarrow>*\n                   \\<langle>e'_,(h'_, l\\<^sub>0 ++ l'_)\\<rangle>\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> \\<langle>e\\<^sub>0_,\n                      (h\\<^sub>0_,\n                       l\\<^sub>0 ++ l\\<^sub>0_)\\<rangle> \\<rightarrow>*\n                     \\<langle>e'_,(h'_, l\\<^sub>0 ++ l'_)\\<rangle>", "by(auto dest: red_lcl_add intro: converse_rtrancl_into_rtrancl simp:Red_def)"], ["proof (state)\nthis:\n  P,E \\<turnstile> \\<langle>e\\<^sub>0_,\n                    (h\\<^sub>0_,\n                     l\\<^sub>0 ++ l\\<^sub>0_)\\<rangle> \\<rightarrow>*\n                   \\<langle>e'_,(h'_, l\\<^sub>0 ++ l'_)\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \nred_preserves_obj:\"\\<lbrakk>P,E \\<turnstile> \\<langle>e,(h,l)\\<rangle> \\<rightarrow> \\<langle>e',(h',l')\\<rangle>; h a = Some(D,S)\\<rbrakk> \n  \\<Longrightarrow> \\<exists>S'. h' a = Some(D,S')\"\nand reds_preserves_obj:\"\\<lbrakk>P,E \\<turnstile> \\<langle>es,(h,l)\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l')\\<rangle>; h a = Some(D,S)\\<rbrakk> \n  \\<Longrightarrow> \\<exists>S'. h' a = Some(D,S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>P,E \\<turnstile> \\<langle>e,(h, l)\\<rangle> \\<rightarrow>\n                               \\<langle>e',(h', l')\\<rangle>;\n      h a = \\<lfloor>(D, S)\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>S'. h' a = \\<lfloor>(D, S')\\<rfloor>) &&&\n    (\\<lbrakk>P,E \\<turnstile> \\<langle>es,(h, l)\\<rangle> [\\<rightarrow>]\n                               \\<langle>es',(h', l')\\<rangle>;\n      h a = \\<lfloor>(D, S)\\<rfloor>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>S'. h' a = \\<lfloor>(D, S')\\<rfloor>)", "by (induct rule:red_reds_inducts) (auto dest:new_Addr_SomeD)"], ["", "end"]]}