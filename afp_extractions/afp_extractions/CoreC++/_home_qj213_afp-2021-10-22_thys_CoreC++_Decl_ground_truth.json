{"file_name": "/home/qj213/afp-2021-10-22/thys/CoreC++/Decl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CoreC++", "problem_names": ["lemma not_getbase_repeats:\n  \"D \\<notin> set (map getbase xs) \\<Longrightarrow> Repeats D \\<notin> set xs\"", "lemma not_getbase_shares:\n  \"D \\<notin> set (map getbase xs) \\<Longrightarrow> Shares D \\<notin> set xs\"", "lemma RepBaseclass_isBaseclass:\n  \"\\<lbrakk>class P C = Some(Bs,fs,ms); Repeats D \\<in> set Bs\\<rbrakk>\n\\<Longrightarrow> D \\<in> baseClasses Bs\"", "lemma ShBaseclass_isBaseclass:\n  \"\\<lbrakk>class P C = Some(Bs,fs,ms); Shares D \\<in> set Bs\\<rbrakk>\n\\<Longrightarrow> D \\<in> baseClasses Bs\"", "lemma base_repeats_or_shares:\n  \"\\<lbrakk>B \\<in> set Bs; D = getbase B\\<rbrakk> \n\\<Longrightarrow> Repeats D \\<in> set Bs \\<or> Shares D \\<in> set Bs\"", "lemma baseClasses_repeats_or_shares:\n  \"D \\<in> baseClasses Bs \\<Longrightarrow> Repeats D \\<in> set Bs \\<or> Shares D \\<in> set Bs\"", "lemma finite_is_class: \"finite {C. is_class P C}\"", "lemma finite_baseClasses: \n  \"class P C = Some(Bs,fs,ms) \\<Longrightarrow> finite (baseClasses Bs)\"", "lemma is_type_simps [simp]:\n  \"is_type P Void \\<and> is_type P Boolean \\<and> is_type P Integer \\<and>\n  is_type P NT \\<and> is_type P (Class C) = is_class P C\"", "lemma typeof_lit_is_type: \n  \"typeof v = Some T \\<Longrightarrow> is_type P T\""], "translations": [["", "lemma not_getbase_repeats:\n  \"D \\<notin> set (map getbase xs) \\<Longrightarrow> Repeats D \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<notin> set (map getbase xs) \\<Longrightarrow>\n    Repeats D \\<notin> set xs", "by (induct rule: list.induct, auto)"], ["", "lemma not_getbase_shares:\n  \"D \\<notin> set (map getbase xs) \\<Longrightarrow> Shares D \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<notin> set (map getbase xs) \\<Longrightarrow>\n    Shares D \\<notin> set xs", "by (induct rule: list.induct, auto)"], ["", "lemma RepBaseclass_isBaseclass:\n  \"\\<lbrakk>class P C = Some(Bs,fs,ms); Repeats D \\<in> set Bs\\<rbrakk>\n\\<Longrightarrow> D \\<in> baseClasses Bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>;\n     Repeats D \\<in> set Bs\\<rbrakk>\n    \\<Longrightarrow> D \\<in> baseClasses Bs", "by (simp add:baseClasses_def, induct rule: list.induct, \n  auto simp:not_getbase_repeats)"], ["", "lemma ShBaseclass_isBaseclass:\n  \"\\<lbrakk>class P C = Some(Bs,fs,ms); Shares D \\<in> set Bs\\<rbrakk>\n\\<Longrightarrow> D \\<in> baseClasses Bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>;\n     Shares D \\<in> set Bs\\<rbrakk>\n    \\<Longrightarrow> D \\<in> baseClasses Bs", "by (simp add:baseClasses_def, induct rule: list.induct, \n  auto simp:not_getbase_shares)"], ["", "lemma base_repeats_or_shares:\n  \"\\<lbrakk>B \\<in> set Bs; D = getbase B\\<rbrakk> \n\\<Longrightarrow> Repeats D \\<in> set Bs \\<or> Shares D \\<in> set Bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<in> set Bs; D = getbase B\\<rbrakk>\n    \\<Longrightarrow> Repeats D \\<in> set Bs \\<or> Shares D \\<in> set Bs", "by(induct B rule:base.induct) simp+"], ["", "lemma baseClasses_repeats_or_shares:\n  \"D \\<in> baseClasses Bs \\<Longrightarrow> Repeats D \\<in> set Bs \\<or> Shares D \\<in> set Bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<in> baseClasses Bs \\<Longrightarrow>\n    Repeats D \\<in> set Bs \\<or> Shares D \\<in> set Bs", "by (auto elim!:bexE base_repeats_or_shares \n  simp add:baseClasses_def image_def)"], ["", "lemma finite_is_class: \"finite {C. is_class P C}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {C. is_class P C}", "apply (unfold is_class_def class_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {C. map_of P C \\<noteq> None}", "apply (fold dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (map_of P))", "apply (rule finite_dom_map_of)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_baseClasses: \n  \"class P C = Some(Bs,fs,ms) \\<Longrightarrow> finite (baseClasses Bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<Longrightarrow>\n    finite (baseClasses Bs)", "apply (unfold is_class_def class_def baseClasses_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of P C = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<Longrightarrow>\n    finite (set (map getbase Bs))", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition is_type :: \"prog \\<Rightarrow> ty \\<Rightarrow> bool\" where\n  \"is_type P T  \\<equiv>\n  (case T of Void \\<Rightarrow> True | Boolean \\<Rightarrow> True | Integer \\<Rightarrow> True | NT \\<Rightarrow> True\n   | Class C \\<Rightarrow> is_class P C)\""], ["", "lemma is_type_simps [simp]:\n  \"is_type P Void \\<and> is_type P Boolean \\<and> is_type P Integer \\<and>\n  is_type P NT \\<and> is_type P (Class C) = is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type P Void \\<and>\n    is_type P Boolean \\<and>\n    is_type P Integer \\<and>\n    is_type P NT \\<and> is_type P (Class C) = is_class P C", "by(simp add:is_type_def)"], ["", "abbreviation\n  \"types P == Collect (CONST is_type P)\""], ["", "lemma typeof_lit_is_type: \n  \"typeof v = Some T \\<Longrightarrow> is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof v = \\<lfloor>T\\<rfloor> \\<Longrightarrow> is_type P T", "by (induct v) (auto)"], ["", "end"]]}