{"file_name": "/home/qj213/afp-2021-10-22/thys/CoreC++/HeapExtension.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CoreC++", "problem_names": ["lemma hextI: \"\\<forall>a C S. h a = Some(C,S) \\<longrightarrow> (\\<exists>S'. h' a = Some(C,S')) \\<Longrightarrow> h \\<unlhd> h'\"", "lemma hext_objD: \"\\<lbrakk> h \\<unlhd> h'; h a = Some(C,S) \\<rbrakk> \\<Longrightarrow> \\<exists>S'. h' a = Some(C,S')\"", "lemma hext_refl [iff]: \"h \\<unlhd> h\"", "lemma hext_new [simp]: \"h a = None \\<Longrightarrow> h \\<unlhd> h(a\\<mapsto>x)\"", "lemma hext_trans: \"\\<lbrakk> h \\<unlhd> h'; h' \\<unlhd> h'' \\<rbrakk> \\<Longrightarrow> h \\<unlhd> h''\"", "lemma hext_upd_obj: \"h a = Some (C,S) \\<Longrightarrow> h \\<unlhd> h(a\\<mapsto>(C,S'))\"", "lemma preallocated_hext:\n  \"\\<lbrakk> preallocated h; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> preallocated h'\"", "lemmas preallocated_upd_obj = preallocated_hext [OF _ hext_upd_obj]", "lemmas preallocated_new  = preallocated_hext [OF _ hext_new]", "lemma red_hext_incr: \"P,E \\<turnstile> \\<langle>e,(h,l)\\<rangle> \\<rightarrow> \\<langle>e',(h',l')\\<rangle>  \\<Longrightarrow> h \\<unlhd> h'\"\n  and reds_hext_incr: \"P,E \\<turnstile> \\<langle>es,(h,l)\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l')\\<rangle>  \\<Longrightarrow> h \\<unlhd> h'\"", "lemma step_hext_incr: \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow>* \\<langle>e',s'\\<rangle>  \\<Longrightarrow> hp s \\<unlhd> hp s'\"", "lemma steps_hext_incr: \"P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>]* \\<langle>es',s'\\<rangle>  \\<Longrightarrow> hp s \\<unlhd> hp s'\"", "lemma eval_hext: \"P,E \\<turnstile> \\<langle>e,(h,l)\\<rangle> \\<Rightarrow> \\<langle>e',(h',l')\\<rangle> \\<Longrightarrow> h \\<unlhd> h'\"\nand evals_hext:  \"P,E \\<turnstile> \\<langle>es,(h,l)\\<rangle> [\\<Rightarrow>] \\<langle>es',(h',l')\\<rangle> \\<Longrightarrow> h \\<unlhd> h'\"", "lemma conf_hext: \"h \\<unlhd> h' \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T\"", "lemma confs_hext: \"P,h \\<turnstile> vs [:\\<le>] Ts \\<Longrightarrow> h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> vs [:\\<le>] Ts\"", "lemma fconf_hext: \"\\<lbrakk> P,h \\<turnstile> fs (:\\<le>) E; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> fs (:\\<le>) E\"", "lemmas fconf_upd_obj = fconf_hext [OF _ hext_upd_obj]", "lemmas fconf_new = fconf_hext [OF _ hext_new]", "lemma oconf_hext: \"P,h \\<turnstile> obj \\<surd> \\<Longrightarrow> h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> obj \\<surd>\"", "lemmas oconf_new = oconf_hext [OF _ hext_new]", "lemmas oconf_upd_obj = oconf_hext [OF _ hext_upd_obj]", "lemma hconf_new: \"\\<lbrakk> P \\<turnstile> h \\<surd>; h a = None; P,h \\<turnstile> obj \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile> h(a\\<mapsto>obj) \\<surd>\"", "lemma \"\\<lbrakk>P \\<turnstile> h \\<surd>; h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None; wf_prog wf_md P\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> h' \\<surd>\"", "lemma hconf_upd_obj: \n\"\\<lbrakk> P \\<turnstile> h\\<surd>; h a = Some(C,S); P,h \\<turnstile> (C,S')\\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile> h(a\\<mapsto>(C,S'))\\<surd>\"", "lemma lconf_hext: \"\\<lbrakk> P,h \\<turnstile> l (:\\<le>)\\<^sub>w E; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> l (:\\<le>)\\<^sub>w E\"", "lemma hext_typeof_mono: \"\\<lbrakk> h \\<unlhd> h'; P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = Some T \\<rbrakk> \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v = Some T\"", "lemma WTrt_hext_mono: \"P,E,h \\<turnstile> e : T \\<Longrightarrow> (\\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T)\"\nand WTrts_hext_mono: \"P,E,h \\<turnstile> es [:] Ts \\<Longrightarrow> (\\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts)\""], "translations": [["", "lemma hextI: \"\\<forall>a C S. h a = Some(C,S) \\<longrightarrow> (\\<exists>S'. h' a = Some(C,S')) \\<Longrightarrow> h \\<unlhd> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a C S.\n       h a = \\<lfloor>(C, S)\\<rfloor> \\<longrightarrow>\n       (\\<exists>S'. h' a = \\<lfloor>(C, S')\\<rfloor>) \\<Longrightarrow>\n    h \\<unlhd> h'", "apply (unfold hext_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a C S.\n       h a = \\<lfloor>(C, S)\\<rfloor> \\<longrightarrow>\n       (\\<exists>S'. h' a = \\<lfloor>(C, S')\\<rfloor>) \\<Longrightarrow>\n    \\<forall>a C S.\n       h a = \\<lfloor>(C, S)\\<rfloor> \\<longrightarrow>\n       (\\<exists>S'. h' a = \\<lfloor>(C, S')\\<rfloor>)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hext_objD: \"\\<lbrakk> h \\<unlhd> h'; h a = Some(C,S) \\<rbrakk> \\<Longrightarrow> \\<exists>S'. h' a = Some(C,S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h'; h a = \\<lfloor>(C, S)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>S'. h' a = \\<lfloor>(C, S')\\<rfloor>", "apply (unfold hext_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a C S.\n                h a = \\<lfloor>(C, S)\\<rfloor> \\<longrightarrow>\n                (\\<exists>S'. h' a = \\<lfloor>(C, S')\\<rfloor>);\n     h a = \\<lfloor>(C, S)\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>S'. h' a = \\<lfloor>(C, S')\\<rfloor>", "apply (force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hext_refl [iff]: \"h \\<unlhd> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<unlhd> h", "apply (rule hextI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a C S.\n       h a = \\<lfloor>(C, S)\\<rfloor> \\<longrightarrow>\n       (\\<exists>S'. h a = \\<lfloor>(C, S')\\<rfloor>)", "apply (fast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hext_new [simp]: \"h a = None \\<Longrightarrow> h \\<unlhd> h(a\\<mapsto>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = None \\<Longrightarrow> h \\<unlhd> h(a \\<mapsto> x)", "apply (rule hextI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = None \\<Longrightarrow>\n    \\<forall>aa C S.\n       h aa = \\<lfloor>(C, S)\\<rfloor> \\<longrightarrow>\n       (\\<exists>S'. (h(a \\<mapsto> x)) aa = \\<lfloor>(C, S')\\<rfloor>)", "apply (auto simp:fun_upd_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hext_trans: \"\\<lbrakk> h \\<unlhd> h'; h' \\<unlhd> h'' \\<rbrakk> \\<Longrightarrow> h \\<unlhd> h''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h'; h' \\<unlhd> h''\\<rbrakk>\n    \\<Longrightarrow> h \\<unlhd> h''", "apply (rule hextI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h'; h' \\<unlhd> h''\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a C S.\n                         h a = \\<lfloor>(C, S)\\<rfloor> \\<longrightarrow>\n                         (\\<exists>S'. h'' a = \\<lfloor>(C, S')\\<rfloor>)", "apply (fast dest: hext_objD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hext_upd_obj: \"h a = Some (C,S) \\<Longrightarrow> h \\<unlhd> h(a\\<mapsto>(C,S'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = \\<lfloor>(C, S)\\<rfloor> \\<Longrightarrow>\n    h \\<unlhd> h(a \\<mapsto> (C, S'))", "apply (rule hextI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h a = \\<lfloor>(C, S)\\<rfloor> \\<Longrightarrow>\n    \\<forall>aa Ca S.\n       h aa = \\<lfloor>(Ca, S)\\<rfloor> \\<longrightarrow>\n       (\\<exists>S'a.\n           (h(a \\<mapsto> (C, S'))) aa = \\<lfloor>(Ca, S'a)\\<rfloor>)", "apply (auto simp:fun_upd_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>\\<open>\\<unlhd>\\<close> and preallocated\\<close>"], ["", "lemma preallocated_hext:\n  \"\\<lbrakk> preallocated h; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> preallocated h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preallocated h; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> preallocated h'", "by (simp add: preallocated_def hext_def)"], ["", "lemmas preallocated_upd_obj = preallocated_hext [OF _ hext_upd_obj]"], ["", "lemmas preallocated_new  = preallocated_hext [OF _ hext_new]"], ["", "subsection \\<open>\\<open>\\<unlhd>\\<close> in Small- and BigStep\\<close>"], ["", "lemma red_hext_incr: \"P,E \\<turnstile> \\<langle>e,(h,l)\\<rangle> \\<rightarrow> \\<langle>e',(h',l')\\<rangle>  \\<Longrightarrow> h \\<unlhd> h'\"\n  and reds_hext_incr: \"P,E \\<turnstile> \\<langle>es,(h,l)\\<rangle> [\\<rightarrow>] \\<langle>es',(h',l')\\<rangle>  \\<Longrightarrow> h \\<unlhd> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,E \\<turnstile> \\<langle>e,(h, l)\\<rangle> \\<rightarrow>\n                      \\<langle>e',(h', l')\\<rangle> \\<Longrightarrow>\n     h \\<unlhd> h') &&&\n    (P,E \\<turnstile> \\<langle>es,(h, l)\\<rangle> [\\<rightarrow>]\n                      \\<langle>es',(h', l')\\<rangle> \\<Longrightarrow>\n     h \\<unlhd> h')", "proof(induct rule:red_reds_inducts)"], ["proof (state)\ngoal (61 subgoals):\n 1. \\<And>h a h' C E l.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>h E C l. new_Addr h = None \\<Longrightarrow> h \\<unlhd> h\n 3. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 4. \\<And>E C a b. a \\<unlhd> a\n 5. \\<And>Cs C Cs' Ds E a aa b.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 6. \\<And>E C a Cs Cs' aa b. aa \\<unlhd> aa\n 7. \\<And>C Cs E a aa b.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 8. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 9. \\<And>E C a b. a \\<unlhd> a\n 10. \\<And>Cs C Cs' Ds E a aa b.\n        \\<lbrakk>P \\<turnstile> Path last Cs to C unique;\n         P \\<turnstile> Path last Cs to C via Cs' ;\n         Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n        \\<Longrightarrow> aa \\<unlhd> aa\nA total of 61 subgoals...", "case RedNew"], ["proof (state)\nthis:\n  new_Addr h_ = \\<lfloor>a_\\<rfloor>\n  h'_ = h_(a_ \\<mapsto> (C_, Collect (init_obj P C_)))\n\ngoal (61 subgoals):\n 1. \\<And>h a h' C E l.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>h E C l. new_Addr h = None \\<Longrightarrow> h \\<unlhd> h\n 3. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 4. \\<And>E C a b. a \\<unlhd> a\n 5. \\<And>Cs C Cs' Ds E a aa b.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 6. \\<And>E C a Cs Cs' aa b. aa \\<unlhd> aa\n 7. \\<And>C Cs E a aa b.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 8. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 9. \\<And>E C a b. a \\<unlhd> a\n 10. \\<And>Cs C Cs' Ds E a aa b.\n        \\<lbrakk>P \\<turnstile> Path last Cs to C unique;\n         P \\<turnstile> Path last Cs to C via Cs' ;\n         Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n        \\<Longrightarrow> aa \\<unlhd> aa\nA total of 61 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  new_Addr h_ = \\<lfloor>a_\\<rfloor>\n  h'_ = h_(a_ \\<mapsto> (C_, Collect (init_obj P C_)))\n\ngoal (1 subgoal):\n 1. h_ \\<unlhd> h'_", "by(fastforce dest:new_Addr_SomeD simp:hext_def split:if_splits)"], ["proof (state)\nthis:\n  h_ \\<unlhd> h'_\n\ngoal (60 subgoals):\n 1. \\<And>h E C l. new_Addr h = None \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 3. \\<And>E C a b. a \\<unlhd> a\n 4. \\<And>Cs C Cs' Ds E a aa b.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 5. \\<And>E C a Cs Cs' aa b. aa \\<unlhd> aa\n 6. \\<And>C Cs E a aa b.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 7. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 8. \\<And>E C a b. a \\<unlhd> a\n 9. \\<And>Cs C Cs' Ds E a aa b.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C unique;\n        P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 10. \\<And>E C a Cs Cs' aa b. aa \\<unlhd> aa\nA total of 60 subgoals...", "next"], ["proof (state)\ngoal (60 subgoals):\n 1. \\<And>h E C l. new_Addr h = None \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 3. \\<And>E C a b. a \\<unlhd> a\n 4. \\<And>Cs C Cs' Ds E a aa b.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 5. \\<And>E C a Cs Cs' aa b. aa \\<unlhd> aa\n 6. \\<And>C Cs E a aa b.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 7. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 8. \\<And>E C a b. a \\<unlhd> a\n 9. \\<And>Cs C Cs' Ds E a aa b.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C unique;\n        P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 10. \\<And>E C a Cs Cs' aa b. aa \\<unlhd> aa\nA total of 60 subgoals...", "case RedFAss"], ["proof (state)\nthis:\n  h_ a_ = \\<lfloor>(D_, S_)\\<rfloor>\n  P \\<turnstile> last Cs'_ has least F_:T_ via Cs_\n  P \\<turnstile> T_ casts v_ to v'_ \n  Ds_ = Cs'_ @\\<^sub>p Cs_\n  (Ds_, fs_) \\<in> S_\n\ngoal (60 subgoals):\n 1. \\<And>h E C l. new_Addr h = None \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 3. \\<And>E C a b. a \\<unlhd> a\n 4. \\<And>Cs C Cs' Ds E a aa b.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 5. \\<And>E C a Cs Cs' aa b. aa \\<unlhd> aa\n 6. \\<And>C Cs E a aa b.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 7. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 8. \\<And>E C a b. a \\<unlhd> a\n 9. \\<And>Cs C Cs' Ds E a aa b.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C unique;\n        P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 10. \\<And>E C a Cs Cs' aa b. aa \\<unlhd> aa\nA total of 60 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  h_ a_ = \\<lfloor>(D_, S_)\\<rfloor>\n  P \\<turnstile> last Cs'_ has least F_:T_ via Cs_\n  P \\<turnstile> T_ casts v_ to v'_ \n  Ds_ = Cs'_ @\\<^sub>p Cs_\n  (Ds_, fs_) \\<in> S_\n\ngoal (1 subgoal):\n 1. h_ \\<unlhd> h_(a_ \\<mapsto>\n    (D_, insert (Ds_, fs_(F_ \\<mapsto> v'_)) (S_ - {(Ds_, fs_)})))", "by(simp add:hext_def split:if_splits)"], ["proof (state)\nthis:\n  h_ \\<unlhd> h_(a_ \\<mapsto>\n  (D_, insert (Ds_, fs_(F_ \\<mapsto> v'_)) (S_ - {(Ds_, fs_)})))\n\ngoal (59 subgoals):\n 1. \\<And>h E C l. new_Addr h = None \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 3. \\<And>E C a b. a \\<unlhd> a\n 4. \\<And>Cs C Cs' Ds E a aa b.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 5. \\<And>E C a Cs Cs' aa b. aa \\<unlhd> aa\n 6. \\<And>C Cs E a aa b.\n       \\<lbrakk>C \\<notin> set Cs;\n        (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 7. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<rightarrow>\n                                 \\<langle>e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 8. \\<And>E C a b. a \\<unlhd> a\n 9. \\<And>Cs C Cs' Ds E a aa b.\n       \\<lbrakk>P \\<turnstile> Path last Cs to C unique;\n        P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> aa \\<unlhd> aa\n 10. \\<And>E C a Cs Cs' aa b. aa \\<unlhd> aa\nA total of 59 subgoals...", "qed simp_all"], ["", "lemma step_hext_incr: \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow>* \\<langle>e',s'\\<rangle>  \\<Longrightarrow> hp s \\<unlhd> hp s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow>*\n                     \\<langle>e',s'\\<rangle> \\<Longrightarrow>\n    hp s \\<unlhd> hp s'", "proof(induct rule:converse_rtrancl_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. hp s' \\<unlhd> hp s'\n 2. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Red P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> \\<rightarrow>*\n                         \\<langle>e',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "case refl"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. hp s' \\<unlhd> hp s'\n 2. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Red P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> \\<rightarrow>*\n                         \\<langle>e',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. hp s' \\<unlhd> hp s'", "by(rule hext_refl)"], ["proof (state)\nthis:\n  hp s' \\<unlhd> hp s'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Red P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> \\<rightarrow>*\n                         \\<langle>e',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Red P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> \\<rightarrow>*\n                         \\<langle>e',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "case (step e s e'' s'')"], ["proof (state)\nthis:\n  ((e, s), e'', s'') \\<in> Red P E\n  P,E \\<turnstile> \\<langle>e'',s''\\<rangle> \\<rightarrow>*\n                   \\<langle>e',s'\\<rangle>\n  hp s'' \\<unlhd> hp s'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Red P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> \\<rightarrow>*\n                         \\<langle>e',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "have Red:\"((e, s), e'', s'') \\<in> Red P E\"\n    and hext:\"hp s'' \\<unlhd> hp s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((e, s), e'', s'') \\<in> Red P E &&& hp s'' \\<unlhd> hp s'", "by fact+"], ["proof (state)\nthis:\n  ((e, s), e'', s'') \\<in> Red P E\n  hp s'' \\<unlhd> hp s'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Red P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> \\<rightarrow>*\n                         \\<langle>e',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "from Red"], ["proof (chain)\npicking this:\n  ((e, s), e'', s'') \\<in> Red P E", "have \"P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow> \\<langle>e'',s''\\<rangle>\""], ["proof (prove)\nusing this:\n  ((e, s), e'', s'') \\<in> Red P E\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow>\n                     \\<langle>e'',s''\\<rangle>", "by simp"], ["proof (state)\nthis:\n  P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow>\n                   \\<langle>e'',s''\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Red P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> \\<rightarrow>*\n                         \\<langle>e',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "hence \"hp s \\<unlhd> hp s''\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> \\<langle>e,s\\<rangle> \\<rightarrow>\n                   \\<langle>e'',s''\\<rangle>\n\ngoal (1 subgoal):\n 1. hp s \\<unlhd> hp s''", "by(cases s,cases s'')(auto dest:red_hext_incr)"], ["proof (state)\nthis:\n  hp s \\<unlhd> hp s''\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Red P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> \\<rightarrow>*\n                         \\<langle>e',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "with hext"], ["proof (chain)\npicking this:\n  hp s'' \\<unlhd> hp s'\n  hp s \\<unlhd> hp s''", "show ?case"], ["proof (prove)\nusing this:\n  hp s'' \\<unlhd> hp s'\n  hp s \\<unlhd> hp s''\n\ngoal (1 subgoal):\n 1. hp s \\<unlhd> hp s'", "by-(rule hext_trans)"], ["proof (state)\nthis:\n  hp s \\<unlhd> hp s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_hext_incr: \"P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>]* \\<langle>es',s'\\<rangle>  \\<Longrightarrow> hp s \\<unlhd> hp s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>]*\n                     \\<langle>es',s'\\<rangle> \\<Longrightarrow>\n    hp s \\<unlhd> hp s'", "proof(induct rule:converse_rtrancl_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. hp s' \\<unlhd> hp s'\n 2. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Reds P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> [\\<rightarrow>]*\n                         \\<langle>es',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "case refl"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. hp s' \\<unlhd> hp s'\n 2. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Reds P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> [\\<rightarrow>]*\n                         \\<langle>es',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. hp s' \\<unlhd> hp s'", "by(rule hext_refl)"], ["proof (state)\nthis:\n  hp s' \\<unlhd> hp s'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Reds P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> [\\<rightarrow>]*\n                         \\<langle>es',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Reds P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> [\\<rightarrow>]*\n                         \\<langle>es',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "case (step es s es'' s'')"], ["proof (state)\nthis:\n  ((es, s), es'', s'') \\<in> Reds P E\n  P,E \\<turnstile> \\<langle>es'',s''\\<rangle> [\\<rightarrow>]*\n                   \\<langle>es',s'\\<rangle>\n  hp s'' \\<unlhd> hp s'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Reds P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> [\\<rightarrow>]*\n                         \\<langle>es',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "have Reds:\"((es, s), es'', s'') \\<in> Reds P E\"\n    and hext:\"hp s'' \\<unlhd> hp s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((es, s), es'', s'') \\<in> Reds P E &&& hp s'' \\<unlhd> hp s'", "by fact+"], ["proof (state)\nthis:\n  ((es, s), es'', s'') \\<in> Reds P E\n  hp s'' \\<unlhd> hp s'\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Reds P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> [\\<rightarrow>]*\n                         \\<langle>es',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "from Reds"], ["proof (chain)\npicking this:\n  ((es, s), es'', s'') \\<in> Reds P E", "have \"P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>] \\<langle>es'',s''\\<rangle>\""], ["proof (prove)\nusing this:\n  ((es, s), es'', s'') \\<in> Reds P E\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>]\n                     \\<langle>es'',s''\\<rangle>", "by simp"], ["proof (state)\nthis:\n  P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>]\n                   \\<langle>es'',s''\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Reds P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> [\\<rightarrow>]*\n                         \\<langle>es',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "hence \"hp s \\<unlhd> hp s''\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> \\<langle>es,s\\<rangle> [\\<rightarrow>]\n                   \\<langle>es'',s''\\<rangle>\n\ngoal (1 subgoal):\n 1. hp s \\<unlhd> hp s''", "by(cases s,cases s'',auto dest:reds_hext_incr)"], ["proof (state)\nthis:\n  hp s \\<unlhd> hp s''\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> Reds P E;\n        P,E \\<turnstile> \\<langle>aa,ba\\<rangle> [\\<rightarrow>]*\n                         \\<langle>es',s'\\<rangle>;\n        hp ba \\<unlhd> hp s'\\<rbrakk>\n       \\<Longrightarrow> hp b \\<unlhd> hp s'", "with hext"], ["proof (chain)\npicking this:\n  hp s'' \\<unlhd> hp s'\n  hp s \\<unlhd> hp s''", "show ?case"], ["proof (prove)\nusing this:\n  hp s'' \\<unlhd> hp s'\n  hp s \\<unlhd> hp s''\n\ngoal (1 subgoal):\n 1. hp s \\<unlhd> hp s'", "by-(rule hext_trans)"], ["proof (state)\nthis:\n  hp s \\<unlhd> hp s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_hext: \"P,E \\<turnstile> \\<langle>e,(h,l)\\<rangle> \\<Rightarrow> \\<langle>e',(h',l')\\<rangle> \\<Longrightarrow> h \\<unlhd> h'\"\nand evals_hext:  \"P,E \\<turnstile> \\<langle>es,(h,l)\\<rangle> [\\<Rightarrow>] \\<langle>es',(h',l')\\<rangle> \\<Longrightarrow> h \\<unlhd> h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,E \\<turnstile> \\<langle>e,(h, l)\\<rangle> \\<Rightarrow>\n                      \\<langle>e',(h', l')\\<rangle> \\<Longrightarrow>\n     h \\<unlhd> h') &&&\n    (P,E \\<turnstile> \\<langle>es,(h, l)\\<rangle> [\\<Rightarrow>]\n                      \\<langle>es',(h', l')\\<rangle> \\<Longrightarrow>\n     h \\<unlhd> h')", "proof (induct rule:eval_evals_inducts)"], ["proof (state)\ngoal (48 subgoals):\n 1. \\<And>h a h' C E l.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>h E C l. new_Addr h = None \\<Longrightarrow> h \\<unlhd> h\n 3. \\<And>E e a b aa Cs ab ba C Cs' Ds.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 4. \\<And>E e a b aa Cs C Cs' ab ba.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs @ [C] @ Cs'),\n                                  (ab, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 5. \\<And>E e a b aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>null,(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 6. \\<And>E e a b aa Cs ab ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*;\n        C \\<notin> set Cs\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 7. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>throw e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 8. \\<And>E e a b aa Cs ab ba C Cs' Ds.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; P \\<turnstile> Path last Cs to C unique;\n        P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 9. \\<And>E e a b aa Cs C Cs' ab ba.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs @ [C] @ Cs'),\n                                  (ab, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 10. \\<And>E e a b aa Cs h l D S C Cs'.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                  \\<langle>ref (aa, Cs),(h, l)\\<rangle>;\n         a \\<unlhd> h; h aa = \\<lfloor>(D, S)\\<rfloor>;\n         P \\<turnstile> Path D to C via Cs' ;\n         P \\<turnstile> Path D to C unique\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> h\nA total of 48 subgoals...", "case New"], ["proof (state)\nthis:\n  new_Addr h_ = \\<lfloor>a_\\<rfloor>\n  h'_ = h_(a_ \\<mapsto> (C_, Collect (init_obj P C_)))\n\ngoal (48 subgoals):\n 1. \\<And>h a h' C E l.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C)))\\<rbrakk>\n       \\<Longrightarrow> h \\<unlhd> h'\n 2. \\<And>h E C l. new_Addr h = None \\<Longrightarrow> h \\<unlhd> h\n 3. \\<And>E e a b aa Cs ab ba C Cs' Ds.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 4. \\<And>E e a b aa Cs C Cs' ab ba.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs @ [C] @ Cs'),\n                                  (ab, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 5. \\<And>E e a b aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>null,(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 6. \\<And>E e a b aa Cs ab ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*;\n        C \\<notin> set Cs\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 7. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>throw e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 8. \\<And>E e a b aa Cs ab ba C Cs' Ds.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; P \\<turnstile> Path last Cs to C unique;\n        P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 9. \\<And>E e a b aa Cs C Cs' ab ba.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs @ [C] @ Cs'),\n                                  (ab, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 10. \\<And>E e a b aa Cs h l D S C Cs'.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                  \\<langle>ref (aa, Cs),(h, l)\\<rangle>;\n         a \\<unlhd> h; h aa = \\<lfloor>(D, S)\\<rfloor>;\n         P \\<turnstile> Path D to C via Cs' ;\n         P \\<turnstile> Path D to C unique\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> h\nA total of 48 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  new_Addr h_ = \\<lfloor>a_\\<rfloor>\n  h'_ = h_(a_ \\<mapsto> (C_, Collect (init_obj P C_)))\n\ngoal (1 subgoal):\n 1. h_ \\<unlhd> h'_", "by(fastforce intro!: hext_new intro:someI simp:new_Addr_def\n                split:if_split_asm simp del:fun_upd_apply)"], ["proof (state)\nthis:\n  h_ \\<unlhd> h'_\n\ngoal (47 subgoals):\n 1. \\<And>h E C l. new_Addr h = None \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>E e a b aa Cs ab ba C Cs' Ds.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 3. \\<And>E e a b aa Cs C Cs' ab ba.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs @ [C] @ Cs'),\n                                  (ab, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 4. \\<And>E e a b aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>null,(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 5. \\<And>E e a b aa Cs ab ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*;\n        C \\<notin> set Cs\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 6. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>throw e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 7. \\<And>E e a b aa Cs ab ba C Cs' Ds.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; P \\<turnstile> Path last Cs to C unique;\n        P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 8. \\<And>E e a b aa Cs C Cs' ab ba.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs @ [C] @ Cs'),\n                                  (ab, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 9. \\<And>E e a b aa Cs h l D S C Cs'.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(h, l)\\<rangle>;\n        a \\<unlhd> h; h aa = \\<lfloor>(D, S)\\<rfloor>;\n        P \\<turnstile> Path D to C via Cs' ;\n        P \\<turnstile> Path D to C unique\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 10. \\<And>E e a b aa ba C.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                  \\<langle>null,(aa, ba)\\<rangle>;\n         a \\<unlhd> aa\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> aa\nA total of 47 subgoals...", "next"], ["proof (state)\ngoal (47 subgoals):\n 1. \\<And>h E C l. new_Addr h = None \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>E e a b aa Cs ab ba C Cs' Ds.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 3. \\<And>E e a b aa Cs C Cs' ab ba.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs @ [C] @ Cs'),\n                                  (ab, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 4. \\<And>E e a b aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>null,(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 5. \\<And>E e a b aa Cs ab ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*;\n        C \\<notin> set Cs\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 6. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>throw e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 7. \\<And>E e a b aa Cs ab ba C Cs' Ds.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; P \\<turnstile> Path last Cs to C unique;\n        P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 8. \\<And>E e a b aa Cs C Cs' ab ba.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs @ [C] @ Cs'),\n                                  (ab, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 9. \\<And>E e a b aa Cs h l D S C Cs'.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(h, l)\\<rangle>;\n        a \\<unlhd> h; h aa = \\<lfloor>(D, S)\\<rfloor>;\n        P \\<turnstile> Path D to C via Cs' ;\n        P \\<turnstile> Path D to C unique\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 10. \\<And>E e a b aa ba C.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                  \\<langle>null,(aa, ba)\\<rangle>;\n         a \\<unlhd> aa\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> aa\nA total of 47 subgoals...", "case FAss"], ["proof (state)\nthis:\n  P,E_ \\<turnstile> \\<langle>e\\<^sub>1_,(a___, b___)\\<rangle> \\<Rightarrow>\n                    \\<langle>ref (aa___, Cs'_),(a_, b_)\\<rangle>\n  a___ \\<unlhd> a_\n  P,E_ \\<turnstile> \\<langle>e\\<^sub>2_,(a_, b_)\\<rangle> \\<Rightarrow>\n                    \\<langle>Val v_,(h\\<^sub>2_, l\\<^sub>2_)\\<rangle>\n  a_ \\<unlhd> h\\<^sub>2_\n  h\\<^sub>2_ aa___ = \\<lfloor>(D_, S_)\\<rfloor>\n  P \\<turnstile> last Cs'_ has least F_:T_ via Cs_\n  P \\<turnstile> T_ casts v_ to v'_ \n  Ds_ = Cs'_ @\\<^sub>p Cs_\n  (Ds_, fs_) \\<in> S_\n  fs'_ = fs_(F_ \\<mapsto> v'_)\n  S'_ = S_ - {(Ds_, fs_)} \\<union> {(Ds_, fs'_)}\n  h\\<^sub>2'_ = h\\<^sub>2_(aa___ \\<mapsto> (D_, S'_))\n\ngoal (47 subgoals):\n 1. \\<And>h E C l. new_Addr h = None \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>E e a b aa Cs ab ba C Cs' Ds.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 3. \\<And>E e a b aa Cs C Cs' ab ba.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs @ [C] @ Cs'),\n                                  (ab, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 4. \\<And>E e a b aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>null,(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 5. \\<And>E e a b aa Cs ab ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*;\n        C \\<notin> set Cs\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 6. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>throw e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 7. \\<And>E e a b aa Cs ab ba C Cs' Ds.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; P \\<turnstile> Path last Cs to C unique;\n        P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 8. \\<And>E e a b aa Cs C Cs' ab ba.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs @ [C] @ Cs'),\n                                  (ab, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 9. \\<And>E e a b aa Cs h l D S C Cs'.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(h, l)\\<rangle>;\n        a \\<unlhd> h; h aa = \\<lfloor>(D, S)\\<rfloor>;\n        P \\<turnstile> Path D to C via Cs' ;\n        P \\<turnstile> Path D to C unique\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 10. \\<And>E e a b aa ba C.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                  \\<langle>null,(aa, ba)\\<rangle>;\n         a \\<unlhd> aa\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> aa\nA total of 47 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  P,E_ \\<turnstile> \\<langle>e\\<^sub>1_,(a___, b___)\\<rangle> \\<Rightarrow>\n                    \\<langle>ref (aa___, Cs'_),(a_, b_)\\<rangle>\n  a___ \\<unlhd> a_\n  P,E_ \\<turnstile> \\<langle>e\\<^sub>2_,(a_, b_)\\<rangle> \\<Rightarrow>\n                    \\<langle>Val v_,(h\\<^sub>2_, l\\<^sub>2_)\\<rangle>\n  a_ \\<unlhd> h\\<^sub>2_\n  h\\<^sub>2_ aa___ = \\<lfloor>(D_, S_)\\<rfloor>\n  P \\<turnstile> last Cs'_ has least F_:T_ via Cs_\n  P \\<turnstile> T_ casts v_ to v'_ \n  Ds_ = Cs'_ @\\<^sub>p Cs_\n  (Ds_, fs_) \\<in> S_\n  fs'_ = fs_(F_ \\<mapsto> v'_)\n  S'_ = S_ - {(Ds_, fs_)} \\<union> {(Ds_, fs'_)}\n  h\\<^sub>2'_ = h\\<^sub>2_(aa___ \\<mapsto> (D_, S'_))\n\ngoal (1 subgoal):\n 1. a___ \\<unlhd> h\\<^sub>2'_", "by(auto simp:sym[THEN hext_upd_obj] simp del:fun_upd_apply\n            elim!: hext_trans)"], ["proof (state)\nthis:\n  a___ \\<unlhd> h\\<^sub>2'_\n\ngoal (46 subgoals):\n 1. \\<And>h E C l. new_Addr h = None \\<Longrightarrow> h \\<unlhd> h\n 2. \\<And>E e a b aa Cs ab ba C Cs' Ds.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 3. \\<And>E e a b aa Cs C Cs' ab ba.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs @ [C] @ Cs'),\n                                  (ab, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 4. \\<And>E e a b aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>null,(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 5. \\<And>E e a b aa Cs ab ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; (last Cs, C) \\<notin> (subcls1 P)\\<^sup>*;\n        C \\<notin> set Cs\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 6. \\<And>E e a b e' aa ba C.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>throw e',(aa, ba)\\<rangle>;\n        a \\<unlhd> aa\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> aa\n 7. \\<And>E e a b aa Cs ab ba C Cs' Ds.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(ab, ba)\\<rangle>;\n        a \\<unlhd> ab; P \\<turnstile> Path last Cs to C unique;\n        P \\<turnstile> Path last Cs to C via Cs' ;\n        Ds = Cs @\\<^sub>p Cs'\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 8. \\<And>E e a b aa Cs C Cs' ab ba.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs @ [C] @ Cs'),\n                                  (ab, ba)\\<rangle>;\n        a \\<unlhd> ab\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> ab\n 9. \\<And>E e a b aa Cs h l D S C Cs'.\n       \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                 \\<langle>ref (aa, Cs),(h, l)\\<rangle>;\n        a \\<unlhd> h; h aa = \\<lfloor>(D, S)\\<rfloor>;\n        P \\<turnstile> Path D to C via Cs' ;\n        P \\<turnstile> Path D to C unique\\<rbrakk>\n       \\<Longrightarrow> a \\<unlhd> h\n 10. \\<And>E e a b aa ba C.\n        \\<lbrakk>P,E \\<turnstile> \\<langle>e,(a, b)\\<rangle> \\<Rightarrow>\n                                  \\<langle>null,(aa, ba)\\<rangle>;\n         a \\<unlhd> aa\\<rbrakk>\n        \\<Longrightarrow> a \\<unlhd> aa\nA total of 46 subgoals...", "qed (auto elim!: hext_trans)"], ["", "subsection \\<open>\\<open>\\<unlhd>\\<close> and conformance\\<close>"], ["", "lemma conf_hext: \"h \\<unlhd> h' \\<Longrightarrow> P,h \\<turnstile> v :\\<le> T \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h'; P,h \\<turnstile> v :\\<le> T\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> v :\\<le> T", "by(cases T)(induct v,auto dest: hext_objD split:if_split_asm)+"], ["", "lemma confs_hext: \"P,h \\<turnstile> vs [:\\<le>] Ts \\<Longrightarrow> h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> vs [:\\<le>] Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> vs [:\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> vs [:\\<le>] Ts", "by (erule list_all2_mono, erule conf_hext, assumption)"], ["", "lemma fconf_hext: \"\\<lbrakk> P,h \\<turnstile> fs (:\\<le>) E; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> fs (:\\<le>) E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> fs (:\\<le>) E; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> fs (:\\<le>) E", "apply (unfold fconf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>FD T.\n                E FD = \\<lfloor>T\\<rfloor> \\<longrightarrow>\n                (\\<exists>v.\n                    fs FD = \\<lfloor>v\\<rfloor> \\<and>\n                    P,h \\<turnstile> v :\\<le> T);\n     h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>FD T.\n                         E FD = \\<lfloor>T\\<rfloor> \\<longrightarrow>\n                         (\\<exists>v.\n                             fs FD = \\<lfloor>v\\<rfloor> \\<and>\n                             P,h' \\<turnstile> v :\\<le> T)", "apply  (fast elim: conf_hext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas fconf_upd_obj = fconf_hext [OF _ hext_upd_obj]"], ["", "lemmas fconf_new = fconf_hext [OF _ hext_new]"], ["", "lemma oconf_hext: \"P,h \\<turnstile> obj \\<surd> \\<Longrightarrow> h \\<unlhd> h' \\<Longrightarrow> P,h' \\<turnstile> obj \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> obj \\<surd>; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> obj \\<surd>", "apply (auto simp:oconf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C S Cs fs'.\n       \\<lbrakk>h \\<unlhd> h'; obj = (C, S);\n        \\<forall>Cs.\n           Subobjs P C Cs \\<longrightarrow>\n           (\\<exists>!fs'. (Cs, fs') \\<in> S);\n        \\<forall>Cs fs'.\n           (Cs, fs') \\<in> S \\<longrightarrow>\n           Subobjs P C Cs \\<and>\n           (\\<exists>fs.\n               (\\<exists>Bs ms.\n                   class P (last Cs) =\n                   \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n               P,h \\<turnstile> fs' (:\\<le>) map_of fs);\n        (Cs, fs') \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h' \\<turnstile> fs' (:\\<le>) map_of fs", "apply (erule allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C S Cs fs'.\n       \\<lbrakk>h \\<unlhd> h'; obj = (C, S);\n        \\<forall>Cs fs'.\n           (Cs, fs') \\<in> S \\<longrightarrow>\n           Subobjs P C Cs \\<and>\n           (\\<exists>fs.\n               (\\<exists>Bs ms.\n                   class P (last Cs) =\n                   \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n               P,h \\<turnstile> fs' (:\\<le>) map_of fs);\n        (Cs, fs') \\<in> S;\n        Subobjs P C (?Cs14 C S Cs fs') \\<longrightarrow>\n        (\\<exists>!fs'a. (?Cs14 C S Cs fs', fs'a) \\<in> S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h' \\<turnstile> fs' (:\\<le>) map_of fs", "apply (erule_tac x=\"Cs\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C S Cs fs'.\n       \\<lbrakk>h \\<unlhd> h'; obj = (C, S); (Cs, fs') \\<in> S;\n        Subobjs P C (?Cs14 C S Cs fs') \\<longrightarrow>\n        (\\<exists>!fs'a. (?Cs14 C S Cs fs', fs'a) \\<in> S);\n        \\<forall>fs'.\n           (Cs, fs') \\<in> S \\<longrightarrow>\n           Subobjs P C Cs \\<and>\n           (\\<exists>fs.\n               (\\<exists>Bs ms.\n                   class P (last Cs) =\n                   \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n               P,h \\<turnstile> fs' (:\\<le>) map_of fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h' \\<turnstile> fs' (:\\<le>) map_of fs", "apply (erule_tac x=\"fs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C S Cs fs'.\n       \\<lbrakk>h \\<unlhd> h'; obj = (C, S); (Cs, fs') \\<in> S;\n        Subobjs P C (?Cs14 C S Cs fs') \\<longrightarrow>\n        (\\<exists>!fs'a. (?Cs14 C S Cs fs', fs'a) \\<in> S);\n        (Cs, fs') \\<in> S \\<longrightarrow>\n        Subobjs P C Cs \\<and>\n        (\\<exists>fs.\n            (\\<exists>Bs ms.\n                class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n            P,h \\<turnstile> fs' (:\\<le>) map_of fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h' \\<turnstile> fs' (:\\<le>) map_of fs", "apply (fastforce elim:fconf_hext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas oconf_new = oconf_hext [OF _ hext_new]"], ["", "lemmas oconf_upd_obj = oconf_hext [OF _ hext_upd_obj]"], ["", "lemma hconf_new: \"\\<lbrakk> P \\<turnstile> h \\<surd>; h a = None; P,h \\<turnstile> obj \\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile> h(a\\<mapsto>obj) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> h \\<surd>; h a = None;\n     P,h \\<turnstile> obj \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> h(a \\<mapsto> obj) \\<surd>", "by (unfold hconf_def) (auto intro: oconf_new preallocated_new)"], ["", "lemma \"\\<lbrakk>P \\<turnstile> h \\<surd>; h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None; wf_prog wf_md P\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> h' \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> h \\<surd>;\n     h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> h' \\<surd>", "apply (simp add:hconf_def oconf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>a aa b.\n                 h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n                 (\\<forall>Cs.\n                     Subobjs P aa Cs \\<longrightarrow>\n                     (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n                 (\\<forall>Cs fs'.\n                     (Cs, fs') \\<in> b \\<longrightarrow>\n                     Subobjs P aa Cs \\<and>\n                     (\\<exists>fs.\n                         (\\<exists>Bs ms.\n                             class P (last Cs) =\n                             \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                         P,h \\<turnstile> fs' (:\\<le>) map_of fs))) \\<and>\n             preallocated h;\n     h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>aa.\n                          (aa = a \\<longrightarrow>\n                           (\\<forall>Cs.\n                               Subobjs P C Cs \\<longrightarrow>\n                               (\\<exists>!fs'.\n                                   init_obj P C (Cs, fs'))) \\<and>\n                           (\\<forall>Cs fs'.\n                               init_obj P C (Cs, fs') \\<longrightarrow>\n                               Subobjs P C Cs \\<and>\n                               (\\<exists>fs.\n                                   (\\<exists>Bs ms.\n class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                                   P,h(a \\<mapsto>\n                                   (C, Collect\n  (init_obj P C))) \\<turnstile> fs' (:\\<le>) map_of fs))) \\<and>\n                          (aa \\<noteq> a \\<longrightarrow>\n                           (\\<forall>ab b.\n                               h aa =\n                               \\<lfloor>(ab, b)\\<rfloor> \\<longrightarrow>\n                               (\\<forall>Cs fs'.\n                                   (Cs, fs') \\<in> b \\<longrightarrow>\n                                   (\\<exists>fs.\n (\\<exists>Bs ms. class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n P,h(a \\<mapsto>\n (C, Collect\n      (init_obj P C))) \\<turnstile> fs' (:\\<le>) map_of fs))))) \\<and>\n                      preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; Subobjs P C Cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs'. init_obj P C (Cs, fs')\n 2. \\<And>Cs fs' y.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; Subobjs P C Cs; init_obj P C (Cs, fs');\n        init_obj P C (Cs, y)\\<rbrakk>\n       \\<Longrightarrow> fs' = y\n 3. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Cs\n 4. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 5. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 6. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (rule_tac x=\"init_class_fieldmap P (last Cs)\" in exI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; Subobjs P C Cs\\<rbrakk>\n       \\<Longrightarrow> init_obj P C (Cs, init_class_fieldmap P (last Cs))\n 2. \\<And>Cs fs' y.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; Subobjs P C Cs; init_obj P C (Cs, fs');\n        init_obj P C (Cs, y)\\<rbrakk>\n       \\<Longrightarrow> fs' = y\n 3. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Cs\n 4. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 5. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 6. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (rule init_obj.intros)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; Subobjs P C Cs\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Cs\n 2. \\<And>Cs fs' y.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; Subobjs P C Cs; init_obj P C (Cs, fs');\n        init_obj P C (Cs, y)\\<rbrakk>\n       \\<Longrightarrow> fs' = y\n 3. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Cs\n 4. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 5. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 6. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply assumption"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Cs fs' y.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; Subobjs P C Cs; init_obj P C (Cs, fs');\n        init_obj P C (Cs, y)\\<rbrakk>\n       \\<Longrightarrow> fs' = y\n 2. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Cs\n 3. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 4. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 5. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (erule init_obj.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Cs fs' y Csa.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; Subobjs P C Cs; init_obj P C (Cs, y);\n        (Cs, fs') = (Csa, init_class_fieldmap P (last Csa));\n        Subobjs P C Csa\\<rbrakk>\n       \\<Longrightarrow> fs' = y\n 2. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Cs\n 3. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 4. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 5. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Cs y.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, y); Subobjs P C Cs\\<rbrakk>\n       \\<Longrightarrow> init_class_fieldmap P (last Cs) = y\n 2. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Cs\n 3. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 4. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 5. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (erule init_obj.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Cs y Csa.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; Subobjs P C Cs;\n        (Cs, y) = (Csa, init_class_fieldmap P (last Csa));\n        Subobjs P C Csa\\<rbrakk>\n       \\<Longrightarrow> init_class_fieldmap P (last Cs) = y\n 2. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Cs\n 3. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 4. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 5. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Cs\n 2. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 3. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 4. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (erule_tac x=\"a\" in allE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; init_obj P C (Cs, fs');\n        \\<forall>aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Cs\n 2. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 3. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 4. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Cs\n 2. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 3. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 4. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (erule init_obj.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Cs fs' Csa.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h;\n        (Cs, fs') = (Csa, init_class_fieldmap P (last Csa));\n        Subobjs P C Csa\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Cs\n 2. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 3. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 4. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 2. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 3. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (erule_tac x=\"a\" in allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; init_obj P C (Cs, fs');\n        \\<forall>aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 2. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 3. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; init_obj P C (Cs, fs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 2. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 3. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (erule init_obj.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Cs fs' Csa.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h;\n        (Cs, fs') = (Csa, init_class_fieldmap P (last Csa));\n        Subobjs P C Csa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 2. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 3. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; Subobjs P C Cs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> init_class_fieldmap P\n                (last Cs) (:\\<le>) map_of fs\n 2. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 3. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (drule Subobj_last_isClass)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        preallocated h; Subobjs P C Cs\\<rbrakk>\n       \\<Longrightarrow> Subobjs P (?C76 Cs) (?Cs76 Cs)\n 2. \\<And>Cs.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        preallocated h; Subobjs P C Cs;\n        is_class P (last (?Cs76 Cs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> init_class_fieldmap P\n                (last Cs) (:\\<le>) map_of fs\n 3. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 4. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Cs.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        preallocated h; Subobjs P C Cs; is_class P (last Cs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> init_class_fieldmap P\n                (last Cs) (:\\<le>) map_of fs\n 2. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 3. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (auto simp:is_class_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Cs aa aaa b.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        preallocated h; Subobjs P C Cs;\n        class P (last Cs) = \\<lfloor>(aa, aaa, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,h(a \\<mapsto>\n                         (C, Collect\n                              (init_obj P\n                                C))) \\<turnstile> init_class_fieldmap P\n             (last Cs) (:\\<le>) map_of aaa\n 2. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 3. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (rule fconf_init_fields)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Cs aa aaa b.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        preallocated h; Subobjs P C Cs;\n        class P (last Cs) = \\<lfloor>(aa, aaa, b)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> class P (last Cs) =\n                         \\<lfloor>(?Bs82 Cs aa aaa b, aaa,\n                                   ?ms82 Cs aa aaa b)\\<rfloor>\n 2. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 3. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P;\n        \\<forall>a aa b.\n           h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n        preallocated h; aa \\<noteq> a; h aa = \\<lfloor>(aaa, b)\\<rfloor>;\n        (Cs, fs') \\<in> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 2. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (erule_tac x=\"aa\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; aa \\<noteq> a;\n        h aa = \\<lfloor>(aaa, b)\\<rfloor>; (Cs, fs') \\<in> b;\n        \\<forall>a b.\n           h aa = \\<lfloor>(a, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P a Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P a Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 2. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (erule_tac x=\"aaa\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; aa \\<noteq> a;\n        h aa = \\<lfloor>(aaa, b)\\<rfloor>; (Cs, fs') \\<in> b;\n        \\<forall>b.\n           h aa = \\<lfloor>(aaa, b)\\<rfloor> \\<longrightarrow>\n           (\\<forall>Cs.\n               Subobjs P aaa Cs \\<longrightarrow>\n               (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n           (\\<forall>Cs fs'.\n               (Cs, fs') \\<in> b \\<longrightarrow>\n               Subobjs P aaa Cs \\<and>\n               (\\<exists>fs.\n                   (\\<exists>Bs ms.\n                       class P (last Cs) =\n                       \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                   P,h \\<turnstile> fs' (:\\<le>) map_of fs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 2. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (erule_tac x=\"b\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; aa \\<noteq> a;\n        h aa = \\<lfloor>(aaa, b)\\<rfloor>; (Cs, fs') \\<in> b;\n        h aa = \\<lfloor>(aaa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aaa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aaa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 2. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; aa \\<noteq> a;\n        h aa = \\<lfloor>(aaa, b)\\<rfloor>; (Cs, fs') \\<in> b;\n        \\<forall>Cs.\n           Subobjs P aaa Cs \\<longrightarrow>\n           (\\<exists>!fs'. (Cs, fs') \\<in> b);\n        \\<forall>Cs fs'.\n           (Cs, fs') \\<in> b \\<longrightarrow>\n           Subobjs P aaa Cs \\<and>\n           (\\<exists>fs.\n               (\\<exists>Bs ms.\n                   class P (last Cs) =\n                   \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n               P,h \\<turnstile> fs' (:\\<le>) map_of fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 2. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>\\<forall>Cs fs'.\n                   (Cs, fs') \\<in> b \\<longrightarrow>\n                   Subobjs P aaa Cs \\<and>\n                   (\\<exists>fs.\n                       (\\<exists>Bs ms.\n                           class P (last Cs) =\n                           \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                       P,h \\<turnstile> fs' (:\\<le>) map_of fs);\n        h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; aa \\<noteq> a;\n        h aa = \\<lfloor>(aaa, b)\\<rfloor>; (Cs, fs') \\<in> b;\n        \\<forall>Cs.\n           Subobjs P aaa Cs \\<longrightarrow>\n           (\\<exists>!fs'. (Cs, fs') \\<in> b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 2. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (erule_tac x=\"Cs\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; aa \\<noteq> a;\n        h aa = \\<lfloor>(aaa, b)\\<rfloor>; (Cs, fs') \\<in> b;\n        \\<forall>Cs.\n           Subobjs P aaa Cs \\<longrightarrow>\n           (\\<exists>!fs'. (Cs, fs') \\<in> b);\n        \\<forall>fs'.\n           (Cs, fs') \\<in> b \\<longrightarrow>\n           Subobjs P aaa Cs \\<and>\n           (\\<exists>fs.\n               (\\<exists>Bs ms.\n                   class P (last Cs) =\n                   \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n               P,h \\<turnstile> fs' (:\\<le>) map_of fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 2. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (erule_tac x=\"fs'\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa b Cs fs'.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; aa \\<noteq> a;\n        h aa = \\<lfloor>(aaa, b)\\<rfloor>; (Cs, fs') \\<in> b;\n        \\<forall>Cs.\n           Subobjs P aaa Cs \\<longrightarrow>\n           (\\<exists>!fs'. (Cs, fs') \\<in> b);\n        (Cs, fs') \\<in> b \\<longrightarrow>\n        Subobjs P aaa Cs \\<and>\n        (\\<exists>fs.\n            (\\<exists>Bs ms.\n                class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n            P,h \\<turnstile> fs' (:\\<le>) map_of fs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fs.\n                            (\\<exists>Bs ms.\n                                class P (last Cs) =\n                                \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                            P,h(a \\<mapsto>\n                            (C, Collect\n                                 (init_obj P\n                                   C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 2. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa b Cs fs' fs Bs ms.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; aa \\<noteq> a;\n        h aa = \\<lfloor>(aaa, b)\\<rfloor>; (Cs, fs') \\<in> b;\n        \\<forall>Cs.\n           Subobjs P aaa Cs \\<longrightarrow>\n           (\\<exists>!fs'. (Cs, fs') \\<in> b);\n        Subobjs P aaa Cs; P,h \\<turnstile> fs' (:\\<le>) map_of fs;\n        class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,h(a \\<mapsto>\n                         (C, Collect\n                              (init_obj P\n                                C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 2. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "thm fconf_new"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa b Cs fs' fs Bs ms.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; aa \\<noteq> a;\n        h aa = \\<lfloor>(aaa, b)\\<rfloor>; (Cs, fs') \\<in> b;\n        \\<forall>Cs.\n           Subobjs P aaa Cs \\<longrightarrow>\n           (\\<exists>!fs'. (Cs, fs') \\<in> b);\n        Subobjs P aaa Cs; P,h \\<turnstile> fs' (:\\<le>) map_of fs;\n        class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P,h(a \\<mapsto>\n                         (C, Collect\n                              (init_obj P\n                                C))) \\<turnstile> fs' (:\\<le>) map_of fs\n 2. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (erule fconf_new)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa aaa b Cs fs' fs Bs ms.\n       \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n        wf_prog wf_md P; preallocated h; aa \\<noteq> a;\n        h aa = \\<lfloor>(aaa, b)\\<rfloor>; (Cs, fs') \\<in> b;\n        \\<forall>Cs.\n           Subobjs P aaa Cs \\<longrightarrow>\n           (\\<exists>!fs'. (Cs, fs') \\<in> b);\n        Subobjs P aaa Cs;\n        class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> h a = None\n 2. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated\n                       (h(a \\<mapsto> (C, Collect (init_obj P C))))", "apply (rule preallocated_new)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> preallocated h\n 2. \\<lbrakk>h' = h(a \\<mapsto> (C, Collect (init_obj P C))); h a = None;\n     wf_prog wf_md P;\n     \\<forall>a aa b.\n        h a = \\<lfloor>(aa, b)\\<rfloor> \\<longrightarrow>\n        (\\<forall>Cs.\n            Subobjs P aa Cs \\<longrightarrow>\n            (\\<exists>!fs'. (Cs, fs') \\<in> b)) \\<and>\n        (\\<forall>Cs fs'.\n            (Cs, fs') \\<in> b \\<longrightarrow>\n            Subobjs P aa Cs \\<and>\n            (\\<exists>fs.\n                (\\<exists>Bs ms.\n                    class P (last Cs) =\n                    \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                P,h \\<turnstile> fs' (:\\<le>) map_of fs));\n     preallocated h\\<rbrakk>\n    \\<Longrightarrow> h a = None", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hconf_upd_obj: \n\"\\<lbrakk> P \\<turnstile> h\\<surd>; h a = Some(C,S); P,h \\<turnstile> (C,S')\\<surd> \\<rbrakk> \\<Longrightarrow> P \\<turnstile> h(a\\<mapsto>(C,S'))\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> h \\<surd>; h a = \\<lfloor>(C, S)\\<rfloor>;\n     P,h \\<turnstile> (C, S') \\<surd>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> h(a \\<mapsto> (C, S')) \\<surd>", "by (unfold hconf_def) (auto intro: oconf_upd_obj preallocated_upd_obj)"], ["", "lemma lconf_hext: \"\\<lbrakk> P,h \\<turnstile> l (:\\<le>)\\<^sub>w E; h \\<unlhd> h' \\<rbrakk> \\<Longrightarrow> P,h' \\<turnstile> l (:\\<le>)\\<^sub>w E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,h \\<turnstile> l (:\\<le>)\\<^sub>w E; h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> P,h' \\<turnstile> l (:\\<le>)\\<^sub>w E", "apply (unfold lconf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>V v.\n                l V = \\<lfloor>v\\<rfloor> \\<longrightarrow>\n                (\\<exists>T.\n                    E V = \\<lfloor>T\\<rfloor> \\<and>\n                    P,h \\<turnstile> v :\\<le> T);\n     h \\<unlhd> h'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>V v.\n                         l V = \\<lfloor>v\\<rfloor> \\<longrightarrow>\n                         (\\<exists>T.\n                             E V = \\<lfloor>T\\<rfloor> \\<and>\n                             P,h' \\<turnstile> v :\\<le> T)", "apply  (fast elim: conf_hext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>\\<open>\\<unlhd>\\<close> in the runtime type system\\<close>"], ["", "lemma hext_typeof_mono: \"\\<lbrakk> h \\<unlhd> h'; P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = Some T \\<rbrakk> \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v = Some T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<unlhd> h';\n     P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                      \\<lfloor>T\\<rfloor>", "apply(cases v)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>h \\<unlhd> h';\n     P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n     v = Unit\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                      \\<lfloor>T\\<rfloor>\n 2. \\<lbrakk>h \\<unlhd> h';\n     P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n     v = Null\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                      \\<lfloor>T\\<rfloor>\n 3. \\<And>x3.\n       \\<lbrakk>h \\<unlhd> h';\n        P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Bool x3\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                         \\<lfloor>T\\<rfloor>\n 4. \\<And>x4.\n       \\<lbrakk>h \\<unlhd> h';\n        P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Intg x4\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                         \\<lfloor>T\\<rfloor>\n 5. \\<And>x5.\n       \\<lbrakk>h \\<unlhd> h';\n        P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Ref x5\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                         \\<lfloor>T\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>h \\<unlhd> h';\n     P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n     v = Null\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                      \\<lfloor>T\\<rfloor>\n 2. \\<And>x3.\n       \\<lbrakk>h \\<unlhd> h';\n        P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Bool x3\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                         \\<lfloor>T\\<rfloor>\n 3. \\<And>x4.\n       \\<lbrakk>h \\<unlhd> h';\n        P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Intg x4\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                         \\<lfloor>T\\<rfloor>\n 4. \\<And>x5.\n       \\<lbrakk>h \\<unlhd> h';\n        P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Ref x5\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                         \\<lfloor>T\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>h \\<unlhd> h';\n        P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Bool x3\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                         \\<lfloor>T\\<rfloor>\n 2. \\<And>x4.\n       \\<lbrakk>h \\<unlhd> h';\n        P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Intg x4\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                         \\<lfloor>T\\<rfloor>\n 3. \\<And>x5.\n       \\<lbrakk>h \\<unlhd> h';\n        P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Ref x5\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                         \\<lfloor>T\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x4.\n       \\<lbrakk>h \\<unlhd> h';\n        P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Intg x4\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                         \\<lfloor>T\\<rfloor>\n 2. \\<And>x5.\n       \\<lbrakk>h \\<unlhd> h';\n        P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Ref x5\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                         \\<lfloor>T\\<rfloor>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x5.\n       \\<lbrakk>h \\<unlhd> h';\n        P \\<turnstile> typeof\\<^bsub>h\\<^esub> v = \\<lfloor>T\\<rfloor>;\n        v = Ref x5\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> typeof\\<^bsub>h'\\<^esub> v =\n                         \\<lfloor>T\\<rfloor>", "apply(fastforce simp:hext_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WTrt_hext_mono: \"P,E,h \\<turnstile> e : T \\<Longrightarrow> (\\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T)\"\nand WTrts_hext_mono: \"P,E,h \\<turnstile> es [:] Ts \\<Longrightarrow> (\\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,E,h \\<turnstile> e : T \\<Longrightarrow>\n     (\\<And>h'.\n         h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T)) &&&\n    (P,E,h \\<turnstile> es [:] Ts \\<Longrightarrow>\n     (\\<And>h'.\n         h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts))", "apply(induct rule: WTrt_inducts)"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>C E h h'.\n       \\<lbrakk>is_class P C; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> new C : Class C\n 2. \\<And>E h e T C h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n        is_refT T; is_class P C; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Cast C e : Class C\n 3. \\<And>E h e T C h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n        is_refT T; is_class P C; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> \\<lparr>C\\<rparr>e : Class C\n 4. \\<And>h v T E h'.\n       \\<lbrakk>P \\<turnstile> typeof\\<^bsub>h\\<^esub> v =\n                \\<lfloor>T\\<rfloor>;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Val v : T\n 5. \\<And>E V T h h'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Var V : T\n 6. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        case bop of Eq \\<Rightarrow> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 7. \\<And>E V T h e T' h'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> V:=e : T\n 8. \\<And>E h e C Cs F T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 9. \\<And>E h e F Cs T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 10. \\<And>E h e\\<^sub>1 C Cs F T e\\<^sub>2 T' h'.\n        \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : Class C;\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow>\n            P,E,h' \\<turnstile> e\\<^sub>1 : Class C;\n         Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n         P,E,h \\<turnstile> e\\<^sub>2 : T';\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow>\n            P,E,h' \\<turnstile> e\\<^sub>2 : T';\n         P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n        \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\nA total of 21 subgoals...", "apply(simp add: WTrtNew)"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>E h e T C h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n        is_refT T; is_class P C; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Cast C e : Class C\n 2. \\<And>E h e T C h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n        is_refT T; is_class P C; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> \\<lparr>C\\<rparr>e : Class C\n 3. \\<And>h v T E h'.\n       \\<lbrakk>P \\<turnstile> typeof\\<^bsub>h\\<^esub> v =\n                \\<lfloor>T\\<rfloor>;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Val v : T\n 4. \\<And>E V T h h'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Var V : T\n 5. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        case bop of Eq \\<Rightarrow> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 6. \\<And>E V T h e T' h'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> V:=e : T\n 7. \\<And>E h e C Cs F T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 8. \\<And>E h e F Cs T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 9. \\<And>E h e\\<^sub>1 C Cs F T e\\<^sub>2 T' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 10. \\<And>E h e\\<^sub>1 e\\<^sub>2 T' T F Cs h'.\n        \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : NT;\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow>\n            P,E,h' \\<turnstile> e\\<^sub>1 : NT;\n         P,E,h \\<turnstile> e\\<^sub>2 : T';\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow>\n            P,E,h' \\<turnstile> e\\<^sub>2 : T';\n         P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n        \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\nA total of 20 subgoals...", "apply(fastforce intro: WTrtDynCast)"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>E h e T C h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n        is_refT T; is_class P C; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> \\<lparr>C\\<rparr>e : Class C\n 2. \\<And>h v T E h'.\n       \\<lbrakk>P \\<turnstile> typeof\\<^bsub>h\\<^esub> v =\n                \\<lfloor>T\\<rfloor>;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Val v : T\n 3. \\<And>E V T h h'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Var V : T\n 4. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        case bop of Eq \\<Rightarrow> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 5. \\<And>E V T h e T' h'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> V:=e : T\n 6. \\<And>E h e C Cs F T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 7. \\<And>E h e F Cs T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 8. \\<And>E h e\\<^sub>1 C Cs F T e\\<^sub>2 T' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 9. \\<And>E h e\\<^sub>1 e\\<^sub>2 T' T F Cs h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : NT;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 10. \\<And>E h e C M Ts T a b Cs es Ts' h'.\n        \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n         P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n         P,E,h \\<turnstile> es [:] Ts';\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n         P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n        \\<Longrightarrow> P,E,h' \\<turnstile> Call e None M es : T\nA total of 19 subgoals...", "apply(fastforce intro: WTrtStaticCast)"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>h v T E h'.\n       \\<lbrakk>P \\<turnstile> typeof\\<^bsub>h\\<^esub> v =\n                \\<lfloor>T\\<rfloor>;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Val v : T\n 2. \\<And>E V T h h'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Var V : T\n 3. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        case bop of Eq \\<Rightarrow> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 4. \\<And>E V T h e T' h'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> V:=e : T\n 5. \\<And>E h e C Cs F T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 6. \\<And>E h e F Cs T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 7. \\<And>E h e\\<^sub>1 C Cs F T e\\<^sub>2 T' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 8. \\<And>E h e\\<^sub>1 e\\<^sub>2 T' T F Cs h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : NT;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 9. \\<And>E h e C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e None M es : T\n 10. \\<And>E h e C' C M Ts T a b Cs es Ts' h'.\n        \\<lbrakk>P,E,h \\<turnstile> e : Class C';\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow>\n            P,E,h' \\<turnstile> e : Class C';\n         P \\<turnstile> Path C' to C unique;\n         P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n         P,E,h \\<turnstile> es [:] Ts';\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n         P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n        \\<Longrightarrow> P,E,h' \\<turnstile> Call e \\<lfloor>C\\<rfloor> M\n         es : T\nA total of 18 subgoals...", "apply(fastforce simp: WTrtVal dest:hext_typeof_mono)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>E V T h h'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Var V : T\n 2. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        case bop of Eq \\<Rightarrow> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 3. \\<And>E V T h e T' h'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> V:=e : T\n 4. \\<And>E h e C Cs F T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 5. \\<And>E h e F Cs T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 6. \\<And>E h e\\<^sub>1 C Cs F T e\\<^sub>2 T' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 7. \\<And>E h e\\<^sub>1 e\\<^sub>2 T' T F Cs h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : NT;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 8. \\<And>E h e C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e None M es : T\n 9. \\<And>E h e C' C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e \\<lfloor>C\\<rfloor> M\n        es : T\n 10. \\<And>E h e es Ts Copt M T h'.\n        \\<lbrakk>P,E,h \\<turnstile> e : NT;\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n         P,E,h \\<turnstile> es [:] Ts;\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n         h \\<unlhd> h'\\<rbrakk>\n        \\<Longrightarrow> P,E,h' \\<turnstile> Call e Copt M es : T\nA total of 17 subgoals...", "apply(simp add: WTrtVar)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        case bop of Eq \\<Rightarrow> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 : T\n 2. \\<And>E V T h e T' h'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> V:=e : T\n 3. \\<And>E h e C Cs F T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 4. \\<And>E h e F Cs T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 5. \\<And>E h e\\<^sub>1 C Cs F T e\\<^sub>2 T' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 6. \\<And>E h e\\<^sub>1 e\\<^sub>2 T' T F Cs h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : NT;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 7. \\<And>E h e C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e None M es : T\n 8. \\<And>E h e C' C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e \\<lfloor>C\\<rfloor> M\n        es : T\n 9. \\<And>E h e es Ts Copt M T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e Copt M es : T\n 10. \\<And>E V T h e T' h'.\n        \\<lbrakk>P,E(V \\<mapsto> T),h \\<turnstile> e : T';\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow>\n            P,E(V \\<mapsto> T),h' \\<turnstile> e : T';\n         is_type P T; h \\<unlhd> h'\\<rbrakk>\n        \\<Longrightarrow> P,E,h' \\<turnstile> {V:T; e} : T'\nA total of 16 subgoals...", "apply(fastforce simp add: WTrtBinOp)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>E V T h e T' h'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> V:=e : T\n 2. \\<And>E h e C Cs F T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 3. \\<And>E h e F Cs T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 4. \\<And>E h e\\<^sub>1 C Cs F T e\\<^sub>2 T' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 5. \\<And>E h e\\<^sub>1 e\\<^sub>2 T' T F Cs h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : NT;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 6. \\<And>E h e C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e None M es : T\n 7. \\<And>E h e C' C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e \\<lfloor>C\\<rfloor> M\n        es : T\n 8. \\<And>E h e es Ts Copt M T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e Copt M es : T\n 9. \\<And>E V T h e T' h'.\n       \\<lbrakk>P,E(V \\<mapsto> T),h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E(V \\<mapsto> T),h' \\<turnstile> e : T';\n        is_type P T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> {V:T; e} : T'\n 10. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 h'.\n        \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow>\n            P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n         P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow>\n            P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n         h \\<unlhd> h'\\<rbrakk>\n        \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1;;\n                          e\\<^sub>2 : T\\<^sub>2\nA total of 15 subgoals...", "apply(fastforce simp add: WTrtLAss)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>E h e C Cs F T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 2. \\<And>E h e F Cs T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 3. \\<And>E h e\\<^sub>1 C Cs F T e\\<^sub>2 T' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 4. \\<And>E h e\\<^sub>1 e\\<^sub>2 T' T F Cs h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : NT;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 5. \\<And>E h e C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e None M es : T\n 6. \\<And>E h e C' C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e \\<lfloor>C\\<rfloor> M\n        es : T\n 7. \\<And>E h e es Ts Copt M T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e Copt M es : T\n 8. \\<And>E V T h e T' h'.\n       \\<lbrakk>P,E(V \\<mapsto> T),h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E(V \\<mapsto> T),h' \\<turnstile> e : T';\n        is_type P T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> {V:T; e} : T'\n 9. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 10. \\<And>E h e e\\<^sub>1 T e\\<^sub>2 h'.\n        \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n         P,E,h \\<turnstile> e\\<^sub>1 : T;\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow>\n            P,E,h' \\<turnstile> e\\<^sub>1 : T;\n         P,E,h \\<turnstile> e\\<^sub>2 : T;\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow>\n            P,E,h' \\<turnstile> e\\<^sub>2 : T;\n         h \\<unlhd> h'\\<rbrakk>\n        \\<Longrightarrow> P,E,h' \\<turnstile> if (e) e\\<^sub>1\n                          else e\\<^sub>2 : T\nA total of 14 subgoals...", "apply(fastforce simp: WTrtFAcc del:WTrt_WTrts.intros WTrt_elim_cases)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>E h e F Cs T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<bullet>F{Cs} : T\n 2. \\<And>E h e\\<^sub>1 C Cs F T e\\<^sub>2 T' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 3. \\<And>E h e\\<^sub>1 e\\<^sub>2 T' T F Cs h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : NT;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 4. \\<And>E h e C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e None M es : T\n 5. \\<And>E h e C' C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e \\<lfloor>C\\<rfloor> M\n        es : T\n 6. \\<And>E h e es Ts Copt M T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e Copt M es : T\n 7. \\<And>E V T h e T' h'.\n       \\<lbrakk>P,E(V \\<mapsto> T),h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E(V \\<mapsto> T),h' \\<turnstile> e : T';\n        is_type P T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> {V:T; e} : T'\n 8. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 9. \\<And>E h e e\\<^sub>1 T e\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> e\\<^sub>1 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T;\n        P,E,h \\<turnstile> e\\<^sub>2 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 10. \\<And>E h e c T h'.\n        \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n         P,E,h \\<turnstile> c : T;\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> c : T;\n         h \\<unlhd> h'\\<rbrakk>\n        \\<Longrightarrow> P,E,h' \\<turnstile> while (e) c : Void\nA total of 13 subgoals...", "apply(simp add: WTrtFAccNT)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>E h e\\<^sub>1 C Cs F T e\\<^sub>2 T' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : Class C;\n        Cs \\<noteq> []; P \\<turnstile> C has least F:T via Cs;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 2. \\<And>E h e\\<^sub>1 e\\<^sub>2 T' T F Cs h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : NT;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 3. \\<And>E h e C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e None M es : T\n 4. \\<And>E h e C' C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e \\<lfloor>C\\<rfloor> M\n        es : T\n 5. \\<And>E h e es Ts Copt M T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e Copt M es : T\n 6. \\<And>E V T h e T' h'.\n       \\<lbrakk>P,E(V \\<mapsto> T),h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E(V \\<mapsto> T),h' \\<turnstile> e : T';\n        is_type P T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> {V:T; e} : T'\n 7. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 8. \\<And>E h e e\\<^sub>1 T e\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> e\\<^sub>1 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T;\n        P,E,h \\<turnstile> e\\<^sub>2 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 9. \\<And>E h e c T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> c : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> c : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> while (e) c : Void\n 10. \\<And>E h e T' T h'.\n        \\<lbrakk>P,E,h \\<turnstile> e : T';\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n         is_refT T'; h \\<unlhd> h'\\<rbrakk>\n        \\<Longrightarrow> P,E,h' \\<turnstile> throw e : T\nA total of 12 subgoals...", "apply(fastforce simp: WTrtFAss del:WTrt_WTrts.intros WTrt_elim_cases)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>E h e\\<^sub>1 e\\<^sub>2 T' T F Cs h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : NT;\n        P,E,h \\<turnstile> e\\<^sub>2 : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T';\n        P \\<turnstile> T' \\<le> T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 : T\n 2. \\<And>E h e C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e None M es : T\n 3. \\<And>E h e C' C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e \\<lfloor>C\\<rfloor> M\n        es : T\n 4. \\<And>E h e es Ts Copt M T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e Copt M es : T\n 5. \\<And>E V T h e T' h'.\n       \\<lbrakk>P,E(V \\<mapsto> T),h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E(V \\<mapsto> T),h' \\<turnstile> e : T';\n        is_type P T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> {V:T; e} : T'\n 6. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 7. \\<And>E h e e\\<^sub>1 T e\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> e\\<^sub>1 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T;\n        P,E,h \\<turnstile> e\\<^sub>2 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 8. \\<And>E h e c T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> c : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> c : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> while (e) c : Void\n 9. \\<And>E h e T' T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        is_refT T'; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> throw e : T\n 10. \\<And>E h h'.\n        h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> [] [:] []\nA total of 11 subgoals...", "apply(fastforce simp: WTrtFAssNT del:WTrt_WTrts.intros WTrt_elim_cases)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>E h e C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e None M es : T\n 2. \\<And>E h e C' C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e \\<lfloor>C\\<rfloor> M\n        es : T\n 3. \\<And>E h e es Ts Copt M T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e Copt M es : T\n 4. \\<And>E V T h e T' h'.\n       \\<lbrakk>P,E(V \\<mapsto> T),h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E(V \\<mapsto> T),h' \\<turnstile> e : T';\n        is_type P T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> {V:T; e} : T'\n 5. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 6. \\<And>E h e e\\<^sub>1 T e\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> e\\<^sub>1 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T;\n        P,E,h \\<turnstile> e\\<^sub>2 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 7. \\<And>E h e c T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> c : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> c : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> while (e) c : Void\n 8. \\<And>E h e T' T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        is_refT T'; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> throw e : T\n 9. \\<And>E h h'.\n       h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> [] [:] []\n 10. \\<And>E h e T es Ts h'.\n        \\<lbrakk>P,E,h \\<turnstile> e : T;\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n         P,E,h \\<turnstile> es [:] Ts;\n         \\<And>h'.\n            h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n         h \\<unlhd> h'\\<rbrakk>\n        \\<Longrightarrow> P,E,h' \\<turnstile> e # es [:] T # Ts", "apply(fastforce simp: WTrtCall del:WTrt_WTrts.intros WTrt_elim_cases)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>E h e C' C M Ts T a b Cs es Ts' h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Class C';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Class C';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E,h \\<turnstile> es [:] Ts';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts';\n        P \\<turnstile> Ts' [\\<le>] Ts; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e \\<lfloor>C\\<rfloor> M\n        es : T\n 2. \\<And>E h e es Ts Copt M T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e Copt M es : T\n 3. \\<And>E V T h e T' h'.\n       \\<lbrakk>P,E(V \\<mapsto> T),h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E(V \\<mapsto> T),h' \\<turnstile> e : T';\n        is_type P T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> {V:T; e} : T'\n 4. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 5. \\<And>E h e e\\<^sub>1 T e\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> e\\<^sub>1 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T;\n        P,E,h \\<turnstile> e\\<^sub>2 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 6. \\<And>E h e c T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> c : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> c : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> while (e) c : Void\n 7. \\<And>E h e T' T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        is_refT T'; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> throw e : T\n 8. \\<And>E h h'.\n       h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> [] [:] []\n 9. \\<And>E h e T es Ts h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e # es [:] T # Ts", "apply(fastforce simp: WTrtStaticCall del:WTrt_WTrts.intros WTrt_elim_cases)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>E h e es Ts Copt M T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : NT;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : NT;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> Call e Copt M es : T\n 2. \\<And>E V T h e T' h'.\n       \\<lbrakk>P,E(V \\<mapsto> T),h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E(V \\<mapsto> T),h' \\<turnstile> e : T';\n        is_type P T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> {V:T; e} : T'\n 3. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 4. \\<And>E h e e\\<^sub>1 T e\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> e\\<^sub>1 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T;\n        P,E,h \\<turnstile> e\\<^sub>2 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 5. \\<And>E h e c T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> c : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> c : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> while (e) c : Void\n 6. \\<And>E h e T' T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        is_refT T'; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> throw e : T\n 7. \\<And>E h h'.\n       h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> [] [:] []\n 8. \\<And>E h e T es Ts h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e # es [:] T # Ts", "apply(fastforce simp: WTrtCallNT del:WTrt_WTrts.intros WTrt_elim_cases)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>E V T h e T' h'.\n       \\<lbrakk>P,E(V \\<mapsto> T),h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E(V \\<mapsto> T),h' \\<turnstile> e : T';\n        is_type P T; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> {V:T; e} : T'\n 2. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 3. \\<And>E h e e\\<^sub>1 T e\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> e\\<^sub>1 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T;\n        P,E,h \\<turnstile> e\\<^sub>2 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 4. \\<And>E h e c T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> c : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> c : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> while (e) c : Void\n 5. \\<And>E h e T' T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        is_refT T'; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> throw e : T\n 6. \\<And>E h h'.\n       h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> [] [:] []\n 7. \\<And>E h e T es Ts h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e # es [:] T # Ts", "apply(fastforce)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>E h e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T\\<^sub>1;\n        P,E,h \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T\\<^sub>2;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e\\<^sub>1;;\n                         e\\<^sub>2 : T\\<^sub>2\n 2. \\<And>E h e e\\<^sub>1 T e\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> e\\<^sub>1 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T;\n        P,E,h \\<turnstile> e\\<^sub>2 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 3. \\<And>E h e c T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> c : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> c : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> while (e) c : Void\n 4. \\<And>E h e T' T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        is_refT T'; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> throw e : T\n 5. \\<And>E h h'.\n       h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> [] [:] []\n 6. \\<And>E h e T es Ts h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e # es [:] T # Ts", "apply(fastforce simp add: WTrtSeq)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>E h e e\\<^sub>1 T e\\<^sub>2 h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> e\\<^sub>1 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>1 : T;\n        P,E,h \\<turnstile> e\\<^sub>2 : T;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow>\n           P,E,h' \\<turnstile> e\\<^sub>2 : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> if (e) e\\<^sub>1\n                         else e\\<^sub>2 : T\n 2. \\<And>E h e c T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> c : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> c : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> while (e) c : Void\n 3. \\<And>E h e T' T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        is_refT T'; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> throw e : T\n 4. \\<And>E h h'.\n       h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> [] [:] []\n 5. \\<And>E h e T es Ts h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e # es [:] T # Ts", "apply(fastforce simp add: WTrtCond)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>E h e c T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : Boolean;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : Boolean;\n        P,E,h \\<turnstile> c : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> c : T;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> while (e) c : Void\n 2. \\<And>E h e T' T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        is_refT T'; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> throw e : T\n 3. \\<And>E h h'.\n       h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> [] [:] []\n 4. \\<And>E h e T es Ts h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e # es [:] T # Ts", "apply(fastforce simp add: WTrtWhile)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>E h e T' T h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T';\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T';\n        is_refT T'; h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> throw e : T\n 2. \\<And>E h h'.\n       h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> [] [:] []\n 3. \\<And>E h e T es Ts h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e # es [:] T # Ts", "apply(fastforce simp add: WTrtThrow)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>E h h'.\n       h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> [] [:] []\n 2. \\<And>E h e T es Ts h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e # es [:] T # Ts", "apply(simp add: WTrtNil)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>E h e T es Ts h'.\n       \\<lbrakk>P,E,h \\<turnstile> e : T;\n        \\<And>h'. h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> e : T;\n        P,E,h \\<turnstile> es [:] Ts;\n        \\<And>h'.\n           h \\<unlhd> h' \\<Longrightarrow> P,E,h' \\<turnstile> es [:] Ts;\n        h \\<unlhd> h'\\<rbrakk>\n       \\<Longrightarrow> P,E,h' \\<turnstile> e # es [:] T # Ts", "apply(simp add: WTrtCons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}