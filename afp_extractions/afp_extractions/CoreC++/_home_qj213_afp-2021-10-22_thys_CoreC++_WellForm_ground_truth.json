{"file_name": "/home/qj213/afp-2021-10-22/thys/CoreC++/WellForm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CoreC++", "problem_names": ["lemma class_wf: \n  \"\\<lbrakk>class P C = Some c; wf_prog wf_md P\\<rbrakk> \\<Longrightarrow> wf_cdecl wf_md P (C,c)\"", "lemma is_class_xcpt:\n  \"\\<lbrakk> C \\<in> sys_xcpts; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> is_class P C\"", "lemma is_type_pTs:\nassumes \"wf_prog wf_md P\" and \"(C,S,fs,ms) \\<in> set P\" and \"(M,Ts,T,m) \\<in> set ms\"\nshows \"set Ts \\<subseteq> types P\"", "lemma subcls1_wfD:\n  \"\\<lbrakk> P \\<turnstile> C \\<prec>\\<^sup>1 D; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> D \\<noteq> C \\<and> (D,C) \\<notin> (subcls1 P)\\<^sup>+\"", "lemma wf_cdecl_supD: \n  \"\\<lbrakk>wf_cdecl wf_md P (C,Bs,r); D \\<in> baseClasses Bs\\<rbrakk> \\<Longrightarrow> is_class P D\"", "lemma subcls_asym:\n  \"\\<lbrakk> wf_prog wf_md P; (C,D) \\<in> (subcls1 P)\\<^sup>+ \\<rbrakk> \\<Longrightarrow> (D,C) \\<notin> (subcls1 P)\\<^sup>+\"", "lemma subcls_irrefl:\n  \"\\<lbrakk> wf_prog wf_md P; (C,D) \\<in> (subcls1 P)\\<^sup>+ \\<rbrakk> \\<Longrightarrow> C \\<noteq> D\"", "lemma subcls_asym2:\n  \"\\<lbrakk> (C,D) \\<in> (subcls1 P)\\<^sup>*; wf_prog wf_md P; (D,C) \\<in> (subcls1 P)\\<^sup>* \\<rbrakk> \\<Longrightarrow> C = D\"", "lemma acyclic_subcls1:\n  \"wf_prog wf_md P \\<Longrightarrow> acyclic (subcls1 P)\"", "lemma wf_subcls1:\n  \"wf_prog wf_md P \\<Longrightarrow> wf ((subcls1 P)\\<inverse>)\"", "lemma subcls_induct: \n  \"\\<lbrakk> wf_prog wf_md P; \\<And>C. \\<forall>D. (C,D) \\<in> (subcls1 P)\\<^sup>+ \\<longrightarrow> Q D \\<Longrightarrow> Q C \\<rbrakk> \\<Longrightarrow> Q C\"\n\n  (is \"?A \\<Longrightarrow> PROP ?P \\<Longrightarrow> _\")", "lemma last_leq_path:\nassumes leq:\"P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Ds\" and wf:\"wf_prog wf_md P\"\nshows \"P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds\"", "lemma last_leq_paths:\nassumes leq:\"(Cs,Ds) \\<in> (leq_path1 P C)\\<^sup>+\" and wf:\"wf_prog wf_md P\"\nshows \"(last Cs,last Ds) \\<in> (subcls1 P)\\<^sup>+\"", "lemma leq_path1_wfD:\n\"\\<lbrakk> P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs'; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> Cs \\<noteq> Cs' \\<and> (Cs',Cs) \\<notin> (leq_path1 P C)\\<^sup>+\"", "lemma leq_path_asym:\n\"\\<lbrakk>(Cs,Cs') \\<in> (leq_path1 P C)\\<^sup>+; wf_prog wf_md P\\<rbrakk> \\<Longrightarrow> (Cs',Cs) \\<notin> (leq_path1 P C)\\<^sup>+\"", "lemma leq_path_asym2:\"\\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> Cs'; P,C \\<turnstile> Cs' \\<sqsubseteq> Cs; wf_prog wf_md P\\<rbrakk> \\<Longrightarrow> Cs = Cs'\"", "lemma leq_path_Subobjs:\n\"\\<lbrakk>P,C \\<turnstile> [C] \\<sqsubseteq> Cs; is_class P C; wf_prog wf_md P\\<rbrakk> \\<Longrightarrow> Subobjs P C Cs\"", "lemma Subobj_last_isClass:\"\\<lbrakk>wf_prog wf_md P; Subobjs P C Cs\\<rbrakk> \\<Longrightarrow> is_class P (last Cs)\"", "lemma converse_SubobjsR_Rep:\n  \"\\<lbrakk>Subobjs\\<^sub>R P C Cs; P \\<turnstile> last Cs \\<prec>\\<^sub>R C'; wf_prog wf_md P\\<rbrakk> \n\\<Longrightarrow> Subobjs\\<^sub>R P C (Cs@[C'])\"", "lemma converse_Subobjs_Rep:\n  \"\\<lbrakk>Subobjs P C Cs; P \\<turnstile> last Cs \\<prec>\\<^sub>R C';  wf_prog wf_md P\\<rbrakk> \n\\<Longrightarrow> Subobjs P C (Cs@[C'])\"", "lemma isSubobj_Subobjs_rev:\nassumes subo:\"is_subobj P ((C,C'#rev Cs'))\" and wf:\"wf_prog wf_md P\"\nshows \"Subobjs P C (C'#rev Cs')\"", "lemma isSubobj_Subobjs:\nassumes subo:\"is_subobj P ((C,Cs))\" and wf:\"wf_prog wf_md P\"\nshows \"Subobjs P C Cs\"", "lemma isSubobj_eq_Subobjs:\n  \"wf_prog wf_md P \\<Longrightarrow> is_subobj P ((C,Cs)) = (Subobjs P C Cs)\"", "lemma subo_trans_subcls:\n  assumes subo:\"Subobjs P C (Cs@ C'#rev Cs')\"\n  shows \"\\<forall>C'' \\<in> set Cs'. (C',C'') \\<in> (subcls1 P)\\<^sup>+\"", "lemma unique1:\n  assumes subo:\"Subobjs P C (Cs@ C'#Cs')\" and wf:\"wf_prog wf_md P\"\n  shows \"C' \\<notin> set Cs'\"", "lemma subo_subcls_trans:\n  assumes subo:\"Subobjs P C (Cs@ C'#Cs')\"\n  shows \"\\<forall>C'' \\<in> set Cs. (C'',C') \\<in> (subcls1 P)\\<^sup>+\"", "lemma unique2:\n  assumes subo:\"Subobjs P C (Cs@ C'#Cs')\" and wf:\"wf_prog wf_md P\"\n  shows \"C' \\<notin> set Cs\"", "lemma mdc_hd_path:\nassumes subo:\"Subobjs P C Cs\" and set:\"C \\<in> set Cs\" and wf:\"wf_prog wf_md P\"\nshows \"C = hd Cs\"", "lemma mdc_eq_last:\n  assumes subo:\"Subobjs P C Cs\" and last:\"last Cs = C\" and wf:\"wf_prog wf_md P\"\nshows \"Cs = [C]\"", "lemma assumes leq:\"P \\<turnstile> C \\<preceq>\\<^sup>* D\" and wf:\"wf_prog wf_md P\"\n  shows subcls_leq_path:\"\\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs@[D]\"", "lemma assumes subo:\"Subobjs P C (rev Cs)\" and wf:\"wf_prog wf_md P\"\n  shows subobjs_rel_rev:\"P,C \\<turnstile> [C] \\<sqsubseteq> (rev Cs)\"", "lemma subobjs_rel:\nassumes subo:\"Subobjs P C Cs\" and wf:\"wf_prog wf_md P\"\nshows \"P,C \\<turnstile> [C] \\<sqsubseteq> Cs\"", "lemma assumes wf:\"wf_prog wf_md P\"\n  shows leq_path_last:\"\\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> Cs'; last Cs = last Cs'\\<rbrakk> \\<Longrightarrow> Cs = Cs'\"", "lemma appendPath1:\n  \"\\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds\\<rbrakk>\n\\<Longrightarrow> Subobjs P C Ds\"", "lemma appendPath2_rev:\nassumes subo1:\"Subobjs P C Cs\" and subo2:\"Subobjs P (last Cs) (last Cs#rev Ds)\"\n  and wf:\"wf_prog wf_md P\"\nshows \"Subobjs P C (Cs@(tl (last Cs#rev Ds)))\"", "lemma appendPath2:\nassumes subo1:\"Subobjs P C Cs\" and subo2:\"Subobjs P (last Cs) Ds\" \n  and eq:\"last Cs = hd Ds\" and wf:\"wf_prog wf_md P\"\nshows \"Subobjs P C (Cs@(tl Ds))\"", "lemma Subobjs_appendPath:\n  \"\\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;wf_prog wf_md P\\<rbrakk>\n\\<Longrightarrow> Subobjs P C (Cs@\\<^sub>pDs)\"", "lemma assumes subo:\"Subobjs P C Cs\" and wf:\"wf_prog wf_md P\"\n  shows path_contains_classes:\"\\<forall>C' \\<in> set Cs. is_class P C'\"", "lemma path_subset_classes:\"\\<lbrakk>Subobjs P C Cs; wf_prog wf_md P\\<rbrakk> \n  \\<Longrightarrow> set Cs \\<subseteq> {C. is_class P C}\"", "lemma assumes subo:\"Subobjs P C (rev Cs)\" and wf:\"wf_prog wf_md P\"\n  shows rev_path_distinct_classes:\"distinct Cs\"", "lemma assumes subo:\"Subobjs P C Cs\" and wf:\"wf_prog wf_md P\"\n  shows path_distinct_classes:\"distinct Cs\"", "lemma assumes wf:\"wf_prog wf_md P\" \n  shows prog_length:\"length P = card {C. is_class P C}\"", "lemma assumes subo:\"Subobjs P C Cs\" and wf:\"wf_prog wf_md P\"\n  shows path_length:\"length Cs \\<le> length P\"", "lemma empty_path_empty_set:\"{Cs. Subobjs P C Cs \\<and> length Cs \\<le> 0} = {}\"", "lemma split_set_path_length:\"{Cs. Subobjs P C Cs \\<and> length Cs \\<le> Suc(n)} = \n{Cs. Subobjs P C Cs \\<and> length Cs \\<le> n} \\<union> {Cs. Subobjs P C Cs \\<and> length Cs = Suc(n)}\"", "lemma empty_list_set:\"{xs. set xs \\<subseteq> F \\<and> xs = []} = {[]}\"", "lemma suc_n_union_of_union:\"{xs. set xs \\<subseteq> F \\<and> length xs = Suc n} = (UN x:F. UN xs : {xs. set xs \\<le> F \\<and> length xs = n}. {x#xs})\"", "lemma max_length_finite_set:\"finite F \\<Longrightarrow> finite{xs. set xs <= F \\<and> length xs = n}\"", "lemma path_length_n_finite_set:\n\"wf_prog wf_md P \\<Longrightarrow> finite{Cs. Subobjs P C Cs \\<and> length Cs = n}\"", "lemma path_finite_leq:\n\"wf_prog wf_md P \\<Longrightarrow> finite{Cs. Subobjs P C Cs \\<and> length Cs \\<le> length P}\"", "lemma path_finite:\"wf_prog wf_md P \\<Longrightarrow> finite{Cs. Subobjs P C Cs}\"", "lemma path_via_reverse:\n  assumes path_via:\"P \\<turnstile> Path C to D via Cs\" and wf:\"wf_prog wf_md P\"\n  shows \"\\<forall>Cs'. P \\<turnstile> Path D to C via Cs' \\<longrightarrow> Cs = [C] \\<and> Cs' = [C] \\<and> C = D\"", "lemma path_hd_appendPath:\n  assumes path:\"P,C \\<turnstile> Cs \\<sqsubseteq> Cs'@\\<^sub>pCs\" and last:\"last Cs' = hd Cs\"\n  and notemptyCs:\"Cs \\<noteq> []\" and notemptyCs':\"Cs' \\<noteq> []\" and wf:\"wf_prog wf_md P\"\n  shows \"Cs' = [hd Cs]\"", "lemma path_via_C: \"\\<lbrakk>P \\<turnstile> Path C to C via Cs; wf_prog wf_md P\\<rbrakk> \\<Longrightarrow> Cs = [C]\"", "lemma assumes wf:\"wf_prog wf_md P\"\n  and path_via:\"P \\<turnstile> Path last Cs to C via Cs'\"\n  and path_via':\"P \\<turnstile> Path last Cs to C via Cs''\"\n  and appendPath:\"Cs = Cs@\\<^sub>pCs'\"\nshows appendPath_path_via:\"Cs = Cs@\\<^sub>pCs''\"", "lemma subo_no_path:\n  assumes subo:\"Subobjs P C' (Cs @ C#Cs')\" and wf:\"wf_prog wf_md P\"\n  and notempty:\"Cs' \\<noteq> []\"\n  shows \"\\<not> P \\<turnstile> Path last Cs' to C via Ds\"", "lemma leq_implies_path:\n  assumes leq:\"P \\<turnstile> C \\<preceq>\\<^sup>* D\" and \"class\": \"is_class P C\"\n  and wf:\"wf_prog wf_md P\"\nshows \"\\<exists>Cs. P \\<turnstile> Path C to D via Cs\"", "lemma least_method_implies_path_unique:\nassumes least:\"P \\<turnstile> C has least M = (Ts,T,m) via Cs\" and wf:\"wf_prog wf_md P\"\nshows \"P \\<turnstile> Path C to (last Cs) unique\"", "lemma least_field_implies_path_unique:\nassumes least:\"P \\<turnstile> C has least F:T via Cs\" and wf:\"wf_prog wf_md P\"\nshows \"P \\<turnstile> Path C to (hd Cs) unique\"", "lemma least_field_implies_path_via_hd: \n\"\\<lbrakk>P \\<turnstile> C has least F:T via Cs; wf_prog wf_md P\\<rbrakk> \n\\<Longrightarrow> P \\<turnstile> Path C to (hd Cs) via [hd Cs]\"", "lemma path_C_to_C_unique:\n\"\\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk> \\<Longrightarrow> P \\<turnstile> Path C to C unique\"", "lemma leqR_SubobjsR:\"\\<lbrakk>(C,D) \\<in> (subclsR P)\\<^sup>*; is_class P C; wf_prog wf_md P\\<rbrakk> \n\\<Longrightarrow> \\<exists>Cs. Subobjs\\<^sub>R P C (Cs@[D])\"", "lemma assumes path_unique:\"P \\<turnstile> Path C to D unique\" and leq:\"P \\<turnstile> C \\<preceq>\\<^sup>* C'\"\n  and leqR:\"(C',D) \\<in> (subclsR P)\\<^sup>*\" and wf:\"wf_prog wf_md P\"\n  shows \"P \\<turnstile> Path C to C' unique\"", "lemma has_path_has:\n\"\\<lbrakk>P \\<turnstile> Path D to C via Ds; P \\<turnstile> C has M = (Ts,T,m) via Cs; wf_prog wf_md P\\<rbrakk> \n  \\<Longrightarrow> P \\<turnstile> D has M = (Ts,T,m) via Ds@\\<^sub>pCs\"", "lemma has_least_wf_mdecl:\n  \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> C has least M = m via Cs \\<rbrakk> \n\\<Longrightarrow> wf_mdecl wf_md P (last Cs) (M,m)\"", "lemma has_overrider_wf_mdecl:\n  \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> (C,Cs) has overrider M = m via Cs' \\<rbrakk> \n\\<Longrightarrow> wf_mdecl wf_md P (last Cs') (M,m)\"", "lemma select_method_wf_mdecl:\n  \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> (C,Cs) selects M = m via Cs' \\<rbrakk> \n\\<Longrightarrow> wf_mdecl wf_md P (last Cs') (M,m)\"", "lemma wf_sees_method_fun:\n\"\\<lbrakk>P \\<turnstile> C has least M = mthd via Cs; P \\<turnstile> C has least M = mthd' via Cs'; \n  wf_prog wf_md P\\<rbrakk>\n  \\<Longrightarrow> mthd = mthd' \\<and> Cs = Cs'\"", "lemma wf_select_method_fun: \n  assumes wf:\"wf_prog wf_md P\"\n  shows \"\\<lbrakk>P \\<turnstile> (C,Cs) selects M = mthd via Cs'; P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\\<rbrakk>\n  \\<Longrightarrow> mthd = mthd' \\<and> Cs' = Cs''\"", "lemma least_field_is_type:\nassumes field:\"P \\<turnstile> C has least F:T via Cs\" and wf:\"wf_prog wf_md P\"\nshows \"is_type P T\"", "lemma least_method_is_type:\nassumes \"method\":\"P \\<turnstile> C has least M = (Ts,T,m) via Cs\" and wf:\"wf_prog wf_md P\"\nshows \"is_type P T\"", "lemma least_overrider_is_type:\nassumes \"method\":\"P \\<turnstile> (C,Cs) has overrider M = (Ts,T,m) via Cs'\" \n  and wf:\"wf_prog wf_md P\"\nshows \"is_type P T\"", "lemma select_method_is_type:\n\"\\<lbrakk> P \\<turnstile> (C,Cs) selects M = (Ts,T,m) via Cs'; wf_prog wf_md P\\<rbrakk> \\<Longrightarrow> is_type P T\"", "lemma base_subtype:\n\"\\<lbrakk>wf_cdecl wf_md P (C,Bs,fs,ms); C' \\<in> baseClasses Bs; \n  P \\<turnstile> C' has M = (Ts',T',m') via Cs@\\<^sub>p[D]; (M,Ts,T,m)\\<in>set ms\\<rbrakk>\n  \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\"", "lemma subclsPlus_subtype:\n  assumes classD:\"class P D = Some(Bs',fs',ms')\" \n  and mapMs':\"map_of ms' M = Some(Ts',T',m')\"\n  and leq:\"(C,D) \\<in> (subcls1 P)\\<^sup>+\" and wf:\"wf_prog wf_md P\"\nshows \"\\<forall>Bs fs ms Ts T m. class P C = Some(Bs,fs,ms) \\<and> map_of ms M = Some(Ts,T,m) \n    \\<longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\"", "lemma leq_method_subtypes:\n  assumes leq:\"P \\<turnstile> D \\<preceq>\\<^sup>* C\" and least:\"P \\<turnstile> D has least M = (Ts',T',m') via Ds\"\n  and wf:\"wf_prog wf_md P\"\n  shows \"\\<forall>Ts T m Cs. P \\<turnstile> C has M = (Ts,T,m) via Cs \\<longrightarrow> \n                       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\"", "lemma leq_methods_subtypes:\n  assumes leq:\"P \\<turnstile> D \\<preceq>\\<^sup>* C\" and least:\"(Ds,(Ts',T',m')) \\<in> MinimalMethodDefs P D M\"\n  and wf:\"wf_prog wf_md P\"\n  shows \"\\<forall>Ts T m Cs Cs'. P \\<turnstile> Path D to C via Cs' \\<and> P,D \\<turnstile> Ds \\<sqsubseteq> Cs'@\\<^sub>pCs \\<and> Cs \\<noteq> [] \\<and> \n                         P \\<turnstile> C has M = (Ts,T,m) via Cs \n                                \\<longrightarrow>  Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\"", "lemma select_least_methods_subtypes: \n  assumes select_method:\"P \\<turnstile> (C,Cs@\\<^sub>pDs) selects M = (Ts,T,pns,body) via Cs'\"\n  and least_method:\"P \\<turnstile> last Cs has least M = (Ts',T',pns',body') via Ds\"\n  and path:\"P \\<turnstile> Path C to (last Cs) via Cs\"\n  and wf:\"wf_prog wf_md P\"\n  shows \"Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\"", "lemma wf_syscls:\n  \"set SystemClasses \\<subseteq> set P \\<Longrightarrow> wf_syscls P\"", "lemma Class_widen: \"\\<lbrakk>P \\<turnstile> Class C \\<le> T; wf_prog wf_md P; is_class P C\\<rbrakk>  \n  \\<Longrightarrow>  \\<exists>D. T = Class D \\<and> P \\<turnstile> Path C to D unique\"", "lemma Class_widen_Class [iff]: \"\\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk> \\<Longrightarrow> \n  (P \\<turnstile> Class C \\<le> Class D) = (P \\<turnstile> Path C to D unique)\"", "lemma widen_Class: \"\\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk> \\<Longrightarrow> \n  (P \\<turnstile> T \\<le> Class C) = \n    (T = NT \\<or> (\\<exists>D. T = Class D \\<and> P \\<turnstile> Path D to C unique))\"", "lemma assumes wf:\"wf_prog wf_md P\" \nshows WT_determ: \"P,E \\<turnstile> e :: T \\<Longrightarrow> (\\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T')\"\nand WTs_determ: \"P,E \\<turnstile> es [::] Ts \\<Longrightarrow> (\\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts')\""], "translations": [["", "lemma class_wf: \n  \"\\<lbrakk>class P C = Some c; wf_prog wf_md P\\<rbrakk> \\<Longrightarrow> wf_cdecl wf_md P (C,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>class P C = \\<lfloor>c\\<rfloor>; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> wf_cdecl wf_md P (C, c)", "apply (unfold wf_prog_def class_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>map_of P C = \\<lfloor>c\\<rfloor>;\n     wf_syscls P \\<and>\n     distinct_fst P \\<and>\n     (\\<forall>c\\<in>set P. wf_cdecl wf_md P c)\\<rbrakk>\n    \\<Longrightarrow> wf_cdecl wf_md P (C, c)", "apply (fast dest: map_of_SomeD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_class_xcpt:\n  \"\\<lbrakk> C \\<in> sys_xcpts; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> is_class P C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> sys_xcpts; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> is_class P C", "apply (simp add: wf_prog_def wf_syscls_def is_class_def class_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> sys_xcpts;\n     sys_xcpts \\<subseteq> fst ` set P \\<and>\n     distinct_fst P \\<and>\n     (\\<forall>c\\<in>set P. wf_cdecl wf_md P c)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         map_of P C = \\<lfloor>(a, aa, b)\\<rfloor>", "apply (fastforce intro!: map_of_SomeI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_type_pTs:\nassumes \"wf_prog wf_md P\" and \"(C,S,fs,ms) \\<in> set P\" and \"(M,Ts,T,m) \\<in> set ms\"\nshows \"set Ts \\<subseteq> types P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set Ts \\<subseteq> types P", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set Ts \\<Longrightarrow> x \\<in> types P", "from assms"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  (C, S, fs, ms) \\<in> set P\n  (M, Ts, T, m) \\<in> set ms", "have \"wf_mdecl wf_md P C (M,Ts,T,m)\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  (C, S, fs, ms) \\<in> set P\n  (M, Ts, T, m) \\<in> set ms\n\ngoal (1 subgoal):\n 1. wf_mdecl wf_md P C (M, Ts, T, m)", "by (unfold wf_prog_def wf_cdecl_def) auto"], ["proof (state)\nthis:\n  wf_mdecl wf_md P C (M, Ts, T, m)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set Ts \\<Longrightarrow> x \\<in> types P", "hence \"\\<forall>t \\<in> set Ts. is_type P t\""], ["proof (prove)\nusing this:\n  wf_mdecl wf_md P C (M, Ts, T, m)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set Ts. is_type P t", "by (unfold wf_mdecl_def) auto"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set Ts. is_type P t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set Ts \\<Longrightarrow> x \\<in> types P", "moreover"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set Ts. is_type P t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set Ts \\<Longrightarrow> x \\<in> types P", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set Ts \\<Longrightarrow> x \\<in> types P", "assume \"t \\<in> set Ts\""], ["proof (state)\nthis:\n  t \\<in> set Ts\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set Ts \\<Longrightarrow> x \\<in> types P", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>set Ts. is_type P t\n  t \\<in> set Ts", "have \"is_type P t\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set Ts. is_type P t\n  t \\<in> set Ts\n\ngoal (1 subgoal):\n 1. is_type P t", "by blast"], ["proof (state)\nthis:\n  is_type P t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set Ts \\<Longrightarrow> x \\<in> types P", "thus \"t \\<in> types P\""], ["proof (prove)\nusing this:\n  is_type P t\n\ngoal (1 subgoal):\n 1. t \\<in> types P", ".."], ["proof (state)\nthis:\n  t \\<in> types P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Well-formedness subclass lemmas\\<close>"], ["", "lemma subcls1_wfD:\n  \"\\<lbrakk> P \\<turnstile> C \\<prec>\\<^sup>1 D; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> D \\<noteq> C \\<and> (D,C) \\<notin> (subcls1 P)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sup>1 D; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> D \\<noteq> C \\<and>\n                      (D, C) \\<notin> (subcls1 P)\\<^sup>+", "apply( frule r_into_trancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sup>1 D; wf_prog wf_md P;\n     (C, D) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> D \\<noteq> C \\<and>\n                      (D, C) \\<notin> (subcls1 P)\\<^sup>+", "apply( drule subcls1D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; (C, D) \\<in> (subcls1 P)\\<^sup>+;\n     \\<exists>fs ms Bs.\n        class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n        D \\<in> baseClasses Bs\\<rbrakk>\n    \\<Longrightarrow> D \\<noteq> C \\<and>\n                      (D, C) \\<notin> (subcls1 P)\\<^sup>+", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fs ms Bs.\n       \\<lbrakk>wf_prog wf_md P; (C, D) \\<in> (subcls1 P)\\<^sup>+;\n        class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>;\n        D \\<in> baseClasses Bs\\<rbrakk>\n       \\<Longrightarrow> D \\<noteq> C \\<and>\n                         (D, C) \\<notin> (subcls1 P)\\<^sup>+", "apply( drule (1) class_wf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fs ms Bs.\n       \\<lbrakk>wf_prog wf_md P; (C, D) \\<in> (subcls1 P)\\<^sup>+;\n        D \\<in> baseClasses Bs; wf_cdecl wf_md P (C, Bs, fs, ms)\\<rbrakk>\n       \\<Longrightarrow> D \\<noteq> C \\<and>\n                         (D, C) \\<notin> (subcls1 P)\\<^sup>+", "apply( unfold wf_cdecl_def baseClasses_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fs ms Bs.\n       \\<lbrakk>wf_prog wf_md P; (C, D) \\<in> (subcls1 P)\\<^sup>+;\n        D \\<in> set (map getbase Bs);\n        case (C, Bs, fs, ms) of\n        (C, Bs, fs, ms) \\<Rightarrow>\n          (\\<forall>M mthd Cs.\n              P \\<turnstile> C has M = mthd via Cs \\<longrightarrow>\n              (\\<exists>mthd' Cs'.\n                  P \\<turnstile> (C, Cs) has overrider M = mthd' via Cs')) \\<and>\n          (\\<forall>f\\<in>set fs. wf_fdecl P f) \\<and>\n          distinct_fst fs \\<and>\n          (\\<forall>m\\<in>set ms. wf_mdecl wf_md P C m) \\<and>\n          distinct_fst ms \\<and>\n          (\\<forall>D\\<in>set (map getbase Bs).\n              is_class P D \\<and>\n              (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n              (\\<forall>(M, Ts, T, m)\\<in>set ms.\n                  \\<forall>Ts' T' m' Cs.\n                     P \\<turnstile> D has M = (Ts', T',\n         m') via Cs \\<longrightarrow>\n                     Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'))\\<rbrakk>\n       \\<Longrightarrow> D \\<noteq> C \\<and>\n                         (D, C) \\<notin> (subcls1 P)\\<^sup>+", "apply(force simp add: reflcl_trancl [THEN sym] simp del: reflcl_trancl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_cdecl_supD: \n  \"\\<lbrakk>wf_cdecl wf_md P (C,Bs,r); D \\<in> baseClasses Bs\\<rbrakk> \\<Longrightarrow> is_class P D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_cdecl wf_md P (C, Bs, r); D \\<in> baseClasses Bs\\<rbrakk>\n    \\<Longrightarrow> is_class P D", "by (auto simp: wf_cdecl_def baseClasses_def)"], ["", "lemma subcls_asym:\n  \"\\<lbrakk> wf_prog wf_md P; (C,D) \\<in> (subcls1 P)\\<^sup>+ \\<rbrakk> \\<Longrightarrow> (D,C) \\<notin> (subcls1 P)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; (C, D) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> (D, C) \\<notin> (subcls1 P)\\<^sup>+", "apply(erule trancl.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>wf_prog wf_md P; C = a; D = b;\n        P \\<turnstile> a \\<prec>\\<^sup>1 b\\<rbrakk>\n       \\<Longrightarrow> (D, C) \\<notin> (subcls1 P)\\<^sup>+\n 2. \\<And>a b c.\n       \\<lbrakk>wf_prog wf_md P; C = a; D = c;\n        (a, b) \\<in> (subcls1 P)\\<^sup>+;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> (D, C) \\<notin> (subcls1 P)\\<^sup>+", "apply(fast dest!: subcls1_wfD )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>wf_prog wf_md P; C = a; D = c;\n        (a, b) \\<in> (subcls1 P)\\<^sup>+;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> (D, C) \\<notin> (subcls1 P)\\<^sup>+", "apply(fast dest!: subcls1_wfD intro: trancl_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subcls_irrefl:\n  \"\\<lbrakk> wf_prog wf_md P; (C,D) \\<in> (subcls1 P)\\<^sup>+ \\<rbrakk> \\<Longrightarrow> C \\<noteq> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; (C, D) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> C \\<noteq> D", "apply (erule trancl_trans_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>wf_prog wf_md P; P \\<turnstile> x \\<prec>\\<^sup>1 y\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y\n 2. \\<And>x y z.\n       \\<lbrakk>wf_prog wf_md P; (x, y) \\<in> (subcls1 P)\\<^sup>+;\n        x \\<noteq> y; (y, z) \\<in> (subcls1 P)\\<^sup>+;\n        y \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> z", "apply  (auto dest: subcls1_wfD subcls_asym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subcls_asym2:\n  \"\\<lbrakk> (C,D) \\<in> (subcls1 P)\\<^sup>*; wf_prog wf_md P; (D,C) \\<in> (subcls1 P)\\<^sup>* \\<rbrakk> \\<Longrightarrow> C = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D; wf_prog wf_md P;\n     P \\<turnstile> D \\<preceq>\\<^sup>* C\\<rbrakk>\n    \\<Longrightarrow> C = D", "apply (induct rule:rtrancl.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>wf_prog wf_md P;\n        P \\<turnstile> a \\<preceq>\\<^sup>* a\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>wf_prog wf_md P;\n         P \\<turnstile> b \\<preceq>\\<^sup>* a\\<rbrakk>\n        \\<Longrightarrow> a = b;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; wf_prog wf_md P;\n        P \\<turnstile> c \\<preceq>\\<^sup>* a\\<rbrakk>\n       \\<Longrightarrow> a = c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>wf_prog wf_md P;\n         P \\<turnstile> b \\<preceq>\\<^sup>* a\\<rbrakk>\n        \\<Longrightarrow> a = b;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; wf_prog wf_md P;\n        P \\<turnstile> c \\<preceq>\\<^sup>* a\\<rbrakk>\n       \\<Longrightarrow> a = c", "apply (drule rtrancl_into_trancl1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<lbrakk>wf_prog wf_md P;\n                 P \\<turnstile> b \\<preceq>\\<^sup>* a\\<rbrakk>\n                \\<Longrightarrow> a = b;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; wf_prog wf_md P;\n        P \\<turnstile> c \\<preceq>\\<^sup>* a\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> b \\<prec>\\<^sup>1 ?c2 a b c\n 2. \\<And>a b c.\n       \\<lbrakk>\\<lbrakk>wf_prog wf_md P;\n                 P \\<turnstile> b \\<preceq>\\<^sup>* a\\<rbrakk>\n                \\<Longrightarrow> a = b;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; wf_prog wf_md P;\n        P \\<turnstile> c \\<preceq>\\<^sup>* a;\n        (a, ?c2 a b c) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> a = c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<lbrakk>wf_prog wf_md P;\n                 P \\<turnstile> b \\<preceq>\\<^sup>* a\\<rbrakk>\n                \\<Longrightarrow> a = b;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; wf_prog wf_md P;\n        P \\<turnstile> c \\<preceq>\\<^sup>* a;\n        (a, c) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> a = c", "apply (drule subcls_asym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<lbrakk>wf_prog wf_md P;\n                 P \\<turnstile> b \\<preceq>\\<^sup>* a\\<rbrakk>\n                \\<Longrightarrow> a = b;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> c \\<preceq>\\<^sup>* a;\n        (a, c) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> (?C5 a b c, ?D5 a b c) \\<in> (subcls1 P)\\<^sup>+\n 2. \\<And>a b c.\n       \\<lbrakk>\\<lbrakk>wf_prog wf_md P;\n                 P \\<turnstile> b \\<preceq>\\<^sup>* a\\<rbrakk>\n                \\<Longrightarrow> a = b;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> c \\<preceq>\\<^sup>* a;\n        (a, c) \\<in> (subcls1 P)\\<^sup>+;\n        (?D5 a b c, ?C5 a b c) \\<notin> (subcls1 P)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> a = c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<lbrakk>wf_prog wf_md P;\n                 P \\<turnstile> b \\<preceq>\\<^sup>* a\\<rbrakk>\n                \\<Longrightarrow> a = b;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> c \\<preceq>\\<^sup>* a;\n        (a, c) \\<in> (subcls1 P)\\<^sup>+;\n        (c, a) \\<notin> (subcls1 P)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> a = c", "apply(drule rtranclD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<lbrakk>wf_prog wf_md P;\n                 P \\<turnstile> b \\<preceq>\\<^sup>* a\\<rbrakk>\n                \\<Longrightarrow> a = b;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (a, c) \\<in> (subcls1 P)\\<^sup>+;\n        (c, a) \\<notin> (subcls1 P)\\<^sup>+;\n        c = a \\<or>\n        c \\<noteq> a \\<and> (c, a) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> a = c", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma acyclic_subcls1:\n  \"wf_prog wf_md P \\<Longrightarrow> acyclic (subcls1 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow> acyclic (subcls1 P)", "apply (unfold acyclic_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow>\n    \\<forall>x. (x, x) \\<notin> (subcls1 P)\\<^sup>+", "apply (fast dest: subcls_irrefl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_subcls1:\n  \"wf_prog wf_md P \\<Longrightarrow> wf ((subcls1 P)\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow> wf ((subcls1 P)\\<inverse>)", "apply (rule finite_acyclic_wf_converse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf_prog wf_md P \\<Longrightarrow> finite (subcls1 P)\n 2. wf_prog wf_md P \\<Longrightarrow> acyclic (subcls1 P)", "apply (rule finite_subcls1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow> acyclic (subcls1 P)", "apply (erule acyclic_subcls1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subcls_induct: \n  \"\\<lbrakk> wf_prog wf_md P; \\<And>C. \\<forall>D. (C,D) \\<in> (subcls1 P)\\<^sup>+ \\<longrightarrow> Q D \\<Longrightarrow> Q C \\<rbrakk> \\<Longrightarrow> Q C\"\n\n  (is \"?A \\<Longrightarrow> PROP ?P \\<Longrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     \\<And>C.\n        \\<forall>D.\n           (C, D) \\<in> (subcls1 P)\\<^sup>+ \\<longrightarrow>\n           Q D \\<Longrightarrow>\n        Q C\\<rbrakk>\n    \\<Longrightarrow> Q C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     \\<And>C.\n        \\<forall>D.\n           (C, D) \\<in> (subcls1 P)\\<^sup>+ \\<longrightarrow>\n           Q D \\<Longrightarrow>\n        Q C\\<rbrakk>\n    \\<Longrightarrow> Q C", "assume p: \"PROP ?P\""], ["proof (state)\nthis:\n  \\<forall>D.\n     (?C, D) \\<in> (subcls1 P)\\<^sup>+ \\<longrightarrow>\n     Q D \\<Longrightarrow>\n  Q ?C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     \\<And>C.\n        \\<forall>D.\n           (C, D) \\<in> (subcls1 P)\\<^sup>+ \\<longrightarrow>\n           Q D \\<Longrightarrow>\n        Q C\\<rbrakk>\n    \\<Longrightarrow> Q C", "assume ?A"], ["proof (state)\nthis:\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     \\<And>C.\n        \\<forall>D.\n           (C, D) \\<in> (subcls1 P)\\<^sup>+ \\<longrightarrow>\n           Q D \\<Longrightarrow>\n        Q C\\<rbrakk>\n    \\<Longrightarrow> Q C", "thus ?thesis"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. Q C", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow> Q C", "apply(drule wf_subcls1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf ((subcls1 P)\\<inverse>) \\<Longrightarrow> Q C", "apply(drule wf_trancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (((subcls1 P)\\<inverse>)\\<^sup>+) \\<Longrightarrow> Q C", "apply(simp only: trancl_converse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (((subcls1 P)\\<^sup>+)\\<inverse>) \\<Longrightarrow> Q C", "apply(erule_tac a = C in wf_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> ((subcls1 P)\\<^sup>+)\\<inverse> \\<longrightarrow>\n          Q y \\<Longrightarrow>\n       Q x", "apply(rule p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> ((subcls1 P)\\<^sup>+)\\<inverse> \\<longrightarrow>\n          Q y \\<Longrightarrow>\n       \\<forall>D. (x, D) \\<in> (subcls1 P)\\<^sup>+ \\<longrightarrow> Q D", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Q C\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Well-formedness leq\\_path lemmas\\<close>"], ["", "lemma last_leq_path:\nassumes leq:\"P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Ds\" and wf:\"wf_prog wf_md P\"\nshows \"P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds", "using leq"], ["proof (prove)\nusing this:\n  P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Ds\n\ngoal (1 subgoal):\n 1. P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds", "proof (induct rule:leq_path1.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Cs Ds.\n       \\<lbrakk>Subobjs P C Cs; Subobjs P C Ds; Cs = butlast Ds\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds\n 2. \\<And>Cs D.\n       \\<lbrakk>Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]", "fix Cs Ds"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Cs Ds.\n       \\<lbrakk>Subobjs P C Cs; Subobjs P C Ds; Cs = butlast Ds\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds\n 2. \\<And>Cs D.\n       \\<lbrakk>Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]", "assume suboCs:\"Subobjs P C Cs\" and suboDs:\"Subobjs P C Ds\"\n  and butlast:\"Cs = butlast Ds\""], ["proof (state)\nthis:\n  Subobjs P C Cs\n  Subobjs P C Ds\n  Cs = butlast Ds\n\ngoal (2 subgoals):\n 1. \\<And>Cs Ds.\n       \\<lbrakk>Subobjs P C Cs; Subobjs P C Ds; Cs = butlast Ds\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds\n 2. \\<And>Cs D.\n       \\<lbrakk>Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]", "from suboDs"], ["proof (chain)\npicking this:\n  Subobjs P C Ds", "have notempty:\"Ds \\<noteq> []\""], ["proof (prove)\nusing this:\n  Subobjs P C Ds\n\ngoal (1 subgoal):\n 1. Ds \\<noteq> []", "by -(drule Subobjs_nonempty)"], ["proof (state)\nthis:\n  Ds \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>Cs Ds.\n       \\<lbrakk>Subobjs P C Cs; Subobjs P C Ds; Cs = butlast Ds\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds\n 2. \\<And>Cs D.\n       \\<lbrakk>Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]", "with butlast"], ["proof (chain)\npicking this:\n  Cs = butlast Ds\n  Ds \\<noteq> []", "have DsCs:\"Ds = Cs @ [last Ds]\""], ["proof (prove)\nusing this:\n  Cs = butlast Ds\n  Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. Ds = Cs @ [last Ds]", "by simp"], ["proof (state)\nthis:\n  Ds = Cs @ [last Ds]\n\ngoal (2 subgoals):\n 1. \\<And>Cs Ds.\n       \\<lbrakk>Subobjs P C Cs; Subobjs P C Ds; Cs = butlast Ds\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds\n 2. \\<And>Cs D.\n       \\<lbrakk>Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]", "from suboCs"], ["proof (chain)\npicking this:\n  Subobjs P C Cs", "have notempty:\"Cs \\<noteq> []\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n\ngoal (1 subgoal):\n 1. Cs \\<noteq> []", "by -(drule Subobjs_nonempty)"], ["proof (state)\nthis:\n  Cs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>Cs Ds.\n       \\<lbrakk>Subobjs P C Cs; Subobjs P C Ds; Cs = butlast Ds\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds\n 2. \\<And>Cs D.\n       \\<lbrakk>Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]", "with DsCs"], ["proof (chain)\npicking this:\n  Ds = Cs @ [last Ds]\n  Cs \\<noteq> []", "have \"Ds = ((butlast Cs) @ [last Cs]) @ [last Ds]\""], ["proof (prove)\nusing this:\n  Ds = Cs @ [last Ds]\n  Cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Ds = (butlast Cs @ [last Cs]) @ [last Ds]", "by simp"], ["proof (state)\nthis:\n  Ds = (butlast Cs @ [last Cs]) @ [last Ds]\n\ngoal (2 subgoals):\n 1. \\<And>Cs Ds.\n       \\<lbrakk>Subobjs P C Cs; Subobjs P C Ds; Cs = butlast Ds\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds\n 2. \\<And>Cs D.\n       \\<lbrakk>Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]", "with suboDs"], ["proof (chain)\npicking this:\n  Subobjs P C Ds\n  Ds = (butlast Cs @ [last Cs]) @ [last Ds]", "have \"Subobjs P C ((butlast Cs) @ [last Cs,last Ds])\""], ["proof (prove)\nusing this:\n  Subobjs P C Ds\n  Ds = (butlast Cs @ [last Cs]) @ [last Ds]\n\ngoal (1 subgoal):\n 1. Subobjs P C (butlast Cs @ [last Cs, last Ds])", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (butlast Cs @ [last Cs, last Ds])\n\ngoal (2 subgoals):\n 1. \\<And>Cs Ds.\n       \\<lbrakk>Subobjs P C Cs; Subobjs P C Ds; Cs = butlast Ds\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds\n 2. \\<And>Cs D.\n       \\<lbrakk>Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]", "thus \"P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds\""], ["proof (prove)\nusing this:\n  Subobjs P C (butlast Cs @ [last Cs, last Ds])\n\ngoal (1 subgoal):\n 1. P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds", "by (fastforce intro:subclsR_subcls1 Subobjs_subclsR)"], ["proof (state)\nthis:\n  P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Ds\n\ngoal (1 subgoal):\n 1. \\<And>Cs D.\n       \\<lbrakk>Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Cs D.\n       \\<lbrakk>Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]", "fix Cs D"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Cs D.\n       \\<lbrakk>Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]", "assume \"P \\<turnstile> last Cs \\<prec>\\<^sub>S D\""], ["proof (state)\nthis:\n  P \\<turnstile> last Cs \\<prec>\\<^sub>S D\n\ngoal (1 subgoal):\n 1. \\<And>Cs D.\n       \\<lbrakk>Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]", "thus \"P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]\""], ["proof (prove)\nusing this:\n  P \\<turnstile> last Cs \\<prec>\\<^sub>S D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]", "by (fastforce intro:subclsS_subcls1)"], ["proof (state)\nthis:\n  P \\<turnstile> last Cs \\<prec>\\<^sup>1 last [D]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma last_leq_paths:\nassumes leq:\"(Cs,Ds) \\<in> (leq_path1 P C)\\<^sup>+\" and wf:\"wf_prog wf_md P\"\nshows \"(last Cs,last Ds) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (last Cs, last Ds) \\<in> (subcls1 P)\\<^sup>+", "using leq"], ["proof (prove)\nusing this:\n  (Cs, Ds) \\<in> (leq_path1 P C)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (last Cs, last Ds) \\<in> (subcls1 P)\\<^sup>+", "proof (induct rule:trancl.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       P,C \\<turnstile> a \\<sqsubset>\\<^sup>1 b \\<Longrightarrow>\n       (last a, last b) \\<in> (subcls1 P)\\<^sup>+\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (leq_path1 P C)\\<^sup>+;\n        (last a, last b) \\<in> (subcls1 P)\\<^sup>+;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> (last a, last c) \\<in> (subcls1 P)\\<^sup>+", "fix Cs Ds"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       P,C \\<turnstile> a \\<sqsubset>\\<^sup>1 b \\<Longrightarrow>\n       (last a, last b) \\<in> (subcls1 P)\\<^sup>+\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (leq_path1 P C)\\<^sup>+;\n        (last a, last b) \\<in> (subcls1 P)\\<^sup>+;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> (last a, last c) \\<in> (subcls1 P)\\<^sup>+", "assume \"P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Ds\""], ["proof (state)\nthis:\n  P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Ds\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       P,C \\<turnstile> a \\<sqsubset>\\<^sup>1 b \\<Longrightarrow>\n       (last a, last b) \\<in> (subcls1 P)\\<^sup>+\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (leq_path1 P C)\\<^sup>+;\n        (last a, last b) \\<in> (subcls1 P)\\<^sup>+;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> (last a, last c) \\<in> (subcls1 P)\\<^sup>+", "thus \"(last Cs, last Ds) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Ds\n\ngoal (1 subgoal):\n 1. (last Cs, last Ds) \\<in> (subcls1 P)\\<^sup>+", "using wf"], ["proof (prove)\nusing this:\n  P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Ds\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. (last Cs, last Ds) \\<in> (subcls1 P)\\<^sup>+", "by (fastforce intro:r_into_trancl elim:last_leq_path)"], ["proof (state)\nthis:\n  (last Cs, last Ds) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (leq_path1 P C)\\<^sup>+;\n        (last a, last b) \\<in> (subcls1 P)\\<^sup>+;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> (last a, last c) \\<in> (subcls1 P)\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (leq_path1 P C)\\<^sup>+;\n        (last a, last b) \\<in> (subcls1 P)\\<^sup>+;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> (last a, last c) \\<in> (subcls1 P)\\<^sup>+", "fix Cs Cs' Ds"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (leq_path1 P C)\\<^sup>+;\n        (last a, last b) \\<in> (subcls1 P)\\<^sup>+;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> (last a, last c) \\<in> (subcls1 P)\\<^sup>+", "assume \"(last Cs, last Cs') \\<in> (subcls1 P)\\<^sup>+\"\n    and \"P,C \\<turnstile> Cs' \\<sqsubset>\\<^sup>1 Ds\""], ["proof (state)\nthis:\n  (last Cs, last Cs') \\<in> (subcls1 P)\\<^sup>+\n  P,C \\<turnstile> Cs' \\<sqsubset>\\<^sup>1 Ds\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (leq_path1 P C)\\<^sup>+;\n        (last a, last b) \\<in> (subcls1 P)\\<^sup>+;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> (last a, last c) \\<in> (subcls1 P)\\<^sup>+", "thus \"(last Cs, last Ds) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (last Cs, last Cs') \\<in> (subcls1 P)\\<^sup>+\n  P,C \\<turnstile> Cs' \\<sqsubset>\\<^sup>1 Ds\n\ngoal (1 subgoal):\n 1. (last Cs, last Ds) \\<in> (subcls1 P)\\<^sup>+", "using wf"], ["proof (prove)\nusing this:\n  (last Cs, last Cs') \\<in> (subcls1 P)\\<^sup>+\n  P,C \\<turnstile> Cs' \\<sqsubset>\\<^sup>1 Ds\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. (last Cs, last Ds) \\<in> (subcls1 P)\\<^sup>+", "by (fastforce dest:last_leq_path)"], ["proof (state)\nthis:\n  (last Cs, last Ds) \\<in> (subcls1 P)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leq_path1_wfD:\n\"\\<lbrakk> P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs'; wf_prog wf_md P \\<rbrakk> \\<Longrightarrow> Cs \\<noteq> Cs' \\<and> (Cs',Cs) \\<notin> (leq_path1 P C)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs';\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> Cs \\<noteq> Cs' \\<and>\n                      (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs';\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> Cs \\<noteq> Cs'\n 2. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs';\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+", "apply (erule leq_path1.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Csa Ds.\n       \\<lbrakk>wf_prog wf_md P; Cs = Csa; Cs' = Ds; Subobjs P C Csa;\n        Subobjs P C Ds; Csa = butlast Ds\\<rbrakk>\n       \\<Longrightarrow> Cs \\<noteq> Cs'\n 2. \\<And>Csa D.\n       \\<lbrakk>wf_prog wf_md P; Cs = Csa; Cs' = [D]; Subobjs P C Csa;\n        P \\<turnstile> last Csa \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> Cs \\<noteq> Cs'\n 3. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs';\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Csa Ds.\n       \\<lbrakk>wf_prog wf_md P; Cs = butlast Ds; Cs' = Ds;\n        Subobjs P C (butlast Ds); Subobjs P C Ds; Csa = butlast Ds\\<rbrakk>\n       \\<Longrightarrow> butlast Ds \\<noteq> Ds\n 2. \\<And>Csa D.\n       \\<lbrakk>wf_prog wf_md P; Cs = Csa; Cs' = [D]; Subobjs P C Csa;\n        P \\<turnstile> last Csa \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> Cs \\<noteq> Cs'\n 3. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs';\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+", "apply (drule_tac Cs=\"Ds\" in Subobjs_nonempty)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Csa Ds.\n       \\<lbrakk>wf_prog wf_md P; Cs = butlast Ds; Cs' = Ds;\n        Subobjs P C (butlast Ds); Csa = butlast Ds; Ds \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> butlast Ds \\<noteq> Ds\n 2. \\<And>Csa D.\n       \\<lbrakk>wf_prog wf_md P; Cs = Csa; Cs' = [D]; Subobjs P C Csa;\n        P \\<turnstile> last Csa \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> Cs \\<noteq> Cs'\n 3. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs';\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+", "apply (rule butlast_noteq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Csa Ds.\n       \\<lbrakk>wf_prog wf_md P; Cs = butlast Ds; Cs' = Ds;\n        Subobjs P C (butlast Ds); Csa = butlast Ds; Ds \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Ds \\<noteq> []\n 2. \\<And>Csa D.\n       \\<lbrakk>wf_prog wf_md P; Cs = Csa; Cs' = [D]; Subobjs P C Csa;\n        P \\<turnstile> last Csa \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> Cs \\<noteq> Cs'\n 3. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs';\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Csa D.\n       \\<lbrakk>wf_prog wf_md P; Cs = Csa; Cs' = [D]; Subobjs P C Csa;\n        P \\<turnstile> last Csa \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> Cs \\<noteq> Cs'\n 2. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs';\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D.\n       \\<lbrakk>wf_prog wf_md P; Cs' = [D]; Subobjs P C [D];\n        P \\<turnstile> D \\<prec>\\<^sub>S D; Cs = [D]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs';\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+", "apply (drule subclsS_subcls1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D.\n       \\<lbrakk>wf_prog wf_md P; Cs' = [D]; Subobjs P C [D]; Cs = [D];\n        P \\<turnstile> D \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs';\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+", "apply (drule subcls1_wfD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>D.\n       \\<lbrakk>wf_prog wf_md P; Cs' = [D]; Subobjs P C [D];\n        Cs = [D]\\<rbrakk>\n       \\<Longrightarrow> wf_prog (?wf_md18 D) P\n 2. \\<And>D.\n       \\<lbrakk>wf_prog wf_md P; Cs' = [D]; Subobjs P C [D]; Cs = [D];\n        D \\<noteq> D \\<and> (D, D) \\<notin> (subcls1 P)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs';\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs';\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs'; wf_prog wf_md P;\n     (Cs', Cs) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> False", "apply (frule last_leq_path)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs'; wf_prog wf_md P;\n     (Cs', Cs) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> wf_prog ?wf_md22 P\n 2. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs'; wf_prog wf_md P;\n     (Cs', Cs) \\<in> (leq_path1 P C)\\<^sup>+;\n     P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Cs'\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs'; wf_prog wf_md P;\n     (Cs', Cs) \\<in> (leq_path1 P C)\\<^sup>+;\n     P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Cs'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule last_leq_paths)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs'; wf_prog wf_md P;\n     P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Cs'\\<rbrakk>\n    \\<Longrightarrow> wf_prog ?wf_md25 P\n 2. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs'; wf_prog wf_md P;\n     P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Cs';\n     (last Cs', last Cs) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs'; wf_prog wf_md P;\n     P \\<turnstile> last Cs \\<prec>\\<^sup>1 last Cs';\n     (last Cs', last Cs) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule_tac r=\"subcls1 P\" in r_into_trancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs'; wf_prog wf_md P;\n     (last Cs', last Cs) \\<in> (subcls1 P)\\<^sup>+;\n     (last Cs, last Cs') \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule subcls_asym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs';\n     (last Cs', last Cs) \\<in> (subcls1 P)\\<^sup>+;\n     (last Cs, last Cs') \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> (?C30, ?D30) \\<in> (subcls1 P)\\<^sup>+\n 2. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs';\n     (last Cs', last Cs) \\<in> (subcls1 P)\\<^sup>+;\n     (last Cs, last Cs') \\<in> (subcls1 P)\\<^sup>+;\n     (?D30, ?C30) \\<notin> (subcls1 P)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma leq_path_asym:\n\"\\<lbrakk>(Cs,Cs') \\<in> (leq_path1 P C)\\<^sup>+; wf_prog wf_md P\\<rbrakk> \\<Longrightarrow> (Cs',Cs) \\<notin> (leq_path1 P C)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Cs, Cs') \\<in> (leq_path1 P C)\\<^sup>+;\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+", "apply(erule tranclE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P;\n     P,C \\<turnstile> Cs \\<sqsubset>\\<^sup>1 Cs'\\<rbrakk>\n    \\<Longrightarrow> (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+\n 2. \\<And>c.\n       \\<lbrakk>wf_prog wf_md P; (Cs, c) \\<in> (leq_path1 P C)\\<^sup>+;\n        P,C \\<turnstile> c \\<sqsubset>\\<^sup>1 Cs'\\<rbrakk>\n       \\<Longrightarrow> (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+", "apply(fast dest!:leq_path1_wfD )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>wf_prog wf_md P; (Cs, c) \\<in> (leq_path1 P C)\\<^sup>+;\n        P,C \\<turnstile> c \\<sqsubset>\\<^sup>1 Cs'\\<rbrakk>\n       \\<Longrightarrow> (Cs', Cs) \\<notin> (leq_path1 P C)\\<^sup>+", "apply(fast dest!:leq_path1_wfD intro: trancl_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma leq_path_asym2:\"\\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> Cs'; P,C \\<turnstile> Cs' \\<sqsubseteq> Cs; wf_prog wf_md P\\<rbrakk> \\<Longrightarrow> Cs = Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     P,C \\<turnstile> Cs' \\<sqsubseteq> Cs; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'", "apply (induct rule:rtrancl.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P,C \\<turnstile> a \\<sqsubseteq> a; wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> a = a\n 2. \\<And>a b c.\n       \\<lbrakk>P,C \\<turnstile> a \\<sqsubseteq> b;\n        \\<lbrakk>P,C \\<turnstile> b \\<sqsubseteq> a;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> a = b;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c;\n        P,C \\<turnstile> c \\<sqsubseteq> a; wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> a = c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P,C \\<turnstile> a \\<sqsubseteq> b;\n        \\<lbrakk>P,C \\<turnstile> b \\<sqsubseteq> a;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> a = b;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c;\n        P,C \\<turnstile> c \\<sqsubseteq> a; wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> a = c", "apply (drule rtrancl_into_trancl1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<lbrakk>P,C \\<turnstile> b \\<sqsubseteq> a;\n                 wf_prog wf_md P\\<rbrakk>\n                \\<Longrightarrow> a = b;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c;\n        P,C \\<turnstile> c \\<sqsubseteq> a; wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 ?c2 a b c\n 2. \\<And>a b c.\n       \\<lbrakk>\\<lbrakk>P,C \\<turnstile> b \\<sqsubseteq> a;\n                 wf_prog wf_md P\\<rbrakk>\n                \\<Longrightarrow> a = b;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c;\n        P,C \\<turnstile> c \\<sqsubseteq> a; wf_prog wf_md P;\n        (a, ?c2 a b c) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> a = c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<lbrakk>P,C \\<turnstile> b \\<sqsubseteq> a;\n                 wf_prog wf_md P\\<rbrakk>\n                \\<Longrightarrow> a = b;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c;\n        P,C \\<turnstile> c \\<sqsubseteq> a; wf_prog wf_md P;\n        (a, c) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> a = c", "apply (drule leq_path_asym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<lbrakk>P,C \\<turnstile> b \\<sqsubseteq> a;\n                 wf_prog wf_md P\\<rbrakk>\n                \\<Longrightarrow> a = b;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c;\n        P,C \\<turnstile> c \\<sqsubseteq> a; wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> wf_prog (?wf_md5 a b c) P\n 2. \\<And>a b c.\n       \\<lbrakk>\\<lbrakk>P,C \\<turnstile> b \\<sqsubseteq> a;\n                 wf_prog wf_md P\\<rbrakk>\n                \\<Longrightarrow> a = b;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c;\n        P,C \\<turnstile> c \\<sqsubseteq> a; wf_prog wf_md P;\n        (c, a) \\<notin> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> a = c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<lbrakk>P,C \\<turnstile> b \\<sqsubseteq> a;\n                 wf_prog wf_md P\\<rbrakk>\n                \\<Longrightarrow> a = b;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c;\n        P,C \\<turnstile> c \\<sqsubseteq> a; wf_prog wf_md P;\n        (c, a) \\<notin> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> a = c", "apply (drule_tac a=\"c\" and b=\"a\" in rtranclD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<lbrakk>P,C \\<turnstile> b \\<sqsubseteq> a;\n                 wf_prog wf_md P\\<rbrakk>\n                \\<Longrightarrow> a = b;\n        P,C \\<turnstile> b \\<sqsubset>\\<^sup>1 c; wf_prog wf_md P;\n        (c, a) \\<notin> (leq_path1 P C)\\<^sup>+;\n        c = a \\<or>\n        c \\<noteq> a \\<and> (c, a) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> a = c", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma leq_path_Subobjs:\n\"\\<lbrakk>P,C \\<turnstile> [C] \\<sqsubseteq> Cs; is_class P C; wf_prog wf_md P\\<rbrakk> \\<Longrightarrow> Subobjs P C Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,C \\<turnstile> [C] \\<sqsubseteq> Cs; is_class P C;\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> Subobjs P C Cs", "by (induct rule:rtrancl_induct,auto intro:Subobjs_Base elim!:leq_path1.cases,\n         auto dest!:Subobjs_subclass intro!:Subobjs_Sh SubobjsR_Base dest!:subclsSD\n              intro:wf_cdecl_supD class_wf ShBaseclass_isBaseclass subclsSI)"], ["", "subsection\\<open>Lemmas concerning Subobjs\\<close>"], ["", "lemma Subobj_last_isClass:\"\\<lbrakk>wf_prog wf_md P; Subobjs P C Cs\\<rbrakk> \\<Longrightarrow> is_class P (last Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; Subobjs P C Cs\\<rbrakk>\n    \\<Longrightarrow> is_class P (last Cs)", "apply (frule Subobjs_isClass)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; Subobjs P C Cs; is_class P C\\<rbrakk>\n    \\<Longrightarrow> is_class P (last Cs)", "apply (drule Subobjs_subclass)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C;\n     P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\\<rbrakk>\n    \\<Longrightarrow> is_class P (last Cs)", "apply (drule rtranclD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C;\n     C = last Cs \\<or>\n     C \\<noteq> last Cs \\<and>\n     (C, last Cs) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> is_class P (last Cs)", "apply (erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C; C = last Cs\\<rbrakk>\n    \\<Longrightarrow> is_class P (last Cs)\n 2. \\<lbrakk>wf_prog wf_md P; is_class P C;\n     C \\<noteq> last Cs \\<and>\n     (C, last Cs) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> is_class P (last Cs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C;\n     C \\<noteq> last Cs \\<and>\n     (C, last Cs) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> is_class P (last Cs)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C; C \\<noteq> last Cs;\n     (C, last Cs) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> is_class P (last Cs)", "apply (erule trancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>wf_prog wf_md P; is_class P C; C \\<noteq> last Cs;\n        P \\<turnstile> C \\<prec>\\<^sup>1 y\\<rbrakk>\n       \\<Longrightarrow> is_class P y\n 2. \\<And>y z.\n       \\<lbrakk>wf_prog wf_md P; is_class P C; C \\<noteq> last Cs;\n        (C, y) \\<in> (subcls1 P)\\<^sup>+;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z; is_class P y\\<rbrakk>\n       \\<Longrightarrow> is_class P z", "apply (fastforce dest:subcls1D class_wf elim:wf_cdecl_supD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>wf_prog wf_md P; is_class P C; C \\<noteq> last Cs;\n        (C, y) \\<in> (subcls1 P)\\<^sup>+;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z; is_class P y\\<rbrakk>\n       \\<Longrightarrow> is_class P z", "apply (fastforce dest:subcls1D class_wf elim:wf_cdecl_supD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma converse_SubobjsR_Rep:\n  \"\\<lbrakk>Subobjs\\<^sub>R P C Cs; P \\<turnstile> last Cs \\<prec>\\<^sub>R C'; wf_prog wf_md P\\<rbrakk> \n\\<Longrightarrow> Subobjs\\<^sub>R P C (Cs@[C'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs\\<^sub>R P C Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>R C'; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> Subobjs\\<^sub>R P C (Cs @ [C'])", "apply (induct rule:Subobjs\\<^sub>R.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>is_class P C; P \\<turnstile> last [C] \\<prec>\\<^sub>R C';\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> Subobjs\\<^sub>R P C ([C] @ [C'])\n 2. \\<And>C D Cs.\n       \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sub>R D; Subobjs\\<^sub>R P D Cs;\n        \\<lbrakk>P \\<turnstile> last Cs \\<prec>\\<^sub>R C';\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> Subobjs\\<^sub>R P D (Cs @ [C']);\n        P \\<turnstile> last (C # Cs) \\<prec>\\<^sub>R C';\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> Subobjs\\<^sub>R P C ((C # Cs) @ [C'])", "apply (frule subclsR_subcls1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>is_class P C; P \\<turnstile> last [C] \\<prec>\\<^sub>R C';\n        wf_prog wf_md P; P \\<turnstile> last [C] \\<prec>\\<^sup>1 C'\\<rbrakk>\n       \\<Longrightarrow> Subobjs\\<^sub>R P C ([C] @ [C'])\n 2. \\<And>C D Cs.\n       \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sub>R D; Subobjs\\<^sub>R P D Cs;\n        \\<lbrakk>P \\<turnstile> last Cs \\<prec>\\<^sub>R C';\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> Subobjs\\<^sub>R P D (Cs @ [C']);\n        P \\<turnstile> last (C # Cs) \\<prec>\\<^sub>R C';\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> Subobjs\\<^sub>R P C ((C # Cs) @ [C'])", "apply (fastforce dest!:subcls1D class_wf wf_cdecl_supD SubobjsR_Base SubobjsR_Rep)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C D Cs.\n       \\<lbrakk>P \\<turnstile> C \\<prec>\\<^sub>R D; Subobjs\\<^sub>R P D Cs;\n        \\<lbrakk>P \\<turnstile> last Cs \\<prec>\\<^sub>R C';\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> Subobjs\\<^sub>R P D (Cs @ [C']);\n        P \\<turnstile> last (C # Cs) \\<prec>\\<^sub>R C';\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> Subobjs\\<^sub>R P C ((C # Cs) @ [C'])", "apply (fastforce elim:SubobjsR_Rep simp: SubobjsR_nonempty split:if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma converse_Subobjs_Rep:\n  \"\\<lbrakk>Subobjs P C Cs; P \\<turnstile> last Cs \\<prec>\\<^sub>R C';  wf_prog wf_md P\\<rbrakk> \n\\<Longrightarrow> Subobjs P C (Cs@[C'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C Cs; P \\<turnstile> last Cs \\<prec>\\<^sub>R C';\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> Subobjs P C (Cs @ [C'])", "by (induct rule:Subobjs.induct, fastforce dest:converse_SubobjsR_Rep Subobjs_Rep, \n  fastforce dest:converse_SubobjsR_Rep Subobjs_Sh)"], ["", "lemma isSubobj_Subobjs_rev:\nassumes subo:\"is_subobj P ((C,C'#rev Cs'))\" and wf:\"wf_prog wf_md P\"\nshows \"Subobjs P C (C'#rev Cs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C (C' # rev Cs')", "using subo"], ["proof (prove)\nusing this:\n  is_subobj P (C, C' # rev Cs')\n\ngoal (1 subgoal):\n 1. Subobjs P C (C' # rev Cs')", "proof (induct Cs')"], ["proof (state)\ngoal (2 subgoals):\n 1. is_subobj P (C, C' # rev []) \\<Longrightarrow> Subobjs P C (C' # rev [])\n 2. \\<And>a Cs'.\n       \\<lbrakk>is_subobj P (C, C' # rev Cs') \\<Longrightarrow>\n                Subobjs P C (C' # rev Cs');\n        is_subobj P (C, C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (C' # rev (a # Cs'))", "case Nil"], ["proof (state)\nthis:\n  is_subobj P (C, C' # rev [])\n\ngoal (2 subgoals):\n 1. is_subobj P (C, C' # rev []) \\<Longrightarrow> Subobjs P C (C' # rev [])\n 2. \\<And>a Cs'.\n       \\<lbrakk>is_subobj P (C, C' # rev Cs') \\<Longrightarrow>\n                Subobjs P C (C' # rev Cs');\n        is_subobj P (C, C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (C' # rev (a # Cs'))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C (C' # rev [])", "proof (cases \"C=C'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C = C' \\<Longrightarrow> Subobjs P C (C' # rev [])\n 2. C \\<noteq> C' \\<Longrightarrow> Subobjs P C (C' # rev [])", "case True"], ["proof (state)\nthis:\n  C = C'\n\ngoal (2 subgoals):\n 1. C = C' \\<Longrightarrow> Subobjs P C (C' # rev [])\n 2. C \\<noteq> C' \\<Longrightarrow> Subobjs P C (C' # rev [])", "have \"is_subobj P ((C,C'#rev []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subobj P (C, C' # rev [])", "by fact"], ["proof (state)\nthis:\n  is_subobj P (C, C' # rev [])\n\ngoal (2 subgoals):\n 1. C = C' \\<Longrightarrow> Subobjs P C (C' # rev [])\n 2. C \\<noteq> C' \\<Longrightarrow> Subobjs P C (C' # rev [])", "with True"], ["proof (chain)\npicking this:\n  C = C'\n  is_subobj P (C, C' # rev [])", "have \"is_subobj P ((C,[C]))\""], ["proof (prove)\nusing this:\n  C = C'\n  is_subobj P (C, C' # rev [])\n\ngoal (1 subgoal):\n 1. is_subobj P (C, [C])", "by simp"], ["proof (state)\nthis:\n  is_subobj P (C, [C])\n\ngoal (2 subgoals):\n 1. C = C' \\<Longrightarrow> Subobjs P C (C' # rev [])\n 2. C \\<noteq> C' \\<Longrightarrow> Subobjs P C (C' # rev [])", "hence \"is_class P C\""], ["proof (prove)\nusing this:\n  is_subobj P (C, [C])\n\ngoal (1 subgoal):\n 1. is_class P C", "by (fastforce elim:converse_rtranclE dest:subclsS_subcls1 elim:subcls1_class)"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (2 subgoals):\n 1. C = C' \\<Longrightarrow> Subobjs P C (C' # rev [])\n 2. C \\<noteq> C' \\<Longrightarrow> Subobjs P C (C' # rev [])", "with True"], ["proof (chain)\npicking this:\n  C = C'\n  is_class P C", "show ?thesis"], ["proof (prove)\nusing this:\n  C = C'\n  is_class P C\n\ngoal (1 subgoal):\n 1. Subobjs P C (C' # rev [])", "by (fastforce intro:Subobjs_Base)"], ["proof (state)\nthis:\n  Subobjs P C (C' # rev [])\n\ngoal (1 subgoal):\n 1. C \\<noteq> C' \\<Longrightarrow> Subobjs P C (C' # rev [])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<noteq> C' \\<Longrightarrow> Subobjs P C (C' # rev [])", "case False"], ["proof (state)\nthis:\n  C \\<noteq> C'\n\ngoal (1 subgoal):\n 1. C \\<noteq> C' \\<Longrightarrow> Subobjs P C (C' # rev [])", "have \"is_subobj P ((C,C'#rev []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subobj P (C, C' # rev [])", "by fact"], ["proof (state)\nthis:\n  is_subobj P (C, C' # rev [])\n\ngoal (1 subgoal):\n 1. C \\<noteq> C' \\<Longrightarrow> Subobjs P C (C' # rev [])", "with False"], ["proof (chain)\npicking this:\n  C \\<noteq> C'\n  is_subobj P (C, C' # rev [])", "obtain D where sup:\"P \\<turnstile> C \\<preceq>\\<^sup>* D\" and subS:\"P \\<turnstile> D \\<prec>\\<^sub>S C'\""], ["proof (prove)\nusing this:\n  C \\<noteq> C'\n  is_subobj P (C, C' # rev [])\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n         P \\<turnstile> D \\<prec>\\<^sub>S C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> D \\<prec>\\<^sub>S C'\n\ngoal (1 subgoal):\n 1. C \\<noteq> C' \\<Longrightarrow> Subobjs P C (C' # rev [])", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> D \\<prec>\\<^sub>S C'", "have \"is_class P C'\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> D \\<prec>\\<^sub>S C'\n\ngoal (1 subgoal):\n 1. is_class P C'", "by (fastforce dest:subclsS_subcls1 subcls1D class_wf elim:wf_cdecl_supD)"], ["proof (state)\nthis:\n  is_class P C'\n\ngoal (1 subgoal):\n 1. C \\<noteq> C' \\<Longrightarrow> Subobjs P C (C' # rev [])", "hence \"Subobjs\\<^sub>R P C' [C']\""], ["proof (prove)\nusing this:\n  is_class P C'\n\ngoal (1 subgoal):\n 1. Subobjs\\<^sub>R P C' [C']", "by (fastforce elim:SubobjsR_Base)"], ["proof (state)\nthis:\n  Subobjs\\<^sub>R P C' [C']\n\ngoal (1 subgoal):\n 1. C \\<noteq> C' \\<Longrightarrow> Subobjs P C (C' # rev [])", "with sup subS"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> D \\<prec>\\<^sub>S C'\n  Subobjs\\<^sub>R P C' [C']", "have \"Subobjs P C [C']\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> D \\<prec>\\<^sub>S C'\n  Subobjs\\<^sub>R P C' [C']\n\ngoal (1 subgoal):\n 1. Subobjs P C [C']", "by -(erule Subobjs_Sh, simp)"], ["proof (state)\nthis:\n  Subobjs P C [C']\n\ngoal (1 subgoal):\n 1. C \\<noteq> C' \\<Longrightarrow> Subobjs P C (C' # rev [])", "thus ?thesis"], ["proof (prove)\nusing this:\n  Subobjs P C [C']\n\ngoal (1 subgoal):\n 1. Subobjs P C (C' # rev [])", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (C' # rev [])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Subobjs P C (C' # rev [])\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>is_subobj P (C, C' # rev Cs') \\<Longrightarrow>\n                Subobjs P C (C' # rev Cs');\n        is_subobj P (C, C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (C' # rev (a # Cs'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>is_subobj P (C, C' # rev Cs') \\<Longrightarrow>\n                Subobjs P C (C' # rev Cs');\n        is_subobj P (C, C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (C' # rev (a # Cs'))", "case (Cons C'' Cs'')"], ["proof (state)\nthis:\n  is_subobj P (C, C' # rev Cs'') \\<Longrightarrow>\n  Subobjs P C (C' # rev Cs'')\n  is_subobj P (C, C' # rev (C'' # Cs''))\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>is_subobj P (C, C' # rev Cs') \\<Longrightarrow>\n                Subobjs P C (C' # rev Cs');\n        is_subobj P (C, C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (C' # rev (a # Cs'))", "have IH:\"is_subobj P ((C,C'#rev Cs'')) \\<Longrightarrow> Subobjs P C (C'#rev Cs'')\"\n    and subo:\"is_subobj P ((C,C'#rev(C''# Cs'')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_subobj P (C, C' # rev Cs'') \\<Longrightarrow>\n     Subobjs P C (C' # rev Cs'')) &&&\n    is_subobj P (C, C' # rev (C'' # Cs''))", "by fact+"], ["proof (state)\nthis:\n  is_subobj P (C, C' # rev Cs'') \\<Longrightarrow>\n  Subobjs P C (C' # rev Cs'')\n  is_subobj P (C, C' # rev (C'' # Cs''))\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>is_subobj P (C, C' # rev Cs') \\<Longrightarrow>\n                Subobjs P C (C' # rev Cs');\n        is_subobj P (C, C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (C' # rev (a # Cs'))", "obtain Ds' where Ds':\"Ds' = rev Cs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ds'. Ds' = rev Cs'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  Ds' = rev Cs''\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>is_subobj P (C, C' # rev Cs') \\<Longrightarrow>\n                Subobjs P C (C' # rev Cs');\n        is_subobj P (C, C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (C' # rev (a # Cs'))", "obtain D Ds where DDs:\"D#Ds = Ds'@[C'']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D Ds.\n        D # Ds = Ds' @ [C''] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases Ds') auto"], ["proof (state)\nthis:\n  D # Ds = Ds' @ [C'']\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>is_subobj P (C, C' # rev Cs') \\<Longrightarrow>\n                Subobjs P C (C' # rev Cs');\n        is_subobj P (C, C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (C' # rev (a # Cs'))", "with Ds' subo"], ["proof (chain)\npicking this:\n  Ds' = rev Cs''\n  is_subobj P (C, C' # rev (C'' # Cs''))\n  D # Ds = Ds' @ [C'']", "have \"is_subobj P ((C,C'#D#Ds))\""], ["proof (prove)\nusing this:\n  Ds' = rev Cs''\n  is_subobj P (C, C' # rev (C'' # Cs''))\n  D # Ds = Ds' @ [C'']\n\ngoal (1 subgoal):\n 1. is_subobj P (C, C' # D # Ds)", "by simp"], ["proof (state)\nthis:\n  is_subobj P (C, C' # D # Ds)\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>is_subobj P (C, C' # rev Cs') \\<Longrightarrow>\n                Subobjs P C (C' # rev Cs');\n        is_subobj P (C, C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (C' # rev (a # Cs'))", "hence subobl:\"is_subobj P ((C,butlast(C'#D#Ds)))\" \n    and subRbl:\"P \\<turnstile> last(butlast(C'#D#Ds)) \\<prec>\\<^sub>R last(C'#D#Ds)\""], ["proof (prove)\nusing this:\n  is_subobj P (C, C' # D # Ds)\n\ngoal (1 subgoal):\n 1. is_subobj P (C, butlast (C' # D # Ds)) &&&\n    P \\<turnstile> last\n                    (butlast\n                      (C' # D # Ds)) \\<prec>\\<^sub>R last (C' # D # Ds)", "by simp+"], ["proof (state)\nthis:\n  is_subobj P (C, butlast (C' # D # Ds))\n  P \\<turnstile> last\n                  (butlast (C' # D # Ds)) \\<prec>\\<^sub>R last (C' # D # Ds)\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>is_subobj P (C, C' # rev Cs') \\<Longrightarrow>\n                Subobjs P C (C' # rev Cs');\n        is_subobj P (C, C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (C' # rev (a # Cs'))", "with DDs Ds'"], ["proof (chain)\npicking this:\n  D # Ds = Ds' @ [C'']\n  Ds' = rev Cs''\n  is_subobj P (C, butlast (C' # D # Ds))\n  P \\<turnstile> last\n                  (butlast (C' # D # Ds)) \\<prec>\\<^sub>R last (C' # D # Ds)", "have \"is_subobj P ((C,C'#rev Cs''))\""], ["proof (prove)\nusing this:\n  D # Ds = Ds' @ [C'']\n  Ds' = rev Cs''\n  is_subobj P (C, butlast (C' # D # Ds))\n  P \\<turnstile> last\n                  (butlast (C' # D # Ds)) \\<prec>\\<^sub>R last (C' # D # Ds)\n\ngoal (1 subgoal):\n 1. is_subobj P (C, C' # rev Cs'')", "by (simp del: is_subobj.simps)"], ["proof (state)\nthis:\n  is_subobj P (C, C' # rev Cs'')\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>is_subobj P (C, C' # rev Cs') \\<Longrightarrow>\n                Subobjs P C (C' # rev Cs');\n        is_subobj P (C, C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (C' # rev (a # Cs'))", "with IH"], ["proof (chain)\npicking this:\n  is_subobj P (C, C' # rev Cs'') \\<Longrightarrow>\n  Subobjs P C (C' # rev Cs'')\n  is_subobj P (C, C' # rev Cs'')", "have suborev:\"Subobjs P C (C'#rev Cs'')\""], ["proof (prove)\nusing this:\n  is_subobj P (C, C' # rev Cs'') \\<Longrightarrow>\n  Subobjs P C (C' # rev Cs'')\n  is_subobj P (C, C' # rev Cs'')\n\ngoal (1 subgoal):\n 1. Subobjs P C (C' # rev Cs'')", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (C' # rev Cs'')\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>is_subobj P (C, C' # rev Cs') \\<Longrightarrow>\n                Subobjs P C (C' # rev Cs');\n        is_subobj P (C, C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (C' # rev (a # Cs'))", "from subRbl DDs Ds'"], ["proof (chain)\npicking this:\n  P \\<turnstile> last\n                  (butlast (C' # D # Ds)) \\<prec>\\<^sub>R last (C' # D # Ds)\n  D # Ds = Ds' @ [C'']\n  Ds' = rev Cs''", "have subR:\"P \\<turnstile> last(C'#rev Cs'') \\<prec>\\<^sub>R C''\""], ["proof (prove)\nusing this:\n  P \\<turnstile> last\n                  (butlast (C' # D # Ds)) \\<prec>\\<^sub>R last (C' # D # Ds)\n  D # Ds = Ds' @ [C'']\n  Ds' = rev Cs''\n\ngoal (1 subgoal):\n 1. P \\<turnstile> last (C' # rev Cs'') \\<prec>\\<^sub>R C''", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> last (C' # rev Cs'') \\<prec>\\<^sub>R C''\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>is_subobj P (C, C' # rev Cs') \\<Longrightarrow>\n                Subobjs P C (C' # rev Cs');\n        is_subobj P (C, C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (C' # rev (a # Cs'))", "with suborev wf"], ["proof (chain)\npicking this:\n  Subobjs P C (C' # rev Cs'')\n  wf_prog wf_md P\n  P \\<turnstile> last (C' # rev Cs'') \\<prec>\\<^sub>R C''", "show ?case"], ["proof (prove)\nusing this:\n  Subobjs P C (C' # rev Cs'')\n  wf_prog wf_md P\n  P \\<turnstile> last (C' # rev Cs'') \\<prec>\\<^sub>R C''\n\ngoal (1 subgoal):\n 1. Subobjs P C (C' # rev (C'' # Cs''))", "by (fastforce dest:converse_Subobjs_Rep)"], ["proof (state)\nthis:\n  Subobjs P C (C' # rev (C'' # Cs''))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isSubobj_Subobjs:\nassumes subo:\"is_subobj P ((C,Cs))\" and wf:\"wf_prog wf_md P\"\nshows \"Subobjs P C Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C Cs", "using subo"], ["proof (prove)\nusing this:\n  is_subobj P (C, Cs)\n\ngoal (1 subgoal):\n 1. Subobjs P C Cs", "proof (induct Cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_subobj P (C, []) \\<Longrightarrow> Subobjs P C []\n 2. \\<And>a Cs.\n       \\<lbrakk>is_subobj P (C, Cs) \\<Longrightarrow> Subobjs P C Cs;\n        is_subobj P (C, a # Cs)\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (a # Cs)", "case Nil"], ["proof (state)\nthis:\n  is_subobj P (C, [])\n\ngoal (2 subgoals):\n 1. is_subobj P (C, []) \\<Longrightarrow> Subobjs P C []\n 2. \\<And>a Cs.\n       \\<lbrakk>is_subobj P (C, Cs) \\<Longrightarrow> Subobjs P C Cs;\n        is_subobj P (C, a # Cs)\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (a # Cs)", "thus ?case"], ["proof (prove)\nusing this:\n  is_subobj P (C, [])\n\ngoal (1 subgoal):\n 1. Subobjs P C []", "by simp"], ["proof (state)\nthis:\n  Subobjs P C []\n\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>is_subobj P (C, Cs) \\<Longrightarrow> Subobjs P C Cs;\n        is_subobj P (C, a # Cs)\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (a # Cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>is_subobj P (C, Cs) \\<Longrightarrow> Subobjs P C Cs;\n        is_subobj P (C, a # Cs)\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (a # Cs)", "case (Cons C' Cs')"], ["proof (state)\nthis:\n  is_subobj P (C, Cs') \\<Longrightarrow> Subobjs P C Cs'\n  is_subobj P (C, C' # Cs')\n\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>is_subobj P (C, Cs) \\<Longrightarrow> Subobjs P C Cs;\n        is_subobj P (C, a # Cs)\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (a # Cs)", "have subo:\"is_subobj P ((C,C'#Cs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subobj P (C, C' # Cs')", "by fact"], ["proof (state)\nthis:\n  is_subobj P (C, C' # Cs')\n\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>is_subobj P (C, Cs) \\<Longrightarrow> Subobjs P C Cs;\n        is_subobj P (C, a # Cs)\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (a # Cs)", "obtain Cs'' where Cs'':\"Cs'' = rev Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Cs''. Cs'' = rev Cs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  Cs'' = rev Cs'\n\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>is_subobj P (C, Cs) \\<Longrightarrow> Subobjs P C Cs;\n        is_subobj P (C, a # Cs)\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (a # Cs)", "with subo"], ["proof (chain)\npicking this:\n  is_subobj P (C, C' # Cs')\n  Cs'' = rev Cs'", "have \"is_subobj P ((C,C'#rev Cs''))\""], ["proof (prove)\nusing this:\n  is_subobj P (C, C' # Cs')\n  Cs'' = rev Cs'\n\ngoal (1 subgoal):\n 1. is_subobj P (C, C' # rev Cs'')", "by simp"], ["proof (state)\nthis:\n  is_subobj P (C, C' # rev Cs'')\n\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>is_subobj P (C, Cs) \\<Longrightarrow> Subobjs P C Cs;\n        is_subobj P (C, a # Cs)\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (a # Cs)", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  is_subobj P (C, C' # rev Cs'')", "have \"Subobjs P C (C'#rev Cs'')\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  is_subobj P (C, C' # rev Cs'')\n\ngoal (1 subgoal):\n 1. Subobjs P C (C' # rev Cs'')", "by - (rule isSubobj_Subobjs_rev)"], ["proof (state)\nthis:\n  Subobjs P C (C' # rev Cs'')\n\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>is_subobj P (C, Cs) \\<Longrightarrow> Subobjs P C Cs;\n        is_subobj P (C, a # Cs)\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (a # Cs)", "with Cs''"], ["proof (chain)\npicking this:\n  Cs'' = rev Cs'\n  Subobjs P C (C' # rev Cs'')", "show ?case"], ["proof (prove)\nusing this:\n  Cs'' = rev Cs'\n  Subobjs P C (C' # rev Cs'')\n\ngoal (1 subgoal):\n 1. Subobjs P C (C' # Cs')", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (C' # Cs')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isSubobj_eq_Subobjs:\n  \"wf_prog wf_md P \\<Longrightarrow> is_subobj P ((C,Cs)) = (Subobjs P C Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow> is_subobj P (C, Cs) = Subobjs P C Cs", "by(auto elim:isSubobj_Subobjs Subobjs_isSubobj)"], ["", "lemma subo_trans_subcls:\n  assumes subo:\"Subobjs P C (Cs@ C'#rev Cs')\"\n  shows \"\\<forall>C'' \\<in> set Cs'. (C',C'') \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C''\\<in>set Cs'. (C', C'') \\<in> (subcls1 P)\\<^sup>+", "using subo"], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ C' # rev Cs')\n\ngoal (1 subgoal):\n 1. \\<forall>C''\\<in>set Cs'. (C', C'') \\<in> (subcls1 P)\\<^sup>+", "proof (induct Cs')"], ["proof (state)\ngoal (2 subgoals):\n 1. Subobjs P C (Cs @ C' # rev []) \\<Longrightarrow>\n    \\<forall>C''\\<in>set []. (C', C'') \\<in> (subcls1 P)\\<^sup>+\n 2. \\<And>a Cs'.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev Cs') \\<Longrightarrow>\n                \\<forall>C''\\<in>set Cs'.\n                   (C', C'') \\<in> (subcls1 P)\\<^sup>+;\n        Subobjs P C (Cs @ C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C''\\<in>set (a # Cs').\n                            (C', C'') \\<in> (subcls1 P)\\<^sup>+", "case Nil"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ C' # rev [])\n\ngoal (2 subgoals):\n 1. Subobjs P C (Cs @ C' # rev []) \\<Longrightarrow>\n    \\<forall>C''\\<in>set []. (C', C'') \\<in> (subcls1 P)\\<^sup>+\n 2. \\<And>a Cs'.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev Cs') \\<Longrightarrow>\n                \\<forall>C''\\<in>set Cs'.\n                   (C', C'') \\<in> (subcls1 P)\\<^sup>+;\n        Subobjs P C (Cs @ C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C''\\<in>set (a # Cs').\n                            (C', C'') \\<in> (subcls1 P)\\<^sup>+", "thus ?case"], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ C' # rev [])\n\ngoal (1 subgoal):\n 1. \\<forall>C''\\<in>set []. (C', C'') \\<in> (subcls1 P)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  \\<forall>C''\\<in>set []. (C', C'') \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev Cs') \\<Longrightarrow>\n                \\<forall>C''\\<in>set Cs'.\n                   (C', C'') \\<in> (subcls1 P)\\<^sup>+;\n        Subobjs P C (Cs @ C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C''\\<in>set (a # Cs').\n                            (C', C'') \\<in> (subcls1 P)\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev Cs') \\<Longrightarrow>\n                \\<forall>C''\\<in>set Cs'.\n                   (C', C'') \\<in> (subcls1 P)\\<^sup>+;\n        Subobjs P C (Cs @ C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C''\\<in>set (a # Cs').\n                            (C', C'') \\<in> (subcls1 P)\\<^sup>+", "case (Cons D Ds)"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ C' # rev Ds) \\<Longrightarrow>\n  \\<forall>C''\\<in>set Ds. (C', C'') \\<in> (subcls1 P)\\<^sup>+\n  Subobjs P C (Cs @ C' # rev (D # Ds))\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev Cs') \\<Longrightarrow>\n                \\<forall>C''\\<in>set Cs'.\n                   (C', C'') \\<in> (subcls1 P)\\<^sup>+;\n        Subobjs P C (Cs @ C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C''\\<in>set (a # Cs').\n                            (C', C'') \\<in> (subcls1 P)\\<^sup>+", "have IH:\"Subobjs P C (Cs @ C' # rev Ds) \\<Longrightarrow>\n           \\<forall>C''\\<in>set Ds. (C', C'') \\<in> (subcls1 P)\\<^sup>+\"\n    and \"Subobjs P C (Cs @ C' # rev (D # Ds))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Subobjs P C (Cs @ C' # rev Ds) \\<Longrightarrow>\n     \\<forall>C''\\<in>set Ds. (C', C'') \\<in> (subcls1 P)\\<^sup>+) &&&\n    Subobjs P C (Cs @ C' # rev (D # Ds))", "by fact+"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ C' # rev Ds) \\<Longrightarrow>\n  \\<forall>C''\\<in>set Ds. (C', C'') \\<in> (subcls1 P)\\<^sup>+\n  Subobjs P C (Cs @ C' # rev (D # Ds))\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev Cs') \\<Longrightarrow>\n                \\<forall>C''\\<in>set Cs'.\n                   (C', C'') \\<in> (subcls1 P)\\<^sup>+;\n        Subobjs P C (Cs @ C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C''\\<in>set (a # Cs').\n                            (C', C'') \\<in> (subcls1 P)\\<^sup>+", "hence subo':\"Subobjs P C (Cs@ C'#rev Ds @ [D])\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ C' # rev Ds) \\<Longrightarrow>\n  \\<forall>C''\\<in>set Ds. (C', C'') \\<in> (subcls1 P)\\<^sup>+\n  Subobjs P C (Cs @ C' # rev (D # Ds))\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ C' # rev Ds @ [D])", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ C' # rev Ds @ [D])\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev Cs') \\<Longrightarrow>\n                \\<forall>C''\\<in>set Cs'.\n                   (C', C'') \\<in> (subcls1 P)\\<^sup>+;\n        Subobjs P C (Cs @ C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C''\\<in>set (a # Cs').\n                            (C', C'') \\<in> (subcls1 P)\\<^sup>+", "hence \"Subobjs P C (Cs@ C'#rev Ds)\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ C' # rev Ds @ [D])\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ C' # rev Ds)", "by -(rule appendSubobj,simp_all)"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ C' # rev Ds)\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev Cs') \\<Longrightarrow>\n                \\<forall>C''\\<in>set Cs'.\n                   (C', C'') \\<in> (subcls1 P)\\<^sup>+;\n        Subobjs P C (Cs @ C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C''\\<in>set (a # Cs').\n                            (C', C'') \\<in> (subcls1 P)\\<^sup>+", "with IH"], ["proof (chain)\npicking this:\n  Subobjs P C (Cs @ C' # rev Ds) \\<Longrightarrow>\n  \\<forall>C''\\<in>set Ds. (C', C'') \\<in> (subcls1 P)\\<^sup>+\n  Subobjs P C (Cs @ C' # rev Ds)", "have set:\"\\<forall>C''\\<in>set Ds. (C', C'') \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ C' # rev Ds) \\<Longrightarrow>\n  \\<forall>C''\\<in>set Ds. (C', C'') \\<in> (subcls1 P)\\<^sup>+\n  Subobjs P C (Cs @ C' # rev Ds)\n\ngoal (1 subgoal):\n 1. \\<forall>C''\\<in>set Ds. (C', C'') \\<in> (subcls1 P)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  \\<forall>C''\\<in>set Ds. (C', C'') \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev Cs') \\<Longrightarrow>\n                \\<forall>C''\\<in>set Cs'.\n                   (C', C'') \\<in> (subcls1 P)\\<^sup>+;\n        Subobjs P C (Cs @ C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C''\\<in>set (a # Cs').\n                            (C', C'') \\<in> (subcls1 P)\\<^sup>+", "hence revset:\"\\<forall>C''\\<in>set (rev Ds). (C', C'') \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<forall>C''\\<in>set Ds. (C', C'') \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<forall>C''\\<in>set (rev Ds). (C', C'') \\<in> (subcls1 P)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  \\<forall>C''\\<in>set (rev Ds). (C', C'') \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev Cs') \\<Longrightarrow>\n                \\<forall>C''\\<in>set Cs'.\n                   (C', C'') \\<in> (subcls1 P)\\<^sup>+;\n        Subobjs P C (Cs @ C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C''\\<in>set (a # Cs').\n                            (C', C'') \\<in> (subcls1 P)\\<^sup>+", "have \"(C',D) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (C', D) \\<in> (subcls1 P)\\<^sup>+", "proof (cases \"Ds = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Ds = [] \\<Longrightarrow> (C', D) \\<in> (subcls1 P)\\<^sup>+\n 2. Ds \\<noteq> [] \\<Longrightarrow> (C', D) \\<in> (subcls1 P)\\<^sup>+", "case True"], ["proof (state)\nthis:\n  Ds = []\n\ngoal (2 subgoals):\n 1. Ds = [] \\<Longrightarrow> (C', D) \\<in> (subcls1 P)\\<^sup>+\n 2. Ds \\<noteq> [] \\<Longrightarrow> (C', D) \\<in> (subcls1 P)\\<^sup>+", "with subo'"], ["proof (chain)\npicking this:\n  Subobjs P C (Cs @ C' # rev Ds @ [D])\n  Ds = []", "have \"Subobjs P C (Cs@[C',D])\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ C' # rev Ds @ [D])\n  Ds = []\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ [C', D])", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ [C', D])\n\ngoal (2 subgoals):\n 1. Ds = [] \\<Longrightarrow> (C', D) \\<in> (subcls1 P)\\<^sup>+\n 2. Ds \\<noteq> [] \\<Longrightarrow> (C', D) \\<in> (subcls1 P)\\<^sup>+", "thus ?thesis"], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ [C', D])\n\ngoal (1 subgoal):\n 1. (C', D) \\<in> (subcls1 P)\\<^sup>+", "by (fastforce intro: subclsR_subcls1 Subobjs_subclsR)"], ["proof (state)\nthis:\n  (C', D) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. Ds \\<noteq> [] \\<Longrightarrow> (C', D) \\<in> (subcls1 P)\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Ds \\<noteq> [] \\<Longrightarrow> (C', D) \\<in> (subcls1 P)\\<^sup>+", "case False"], ["proof (state)\nthis:\n  Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. Ds \\<noteq> [] \\<Longrightarrow> (C', D) \\<in> (subcls1 P)\\<^sup>+", "with revset"], ["proof (chain)\npicking this:\n  \\<forall>C''\\<in>set (rev Ds). (C', C'') \\<in> (subcls1 P)\\<^sup>+\n  Ds \\<noteq> []", "have hd:\"(C',hd Ds) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  \\<forall>C''\\<in>set (rev Ds). (C', C'') \\<in> (subcls1 P)\\<^sup>+\n  Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. (C', hd Ds) \\<in> (subcls1 P)\\<^sup>+", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>C''\\<in>set (rev Ds).\n                (C', C'') \\<in> (subcls1 P)\\<^sup>+;\n     Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (C', hd Ds) \\<in> (subcls1 P)\\<^sup>+", "apply (erule ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Ds \\<noteq> []; (C', ?C''2) \\<in> (subcls1 P)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> (C', hd Ds) \\<in> (subcls1 P)\\<^sup>+\n 2. \\<lbrakk>Ds \\<noteq> []; ?C''2 \\<notin> set (rev Ds)\\<rbrakk>\n    \\<Longrightarrow> (C', hd Ds) \\<in> (subcls1 P)\\<^sup>+", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ds \\<noteq> []; hd Ds \\<notin> set (rev Ds)\\<rbrakk>\n    \\<Longrightarrow> (C', hd Ds) \\<in> (subcls1 P)\\<^sup>+", "apply (simp add:in_set_conv_decomp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ds \\<noteq> [];\n     \\<forall>ys zs. Ds \\<noteq> ys @ hd Ds # zs\\<rbrakk>\n    \\<Longrightarrow> (C', hd Ds) \\<in> (subcls1 P)\\<^sup>+", "apply (erule_tac x=\"[]\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ds \\<noteq> [];\n     \\<forall>zs. Ds \\<noteq> [] @ hd Ds # zs\\<rbrakk>\n    \\<Longrightarrow> (C', hd Ds) \\<in> (subcls1 P)\\<^sup>+", "apply (erule_tac x=\"tl Ds\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ds \\<noteq> []; Ds \\<noteq> [] @ hd Ds # tl Ds\\<rbrakk>\n    \\<Longrightarrow> (C', hd Ds) \\<in> (subcls1 P)\\<^sup>+", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (C', hd Ds) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. Ds \\<noteq> [] \\<Longrightarrow> (C', D) \\<in> (subcls1 P)\\<^sup>+", "from False subo'"], ["proof (chain)\npicking this:\n  Ds \\<noteq> []\n  Subobjs P C (Cs @ C' # rev Ds @ [D])", "have \"(hd Ds,D) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  Ds \\<noteq> []\n  Subobjs P C (Cs @ C' # rev Ds @ [D])\n\ngoal (1 subgoal):\n 1. (hd Ds, D) \\<in> (subcls1 P)\\<^sup>+", "apply (cases Ds)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Ds \\<noteq> []; Subobjs P C (Cs @ C' # rev Ds @ [D]);\n     Ds = []\\<rbrakk>\n    \\<Longrightarrow> (hd Ds, D) \\<in> (subcls1 P)\\<^sup>+\n 2. \\<And>a list.\n       \\<lbrakk>Ds \\<noteq> []; Subobjs P C (Cs @ C' # rev Ds @ [D]);\n        Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> (hd Ds, D) \\<in> (subcls1 P)\\<^sup>+", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Ds \\<noteq> []; Subobjs P C (Cs @ C' # rev Ds @ [D]);\n        Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> (hd Ds, D) \\<in> (subcls1 P)\\<^sup>+", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev list @ [a, D]);\n        Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> (a, D) \\<in> (subcls1 P)\\<^sup>+", "apply (rule r_into_trancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev list @ [a, D]);\n        Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> a \\<prec>\\<^sup>1 D", "apply (rule subclsR_subcls1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev list @ [a, D]);\n        Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> a \\<prec>\\<^sub>R D", "apply (rule_tac Cs=\"Cs @ C' # rev list\" in Subobjs_subclsR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev list @ [a, D]);\n        Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> Subobjs P (?C7 a list)\n                          ((Cs @ C' # rev list) @ [a, D] @ ?Cs'7 a list)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (hd Ds, D) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. Ds \\<noteq> [] \\<Longrightarrow> (C', D) \\<in> (subcls1 P)\\<^sup>+", "with hd"], ["proof (chain)\npicking this:\n  (C', hd Ds) \\<in> (subcls1 P)\\<^sup>+\n  (hd Ds, D) \\<in> (subcls1 P)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  (C', hd Ds) \\<in> (subcls1 P)\\<^sup>+\n  (hd Ds, D) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (C', D) \\<in> (subcls1 P)\\<^sup>+", "by (rule trancl_trans)"], ["proof (state)\nthis:\n  (C', D) \\<in> (subcls1 P)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (C', D) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>a Cs'.\n       \\<lbrakk>Subobjs P C (Cs @ C' # rev Cs') \\<Longrightarrow>\n                \\<forall>C''\\<in>set Cs'.\n                   (C', C'') \\<in> (subcls1 P)\\<^sup>+;\n        Subobjs P C (Cs @ C' # rev (a # Cs'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C''\\<in>set (a # Cs').\n                            (C', C'') \\<in> (subcls1 P)\\<^sup>+", "with set"], ["proof (chain)\npicking this:\n  \\<forall>C''\\<in>set Ds. (C', C'') \\<in> (subcls1 P)\\<^sup>+\n  (C', D) \\<in> (subcls1 P)\\<^sup>+", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>C''\\<in>set Ds. (C', C'') \\<in> (subcls1 P)\\<^sup>+\n  (C', D) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<forall>C''\\<in>set (D # Ds). (C', C'') \\<in> (subcls1 P)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  \\<forall>C''\\<in>set (D # Ds). (C', C'') \\<in> (subcls1 P)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique1:\n  assumes subo:\"Subobjs P C (Cs@ C'#Cs')\" and wf:\"wf_prog wf_md P\"\n  shows \"C' \\<notin> set Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C' \\<notin> set Cs'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C' \\<notin> set Cs'", "obtain Ds where Ds:\"Ds = rev Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ds. Ds = rev Cs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  Ds = rev Cs'\n\ngoal (1 subgoal):\n 1. C' \\<notin> set Cs'", "with subo"], ["proof (chain)\npicking this:\n  Subobjs P C (Cs @ C' # Cs')\n  Ds = rev Cs'", "have \"Subobjs P C (Cs@ C'#rev Ds)\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ C' # Cs')\n  Ds = rev Cs'\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ C' # rev Ds)", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ C' # rev Ds)\n\ngoal (1 subgoal):\n 1. C' \\<notin> set Cs'", "with Ds subo"], ["proof (chain)\npicking this:\n  Ds = rev Cs'\n  Subobjs P C (Cs @ C' # Cs')\n  Subobjs P C (Cs @ C' # rev Ds)", "have \"\\<forall>C'' \\<in> set Cs'. (C',C'') \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  Ds = rev Cs'\n  Subobjs P C (Cs @ C' # Cs')\n  Subobjs P C (Cs @ C' # rev Ds)\n\ngoal (1 subgoal):\n 1. \\<forall>C''\\<in>set Cs'. (C', C'') \\<in> (subcls1 P)\\<^sup>+", "by (fastforce dest:subo_trans_subcls)"], ["proof (state)\nthis:\n  \\<forall>C''\\<in>set Cs'. (C', C'') \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. C' \\<notin> set Cs'", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  \\<forall>C''\\<in>set Cs'. (C', C'') \\<in> (subcls1 P)\\<^sup>+", "have \"\\<forall>C'' \\<in> set Cs'. C' \\<noteq> C''\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  \\<forall>C''\\<in>set Cs'. (C', C'') \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<forall>C''\\<in>set Cs'. C' \\<noteq> C''", "by (auto dest:subcls_irrefl)"], ["proof (state)\nthis:\n  \\<forall>C''\\<in>set Cs'. C' \\<noteq> C''\n\ngoal (1 subgoal):\n 1. C' \\<notin> set Cs'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>C''\\<in>set Cs'. C' \\<noteq> C''\n\ngoal (1 subgoal):\n 1. C' \\<notin> set Cs'", "by fastforce"], ["proof (state)\nthis:\n  C' \\<notin> set Cs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subo_subcls_trans:\n  assumes subo:\"Subobjs P C (Cs@ C'#Cs')\"\n  shows \"\\<forall>C'' \\<in> set Cs. (C'',C') \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C''\\<in>set Cs. (C'', C') \\<in> (subcls1 P)\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>C''\\<in>set Cs. (C'', C') \\<in> (subcls1 P)\\<^sup>+", "from wf subo"], ["proof (chain)\npicking this:\n  wf {(x, y). x < y}\n  Subobjs P C (Cs @ C' # Cs')", "have \"\\<And>C''. C'' \\<in> set Cs \\<Longrightarrow> (C'',C') \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  wf {(x, y). x < y}\n  Subobjs P C (Cs @ C' # Cs')\n\ngoal (1 subgoal):\n 1. \\<And>C''.\n       C'' \\<in> set Cs \\<Longrightarrow>\n       (C'', C') \\<in> (subcls1 P)\\<^sup>+", "apply (auto simp:in_set_conv_decomp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C'' ys zs.\n       \\<lbrakk>wf {(x, y). x < y}; Subobjs P C (ys @ C'' # zs @ C' # Cs');\n        Cs = ys @ C'' # zs\\<rbrakk>\n       \\<Longrightarrow> (C'', C') \\<in> (subcls1 P)\\<^sup>+", "apply (case_tac zs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C'' ys zs.\n       \\<lbrakk>wf {(x, y). x < y}; Subobjs P C (ys @ C'' # zs @ C' # Cs');\n        Cs = ys @ C'' # zs; zs = []\\<rbrakk>\n       \\<Longrightarrow> (C'', C') \\<in> (subcls1 P)\\<^sup>+\n 2. \\<And>C'' ys zs a list.\n       \\<lbrakk>wf {(x, y). x < y}; Subobjs P C (ys @ C'' # zs @ C' # Cs');\n        Cs = ys @ C'' # zs; zs = a # list\\<rbrakk>\n       \\<Longrightarrow> (C'', C') \\<in> (subcls1 P)\\<^sup>+", "apply (fastforce intro: subclsR_subcls1 Subobjs_subclsR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C'' ys zs a list.\n       \\<lbrakk>wf {(x, y). x < y}; Subobjs P C (ys @ C'' # zs @ C' # Cs');\n        Cs = ys @ C'' # zs; zs = a # list\\<rbrakk>\n       \\<Longrightarrow> (C'', C') \\<in> (subcls1 P)\\<^sup>+", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C'' ys zs a list.\n       \\<lbrakk>wf {(x, y). x < y};\n        Subobjs P C (ys @ C'' # a # list @ C' # Cs');\n        Cs = ys @ C'' # a # list; zs = a # list\\<rbrakk>\n       \\<Longrightarrow> (C'', C') \\<in> (subcls1 P)\\<^sup>+", "apply (rule_tac b=\"a\" in trancl_rtrancl_trancl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C'' ys zs a list.\n       \\<lbrakk>wf {(x, y). x < y};\n        Subobjs P C (ys @ C'' # a # list @ C' # Cs');\n        Cs = ys @ C'' # a # list; zs = a # list\\<rbrakk>\n       \\<Longrightarrow> (C'', a) \\<in> (subcls1 P)\\<^sup>+\n 2. \\<And>C'' ys zs a list.\n       \\<lbrakk>wf {(x, y). x < y};\n        Subobjs P C (ys @ C'' # a # list @ C' # Cs');\n        Cs = ys @ C'' # a # list; zs = a # list\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> a \\<preceq>\\<^sup>* C'", "apply (fastforce intro: subclsR_subcls1 Subobjs_subclsR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C'' ys zs a list.\n       \\<lbrakk>wf {(x, y). x < y};\n        Subobjs P C (ys @ C'' # a # list @ C' # Cs');\n        Cs = ys @ C'' # a # list; zs = a # list\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> a \\<preceq>\\<^sup>* C'", "apply (subgoal_tac \"P \\<turnstile> a \\<preceq>\\<^sup>* last (a # list @ [C'])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C'' ys zs a list.\n       \\<lbrakk>wf {(x, y). x < y};\n        Subobjs P C (ys @ C'' # a # list @ C' # Cs');\n        Cs = ys @ C'' # a # list; zs = a # list;\n        P \\<turnstile> a \\<preceq>\\<^sup>* last (a # list @ [C'])\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> a \\<preceq>\\<^sup>* C'\n 2. \\<And>C'' ys zs a list.\n       \\<lbrakk>wf {(x, y). x < y};\n        Subobjs P C (ys @ C'' # a # list @ C' # Cs');\n        Cs = ys @ C'' # a # list; zs = a # list\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> a \\<preceq>\\<^sup>* last\n                       (a # list @ [C'])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C'' ys zs a list.\n       \\<lbrakk>wf {(x, y). x < y};\n        Subobjs P C (ys @ C'' # a # list @ C' # Cs');\n        Cs = ys @ C'' # a # list; zs = a # list\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> a \\<preceq>\\<^sup>* last\n                       (a # list @ [C'])", "apply (rule Subobjs_subclass)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C'' ys zs a list.\n       \\<lbrakk>wf {(x, y). x < y};\n        Subobjs P C (ys @ C'' # a # list @ C' # Cs');\n        Cs = ys @ C'' # a # list; zs = a # list\\<rbrakk>\n       \\<Longrightarrow> Subobjs P a (a # list @ [C'])", "apply (rule_tac C=\"C\" and Cs=\" ys @[C'']\" in Subobjs_Subobjs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>C'' ys zs a list.\n       \\<lbrakk>wf {(x, y). x < y};\n        Subobjs P C (ys @ C'' # a # list @ C' # Cs');\n        Cs = ys @ C'' # a # list; zs = a # list\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C ((ys @ [C'']) @ a # list @ [C'])", "apply (rule_tac Cs'=\"Cs'\" in appendSubobj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C'' ys zs a list.\n       \\<lbrakk>wf {(x, y). x < y};\n        Subobjs P C (ys @ C'' # a # list @ C' # Cs');\n        Cs = ys @ C'' # a # list; zs = a # list\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C\n                          (((ys @ [C'']) @ a # list @ [C']) @ Cs')\n 2. \\<And>C'' ys zs a list.\n       \\<lbrakk>wf {(x, y). x < y};\n        Subobjs P C (ys @ C'' # a # list @ C' # Cs');\n        Cs = ys @ C'' # a # list; zs = a # list\\<rbrakk>\n       \\<Longrightarrow> (ys @ [C'']) @ a # list @ [C'] \\<noteq> []", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?C'' \\<in> set Cs \\<Longrightarrow> (?C'', C') \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<forall>C''\\<in>set Cs. (C'', C') \\<in> (subcls1 P)\\<^sup>+", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?C'' \\<in> set Cs \\<Longrightarrow> (?C'', C') \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<forall>C''\\<in>set Cs. (C'', C') \\<in> (subcls1 P)\\<^sup>+", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>C''\\<in>set Cs. (C'', C') \\<in> (subcls1 P)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique2:\n  assumes subo:\"Subobjs P C (Cs@ C'#Cs')\" and wf:\"wf_prog wf_md P\"\n  shows \"C' \\<notin> set Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C' \\<notin> set Cs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C' \\<notin> set Cs", "from subo wf"], ["proof (chain)\npicking this:\n  Subobjs P C (Cs @ C' # Cs')\n  wf_prog wf_md P", "have \"\\<forall>C'' \\<in> set Cs. (C'',C') \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ C' # Cs')\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. \\<forall>C''\\<in>set Cs. (C'', C') \\<in> (subcls1 P)\\<^sup>+", "by (fastforce dest:subo_subcls_trans)"], ["proof (state)\nthis:\n  \\<forall>C''\\<in>set Cs. (C'', C') \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. C' \\<notin> set Cs", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  \\<forall>C''\\<in>set Cs. (C'', C') \\<in> (subcls1 P)\\<^sup>+", "have \"\\<forall>C'' \\<in> set Cs. C' \\<noteq> C''\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  \\<forall>C''\\<in>set Cs. (C'', C') \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<forall>C''\\<in>set Cs. C' \\<noteq> C''", "by (auto dest:subcls_irrefl)"], ["proof (state)\nthis:\n  \\<forall>C''\\<in>set Cs. C' \\<noteq> C''\n\ngoal (1 subgoal):\n 1. C' \\<notin> set Cs", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>C''\\<in>set Cs. C' \\<noteq> C''\n\ngoal (1 subgoal):\n 1. C' \\<notin> set Cs", "by fastforce"], ["proof (state)\nthis:\n  C' \\<notin> set Cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mdc_hd_path:\nassumes subo:\"Subobjs P C Cs\" and set:\"C \\<in> set Cs\" and wf:\"wf_prog wf_md P\"\nshows \"C = hd Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C = hd Cs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C = hd Cs", "from subo set"], ["proof (chain)\npicking this:\n  Subobjs P C Cs\n  C \\<in> set Cs", "obtain Ds Ds' where Cs:\"Cs = Ds@ C#Ds'\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n  C \\<in> set Cs\n\ngoal (1 subgoal):\n 1. (\\<And>Ds Ds'.\n        Cs = Ds @ C # Ds' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:in_set_conv_decomp)"], ["proof (state)\nthis:\n  Cs = Ds @ C # Ds'\n\ngoal (1 subgoal):\n 1. C = hd Cs", "then"], ["proof (chain)\npicking this:\n  Cs = Ds @ C # Ds'", "obtain Cs' where Cs':\"Cs' = rev Ds\""], ["proof (prove)\nusing this:\n  Cs = Ds @ C # Ds'\n\ngoal (1 subgoal):\n 1. (\\<And>Cs'. Cs' = rev Ds \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  Cs' = rev Ds\n\ngoal (1 subgoal):\n 1. C = hd Cs", "with Cs subo"], ["proof (chain)\npicking this:\n  Cs = Ds @ C # Ds'\n  Subobjs P C Cs\n  Cs' = rev Ds", "have subo':\"Subobjs P C ((rev Cs')@ C#Ds')\""], ["proof (prove)\nusing this:\n  Cs = Ds @ C # Ds'\n  Subobjs P C Cs\n  Cs' = rev Ds\n\ngoal (1 subgoal):\n 1. Subobjs P C (rev Cs' @ C # Ds')", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (rev Cs' @ C # Ds')\n\ngoal (1 subgoal):\n 1. C = hd Cs", "thus ?thesis"], ["proof (prove)\nusing this:\n  Subobjs P C (rev Cs' @ C # Ds')\n\ngoal (1 subgoal):\n 1. C = hd Cs", "proof (cases Cs')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C (rev Cs' @ C # Ds'); Cs' = []\\<rbrakk>\n    \\<Longrightarrow> C = hd Cs\n 2. \\<And>a list.\n       \\<lbrakk>Subobjs P C (rev Cs' @ C # Ds'); Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> C = hd Cs", "case Nil"], ["proof (state)\nthis:\n  Cs' = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C (rev Cs' @ C # Ds'); Cs' = []\\<rbrakk>\n    \\<Longrightarrow> C = hd Cs\n 2. \\<And>a list.\n       \\<lbrakk>Subobjs P C (rev Cs' @ C # Ds'); Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> C = hd Cs", "with Cs Cs'"], ["proof (chain)\npicking this:\n  Cs = Ds @ C # Ds'\n  Cs' = rev Ds\n  Cs' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  Cs = Ds @ C # Ds'\n  Cs' = rev Ds\n  Cs' = []\n\ngoal (1 subgoal):\n 1. C = hd Cs", "by simp"], ["proof (state)\nthis:\n  C = hd Cs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P C (rev Cs' @ C # Ds'); Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> C = hd Cs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P C (rev Cs' @ C # Ds'); Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> C = hd Cs", "case (Cons X Xs)"], ["proof (state)\nthis:\n  Cs' = X # Xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P C (rev Cs' @ C # Ds'); Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> C = hd Cs", "with subo'"], ["proof (chain)\npicking this:\n  Subobjs P C (rev Cs' @ C # Ds')\n  Cs' = X # Xs", "have suboX:\"Subobjs P C ((rev Xs)@[X,C]@Ds')\""], ["proof (prove)\nusing this:\n  Subobjs P C (rev Cs' @ C # Ds')\n  Cs' = X # Xs\n\ngoal (1 subgoal):\n 1. Subobjs P C (rev Xs @ [X, C] @ Ds')", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (rev Xs @ [X, C] @ Ds')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P C (rev Cs' @ C # Ds'); Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> C = hd Cs", "hence leq:\"P \\<turnstile> X \\<prec>\\<^sup>1 C\""], ["proof (prove)\nusing this:\n  Subobjs P C (rev Xs @ [X, C] @ Ds')\n\ngoal (1 subgoal):\n 1. P \\<turnstile> X \\<prec>\\<^sup>1 C", "by (fastforce intro:subclsR_subcls1 Subobjs_subclsR)"], ["proof (state)\nthis:\n  P \\<turnstile> X \\<prec>\\<^sup>1 C\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P C (rev Cs' @ C # Ds'); Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> C = hd Cs", "from suboX wf"], ["proof (chain)\npicking this:\n  Subobjs P C (rev Xs @ [X, C] @ Ds')\n  wf_prog wf_md P", "have \"P \\<turnstile> C \\<preceq>\\<^sup>* last ((rev Xs)@[X])\""], ["proof (prove)\nusing this:\n  Subobjs P C (rev Xs @ [X, C] @ Ds')\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* last (rev Xs @ [X])", "by (fastforce intro:Subobjs_subclass appendSubobj)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* last (rev Xs @ [X])\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P C (rev Cs' @ C # Ds'); Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> C = hd Cs", "with leq"], ["proof (chain)\npicking this:\n  P \\<turnstile> X \\<prec>\\<^sup>1 C\n  P \\<turnstile> C \\<preceq>\\<^sup>* last (rev Xs @ [X])", "have \"(C,C) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  P \\<turnstile> X \\<prec>\\<^sup>1 C\n  P \\<turnstile> C \\<preceq>\\<^sup>* last (rev Xs @ [X])\n\ngoal (1 subgoal):\n 1. (C, C) \\<in> (subcls1 P)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (C, C) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P C (rev Cs' @ C # Ds'); Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> C = hd Cs", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  (C, C) \\<in> (subcls1 P)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  (C, C) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. C = hd Cs", "by (fastforce dest:subcls_irrefl)"], ["proof (state)\nthis:\n  C = hd Cs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C = hd Cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mdc_eq_last:\n  assumes subo:\"Subobjs P C Cs\" and last:\"last Cs = C\" and wf:\"wf_prog wf_md P\"\nshows \"Cs = [C]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs = [C]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Cs = [C]", "from subo"], ["proof (chain)\npicking this:\n  Subobjs P C Cs", "have notempty:\"Cs \\<noteq> []\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n\ngoal (1 subgoal):\n 1. Cs \\<noteq> []", "by - (drule Subobjs_nonempty)"], ["proof (state)\nthis:\n  Cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Cs = [C]", "hence lastset:\"last Cs \\<in> set Cs\""], ["proof (prove)\nusing this:\n  Cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. last Cs \\<in> set Cs", "apply (auto simp add:in_set_conv_decomp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs \\<noteq> [] \\<Longrightarrow> \\<exists>ys zs. Cs = ys @ last Cs # zs", "apply (rule_tac x=\"butlast Cs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs \\<noteq> [] \\<Longrightarrow>\n    \\<exists>zs. Cs = butlast Cs @ last Cs # zs", "apply (rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs \\<noteq> [] \\<Longrightarrow> Cs = butlast Cs @ [last Cs]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  last Cs \\<in> set Cs\n\ngoal (1 subgoal):\n 1. Cs = [C]", "with last"], ["proof (chain)\npicking this:\n  last Cs = C\n  last Cs \\<in> set Cs", "have C:\"C \\<in> set Cs\""], ["proof (prove)\nusing this:\n  last Cs = C\n  last Cs \\<in> set Cs\n\ngoal (1 subgoal):\n 1. C \\<in> set Cs", "by simp"], ["proof (state)\nthis:\n  C \\<in> set Cs\n\ngoal (1 subgoal):\n 1. Cs = [C]", "with subo wf"], ["proof (chain)\npicking this:\n  Subobjs P C Cs\n  wf_prog wf_md P\n  C \\<in> set Cs", "have hd:\"C = hd Cs\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n  wf_prog wf_md P\n  C \\<in> set Cs\n\ngoal (1 subgoal):\n 1. C = hd Cs", "by -(rule mdc_hd_path)"], ["proof (state)\nthis:\n  C = hd Cs\n\ngoal (1 subgoal):\n 1. Cs = [C]", "then"], ["proof (chain)\npicking this:\n  C = hd Cs", "obtain Cs' where Cs':\"Cs' = tl Cs\""], ["proof (prove)\nusing this:\n  C = hd Cs\n\ngoal (1 subgoal):\n 1. (\\<And>Cs'. Cs' = tl Cs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  Cs' = tl Cs\n\ngoal (1 subgoal):\n 1. Cs = [C]", "thus ?thesis"], ["proof (prove)\nusing this:\n  Cs' = tl Cs\n\ngoal (1 subgoal):\n 1. Cs = [C]", "proof (cases Cs')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cs' = tl Cs; Cs' = []\\<rbrakk> \\<Longrightarrow> Cs = [C]\n 2. \\<And>a list.\n       \\<lbrakk>Cs' = tl Cs; Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> Cs = [C]", "case Nil"], ["proof (state)\nthis:\n  Cs' = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Cs' = tl Cs; Cs' = []\\<rbrakk> \\<Longrightarrow> Cs = [C]\n 2. \\<And>a list.\n       \\<lbrakk>Cs' = tl Cs; Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> Cs = [C]", "with hd subo Cs'"], ["proof (chain)\npicking this:\n  C = hd Cs\n  Subobjs P C Cs\n  Cs' = tl Cs\n  Cs' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  C = hd Cs\n  Subobjs P C Cs\n  Cs' = tl Cs\n  Cs' = []\n\ngoal (1 subgoal):\n 1. Cs = [C]", "by (fastforce dest:Subobjs_nonempty hd_Cons_tl)"], ["proof (state)\nthis:\n  Cs = [C]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = tl Cs; Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> Cs = [C]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = tl Cs; Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> Cs = [C]", "case (Cons D Ds)"], ["proof (state)\nthis:\n  Cs' = D # Ds\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = tl Cs; Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> Cs = [C]", "with Cs' hd notempty"], ["proof (chain)\npicking this:\n  Cs' = tl Cs\n  C = hd Cs\n  Cs \\<noteq> []\n  Cs' = D # Ds", "have Cs:\"Cs=C#D#Ds\""], ["proof (prove)\nusing this:\n  Cs' = tl Cs\n  C = hd Cs\n  Cs \\<noteq> []\n  Cs' = D # Ds\n\ngoal (1 subgoal):\n 1. Cs = C # D # Ds", "by simp"], ["proof (state)\nthis:\n  Cs = C # D # Ds\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = tl Cs; Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> Cs = [C]", "with subo"], ["proof (chain)\npicking this:\n  Subobjs P C Cs\n  Cs = C # D # Ds", "have \"Subobjs P C (C#D#Ds)\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n  Cs = C # D # Ds\n\ngoal (1 subgoal):\n 1. Subobjs P C (C # D # Ds)", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (C # D # Ds)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = tl Cs; Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> Cs = [C]", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  Subobjs P C (C # D # Ds)", "have notset:\"C \\<notin> set (D#Ds)\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  Subobjs P C (C # D # Ds)\n\ngoal (1 subgoal):\n 1. C \\<notin> set (D # Ds)", "by -(rule_tac Cs=\"[]\" in unique1,simp_all)"], ["proof (state)\nthis:\n  C \\<notin> set (D # Ds)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = tl Cs; Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> Cs = [C]", "from Cs last"], ["proof (chain)\npicking this:\n  Cs = C # D # Ds\n  last Cs = C", "have \"last Cs = last (D#Ds)\""], ["proof (prove)\nusing this:\n  Cs = C # D # Ds\n  last Cs = C\n\ngoal (1 subgoal):\n 1. last Cs = last (D # Ds)", "by simp"], ["proof (state)\nthis:\n  last Cs = last (D # Ds)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = tl Cs; Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> Cs = [C]", "hence \"last Cs \\<in> set (D#Ds)\""], ["proof (prove)\nusing this:\n  last Cs = last (D # Ds)\n\ngoal (1 subgoal):\n 1. last Cs \\<in> set (D # Ds)", "apply (auto simp add:in_set_conv_decomp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>last Cs = last Ds; Ds \\<noteq> [];\n     \\<forall>ys zs. Ds \\<noteq> ys @ last Ds # zs\\<rbrakk>\n    \\<Longrightarrow> last Ds = D", "apply (erule_tac x=\"butlast Ds\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>last Cs = last Ds; Ds \\<noteq> [];\n     \\<forall>zs. Ds \\<noteq> butlast Ds @ last Ds # zs\\<rbrakk>\n    \\<Longrightarrow> last Ds = D", "apply (erule_tac x=\"[]\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>last Cs = last Ds; Ds \\<noteq> [];\n     Ds \\<noteq> butlast Ds @ [last Ds]\\<rbrakk>\n    \\<Longrightarrow> last Ds = D", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  last Cs \\<in> set (D # Ds)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = tl Cs; Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> Cs = [C]", "with last"], ["proof (chain)\npicking this:\n  last Cs = C\n  last Cs \\<in> set (D # Ds)", "have \"C \\<in> set (D#Ds)\""], ["proof (prove)\nusing this:\n  last Cs = C\n  last Cs \\<in> set (D # Ds)\n\ngoal (1 subgoal):\n 1. C \\<in> set (D # Ds)", "by simp"], ["proof (state)\nthis:\n  C \\<in> set (D # Ds)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = tl Cs; Cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> Cs = [C]", "with notset"], ["proof (chain)\npicking this:\n  C \\<notin> set (D # Ds)\n  C \\<in> set (D # Ds)", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<notin> set (D # Ds)\n  C \\<in> set (D # Ds)\n\ngoal (1 subgoal):\n 1. Cs = [C]", "by simp"], ["proof (state)\nthis:\n  Cs = [C]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cs = [C]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes leq:\"P \\<turnstile> C \\<preceq>\\<^sup>* D\" and wf:\"wf_prog wf_md P\"\n  shows subcls_leq_path:\"\\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs@[D]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [D]", "using leq"], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [D]", "proof (induct rule:rtrancl.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [a]\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "fix C"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [a]\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "show \"\\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs@[C]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C]", "by (rule_tac x=\"[]\" in exI,simp)"], ["proof (state)\nthis:\n  \\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C]\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "fix C C' D"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "assume leq':\"P \\<turnstile> C \\<preceq>\\<^sup>* C'\" and IH:\"\\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs@[C']\"\n    and sub:\"P \\<turnstile> C' \\<prec>\\<^sup>1 D\""], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* C'\n  \\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C']\n  P \\<turnstile> C' \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "from sub"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' \\<prec>\\<^sup>1 D", "have \"is_class P C'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' \\<prec>\\<^sup>1 D\n\ngoal (1 subgoal):\n 1. is_class P C'", "by (rule subcls1_class)"], ["proof (state)\nthis:\n  is_class P C'\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "with leq'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* C'\n  is_class P C'", "have \"class\": \"is_class P C\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* C'\n  is_class P C'\n\ngoal (1 subgoal):\n 1. is_class P C", "by (rule subcls_is_class)"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "from IH"], ["proof (chain)\npicking this:\n  \\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C']", "obtain Cs where steps:\"P,C \\<turnstile> [C] \\<sqsubseteq> Cs@[C']\""], ["proof (prove)\nusing this:\n  \\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C']\n\ngoal (1 subgoal):\n 1. (\\<And>Cs.\n        P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C'] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C']\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "hence subo:\"Subobjs P C (Cs@[C'])\""], ["proof (prove)\nusing this:\n  P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C']\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ [C'])", "using \"class\" wf"], ["proof (prove)\nusing this:\n  P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C']\n  is_class P C\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ [C'])", "by (fastforce intro:leq_path_Subobjs)"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ [C'])\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "{"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ [C'])\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "assume \"P \\<turnstile> C' \\<prec>\\<^sub>R D\""], ["proof (state)\nthis:\n  P \\<turnstile> C' \\<prec>\\<^sub>R D\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "with subo wf"], ["proof (chain)\npicking this:\n  Subobjs P C (Cs @ [C'])\n  wf_prog wf_md P\n  P \\<turnstile> C' \\<prec>\\<^sub>R D", "have \"Subobjs P C (Cs@[C',D])\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ [C'])\n  wf_prog wf_md P\n  P \\<turnstile> C' \\<prec>\\<^sub>R D\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ [C', D])", "by (fastforce dest:converse_Subobjs_Rep)"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ [C', D])\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "with subo"], ["proof (chain)\npicking this:\n  Subobjs P C (Cs @ [C'])\n  Subobjs P C (Cs @ [C', D])", "have \"P,C \\<turnstile> (Cs@[C']) \\<sqsubset>\\<^sup>1 (Cs@[C']@[D])\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ [C'])\n  Subobjs P C (Cs @ [C', D])\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 Cs @ [C'] @ [D]", "by (fastforce intro:leq_path_rep)"], ["proof (state)\nthis:\n  P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 Cs @ [C'] @ [D]\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "}"], ["proof (state)\nthis:\n  P \\<turnstile> C' \\<prec>\\<^sub>R D \\<Longrightarrow>\n  P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 Cs @ [C'] @ [D]\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "moreover"], ["proof (state)\nthis:\n  P \\<turnstile> C' \\<prec>\\<^sub>R D \\<Longrightarrow>\n  P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 Cs @ [C'] @ [D]\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "{"], ["proof (state)\nthis:\n  P \\<turnstile> C' \\<prec>\\<^sub>R D \\<Longrightarrow>\n  P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 Cs @ [C'] @ [D]\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "assume \"P \\<turnstile> C' \\<prec>\\<^sub>S D\""], ["proof (state)\nthis:\n  P \\<turnstile> C' \\<prec>\\<^sub>S D\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "with subo"], ["proof (chain)\npicking this:\n  Subobjs P C (Cs @ [C'])\n  P \\<turnstile> C' \\<prec>\\<^sub>S D", "have \"P,C \\<turnstile> (Cs@[C']) \\<sqsubset>\\<^sup>1 [D]\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ [C'])\n  P \\<turnstile> C' \\<prec>\\<^sub>S D\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 [D]", "by (rule leq_path_sh)"], ["proof (state)\nthis:\n  P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 [D]\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "}"], ["proof (state)\nthis:\n  P \\<turnstile> C' \\<prec>\\<^sub>S D \\<Longrightarrow>\n  P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 [D]\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<exists>Cs. P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [b];\n        P \\<turnstile> b \\<prec>\\<^sup>1 c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs.\n                            P,a \\<turnstile> [a] \\<sqsubseteq> Cs @ [c]", "ultimately"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' \\<prec>\\<^sub>R D \\<Longrightarrow>\n  P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 Cs @ [C'] @ [D]\n  P \\<turnstile> C' \\<prec>\\<^sub>S D \\<Longrightarrow>\n  P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 [D]", "show \"\\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs@[D]\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' \\<prec>\\<^sub>R D \\<Longrightarrow>\n  P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 Cs @ [C'] @ [D]\n  P \\<turnstile> C' \\<prec>\\<^sub>S D \\<Longrightarrow>\n  P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 [D]\n\ngoal (1 subgoal):\n 1. \\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [D]", "using sub steps"], ["proof (prove)\nusing this:\n  P \\<turnstile> C' \\<prec>\\<^sub>R D \\<Longrightarrow>\n  P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 Cs @ [C'] @ [D]\n  P \\<turnstile> C' \\<prec>\\<^sub>S D \\<Longrightarrow>\n  P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 [D]\n  P \\<turnstile> C' \\<prec>\\<^sup>1 D\n  P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C']\n\ngoal (1 subgoal):\n 1. \\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [D]", "apply (auto dest!:subcls1_subclsR_or_subclsS)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 Cs @ [C', D];\n     P \\<turnstile> C' \\<prec>\\<^sub>S D \\<Longrightarrow>\n     P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 [D];\n     P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C'];\n     P \\<turnstile> C' \\<prec>\\<^sub>R D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs.\n                         P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [D]\n 2. \\<lbrakk>P \\<turnstile> C' \\<prec>\\<^sub>R D \\<Longrightarrow>\n             P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 Cs @ [C', D];\n     P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 [D];\n     P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C'];\n     P \\<turnstile> C' \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs.\n                         P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [D]", "apply (rule_tac x=\"Cs@[C']\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 Cs @ [C', D];\n     P \\<turnstile> C' \\<prec>\\<^sub>S D \\<Longrightarrow>\n     P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 [D];\n     P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C'];\n     P \\<turnstile> C' \\<prec>\\<^sub>R D\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> (Cs @ [C']) @ [D]\n 2. \\<lbrakk>P \\<turnstile> C' \\<prec>\\<^sub>R D \\<Longrightarrow>\n             P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 Cs @ [C', D];\n     P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 [D];\n     P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C'];\n     P \\<turnstile> C' \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs.\n                         P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [D]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C' \\<prec>\\<^sub>R D \\<Longrightarrow>\n             P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 Cs @ [C', D];\n     P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 [D];\n     P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C'];\n     P \\<turnstile> C' \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs.\n                         P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [D]", "apply (rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C' \\<prec>\\<^sub>R D \\<Longrightarrow>\n             P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 Cs @ [C', D];\n     P,C \\<turnstile> (Cs @ [C']) \\<sqsubset>\\<^sup>1 [D];\n     P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [C'];\n     P \\<turnstile> C' \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> [] @ [D]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>Cs. P,C \\<turnstile> [C] \\<sqsubseteq> Cs @ [D]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes subo:\"Subobjs P C (rev Cs)\" and wf:\"wf_prog wf_md P\"\n  shows subobjs_rel_rev:\"P,C \\<turnstile> [C] \\<sqsubseteq> (rev Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs", "using subo"], ["proof (prove)\nusing this:\n  Subobjs P C (rev Cs)\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs", "proof (induct Cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. Subobjs P C (rev []) \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev []\n 2. \\<And>a Cs.\n       \\<lbrakk>Subobjs P C (rev Cs) \\<Longrightarrow>\n                P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs;\n        Subobjs P C (rev (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (a # Cs)", "case Nil"], ["proof (state)\nthis:\n  Subobjs P C (rev [])\n\ngoal (2 subgoals):\n 1. Subobjs P C (rev []) \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev []\n 2. \\<And>a Cs.\n       \\<lbrakk>Subobjs P C (rev Cs) \\<Longrightarrow>\n                P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs;\n        Subobjs P C (rev (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (a # Cs)", "thus ?case"], ["proof (prove)\nusing this:\n  Subobjs P C (rev [])\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> rev []", "by (fastforce dest:Subobjs_nonempty)"], ["proof (state)\nthis:\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev []\n\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>Subobjs P C (rev Cs) \\<Longrightarrow>\n                P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs;\n        Subobjs P C (rev (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (a # Cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>Subobjs P C (rev Cs) \\<Longrightarrow>\n                P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs;\n        Subobjs P C (rev (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (a # Cs)", "case (Cons C' Cs')"], ["proof (state)\nthis:\n  Subobjs P C (rev Cs') \\<Longrightarrow>\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'\n  Subobjs P C (rev (C' # Cs'))\n\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>Subobjs P C (rev Cs) \\<Longrightarrow>\n                P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs;\n        Subobjs P C (rev (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (a # Cs)", "have subo':\"Subobjs P C (rev (C'#Cs'))\"\n    and IH:\"Subobjs P C (rev Cs') \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C (rev (C' # Cs')) &&&\n    (Subobjs P C (rev Cs') \\<Longrightarrow>\n     P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs')", "by fact+"], ["proof (state)\nthis:\n  Subobjs P C (rev (C' # Cs'))\n  Subobjs P C (rev Cs') \\<Longrightarrow>\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'\n\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>Subobjs P C (rev Cs) \\<Longrightarrow>\n                P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs;\n        Subobjs P C (rev (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (a # Cs)", "from subo'"], ["proof (chain)\npicking this:\n  Subobjs P C (rev (C' # Cs'))", "have \"class\": \"is_class P C\""], ["proof (prove)\nusing this:\n  Subobjs P C (rev (C' # Cs'))\n\ngoal (1 subgoal):\n 1. is_class P C", "by(rule Subobjs_isClass)"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>Subobjs P C (rev Cs) \\<Longrightarrow>\n                P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs;\n        Subobjs P C (rev (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (a # Cs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "proof (cases \"Cs' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Cs' = [] \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')\n 2. Cs' \\<noteq> [] \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "case True"], ["proof (state)\nthis:\n  Cs' = []\n\ngoal (2 subgoals):\n 1. Cs' = [] \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')\n 2. Cs' \\<noteq> [] \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "hence empty:\"Cs' = []\""], ["proof (prove)\nusing this:\n  Cs' = []\n\ngoal (1 subgoal):\n 1. Cs' = []", "."], ["proof (state)\nthis:\n  Cs' = []\n\ngoal (2 subgoals):\n 1. Cs' = [] \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')\n 2. Cs' \\<noteq> [] \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "with subo'"], ["proof (chain)\npicking this:\n  Subobjs P C (rev (C' # Cs'))\n  Cs' = []", "have subo'':\"Subobjs P C [C']\""], ["proof (prove)\nusing this:\n  Subobjs P C (rev (C' # Cs'))\n  Cs' = []\n\ngoal (1 subgoal):\n 1. Subobjs P C [C']", "by simp"], ["proof (state)\nthis:\n  Subobjs P C [C']\n\ngoal (2 subgoals):\n 1. Cs' = [] \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')\n 2. Cs' \\<noteq> [] \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "thus ?thesis"], ["proof (prove)\nusing this:\n  Subobjs P C [C']\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "proof (cases \"C = C'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C [C']; C = C'\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')\n 2. \\<lbrakk>Subobjs P C [C']; C \\<noteq> C'\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "case True"], ["proof (state)\nthis:\n  C = C'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C [C']; C = C'\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')\n 2. \\<lbrakk>Subobjs P C [C']; C \\<noteq> C'\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "with empty"], ["proof (chain)\npicking this:\n  Cs' = []\n  C = C'", "show ?thesis"], ["proof (prove)\nusing this:\n  Cs' = []\n  C = C'\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "by simp"], ["proof (state)\nthis:\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C [C']; C \\<noteq> C'\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C [C']; C \\<noteq> C'\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "case False"], ["proof (state)\nthis:\n  C \\<noteq> C'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C [C']; C \\<noteq> C'\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "with subo''"], ["proof (chain)\npicking this:\n  Subobjs P C [C']\n  C \\<noteq> C'", "obtain D D' where leq:\"P \\<turnstile> C \\<preceq>\\<^sup>* D\" and subS:\"P \\<turnstile> D \\<prec>\\<^sub>S D'\"\n        and suboR:\"Subobjs\\<^sub>R P D' [C']\""], ["proof (prove)\nusing this:\n  Subobjs P C [C']\n  C \\<noteq> C'\n\ngoal (1 subgoal):\n 1. (\\<And>D D'.\n        \\<lbrakk>P \\<turnstile> C \\<preceq>\\<^sup>* D;\n         P \\<turnstile> D \\<prec>\\<^sub>S D';\n         Subobjs\\<^sub>R P D' [C']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim:Subobjs.cases dest:hd_SubobjsR)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  P \\<turnstile> D \\<prec>\\<^sub>S D'\n  Subobjs\\<^sub>R P D' [C']\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C [C']; C \\<noteq> C'\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "from suboR"], ["proof (chain)\npicking this:\n  Subobjs\\<^sub>R P D' [C']", "have C':\"C' = D'\""], ["proof (prove)\nusing this:\n  Subobjs\\<^sub>R P D' [C']\n\ngoal (1 subgoal):\n 1. C' = D'", "by (fastforce dest:hd_SubobjsR)"], ["proof (state)\nthis:\n  C' = D'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C [C']; C \\<noteq> C'\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "from leq wf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  wf_prog wf_md P", "obtain Ds where steps:\"P,C \\<turnstile> [C] \\<sqsubseteq> Ds@[D]\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. (\\<And>Ds.\n        P,C \\<turnstile> [C] \\<sqsubseteq> Ds @ [D] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto dest:subcls_leq_path)"], ["proof (state)\nthis:\n  P,C \\<turnstile> [C] \\<sqsubseteq> Ds @ [D]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C [C']; C \\<noteq> C'\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "hence suboSteps:\"Subobjs P C (Ds@[D])\""], ["proof (prove)\nusing this:\n  P,C \\<turnstile> [C] \\<sqsubseteq> Ds @ [D]\n\ngoal (1 subgoal):\n 1. Subobjs P C (Ds @ [D])", "using \"class\" wf"], ["proof (prove)\nusing this:\n  P,C \\<turnstile> [C] \\<sqsubseteq> Ds @ [D]\n  is_class P C\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. Subobjs P C (Ds @ [D])", "apply (induct rule:rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_class P C; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> Subobjs P C [C]\n 2. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> [C] \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        \\<lbrakk>is_class P C; wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> Subobjs P C y;\n        is_class P C; wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C z", "apply (erule Subobjs_Base)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> [C] \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        \\<lbrakk>is_class P C; wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> Subobjs P C y;\n        is_class P C; wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C z", "apply (auto elim!:leq_path1.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Cs D.\n       \\<lbrakk>P,C \\<turnstile> [C] \\<sqsubseteq> Cs; is_class P C;\n        wf_prog wf_md P; Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C [D]", "apply (subgoal_tac \"Subobjs\\<^sub>R P D [D]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Cs D.\n       \\<lbrakk>P,C \\<turnstile> [C] \\<sqsubseteq> Cs; is_class P C;\n        wf_prog wf_md P; Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D;\n        Subobjs\\<^sub>R P D [D]\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C [D]\n 2. \\<And>Cs D.\n       \\<lbrakk>P,C \\<turnstile> [C] \\<sqsubseteq> Cs; is_class P C;\n        wf_prog wf_md P; Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> Subobjs\\<^sub>R P D [D]", "apply (fastforce dest:Subobjs_subclass intro:Subobjs_Sh)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Cs D.\n       \\<lbrakk>P,C \\<turnstile> [C] \\<sqsubseteq> Cs; is_class P C;\n        wf_prog wf_md P; Subobjs P C Cs;\n        P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n       \\<Longrightarrow> Subobjs\\<^sub>R P D [D]", "apply (fastforce dest!:subclsSD intro:SubobjsR_Base wf_cdecl_supD \n                                             class_wf ShBaseclass_isBaseclass)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Subobjs P C (Ds @ [D])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C [C']; C \\<noteq> C'\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "hence step:\"P,C \\<turnstile> (Ds@[D]) \\<sqsubset>\\<^sup>1 [D']\""], ["proof (prove)\nusing this:\n  Subobjs P C (Ds @ [D])\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> (Ds @ [D]) \\<sqsubset>\\<^sup>1 [D']", "using subS"], ["proof (prove)\nusing this:\n  Subobjs P C (Ds @ [D])\n  P \\<turnstile> D \\<prec>\\<^sub>S D'\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> (Ds @ [D]) \\<sqsubset>\\<^sup>1 [D']", "by (rule leq_path_sh)"], ["proof (state)\nthis:\n  P,C \\<turnstile> (Ds @ [D]) \\<sqsubset>\\<^sup>1 [D']\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C [C']; C \\<noteq> C'\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "with steps empty False C'"], ["proof (chain)\npicking this:\n  P,C \\<turnstile> [C] \\<sqsubseteq> Ds @ [D]\n  Cs' = []\n  C \\<noteq> C'\n  C' = D'\n  P,C \\<turnstile> (Ds @ [D]) \\<sqsubset>\\<^sup>1 [D']", "show ?thesis"], ["proof (prove)\nusing this:\n  P,C \\<turnstile> [C] \\<sqsubseteq> Ds @ [D]\n  Cs' = []\n  C \\<noteq> C'\n  C' = D'\n  P,C \\<turnstile> (Ds @ [D]) \\<sqsubset>\\<^sup>1 [D']\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "by simp"], ["proof (state)\nthis:\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')\n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> [] \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Cs' \\<noteq> [] \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "case False"], ["proof (state)\nthis:\n  Cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> [] \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "with subo'"], ["proof (chain)\npicking this:\n  Subobjs P C (rev (C' # Cs'))\n  Cs' \\<noteq> []", "have subo'':\"Subobjs P C (rev Cs')\""], ["proof (prove)\nusing this:\n  Subobjs P C (rev (C' # Cs'))\n  Cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. Subobjs P C (rev Cs')", "by (fastforce intro:butlast_Subobjs)"], ["proof (state)\nthis:\n  Subobjs P C (rev Cs')\n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> [] \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "with IH"], ["proof (chain)\npicking this:\n  Subobjs P C (rev Cs') \\<Longrightarrow>\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'\n  Subobjs P C (rev Cs')", "have steps:\"P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'\""], ["proof (prove)\nusing this:\n  Subobjs P C (rev Cs') \\<Longrightarrow>\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'\n  Subobjs P C (rev Cs')\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'", "by simp"], ["proof (state)\nthis:\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'\n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> [] \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "from subo' subo''"], ["proof (chain)\npicking this:\n  Subobjs P C (rev (C' # Cs'))\n  Subobjs P C (rev Cs')", "have \"P,C \\<turnstile> rev Cs' \\<sqsubset>\\<^sup>1 rev (C'#Cs')\""], ["proof (prove)\nusing this:\n  Subobjs P C (rev (C' # Cs'))\n  Subobjs P C (rev Cs')\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> rev Cs' \\<sqsubset>\\<^sup>1 rev (C' # Cs')", "by (fastforce intro:leq_pathRep)"], ["proof (state)\nthis:\n  P,C \\<turnstile> rev Cs' \\<sqsubset>\\<^sup>1 rev (C' # Cs')\n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> [] \\<Longrightarrow>\n    P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "with steps"], ["proof (chain)\npicking this:\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'\n  P,C \\<turnstile> rev Cs' \\<sqsubset>\\<^sup>1 rev (C' # Cs')", "show ?thesis"], ["proof (prove)\nusing this:\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'\n  P,C \\<turnstile> rev Cs' \\<sqsubset>\\<^sup>1 rev (C' # Cs')\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')", "by simp"], ["proof (state)\nthis:\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev (C' # Cs')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subobjs_rel:\nassumes subo:\"Subobjs P C Cs\" and wf:\"wf_prog wf_md P\"\nshows \"P,C \\<turnstile> [C] \\<sqsubseteq> Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> Cs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> Cs", "obtain Cs' where Cs':\"Cs' = rev Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Cs'. Cs' = rev Cs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  Cs' = rev Cs\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> Cs", "with subo"], ["proof (chain)\npicking this:\n  Subobjs P C Cs\n  Cs' = rev Cs", "have \"Subobjs P C (rev Cs')\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n  Cs' = rev Cs\n\ngoal (1 subgoal):\n 1. Subobjs P C (rev Cs')", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (rev Cs')\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> Cs", "hence \"P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'\""], ["proof (prove)\nusing this:\n  Subobjs P C (rev Cs')\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'", "using wf"], ["proof (prove)\nusing this:\n  Subobjs P C (rev Cs')\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'", "by (rule subobjs_rel_rev)"], ["proof (state)\nthis:\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> Cs", "with Cs'"], ["proof (chain)\npicking this:\n  Cs' = rev Cs\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  Cs' = rev Cs\n  P,C \\<turnstile> [C] \\<sqsubseteq> rev Cs'\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> [C] \\<sqsubseteq> Cs", "by simp"], ["proof (state)\nthis:\n  P,C \\<turnstile> [C] \\<sqsubseteq> Cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes wf:\"wf_prog wf_md P\"\n  shows leq_path_last:\"\\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> Cs'; last Cs = last Cs'\\<rbrakk> \\<Longrightarrow> Cs = Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     last Cs = last Cs'\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'", "proof(induct rule:rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. last Cs = last Cs \\<Longrightarrow> Cs = Cs\n 2. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "show \"Cs = Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs = Cs", "by simp"], ["proof (state)\nthis:\n  Cs = Cs\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "fix Cs' Cs''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "assume leqs:\"P,C \\<turnstile> Cs \\<sqsubseteq> Cs'\" and leq:\"P,C \\<turnstile> Cs' \\<sqsubset>\\<^sup>1 Cs''\"\n    and last:\"last Cs = last Cs''\"\n    and IH:\"last Cs = last Cs' \\<Longrightarrow> Cs = Cs'\""], ["proof (state)\nthis:\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs'\n  P,C \\<turnstile> Cs' \\<sqsubset>\\<^sup>1 Cs''\n  last Cs = last Cs''\n  last Cs = last Cs' \\<Longrightarrow> Cs = Cs'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "from leq wf"], ["proof (chain)\npicking this:\n  P,C \\<turnstile> Cs' \\<sqsubset>\\<^sup>1 Cs''\n  wf_prog wf_md P", "have sup1:\"P \\<turnstile> last Cs' \\<prec>\\<^sup>1 last Cs''\""], ["proof (prove)\nusing this:\n  P,C \\<turnstile> Cs' \\<sqsubset>\\<^sup>1 Cs''\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. P \\<turnstile> last Cs' \\<prec>\\<^sup>1 last Cs''", "by(rule last_leq_path)"], ["proof (state)\nthis:\n  P \\<turnstile> last Cs' \\<prec>\\<^sup>1 last Cs''\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "{"], ["proof (state)\nthis:\n  P \\<turnstile> last Cs' \\<prec>\\<^sup>1 last Cs''\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "assume \"Cs = Cs'\""], ["proof (state)\nthis:\n  Cs = Cs'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "with last"], ["proof (chain)\npicking this:\n  last Cs = last Cs''\n  Cs = Cs'", "have eq:\"last Cs'' = last Cs'\""], ["proof (prove)\nusing this:\n  last Cs = last Cs''\n  Cs = Cs'\n\ngoal (1 subgoal):\n 1. last Cs'' = last Cs'", "by simp"], ["proof (state)\nthis:\n  last Cs'' = last Cs'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "with eq wf sup1"], ["proof (chain)\npicking this:\n  last Cs'' = last Cs'\n  wf_prog wf_md P\n  P \\<turnstile> last Cs' \\<prec>\\<^sup>1 last Cs''\n  last Cs'' = last Cs'", "have \"Cs = Cs''\""], ["proof (prove)\nusing this:\n  last Cs'' = last Cs'\n  wf_prog wf_md P\n  P \\<turnstile> last Cs' \\<prec>\\<^sup>1 last Cs''\n  last Cs'' = last Cs'\n\ngoal (1 subgoal):\n 1. Cs = Cs''", "by(fastforce dest:subcls1_wfD)"], ["proof (state)\nthis:\n  Cs = Cs''\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "}"], ["proof (state)\nthis:\n  Cs = Cs' \\<Longrightarrow> Cs = Cs''\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "moreover"], ["proof (state)\nthis:\n  Cs = Cs' \\<Longrightarrow> Cs = Cs''\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "{"], ["proof (state)\nthis:\n  Cs = Cs' \\<Longrightarrow> Cs = Cs''\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "assume \"(Cs,Cs') \\<in> (leq_path1 P C)\\<^sup>+\""], ["proof (state)\nthis:\n  (Cs, Cs') \\<in> (leq_path1 P C)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "hence sub:\"(last Cs,last Cs') \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (Cs, Cs') \\<in> (leq_path1 P C)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (last Cs, last Cs') \\<in> (subcls1 P)\\<^sup>+", "using wf"], ["proof (prove)\nusing this:\n  (Cs, Cs') \\<in> (leq_path1 P C)\\<^sup>+\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. (last Cs, last Cs') \\<in> (subcls1 P)\\<^sup>+", "by(rule last_leq_paths)"], ["proof (state)\nthis:\n  (last Cs, last Cs') \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "with sup1 last"], ["proof (chain)\npicking this:\n  P \\<turnstile> last Cs' \\<prec>\\<^sup>1 last Cs''\n  last Cs = last Cs''\n  (last Cs, last Cs') \\<in> (subcls1 P)\\<^sup>+", "have \"(last Cs'',last Cs'') \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  P \\<turnstile> last Cs' \\<prec>\\<^sup>1 last Cs''\n  last Cs = last Cs''\n  (last Cs, last Cs') \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (last Cs'', last Cs'') \\<in> (subcls1 P)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (last Cs'', last Cs'') \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  (last Cs'', last Cs'') \\<in> (subcls1 P)\\<^sup>+", "have \"Cs = Cs''\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  (last Cs'', last Cs'') \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. Cs = Cs''", "by(fastforce dest:subcls_irrefl)"], ["proof (state)\nthis:\n  Cs = Cs''\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "}"], ["proof (state)\nthis:\n  (Cs, Cs') \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow> Cs = Cs''\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>P,C \\<turnstile> Cs \\<sqsubseteq> y;\n        P,C \\<turnstile> y \\<sqsubset>\\<^sup>1 z;\n        last Cs = last y \\<Longrightarrow> Cs = y; last Cs = last z\\<rbrakk>\n       \\<Longrightarrow> Cs = z", "ultimately"], ["proof (chain)\npicking this:\n  Cs = Cs' \\<Longrightarrow> Cs = Cs''\n  (Cs, Cs') \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow> Cs = Cs''", "show \"Cs = Cs''\""], ["proof (prove)\nusing this:\n  Cs = Cs' \\<Longrightarrow> Cs = Cs''\n  (Cs, Cs') \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow> Cs = Cs''\n\ngoal (1 subgoal):\n 1. Cs = Cs''", "using leqs"], ["proof (prove)\nusing this:\n  Cs = Cs' \\<Longrightarrow> Cs = Cs''\n  (Cs, Cs') \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow> Cs = Cs''\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs'\n\ngoal (1 subgoal):\n 1. Cs = Cs''", "by(fastforce dest:rtranclD)"], ["proof (state)\nthis:\n  Cs = Cs''\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Well-formedness and appendPath\\<close>"], ["", "lemma appendPath1:\n  \"\\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds\\<rbrakk>\n\\<Longrightarrow> Subobjs P C Ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;\n     last Cs \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> Subobjs P C Ds", "apply(subgoal_tac \"\\<not> Subobjs\\<^sub>R P (last Cs) Ds\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n     \\<not> Subobjs\\<^sub>R P (last Cs) Ds\\<rbrakk>\n    \\<Longrightarrow> Subobjs P C Ds\n 2. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;\n     last Cs \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> \\<not> Subobjs\\<^sub>R P (last Cs) Ds", "apply (subgoal_tac \"\\<exists>C' D. P \\<turnstile> last Cs \\<preceq>\\<^sup>* C' \\<and> P \\<turnstile> C' \\<prec>\\<^sub>S D \\<and> Subobjs\\<^sub>R P D Ds\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n     \\<not> Subobjs\\<^sub>R P (last Cs) Ds;\n     \\<exists>C' D.\n        P \\<turnstile> last Cs \\<preceq>\\<^sup>* C' \\<and>\n        P \\<turnstile> C' \\<prec>\\<^sub>S D \\<and>\n        Subobjs\\<^sub>R P D Ds\\<rbrakk>\n    \\<Longrightarrow> Subobjs P C Ds\n 2. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n     \\<not> Subobjs\\<^sub>R P (last Cs) Ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C' D.\n                         P \\<turnstile> last Cs \\<preceq>\\<^sup>* C' \\<and>\n                         P \\<turnstile> C' \\<prec>\\<^sub>S D \\<and>\n                         Subobjs\\<^sub>R P D Ds\n 3. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;\n     last Cs \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> \\<not> Subobjs\\<^sub>R P (last Cs) Ds", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>C' D.\n       \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;\n        last Cs \\<noteq> hd Ds; \\<not> Subobjs\\<^sub>R P (last Cs) Ds;\n        P \\<turnstile> last Cs \\<preceq>\\<^sup>* C';\n        P \\<turnstile> C' \\<prec>\\<^sub>S D; Subobjs\\<^sub>R P D Ds\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Ds\n 2. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n     \\<not> Subobjs\\<^sub>R P (last Cs) Ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C' D.\n                         P \\<turnstile> last Cs \\<preceq>\\<^sup>* C' \\<and>\n                         P \\<turnstile> C' \\<prec>\\<^sub>S D \\<and>\n                         Subobjs\\<^sub>R P D Ds\n 3. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;\n     last Cs \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> \\<not> Subobjs\\<^sub>R P (last Cs) Ds", "apply (drule Subobjs_subclass)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>C' D.\n       \\<lbrakk>Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n        \\<not> Subobjs\\<^sub>R P (last Cs) Ds;\n        P \\<turnstile> last Cs \\<preceq>\\<^sup>* C';\n        P \\<turnstile> C' \\<prec>\\<^sub>S D; Subobjs\\<^sub>R P D Ds;\n        P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Ds\n 2. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n     \\<not> Subobjs\\<^sub>R P (last Cs) Ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C' D.\n                         P \\<turnstile> last Cs \\<preceq>\\<^sup>* C' \\<and>\n                         P \\<turnstile> C' \\<prec>\\<^sub>S D \\<and>\n                         Subobjs\\<^sub>R P D Ds\n 3. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;\n     last Cs \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> \\<not> Subobjs\\<^sub>R P (last Cs) Ds", "apply (subgoal_tac \"P \\<turnstile> C \\<preceq>\\<^sup>* C'\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>C' D.\n       \\<lbrakk>Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n        \\<not> Subobjs\\<^sub>R P (last Cs) Ds;\n        P \\<turnstile> last Cs \\<preceq>\\<^sup>* C';\n        P \\<turnstile> C' \\<prec>\\<^sub>S D; Subobjs\\<^sub>R P D Ds;\n        P \\<turnstile> C \\<preceq>\\<^sup>* last Cs;\n        P \\<turnstile> C \\<preceq>\\<^sup>* C'\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C Ds\n 2. \\<And>C' D.\n       \\<lbrakk>Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n        \\<not> Subobjs\\<^sub>R P (last Cs) Ds;\n        P \\<turnstile> last Cs \\<preceq>\\<^sup>* C';\n        P \\<turnstile> C' \\<prec>\\<^sub>S D; Subobjs\\<^sub>R P D Ds;\n        P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* C'\n 3. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n     \\<not> Subobjs\\<^sub>R P (last Cs) Ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C' D.\n                         P \\<turnstile> last Cs \\<preceq>\\<^sup>* C' \\<and>\n                         P \\<turnstile> C' \\<prec>\\<^sub>S D \\<and>\n                         Subobjs\\<^sub>R P D Ds\n 4. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;\n     last Cs \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> \\<not> Subobjs\\<^sub>R P (last Cs) Ds", "apply (erule_tac C'=\"C'\" and D=\"D\" in Subobjs_Sh)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>C' D.\n       \\<lbrakk>Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n        \\<not> Subobjs\\<^sub>R P (last Cs) Ds;\n        P \\<turnstile> last Cs \\<preceq>\\<^sup>* C';\n        P \\<turnstile> C' \\<prec>\\<^sub>S D; Subobjs\\<^sub>R P D Ds;\n        P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C' \\<prec>\\<^sub>S D\n 2. \\<And>C' D.\n       \\<lbrakk>Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n        \\<not> Subobjs\\<^sub>R P (last Cs) Ds;\n        P \\<turnstile> last Cs \\<preceq>\\<^sup>* C';\n        P \\<turnstile> C' \\<prec>\\<^sub>S D; Subobjs\\<^sub>R P D Ds;\n        P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\\<rbrakk>\n       \\<Longrightarrow> Subobjs\\<^sub>R P D Ds\n 3. \\<And>C' D.\n       \\<lbrakk>Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n        \\<not> Subobjs\\<^sub>R P (last Cs) Ds;\n        P \\<turnstile> last Cs \\<preceq>\\<^sup>* C';\n        P \\<turnstile> C' \\<prec>\\<^sub>S D; Subobjs\\<^sub>R P D Ds;\n        P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* C'\n 4. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n     \\<not> Subobjs\\<^sub>R P (last Cs) Ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C' D.\n                         P \\<turnstile> last Cs \\<preceq>\\<^sup>* C' \\<and>\n                         P \\<turnstile> C' \\<prec>\\<^sub>S D \\<and>\n                         Subobjs\\<^sub>R P D Ds\n 5. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;\n     last Cs \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> \\<not> Subobjs\\<^sub>R P (last Cs) Ds", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>C' D.\n       \\<lbrakk>Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n        \\<not> Subobjs\\<^sub>R P (last Cs) Ds;\n        P \\<turnstile> last Cs \\<preceq>\\<^sup>* C';\n        P \\<turnstile> C' \\<prec>\\<^sub>S D; Subobjs\\<^sub>R P D Ds;\n        P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\\<rbrakk>\n       \\<Longrightarrow> Subobjs\\<^sub>R P D Ds\n 2. \\<And>C' D.\n       \\<lbrakk>Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n        \\<not> Subobjs\\<^sub>R P (last Cs) Ds;\n        P \\<turnstile> last Cs \\<preceq>\\<^sup>* C';\n        P \\<turnstile> C' \\<prec>\\<^sub>S D; Subobjs\\<^sub>R P D Ds;\n        P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* C'\n 3. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n     \\<not> Subobjs\\<^sub>R P (last Cs) Ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C' D.\n                         P \\<turnstile> last Cs \\<preceq>\\<^sup>* C' \\<and>\n                         P \\<turnstile> C' \\<prec>\\<^sub>S D \\<and>\n                         Subobjs\\<^sub>R P D Ds\n 4. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;\n     last Cs \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> \\<not> Subobjs\\<^sub>R P (last Cs) Ds", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>C' D.\n       \\<lbrakk>Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n        \\<not> Subobjs\\<^sub>R P (last Cs) Ds;\n        P \\<turnstile> last Cs \\<preceq>\\<^sup>* C';\n        P \\<turnstile> C' \\<prec>\\<^sub>S D; Subobjs\\<^sub>R P D Ds;\n        P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> C \\<preceq>\\<^sup>* C'\n 2. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n     \\<not> Subobjs\\<^sub>R P (last Cs) Ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C' D.\n                         P \\<turnstile> last Cs \\<preceq>\\<^sup>* C' \\<and>\n                         P \\<turnstile> C' \\<prec>\\<^sub>S D \\<and>\n                         Subobjs\\<^sub>R P D Ds\n 3. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;\n     last Cs \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> \\<not> Subobjs\\<^sub>R P (last Cs) Ds", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds; last Cs \\<noteq> hd Ds;\n     \\<not> Subobjs\\<^sub>R P (last Cs) Ds\\<rbrakk>\n    \\<Longrightarrow> \\<exists>C' D.\n                         P \\<turnstile> last Cs \\<preceq>\\<^sup>* C' \\<and>\n                         P \\<turnstile> C' \\<prec>\\<^sub>S D \\<and>\n                         Subobjs\\<^sub>R P D Ds\n 2. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;\n     last Cs \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> \\<not> Subobjs\\<^sub>R P (last Cs) Ds", "apply (erule Subobjs_notSubobjsR)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C Cs; last Cs \\<noteq> hd Ds;\n     \\<not> Subobjs\\<^sub>R P (last Cs) Ds\\<rbrakk>\n    \\<Longrightarrow> \\<not> Subobjs\\<^sub>R P (last Cs) Ds\n 2. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;\n     last Cs \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> \\<not> Subobjs\\<^sub>R P (last Cs) Ds", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;\n     last Cs \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> \\<not> Subobjs\\<^sub>R P (last Cs) Ds", "apply (fastforce dest:hd_SubobjsR)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma appendPath2_rev:\nassumes subo1:\"Subobjs P C Cs\" and subo2:\"Subobjs P (last Cs) (last Cs#rev Ds)\"\n  and wf:\"wf_prog wf_md P\"\nshows \"Subobjs P C (Cs@(tl (last Cs#rev Ds)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ tl (last Cs # rev Ds))", "using subo2"], ["proof (prove)\nusing this:\n  Subobjs P (last Cs) (last Cs # rev Ds)\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ tl (last Cs # rev Ds))", "proof (induct Ds)"], ["proof (state)\ngoal (2 subgoals):\n 1. Subobjs P (last Cs) (last Cs # rev []) \\<Longrightarrow>\n    Subobjs P C (Cs @ tl (last Cs # rev []))\n 2. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "case Nil"], ["proof (state)\nthis:\n  Subobjs P (last Cs) (last Cs # rev [])\n\ngoal (2 subgoals):\n 1. Subobjs P (last Cs) (last Cs # rev []) \\<Longrightarrow>\n    Subobjs P C (Cs @ tl (last Cs # rev []))\n 2. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "with subo1"], ["proof (chain)\npicking this:\n  Subobjs P C Cs\n  Subobjs P (last Cs) (last Cs # rev [])", "show ?case"], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n  Subobjs P (last Cs) (last Cs # rev [])\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ tl (last Cs # rev []))", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ tl (last Cs # rev []))\n\ngoal (1 subgoal):\n 1. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "case (Cons D' Ds')"], ["proof (state)\nthis:\n  Subobjs P (last Cs) (last Cs # rev Ds') \\<Longrightarrow>\n  Subobjs P C (Cs @ tl (last Cs # rev Ds'))\n  Subobjs P (last Cs) (last Cs # rev (D' # Ds'))\n\ngoal (1 subgoal):\n 1. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "have IH:\"Subobjs P (last Cs) (last Cs#rev Ds')\n    \\<Longrightarrow> Subobjs P C (Cs@tl(last Cs#rev Ds'))\"\n    and subo:\"Subobjs P (last Cs) (last Cs#rev (D'#Ds'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Subobjs P (last Cs) (last Cs # rev Ds') \\<Longrightarrow>\n     Subobjs P C (Cs @ tl (last Cs # rev Ds'))) &&&\n    Subobjs P (last Cs) (last Cs # rev (D' # Ds'))", "by fact+"], ["proof (state)\nthis:\n  Subobjs P (last Cs) (last Cs # rev Ds') \\<Longrightarrow>\n  Subobjs P C (Cs @ tl (last Cs # rev Ds'))\n  Subobjs P (last Cs) (last Cs # rev (D' # Ds'))\n\ngoal (1 subgoal):\n 1. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "from subo"], ["proof (chain)\npicking this:\n  Subobjs P (last Cs) (last Cs # rev (D' # Ds'))", "have \"Subobjs P (last Cs) (last Cs#rev Ds')\""], ["proof (prove)\nusing this:\n  Subobjs P (last Cs) (last Cs # rev (D' # Ds'))\n\ngoal (1 subgoal):\n 1. Subobjs P (last Cs) (last Cs # rev Ds')", "by (fastforce intro:butlast_Subobjs)"], ["proof (state)\nthis:\n  Subobjs P (last Cs) (last Cs # rev Ds')\n\ngoal (1 subgoal):\n 1. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "with IH"], ["proof (chain)\npicking this:\n  Subobjs P (last Cs) (last Cs # rev Ds') \\<Longrightarrow>\n  Subobjs P C (Cs @ tl (last Cs # rev Ds'))\n  Subobjs P (last Cs) (last Cs # rev Ds')", "have subo':\"Subobjs P C (Cs@tl(last Cs#rev Ds'))\""], ["proof (prove)\nusing this:\n  Subobjs P (last Cs) (last Cs # rev Ds') \\<Longrightarrow>\n  Subobjs P C (Cs @ tl (last Cs # rev Ds'))\n  Subobjs P (last Cs) (last Cs # rev Ds')\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ tl (last Cs # rev Ds'))", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ tl (last Cs # rev Ds'))\n\ngoal (1 subgoal):\n 1. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "have last:\"last(last Cs#rev Ds') = last (Cs@tl(last Cs#rev Ds'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (last Cs # rev Ds') = last (Cs @ tl (last Cs # rev Ds'))", "by (cases Ds')auto"], ["proof (state)\nthis:\n  last (last Cs # rev Ds') = last (Cs @ tl (last Cs # rev Ds'))\n\ngoal (1 subgoal):\n 1. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "obtain C' Cs' where C':\"C' = last(last Cs#rev Ds')\" and\n    \"Cs' = butlast(last Cs#rev Ds')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C' Cs'.\n        \\<lbrakk>C' = last (last Cs # rev Ds');\n         Cs' = butlast (last Cs # rev Ds')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  C' = last (last Cs # rev Ds')\n  Cs' = butlast (last Cs # rev Ds')\n\ngoal (1 subgoal):\n 1. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "then"], ["proof (chain)\npicking this:\n  C' = last (last Cs # rev Ds')\n  Cs' = butlast (last Cs # rev Ds')", "have \"Cs' @ [C'] = last Cs # rev Ds'\""], ["proof (prove)\nusing this:\n  C' = last (last Cs # rev Ds')\n  Cs' = butlast (last Cs # rev Ds')\n\ngoal (1 subgoal):\n 1. Cs' @ [C'] = last Cs # rev Ds'", "using append_butlast_last_id"], ["proof (prove)\nusing this:\n  C' = last (last Cs # rev Ds')\n  Cs' = butlast (last Cs # rev Ds')\n  ?xs \\<noteq> [] \\<Longrightarrow> butlast ?xs @ [last ?xs] = ?xs\n\ngoal (1 subgoal):\n 1. Cs' @ [C'] = last Cs # rev Ds'", "by blast"], ["proof (state)\nthis:\n  Cs' @ [C'] = last Cs # rev Ds'\n\ngoal (1 subgoal):\n 1. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "hence \"last Cs#rev (D'#Ds') = Cs'@[C',D']\""], ["proof (prove)\nusing this:\n  Cs' @ [C'] = last Cs # rev Ds'\n\ngoal (1 subgoal):\n 1. last Cs # rev (D' # Ds') = Cs' @ [C', D']", "by simp"], ["proof (state)\nthis:\n  last Cs # rev (D' # Ds') = Cs' @ [C', D']\n\ngoal (1 subgoal):\n 1. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "with subo"], ["proof (chain)\npicking this:\n  Subobjs P (last Cs) (last Cs # rev (D' # Ds'))\n  last Cs # rev (D' # Ds') = Cs' @ [C', D']", "have \"Subobjs P (last Cs) (Cs'@[C',D'])\""], ["proof (prove)\nusing this:\n  Subobjs P (last Cs) (last Cs # rev (D' # Ds'))\n  last Cs # rev (D' # Ds') = Cs' @ [C', D']\n\ngoal (1 subgoal):\n 1. Subobjs P (last Cs) (Cs' @ [C', D'])", "by (cases Cs') auto"], ["proof (state)\nthis:\n  Subobjs P (last Cs) (Cs' @ [C', D'])\n\ngoal (1 subgoal):\n 1. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "hence \"P \\<turnstile> C' \\<prec>\\<^sub>R D'\""], ["proof (prove)\nusing this:\n  Subobjs P (last Cs) (Cs' @ [C', D'])\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C' \\<prec>\\<^sub>R D'", "by - (rule Subobjs_subclsR,simp)"], ["proof (state)\nthis:\n  P \\<turnstile> C' \\<prec>\\<^sub>R D'\n\ngoal (1 subgoal):\n 1. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "with C' last"], ["proof (chain)\npicking this:\n  C' = last (last Cs # rev Ds')\n  last (last Cs # rev Ds') = last (Cs @ tl (last Cs # rev Ds'))\n  P \\<turnstile> C' \\<prec>\\<^sub>R D'", "have \"P \\<turnstile> last (Cs@tl(last Cs#rev Ds')) \\<prec>\\<^sub>R D'\""], ["proof (prove)\nusing this:\n  C' = last (last Cs # rev Ds')\n  last (last Cs # rev Ds') = last (Cs @ tl (last Cs # rev Ds'))\n  P \\<turnstile> C' \\<prec>\\<^sub>R D'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> last (Cs @ tl (last Cs # rev Ds')) \\<prec>\\<^sub>R D'", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> last (Cs @ tl (last Cs # rev Ds')) \\<prec>\\<^sub>R D'\n\ngoal (1 subgoal):\n 1. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "with subo' wf"], ["proof (chain)\npicking this:\n  Subobjs P C (Cs @ tl (last Cs # rev Ds'))\n  wf_prog wf_md P\n  P \\<turnstile> last (Cs @ tl (last Cs # rev Ds')) \\<prec>\\<^sub>R D'", "have \"Subobjs P C ((Cs@tl(last Cs#rev Ds'))@[D'])\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ tl (last Cs # rev Ds'))\n  wf_prog wf_md P\n  P \\<turnstile> last (Cs @ tl (last Cs # rev Ds')) \\<prec>\\<^sub>R D'\n\ngoal (1 subgoal):\n 1. Subobjs P C ((Cs @ tl (last Cs # rev Ds')) @ [D'])", "by (erule_tac Cs=\"(Cs@tl(last Cs#rev Ds'))\" in converse_Subobjs_Rep) simp"], ["proof (state)\nthis:\n  Subobjs P C ((Cs @ tl (last Cs # rev Ds')) @ [D'])\n\ngoal (1 subgoal):\n 1. \\<And>a Ds.\n       \\<lbrakk>Subobjs P (last Cs) (last Cs # rev Ds) \\<Longrightarrow>\n                Subobjs P C (Cs @ tl (last Cs # rev Ds));\n        Subobjs P (last Cs) (last Cs # rev (a # Ds))\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl (last Cs # rev (a # Ds)))", "thus ?case"], ["proof (prove)\nusing this:\n  Subobjs P C ((Cs @ tl (last Cs # rev Ds')) @ [D'])\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ tl (last Cs # rev (D' # Ds')))", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ tl (last Cs # rev (D' # Ds')))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma appendPath2:\nassumes subo1:\"Subobjs P C Cs\" and subo2:\"Subobjs P (last Cs) Ds\" \n  and eq:\"last Cs = hd Ds\" and wf:\"wf_prog wf_md P\"\nshows \"Subobjs P C (Cs@(tl Ds))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ tl Ds)", "using subo2"], ["proof (prove)\nusing this:\n  Subobjs P (last Cs) Ds\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ tl Ds)", "proof (cases Ds)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P (last Cs) Ds; Ds = []\\<rbrakk>\n    \\<Longrightarrow> Subobjs P C (Cs @ tl Ds)\n 2. \\<And>a list.\n       \\<lbrakk>Subobjs P (last Cs) Ds; Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl Ds)", "case Nil"], ["proof (state)\nthis:\n  Ds = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P (last Cs) Ds; Ds = []\\<rbrakk>\n    \\<Longrightarrow> Subobjs P C (Cs @ tl Ds)\n 2. \\<And>a list.\n       \\<lbrakk>Subobjs P (last Cs) Ds; Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl Ds)", "with subo1"], ["proof (chain)\npicking this:\n  Subobjs P C Cs\n  Ds = []", "show ?thesis"], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n  Ds = []\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ tl Ds)", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ tl Ds)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P (last Cs) Ds; Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl Ds)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P (last Cs) Ds; Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl Ds)", "case (Cons D' Ds')"], ["proof (state)\nthis:\n  Ds = D' # Ds'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P (last Cs) Ds; Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl Ds)", "with subo2 eq"], ["proof (chain)\npicking this:\n  Subobjs P (last Cs) Ds\n  last Cs = hd Ds\n  Ds = D' # Ds'", "have subo:\"Subobjs P (last Cs) (last Cs#Ds')\""], ["proof (prove)\nusing this:\n  Subobjs P (last Cs) Ds\n  last Cs = hd Ds\n  Ds = D' # Ds'\n\ngoal (1 subgoal):\n 1. Subobjs P (last Cs) (last Cs # Ds')", "by simp"], ["proof (state)\nthis:\n  Subobjs P (last Cs) (last Cs # Ds')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P (last Cs) Ds; Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl Ds)", "obtain Ds'' where Ds'':\"Ds'' = rev Ds'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ds''. Ds'' = rev Ds' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  Ds'' = rev Ds'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P (last Cs) Ds; Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl Ds)", "with subo"], ["proof (chain)\npicking this:\n  Subobjs P (last Cs) (last Cs # Ds')\n  Ds'' = rev Ds'", "have \"Subobjs P (last Cs) (last Cs#rev Ds'')\""], ["proof (prove)\nusing this:\n  Subobjs P (last Cs) (last Cs # Ds')\n  Ds'' = rev Ds'\n\ngoal (1 subgoal):\n 1. Subobjs P (last Cs) (last Cs # rev Ds'')", "by simp"], ["proof (state)\nthis:\n  Subobjs P (last Cs) (last Cs # rev Ds'')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P (last Cs) Ds; Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl Ds)", "with subo1 wf"], ["proof (chain)\npicking this:\n  Subobjs P C Cs\n  wf_prog wf_md P\n  Subobjs P (last Cs) (last Cs # rev Ds'')", "have \"Subobjs P C (Cs@(tl (last Cs#rev Ds'')))\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n  wf_prog wf_md P\n  Subobjs P (last Cs) (last Cs # rev Ds'')\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ tl (last Cs # rev Ds''))", "by -(rule appendPath2_rev)"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ tl (last Cs # rev Ds''))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Subobjs P (last Cs) Ds; Ds = a # list\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C (Cs @ tl Ds)", "with Ds'' eq Cons"], ["proof (chain)\npicking this:\n  Ds'' = rev Ds'\n  last Cs = hd Ds\n  Ds = D' # Ds'\n  Subobjs P C (Cs @ tl (last Cs # rev Ds''))", "show ?thesis"], ["proof (prove)\nusing this:\n  Ds'' = rev Ds'\n  last Cs = hd Ds\n  Ds = D' # Ds'\n  Subobjs P C (Cs @ tl (last Cs # rev Ds''))\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ tl Ds)", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ tl Ds)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Subobjs_appendPath:\n  \"\\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;wf_prog wf_md P\\<rbrakk>\n\\<Longrightarrow> Subobjs P C (Cs@\\<^sub>pDs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C Cs; Subobjs P (last Cs) Ds;\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> Subobjs P C (Cs @\\<^sub>p Ds)", "by(fastforce elim:appendPath2 appendPath1 simp:appendPath_def)"], ["", "subsection\\<open>Path and program size\\<close>"], ["", "lemma assumes subo:\"Subobjs P C Cs\" and wf:\"wf_prog wf_md P\"\n  shows path_contains_classes:\"\\<forall>C' \\<in> set Cs. is_class P C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C'\\<in>set Cs. is_class P C'", "using subo"], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n\ngoal (1 subgoal):\n 1. \\<forall>C'\\<in>set Cs. is_class P C'", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C'.\n       \\<lbrakk>Subobjs P C Cs; C' \\<in> set Cs\\<rbrakk>\n       \\<Longrightarrow> is_class P C'", "fix C'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C'.\n       \\<lbrakk>Subobjs P C Cs; C' \\<in> set Cs\\<rbrakk>\n       \\<Longrightarrow> is_class P C'", "assume subo:\"Subobjs P C Cs\" and set:\"C' \\<in> set Cs\""], ["proof (state)\nthis:\n  Subobjs P C Cs\n  C' \\<in> set Cs\n\ngoal (1 subgoal):\n 1. \\<And>C'.\n       \\<lbrakk>Subobjs P C Cs; C' \\<in> set Cs\\<rbrakk>\n       \\<Longrightarrow> is_class P C'", "from set"], ["proof (chain)\npicking this:\n  C' \\<in> set Cs", "obtain Ds Ds' where Cs:\"Cs = Ds@C'#Ds'\""], ["proof (prove)\nusing this:\n  C' \\<in> set Cs\n\ngoal (1 subgoal):\n 1. (\\<And>Ds Ds'.\n        Cs = Ds @ C' # Ds' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp:in_set_conv_decomp)"], ["proof (state)\nthis:\n  Cs = Ds @ C' # Ds'\n\ngoal (1 subgoal):\n 1. \\<And>C'.\n       \\<lbrakk>Subobjs P C Cs; C' \\<in> set Cs\\<rbrakk>\n       \\<Longrightarrow> is_class P C'", "with Cs"], ["proof (chain)\npicking this:\n  Cs = Ds @ C' # Ds'\n  Cs = Ds @ C' # Ds'", "show \"is_class P C'\""], ["proof (prove)\nusing this:\n  Cs = Ds @ C' # Ds'\n  Cs = Ds @ C' # Ds'\n\ngoal (1 subgoal):\n 1. is_class P C'", "proof (cases \"Ds = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cs = Ds @ C' # Ds'; Cs = Ds @ C' # Ds'; Ds = []\\<rbrakk>\n    \\<Longrightarrow> is_class P C'\n 2. \\<lbrakk>Cs = Ds @ C' # Ds'; Cs = Ds @ C' # Ds'; Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> is_class P C'", "case True"], ["proof (state)\nthis:\n  Ds = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Cs = Ds @ C' # Ds'; Cs = Ds @ C' # Ds'; Ds = []\\<rbrakk>\n    \\<Longrightarrow> is_class P C'\n 2. \\<lbrakk>Cs = Ds @ C' # Ds'; Cs = Ds @ C' # Ds'; Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> is_class P C'", "with Cs subo"], ["proof (chain)\npicking this:\n  Cs = Ds @ C' # Ds'\n  Subobjs P C Cs\n  Ds = []", "have subo':\"Subobjs P C (C'#Ds')\""], ["proof (prove)\nusing this:\n  Cs = Ds @ C' # Ds'\n  Subobjs P C Cs\n  Ds = []\n\ngoal (1 subgoal):\n 1. Subobjs P C (C' # Ds')", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (C' # Ds')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Cs = Ds @ C' # Ds'; Cs = Ds @ C' # Ds'; Ds = []\\<rbrakk>\n    \\<Longrightarrow> is_class P C'\n 2. \\<lbrakk>Cs = Ds @ C' # Ds'; Cs = Ds @ C' # Ds'; Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> is_class P C'", "thus ?thesis"], ["proof (prove)\nusing this:\n  Subobjs P C (C' # Ds')\n\ngoal (1 subgoal):\n 1. is_class P C'", "by (rule Subobjs.cases,\n      auto dest:hd_SubobjsR intro:SubobjsR_isClass)"], ["proof (state)\nthis:\n  is_class P C'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs = Ds @ C' # Ds'; Cs = Ds @ C' # Ds'; Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> is_class P C'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs = Ds @ C' # Ds'; Cs = Ds @ C' # Ds'; Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> is_class P C'", "case False"], ["proof (state)\nthis:\n  Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs = Ds @ C' # Ds'; Cs = Ds @ C' # Ds'; Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> is_class P C'", "then"], ["proof (chain)\npicking this:\n  Ds \\<noteq> []", "obtain C'' Cs'' where Cs'':\"Cs'' = butlast Ds\"\n      and last:\"C'' = last Ds\""], ["proof (prove)\nusing this:\n  Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>Cs'' C''.\n        \\<lbrakk>Cs'' = butlast Ds; C'' = last Ds\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Cs'' = butlast Ds\n  C'' = last Ds\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs = Ds @ C' # Ds'; Cs = Ds @ C' # Ds'; Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> is_class P C'", "with False"], ["proof (chain)\npicking this:\n  Ds \\<noteq> []\n  Cs'' = butlast Ds\n  C'' = last Ds", "have Ds:\"Ds = Cs''@[C'']\""], ["proof (prove)\nusing this:\n  Ds \\<noteq> []\n  Cs'' = butlast Ds\n  C'' = last Ds\n\ngoal (1 subgoal):\n 1. Ds = Cs'' @ [C'']", "by simp"], ["proof (state)\nthis:\n  Ds = Cs'' @ [C'']\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs = Ds @ C' # Ds'; Cs = Ds @ C' # Ds'; Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> is_class P C'", "with Cs subo"], ["proof (chain)\npicking this:\n  Cs = Ds @ C' # Ds'\n  Subobjs P C Cs\n  Ds = Cs'' @ [C'']", "have subo':\"Subobjs P C (Cs''@[C'',C']@Ds')\""], ["proof (prove)\nusing this:\n  Cs = Ds @ C' # Ds'\n  Subobjs P C Cs\n  Ds = Cs'' @ [C'']\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs'' @ [C'', C'] @ Ds')", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (Cs'' @ [C'', C'] @ Ds')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs = Ds @ C' # Ds'; Cs = Ds @ C' # Ds'; Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> is_class P C'", "hence \"P \\<turnstile> C'' \\<prec>\\<^sub>R C'\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs'' @ [C'', C'] @ Ds')\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C'' \\<prec>\\<^sub>R C'", "by(fastforce intro:isSubobjs_subclsR Subobjs_isSubobj)"], ["proof (state)\nthis:\n  P \\<turnstile> C'' \\<prec>\\<^sub>R C'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs = Ds @ C' # Ds'; Cs = Ds @ C' # Ds'; Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> is_class P C'", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  P \\<turnstile> C'' \\<prec>\\<^sub>R C'", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  P \\<turnstile> C'' \\<prec>\\<^sub>R C'\n\ngoal (1 subgoal):\n 1. is_class P C'", "by (fastforce dest!:subclsRD\n                   intro:wf_cdecl_supD class_wf RepBaseclass_isBaseclass subclsSI)"], ["proof (state)\nthis:\n  is_class P C'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_class P C'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_subset_classes:\"\\<lbrakk>Subobjs P C Cs; wf_prog wf_md P\\<rbrakk> \n  \\<Longrightarrow> set Cs \\<subseteq> {C. is_class P C}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C Cs; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> set Cs \\<subseteq> {C. is_class P C}", "by (auto dest:path_contains_classes)"], ["", "lemma assumes subo:\"Subobjs P C (rev Cs)\" and wf:\"wf_prog wf_md P\"\n  shows rev_path_distinct_classes:\"distinct Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct Cs", "using subo"], ["proof (prove)\nusing this:\n  Subobjs P C (rev Cs)\n\ngoal (1 subgoal):\n 1. distinct Cs", "proof (induct Cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. Subobjs P C (rev []) \\<Longrightarrow> distinct []\n 2. \\<And>a Cs.\n       \\<lbrakk>Subobjs P C (rev Cs) \\<Longrightarrow> distinct Cs;\n        Subobjs P C (rev (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> distinct (a # Cs)", "case Nil"], ["proof (state)\nthis:\n  Subobjs P C (rev [])\n\ngoal (2 subgoals):\n 1. Subobjs P C (rev []) \\<Longrightarrow> distinct []\n 2. \\<And>a Cs.\n       \\<lbrakk>Subobjs P C (rev Cs) \\<Longrightarrow> distinct Cs;\n        Subobjs P C (rev (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> distinct (a # Cs)", "thus ?case"], ["proof (prove)\nusing this:\n  Subobjs P C (rev [])\n\ngoal (1 subgoal):\n 1. distinct []", "by(fastforce dest:Subobjs_nonempty)"], ["proof (state)\nthis:\n  distinct []\n\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>Subobjs P C (rev Cs) \\<Longrightarrow> distinct Cs;\n        Subobjs P C (rev (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> distinct (a # Cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>Subobjs P C (rev Cs) \\<Longrightarrow> distinct Cs;\n        Subobjs P C (rev (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> distinct (a # Cs)", "case (Cons C' Cs')"], ["proof (state)\nthis:\n  Subobjs P C (rev Cs') \\<Longrightarrow> distinct Cs'\n  Subobjs P C (rev (C' # Cs'))\n\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>Subobjs P C (rev Cs) \\<Longrightarrow> distinct Cs;\n        Subobjs P C (rev (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> distinct (a # Cs)", "have subo':\"Subobjs P C (rev(C'#Cs'))\"\n    and IH:\"Subobjs P C (rev Cs') \\<Longrightarrow> distinct Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C (rev (C' # Cs')) &&&\n    (Subobjs P C (rev Cs') \\<Longrightarrow> distinct Cs')", "by fact+"], ["proof (state)\nthis:\n  Subobjs P C (rev (C' # Cs'))\n  Subobjs P C (rev Cs') \\<Longrightarrow> distinct Cs'\n\ngoal (1 subgoal):\n 1. \\<And>a Cs.\n       \\<lbrakk>Subobjs P C (rev Cs) \\<Longrightarrow> distinct Cs;\n        Subobjs P C (rev (a # Cs))\\<rbrakk>\n       \\<Longrightarrow> distinct (a # Cs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (C' # Cs')", "proof (cases \"Cs' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Cs' = [] \\<Longrightarrow> distinct (C' # Cs')\n 2. Cs' \\<noteq> [] \\<Longrightarrow> distinct (C' # Cs')", "case True"], ["proof (state)\nthis:\n  Cs' = []\n\ngoal (2 subgoals):\n 1. Cs' = [] \\<Longrightarrow> distinct (C' # Cs')\n 2. Cs' \\<noteq> [] \\<Longrightarrow> distinct (C' # Cs')", "thus ?thesis"], ["proof (prove)\nusing this:\n  Cs' = []\n\ngoal (1 subgoal):\n 1. distinct (C' # Cs')", "by simp"], ["proof (state)\nthis:\n  distinct (C' # Cs')\n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> [] \\<Longrightarrow> distinct (C' # Cs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Cs' \\<noteq> [] \\<Longrightarrow> distinct (C' # Cs')", "case False"], ["proof (state)\nthis:\n  Cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> [] \\<Longrightarrow> distinct (C' # Cs')", "hence rev:\"rev Cs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  Cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. rev Cs' \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  rev Cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> [] \\<Longrightarrow> distinct (C' # Cs')", "from subo'"], ["proof (chain)\npicking this:\n  Subobjs P C (rev (C' # Cs'))", "have subo'':\"Subobjs P C (rev Cs'@[C'])\""], ["proof (prove)\nusing this:\n  Subobjs P C (rev (C' # Cs'))\n\ngoal (1 subgoal):\n 1. Subobjs P C (rev Cs' @ [C'])", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (rev Cs' @ [C'])\n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> [] \\<Longrightarrow> distinct (C' # Cs')", "hence \"Subobjs P C (rev Cs')\""], ["proof (prove)\nusing this:\n  Subobjs P C (rev Cs' @ [C'])\n\ngoal (1 subgoal):\n 1. Subobjs P C (rev Cs')", "using rev wf"], ["proof (prove)\nusing this:\n  Subobjs P C (rev Cs' @ [C'])\n  rev Cs' \\<noteq> []\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. Subobjs P C (rev Cs')", "by(fastforce dest:appendSubobj)"], ["proof (state)\nthis:\n  Subobjs P C (rev Cs')\n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> [] \\<Longrightarrow> distinct (C' # Cs')", "with IH"], ["proof (chain)\npicking this:\n  Subobjs P C (rev Cs') \\<Longrightarrow> distinct Cs'\n  Subobjs P C (rev Cs')", "have dist:\"distinct Cs'\""], ["proof (prove)\nusing this:\n  Subobjs P C (rev Cs') \\<Longrightarrow> distinct Cs'\n  Subobjs P C (rev Cs')\n\ngoal (1 subgoal):\n 1. distinct Cs'", "by simp"], ["proof (state)\nthis:\n  distinct Cs'\n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> [] \\<Longrightarrow> distinct (C' # Cs')", "from subo'' wf"], ["proof (chain)\npicking this:\n  Subobjs P C (rev Cs' @ [C'])\n  wf_prog wf_md P", "have \"C' \\<notin> set (rev Cs')\""], ["proof (prove)\nusing this:\n  Subobjs P C (rev Cs' @ [C'])\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. C' \\<notin> set (rev Cs')", "by(fastforce dest:unique2)"], ["proof (state)\nthis:\n  C' \\<notin> set (rev Cs')\n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> [] \\<Longrightarrow> distinct (C' # Cs')", "with dist"], ["proof (chain)\npicking this:\n  distinct Cs'\n  C' \\<notin> set (rev Cs')", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct Cs'\n  C' \\<notin> set (rev Cs')\n\ngoal (1 subgoal):\n 1. distinct (C' # Cs')", "by simp"], ["proof (state)\nthis:\n  distinct (C' # Cs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (C' # Cs')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes subo:\"Subobjs P C Cs\" and wf:\"wf_prog wf_md P\"\n  shows path_distinct_classes:\"distinct Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct Cs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct Cs", "obtain Cs' where Cs':\"Cs' = rev Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Cs'. Cs' = rev Cs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  Cs' = rev Cs\n\ngoal (1 subgoal):\n 1. distinct Cs", "with subo"], ["proof (chain)\npicking this:\n  Subobjs P C Cs\n  Cs' = rev Cs", "have \"Subobjs P C (rev Cs')\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n  Cs' = rev Cs\n\ngoal (1 subgoal):\n 1. Subobjs P C (rev Cs')", "by simp"], ["proof (state)\nthis:\n  Subobjs P C (rev Cs')\n\ngoal (1 subgoal):\n 1. distinct Cs", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  Subobjs P C (rev Cs')", "have \"distinct Cs'\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  Subobjs P C (rev Cs')\n\ngoal (1 subgoal):\n 1. distinct Cs'", "by -(rule rev_path_distinct_classes)"], ["proof (state)\nthis:\n  distinct Cs'\n\ngoal (1 subgoal):\n 1. distinct Cs", "with Cs'"], ["proof (chain)\npicking this:\n  Cs' = rev Cs\n  distinct Cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  Cs' = rev Cs\n  distinct Cs'\n\ngoal (1 subgoal):\n 1. distinct Cs", "by simp"], ["proof (state)\nthis:\n  distinct Cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes wf:\"wf_prog wf_md P\" \n  shows prog_length:\"length P = card {C. is_class P C}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length P = card {C. is_class P C}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length P = card {C. is_class P C}", "from wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P", "have dist_fst:\"distinct_fst P\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. distinct_fst P", "by (simp add:wf_prog_def)"], ["proof (state)\nthis:\n  distinct_fst P\n\ngoal (1 subgoal):\n 1. length P = card {C. is_class P C}", "hence \"distinct P\""], ["proof (prove)\nusing this:\n  distinct_fst P\n\ngoal (1 subgoal):\n 1. distinct P", "by (simp add:distinct_fst_def,induct P,auto)"], ["proof (state)\nthis:\n  distinct P\n\ngoal (1 subgoal):\n 1. length P = card {C. is_class P C}", "hence card_set:\"card (set P) = length P\""], ["proof (prove)\nusing this:\n  distinct P\n\ngoal (1 subgoal):\n 1. card (set P) = length P", "by (rule distinct_card)"], ["proof (state)\nthis:\n  card (set P) = length P\n\ngoal (1 subgoal):\n 1. length P = card {C. is_class P C}", "from dist_fst"], ["proof (chain)\npicking this:\n  distinct_fst P", "have set:\"{C. is_class P C} = fst ` (set P)\""], ["proof (prove)\nusing this:\n  distinct_fst P\n\ngoal (1 subgoal):\n 1. {C. is_class P C} = fst ` set P", "by (simp add:is_class_def class_def,auto simp:distinct_fst_def,\n      auto dest:map_of_eq_Some_iff intro!:image_eqI)"], ["proof (state)\nthis:\n  {C. is_class P C} = fst ` set P\n\ngoal (1 subgoal):\n 1. length P = card {C. is_class P C}", "from dist_fst"], ["proof (chain)\npicking this:\n  distinct_fst P", "have \"card(fst ` (set P)) = card (set P)\""], ["proof (prove)\nusing this:\n  distinct_fst P\n\ngoal (1 subgoal):\n 1. card (fst ` set P) = card (set P)", "by(auto intro:card_image simp:distinct_map distinct_fst_def)"], ["proof (state)\nthis:\n  card (fst ` set P) = card (set P)\n\ngoal (1 subgoal):\n 1. length P = card {C. is_class P C}", "with card_set set"], ["proof (chain)\npicking this:\n  card (set P) = length P\n  {C. is_class P C} = fst ` set P\n  card (fst ` set P) = card (set P)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (set P) = length P\n  {C. is_class P C} = fst ` set P\n  card (fst ` set P) = card (set P)\n\ngoal (1 subgoal):\n 1. length P = card {C. is_class P C}", "by simp"], ["proof (state)\nthis:\n  length P = card {C. is_class P C}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes subo:\"Subobjs P C Cs\" and wf:\"wf_prog wf_md P\"\n  shows path_length:\"length Cs \\<le> length P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Cs \\<le> length P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length Cs \\<le> length P", "from subo wf"], ["proof (chain)\npicking this:\n  Subobjs P C Cs\n  wf_prog wf_md P", "have \"distinct Cs\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. distinct Cs", "by (rule path_distinct_classes)"], ["proof (state)\nthis:\n  distinct Cs\n\ngoal (1 subgoal):\n 1. length Cs \\<le> length P", "hence card_eq_length:\"card (set Cs) = length Cs\""], ["proof (prove)\nusing this:\n  distinct Cs\n\ngoal (1 subgoal):\n 1. card (set Cs) = length Cs", "by (rule distinct_card)"], ["proof (state)\nthis:\n  card (set Cs) = length Cs\n\ngoal (1 subgoal):\n 1. length Cs \\<le> length P", "from subo wf"], ["proof (chain)\npicking this:\n  Subobjs P C Cs\n  wf_prog wf_md P", "have \"card (set Cs) \\<le> card {C. is_class P C}\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. card (set Cs) \\<le> card {C. is_class P C}", "by (auto dest:path_subset_classes intro:card_mono finite_is_class)"], ["proof (state)\nthis:\n  card (set Cs) \\<le> card {C. is_class P C}\n\ngoal (1 subgoal):\n 1. length Cs \\<le> length P", "with card_eq_length"], ["proof (chain)\npicking this:\n  card (set Cs) = length Cs\n  card (set Cs) \\<le> card {C. is_class P C}", "have \"length Cs \\<le> card {C. is_class P C}\""], ["proof (prove)\nusing this:\n  card (set Cs) = length Cs\n  card (set Cs) \\<le> card {C. is_class P C}\n\ngoal (1 subgoal):\n 1. length Cs \\<le> card {C. is_class P C}", "by simp"], ["proof (state)\nthis:\n  length Cs \\<le> card {C. is_class P C}\n\ngoal (1 subgoal):\n 1. length Cs \\<le> length P", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  length Cs \\<le> card {C. is_class P C}", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  length Cs \\<le> card {C. is_class P C}\n\ngoal (1 subgoal):\n 1. length Cs \\<le> length P", "by(fastforce dest:prog_length)"], ["proof (state)\nthis:\n  length Cs \\<le> length P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma empty_path_empty_set:\"{Cs. Subobjs P C Cs \\<and> length Cs \\<le> 0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Cs. Subobjs P C Cs \\<and> length Cs \\<le> 0} = {}", "by (auto dest:Subobjs_nonempty)"], ["", "lemma split_set_path_length:\"{Cs. Subobjs P C Cs \\<and> length Cs \\<le> Suc(n)} = \n{Cs. Subobjs P C Cs \\<and> length Cs \\<le> n} \\<union> {Cs. Subobjs P C Cs \\<and> length Cs = Suc(n)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Cs. Subobjs P C Cs \\<and> length Cs \\<le> Suc n} =\n    {Cs. Subobjs P C Cs \\<and> length Cs \\<le> n} \\<union>\n    {Cs. Subobjs P C Cs \\<and> length Cs = Suc n}", "by auto"], ["", "lemma empty_list_set:\"{xs. set xs \\<subseteq> F \\<and> xs = []} = {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. set xs \\<subseteq> F \\<and> xs = []} = {[]}", "by auto"], ["", "lemma suc_n_union_of_union:\"{xs. set xs \\<subseteq> F \\<and> length xs = Suc n} = (UN x:F. UN xs : {xs. set xs \\<le> F \\<and> length xs = n}. {x#xs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xs. set xs \\<subseteq> F \\<and> length xs = Suc n} =\n    (\\<Union>x\\<in>F.\n        \\<Union>xs\\<in>{xs. set xs \\<subseteq> F \\<and> length xs = n}.\n           {x # xs})", "by (auto simp:length_Suc_conv)"], ["", "lemma max_length_finite_set:\"finite F \\<Longrightarrow> finite{xs. set xs <= F \\<and> length xs = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite F \\<Longrightarrow>\n    finite {xs. set xs \\<subseteq> F \\<and> length xs = n}", "by(induct n,simp add:empty_list_set, simp add:suc_n_union_of_union)"], ["", "lemma path_length_n_finite_set:\n\"wf_prog wf_md P \\<Longrightarrow> finite{Cs. Subobjs P C Cs \\<and> length Cs = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow>\n    finite {Cs. Subobjs P C Cs \\<and> length Cs = n}", "by (rule_tac B=\"{Cs. set Cs <= {C. is_class P C} \\<and> length Cs = n}\" in finite_subset,\n  auto dest:path_contains_classes intro:max_length_finite_set simp:finite_is_class)"], ["", "lemma path_finite_leq:\n\"wf_prog wf_md P \\<Longrightarrow> finite{Cs. Subobjs P C Cs \\<and> length Cs \\<le> length P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow>\n    finite {Cs. Subobjs P C Cs \\<and> length Cs \\<le> length P}", "by (induct (\"length P\"), simp only:empty_path_empty_set,\n    auto intro:path_length_n_finite_set simp:split_set_path_length)"], ["", "lemma path_finite:\"wf_prog wf_md P \\<Longrightarrow> finite{Cs. Subobjs P C Cs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_prog wf_md P \\<Longrightarrow> finite {Cs. Subobjs P C Cs}", "by (subgoal_tac \"{Cs. Subobjs P C Cs} = \n  {Cs. Subobjs P C Cs \\<and> length Cs \\<le> length P}\",\n  auto intro:path_finite_leq path_length)"], ["", "subsection\\<open>Well-formedness and Path\\<close>"], ["", "lemma path_via_reverse:\n  assumes path_via:\"P \\<turnstile> Path C to D via Cs\" and wf:\"wf_prog wf_md P\"\n  shows \"\\<forall>Cs'. P \\<turnstile> Path D to C via Cs' \\<longrightarrow> Cs = [C] \\<and> Cs' = [C] \\<and> C = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "from path_via"], ["proof (chain)\npicking this:\n  P \\<turnstile> Path C to D via Cs", "have subo:\"Subobjs P C Cs\" and last:\"last Cs = D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path C to D via Cs \n\ngoal (1 subgoal):\n 1. Subobjs P C Cs &&& last Cs = D", "by(simp add:path_via_def)+"], ["proof (state)\nthis:\n  Subobjs P C Cs\n  last Cs = D\n\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "hence leq:\"P \\<turnstile> C \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n  last Cs = D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* D", "by(fastforce dest:Subobjs_subclass)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "{"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "fix Cs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "assume \"P \\<turnstile> Path D to C via Cs'\""], ["proof (state)\nthis:\n  P \\<turnstile> Path D to C via Cs' \n\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "hence subo':\"Subobjs P D Cs'\" and last':\"last Cs' = C\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path D to C via Cs' \n\ngoal (1 subgoal):\n 1. Subobjs P D Cs' &&& last Cs' = C", "by(simp add:path_via_def)+"], ["proof (state)\nthis:\n  Subobjs P D Cs'\n  last Cs' = C\n\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "hence leq':\"P \\<turnstile> D \\<preceq>\\<^sup>* C\""], ["proof (prove)\nusing this:\n  Subobjs P D Cs'\n  last Cs' = C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D \\<preceq>\\<^sup>* C", "by(fastforce dest:Subobjs_subclass)"], ["proof (state)\nthis:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "with leq wf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  wf_prog wf_md P\n  P \\<turnstile> D \\<preceq>\\<^sup>* C", "have CeqD:\"C = D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  wf_prog wf_md P\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. C = D", "by(rule subcls_asym2)"], ["proof (state)\nthis:\n  C = D\n\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "moreover"], ["proof (state)\nthis:\n  C = D\n\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "have Cs:\"Cs = [C]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs = [C]", "using CeqD subo last wf"], ["proof (prove)\nusing this:\n  C = D\n  Subobjs P C Cs\n  last Cs = D\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. Cs = [C]", "by(fastforce intro:mdc_eq_last)"], ["proof (state)\nthis:\n  Cs = [C]\n\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "moreover"], ["proof (state)\nthis:\n  Cs = [C]\n\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "have \"Cs' = [C]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs' = [C]", "using CeqD subo' last' wf"], ["proof (prove)\nusing this:\n  C = D\n  Subobjs P D Cs'\n  last Cs' = C\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. Cs' = [C]", "by(fastforce intro:mdc_eq_last)"], ["proof (state)\nthis:\n  Cs' = [C]\n\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "ultimately"], ["proof (chain)\npicking this:\n  C = D\n  Cs = [C]\n  Cs' = [C]", "have \"Cs = [C] \\<and> Cs' = [C] \\<and> C = D\""], ["proof (prove)\nusing this:\n  C = D\n  Cs = [C]\n  Cs' = [C]\n\ngoal (1 subgoal):\n 1. Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "by simp"], ["proof (state)\nthis:\n  Cs = [C] \\<and> Cs' = [C] \\<and> C = D\n\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "}"], ["proof (state)\nthis:\n  P \\<turnstile> Path D to C via ?Cs'2  \\<Longrightarrow>\n  Cs = [C] \\<and> ?Cs'2 = [C] \\<and> C = D\n\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "thus ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> Path D to C via ?Cs'2  \\<Longrightarrow>\n  Cs = [C] \\<and> ?Cs'2 = [C] \\<and> C = D\n\ngoal (1 subgoal):\n 1. \\<forall>Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n       Cs = [C] \\<and> Cs' = [C] \\<and> C = D", "by blast"], ["proof (state)\nthis:\n  \\<forall>Cs'.\n     P \\<turnstile> Path D to C via Cs'  \\<longrightarrow>\n     Cs = [C] \\<and> Cs' = [C] \\<and> C = D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_hd_appendPath:\n  assumes path:\"P,C \\<turnstile> Cs \\<sqsubseteq> Cs'@\\<^sub>pCs\" and last:\"last Cs' = hd Cs\"\n  and notemptyCs:\"Cs \\<noteq> []\" and notemptyCs':\"Cs' \\<noteq> []\" and wf:\"wf_prog wf_md P\"\n  shows \"Cs' = [hd Cs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs' = [hd Cs]", "using path"], ["proof (prove)\nusing this:\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. Cs' = [hd Cs]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P,C \\<turnstile> Cs \\<sqsubseteq> Cs' @\\<^sub>p Cs \\<Longrightarrow>\n    Cs' = [hd Cs]", "from path notemptyCs last"], ["proof (chain)\npicking this:\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs' @\\<^sub>p Cs\n  Cs \\<noteq> []\n  last Cs' = hd Cs", "have path2:\"P,C \\<turnstile> Cs \\<sqsubseteq> Cs'@ tl Cs\""], ["proof (prove)\nusing this:\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs' @\\<^sub>p Cs\n  Cs \\<noteq> []\n  last Cs' = hd Cs\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> Cs \\<sqsubseteq> Cs' @ tl Cs", "by (simp add:appendPath_def)"], ["proof (state)\nthis:\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs' @ tl Cs\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> Cs \\<sqsubseteq> Cs' @\\<^sub>p Cs \\<Longrightarrow>\n    Cs' = [hd Cs]", "thus ?thesis"], ["proof (prove)\nusing this:\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs' @ tl Cs\n\ngoal (1 subgoal):\n 1. Cs' = [hd Cs]", "proof (auto dest!:rtranclD)"], ["proof (state)\ngoal (2 subgoals):\n 1. Cs = Cs' @ tl Cs \\<Longrightarrow> Cs' = [hd Cs]\n 2. \\<lbrakk>Cs \\<noteq> Cs' @ tl Cs;\n     (Cs, Cs' @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> Cs' = [hd Cs]", "assume \"Cs = Cs'@ tl Cs\""], ["proof (state)\nthis:\n  Cs = Cs' @ tl Cs\n\ngoal (2 subgoals):\n 1. Cs = Cs' @ tl Cs \\<Longrightarrow> Cs' = [hd Cs]\n 2. \\<lbrakk>Cs \\<noteq> Cs' @ tl Cs;\n     (Cs, Cs' @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> Cs' = [hd Cs]", "with notemptyCs"], ["proof (chain)\npicking this:\n  Cs \\<noteq> []\n  Cs = Cs' @ tl Cs", "show \"Cs' = [hd Cs]\""], ["proof (prove)\nusing this:\n  Cs \\<noteq> []\n  Cs = Cs' @ tl Cs\n\ngoal (1 subgoal):\n 1. Cs' = [hd Cs]", "by (rule app_hd_tl)"], ["proof (state)\nthis:\n  Cs' = [hd Cs]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs \\<noteq> Cs' @ tl Cs;\n     (Cs, Cs' @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> Cs' = [hd Cs]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs \\<noteq> Cs' @ tl Cs;\n     (Cs, Cs' @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> Cs' = [hd Cs]", "assume trancl:\"(Cs,Cs'@ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\""], ["proof (state)\nthis:\n  (Cs, Cs' @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs \\<noteq> Cs' @ tl Cs;\n     (Cs, Cs' @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> Cs' = [hd Cs]", "from notemptyCs' last"], ["proof (chain)\npicking this:\n  Cs' \\<noteq> []\n  last Cs' = hd Cs", "have butlastLast:\"Cs' = butlast Cs' @ [hd Cs]\""], ["proof (prove)\nusing this:\n  Cs' \\<noteq> []\n  last Cs' = hd Cs\n\ngoal (1 subgoal):\n 1. Cs' = butlast Cs' @ [hd Cs]", "by -(drule append_butlast_last_id,simp)"], ["proof (state)\nthis:\n  Cs' = butlast Cs' @ [hd Cs]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs \\<noteq> Cs' @ tl Cs;\n     (Cs, Cs' @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> Cs' = [hd Cs]", "with trancl"], ["proof (chain)\npicking this:\n  (Cs, Cs' @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\n  Cs' = butlast Cs' @ [hd Cs]", "have trancl':\"(Cs, (butlast Cs' @ [hd Cs]) @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (Cs, Cs' @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\n  Cs' = butlast Cs' @ [hd Cs]\n\ngoal (1 subgoal):\n 1. (Cs, (butlast Cs' @ [hd Cs]) @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (Cs, (butlast Cs' @ [hd Cs]) @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs \\<noteq> Cs' @ tl Cs;\n     (Cs, Cs' @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> Cs' = [hd Cs]", "from notemptyCs"], ["proof (chain)\npicking this:\n  Cs \\<noteq> []", "have \"(butlast Cs' @ [hd Cs]) @ tl Cs = butlast Cs' @ Cs\""], ["proof (prove)\nusing this:\n  Cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (butlast Cs' @ [hd Cs]) @ tl Cs = butlast Cs' @ Cs", "by simp"], ["proof (state)\nthis:\n  (butlast Cs' @ [hd Cs]) @ tl Cs = butlast Cs' @ Cs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs \\<noteq> Cs' @ tl Cs;\n     (Cs, Cs' @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> Cs' = [hd Cs]", "with trancl'"], ["proof (chain)\npicking this:\n  (Cs, (butlast Cs' @ [hd Cs]) @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\n  (butlast Cs' @ [hd Cs]) @ tl Cs = butlast Cs' @ Cs", "have \"(Cs, butlast Cs' @ Cs) \\<in> (leq_path1 P C)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (Cs, (butlast Cs' @ [hd Cs]) @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\n  (butlast Cs' @ [hd Cs]) @ tl Cs = butlast Cs' @ Cs\n\ngoal (1 subgoal):\n 1. (Cs, butlast Cs' @ Cs) \\<in> (leq_path1 P C)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (Cs, butlast Cs' @ Cs) \\<in> (leq_path1 P C)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs \\<noteq> Cs' @ tl Cs;\n     (Cs, Cs' @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> Cs' = [hd Cs]", "hence \"(last Cs, last (butlast Cs' @ Cs)) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (Cs, butlast Cs' @ Cs) \\<in> (leq_path1 P C)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (last Cs, last (butlast Cs' @ Cs)) \\<in> (subcls1 P)\\<^sup>+", "using wf"], ["proof (prove)\nusing this:\n  (Cs, butlast Cs' @ Cs) \\<in> (leq_path1 P C)\\<^sup>+\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. (last Cs, last (butlast Cs' @ Cs)) \\<in> (subcls1 P)\\<^sup>+", "by (rule last_leq_paths)"], ["proof (state)\nthis:\n  (last Cs, last (butlast Cs' @ Cs)) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs \\<noteq> Cs' @ tl Cs;\n     (Cs, Cs' @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> Cs' = [hd Cs]", "with notemptyCs"], ["proof (chain)\npicking this:\n  Cs \\<noteq> []\n  (last Cs, last (butlast Cs' @ Cs)) \\<in> (subcls1 P)\\<^sup>+", "have \"(last Cs, last Cs) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  Cs \\<noteq> []\n  (last Cs, last (butlast Cs' @ Cs)) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (last Cs, last Cs) \\<in> (subcls1 P)\\<^sup>+", "by -(drule_tac xs=\"butlast Cs'\" in last_appendR,simp)"], ["proof (state)\nthis:\n  (last Cs, last Cs) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs \\<noteq> Cs' @ tl Cs;\n     (Cs, Cs' @ tl Cs) \\<in> (leq_path1 P C)\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> Cs' = [hd Cs]", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  (last Cs, last Cs) \\<in> (subcls1 P)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  (last Cs, last Cs) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. Cs' = [hd Cs]", "by (auto dest:subcls_irrefl)"], ["proof (state)\nthis:\n  Cs' = [hd Cs]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cs' = [hd Cs]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_via_C: \"\\<lbrakk>P \\<turnstile> Path C to C via Cs; wf_prog wf_md P\\<rbrakk> \\<Longrightarrow> Cs = [C]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Path C to C via Cs ; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> Cs = [C]", "by (fastforce intro:mdc_eq_last simp:path_via_def)"], ["", "lemma assumes wf:\"wf_prog wf_md P\"\n  and path_via:\"P \\<turnstile> Path last Cs to C via Cs'\"\n  and path_via':\"P \\<turnstile> Path last Cs to C via Cs''\"\n  and appendPath:\"Cs = Cs@\\<^sub>pCs'\"\nshows appendPath_path_via:\"Cs = Cs@\\<^sub>pCs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "from path_via"], ["proof (chain)\npicking this:\n  P \\<turnstile> Path last Cs to C via Cs'", "have notempty:\"Cs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path last Cs to C via Cs' \n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> []", "by(fastforce intro!:Subobjs_nonempty simp:path_via_def)"], ["proof (state)\nthis:\n  Cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "{"], ["proof (state)\nthis:\n  Cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "assume eq:\"last Cs = hd Cs'\"\n    and Cs:\"Cs = Cs@tl Cs'\""], ["proof (state)\nthis:\n  last Cs = hd Cs'\n  Cs = Cs @ tl Cs'\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "from Cs"], ["proof (chain)\npicking this:\n  Cs = Cs @ tl Cs'", "have \"tl Cs' = []\""], ["proof (prove)\nusing this:\n  Cs = Cs @ tl Cs'\n\ngoal (1 subgoal):\n 1. tl Cs' = []", "by simp"], ["proof (state)\nthis:\n  tl Cs' = []\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "with eq notempty"], ["proof (chain)\npicking this:\n  last Cs = hd Cs'\n  Cs' \\<noteq> []\n  tl Cs' = []", "have \"Cs' = [last Cs]\""], ["proof (prove)\nusing this:\n  last Cs = hd Cs'\n  Cs' \\<noteq> []\n  tl Cs' = []\n\ngoal (1 subgoal):\n 1. Cs' = [last Cs]", "by -(drule hd_Cons_tl,simp)"], ["proof (state)\nthis:\n  Cs' = [last Cs]\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "}"], ["proof (state)\nthis:\n  \\<lbrakk>last Cs = hd Cs'; Cs = Cs @ tl Cs'\\<rbrakk>\n  \\<Longrightarrow> Cs' = [last Cs]\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>last Cs = hd Cs'; Cs = Cs @ tl Cs'\\<rbrakk>\n  \\<Longrightarrow> Cs' = [last Cs]\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "{"], ["proof (state)\nthis:\n  \\<lbrakk>last Cs = hd Cs'; Cs = Cs @ tl Cs'\\<rbrakk>\n  \\<Longrightarrow> Cs' = [last Cs]\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "assume \"Cs = Cs'\""], ["proof (state)\nthis:\n  Cs = Cs'\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "with wf path_via"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  P \\<turnstile> Path last Cs to C via Cs' \n  Cs = Cs'", "have \"Cs' = [last Cs]\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  P \\<turnstile> Path last Cs to C via Cs' \n  Cs = Cs'\n\ngoal (1 subgoal):\n 1. Cs' = [last Cs]", "by(fastforce intro:mdc_eq_last simp:path_via_def)"], ["proof (state)\nthis:\n  Cs' = [last Cs]\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "}"], ["proof (state)\nthis:\n  Cs = Cs' \\<Longrightarrow> Cs' = [last Cs]\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>last Cs = hd Cs'; Cs = Cs @ tl Cs'\\<rbrakk>\n  \\<Longrightarrow> Cs' = [last Cs]\n  Cs = Cs' \\<Longrightarrow> Cs' = [last Cs]", "have eq:\"Cs' = [last Cs]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>last Cs = hd Cs'; Cs = Cs @ tl Cs'\\<rbrakk>\n  \\<Longrightarrow> Cs' = [last Cs]\n  Cs = Cs' \\<Longrightarrow> Cs' = [last Cs]\n\ngoal (1 subgoal):\n 1. Cs' = [last Cs]", "using appendPath"], ["proof (prove)\nusing this:\n  \\<lbrakk>last Cs = hd Cs'; Cs = Cs @ tl Cs'\\<rbrakk>\n  \\<Longrightarrow> Cs' = [last Cs]\n  Cs = Cs' \\<Longrightarrow> Cs' = [last Cs]\n  Cs = Cs @\\<^sub>p Cs'\n\ngoal (1 subgoal):\n 1. Cs' = [last Cs]", "by(simp add:appendPath_def,split if_split_asm,simp_all)"], ["proof (state)\nthis:\n  Cs' = [last Cs]\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "with path_via"], ["proof (chain)\npicking this:\n  P \\<turnstile> Path last Cs to C via Cs' \n  Cs' = [last Cs]", "have \"C = last Cs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path last Cs to C via Cs' \n  Cs' = [last Cs]\n\ngoal (1 subgoal):\n 1. C = last Cs", "by(simp add:path_via_def)"], ["proof (state)\nthis:\n  C = last Cs\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "with wf path_via'"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  P \\<turnstile> Path last Cs to C via Cs'' \n  C = last Cs", "have \"Cs'' = [last Cs]\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  P \\<turnstile> Path last Cs to C via Cs'' \n  C = last Cs\n\ngoal (1 subgoal):\n 1. Cs'' = [last Cs]", "by simp(rule path_via_C)"], ["proof (state)\nthis:\n  Cs'' = [last Cs]\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "thus ?thesis"], ["proof (prove)\nusing this:\n  Cs'' = [last Cs]\n\ngoal (1 subgoal):\n 1. Cs = Cs @\\<^sub>p Cs''", "by (simp add:appendPath_def)"], ["proof (state)\nthis:\n  Cs = Cs @\\<^sub>p Cs''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subo_no_path:\n  assumes subo:\"Subobjs P C' (Cs @ C#Cs')\" and wf:\"wf_prog wf_md P\"\n  and notempty:\"Cs' \\<noteq> []\"\n  shows \"\\<not> P \\<turnstile> Path last Cs' to C via Ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P \\<turnstile> Path last Cs' to C via Ds", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> Path last Cs' to C via Ds  \\<Longrightarrow> False", "assume \"P \\<turnstile> Path last Cs' to C via Ds\""], ["proof (state)\nthis:\n  P \\<turnstile> Path last Cs' to C via Ds \n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path last Cs' to C via Ds  \\<Longrightarrow> False", "hence subo':\"Subobjs P (last Cs') Ds\" and last:\"last Ds = C\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path last Cs' to C via Ds \n\ngoal (1 subgoal):\n 1. Subobjs P (last Cs') Ds &&& last Ds = C", "by (auto simp:path_via_def)"], ["proof (state)\nthis:\n  Subobjs P (last Cs') Ds\n  last Ds = C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path last Cs' to C via Ds  \\<Longrightarrow> False", "hence notemptyDs:\"Ds \\<noteq> []\""], ["proof (prove)\nusing this:\n  Subobjs P (last Cs') Ds\n  last Ds = C\n\ngoal (1 subgoal):\n 1. Ds \\<noteq> []", "by -(drule Subobjs_nonempty)"], ["proof (state)\nthis:\n  Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path last Cs' to C via Ds  \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Ds \\<noteq> []", "obtain D' Ds' where D'Ds':\"Ds = D'#Ds'\""], ["proof (prove)\nusing this:\n  Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>D' Ds'. Ds = D' # Ds' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases Ds)auto"], ["proof (state)\nthis:\n  Ds = D' # Ds'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path last Cs' to C via Ds  \\<Longrightarrow> False", "from subo"], ["proof (chain)\npicking this:\n  Subobjs P C' (Cs @ C # Cs')", "have suboC:\"Subobjs P C (C#Cs')\""], ["proof (prove)\nusing this:\n  Subobjs P C' (Cs @ C # Cs')\n\ngoal (1 subgoal):\n 1. Subobjs P C (C # Cs')", "by (rule Subobjs_Subobjs)"], ["proof (state)\nthis:\n  Subobjs P C (C # Cs')\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path last Cs' to C via Ds  \\<Longrightarrow> False", "with wf subo' notempty"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  Subobjs P (last Cs') Ds\n  Cs' \\<noteq> []\n  Subobjs P C (C # Cs')", "have suboapp:\"Subobjs P C ((C#Cs')@\\<^sub>pDs)\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  Subobjs P (last Cs') Ds\n  Cs' \\<noteq> []\n  Subobjs P C (C # Cs')\n\ngoal (1 subgoal):\n 1. Subobjs P C ((C # Cs') @\\<^sub>p Ds)", "by -(rule Subobjs_appendPath,simp_all)"], ["proof (state)\nthis:\n  Subobjs P C ((C # Cs') @\\<^sub>p Ds)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path last Cs' to C via Ds  \\<Longrightarrow> False", "with notemptyDs last"], ["proof (chain)\npicking this:\n  Ds \\<noteq> []\n  last Ds = C\n  Subobjs P C ((C # Cs') @\\<^sub>p Ds)", "have last':\"last ((C#Cs')@\\<^sub>pDs) = C\""], ["proof (prove)\nusing this:\n  Ds \\<noteq> []\n  last Ds = C\n  Subobjs P C ((C # Cs') @\\<^sub>p Ds)\n\ngoal (1 subgoal):\n 1. last ((C # Cs') @\\<^sub>p Ds) = C", "by -(drule_tac Cs'=\"(C#Cs')\" in appendPath_last,simp)"], ["proof (state)\nthis:\n  last ((C # Cs') @\\<^sub>p Ds) = C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path last Cs' to C via Ds  \\<Longrightarrow> False", "from notemptyDs"], ["proof (chain)\npicking this:\n  Ds \\<noteq> []", "have \"(C#Cs')@\\<^sub>pDs \\<noteq> []\""], ["proof (prove)\nusing this:\n  Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. (C # Cs') @\\<^sub>p Ds \\<noteq> []", "by (simp add:appendPath_def)"], ["proof (state)\nthis:\n  (C # Cs') @\\<^sub>p Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path last Cs' to C via Ds  \\<Longrightarrow> False", "with last'"], ["proof (chain)\npicking this:\n  last ((C # Cs') @\\<^sub>p Ds) = C\n  (C # Cs') @\\<^sub>p Ds \\<noteq> []", "have \"C \\<in> set ((C#Cs')@\\<^sub>pDs)\""], ["proof (prove)\nusing this:\n  last ((C # Cs') @\\<^sub>p Ds) = C\n  (C # Cs') @\\<^sub>p Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. C \\<in> set ((C # Cs') @\\<^sub>p Ds)", "apply (auto simp add:in_set_conv_decomp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>last ((C # Cs') @\\<^sub>p Ds) = C;\n     (C # Cs') @\\<^sub>p Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys zs. (C # Cs') @\\<^sub>p Ds = ys @ C # zs", "apply (rule_tac x=\"butlast((C#Cs')@\\<^sub>pDs)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>last ((C # Cs') @\\<^sub>p Ds) = C;\n     (C # Cs') @\\<^sub>p Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         (C # Cs') @\\<^sub>p Ds =\n                         butlast ((C # Cs') @\\<^sub>p Ds) @ C # zs", "apply (rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>last ((C # Cs') @\\<^sub>p Ds) = C;\n     (C # Cs') @\\<^sub>p Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (C # Cs') @\\<^sub>p Ds =\n                      butlast ((C # Cs') @\\<^sub>p Ds) @ [C]", "apply (drule append_butlast_last_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>last ((C # Cs') @\\<^sub>p Ds) = C;\n     butlast ((C # Cs') @\\<^sub>p Ds) @ [last ((C # Cs') @\\<^sub>p Ds)] =\n     (C # Cs') @\\<^sub>p Ds\\<rbrakk>\n    \\<Longrightarrow> (C # Cs') @\\<^sub>p Ds =\n                      butlast ((C # Cs') @\\<^sub>p Ds) @ [C]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  C \\<in> set ((C # Cs') @\\<^sub>p Ds)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path last Cs' to C via Ds  \\<Longrightarrow> False", "with suboapp wf"], ["proof (chain)\npicking this:\n  Subobjs P C ((C # Cs') @\\<^sub>p Ds)\n  wf_prog wf_md P\n  C \\<in> set ((C # Cs') @\\<^sub>p Ds)", "have hd:\"C = hd ((C#Cs')@\\<^sub>pDs)\""], ["proof (prove)\nusing this:\n  Subobjs P C ((C # Cs') @\\<^sub>p Ds)\n  wf_prog wf_md P\n  C \\<in> set ((C # Cs') @\\<^sub>p Ds)\n\ngoal (1 subgoal):\n 1. C = hd ((C # Cs') @\\<^sub>p Ds)", "by -(rule  mdc_hd_path)"], ["proof (state)\nthis:\n  C = hd ((C # Cs') @\\<^sub>p Ds)\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path last Cs' to C via Ds  \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  C = hd ((C # Cs') @\\<^sub>p Ds)\n\ngoal (1 subgoal):\n 1. False", "proof (cases \"last (C#Cs') = hd Ds\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') = hd Ds\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  last (C # Cs') = hd Ds\n\ngoal (2 subgoals):\n 1. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') = hd Ds\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> False", "hence eq:\"(C#Cs')@\\<^sub>pDs = (C#Cs')@(tl Ds)\""], ["proof (prove)\nusing this:\n  last (C # Cs') = hd Ds\n\ngoal (1 subgoal):\n 1. (C # Cs') @\\<^sub>p Ds = (C # Cs') @ tl Ds", "by (simp add:appendPath_def)"], ["proof (state)\nthis:\n  (C # Cs') @\\<^sub>p Ds = (C # Cs') @ tl Ds\n\ngoal (2 subgoals):\n 1. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') = hd Ds\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases Ds')"], ["proof (state)\ngoal (2 subgoals):\n 1. Ds' = [] \\<Longrightarrow> False\n 2. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "case Nil"], ["proof (state)\nthis:\n  Ds' = []\n\ngoal (2 subgoals):\n 1. Ds' = [] \\<Longrightarrow> False\n 2. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "with D'Ds'"], ["proof (chain)\npicking this:\n  Ds = D' # Ds'\n  Ds' = []", "have Ds:\"Ds = [D']\""], ["proof (prove)\nusing this:\n  Ds = D' # Ds'\n  Ds' = []\n\ngoal (1 subgoal):\n 1. Ds = [D']", "by simp"], ["proof (state)\nthis:\n  Ds = [D']\n\ngoal (2 subgoals):\n 1. Ds' = [] \\<Longrightarrow> False\n 2. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "with last"], ["proof (chain)\npicking this:\n  last Ds = C\n  Ds = [D']", "have \"C = D'\""], ["proof (prove)\nusing this:\n  last Ds = C\n  Ds = [D']\n\ngoal (1 subgoal):\n 1. C = D'", "by simp"], ["proof (state)\nthis:\n  C = D'\n\ngoal (2 subgoals):\n 1. Ds' = [] \\<Longrightarrow> False\n 2. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "with True notempty Ds"], ["proof (chain)\npicking this:\n  last (C # Cs') = hd Ds\n  Cs' \\<noteq> []\n  Ds = [D']\n  C = D'", "have \"last (C#Cs') = C\""], ["proof (prove)\nusing this:\n  last (C # Cs') = hd Ds\n  Cs' \\<noteq> []\n  Ds = [D']\n  C = D'\n\ngoal (1 subgoal):\n 1. last (C # Cs') = C", "by simp"], ["proof (state)\nthis:\n  last (C # Cs') = C\n\ngoal (2 subgoals):\n 1. Ds' = [] \\<Longrightarrow> False\n 2. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "with notempty"], ["proof (chain)\npicking this:\n  Cs' \\<noteq> []\n  last (C # Cs') = C", "have \"last Cs' = C\""], ["proof (prove)\nusing this:\n  Cs' \\<noteq> []\n  last (C # Cs') = C\n\ngoal (1 subgoal):\n 1. last Cs' = C", "by simp"], ["proof (state)\nthis:\n  last Cs' = C\n\ngoal (2 subgoals):\n 1. Ds' = [] \\<Longrightarrow> False\n 2. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "with notempty"], ["proof (chain)\npicking this:\n  Cs' \\<noteq> []\n  last Cs' = C", "have Cset:\"C \\<in> set Cs'\""], ["proof (prove)\nusing this:\n  Cs' \\<noteq> []\n  last Cs' = C\n\ngoal (1 subgoal):\n 1. C \\<in> set Cs'", "apply (auto simp add:in_set_conv_decomp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs' \\<noteq> []; C = last Cs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys zs. Cs' = ys @ last Cs' # zs", "apply (rule_tac x=\"butlast Cs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs' \\<noteq> []; C = last Cs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs. Cs' = butlast Cs' @ last Cs' # zs", "apply (rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs' \\<noteq> []; C = last Cs'\\<rbrakk>\n    \\<Longrightarrow> Cs' = butlast Cs' @ [last Cs']", "apply (drule append_butlast_last_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C = last Cs'; butlast Cs' @ [last Cs'] = Cs'\\<rbrakk>\n    \\<Longrightarrow> Cs' = butlast Cs' @ [last Cs']", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  C \\<in> set Cs'\n\ngoal (2 subgoals):\n 1. Ds' = [] \\<Longrightarrow> False\n 2. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "from subo wf"], ["proof (chain)\npicking this:\n  Subobjs P C' (Cs @ C # Cs')\n  wf_prog wf_md P", "have \"C \\<notin> set Cs'\""], ["proof (prove)\nusing this:\n  Subobjs P C' (Cs @ C # Cs')\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. C \\<notin> set Cs'", "by (rule unique1)"], ["proof (state)\nthis:\n  C \\<notin> set Cs'\n\ngoal (2 subgoals):\n 1. Ds' = [] \\<Longrightarrow> False\n 2. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "with Cset"], ["proof (chain)\npicking this:\n  C \\<in> set Cs'\n  C \\<notin> set Cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> set Cs'\n  C \\<notin> set Cs'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "case (Cons X Xs)"], ["proof (state)\nthis:\n  Ds' = X # Xs\n\ngoal (1 subgoal):\n 1. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "with D'Ds'"], ["proof (chain)\npicking this:\n  Ds = D' # Ds'\n  Ds' = X # Xs", "have tlnotempty:\"tl Ds \\<noteq> []\""], ["proof (prove)\nusing this:\n  Ds = D' # Ds'\n  Ds' = X # Xs\n\ngoal (1 subgoal):\n 1. tl Ds \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  tl Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "with Cons last D'Ds'"], ["proof (chain)\npicking this:\n  Ds' = X # Xs\n  last Ds = C\n  Ds = D' # Ds'\n  tl Ds \\<noteq> []", "have \"last (tl Ds) = C\""], ["proof (prove)\nusing this:\n  Ds' = X # Xs\n  last Ds = C\n  Ds = D' # Ds'\n  tl Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (tl Ds) = C", "by simp"], ["proof (state)\nthis:\n  last (tl Ds) = C\n\ngoal (1 subgoal):\n 1. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "with tlnotempty"], ["proof (chain)\npicking this:\n  tl Ds \\<noteq> []\n  last (tl Ds) = C", "have \"C \\<in> set (tl Ds)\""], ["proof (prove)\nusing this:\n  tl Ds \\<noteq> []\n  last (tl Ds) = C\n\ngoal (1 subgoal):\n 1. C \\<in> set (tl Ds)", "apply (auto simp add:in_set_conv_decomp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tl Ds \\<noteq> []; C = last (tl Ds)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys zs. tl Ds = ys @ last (tl Ds) # zs", "apply (rule_tac x=\"butlast (tl Ds)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tl Ds \\<noteq> []; C = last (tl Ds)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>zs.\n                         tl Ds = butlast (tl Ds) @ last (tl Ds) # zs", "apply (rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tl Ds \\<noteq> []; C = last (tl Ds)\\<rbrakk>\n    \\<Longrightarrow> tl Ds = butlast (tl Ds) @ [last (tl Ds)]", "apply (drule append_butlast_last_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C = last (tl Ds);\n     butlast (tl Ds) @ [last (tl Ds)] = tl Ds\\<rbrakk>\n    \\<Longrightarrow> tl Ds = butlast (tl Ds) @ [last (tl Ds)]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  C \\<in> set (tl Ds)\n\ngoal (1 subgoal):\n 1. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "hence Cset:\"C \\<in> set (Cs'@(tl Ds))\""], ["proof (prove)\nusing this:\n  C \\<in> set (tl Ds)\n\ngoal (1 subgoal):\n 1. C \\<in> set (Cs' @ tl Ds)", "by simp"], ["proof (state)\nthis:\n  C \\<in> set (Cs' @ tl Ds)\n\ngoal (1 subgoal):\n 1. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "from suboapp eq wf"], ["proof (chain)\npicking this:\n  Subobjs P C ((C # Cs') @\\<^sub>p Ds)\n  (C # Cs') @\\<^sub>p Ds = (C # Cs') @ tl Ds\n  wf_prog wf_md P", "have \"C \\<notin> set (Cs'@(tl Ds))\""], ["proof (prove)\nusing this:\n  Subobjs P C ((C # Cs') @\\<^sub>p Ds)\n  (C # Cs') @\\<^sub>p Ds = (C # Cs') @ tl Ds\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. C \\<notin> set (Cs' @ tl Ds)", "by (subgoal_tac \"Subobjs P C (C#(Cs'@(tl Ds)))\",\n          rule_tac Cs=\"[]\" in unique1,simp_all)"], ["proof (state)\nthis:\n  C \\<notin> set (Cs' @ tl Ds)\n\ngoal (1 subgoal):\n 1. \\<And>a list. Ds' = a # list \\<Longrightarrow> False", "with Cset"], ["proof (chain)\npicking this:\n  C \\<in> set (Cs' @ tl Ds)\n  C \\<notin> set (Cs' @ tl Ds)", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> set (Cs' @ tl Ds)\n  C \\<notin> set (Cs' @ tl Ds)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  last (C # Cs') \\<noteq> hd Ds\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> False", "with notemptyDs"], ["proof (chain)\npicking this:\n  Ds \\<noteq> []\n  last (C # Cs') \\<noteq> hd Ds", "have eq:\"(C#Cs')@\\<^sub>pDs = Ds\""], ["proof (prove)\nusing this:\n  Ds \\<noteq> []\n  last (C # Cs') \\<noteq> hd Ds\n\ngoal (1 subgoal):\n 1. (C # Cs') @\\<^sub>p Ds = Ds", "by (simp add:appendPath_def)"], ["proof (state)\nthis:\n  (C # Cs') @\\<^sub>p Ds = Ds\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> False", "with subo' last"], ["proof (chain)\npicking this:\n  Subobjs P (last Cs') Ds\n  last Ds = C\n  (C # Cs') @\\<^sub>p Ds = Ds", "have lastleq:\"P \\<turnstile> last Cs' \\<preceq>\\<^sup>* C\""], ["proof (prove)\nusing this:\n  Subobjs P (last Cs') Ds\n  last Ds = C\n  (C # Cs') @\\<^sub>p Ds = Ds\n\ngoal (1 subgoal):\n 1. P \\<turnstile> last Cs' \\<preceq>\\<^sup>* C", "by (fastforce dest:Subobjs_subclass)"], ["proof (state)\nthis:\n  P \\<turnstile> last Cs' \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> False", "from notempty"], ["proof (chain)\npicking this:\n  Cs' \\<noteq> []", "obtain X Xs where X:\"X = last Cs'\" and \"Xs = butlast Cs'\""], ["proof (prove)\nusing this:\n  Cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>X Xs.\n        \\<lbrakk>X = last Cs'; Xs = butlast Cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  X = last Cs'\n  Xs = butlast Cs'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> False", "with notempty"], ["proof (chain)\npicking this:\n  Cs' \\<noteq> []\n  X = last Cs'\n  Xs = butlast Cs'", "have XXs:\"Cs' = Xs@[X]\""], ["proof (prove)\nusing this:\n  Cs' \\<noteq> []\n  X = last Cs'\n  Xs = butlast Cs'\n\ngoal (1 subgoal):\n 1. Cs' = Xs @ [X]", "by simp"], ["proof (state)\nthis:\n  Cs' = Xs @ [X]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> False", "hence CleqX:\"(C,X) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  Cs' = Xs @ [X]\n\ngoal (1 subgoal):\n 1. (C, X) \\<in> (subcls1 P)\\<^sup>+", "proof (cases Xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Cs' = Xs @ [X]; Xs = []\\<rbrakk>\n    \\<Longrightarrow> (C, X) \\<in> (subcls1 P)\\<^sup>+\n 2. \\<And>a list.\n       \\<lbrakk>Cs' = Xs @ [X]; Xs = a # list\\<rbrakk>\n       \\<Longrightarrow> (C, X) \\<in> (subcls1 P)\\<^sup>+", "case Nil"], ["proof (state)\nthis:\n  Xs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Cs' = Xs @ [X]; Xs = []\\<rbrakk>\n    \\<Longrightarrow> (C, X) \\<in> (subcls1 P)\\<^sup>+\n 2. \\<And>a list.\n       \\<lbrakk>Cs' = Xs @ [X]; Xs = a # list\\<rbrakk>\n       \\<Longrightarrow> (C, X) \\<in> (subcls1 P)\\<^sup>+", "with suboC XXs"], ["proof (chain)\npicking this:\n  Subobjs P C (C # Cs')\n  Cs' = Xs @ [X]\n  Xs = []", "have \"Subobjs P C [C,X]\""], ["proof (prove)\nusing this:\n  Subobjs P C (C # Cs')\n  Cs' = Xs @ [X]\n  Xs = []\n\ngoal (1 subgoal):\n 1. Subobjs P C [C, X]", "by simp"], ["proof (state)\nthis:\n  Subobjs P C [C, X]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Cs' = Xs @ [X]; Xs = []\\<rbrakk>\n    \\<Longrightarrow> (C, X) \\<in> (subcls1 P)\\<^sup>+\n 2. \\<And>a list.\n       \\<lbrakk>Cs' = Xs @ [X]; Xs = a # list\\<rbrakk>\n       \\<Longrightarrow> (C, X) \\<in> (subcls1 P)\\<^sup>+", "thus ?thesis"], ["proof (prove)\nusing this:\n  Subobjs P C [C, X]\n\ngoal (1 subgoal):\n 1. (C, X) \\<in> (subcls1 P)\\<^sup>+", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C [C, X] \\<Longrightarrow> (C, X) \\<in> (subcls1 P)\\<^sup>+", "apply (rule r_into_trancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C [C, X] \\<Longrightarrow> P \\<turnstile> C \\<prec>\\<^sup>1 X", "apply (rule subclsR_subcls1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C [C, X] \\<Longrightarrow> P \\<turnstile> C \\<prec>\\<^sub>R X", "apply (rule_tac Cs=\"[]\" in Subobjs_subclsR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C [C, X] \\<Longrightarrow> Subobjs P ?C5 ([] @ [C, X] @ ?Cs'5)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (C, X) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = Xs @ [X]; Xs = a # list\\<rbrakk>\n       \\<Longrightarrow> (C, X) \\<in> (subcls1 P)\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = Xs @ [X]; Xs = a # list\\<rbrakk>\n       \\<Longrightarrow> (C, X) \\<in> (subcls1 P)\\<^sup>+", "case (Cons Y Ys)"], ["proof (state)\nthis:\n  Xs = Y # Ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = Xs @ [X]; Xs = a # list\\<rbrakk>\n       \\<Longrightarrow> (C, X) \\<in> (subcls1 P)\\<^sup>+", "with suboC XXs"], ["proof (chain)\npicking this:\n  Subobjs P C (C # Cs')\n  Cs' = Xs @ [X]\n  Xs = Y # Ys", "have subo'':\"Subobjs P C ([C,Y]@Ys@[X])\""], ["proof (prove)\nusing this:\n  Subobjs P C (C # Cs')\n  Cs' = Xs @ [X]\n  Xs = Y # Ys\n\ngoal (1 subgoal):\n 1. Subobjs P C ([C, Y] @ Ys @ [X])", "by simp"], ["proof (state)\nthis:\n  Subobjs P C ([C, Y] @ Ys @ [X])\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = Xs @ [X]; Xs = a # list\\<rbrakk>\n       \\<Longrightarrow> (C, X) \\<in> (subcls1 P)\\<^sup>+", "hence plus:\"(C,Y) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  Subobjs P C ([C, Y] @ Ys @ [X])\n\ngoal (1 subgoal):\n 1. (C, Y) \\<in> (subcls1 P)\\<^sup>+", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C ([C, Y] @ Ys @ [X]) \\<Longrightarrow>\n    (C, Y) \\<in> (subcls1 P)\\<^sup>+", "apply (rule r_into_trancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C ([C, Y] @ Ys @ [X]) \\<Longrightarrow>\n    P \\<turnstile> C \\<prec>\\<^sup>1 Y", "apply (rule subclsR_subcls1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C ([C, Y] @ Ys @ [X]) \\<Longrightarrow>\n    P \\<turnstile> C \\<prec>\\<^sub>R Y", "apply (rule_tac Cs=\"[]\" in Subobjs_subclsR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C ([C, Y] @ Ys @ [X]) \\<Longrightarrow>\n    Subobjs P ?C5 ([] @ [C, Y] @ ?Cs'5)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (C, Y) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = Xs @ [X]; Xs = a # list\\<rbrakk>\n       \\<Longrightarrow> (C, X) \\<in> (subcls1 P)\\<^sup>+", "from subo''"], ["proof (chain)\npicking this:\n  Subobjs P C ([C, Y] @ Ys @ [X])", "have \"P \\<turnstile> Y \\<preceq>\\<^sup>* X\""], ["proof (prove)\nusing this:\n  Subobjs P C ([C, Y] @ Ys @ [X])\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Y \\<preceq>\\<^sup>* X", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subobjs P C ([C, Y] @ Ys @ [X]) \\<Longrightarrow>\n    P \\<turnstile> Y \\<preceq>\\<^sup>* X", "apply (subgoal_tac \"Subobjs P C ([C]@Y#(Ys@[X]))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C ([C, Y] @ Ys @ [X]);\n     Subobjs P C ([C] @ Y # Ys @ [X])\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Y \\<preceq>\\<^sup>* X\n 2. Subobjs P C ([C, Y] @ Ys @ [X]) \\<Longrightarrow>\n    Subobjs P C ([C] @ Y # Ys @ [X])", "apply (drule Subobjs_Subobjs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C ([C, Y] @ Ys @ [X]);\n     Subobjs P Y (Y # Ys @ [X])\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Y \\<preceq>\\<^sup>* X\n 2. Subobjs P C ([C, Y] @ Ys @ [X]) \\<Longrightarrow>\n    Subobjs P C ([C] @ Y # Ys @ [X])", "apply (drule_tac C=\"Y\" in Subobjs_subclass)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C ([C, Y] @ Ys @ [X]);\n     P \\<turnstile> Y \\<preceq>\\<^sup>* last (Y # Ys @ [X])\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Y \\<preceq>\\<^sup>* X\n 2. Subobjs P C ([C, Y] @ Ys @ [X]) \\<Longrightarrow>\n    Subobjs P C ([C] @ Y # Ys @ [X])", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P \\<turnstile> Y \\<preceq>\\<^sup>* X\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Cs' = Xs @ [X]; Xs = a # list\\<rbrakk>\n       \\<Longrightarrow> (C, X) \\<in> (subcls1 P)\\<^sup>+", "with plus"], ["proof (chain)\npicking this:\n  (C, Y) \\<in> (subcls1 P)\\<^sup>+\n  P \\<turnstile> Y \\<preceq>\\<^sup>* X", "show ?thesis"], ["proof (prove)\nusing this:\n  (C, Y) \\<in> (subcls1 P)\\<^sup>+\n  P \\<turnstile> Y \\<preceq>\\<^sup>* X\n\ngoal (1 subgoal):\n 1. (C, X) \\<in> (subcls1 P)\\<^sup>+", "by (fastforce elim:trancl_rtrancl_trancl)"], ["proof (state)\nthis:\n  (C, X) \\<in> (subcls1 P)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (C, X) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> False", "from lastleq X"], ["proof (chain)\npicking this:\n  P \\<turnstile> last Cs' \\<preceq>\\<^sup>* C\n  X = last Cs'", "have leq:\"P \\<turnstile> X \\<preceq>\\<^sup>* C\""], ["proof (prove)\nusing this:\n  P \\<turnstile> last Cs' \\<preceq>\\<^sup>* C\n  X = last Cs'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> X \\<preceq>\\<^sup>* C", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> X \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> False", "with CleqX"], ["proof (chain)\npicking this:\n  (C, X) \\<in> (subcls1 P)\\<^sup>+\n  P \\<turnstile> X \\<preceq>\\<^sup>* C", "have \"(C,C) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (C, X) \\<in> (subcls1 P)\\<^sup>+\n  P \\<turnstile> X \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. (C, C) \\<in> (subcls1 P)\\<^sup>+", "by (rule trancl_rtrancl_trancl)"], ["proof (state)\nthis:\n  (C, C) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>C = hd ((C # Cs') @\\<^sub>p Ds);\n     last (C # Cs') \\<noteq> hd Ds\\<rbrakk>\n    \\<Longrightarrow> False", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  (C, C) \\<in> (subcls1 P)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  (C, C) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. False", "by (fastforce dest:subcls_irrefl)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leq_implies_path:\n  assumes leq:\"P \\<turnstile> C \\<preceq>\\<^sup>* D\" and \"class\": \"is_class P C\"\n  and wf:\"wf_prog wf_md P\"\nshows \"\\<exists>Cs. P \\<turnstile> Path C to D via Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "using leq \"class\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* D\n  is_class P C\n\ngoal (1 subgoal):\n 1. \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "proof(induct rule:rtrancl.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. is_class P a \\<Longrightarrow> Ex (path_via P a a)\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        is_class P a \\<Longrightarrow> Ex (path_via P a b);\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; is_class P a\\<rbrakk>\n       \\<Longrightarrow> Ex (path_via P a c)", "fix C"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. is_class P a \\<Longrightarrow> Ex (path_via P a a)\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        is_class P a \\<Longrightarrow> Ex (path_via P a b);\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; is_class P a\\<rbrakk>\n       \\<Longrightarrow> Ex (path_via P a c)", "assume \"is_class P C\""], ["proof (state)\nthis:\n  is_class P C\n\ngoal (2 subgoals):\n 1. \\<And>a. is_class P a \\<Longrightarrow> Ex (path_via P a a)\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        is_class P a \\<Longrightarrow> Ex (path_via P a b);\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; is_class P a\\<rbrakk>\n       \\<Longrightarrow> Ex (path_via P a c)", "thus \"\\<exists>Cs. P \\<turnstile> Path C to C via Cs\""], ["proof (prove)\nusing this:\n  is_class P C\n\ngoal (1 subgoal):\n 1. \\<exists>Cs. P \\<turnstile> Path C to C via Cs", "by (rule_tac x=\"[C]\" in exI,fastforce intro:Subobjs_Base simp:path_via_def)"], ["proof (state)\nthis:\n  \\<exists>Cs. P \\<turnstile> Path C to C via Cs \n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        is_class P a \\<Longrightarrow> Ex (path_via P a b);\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; is_class P a\\<rbrakk>\n       \\<Longrightarrow> Ex (path_via P a c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        is_class P a \\<Longrightarrow> Ex (path_via P a b);\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; is_class P a\\<rbrakk>\n       \\<Longrightarrow> Ex (path_via P a c)", "fix C C' D"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        is_class P a \\<Longrightarrow> Ex (path_via P a b);\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; is_class P a\\<rbrakk>\n       \\<Longrightarrow> Ex (path_via P a c)", "assume CleqC':\"P \\<turnstile> C \\<preceq>\\<^sup>* C'\" and C'leqD:\"P \\<turnstile> C' \\<prec>\\<^sup>1 D\"\n    and classC:\"is_class P C\" and IH:\"is_class P C \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to C' via Cs\""], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* C'\n  P \\<turnstile> C' \\<prec>\\<^sup>1 D\n  is_class P C\n  is_class P C \\<Longrightarrow>\n  \\<exists>Cs. P \\<turnstile> Path C to C' via Cs \n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        is_class P a \\<Longrightarrow> Ex (path_via P a b);\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; is_class P a\\<rbrakk>\n       \\<Longrightarrow> Ex (path_via P a c)", "from IH[OF classC]"], ["proof (chain)\npicking this:\n  \\<exists>Cs. P \\<turnstile> Path C to C' via Cs", "obtain Cs where subo:\"Subobjs P C Cs\" and last:\"last Cs = C'\""], ["proof (prove)\nusing this:\n  \\<exists>Cs. P \\<turnstile> Path C to C' via Cs \n\ngoal (1 subgoal):\n 1. (\\<And>Cs.\n        \\<lbrakk>Subobjs P C Cs; last Cs = C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:path_via_def)"], ["proof (state)\nthis:\n  Subobjs P C Cs\n  last Cs = C'\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        is_class P a \\<Longrightarrow> Ex (path_via P a b);\n        P \\<turnstile> b \\<prec>\\<^sup>1 c; is_class P a\\<rbrakk>\n       \\<Longrightarrow> Ex (path_via P a c)", "with C'leqD"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' \\<prec>\\<^sup>1 D\n  Subobjs P C Cs\n  last Cs = C'", "show \"\\<exists>Cs. P \\<turnstile> Path C to D via Cs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' \\<prec>\\<^sup>1 D\n  Subobjs P C Cs\n  last Cs = C'\n\ngoal (1 subgoal):\n 1. \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "proof (auto dest!:subcls1_subclsR_or_subclsS)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C Cs; C' = last Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>R D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to D via Cs \n 2. \\<lbrakk>Subobjs P C Cs; C' = last Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "assume \"P \\<turnstile> last Cs \\<prec>\\<^sub>R D\""], ["proof (state)\nthis:\n  P \\<turnstile> last Cs \\<prec>\\<^sub>R D\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C Cs; C' = last Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>R D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to D via Cs \n 2. \\<lbrakk>Subobjs P C Cs; C' = last Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "with subo"], ["proof (chain)\npicking this:\n  Subobjs P C Cs\n  P \\<turnstile> last Cs \\<prec>\\<^sub>R D", "have \"Subobjs P C (Cs@[D])\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n  P \\<turnstile> last Cs \\<prec>\\<^sub>R D\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ [D])", "using wf"], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n  P \\<turnstile> last Cs \\<prec>\\<^sub>R D\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ [D])", "by (rule converse_Subobjs_Rep)"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ [D])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C Cs; C' = last Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>R D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to D via Cs \n 2. \\<lbrakk>Subobjs P C Cs; C' = last Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "thus ?thesis"], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ [D])\n\ngoal (1 subgoal):\n 1. \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "by (fastforce simp:path_via_def)"], ["proof (state)\nthis:\n  \\<exists>Cs. P \\<turnstile> Path C to D via Cs \n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C Cs; C' = last Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C Cs; C' = last Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "assume subS:\"P \\<turnstile> last Cs \\<prec>\\<^sub>S D\""], ["proof (state)\nthis:\n  P \\<turnstile> last Cs \\<prec>\\<^sub>S D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C Cs; C' = last Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "from CleqC' last"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* C'\n  last Cs = C'", "have Cleqlast:\"P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* C'\n  last Cs = C'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* last Cs", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C Cs; C' = last Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "from subS"], ["proof (chain)\npicking this:\n  P \\<turnstile> last Cs \\<prec>\\<^sub>S D", "have classLast:\"is_class P (last Cs)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> last Cs \\<prec>\\<^sub>S D\n\ngoal (1 subgoal):\n 1. is_class P (last Cs)", "by (auto intro:subcls1_class subclsS_subcls1)"], ["proof (state)\nthis:\n  is_class P (last Cs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C Cs; C' = last Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "then"], ["proof (chain)\npicking this:\n  is_class P (last Cs)", "obtain Bs fs ms where \"class P (last Cs) = Some(Bs,fs,ms)\""], ["proof (prove)\nusing this:\n  is_class P (last Cs)\n\ngoal (1 subgoal):\n 1. (\\<And>Bs fs ms.\n        class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp:is_class_def)"], ["proof (state)\nthis:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C Cs; C' = last Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "hence classD:\"is_class P D\""], ["proof (prove)\nusing this:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. is_class P D", "using subS wf"], ["proof (prove)\nusing this:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  P \\<turnstile> last Cs \\<prec>\\<^sub>S D\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. is_class P D", "by (auto intro:wf_cdecl_supD dest:class_wf dest!:subclsSD \n               elim:ShBaseclass_isBaseclass)"], ["proof (state)\nthis:\n  is_class P D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C Cs; C' = last Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "with Cleqlast subS"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\n  P \\<turnstile> last Cs \\<prec>\\<^sub>S D\n  is_class P D", "have \"Subobjs P C [D]\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\n  P \\<turnstile> last Cs \\<prec>\\<^sub>S D\n  is_class P D\n\ngoal (1 subgoal):\n 1. Subobjs P C [D]", "by (fastforce intro:Subobjs_Sh SubobjsR_Base)"], ["proof (state)\nthis:\n  Subobjs P C [D]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C Cs; C' = last Cs;\n     P \\<turnstile> last Cs \\<prec>\\<^sub>S D\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "thus ?thesis"], ["proof (prove)\nusing this:\n  Subobjs P C [D]\n\ngoal (1 subgoal):\n 1. \\<exists>Cs. P \\<turnstile> Path C to D via Cs", "by (fastforce simp:path_via_def)"], ["proof (state)\nthis:\n  \\<exists>Cs. P \\<turnstile> Path C to D via Cs \n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Cs. P \\<turnstile> Path C to D via Cs \n\ngoal:\nNo subgoals!", "qed"], ["", "lemma least_method_implies_path_unique:\nassumes least:\"P \\<turnstile> C has least M = (Ts,T,m) via Cs\" and wf:\"wf_prog wf_md P\"\nshows \"P \\<turnstile> Path C to (last Cs) unique\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to last Cs unique", "proof (auto simp add:path_unique_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>Csa. Subobjs P C Csa \\<and> last Csa = last Cs\n 2. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "(* Existence *)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>Csa. Subobjs P C Csa \\<and> last Csa = last Cs\n 2. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from least"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least M = (Ts, T, m) via Cs", "have \"Subobjs P C Cs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least M = (Ts, T, m) via Cs\n\ngoal (1 subgoal):\n 1. Subobjs P C Cs", "by (simp add:LeastMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  Subobjs P C Cs\n\ngoal (2 subgoals):\n 1. \\<exists>Csa. Subobjs P C Csa \\<and> last Csa = last Cs\n 2. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "thus \"\\<exists>Cs'. Subobjs P C Cs' \\<and> last Cs' = last Cs\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n\ngoal (1 subgoal):\n 1. \\<exists>Cs'. Subobjs P C Cs' \\<and> last Cs' = last Cs", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>Cs'. Subobjs P C Cs' \\<and> last Cs' = last Cs\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "(* Uniqueness *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "fix Cs' Cs''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "assume suboCs':\"Subobjs P C Cs'\" and suboCs'':\"Subobjs P C Cs''\"\n    and lastCs':\"last Cs' = last Cs\" and lastCs'':\"last Cs'' = last Cs\""], ["proof (state)\nthis:\n  Subobjs P C Cs'\n  Subobjs P C Cs''\n  last Cs' = last Cs\n  last Cs'' = last Cs\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from suboCs'"], ["proof (chain)\npicking this:\n  Subobjs P C Cs'", "have notemptyCs':\"Cs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs'\n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> []", "by (rule Subobjs_nonempty)"], ["proof (state)\nthis:\n  Cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from suboCs''"], ["proof (chain)\npicking this:\n  Subobjs P C Cs''", "have notemptyCs'':\"Cs'' \\<noteq> []\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs''\n\ngoal (1 subgoal):\n 1. Cs'' \\<noteq> []", "by (rule Subobjs_nonempty)"], ["proof (state)\nthis:\n  Cs'' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from least"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least M = (Ts, T, m) via Cs", "have suboCs:\"Subobjs P C Cs\"\n    and all:\"\\<forall>Ds. Subobjs P C Ds \\<and> \n     (\\<exists>Ts T m Bs ms. (\\<exists>fs. class P (last Ds) = Some (Bs, fs, ms)) \\<and> \n                 map_of ms M = Some(Ts,T,m)) \\<longrightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Ds\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least M = (Ts, T, m) via Cs\n\ngoal (1 subgoal):\n 1. Subobjs P C Cs &&&\n    \\<forall>Ds.\n       Subobjs P C Ds \\<and>\n       (\\<exists>Ts T m Bs ms.\n           (\\<exists>fs.\n               class P (last Ds) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>) \\<longrightarrow>\n       P,C \\<turnstile> Cs \\<sqsubseteq> Ds", "by (auto simp:LeastMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  Subobjs P C Cs\n  \\<forall>Ds.\n     Subobjs P C Ds \\<and>\n     (\\<exists>Ts T m Bs ms.\n         (\\<exists>fs.\n             class P (last Ds) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n         map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>) \\<longrightarrow>\n     P,C \\<turnstile> Cs \\<sqsubseteq> Ds\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from least"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least M = (Ts, T, m) via Cs", "obtain Bs fs ms T Ts m where \n    \"class\": \"class P (last Cs) = Some(Bs, fs, ms)\" and map:\"map_of ms M = Some(Ts,T,m)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least M = (Ts, T, m) via Cs\n\ngoal (1 subgoal):\n 1. (\\<And>Bs fs ms Ts T m.\n        \\<lbrakk>class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>;\n         map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:LeastMethodDef_def MethodDefs_def intro:that)"], ["proof (state)\nthis:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from suboCs' lastCs' \"class\" map all"], ["proof (chain)\npicking this:\n  Subobjs P C Cs'\n  last Cs' = last Cs\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n  \\<forall>Ds.\n     Subobjs P C Ds \\<and>\n     (\\<exists>Ts T m Bs ms.\n         (\\<exists>fs.\n             class P (last Ds) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n         map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>) \\<longrightarrow>\n     P,C \\<turnstile> Cs \\<sqsubseteq> Ds", "have pathCs':\"P,C \\<turnstile> Cs \\<sqsubseteq> Cs'\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs'\n  last Cs' = last Cs\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n  \\<forall>Ds.\n     Subobjs P C Ds \\<and>\n     (\\<exists>Ts T m Bs ms.\n         (\\<exists>fs.\n             class P (last Ds) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n         map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>) \\<longrightarrow>\n     P,C \\<turnstile> Cs \\<sqsubseteq> Ds\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> Cs \\<sqsubseteq> Cs'", "by simp"], ["proof (state)\nthis:\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs'\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "with wf lastCs'"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  last Cs' = last Cs\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs'", "have eq:\"Cs = Cs'\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  last Cs' = last Cs\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs'\n\ngoal (1 subgoal):\n 1. Cs = Cs'", "by(fastforce intro:leq_path_last)"], ["proof (state)\nthis:\n  Cs = Cs'\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from suboCs'' lastCs'' \"class\" map all"], ["proof (chain)\npicking this:\n  Subobjs P C Cs''\n  last Cs'' = last Cs\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n  \\<forall>Ds.\n     Subobjs P C Ds \\<and>\n     (\\<exists>Ts T m Bs ms.\n         (\\<exists>fs.\n             class P (last Ds) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n         map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>) \\<longrightarrow>\n     P,C \\<turnstile> Cs \\<sqsubseteq> Ds", "have pathCs'':\"P,C \\<turnstile> Cs \\<sqsubseteq> Cs''\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs''\n  last Cs'' = last Cs\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n  \\<forall>Ds.\n     Subobjs P C Ds \\<and>\n     (\\<exists>Ts T m Bs ms.\n         (\\<exists>fs.\n             class P (last Ds) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n         map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>) \\<longrightarrow>\n     P,C \\<turnstile> Cs \\<sqsubseteq> Ds\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> Cs \\<sqsubseteq> Cs''", "by simp"], ["proof (state)\nthis:\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs''\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "with wf lastCs''"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  last Cs'' = last Cs\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs''", "have \"Cs = Cs''\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  last Cs'' = last Cs\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs''\n\ngoal (1 subgoal):\n 1. Cs = Cs''", "by(fastforce intro:leq_path_last)"], ["proof (state)\nthis:\n  Cs = Cs''\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = last Cs; Subobjs P C y;\n        last y = last Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "with eq"], ["proof (chain)\npicking this:\n  Cs = Cs'\n  Cs = Cs''", "show \"Cs' = Cs''\""], ["proof (prove)\nusing this:\n  Cs = Cs'\n  Cs = Cs''\n\ngoal (1 subgoal):\n 1. Cs' = Cs''", "by simp"], ["proof (state)\nthis:\n  Cs' = Cs''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma least_field_implies_path_unique:\nassumes least:\"P \\<turnstile> C has least F:T via Cs\" and wf:\"wf_prog wf_md P\"\nshows \"P \\<turnstile> Path C to (hd Cs) unique\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to hd Cs unique", "proof (auto simp add:path_unique_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>Csa. Subobjs P C Csa \\<and> last Csa = hd Cs\n 2. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "(* Existence *)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>Csa. Subobjs P C Csa \\<and> last Csa = hd Cs\n 2. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from least"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least F:T via Cs", "have \"Subobjs P C Cs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least F:T via Cs\n\ngoal (1 subgoal):\n 1. Subobjs P C Cs", "by (simp add:LeastFieldDecl_def FieldDecls_def)"], ["proof (state)\nthis:\n  Subobjs P C Cs\n\ngoal (2 subgoals):\n 1. \\<exists>Csa. Subobjs P C Csa \\<and> last Csa = hd Cs\n 2. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "hence \"Subobjs P C ([hd Cs]@tl Cs)\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n\ngoal (1 subgoal):\n 1. Subobjs P C ([hd Cs] @ tl Cs)", "by - (frule Subobjs_nonempty,simp)"], ["proof (state)\nthis:\n  Subobjs P C ([hd Cs] @ tl Cs)\n\ngoal (2 subgoals):\n 1. \\<exists>Csa. Subobjs P C Csa \\<and> last Csa = hd Cs\n 2. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  Subobjs P C ([hd Cs] @ tl Cs)", "have \"Subobjs P C [hd Cs]\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  Subobjs P C ([hd Cs] @ tl Cs)\n\ngoal (1 subgoal):\n 1. Subobjs P C [hd Cs]", "by (fastforce intro:appendSubobj)"], ["proof (state)\nthis:\n  Subobjs P C [hd Cs]\n\ngoal (2 subgoals):\n 1. \\<exists>Csa. Subobjs P C Csa \\<and> last Csa = hd Cs\n 2. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "thus \"\\<exists>Cs'. Subobjs P C Cs' \\<and> last Cs' = hd Cs\""], ["proof (prove)\nusing this:\n  Subobjs P C [hd Cs]\n\ngoal (1 subgoal):\n 1. \\<exists>Cs'. Subobjs P C Cs' \\<and> last Cs' = hd Cs", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>Cs'. Subobjs P C Cs' \\<and> last Cs' = hd Cs\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "(* Uniqueness *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "fix Cs' Cs''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "assume suboCs':\"Subobjs P C Cs'\" and suboCs'':\"Subobjs P C Cs''\"\n    and lastCs':\"last Cs' = hd Cs\" and lastCs'':\"last Cs'' = hd Cs\""], ["proof (state)\nthis:\n  Subobjs P C Cs'\n  Subobjs P C Cs''\n  last Cs' = hd Cs\n  last Cs'' = hd Cs\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from suboCs'"], ["proof (chain)\npicking this:\n  Subobjs P C Cs'", "have notemptyCs':\"Cs' \\<noteq> []\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs'\n\ngoal (1 subgoal):\n 1. Cs' \\<noteq> []", "by (rule Subobjs_nonempty)"], ["proof (state)\nthis:\n  Cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from suboCs''"], ["proof (chain)\npicking this:\n  Subobjs P C Cs''", "have notemptyCs'':\"Cs'' \\<noteq> []\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs''\n\ngoal (1 subgoal):\n 1. Cs'' \\<noteq> []", "by (rule Subobjs_nonempty)"], ["proof (state)\nthis:\n  Cs'' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from least"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least F:T via Cs", "have suboCs:\"Subobjs P C Cs\"\n    and all:\"\\<forall>Ds. Subobjs P C Ds \\<and> \n     (\\<exists>T Bs fs. (\\<exists>ms. class P (last Ds) = Some (Bs, fs, ms)) \\<and> \n                 map_of fs F = Some T) \\<longrightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Ds\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least F:T via Cs\n\ngoal (1 subgoal):\n 1. Subobjs P C Cs &&&\n    \\<forall>Ds.\n       Subobjs P C Ds \\<and>\n       (\\<exists>T Bs fs.\n           (\\<exists>ms.\n               class P (last Ds) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n           map_of fs F = \\<lfloor>T\\<rfloor>) \\<longrightarrow>\n       P,C \\<turnstile> Cs \\<sqsubseteq> Ds", "by (auto simp:LeastFieldDecl_def FieldDecls_def)"], ["proof (state)\nthis:\n  Subobjs P C Cs\n  \\<forall>Ds.\n     Subobjs P C Ds \\<and>\n     (\\<exists>T Bs fs.\n         (\\<exists>ms.\n             class P (last Ds) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n         map_of fs F = \\<lfloor>T\\<rfloor>) \\<longrightarrow>\n     P,C \\<turnstile> Cs \\<sqsubseteq> Ds\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from least"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least F:T via Cs", "obtain Bs fs ms T where \n    \"class\": \"class P (last Cs) = Some(Bs, fs, ms)\" and map:\"map_of fs F = Some T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least F:T via Cs\n\ngoal (1 subgoal):\n 1. (\\<And>Bs fs ms T.\n        \\<lbrakk>class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>;\n         map_of fs F = \\<lfloor>T\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:LeastFieldDecl_def FieldDecls_def)"], ["proof (state)\nthis:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of fs F = \\<lfloor>T\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from suboCs"], ["proof (chain)\npicking this:\n  Subobjs P C Cs", "have notemptyCs:\"Cs \\<noteq> []\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n\ngoal (1 subgoal):\n 1. Cs \\<noteq> []", "by (rule Subobjs_nonempty)"], ["proof (state)\nthis:\n  Cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from suboCs notemptyCs"], ["proof (chain)\npicking this:\n  Subobjs P C Cs\n  Cs \\<noteq> []", "have suboHd:\"Subobjs P (hd Cs) (hd Cs#tl Cs)\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs\n  Cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Subobjs P (hd Cs) (hd Cs # tl Cs)", "by -(rule_tac C=\"C\" and Cs=\"[]\" in Subobjs_Subobjs,simp)"], ["proof (state)\nthis:\n  Subobjs P (hd Cs) (hd Cs # tl Cs)\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "with suboCs' notemptyCs lastCs' wf"], ["proof (chain)\npicking this:\n  Subobjs P C Cs'\n  Cs \\<noteq> []\n  last Cs' = hd Cs\n  wf_prog wf_md P\n  Subobjs P (hd Cs) (hd Cs # tl Cs)", "have suboCs'App:\"Subobjs P C (Cs'@\\<^sub>pCs)\""], ["proof (prove)\nusing this:\n  Subobjs P C Cs'\n  Cs \\<noteq> []\n  last Cs' = hd Cs\n  wf_prog wf_md P\n  Subobjs P (hd Cs) (hd Cs # tl Cs)\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs' @\\<^sub>p Cs)", "by -(rule Subobjs_appendPath,simp_all)"], ["proof (state)\nthis:\n  Subobjs P C (Cs' @\\<^sub>p Cs)\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from suboHd suboCs'' notemptyCs lastCs'' wf"], ["proof (chain)\npicking this:\n  Subobjs P (hd Cs) (hd Cs # tl Cs)\n  Subobjs P C Cs''\n  Cs \\<noteq> []\n  last Cs'' = hd Cs\n  wf_prog wf_md P", "have suboCs''App:\"Subobjs P C (Cs''@\\<^sub>pCs)\""], ["proof (prove)\nusing this:\n  Subobjs P (hd Cs) (hd Cs # tl Cs)\n  Subobjs P C Cs''\n  Cs \\<noteq> []\n  last Cs'' = hd Cs\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs'' @\\<^sub>p Cs)", "by -(rule Subobjs_appendPath,simp_all)"], ["proof (state)\nthis:\n  Subobjs P C (Cs'' @\\<^sub>p Cs)\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from suboCs'App all \"class\" map notemptyCs"], ["proof (chain)\npicking this:\n  Subobjs P C (Cs' @\\<^sub>p Cs)\n  \\<forall>Ds.\n     Subobjs P C Ds \\<and>\n     (\\<exists>T Bs fs.\n         (\\<exists>ms.\n             class P (last Ds) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n         map_of fs F = \\<lfloor>T\\<rfloor>) \\<longrightarrow>\n     P,C \\<turnstile> Cs \\<sqsubseteq> Ds\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of fs F = \\<lfloor>T\\<rfloor>\n  Cs \\<noteq> []", "have pathCs':\"P,C \\<turnstile> Cs \\<sqsubseteq> Cs'@\\<^sub>pCs\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs' @\\<^sub>p Cs)\n  \\<forall>Ds.\n     Subobjs P C Ds \\<and>\n     (\\<exists>T Bs fs.\n         (\\<exists>ms.\n             class P (last Ds) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n         map_of fs F = \\<lfloor>T\\<rfloor>) \\<longrightarrow>\n     P,C \\<turnstile> Cs \\<sqsubseteq> Ds\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of fs F = \\<lfloor>T\\<rfloor>\n  Cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> Cs \\<sqsubseteq> Cs' @\\<^sub>p Cs", "by -(erule_tac x=\"Cs'@\\<^sub>pCs\" in allE,drule_tac Cs'=\"Cs'\" in appendPath_last,simp)"], ["proof (state)\nthis:\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from suboCs''App all \"class\" map notemptyCs"], ["proof (chain)\npicking this:\n  Subobjs P C (Cs'' @\\<^sub>p Cs)\n  \\<forall>Ds.\n     Subobjs P C Ds \\<and>\n     (\\<exists>T Bs fs.\n         (\\<exists>ms.\n             class P (last Ds) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n         map_of fs F = \\<lfloor>T\\<rfloor>) \\<longrightarrow>\n     P,C \\<turnstile> Cs \\<sqsubseteq> Ds\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of fs F = \\<lfloor>T\\<rfloor>\n  Cs \\<noteq> []", "have pathCs'':\"P,C \\<turnstile> Cs \\<sqsubseteq> Cs''@\\<^sub>pCs\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs'' @\\<^sub>p Cs)\n  \\<forall>Ds.\n     Subobjs P C Ds \\<and>\n     (\\<exists>T Bs fs.\n         (\\<exists>ms.\n             class P (last Ds) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n         map_of fs F = \\<lfloor>T\\<rfloor>) \\<longrightarrow>\n     P,C \\<turnstile> Cs \\<sqsubseteq> Ds\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of fs F = \\<lfloor>T\\<rfloor>\n  Cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> Cs \\<sqsubseteq> Cs'' @\\<^sub>p Cs", "by -(erule_tac x=\"Cs''@\\<^sub>pCs\" in allE,drule_tac Cs'=\"Cs''\" in appendPath_last,simp)"], ["proof (state)\nthis:\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs'' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from pathCs' lastCs' notemptyCs notemptyCs' wf"], ["proof (chain)\npicking this:\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs' @\\<^sub>p Cs\n  last Cs' = hd Cs\n  Cs \\<noteq> []\n  Cs' \\<noteq> []\n  wf_prog wf_md P", "have Cs':\"Cs' = [hd Cs]\""], ["proof (prove)\nusing this:\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs' @\\<^sub>p Cs\n  last Cs' = hd Cs\n  Cs \\<noteq> []\n  Cs' \\<noteq> []\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. Cs' = [hd Cs]", "by (rule path_hd_appendPath)"], ["proof (state)\nthis:\n  Cs' = [hd Cs]\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "from pathCs'' lastCs'' notemptyCs notemptyCs'' wf"], ["proof (chain)\npicking this:\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs'' @\\<^sub>p Cs\n  last Cs'' = hd Cs\n  Cs \\<noteq> []\n  Cs'' \\<noteq> []\n  wf_prog wf_md P", "have \"Cs'' = [hd Cs]\""], ["proof (prove)\nusing this:\n  P,C \\<turnstile> Cs \\<sqsubseteq> Cs'' @\\<^sub>p Cs\n  last Cs'' = hd Cs\n  Cs \\<noteq> []\n  Cs'' \\<noteq> []\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. Cs'' = [hd Cs]", "by (rule path_hd_appendPath)"], ["proof (state)\nthis:\n  Cs'' = [hd Cs]\n\ngoal (1 subgoal):\n 1. \\<And>Csa y.\n       \\<lbrakk>Subobjs P C Csa; last Csa = hd Cs; Subobjs P C y;\n        last y = hd Cs\\<rbrakk>\n       \\<Longrightarrow> Csa = y", "with Cs'"], ["proof (chain)\npicking this:\n  Cs' = [hd Cs]\n  Cs'' = [hd Cs]", "show \"Cs' = Cs''\""], ["proof (prove)\nusing this:\n  Cs' = [hd Cs]\n  Cs'' = [hd Cs]\n\ngoal (1 subgoal):\n 1. Cs' = Cs''", "by simp"], ["proof (state)\nthis:\n  Cs' = Cs''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma least_field_implies_path_via_hd: \n\"\\<lbrakk>P \\<turnstile> C has least F:T via Cs; wf_prog wf_md P\\<rbrakk> \n\\<Longrightarrow> P \\<turnstile> Path C to (hd Cs) via [hd Cs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has least F:T via Cs; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Path C to hd Cs via [hd Cs]", "apply (simp add:LeastFieldDecl_def FieldDecls_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C Cs \\<and>\n             (\\<exists>Bs fs.\n                 (\\<exists>ms.\n                     class P (last Cs) =\n                     \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                 map_of fs F = \\<lfloor>T\\<rfloor>) \\<and>\n             (\\<forall>a.\n                 Subobjs P C a \\<and>\n                 (\\<exists>b Bs fs.\n                     (\\<exists>ms.\n                         class P (last a) =\n                         \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n                     map_of fs F = \\<lfloor>b\\<rfloor>) \\<longrightarrow>\n                 P,C \\<turnstile> Cs \\<sqsubseteq> a);\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Path C to hd Cs via [hd Cs]", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Bs fs ms.\n       \\<lbrakk>wf_prog wf_md P; Subobjs P C Cs;\n        \\<forall>a.\n           Subobjs P C a \\<and>\n           (\\<exists>b Bs fs.\n               (\\<exists>ms.\n                   class P (last a) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n               map_of fs F = \\<lfloor>b\\<rfloor>) \\<longrightarrow>\n           P,C \\<turnstile> Cs \\<sqsubseteq> a;\n        map_of fs F = \\<lfloor>T\\<rfloor>;\n        class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Path C to hd Cs via [hd Cs]", "apply (simp add:path_via_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Bs fs ms.\n       \\<lbrakk>wf_prog wf_md P; Subobjs P C Cs;\n        \\<forall>a.\n           Subobjs P C a \\<and>\n           (\\<exists>b Bs fs.\n               (\\<exists>ms.\n                   class P (last a) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n               map_of fs F = \\<lfloor>b\\<rfloor>) \\<longrightarrow>\n           P,C \\<turnstile> Cs \\<sqsubseteq> a;\n        map_of fs F = \\<lfloor>T\\<rfloor>;\n        class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C [hd Cs]", "apply (frule Subobjs_nonempty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Bs fs ms.\n       \\<lbrakk>wf_prog wf_md P; Subobjs P C Cs;\n        \\<forall>a.\n           Subobjs P C a \\<and>\n           (\\<exists>b Bs fs.\n               (\\<exists>ms.\n                   class P (last a) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n               map_of fs F = \\<lfloor>b\\<rfloor>) \\<longrightarrow>\n           P,C \\<turnstile> Cs \\<sqsubseteq> a;\n        map_of fs F = \\<lfloor>T\\<rfloor>;\n        class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>;\n        Cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C [hd Cs]", "apply (rule_tac Cs'=\"tl Cs\" in appendSubobj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Bs fs ms.\n       \\<lbrakk>wf_prog wf_md P; Subobjs P C Cs;\n        \\<forall>a.\n           Subobjs P C a \\<and>\n           (\\<exists>b Bs fs.\n               (\\<exists>ms.\n                   class P (last a) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n               map_of fs F = \\<lfloor>b\\<rfloor>) \\<longrightarrow>\n           P,C \\<turnstile> Cs \\<sqsubseteq> a;\n        map_of fs F = \\<lfloor>T\\<rfloor>;\n        class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>;\n        Cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Subobjs P C ([hd Cs] @ tl Cs)\n 2. \\<And>Bs fs ms.\n       \\<lbrakk>wf_prog wf_md P; Subobjs P C Cs;\n        \\<forall>a.\n           Subobjs P C a \\<and>\n           (\\<exists>b Bs fs.\n               (\\<exists>ms.\n                   class P (last a) = \\<lfloor>(Bs, fs, ms)\\<rfloor>) \\<and>\n               map_of fs F = \\<lfloor>b\\<rfloor>) \\<longrightarrow>\n           P,C \\<turnstile> Cs \\<sqsubseteq> a;\n        map_of fs F = \\<lfloor>T\\<rfloor>;\n        class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>;\n        Cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> [hd Cs] \\<noteq> []", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_C_to_C_unique:\n\"\\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk> \\<Longrightarrow> P \\<turnstile> Path C to C unique\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Path C to C unique", "apply (unfold path_unique_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>!Cs. Subobjs P C Cs \\<and> last Cs = C", "apply (rule_tac a=\"[C]\" in ex1I)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk>\n    \\<Longrightarrow> Subobjs P C [C] \\<and> last [C] = C\n 2. \\<And>x.\n       \\<lbrakk>wf_prog wf_md P; is_class P C;\n        Subobjs P C x \\<and> last x = C\\<rbrakk>\n       \\<Longrightarrow> x = [C]", "apply (auto intro:Subobjs_Base mdc_eq_last)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma leqR_SubobjsR:\"\\<lbrakk>(C,D) \\<in> (subclsR P)\\<^sup>*; is_class P C; wf_prog wf_md P\\<rbrakk> \n\\<Longrightarrow> \\<exists>Cs. Subobjs\\<^sub>R P C (Cs@[D])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(C, D) \\<in> (subclsR P)\\<^sup>*; is_class P C;\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. Subobjs\\<^sub>R P C (Cs @ [D])", "apply (induct rule:rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_class P C; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. Subobjs\\<^sub>R P C (Cs @ [C])\n 2. \\<And>y z.\n       \\<lbrakk>(C, y) \\<in> (subclsR P)\\<^sup>*;\n        P \\<turnstile> y \\<prec>\\<^sub>R z;\n        \\<lbrakk>is_class P C; wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Cs. Subobjs\\<^sub>R P C (Cs @ [y]);\n        is_class P C; wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs. Subobjs\\<^sub>R P C (Cs @ [z])", "apply (drule SubobjsR_Base)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; Subobjs\\<^sub>R P C [C]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Cs. Subobjs\\<^sub>R P C (Cs @ [C])\n 2. \\<And>y z.\n       \\<lbrakk>(C, y) \\<in> (subclsR P)\\<^sup>*;\n        P \\<turnstile> y \\<prec>\\<^sub>R z;\n        \\<lbrakk>is_class P C; wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Cs. Subobjs\\<^sub>R P C (Cs @ [y]);\n        is_class P C; wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs. Subobjs\\<^sub>R P C (Cs @ [z])", "apply (rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; Subobjs\\<^sub>R P C [C]\\<rbrakk>\n    \\<Longrightarrow> Subobjs\\<^sub>R P C ([] @ [C])\n 2. \\<And>y z.\n       \\<lbrakk>(C, y) \\<in> (subclsR P)\\<^sup>*;\n        P \\<turnstile> y \\<prec>\\<^sub>R z;\n        \\<lbrakk>is_class P C; wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Cs. Subobjs\\<^sub>R P C (Cs @ [y]);\n        is_class P C; wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs. Subobjs\\<^sub>R P C (Cs @ [z])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(C, y) \\<in> (subclsR P)\\<^sup>*;\n        P \\<turnstile> y \\<prec>\\<^sub>R z;\n        \\<lbrakk>is_class P C; wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Cs. Subobjs\\<^sub>R P C (Cs @ [y]);\n        is_class P C; wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Cs. Subobjs\\<^sub>R P C (Cs @ [z])", "apply (auto dest:converse_SubobjsR_Rep)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma assumes path_unique:\"P \\<turnstile> Path C to D unique\" and leq:\"P \\<turnstile> C \\<preceq>\\<^sup>* C'\"\n  and leqR:\"(C',D) \\<in> (subclsR P)\\<^sup>*\" and wf:\"wf_prog wf_md P\"\n  shows \"P \\<turnstile> Path C to C' unique\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "from path_unique"], ["proof (chain)\npicking this:\n  P \\<turnstile> Path C to D unique", "have \"is_class P C\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path C to D unique\n\ngoal (1 subgoal):\n 1. is_class P C", "by (auto intro:Subobjs_isClass simp:path_unique_def)"], ["proof (state)\nthis:\n  is_class P C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "with leq wf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* C'\n  wf_prog wf_md P\n  is_class P C", "obtain Cs where path_via:\"P \\<turnstile> Path C to C' via Cs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* C'\n  wf_prog wf_md P\n  is_class P C\n\ngoal (1 subgoal):\n 1. (\\<And>Cs.\n        P \\<turnstile> Path C to C' via Cs  \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto dest:leq_implies_path)"], ["proof (state)\nthis:\n  P \\<turnstile> Path C to C' via Cs \n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  P \\<turnstile> Path C to C' via Cs", "have classC':\"is_class P C'\""], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  P \\<turnstile> Path C to C' via Cs \n\ngoal (1 subgoal):\n 1. is_class P C'", "by (fastforce intro:Subobj_last_isClass simp:path_via_def)"], ["proof (state)\nthis:\n  is_class P C'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "with leqR wf"], ["proof (chain)\npicking this:\n  (C', D) \\<in> (subclsR P)\\<^sup>*\n  wf_prog wf_md P\n  is_class P C'", "obtain Cs' where subo:\"Subobjs\\<^sub>R P C' Cs'\" and last:\"last Cs' = D\""], ["proof (prove)\nusing this:\n  (C', D) \\<in> (subclsR P)\\<^sup>*\n  wf_prog wf_md P\n  is_class P C'\n\ngoal (1 subgoal):\n 1. (\\<And>Cs'.\n        \\<lbrakk>Subobjs\\<^sub>R P C' Cs'; last Cs' = D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest:leqR_SubobjsR)"], ["proof (state)\nthis:\n  Subobjs\\<^sub>R P C' Cs'\n  last Cs' = D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "hence hd:\"hd Cs' = C'\""], ["proof (prove)\nusing this:\n  Subobjs\\<^sub>R P C' Cs'\n  last Cs' = D\n\ngoal (1 subgoal):\n 1. hd Cs' = C'", "by (fastforce dest:hd_SubobjsR)"], ["proof (state)\nthis:\n  hd Cs' = C'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "with path_via subo wf"], ["proof (chain)\npicking this:\n  P \\<turnstile> Path C to C' via Cs \n  Subobjs\\<^sub>R P C' Cs'\n  wf_prog wf_md P\n  hd Cs' = C'", "have suboApp:\"Subobjs P C (Cs@tl Cs')\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path C to C' via Cs \n  Subobjs\\<^sub>R P C' Cs'\n  wf_prog wf_md P\n  hd Cs' = C'\n\ngoal (1 subgoal):\n 1. Subobjs P C (Cs @ tl Cs')", "by (auto dest!:Subobjs_Rep dest:Subobjs_appendPath \n                simp:path_via_def appendPath_def)"], ["proof (state)\nthis:\n  Subobjs P C (Cs @ tl Cs')\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "hence last':\"last (Cs@tl Cs') = D\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ tl Cs')\n\ngoal (1 subgoal):\n 1. last (Cs @ tl Cs') = D", "proof (cases \"tl Cs' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs'); tl Cs' = []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Cs') = D\n 2. \\<lbrakk>Subobjs P C (Cs @ tl Cs'); tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Cs') = D", "case True"], ["proof (state)\nthis:\n  tl Cs' = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs'); tl Cs' = []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Cs') = D\n 2. \\<lbrakk>Subobjs P C (Cs @ tl Cs'); tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Cs') = D", "with subo hd last"], ["proof (chain)\npicking this:\n  Subobjs\\<^sub>R P C' Cs'\n  hd Cs' = C'\n  last Cs' = D\n  tl Cs' = []", "have \"C' = D\""], ["proof (prove)\nusing this:\n  Subobjs\\<^sub>R P C' Cs'\n  hd Cs' = C'\n  last Cs' = D\n  tl Cs' = []\n\ngoal (1 subgoal):\n 1. C' = D", "by (subgoal_tac \"Cs' = [C']\",auto dest!:SubobjsR_nonempty hd_Cons_tl)"], ["proof (state)\nthis:\n  C' = D\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs'); tl Cs' = []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Cs') = D\n 2. \\<lbrakk>Subobjs P C (Cs @ tl Cs'); tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Cs') = D", "with path_via"], ["proof (chain)\npicking this:\n  P \\<turnstile> Path C to C' via Cs \n  C' = D", "have \"last Cs = D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path C to C' via Cs \n  C' = D\n\ngoal (1 subgoal):\n 1. last Cs = D", "by (auto simp:path_via_def)"], ["proof (state)\nthis:\n  last Cs = D\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs'); tl Cs' = []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Cs') = D\n 2. \\<lbrakk>Subobjs P C (Cs @ tl Cs'); tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Cs') = D", "with True"], ["proof (chain)\npicking this:\n  tl Cs' = []\n  last Cs = D", "show ?thesis"], ["proof (prove)\nusing this:\n  tl Cs' = []\n  last Cs = D\n\ngoal (1 subgoal):\n 1. last (Cs @ tl Cs') = D", "by simp"], ["proof (state)\nthis:\n  last (Cs @ tl Cs') = D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs'); tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Cs') = D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs'); tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Cs') = D", "case False"], ["proof (state)\nthis:\n  tl Cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs'); tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Cs') = D", "from subo"], ["proof (chain)\npicking this:\n  Subobjs\\<^sub>R P C' Cs'", "have Cs':\"Cs' = hd Cs'#tl Cs'\""], ["proof (prove)\nusing this:\n  Subobjs\\<^sub>R P C' Cs'\n\ngoal (1 subgoal):\n 1. Cs' = hd Cs' # tl Cs'", "by (auto dest:SubobjsR_nonempty)"], ["proof (state)\nthis:\n  Cs' = hd Cs' # tl Cs'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs'); tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Cs') = D", "from False"], ["proof (chain)\npicking this:\n  tl Cs' \\<noteq> []", "have \"last(hd Cs'#tl Cs') = last (tl Cs')\""], ["proof (prove)\nusing this:\n  tl Cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (hd Cs' # tl Cs') = last (tl Cs')", "by (rule last_ConsR)"], ["proof (state)\nthis:\n  last (hd Cs' # tl Cs') = last (tl Cs')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs'); tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Cs') = D", "with False Cs' last"], ["proof (chain)\npicking this:\n  tl Cs' \\<noteq> []\n  Cs' = hd Cs' # tl Cs'\n  last Cs' = D\n  last (hd Cs' # tl Cs') = last (tl Cs')", "show ?thesis"], ["proof (prove)\nusing this:\n  tl Cs' \\<noteq> []\n  Cs' = hd Cs' # tl Cs'\n  last Cs' = D\n  last (hd Cs' # tl Cs') = last (tl Cs')\n\ngoal (1 subgoal):\n 1. last (Cs @ tl Cs') = D", "by simp"], ["proof (state)\nthis:\n  last (Cs @ tl Cs') = D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last (Cs @ tl Cs') = D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "with path_unique suboApp"], ["proof (chain)\npicking this:\n  P \\<turnstile> Path C to D unique\n  Subobjs P C (Cs @ tl Cs')\n  last (Cs @ tl Cs') = D", "have all:\"\\<forall>Ds. Subobjs P C Ds \\<and> last Ds = D \\<longrightarrow> Ds = Cs@tl Cs'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path C to D unique\n  Subobjs P C (Cs @ tl Cs')\n  last (Cs @ tl Cs') = D\n\ngoal (1 subgoal):\n 1. \\<forall>Ds.\n       Subobjs P C Ds \\<and> last Ds = D \\<longrightarrow> Ds = Cs @ tl Cs'", "by (auto simp add:path_unique_def)"], ["proof (state)\nthis:\n  \\<forall>Ds.\n     Subobjs P C Ds \\<and> last Ds = D \\<longrightarrow> Ds = Cs @ tl Cs'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "{"], ["proof (state)\nthis:\n  \\<forall>Ds.\n     Subobjs P C Ds \\<and> last Ds = D \\<longrightarrow> Ds = Cs @ tl Cs'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "fix Cs''"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "assume path_via2:\"P \\<turnstile> Path C to C' via Cs''\" and noteq:\"Cs'' \\<noteq> Cs\""], ["proof (state)\nthis:\n  P \\<turnstile> Path C to C' via Cs'' \n  Cs'' \\<noteq> Cs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "with suboApp"], ["proof (chain)\npicking this:\n  Subobjs P C (Cs @ tl Cs')\n  P \\<turnstile> Path C to C' via Cs'' \n  Cs'' \\<noteq> Cs", "have \"last (Cs''@tl Cs') = D\""], ["proof (prove)\nusing this:\n  Subobjs P C (Cs @ tl Cs')\n  P \\<turnstile> Path C to C' via Cs'' \n  Cs'' \\<noteq> Cs\n\ngoal (1 subgoal):\n 1. last (Cs'' @ tl Cs') = D", "proof (cases \"tl Cs' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs');\n     P \\<turnstile> Path C to C' via Cs'' ; Cs'' \\<noteq> Cs;\n     tl Cs' = []\\<rbrakk>\n    \\<Longrightarrow> last (Cs'' @ tl Cs') = D\n 2. \\<lbrakk>Subobjs P C (Cs @ tl Cs');\n     P \\<turnstile> Path C to C' via Cs'' ; Cs'' \\<noteq> Cs;\n     tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs'' @ tl Cs') = D", "case True"], ["proof (state)\nthis:\n  tl Cs' = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs');\n     P \\<turnstile> Path C to C' via Cs'' ; Cs'' \\<noteq> Cs;\n     tl Cs' = []\\<rbrakk>\n    \\<Longrightarrow> last (Cs'' @ tl Cs') = D\n 2. \\<lbrakk>Subobjs P C (Cs @ tl Cs');\n     P \\<turnstile> Path C to C' via Cs'' ; Cs'' \\<noteq> Cs;\n     tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs'' @ tl Cs') = D", "with subo hd last"], ["proof (chain)\npicking this:\n  Subobjs\\<^sub>R P C' Cs'\n  hd Cs' = C'\n  last Cs' = D\n  tl Cs' = []", "have \"C' = D\""], ["proof (prove)\nusing this:\n  Subobjs\\<^sub>R P C' Cs'\n  hd Cs' = C'\n  last Cs' = D\n  tl Cs' = []\n\ngoal (1 subgoal):\n 1. C' = D", "by (subgoal_tac \"Cs' = [C']\",auto dest!:SubobjsR_nonempty hd_Cons_tl)"], ["proof (state)\nthis:\n  C' = D\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs');\n     P \\<turnstile> Path C to C' via Cs'' ; Cs'' \\<noteq> Cs;\n     tl Cs' = []\\<rbrakk>\n    \\<Longrightarrow> last (Cs'' @ tl Cs') = D\n 2. \\<lbrakk>Subobjs P C (Cs @ tl Cs');\n     P \\<turnstile> Path C to C' via Cs'' ; Cs'' \\<noteq> Cs;\n     tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs'' @ tl Cs') = D", "with path_via2"], ["proof (chain)\npicking this:\n  P \\<turnstile> Path C to C' via Cs'' \n  C' = D", "have \"last Cs'' = D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path C to C' via Cs'' \n  C' = D\n\ngoal (1 subgoal):\n 1. last Cs'' = D", "by (auto simp:path_via_def)"], ["proof (state)\nthis:\n  last Cs'' = D\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs');\n     P \\<turnstile> Path C to C' via Cs'' ; Cs'' \\<noteq> Cs;\n     tl Cs' = []\\<rbrakk>\n    \\<Longrightarrow> last (Cs'' @ tl Cs') = D\n 2. \\<lbrakk>Subobjs P C (Cs @ tl Cs');\n     P \\<turnstile> Path C to C' via Cs'' ; Cs'' \\<noteq> Cs;\n     tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs'' @ tl Cs') = D", "with True"], ["proof (chain)\npicking this:\n  tl Cs' = []\n  last Cs'' = D", "show ?thesis"], ["proof (prove)\nusing this:\n  tl Cs' = []\n  last Cs'' = D\n\ngoal (1 subgoal):\n 1. last (Cs'' @ tl Cs') = D", "by simp"], ["proof (state)\nthis:\n  last (Cs'' @ tl Cs') = D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs');\n     P \\<turnstile> Path C to C' via Cs'' ; Cs'' \\<noteq> Cs;\n     tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs'' @ tl Cs') = D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs');\n     P \\<turnstile> Path C to C' via Cs'' ; Cs'' \\<noteq> Cs;\n     tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs'' @ tl Cs') = D", "case False"], ["proof (state)\nthis:\n  tl Cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs');\n     P \\<turnstile> Path C to C' via Cs'' ; Cs'' \\<noteq> Cs;\n     tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs'' @ tl Cs') = D", "from subo"], ["proof (chain)\npicking this:\n  Subobjs\\<^sub>R P C' Cs'", "have Cs':\"Cs' = hd Cs'#tl Cs'\""], ["proof (prove)\nusing this:\n  Subobjs\\<^sub>R P C' Cs'\n\ngoal (1 subgoal):\n 1. Cs' = hd Cs' # tl Cs'", "by (auto dest:SubobjsR_nonempty)"], ["proof (state)\nthis:\n  Cs' = hd Cs' # tl Cs'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs');\n     P \\<turnstile> Path C to C' via Cs'' ; Cs'' \\<noteq> Cs;\n     tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs'' @ tl Cs') = D", "from False"], ["proof (chain)\npicking this:\n  tl Cs' \\<noteq> []", "have \"last(hd Cs'#tl Cs') = last (tl Cs')\""], ["proof (prove)\nusing this:\n  tl Cs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (hd Cs' # tl Cs') = last (tl Cs')", "by (rule last_ConsR)"], ["proof (state)\nthis:\n  last (hd Cs' # tl Cs') = last (tl Cs')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subobjs P C (Cs @ tl Cs');\n     P \\<turnstile> Path C to C' via Cs'' ; Cs'' \\<noteq> Cs;\n     tl Cs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs'' @ tl Cs') = D", "with False Cs' last"], ["proof (chain)\npicking this:\n  tl Cs' \\<noteq> []\n  Cs' = hd Cs' # tl Cs'\n  last Cs' = D\n  last (hd Cs' # tl Cs') = last (tl Cs')", "show ?thesis"], ["proof (prove)\nusing this:\n  tl Cs' \\<noteq> []\n  Cs' = hd Cs' # tl Cs'\n  last Cs' = D\n  last (hd Cs' # tl Cs') = last (tl Cs')\n\ngoal (1 subgoal):\n 1. last (Cs'' @ tl Cs') = D", "by simp"], ["proof (state)\nthis:\n  last (Cs'' @ tl Cs') = D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last (Cs'' @ tl Cs') = D\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "with path_via2 noteq"], ["proof (chain)\npicking this:\n  P \\<turnstile> Path C to C' via Cs'' \n  Cs'' \\<noteq> Cs\n  last (Cs'' @ tl Cs') = D", "have False"], ["proof (prove)\nusing this:\n  P \\<turnstile> Path C to C' via Cs'' \n  Cs'' \\<noteq> Cs\n  last (Cs'' @ tl Cs') = D\n\ngoal (1 subgoal):\n 1. False", "using all subo hd wf"], ["proof (prove)\nusing this:\n  P \\<turnstile> Path C to C' via Cs'' \n  Cs'' \\<noteq> Cs\n  last (Cs'' @ tl Cs') = D\n  \\<forall>Ds.\n     Subobjs P C Ds \\<and> last Ds = D \\<longrightarrow> Ds = Cs @ tl Cs'\n  Subobjs\\<^sub>R P C' Cs'\n  hd Cs' = C'\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. False", "apply (auto simp:path_via_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs'' \\<noteq> Cs;\n     \\<forall>Ds.\n        Subobjs P C Ds \\<and>\n        last Ds = last (Cs'' @ tl Cs') \\<longrightarrow>\n        Ds = Cs @ tl Cs';\n     Subobjs\\<^sub>R P (hd Cs') Cs'; wf_prog wf_md P;\n     D = last (Cs'' @ tl Cs'); C' = hd Cs'; Subobjs P C Cs'';\n     last Cs'' = hd Cs'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule Subobjs_Rep)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Cs'' \\<noteq> Cs;\n     \\<forall>Ds.\n        Subobjs P C Ds \\<and>\n        last Ds = last (Cs'' @ tl Cs') \\<longrightarrow>\n        Ds = Cs @ tl Cs';\n     wf_prog wf_md P; D = last (Cs'' @ tl Cs'); C' = hd Cs';\n     Subobjs P C Cs''; last Cs'' = hd Cs'; Subobjs P (hd Cs') Cs'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule Subobjs_appendPath)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Cs'' \\<noteq> Cs;\n     \\<forall>Ds.\n        Subobjs P C Ds \\<and>\n        last Ds = last (Cs'' @ tl Cs') \\<longrightarrow>\n        Ds = Cs @ tl Cs';\n     wf_prog wf_md P; D = last (Cs'' @ tl Cs'); C' = hd Cs';\n     last Cs'' = hd Cs'; Subobjs P (hd Cs') Cs'\\<rbrakk>\n    \\<Longrightarrow> Subobjs P (last Cs'') ?Ds16\n 2. \\<lbrakk>Cs'' \\<noteq> Cs;\n     \\<forall>Ds.\n        Subobjs P C Ds \\<and>\n        last Ds = last (Cs'' @ tl Cs') \\<longrightarrow>\n        Ds = Cs @ tl Cs';\n     wf_prog wf_md P; D = last (Cs'' @ tl Cs'); C' = hd Cs';\n     last Cs'' = hd Cs'; Subobjs P (hd Cs') Cs'\\<rbrakk>\n    \\<Longrightarrow> wf_prog ?wf_md16 P\n 3. \\<lbrakk>Cs'' \\<noteq> Cs;\n     \\<forall>Ds.\n        Subobjs P C Ds \\<and>\n        last Ds = last (Cs'' @ tl Cs') \\<longrightarrow>\n        Ds = Cs @ tl Cs';\n     wf_prog wf_md P; D = last (Cs'' @ tl Cs'); C' = hd Cs';\n     last Cs'' = hd Cs'; Subobjs P (hd Cs') Cs';\n     Subobjs P C (Cs'' @\\<^sub>p ?Ds16)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto simp:appendPath_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P \\<turnstile> Path C to C' via ?Cs''2 ;\n   ?Cs''2 \\<noteq> Cs\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "with path_via"], ["proof (chain)\npicking this:\n  P \\<turnstile> Path C to C' via Cs \n  \\<lbrakk>P \\<turnstile> Path C to C' via ?Cs''2 ;\n   ?Cs''2 \\<noteq> Cs\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> Path C to C' via Cs \n  \\<lbrakk>P \\<turnstile> Path C to C' via ?Cs''2 ;\n   ?Cs''2 \\<noteq> Cs\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. P \\<turnstile> Path C to C' unique", "by (auto simp:path_via_def path_unique_def)"], ["proof (state)\nthis:\n  P \\<turnstile> Path C to C' unique\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Well-formedness and member lookup\\<close>"], ["", "lemma has_path_has:\n\"\\<lbrakk>P \\<turnstile> Path D to C via Ds; P \\<turnstile> C has M = (Ts,T,m) via Cs; wf_prog wf_md P\\<rbrakk> \n  \\<Longrightarrow> P \\<turnstile> D has M = (Ts,T,m) via Ds@\\<^sub>pCs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Path D to C via Ds ;\n     P \\<turnstile> C has M = (Ts, T, m) via Cs; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> D has M = (Ts, T,\n          m) via Ds @\\<^sub>p Cs", "by (clarsimp simp:HasMethodDef_def MethodDefs_def,frule Subobjs_nonempty,\n         drule_tac Cs'=\"Ds\" in appendPath_last,\n         fastforce intro:Subobjs_appendPath simp:path_via_def)"], ["", "lemma has_least_wf_mdecl:\n  \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> C has least M = m via Cs \\<rbrakk> \n\\<Longrightarrow> wf_mdecl wf_md P (last Cs) (M,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     P \\<turnstile> C has least M = m via Cs\\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf_md P (last Cs) (M, m)", "by(fastforce dest:visible_methods_exist class_wf map_of_SomeD \n                 simp:LeastMethodDef_def wf_cdecl_def)"], ["", "lemma has_overrider_wf_mdecl:\n  \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> (C,Cs) has overrider M = m via Cs' \\<rbrakk> \n\\<Longrightarrow> wf_mdecl wf_md P (last Cs') (M,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     P \\<turnstile> (C, Cs) has overrider M = m via Cs'\\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf_md P (last Cs') (M, m)", "by(fastforce dest:visible_methods_exist map_of_SomeD class_wf\n                 simp:FinalOverriderMethodDef_def OverriderMethodDefs_def \n                      MinimalMethodDefs_def wf_cdecl_def)"], ["", "lemma select_method_wf_mdecl:\n  \"\\<lbrakk> wf_prog wf_md P; P \\<turnstile> (C,Cs) selects M = m via Cs' \\<rbrakk> \n\\<Longrightarrow> wf_mdecl wf_md P (last Cs') (M,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P;\n     P \\<turnstile> (C,Cs) selects M = m via Cs'\\<rbrakk>\n    \\<Longrightarrow> wf_mdecl wf_md P (last Cs') (M, m)", "by(fastforce elim:SelectMethodDef.induct \n                 intro:has_least_wf_mdecl has_overrider_wf_mdecl)"], ["", "lemma wf_sees_method_fun:\n\"\\<lbrakk>P \\<turnstile> C has least M = mthd via Cs; P \\<turnstile> C has least M = mthd' via Cs'; \n  wf_prog wf_md P\\<rbrakk>\n  \\<Longrightarrow> mthd = mthd' \\<and> Cs = Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> C has least M = mthd via Cs;\n     P \\<turnstile> C has least M = mthd' via Cs'; wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> mthd = mthd' \\<and> Cs = Cs'", "apply (auto simp:LeastMethodDef_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs', mthd') \\<Rightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow>\n          P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a\\<rbrakk>\n    \\<Longrightarrow> mthd = mthd'\n 2. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs', mthd') \\<Rightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow>\n          P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'", "apply (erule_tac x=\"(Cs', mthd')\" in ballE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow> P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a;\n     case (Cs', mthd') of\n     (Cs', mthd') \\<Rightarrow>\n       P,C \\<turnstile> Cs \\<sqsubseteq> Cs'\\<rbrakk>\n    \\<Longrightarrow> mthd = mthd'\n 2. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow> P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a;\n     (Cs', mthd') \\<notin> MethodDefs P C M\\<rbrakk>\n    \\<Longrightarrow> mthd = mthd'\n 3. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs', mthd') \\<Rightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow>\n          P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'", "apply (erule_tac x=\"(Cs, mthd)\" in ballE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     case (Cs', mthd') of\n     (Cs', mthd') \\<Rightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     case (Cs, mthd) of\n     (Cs'a, mthd') \\<Rightarrow>\n       P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a\\<rbrakk>\n    \\<Longrightarrow> mthd = mthd'\n 2. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     case (Cs', mthd') of\n     (Cs', mthd') \\<Rightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     (Cs, mthd) \\<notin> MethodDefs P C M\\<rbrakk>\n    \\<Longrightarrow> mthd = mthd'\n 3. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow> P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a;\n     (Cs', mthd') \\<notin> MethodDefs P C M\\<rbrakk>\n    \\<Longrightarrow> mthd = mthd'\n 4. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs', mthd') \\<Rightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow>\n          P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     P,C \\<turnstile> Cs' \\<sqsubseteq> Cs\\<rbrakk>\n    \\<Longrightarrow> mthd = mthd'\n 2. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs', mthd') \\<Rightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow>\n          P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'", "apply (drule leq_path_asym2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     P,C \\<turnstile> Cs' \\<sqsubseteq> Cs\\<rbrakk>\n    \\<Longrightarrow> P,C \\<turnstile> Cs' \\<sqsubseteq> Cs\n 2. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     P,C \\<turnstile> Cs' \\<sqsubseteq> Cs\\<rbrakk>\n    \\<Longrightarrow> wf_prog ?wf_md9 P\n 3. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     P,C \\<turnstile> Cs' \\<sqsubseteq> Cs; Cs = Cs'\\<rbrakk>\n    \\<Longrightarrow> mthd = mthd'\n 4. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs', mthd') \\<Rightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow>\n          P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; (Cs', mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M; Cs = Cs'\\<rbrakk>\n    \\<Longrightarrow> mthd = mthd'\n 2. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs', mthd') \\<Rightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow>\n          P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'", "apply (rule sees_methods_fun)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; (Cs', mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M; Cs = Cs'\\<rbrakk>\n    \\<Longrightarrow> (?Cs13, mthd) \\<in> MethodDefs ?P13 ?C13 ?M13\n 2. \\<lbrakk>wf_prog wf_md P; (Cs', mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M; Cs = Cs'\\<rbrakk>\n    \\<Longrightarrow> (?Cs13, mthd') \\<in> MethodDefs ?P13 ?C13 ?M13\n 3. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs', mthd') \\<Rightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow>\n          P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs', mthd') \\<Rightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow>\n          P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'", "apply (erule_tac x=\"(Cs', mthd')\" in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow> P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a;\n     case (Cs', mthd') of\n     (Cs', mthd') \\<Rightarrow>\n       P,C \\<turnstile> Cs \\<sqsubseteq> Cs'\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'\n 2. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow> P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a;\n     (Cs', mthd') \\<notin> MethodDefs P C M\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'", "apply (erule_tac x=\"(Cs, mthd)\" in ballE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     case (Cs', mthd') of\n     (Cs', mthd') \\<Rightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     case (Cs, mthd) of\n     (Cs'a, mthd') \\<Rightarrow>\n       P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'\n 2. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     case (Cs', mthd') of\n     (Cs', mthd') \\<Rightarrow> P,C \\<turnstile> Cs \\<sqsubseteq> Cs';\n     (Cs, mthd) \\<notin> MethodDefs P C M\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'\n 3. \\<lbrakk>wf_prog wf_md P; (Cs, mthd) \\<in> MethodDefs P C M;\n     (Cs', mthd') \\<in> MethodDefs P C M;\n     \\<forall>x\\<in>MethodDefs P C M.\n        case x of\n        (Cs'a, mthd') \\<Rightarrow> P,C \\<turnstile> Cs' \\<sqsubseteq> Cs'a;\n     (Cs', mthd') \\<notin> MethodDefs P C M\\<rbrakk>\n    \\<Longrightarrow> Cs = Cs'", "apply (auto intro:leq_path_asym2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_select_method_fun: \n  assumes wf:\"wf_prog wf_md P\"\n  shows \"\\<lbrakk>P \\<turnstile> (C,Cs) selects M = mthd via Cs'; P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\\<rbrakk>\n  \\<Longrightarrow> mthd = mthd' \\<and> Cs' = Cs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> (C,Cs) selects M = mthd via Cs';\n     P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\\<rbrakk>\n    \\<Longrightarrow> mthd = mthd' \\<and> Cs' = Cs''", "proof(induct rule:SelectMethodDef.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C M mthd Cs' Cs.\n       \\<lbrakk>P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd' \\<and> Cs' = Cs''\n 2. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd' \\<and> Cs' = Cs''", "case (dyn_unique C M mthd Cs' Cs)"], ["proof (state)\nthis:\n  P \\<turnstile> C has least M = mthd via Cs'\n  P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\n\ngoal (2 subgoals):\n 1. \\<And>C M mthd Cs' Cs.\n       \\<lbrakk>P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd' \\<and> Cs' = Cs''\n 2. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd' \\<and> Cs' = Cs''", "have \"P \\<turnstile> (C, Cs) selects M = mthd' via Cs''\"\n    and \"P \\<turnstile> C has least M = mthd via Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> (C,Cs) selects M = mthd' via Cs'' &&&\n    P \\<turnstile> C has least M = mthd via Cs'", "by fact+"], ["proof (state)\nthis:\n  P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\n  P \\<turnstile> C has least M = mthd via Cs'\n\ngoal (2 subgoals):\n 1. \\<And>C M mthd Cs' Cs.\n       \\<lbrakk>P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd' \\<and> Cs' = Cs''\n 2. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd' \\<and> Cs' = Cs''", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\n  P \\<turnstile> C has least M = mthd via Cs'\n\ngoal (1 subgoal):\n 1. mthd = mthd' \\<and> Cs' = Cs''", "proof(induct rule:SelectMethodDef.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C M mthd Cs' Cs.\n       \\<lbrakk>P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'\n 2. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'", "case (dyn_unique D M' mthd' Ds' Ds)"], ["proof (state)\nthis:\n  P \\<turnstile> D has least M' = mthd' via Ds'\n  P \\<turnstile> D has least M' = mthd via Cs'\n\ngoal (2 subgoals):\n 1. \\<And>C M mthd Cs' Cs.\n       \\<lbrakk>P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'\n 2. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'", "have \"P \\<turnstile> D has least M' = mthd' via Ds'\" \n      and \"P \\<turnstile> D has least M' = mthd via Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D has least M' = mthd' via Ds' &&&\n    P \\<turnstile> D has least M' = mthd via Cs'", "by fact+"], ["proof (state)\nthis:\n  P \\<turnstile> D has least M' = mthd' via Ds'\n  P \\<turnstile> D has least M' = mthd via Cs'\n\ngoal (2 subgoals):\n 1. \\<And>C M mthd Cs' Cs.\n       \\<lbrakk>P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'\n 2. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'", "with wf"], ["proof (chain)\npicking this:\n  wf_prog wf_md P\n  P \\<turnstile> D has least M' = mthd' via Ds'\n  P \\<turnstile> D has least M' = mthd via Cs'", "show ?case"], ["proof (prove)\nusing this:\n  wf_prog wf_md P\n  P \\<turnstile> D has least M' = mthd' via Ds'\n  P \\<turnstile> D has least M' = mthd via Cs'\n\ngoal (1 subgoal):\n 1. mthd = mthd' \\<and> Cs' = Ds'", "by -(rule wf_sees_method_fun,simp_all)"], ["proof (state)\nthis:\n  mthd = mthd' \\<and> Cs' = Ds'\n\ngoal (1 subgoal):\n 1. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'", "case (dyn_ambiguous D M' Ds mthd' Ds')"], ["proof (state)\nthis:\n  \\<forall>mthd Cs'. \\<not> P \\<turnstile> D has least M' = mthd via Cs'\n  P \\<turnstile> (D, Ds) has overrider M' = mthd' via Ds'\n  P \\<turnstile> D has least M' = mthd via Cs'\n\ngoal (1 subgoal):\n 1. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'", "have \"\\<forall>mthd Cs'. \\<not> P \\<turnstile> D has least M' = mthd via Cs'\"\n      and \"P \\<turnstile> D has least M' = mthd via Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>mthd Cs'.\n       \\<not> P \\<turnstile> D has least M' = mthd via Cs' &&&\n    P \\<turnstile> D has least M' = mthd via Cs'", "by fact+"], ["proof (state)\nthis:\n  \\<forall>mthd Cs'. \\<not> P \\<turnstile> D has least M' = mthd via Cs'\n  P \\<turnstile> D has least M' = mthd via Cs'\n\ngoal (1 subgoal):\n 1. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>mthd Cs'. \\<not> P \\<turnstile> D has least M' = mthd via Cs'\n  P \\<turnstile> D has least M' = mthd via Cs'\n\ngoal (1 subgoal):\n 1. mthd = mthd' \\<and> Cs' = Ds'", "by blast"], ["proof (state)\nthis:\n  mthd = mthd' \\<and> Cs' = Ds'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mthd = mthd' \\<and> Cs' = Cs''\n\ngoal (1 subgoal):\n 1. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd' \\<and> Cs' = Cs''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd' \\<and> Cs' = Cs''", "case (dyn_ambiguous C M Cs mthd Cs')"], ["proof (state)\nthis:\n  \\<forall>mthd Cs'. \\<not> P \\<turnstile> C has least M = mthd via Cs'\n  P \\<turnstile> (C, Cs) has overrider M = mthd via Cs'\n  P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\n\ngoal (1 subgoal):\n 1. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd' \\<and> Cs' = Cs''", "have \"P \\<turnstile> (C, Cs) selects M = mthd' via Cs''\"\n    and \"P \\<turnstile> (C, Cs) has overrider M = mthd via Cs'\"\n    and \"\\<forall>mthd Cs'. \\<not> P \\<turnstile> C has least M = mthd via Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> (C,Cs) selects M = mthd' via Cs'' &&&\n    P \\<turnstile> (C, Cs) has overrider M = mthd via Cs' &&&\n    \\<forall>mthd Cs'. \\<not> P \\<turnstile> C has least M = mthd via Cs'", "by fact+"], ["proof (state)\nthis:\n  P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\n  P \\<turnstile> (C, Cs) has overrider M = mthd via Cs'\n  \\<forall>mthd Cs'. \\<not> P \\<turnstile> C has least M = mthd via Cs'\n\ngoal (1 subgoal):\n 1. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd' \\<and> Cs' = Cs''", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> (C,Cs) selects M = mthd' via Cs''\n  P \\<turnstile> (C, Cs) has overrider M = mthd via Cs'\n  \\<forall>mthd Cs'. \\<not> P \\<turnstile> C has least M = mthd via Cs'\n\ngoal (1 subgoal):\n 1. mthd = mthd' \\<and> Cs' = Cs''", "proof(induct rule:SelectMethodDef.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C M mthd Cs' Cs.\n       \\<lbrakk>P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        \\<forall>mthd Cs'.\n           \\<not> P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'\n 2. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        \\<forall>mthd Cs'.\n           \\<not> P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'", "case (dyn_unique D M' mthd' Ds' Ds)"], ["proof (state)\nthis:\n  P \\<turnstile> D has least M' = mthd' via Ds'\n  P \\<turnstile> (D, Ds) has overrider M' = mthd via Cs'\n  \\<forall>mthd Cs'. \\<not> P \\<turnstile> D has least M' = mthd via Cs'\n\ngoal (2 subgoals):\n 1. \\<And>C M mthd Cs' Cs.\n       \\<lbrakk>P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        \\<forall>mthd Cs'.\n           \\<not> P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'\n 2. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        \\<forall>mthd Cs'.\n           \\<not> P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'", "have \"P \\<turnstile> D has least M' = mthd' via Ds'\"\n      and \"\\<forall>mthd Cs'. \\<not> P \\<turnstile> D has least M' = mthd via Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> D has least M' = mthd' via Ds' &&&\n    \\<forall>mthd Cs'. \\<not> P \\<turnstile> D has least M' = mthd via Cs'", "by fact+"], ["proof (state)\nthis:\n  P \\<turnstile> D has least M' = mthd' via Ds'\n  \\<forall>mthd Cs'. \\<not> P \\<turnstile> D has least M' = mthd via Cs'\n\ngoal (2 subgoals):\n 1. \\<And>C M mthd Cs' Cs.\n       \\<lbrakk>P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        \\<forall>mthd Cs'.\n           \\<not> P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'\n 2. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        \\<forall>mthd Cs'.\n           \\<not> P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> D has least M' = mthd' via Ds'\n  \\<forall>mthd Cs'. \\<not> P \\<turnstile> D has least M' = mthd via Cs'\n\ngoal (1 subgoal):\n 1. mthd = mthd' \\<and> Cs' = Ds'", "by blast"], ["proof (state)\nthis:\n  mthd = mthd' \\<and> Cs' = Ds'\n\ngoal (1 subgoal):\n 1. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        \\<forall>mthd Cs'.\n           \\<not> P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        \\<forall>mthd Cs'.\n           \\<not> P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'", "case (dyn_ambiguous D M' Ds mthd' Ds')"], ["proof (state)\nthis:\n  \\<forall>mthd Cs'. \\<not> P \\<turnstile> D has least M' = mthd via Cs'\n  P \\<turnstile> (D, Ds) has overrider M' = mthd' via Ds'\n  P \\<turnstile> (D, Ds) has overrider M' = mthd via Cs'\n  \\<forall>mthd Cs'. \\<not> P \\<turnstile> D has least M' = mthd via Cs'\n\ngoal (1 subgoal):\n 1. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        \\<forall>mthd Cs'.\n           \\<not> P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'", "have \"P \\<turnstile> (D, Ds) has overrider M' = mthd' via Ds'\"\n      and \"P \\<turnstile> (D, Ds) has overrider M' = mthd via Cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> (D, Ds) has overrider M' = mthd' via Ds' &&&\n    P \\<turnstile> (D, Ds) has overrider M' = mthd via Cs'", "by fact+"], ["proof (state)\nthis:\n  P \\<turnstile> (D, Ds) has overrider M' = mthd' via Ds'\n  P \\<turnstile> (D, Ds) has overrider M' = mthd via Cs'\n\ngoal (1 subgoal):\n 1. \\<And>C M Cs mthd Cs'.\n       \\<lbrakk>\\<forall>mthd Cs'.\n                   \\<not> P \\<turnstile> C has least M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        P \\<turnstile> (C, Cs) has overrider M = mthd via Cs';\n        \\<forall>mthd Cs'.\n           \\<not> P \\<turnstile> C has least M = mthd via Cs'\\<rbrakk>\n       \\<Longrightarrow> mthd = mthd \\<and> Cs' = Cs'", "thus ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> (D, Ds) has overrider M' = mthd' via Ds'\n  P \\<turnstile> (D, Ds) has overrider M' = mthd via Cs'\n\ngoal (1 subgoal):\n 1. mthd = mthd' \\<and> Cs' = Ds'", "by(fastforce dest:overrider_method_fun)"], ["proof (state)\nthis:\n  mthd = mthd' \\<and> Cs' = Ds'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mthd = mthd' \\<and> Cs' = Cs''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma least_field_is_type:\nassumes field:\"P \\<turnstile> C has least F:T via Cs\" and wf:\"wf_prog wf_md P\"\nshows \"is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type P T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_type P T", "from field"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least F:T via Cs", "have \"(Cs,T) \\<in> FieldDecls P C F\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least F:T via Cs\n\ngoal (1 subgoal):\n 1. (Cs, T) \\<in> FieldDecls P C F", "by (simp add:LeastFieldDecl_def)"], ["proof (state)\nthis:\n  (Cs, T) \\<in> FieldDecls P C F\n\ngoal (1 subgoal):\n 1. is_type P T", "from this"], ["proof (chain)\npicking this:\n  (Cs, T) \\<in> FieldDecls P C F", "obtain Bs fs ms \n    where \"map_of fs F = Some T\" \n    and \"class\": \"class P (last Cs) = Some (Bs,fs,ms)\""], ["proof (prove)\nusing this:\n  (Cs, T) \\<in> FieldDecls P C F\n\ngoal (1 subgoal):\n 1. (\\<And>fs Bs ms.\n        \\<lbrakk>map_of fs F = \\<lfloor>T\\<rfloor>;\n         class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:FieldDecls_def)"], ["proof (state)\nthis:\n  map_of fs F = \\<lfloor>T\\<rfloor>\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. is_type P T", "hence \"(F,T) \\<in> set fs\""], ["proof (prove)\nusing this:\n  map_of fs F = \\<lfloor>T\\<rfloor>\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (F, T) \\<in> set fs", "by (simp add:map_of_SomeD)"], ["proof (state)\nthis:\n  (F, T) \\<in> set fs\n\ngoal (1 subgoal):\n 1. is_type P T", "with \"class\" wf"], ["proof (chain)\npicking this:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  wf_prog wf_md P\n  (F, T) \\<in> set fs", "show ?thesis"], ["proof (prove)\nusing this:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  wf_prog wf_md P\n  (F, T) \\<in> set fs\n\ngoal (1 subgoal):\n 1. is_type P T", "by(fastforce dest!: class_wf simp: wf_cdecl_def wf_fdecl_def)"], ["proof (state)\nthis:\n  is_type P T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma least_method_is_type:\nassumes \"method\":\"P \\<turnstile> C has least M = (Ts,T,m) via Cs\" and wf:\"wf_prog wf_md P\"\nshows \"is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type P T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_type P T", "from \"method\""], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least M = (Ts, T, m) via Cs", "have \"(Cs,Ts,T,m) \\<in> MethodDefs P C M\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least M = (Ts, T, m) via Cs\n\ngoal (1 subgoal):\n 1. (Cs, Ts, T, m) \\<in> MethodDefs P C M", "by (simp add:LeastMethodDef_def)"], ["proof (state)\nthis:\n  (Cs, Ts, T, m) \\<in> MethodDefs P C M\n\ngoal (1 subgoal):\n 1. is_type P T", "from this"], ["proof (chain)\npicking this:\n  (Cs, Ts, T, m) \\<in> MethodDefs P C M", "obtain Bs fs ms \n    where \"map_of ms M = Some(Ts,T,m)\" \n    and \"class\": \"class P (last Cs) = Some (Bs,fs,ms)\""], ["proof (prove)\nusing this:\n  (Cs, Ts, T, m) \\<in> MethodDefs P C M\n\ngoal (1 subgoal):\n 1. (\\<And>ms Bs fs.\n        \\<lbrakk>map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>;\n         class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:MethodDefs_def)"], ["proof (state)\nthis:\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. is_type P T", "hence \"(M,Ts,T,m) \\<in> set ms\""], ["proof (prove)\nusing this:\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (M, Ts, T, m) \\<in> set ms", "by (simp add:map_of_SomeD)"], ["proof (state)\nthis:\n  (M, Ts, T, m) \\<in> set ms\n\ngoal (1 subgoal):\n 1. is_type P T", "with \"class\" wf"], ["proof (chain)\npicking this:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  wf_prog wf_md P\n  (M, Ts, T, m) \\<in> set ms", "show ?thesis"], ["proof (prove)\nusing this:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  wf_prog wf_md P\n  (M, Ts, T, m) \\<in> set ms\n\ngoal (1 subgoal):\n 1. is_type P T", "by(fastforce dest!: class_wf simp: wf_cdecl_def wf_mdecl_def)"], ["proof (state)\nthis:\n  is_type P T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma least_overrider_is_type:\nassumes \"method\":\"P \\<turnstile> (C,Cs) has overrider M = (Ts,T,m) via Cs'\" \n  and wf:\"wf_prog wf_md P\"\nshows \"is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_type P T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_type P T", "from \"method\""], ["proof (chain)\npicking this:\n  P \\<turnstile> (C, Cs) has overrider M = (Ts, T, m) via Cs'", "have \"(Cs',Ts,T,m) \\<in> MethodDefs P C M\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (C, Cs) has overrider M = (Ts, T, m) via Cs'\n\ngoal (1 subgoal):\n 1. (Cs', Ts, T, m) \\<in> MethodDefs P C M", "by(clarsimp simp:FinalOverriderMethodDef_def OverriderMethodDefs_def \n                     MinimalMethodDefs_def)"], ["proof (state)\nthis:\n  (Cs', Ts, T, m) \\<in> MethodDefs P C M\n\ngoal (1 subgoal):\n 1. is_type P T", "from this"], ["proof (chain)\npicking this:\n  (Cs', Ts, T, m) \\<in> MethodDefs P C M", "obtain Bs fs ms \n    where \"map_of ms M = Some(Ts,T,m)\" \n    and \"class\": \"class P (last Cs') = Some (Bs,fs,ms)\""], ["proof (prove)\nusing this:\n  (Cs', Ts, T, m) \\<in> MethodDefs P C M\n\ngoal (1 subgoal):\n 1. (\\<And>ms Bs fs.\n        \\<lbrakk>map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>;\n         class P (last Cs') = \\<lfloor>(Bs, fs, ms)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:MethodDefs_def)"], ["proof (state)\nthis:\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n  class P (last Cs') = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. is_type P T", "hence \"(M,Ts,T,m) \\<in> set ms\""], ["proof (prove)\nusing this:\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n  class P (last Cs') = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (M, Ts, T, m) \\<in> set ms", "by (simp add:map_of_SomeD)"], ["proof (state)\nthis:\n  (M, Ts, T, m) \\<in> set ms\n\ngoal (1 subgoal):\n 1. is_type P T", "with \"class\" wf"], ["proof (chain)\npicking this:\n  class P (last Cs') = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  wf_prog wf_md P\n  (M, Ts, T, m) \\<in> set ms", "show ?thesis"], ["proof (prove)\nusing this:\n  class P (last Cs') = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  wf_prog wf_md P\n  (M, Ts, T, m) \\<in> set ms\n\ngoal (1 subgoal):\n 1. is_type P T", "by(fastforce dest!: class_wf simp: wf_cdecl_def wf_mdecl_def)"], ["proof (state)\nthis:\n  is_type P T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma select_method_is_type:\n\"\\<lbrakk> P \\<turnstile> (C,Cs) selects M = (Ts,T,m) via Cs'; wf_prog wf_md P\\<rbrakk> \\<Longrightarrow> is_type P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> (C,Cs) selects M = (Ts, T, m) via Cs';\n     wf_prog wf_md P\\<rbrakk>\n    \\<Longrightarrow> is_type P T", "by(auto elim:SelectMethodDef.cases\n             intro:least_method_is_type least_overrider_is_type)"], ["", "lemma base_subtype:\n\"\\<lbrakk>wf_cdecl wf_md P (C,Bs,fs,ms); C' \\<in> baseClasses Bs; \n  P \\<turnstile> C' has M = (Ts',T',m') via Cs@\\<^sub>p[D]; (M,Ts,T,m)\\<in>set ms\\<rbrakk>\n  \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_cdecl wf_md P (C, Bs, fs, ms); C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "apply (simp add:wf_cdecl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>M a aa aaa b Cs.\n                 P \\<turnstile> C has M = (a, aa, aaa,\n     b) via Cs \\<longrightarrow>\n                 (\\<exists>a aa aaa b.\n                     Ex (FinalOverriderMethodDef P (C, Cs) M\n                          (a, aa, aaa, b)))) \\<and>\n             (\\<forall>x\\<in>set fs. wf_fdecl P x) \\<and>\n             distinct_fst fs \\<and>\n             (\\<forall>x\\<in>set ms. wf_mdecl wf_md P C x) \\<and>\n             distinct_fst ms \\<and>\n             (\\<forall>D\\<in>baseClasses Bs.\n                 is_class P D \\<and>\n                 (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n                 (\\<forall>x\\<in>set ms.\n                     case x of\n                     (M, Ts, T, m) \\<Rightarrow>\n                       \\<forall>Ts' T'.\n                          (\\<exists>a b.\n                              Ex (HasMethodDef P D M\n                                   (Ts', T', a, b))) \\<longrightarrow>\n                          Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'));\n     C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa aaa b Cs.\n        P \\<turnstile> C has M = (a, aa, aaa, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa aaa b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, aaa, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     \\<forall>D\\<in>baseClasses Bs.\n        is_class P D \\<and>\n        (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n        (\\<forall>x\\<in>set ms.\n            case x of\n            (M, Ts, T, m) \\<Rightarrow>\n              \\<forall>Ts' T'.\n                 (\\<exists>a b.\n                     Ex (HasMethodDef P D M\n                          (Ts', T', a, b))) \\<longrightarrow>\n                 Ts' = Ts \\<and> P \\<turnstile> T \\<le> T')\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "apply (rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>D\\<in>baseClasses Bs.\n                is_class P D \\<and>\n                (D, C) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n                (\\<forall>x\\<in>set ms.\n                    case x of\n                    (M, Ts, T, m) \\<Rightarrow>\n                      \\<forall>Ts' T'.\n                         (\\<exists>a b.\n                             Ex (HasMethodDef P D M\n                                  (Ts', T', a, b))) \\<longrightarrow>\n                         Ts' = Ts \\<and> P \\<turnstile> T \\<le> T');\n     C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa aaa b Cs.\n        P \\<turnstile> C has M = (a, aa, aaa, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa aaa b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, aaa, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "apply (erule_tac x=\"C'\" in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa aaa b Cs.\n        P \\<turnstile> C has M = (a, aa, aaa, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa aaa b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, aaa, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C' \\<and>\n     (C', C) \\<notin> (subcls1 P)\\<^sup>* \\<and>\n     (\\<forall>x\\<in>set ms.\n         case x of\n         (M, Ts, T, m) \\<Rightarrow>\n           \\<forall>Ts' T'.\n              (\\<exists>a b.\n                  Ex (HasMethodDef P C' M\n                       (Ts', T', a, b))) \\<longrightarrow>\n              Ts' = Ts \\<and> P \\<turnstile> T \\<le> T')\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        P \\<turnstile> C has M = (a, aa, ab, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     C' \\<notin> baseClasses Bs\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa aaa b Cs.\n        P \\<turnstile> C has M = (a, aa, aaa, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa aaa b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, aaa, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     \\<forall>x\\<in>set ms.\n        case x of\n        (M, Ts, T, m) \\<Rightarrow>\n          \\<forall>Ts' T'.\n             (\\<exists>a b.\n                 Ex (HasMethodDef P C' M (Ts', T', a, b))) \\<longrightarrow>\n             Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        P \\<turnstile> C has M = (a, aa, ab, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     C' \\<notin> baseClasses Bs\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "apply (rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set ms.\n                case x of\n                (M, Ts, T, m) \\<Rightarrow>\n                  \\<forall>Ts' T'.\n                     (\\<exists>a b.\n                         Ex (HasMethodDef P C' M\n                              (Ts', T', a, b))) \\<longrightarrow>\n                     Ts' = Ts \\<and> P \\<turnstile> T \\<le> T';\n     C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa aaa b Cs.\n        P \\<turnstile> C has M = (a, aa, aaa, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa aaa b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, aaa, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        P \\<turnstile> C has M = (a, aa, ab, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     C' \\<notin> baseClasses Bs\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "apply (erule_tac x=\"(M, Ts, T, m)\" in ballE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa aaa b Cs.\n        P \\<turnstile> C has M = (a, aa, aaa, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa aaa b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, aaa, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     case (M, Ts, T, m) of\n     (M, Ts, T, m) \\<Rightarrow>\n       \\<forall>Ts' T'.\n          (\\<exists>a b.\n              Ex (HasMethodDef P C' M (Ts', T', a, b))) \\<longrightarrow>\n          Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        P \\<turnstile> C has M = (a, aa, ab, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     (M, Ts, T, m) \\<notin> set ms\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 3. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        P \\<turnstile> C has M = (a, aa, ab, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     C' \\<notin> baseClasses Bs\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        P \\<turnstile> C has M = (a, aa, ab, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     \\<forall>Ts' T'.\n        (\\<exists>a b.\n            Ex (HasMethodDef P C' M (Ts', T', a, b))) \\<longrightarrow>\n        Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        P \\<turnstile> C has M = (a, aa, ab, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     (M, Ts, T, m) \\<notin> set ms\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 3. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        P \\<turnstile> C has M = (a, aa, ab, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     C' \\<notin> baseClasses Bs\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "apply (erule_tac x=\"Ts'\" in allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        P \\<turnstile> C has M = (a, aa, ab, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     \\<forall>T'.\n        (\\<exists>a b.\n            Ex (HasMethodDef P C' M (Ts', T', a, b))) \\<longrightarrow>\n        Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        P \\<turnstile> C has M = (a, aa, ab, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     (M, Ts, T, m) \\<notin> set ms\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 3. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        P \\<turnstile> C has M = (a, aa, ab, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     C' \\<notin> baseClasses Bs\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "apply (erule_tac x=\"T'\" in allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        P \\<turnstile> C has M = (a, aa, ab, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     (\\<exists>a b.\n         Ex (HasMethodDef P C' M (Ts', T', a, b))) \\<longrightarrow>\n     Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        P \\<turnstile> C has M = (a, aa, ab, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     (M, Ts, T, m) \\<notin> set ms\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 3. \\<lbrakk>C' \\<in> baseClasses Bs;\n     P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D];\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        P \\<turnstile> C has M = (a, aa, ab, b) via Cs \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     C' \\<notin> baseClasses Bs\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "apply (auto simp:HasMethodDef_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     (Cs @\\<^sub>p [D], Ts', T', m') \\<in> MethodDefs P C' M;\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        (Cs, a, aa, ab, b) \\<in> MethodDefs P C M \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     \\<forall>a b x. (x, Ts', T', a, b) \\<notin> MethodDefs P C' M\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts\n 2. \\<lbrakk>C' \\<in> baseClasses Bs;\n     (Cs @\\<^sub>p [D], Ts', T', m') \\<in> MethodDefs P C' M;\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        (Cs, a, aa, ab, b) \\<in> MethodDefs P C M \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     \\<forall>a b x. (x, Ts', T', a, b) \\<notin> MethodDefs P C' M\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T \\<le> T'", "apply (erule_tac x=\"fst m'\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     (Cs @\\<^sub>p [D], Ts', T', m') \\<in> MethodDefs P C' M;\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        (Cs, a, aa, ab, b) \\<in> MethodDefs P C M \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     \\<forall>b x.\n        (x, Ts', T', fst m', b) \\<notin> MethodDefs P C' M\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts\n 2. \\<lbrakk>C' \\<in> baseClasses Bs;\n     (Cs @\\<^sub>p [D], Ts', T', m') \\<in> MethodDefs P C' M;\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        (Cs, a, aa, ab, b) \\<in> MethodDefs P C M \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     \\<forall>a b x. (x, Ts', T', a, b) \\<notin> MethodDefs P C' M\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T \\<le> T'", "apply (erule_tac x=\"snd m'\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     (Cs @\\<^sub>p [D], Ts', T', m') \\<in> MethodDefs P C' M;\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        (Cs, a, aa, ab, b) \\<in> MethodDefs P C M \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     \\<forall>x.\n        (x, Ts', T', fst m', snd m') \\<notin> MethodDefs P C' M\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts\n 2. \\<lbrakk>C' \\<in> baseClasses Bs;\n     (Cs @\\<^sub>p [D], Ts', T', m') \\<in> MethodDefs P C' M;\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        (Cs, a, aa, ab, b) \\<in> MethodDefs P C M \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     \\<forall>a b x. (x, Ts', T', a, b) \\<notin> MethodDefs P C' M\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T \\<le> T'", "apply (erule_tac x=\"Cs@\\<^sub>p[D]\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     (Cs @\\<^sub>p [D], Ts', T', m') \\<in> MethodDefs P C' M;\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        (Cs, a, aa, ab, b) \\<in> MethodDefs P C M \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     (Cs @\\<^sub>p [D], Ts', T', fst m', snd m')\n     \\<notin> MethodDefs P C' M\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts\n 2. \\<lbrakk>C' \\<in> baseClasses Bs;\n     (Cs @\\<^sub>p [D], Ts', T', m') \\<in> MethodDefs P C' M;\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        (Cs, a, aa, ab, b) \\<in> MethodDefs P C M \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     \\<forall>a b x. (x, Ts', T', a, b) \\<notin> MethodDefs P C' M\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T \\<le> T'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     (Cs @\\<^sub>p [D], Ts', T', m') \\<in> MethodDefs P C' M;\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        (Cs, a, aa, ab, b) \\<in> MethodDefs P C M \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     \\<forall>a b x. (x, Ts', T', a, b) \\<notin> MethodDefs P C' M\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T \\<le> T'", "apply (erule_tac x=\"fst m'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     (Cs @\\<^sub>p [D], Ts', T', m') \\<in> MethodDefs P C' M;\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        (Cs, a, aa, ab, b) \\<in> MethodDefs P C M \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     \\<forall>b x.\n        (x, Ts', T', fst m', b) \\<notin> MethodDefs P C' M\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T \\<le> T'", "apply (erule_tac x=\"snd m'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     (Cs @\\<^sub>p [D], Ts', T', m') \\<in> MethodDefs P C' M;\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        (Cs, a, aa, ab, b) \\<in> MethodDefs P C M \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     \\<forall>x.\n        (x, Ts', T', fst m', snd m') \\<notin> MethodDefs P C' M\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T \\<le> T'", "apply (erule_tac x=\"Cs@\\<^sub>p[D]\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C' \\<in> baseClasses Bs;\n     (Cs @\\<^sub>p [D], Ts', T', m') \\<in> MethodDefs P C' M;\n     (M, Ts, T, m) \\<in> set ms;\n     \\<forall>M a aa ab b Cs.\n        (Cs, a, aa, ab, b) \\<in> MethodDefs P C M \\<longrightarrow>\n        (\\<exists>a aa ab b.\n            Ex (FinalOverriderMethodDef P (C, Cs) M (a, aa, ab, b)));\n     \\<forall>x\\<in>set fs. wf_fdecl P x; distinct_fst fs;\n     \\<forall>x\\<in>set ms. wf_mdecl wf_md P C x; distinct_fst ms;\n     is_class P C'; (C', C) \\<notin> (subcls1 P)\\<^sup>*;\n     (Cs @\\<^sub>p [D], Ts', T', fst m', snd m')\n     \\<notin> MethodDefs P C' M\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T \\<le> T'", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subclsPlus_subtype:\n  assumes classD:\"class P D = Some(Bs',fs',ms')\" \n  and mapMs':\"map_of ms' M = Some(Ts',T',m')\"\n  and leq:\"(C,D) \\<in> (subcls1 P)\\<^sup>+\" and wf:\"wf_prog wf_md P\"\nshows \"\\<forall>Bs fs ms Ts T m. class P C = Some(Bs,fs,ms) \\<and> map_of ms M = Some(Ts,T,m) \n    \\<longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Bs fs ms Ts T m.\n       class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n       map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n       Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "using leq classD mapMs'"], ["proof (prove)\nusing this:\n  (C, D) \\<in> (subcls1 P)\\<^sup>+\n  class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>Bs fs ms Ts T m.\n       class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n       map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n       Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "proof (erule_tac a=\"C\" and b=\"D\" in converse_trancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "fix C"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "assume CleqD:\"P \\<turnstile> C \\<prec>\\<^sup>1 D\" and classD1:\"class P D = Some(Bs',fs',ms')\""], ["proof (state)\nthis:\n  P \\<turnstile> C \\<prec>\\<^sup>1 D\n  class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "{"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<prec>\\<^sup>1 D\n  class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "fix Bs fs ms Ts T m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "assume classC:\"class P C = Some(Bs,fs,ms)\" and mapMs:\"map_of ms M = Some(Ts,T,m)\""], ["proof (state)\nthis:\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from classD1 mapMs'"], ["proof (chain)\npicking this:\n  class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>", "have hasViaD:\"P \\<turnstile> D has M = (Ts',T',m') via [D]\""], ["proof (prove)\nusing this:\n  class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D has M = (Ts', T', m') via [D]", "by (fastforce intro:Subobjs_Base simp:HasMethodDef_def MethodDefs_def is_class_def)"], ["proof (state)\nthis:\n  P \\<turnstile> D has M = (Ts', T', m') via [D]\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from CleqD classC"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<prec>\\<^sup>1 D\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>", "have base:\"D \\<in> baseClasses Bs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<prec>\\<^sup>1 D\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. D \\<in> baseClasses Bs", "by (fastforce dest:subcls1D)"], ["proof (state)\nthis:\n  D \\<in> baseClasses Bs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from classC wf"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  wf_prog wf_md P", "have cdecl:\"wf_cdecl wf_md P (C,Bs,fs,ms)\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md P (C, Bs, fs, ms)", "by (rule class_wf)"], ["proof (state)\nthis:\n  wf_cdecl wf_md P (C, Bs, fs, ms)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from classC mapMs"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>", "have \"(M,Ts,T,m)\\<in>set ms\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (M, Ts, T, m) \\<in> set ms", "by -(drule map_of_SomeD)"], ["proof (state)\nthis:\n  (M, Ts, T, m) \\<in> set ms\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "with cdecl base hasViaD"], ["proof (chain)\npicking this:\n  wf_cdecl wf_md P (C, Bs, fs, ms)\n  D \\<in> baseClasses Bs\n  P \\<turnstile> D has M = (Ts', T', m') via [D]\n  (M, Ts, T, m) \\<in> set ms", "have \"Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P (C, Bs, fs, ms)\n  D \\<in> baseClasses Bs\n  P \\<turnstile> D has M = (Ts', T', m') via [D]\n  (M, Ts, T, m) \\<in> set ms\n\ngoal (1 subgoal):\n 1. Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "by -(rule_tac Cs=\"[D]\" in base_subtype,auto simp:appendPath_def)"], ["proof (state)\nthis:\n  Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>class P C = \\<lfloor>(?Bs2, ?fs2, ?ms2)\\<rfloor>;\n   map_of ?ms2 M = \\<lfloor>(?Ts2, ?T2, ?m2)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> Ts' = ?Ts2 \\<and> P \\<turnstile> ?T2 \\<le> T'\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 D\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "thus \"\\<forall>Bs fs ms Ts T m. class P C = Some(Bs, fs, ms) \\<and> map_of ms M = Some(Ts,T,m) \n             \\<longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>class P C = \\<lfloor>(?Bs2, ?fs2, ?ms2)\\<rfloor>;\n   map_of ?ms2 M = \\<lfloor>(?Ts2, ?T2, ?m2)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> Ts' = ?Ts2 \\<and> P \\<turnstile> ?T2 \\<le> T'\n\ngoal (1 subgoal):\n 1. \\<forall>Bs fs ms Ts T m.\n       class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n       map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n       Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "by blast"], ["proof (state)\nthis:\n  \\<forall>Bs fs ms Ts T m.\n     class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n     map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n     Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "fix C C'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "assume  classD1:\"class P D = Some(Bs',fs',ms')\" and CleqC':\"P \\<turnstile> C \\<prec>\\<^sup>1 C'\"\n    and subcls:\"(C',D) \\<in> (subcls1 P)\\<^sup>+\"\n    and IH:\"\\<forall>Bs fs ms Ts T m. class P C' = Some(Bs,fs,ms) \\<and> \n                          map_of ms M = Some(Ts,T,m) \\<longrightarrow> \n                  Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\""], ["proof (state)\nthis:\n  class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  P \\<turnstile> C \\<prec>\\<^sup>1 C'\n  (C', D) \\<in> (subcls1 P)\\<^sup>+\n  \\<forall>Bs fs ms Ts T m.\n     class P C' = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n     map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n     Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "{"], ["proof (state)\nthis:\n  class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  P \\<turnstile> C \\<prec>\\<^sup>1 C'\n  (C', D) \\<in> (subcls1 P)\\<^sup>+\n  \\<forall>Bs fs ms Ts T m.\n     class P C' = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n     map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n     Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "fix Bs fs ms Ts T m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "assume classC:\"class P C = Some(Bs,fs,ms)\" and mapMs:\"map_of ms M = Some(Ts,T,m)\""], ["proof (state)\nthis:\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from classD1 mapMs'"], ["proof (chain)\npicking this:\n  class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>", "have hasViaD:\"P \\<turnstile> D has M = (Ts',T',m') via [D]\""], ["proof (prove)\nusing this:\n  class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D has M = (Ts', T', m') via [D]", "by (fastforce intro:Subobjs_Base simp:HasMethodDef_def MethodDefs_def is_class_def)"], ["proof (state)\nthis:\n  P \\<turnstile> D has M = (Ts', T', m') via [D]\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from subcls"], ["proof (chain)\npicking this:\n  (C', D) \\<in> (subcls1 P)\\<^sup>+", "have C'leqD:\"P \\<turnstile> C' \\<preceq>\\<^sup>* D\""], ["proof (prove)\nusing this:\n  (C', D) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C' \\<preceq>\\<^sup>* D", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from classC wf CleqC'"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  wf_prog wf_md P\n  P \\<turnstile> C \\<prec>\\<^sup>1 C'", "have \"is_class P C'\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  wf_prog wf_md P\n  P \\<turnstile> C \\<prec>\\<^sup>1 C'\n\ngoal (1 subgoal):\n 1. is_class P C'", "by (fastforce intro:wf_cdecl_supD class_wf dest:subcls1D)"], ["proof (state)\nthis:\n  is_class P C'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "with C'leqD wf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D\n  wf_prog wf_md P\n  is_class P C'", "obtain Cs where \"P \\<turnstile> Path C' to D via Cs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C' \\<preceq>\\<^sup>* D\n  wf_prog wf_md P\n  is_class P C'\n\ngoal (1 subgoal):\n 1. (\\<And>Cs.\n        P \\<turnstile> Path C' to D via Cs  \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!:leq_implies_path simp:is_class_def)"], ["proof (state)\nthis:\n  P \\<turnstile> Path C' to D via Cs \n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "hence hasVia:\"P \\<turnstile> C' has M = (Ts',T',m') via Cs@\\<^sub>p[D]\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path C' to D via Cs \n\ngoal (1 subgoal):\n 1. P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D]", "using hasViaD wf"], ["proof (prove)\nusing this:\n  P \\<turnstile> Path C' to D via Cs \n  P \\<turnstile> D has M = (Ts', T', m') via [D]\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D]", "by (rule has_path_has)"], ["proof (state)\nthis:\n  P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D]\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from CleqC' classC"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<prec>\\<^sup>1 C'\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>", "have base:\"C' \\<in> baseClasses Bs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<prec>\\<^sup>1 C'\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n\ngoal (1 subgoal):\n 1. C' \\<in> baseClasses Bs", "by (fastforce dest:subcls1D)"], ["proof (state)\nthis:\n  C' \\<in> baseClasses Bs\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from classC wf"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  wf_prog wf_md P", "have cdecl:\"wf_cdecl wf_md P (C,Bs,fs,ms)\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. wf_cdecl wf_md P (C, Bs, fs, ms)", "by (rule class_wf)"], ["proof (state)\nthis:\n  wf_cdecl wf_md P (C, Bs, fs, ms)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from classC mapMs"], ["proof (chain)\npicking this:\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>", "have \"(M,Ts,T,m)\\<in>set ms\""], ["proof (prove)\nusing this:\n  class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n\ngoal (1 subgoal):\n 1. (M, Ts, T, m) \\<in> set ms", "by -(drule map_of_SomeD)"], ["proof (state)\nthis:\n  (M, Ts, T, m) \\<in> set ms\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "with cdecl base hasVia"], ["proof (chain)\npicking this:\n  wf_cdecl wf_md P (C, Bs, fs, ms)\n  C' \\<in> baseClasses Bs\n  P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D]\n  (M, Ts, T, m) \\<in> set ms", "have \"Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\""], ["proof (prove)\nusing this:\n  wf_cdecl wf_md P (C, Bs, fs, ms)\n  C' \\<in> baseClasses Bs\n  P \\<turnstile> C' has M = (Ts', T', m') via Cs @\\<^sub>p [D]\n  (M, Ts, T, m) \\<in> set ms\n\ngoal (1 subgoal):\n 1. Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "by(rule base_subtype)"], ["proof (state)\nthis:\n  Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>class P C = \\<lfloor>(?Bs2, ?fs2, ?ms2)\\<rfloor>;\n   map_of ?ms2 M = \\<lfloor>(?Ts2, ?T2, ?m2)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> Ts' = ?Ts2 \\<and> P \\<turnstile> ?T2 \\<le> T'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>class P D = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n        map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>;\n        P \\<turnstile> y \\<prec>\\<^sup>1 z;\n        (z, D) \\<in> (subcls1 P)\\<^sup>+;\n        \\<forall>Bs fs ms Ts T m.\n           class P z = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n           map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n           Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Bs fs ms Ts T m.\n                            class P y =\n                            \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n                            map_of ms M =\n                            \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n                            Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "thus \"\\<forall>Bs fs ms Ts T m. class P C = Some(Bs, fs, ms) \\<and> map_of ms M = Some(Ts,T,m) \n             \\<longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>class P C = \\<lfloor>(?Bs2, ?fs2, ?ms2)\\<rfloor>;\n   map_of ?ms2 M = \\<lfloor>(?Ts2, ?T2, ?m2)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> Ts' = ?Ts2 \\<and> P \\<turnstile> ?T2 \\<le> T'\n\ngoal (1 subgoal):\n 1. \\<forall>Bs fs ms Ts T m.\n       class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n       map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n       Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "by blast"], ["proof (state)\nthis:\n  \\<forall>Bs fs ms Ts T m.\n     class P C = \\<lfloor>(Bs, fs, ms)\\<rfloor> \\<and>\n     map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor> \\<longrightarrow>\n     Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leq_method_subtypes:\n  assumes leq:\"P \\<turnstile> D \\<preceq>\\<^sup>* C\" and least:\"P \\<turnstile> D has least M = (Ts',T',m') via Ds\"\n  and wf:\"wf_prog wf_md P\"\n  shows \"\\<forall>Ts T m Cs. P \\<turnstile> C has M = (Ts,T,m) via Cs \\<longrightarrow> \n                       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Ts T m Cs.\n       P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n  P \\<turnstile> D has least M = (Ts', T', m') via Ds\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. \\<forall>Ts T m Cs.\n       P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "proof (induct rule:rtrancl.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "fix C"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume Cleast:\"P \\<turnstile> C has least M = (Ts',T',m') via Ds\""], ["proof (state)\nthis:\n  P \\<turnstile> C has least M = (Ts', T', m') via Ds\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "{"], ["proof (state)\nthis:\n  P \\<turnstile> C has least M = (Ts', T', m') via Ds\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "fix Ts T m Cs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume Chas:\"P \\<turnstile> C has M = (Ts,T,m) via Cs\""], ["proof (state)\nthis:\n  P \\<turnstile> C has M = (Ts, T, m) via Cs\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "with Cleast"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least M = (Ts', T', m') via Ds\n  P \\<turnstile> C has M = (Ts, T, m) via Cs", "have path:\"P,C \\<turnstile> Ds \\<sqsubseteq> Cs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least M = (Ts', T', m') via Ds\n  P \\<turnstile> C has M = (Ts, T, m) via Cs\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> Ds \\<sqsubseteq> Cs", "by (fastforce simp:LeastMethodDef_def HasMethodDef_def)"], ["proof (state)\nthis:\n  P,C \\<turnstile> Ds \\<sqsubseteq> Cs\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "{"], ["proof (state)\nthis:\n  P,C \\<turnstile> Ds \\<sqsubseteq> Cs\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume \"Ds = Cs\""], ["proof (state)\nthis:\n  Ds = Cs\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "with Cleast Chas"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least M = (Ts', T', m') via Ds\n  P \\<turnstile> C has M = (Ts, T, m) via Cs\n  Ds = Cs", "have \"Ts = Ts' \\<and> T' = T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least M = (Ts', T', m') via Ds\n  P \\<turnstile> C has M = (Ts, T, m) via Cs\n  Ds = Cs\n\ngoal (1 subgoal):\n 1. Ts = Ts' \\<and> T' = T", "by (auto simp:LeastMethodDef_def HasMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  Ts = Ts' \\<and> T' = T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "hence \"Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  Ts = Ts' \\<and> T' = T\n\ngoal (1 subgoal):\n 1. Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "by auto"], ["proof (state)\nthis:\n  Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "}"], ["proof (state)\nthis:\n  Ds = Cs \\<Longrightarrow> Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "moreover"], ["proof (state)\nthis:\n  Ds = Cs \\<Longrightarrow> Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "{"], ["proof (state)\nthis:\n  Ds = Cs \\<Longrightarrow> Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume \"(Ds,Cs) \\<in> (leq_path1 P C)\\<^sup>+\""], ["proof (state)\nthis:\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "hence subcls:\"(last Ds,last Cs) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (last Ds, last Cs) \\<in> (subcls1 P)\\<^sup>+", "using wf"], ["proof (prove)\nusing this:\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. (last Ds, last Cs) \\<in> (subcls1 P)\\<^sup>+", "by -(rule last_leq_paths)"], ["proof (state)\nthis:\n  (last Ds, last Cs) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "from Chas"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has M = (Ts, T, m) via Cs", "obtain Bs fs ms where \"class P (last Cs) = Some(Bs,fs,ms)\" \n        and \"map_of ms M = Some(Ts,T,m)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has M = (Ts, T, m) via Cs\n\ngoal (1 subgoal):\n 1. (\\<And>Bs fs ms.\n        \\<lbrakk>class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>;\n         map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:HasMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "hence ex:\"\\<forall>Bs' fs' ms' Ts' T' m'. class P (last Ds) = Some(Bs',fs',ms') \\<and> \n        map_of ms' M = Some(Ts',T',m') \\<longrightarrow> Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>Bs' fs' ms' Ts' T' m'.\n       class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n       map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "using subcls wf"], ["proof (prove)\nusing this:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n  (last Ds, last Cs) \\<in> (subcls1 P)\\<^sup>+\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. \\<forall>Bs' fs' ms' Ts' T' m'.\n       class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n       map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "by -(rule subclsPlus_subtype,auto)"], ["proof (state)\nthis:\n  \\<forall>Bs' fs' ms' Ts' T' m'.\n     class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n     map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "from Cleast"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least M = (Ts', T', m') via Ds", "obtain Bs' fs' ms' where \"class P (last Ds) = Some(Bs',fs',ms')\" \n        and \"map_of ms' M = Some(Ts',T',m')\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least M = (Ts', T', m') via Ds\n\ngoal (1 subgoal):\n 1. (\\<And>Bs' fs' ms'.\n        \\<lbrakk>class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n         map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:LeastMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "with ex"], ["proof (chain)\npicking this:\n  \\<forall>Bs' fs' ms' Ts' T' m'.\n     class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n     map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n  class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>", "have \"Ts = Ts'\" and \"P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  \\<forall>Bs' fs' ms' Ts' T' m'.\n     class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n     map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n  class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\n\ngoal (1 subgoal):\n 1. Ts = Ts' &&& P \\<turnstile> T' \\<le> T", "by auto"], ["proof (state)\nthis:\n  Ts = Ts'\n  P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "}"], ["proof (state)\nthis:\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow> Ts = Ts'\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "ultimately"], ["proof (chain)\npicking this:\n  Ds = Cs \\<Longrightarrow> Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow> Ts = Ts'\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T", "have \"Ts = Ts'\" and \"P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  Ds = Cs \\<Longrightarrow> Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow> Ts = Ts'\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. Ts = Ts' &&& P \\<turnstile> T' \\<le> T", "using path"], ["proof (prove)\nusing this:\n  Ds = Cs \\<Longrightarrow> Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow> Ts = Ts'\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T\n  P,C \\<turnstile> Ds \\<sqsubseteq> Cs\n\ngoal (1 subgoal):\n 1. Ts = Ts' &&& P \\<turnstile> T' \\<le> T", "by (auto dest!:rtranclD)"], ["proof (state)\nthis:\n  Ts = Ts'\n  P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "}"], ["proof (state)\nthis:\n  P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2 \\<Longrightarrow>\n  ?Ts2 = Ts'\n  P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2 \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> ?T2\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "thus \"\\<forall>Ts T m Cs. P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow> \n                      Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2 \\<Longrightarrow>\n  ?Ts2 = Ts'\n  P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2 \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> ?T2\n\ngoal (1 subgoal):\n 1. \\<forall>Ts T m Cs.\n       P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "by (simp add:HasMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  \\<forall>Ts T m Cs.\n     P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "fix D C' C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume DleqC':\"P \\<turnstile> D \\<preceq>\\<^sup>* C'\" and C'leqC:\"P \\<turnstile> C' \\<prec>\\<^sup>1 C\"\n  and Dleast:\"P \\<turnstile> D has least M = (Ts',T',m') via Ds\"\n  and IH:\"\\<lbrakk>P \\<turnstile> D has least M = (Ts',T',m') via Ds; wf_prog wf_md P\\<rbrakk>\n   \\<Longrightarrow> \\<forall>Ts T m Cs. P \\<turnstile> C' has M = (Ts, T, m) via Cs \\<longrightarrow> \n            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (state)\nthis:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C'\n  P \\<turnstile> C' \\<prec>\\<^sup>1 C\n  P \\<turnstile> D has least M = (Ts', T', m') via Ds\n  \\<lbrakk>P \\<turnstile> D has least M = (Ts', T', m') via Ds;\n   wf_prog wf_md P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>Ts T m Cs.\n                       P \\<turnstile> C' has M = (Ts, T,\n            m) via Cs \\<longrightarrow>\n                       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "{"], ["proof (state)\nthis:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C'\n  P \\<turnstile> C' \\<prec>\\<^sup>1 C\n  P \\<turnstile> D has least M = (Ts', T', m') via Ds\n  \\<lbrakk>P \\<turnstile> D has least M = (Ts', T', m') via Ds;\n   wf_prog wf_md P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>Ts T m Cs.\n                       P \\<turnstile> C' has M = (Ts, T,\n            m) via Cs \\<longrightarrow>\n                       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "fix Ts T m Cs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume Chas:\"P \\<turnstile> C has M = (Ts,T,m) via Cs\""], ["proof (state)\nthis:\n  P \\<turnstile> C has M = (Ts, T, m) via Cs\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "from Dleast"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has least M = (Ts', T', m') via Ds", "have classD:\"is_class P D\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D has least M = (Ts', T', m') via Ds\n\ngoal (1 subgoal):\n 1. is_class P D", "by (auto intro:Subobjs_isClass simp:LeastMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  is_class P D\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "from DleqC' C'leqC"], ["proof (chain)\npicking this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C'\n  P \\<turnstile> C' \\<prec>\\<^sup>1 C", "have \"P \\<turnstile> D \\<preceq>\\<^sup>* C\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C'\n  P \\<turnstile> C' \\<prec>\\<^sup>1 C\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D \\<preceq>\\<^sup>* C", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C", "obtain Cs' where \"P \\<turnstile> Path D to C via Cs'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n\ngoal (1 subgoal):\n 1. (\\<And>Cs'.\n        P \\<turnstile> Path D to C via Cs'  \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using classD wf"], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n  is_class P D\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. (\\<And>Cs'.\n        P \\<turnstile> Path D to C via Cs'  \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto dest:leq_implies_path)"], ["proof (state)\nthis:\n  P \\<turnstile> Path D to C via Cs' \n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "hence Dhas:\"P \\<turnstile> D has M = (Ts,T,m) via Cs'@\\<^sub>pCs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path D to C via Cs' \n\ngoal (1 subgoal):\n 1. P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs", "using Chas wf"], ["proof (prove)\nusing this:\n  P \\<turnstile> Path D to C via Cs' \n  P \\<turnstile> C has M = (Ts, T, m) via Cs\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs", "by (fastforce intro:has_path_has)"], ["proof (state)\nthis:\n  P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "with Dleast"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has least M = (Ts', T', m') via Ds\n  P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs", "have path:\"P,D \\<turnstile> Ds \\<sqsubseteq> Cs'@\\<^sub>pCs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D has least M = (Ts', T', m') via Ds\n  P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs", "by (auto simp:LeastMethodDef_def HasMethodDef_def)"], ["proof (state)\nthis:\n  P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "{"], ["proof (state)\nthis:\n  P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume \"Ds = Cs'@\\<^sub>pCs\""], ["proof (state)\nthis:\n  Ds = Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "with Dleast Dhas"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has least M = (Ts', T', m') via Ds\n  P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs\n  Ds = Cs' @\\<^sub>p Cs", "have \"Ts = Ts' \\<and> T' = T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D has least M = (Ts', T', m') via Ds\n  P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs\n  Ds = Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. Ts = Ts' \\<and> T' = T", "by (auto simp:LeastMethodDef_def HasMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  Ts = Ts' \\<and> T' = T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "hence \"Ts = Ts' \\<and> T' = T\""], ["proof (prove)\nusing this:\n  Ts = Ts' \\<and> T' = T\n\ngoal (1 subgoal):\n 1. Ts = Ts' \\<and> T' = T", "by auto"], ["proof (state)\nthis:\n  Ts = Ts' \\<and> T' = T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "}"], ["proof (state)\nthis:\n  Ds = Cs' @\\<^sub>p Cs \\<Longrightarrow> Ts = Ts' \\<and> T' = T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "moreover"], ["proof (state)\nthis:\n  Ds = Cs' @\\<^sub>p Cs \\<Longrightarrow> Ts = Ts' \\<and> T' = T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "{"], ["proof (state)\nthis:\n  Ds = Cs' @\\<^sub>p Cs \\<Longrightarrow> Ts = Ts' \\<and> T' = T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume \"(Ds,Cs'@\\<^sub>pCs) \\<in> (leq_path1 P D)\\<^sup>+\""], ["proof (state)\nthis:\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "hence subcls:\"(last Ds,last (Cs'@\\<^sub>pCs)) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (last Ds, last (Cs' @\\<^sub>p Cs)) \\<in> (subcls1 P)\\<^sup>+", "using wf"], ["proof (prove)\nusing this:\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. (last Ds, last (Cs' @\\<^sub>p Cs)) \\<in> (subcls1 P)\\<^sup>+", "by -(rule last_leq_paths)"], ["proof (state)\nthis:\n  (last Ds, last (Cs' @\\<^sub>p Cs)) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "from Dhas"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs", "obtain Bs fs ms where \"class P (last (Cs'@\\<^sub>pCs)) = Some(Bs,fs,ms)\" \n        and \"map_of ms M = Some(Ts,T,m)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. (\\<And>Bs fs ms.\n        \\<lbrakk>class P (last (Cs' @\\<^sub>p Cs)) =\n                 \\<lfloor>(Bs, fs, ms)\\<rfloor>;\n         map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:HasMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  class P (last (Cs' @\\<^sub>p Cs)) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "hence ex:\"\\<forall>Bs' fs' ms' Ts' T' m'. class P (last Ds) = Some(Bs',fs',ms') \\<and> \n                 map_of ms' M = Some(Ts',T',m') \\<longrightarrow> \n                     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  class P (last (Cs' @\\<^sub>p Cs)) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>Bs' fs' ms' Ts' T' m'.\n       class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n       map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "using subcls wf"], ["proof (prove)\nusing this:\n  class P (last (Cs' @\\<^sub>p Cs)) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n  (last Ds, last (Cs' @\\<^sub>p Cs)) \\<in> (subcls1 P)\\<^sup>+\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. \\<forall>Bs' fs' ms' Ts' T' m'.\n       class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n       map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "by -(rule subclsPlus_subtype,auto)"], ["proof (state)\nthis:\n  \\<forall>Bs' fs' ms' Ts' T' m'.\n     class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n     map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "from Dleast"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has least M = (Ts', T', m') via Ds", "obtain Bs' fs' ms' where \"class P (last Ds) = Some(Bs',fs',ms')\" \n        and \"map_of ms' M = Some(Ts',T',m')\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D has least M = (Ts', T', m') via Ds\n\ngoal (1 subgoal):\n 1. (\\<And>Bs' fs' ms'.\n        \\<lbrakk>class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n         map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:LeastMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "with ex"], ["proof (chain)\npicking this:\n  \\<forall>Bs' fs' ms' Ts' T' m'.\n     class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n     map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n  class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>", "have \"Ts = Ts'\" and \"P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  \\<forall>Bs' fs' ms' Ts' T' m'.\n     class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n     map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n  class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\n\ngoal (1 subgoal):\n 1. Ts = Ts' &&& P \\<turnstile> T' \\<le> T", "by auto"], ["proof (state)\nthis:\n  Ts = Ts'\n  P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "}"], ["proof (state)\nthis:\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  Ts = Ts'\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "ultimately"], ["proof (chain)\npicking this:\n  Ds = Cs' @\\<^sub>p Cs \\<Longrightarrow> Ts = Ts' \\<and> T' = T\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  Ts = Ts'\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T", "have \"Ts = Ts'\" and \"P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  Ds = Cs' @\\<^sub>p Cs \\<Longrightarrow> Ts = Ts' \\<and> T' = T\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  Ts = Ts'\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. Ts = Ts' &&& P \\<turnstile> T' \\<le> T", "using path"], ["proof (prove)\nusing this:\n  Ds = Cs' @\\<^sub>p Cs \\<Longrightarrow> Ts = Ts' \\<and> T' = T\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  Ts = Ts'\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T\n  P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. Ts = Ts' &&& P \\<turnstile> T' \\<le> T", "by (auto dest!:rtranclD)"], ["proof (state)\nthis:\n  Ts = Ts'\n  P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "}"], ["proof (state)\nthis:\n  P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2 \\<Longrightarrow>\n  ?Ts2 = Ts'\n  P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2 \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> ?T2\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs.\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        P \\<turnstile> a has least M = (Ts', T', m') via Ds;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs.\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "thus \"\\<forall>Ts T m Cs. P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow> \n            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2 \\<Longrightarrow>\n  ?Ts2 = Ts'\n  P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2 \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> ?T2\n\ngoal (1 subgoal):\n 1. \\<forall>Ts T m Cs.\n       P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "by simp"], ["proof (state)\nthis:\n  \\<forall>Ts T m Cs.\n     P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leq_methods_subtypes:\n  assumes leq:\"P \\<turnstile> D \\<preceq>\\<^sup>* C\" and least:\"(Ds,(Ts',T',m')) \\<in> MinimalMethodDefs P D M\"\n  and wf:\"wf_prog wf_md P\"\n  shows \"\\<forall>Ts T m Cs Cs'. P \\<turnstile> Path D to C via Cs' \\<and> P,D \\<turnstile> Ds \\<sqsubseteq> Cs'@\\<^sub>pCs \\<and> Cs \\<noteq> [] \\<and> \n                         P \\<turnstile> C has M = (Ts,T,m) via Cs \n                                \\<longrightarrow>  Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Ts T m Cs Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<and>\n       P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs \\<and>\n       Cs \\<noteq> [] \\<and>\n       P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "using assms"], ["proof (prove)\nusing this:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P D M\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. \\<forall>Ts T m Cs Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<and>\n       P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs \\<and>\n       Cs \\<noteq> [] \\<and>\n       P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "proof (induct rule:rtrancl.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "fix C"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume Cleast:\"(Ds,(Ts',T',m')) \\<in> MinimalMethodDefs P C M\""], ["proof (state)\nthis:\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P C M\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "{"], ["proof (state)\nthis:\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P C M\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "fix Ts T m Cs Cs'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume path':\"P \\<turnstile> Path C to C via Cs'\"\n      and leq_path:\"P,C \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs\" and notempty:\"Cs \\<noteq> []\"\n      and Chas:\"P \\<turnstile> C has M = (Ts,T,m) via Cs\""], ["proof (state)\nthis:\n  P \\<turnstile> Path C to C via Cs' \n  P,C \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs\n  Cs \\<noteq> []\n  P \\<turnstile> C has M = (Ts, T, m) via Cs\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "from path' wf"], ["proof (chain)\npicking this:\n  P \\<turnstile> Path C to C via Cs' \n  wf_prog wf_md P", "have Cs':\"Cs' = [C]\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path C to C via Cs' \n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. Cs' = [C]", "by(rule path_via_C)"], ["proof (state)\nthis:\n  Cs' = [C]\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "from leq_path Cs' notempty"], ["proof (chain)\npicking this:\n  P,C \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs\n  Cs' = [C]\n  Cs \\<noteq> []", "have leq':\"P,C \\<turnstile> Ds \\<sqsubseteq> Cs\""], ["proof (prove)\nusing this:\n  P,C \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs\n  Cs' = [C]\n  Cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. P,C \\<turnstile> Ds \\<sqsubseteq> Cs", "by(auto simp:appendPath_def split:if_split_asm)"], ["proof (state)\nthis:\n  P,C \\<turnstile> Ds \\<sqsubseteq> Cs\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "{"], ["proof (state)\nthis:\n  P,C \\<turnstile> Ds \\<sqsubseteq> Cs\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume \"Ds = Cs\""], ["proof (state)\nthis:\n  Ds = Cs\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "with Cleast Chas"], ["proof (chain)\npicking this:\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P C M\n  P \\<turnstile> C has M = (Ts, T, m) via Cs\n  Ds = Cs", "have \"Ts = Ts' \\<and> T' = T\""], ["proof (prove)\nusing this:\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P C M\n  P \\<turnstile> C has M = (Ts, T, m) via Cs\n  Ds = Cs\n\ngoal (1 subgoal):\n 1. Ts = Ts' \\<and> T' = T", "by (auto simp:MinimalMethodDefs_def HasMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  Ts = Ts' \\<and> T' = T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "hence \"Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  Ts = Ts' \\<and> T' = T\n\ngoal (1 subgoal):\n 1. Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "by auto"], ["proof (state)\nthis:\n  Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "}"], ["proof (state)\nthis:\n  Ds = Cs \\<Longrightarrow> Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "moreover"], ["proof (state)\nthis:\n  Ds = Cs \\<Longrightarrow> Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "{"], ["proof (state)\nthis:\n  Ds = Cs \\<Longrightarrow> Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume \"(Ds,Cs) \\<in> (leq_path1 P C)\\<^sup>+\""], ["proof (state)\nthis:\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "hence subcls:\"(last Ds,last Cs) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (last Ds, last Cs) \\<in> (subcls1 P)\\<^sup>+", "using wf"], ["proof (prove)\nusing this:\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. (last Ds, last Cs) \\<in> (subcls1 P)\\<^sup>+", "by -(rule last_leq_paths)"], ["proof (state)\nthis:\n  (last Ds, last Cs) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "from Chas"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has M = (Ts, T, m) via Cs", "obtain Bs fs ms where \"class P (last Cs) = Some(Bs,fs,ms)\" \n        and \"map_of ms M = Some(Ts,T,m)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has M = (Ts, T, m) via Cs\n\ngoal (1 subgoal):\n 1. (\\<And>Bs fs ms.\n        \\<lbrakk>class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>;\n         map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:HasMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "hence ex:\"\\<forall>Bs' fs' ms' Ts' T' m'. class P (last Ds) = Some(Bs',fs',ms') \\<and> \n        map_of ms' M = Some(Ts',T',m') \\<longrightarrow> Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>Bs' fs' ms' Ts' T' m'.\n       class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n       map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "using subcls wf"], ["proof (prove)\nusing this:\n  class P (last Cs) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n  (last Ds, last Cs) \\<in> (subcls1 P)\\<^sup>+\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. \\<forall>Bs' fs' ms' Ts' T' m'.\n       class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n       map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "by -(rule subclsPlus_subtype,auto)"], ["proof (state)\nthis:\n  \\<forall>Bs' fs' ms' Ts' T' m'.\n     class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n     map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "from Cleast"], ["proof (chain)\npicking this:\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P C M", "obtain Bs' fs' ms' where \"class P (last Ds) = Some(Bs',fs',ms')\" \n        and \"map_of ms' M = Some(Ts',T',m')\""], ["proof (prove)\nusing this:\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P C M\n\ngoal (1 subgoal):\n 1. (\\<And>Bs' fs' ms'.\n        \\<lbrakk>class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n         map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:MinimalMethodDefs_def MethodDefs_def)"], ["proof (state)\nthis:\n  class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "with ex"], ["proof (chain)\npicking this:\n  \\<forall>Bs' fs' ms' Ts' T' m'.\n     class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n     map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n  class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>", "have \"Ts = Ts'\" and \"P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  \\<forall>Bs' fs' ms' Ts' T' m'.\n     class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n     map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n  class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\n\ngoal (1 subgoal):\n 1. Ts = Ts' &&& P \\<turnstile> T' \\<le> T", "by auto"], ["proof (state)\nthis:\n  Ts = Ts'\n  P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "}"], ["proof (state)\nthis:\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow> Ts = Ts'\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "ultimately"], ["proof (chain)\npicking this:\n  Ds = Cs \\<Longrightarrow> Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow> Ts = Ts'\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T", "have \"Ts = Ts'\" and \"P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  Ds = Cs \\<Longrightarrow> Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow> Ts = Ts'\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. Ts = Ts' &&& P \\<turnstile> T' \\<le> T", "using leq'"], ["proof (prove)\nusing this:\n  Ds = Cs \\<Longrightarrow> Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow> Ts = Ts'\n  (Ds, Cs) \\<in> (leq_path1 P C)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T\n  P,C \\<turnstile> Ds \\<sqsubseteq> Cs\n\ngoal (1 subgoal):\n 1. Ts = Ts' &&& P \\<turnstile> T' \\<le> T", "by (auto dest!:rtranclD)"], ["proof (state)\nthis:\n  Ts = Ts'\n  P \\<turnstile> T' \\<le> T\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P \\<turnstile> Path C to C via ?Cs'2 ;\n   P,C \\<turnstile> Ds \\<sqsubseteq> ?Cs'2 @\\<^sub>p ?Cs2; ?Cs2 \\<noteq> [];\n   P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2\\<rbrakk>\n  \\<Longrightarrow> ?Ts2 = Ts'\n  \\<lbrakk>P \\<turnstile> Path C to C via ?Cs'2 ;\n   P,C \\<turnstile> Ds \\<sqsubseteq> ?Cs'2 @\\<^sub>p ?Cs2; ?Cs2 \\<noteq> [];\n   P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> T' \\<le> ?T2\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to a via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> a has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n 2. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "thus \"\\<forall>Ts T m Cs Cs'. P \\<turnstile> Path C to C via Cs' \\<and> P,C \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs \\<and> Cs \\<noteq> [] \\<and> \n                        P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow> \n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  \\<lbrakk>P \\<turnstile> Path C to C via ?Cs'2 ;\n   P,C \\<turnstile> Ds \\<sqsubseteq> ?Cs'2 @\\<^sub>p ?Cs2; ?Cs2 \\<noteq> [];\n   P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2\\<rbrakk>\n  \\<Longrightarrow> ?Ts2 = Ts'\n  \\<lbrakk>P \\<turnstile> Path C to C via ?Cs'2 ;\n   P,C \\<turnstile> Ds \\<sqsubseteq> ?Cs'2 @\\<^sub>p ?Cs2; ?Cs2 \\<noteq> [];\n   P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> T' \\<le> ?T2\n\ngoal (1 subgoal):\n 1. \\<forall>Ts T m Cs Cs'.\n       P \\<turnstile> Path C to C via Cs'  \\<and>\n       P,C \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs \\<and>\n       Cs \\<noteq> [] \\<and>\n       P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "by blast"], ["proof (state)\nthis:\n  \\<forall>Ts T m Cs Cs'.\n     P \\<turnstile> Path C to C via Cs'  \\<and>\n     P,C \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs \\<and>\n     Cs \\<noteq> [] \\<and>\n     P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "fix D C' C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume DleqC':\"P \\<turnstile> D \\<preceq>\\<^sup>* C'\" and C'leqC:\"P \\<turnstile> C' \\<prec>\\<^sup>1 C\"\n    and Dleast:\"(Ds, Ts', T', m') \\<in> MinimalMethodDefs P D M\"\n    and IH:\"\\<lbrakk>(Ds,Ts',T',m') \\<in> MinimalMethodDefs P D M; wf_prog wf_md P\\<rbrakk>\n   \\<Longrightarrow> \\<forall>Ts T m Cs Cs'. P \\<turnstile> Path D to C' via Cs' \\<and>\n              P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs \\<and> Cs \\<noteq> [] \\<and> P \\<turnstile> C' has M = (Ts, T, m) via Cs \\<longrightarrow> \n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (state)\nthis:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C'\n  P \\<turnstile> C' \\<prec>\\<^sup>1 C\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P D M\n  \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P D M;\n   wf_prog wf_md P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                       P \\<turnstile> Path D to C' via Cs'  \\<and>\n                       P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                   Cs \\<and>\n                       Cs \\<noteq> [] \\<and>\n                       P \\<turnstile> C' has M = (Ts, T,\n            m) via Cs \\<longrightarrow>\n                       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "{"], ["proof (state)\nthis:\n  P \\<turnstile> D \\<preceq>\\<^sup>* C'\n  P \\<turnstile> C' \\<prec>\\<^sup>1 C\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P D M\n  \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P D M;\n   wf_prog wf_md P\\<rbrakk>\n  \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                       P \\<turnstile> Path D to C' via Cs'  \\<and>\n                       P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                   Cs \\<and>\n                       Cs \\<noteq> [] \\<and>\n                       P \\<turnstile> C' has M = (Ts, T,\n            m) via Cs \\<longrightarrow>\n                       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "fix Ts T m Cs Cs'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume path:\"P \\<turnstile> Path D to C via Cs'\"\n      and leq_path:\"P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs\"\n      and notempty:\"Cs \\<noteq> []\"\n      and Chas:\"P \\<turnstile> C has M = (Ts,T,m) via Cs\""], ["proof (state)\nthis:\n  P \\<turnstile> Path D to C via Cs' \n  P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs\n  Cs \\<noteq> []\n  P \\<turnstile> C has M = (Ts, T, m) via Cs\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "from Dleast"], ["proof (chain)\npicking this:\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P D M", "have classD:\"is_class P D\""], ["proof (prove)\nusing this:\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P D M\n\ngoal (1 subgoal):\n 1. is_class P D", "by (auto intro:Subobjs_isClass simp:MinimalMethodDefs_def MethodDefs_def)"], ["proof (state)\nthis:\n  is_class P D\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "from path"], ["proof (chain)\npicking this:\n  P \\<turnstile> Path D to C via Cs'", "have Dhas:\"P \\<turnstile> D has M = (Ts,T,m) via Cs'@\\<^sub>pCs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path D to C via Cs' \n\ngoal (1 subgoal):\n 1. P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs", "using Chas wf"], ["proof (prove)\nusing this:\n  P \\<turnstile> Path D to C via Cs' \n  P \\<turnstile> C has M = (Ts, T, m) via Cs\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs", "by (fastforce intro:has_path_has)"], ["proof (state)\nthis:\n  P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "{"], ["proof (state)\nthis:\n  P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume \"Ds = Cs'@\\<^sub>pCs\""], ["proof (state)\nthis:\n  Ds = Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "with Dleast Dhas"], ["proof (chain)\npicking this:\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P D M\n  P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs\n  Ds = Cs' @\\<^sub>p Cs", "have \"Ts = Ts' \\<and> T' = T\""], ["proof (prove)\nusing this:\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P D M\n  P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs\n  Ds = Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. Ts = Ts' \\<and> T' = T", "by (auto simp:MinimalMethodDefs_def HasMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  Ts = Ts' \\<and> T' = T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "hence \"Ts = Ts' \\<and> T' = T\""], ["proof (prove)\nusing this:\n  Ts = Ts' \\<and> T' = T\n\ngoal (1 subgoal):\n 1. Ts = Ts' \\<and> T' = T", "by auto"], ["proof (state)\nthis:\n  Ts = Ts' \\<and> T' = T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "}"], ["proof (state)\nthis:\n  Ds = Cs' @\\<^sub>p Cs \\<Longrightarrow> Ts = Ts' \\<and> T' = T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "moreover"], ["proof (state)\nthis:\n  Ds = Cs' @\\<^sub>p Cs \\<Longrightarrow> Ts = Ts' \\<and> T' = T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "{"], ["proof (state)\nthis:\n  Ds = Cs' @\\<^sub>p Cs \\<Longrightarrow> Ts = Ts' \\<and> T' = T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "assume \"(Ds,Cs'@\\<^sub>pCs) \\<in> (leq_path1 P D)\\<^sup>+\""], ["proof (state)\nthis:\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "hence subcls:\"(last Ds,last (Cs'@\\<^sub>pCs)) \\<in> (subcls1 P)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (last Ds, last (Cs' @\\<^sub>p Cs)) \\<in> (subcls1 P)\\<^sup>+", "using wf"], ["proof (prove)\nusing this:\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. (last Ds, last (Cs' @\\<^sub>p Cs)) \\<in> (subcls1 P)\\<^sup>+", "by -(rule last_leq_paths)"], ["proof (state)\nthis:\n  (last Ds, last (Cs' @\\<^sub>p Cs)) \\<in> (subcls1 P)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "from Dhas"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs", "obtain Bs fs ms where \"class P (last (Cs'@\\<^sub>pCs)) = Some(Bs,fs,ms)\" \n        and \"map_of ms M = Some(Ts,T,m)\""], ["proof (prove)\nusing this:\n  P \\<turnstile> D has M = (Ts, T, m) via Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. (\\<And>Bs fs ms.\n        \\<lbrakk>class P (last (Cs' @\\<^sub>p Cs)) =\n                 \\<lfloor>(Bs, fs, ms)\\<rfloor>;\n         map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:HasMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  class P (last (Cs' @\\<^sub>p Cs)) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "hence ex:\"\\<forall>Bs' fs' ms' Ts' T' m'. class P (last Ds) = Some(Bs',fs',ms') \\<and> \n                 map_of ms' M = Some(Ts',T',m') \\<longrightarrow> \n                     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  class P (last (Cs' @\\<^sub>p Cs)) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>Bs' fs' ms' Ts' T' m'.\n       class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n       map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "using subcls wf"], ["proof (prove)\nusing this:\n  class P (last (Cs' @\\<^sub>p Cs)) = \\<lfloor>(Bs, fs, ms)\\<rfloor>\n  map_of ms M = \\<lfloor>(Ts, T, m)\\<rfloor>\n  (last Ds, last (Cs' @\\<^sub>p Cs)) \\<in> (subcls1 P)\\<^sup>+\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. \\<forall>Bs' fs' ms' Ts' T' m'.\n       class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n       map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "by -(rule subclsPlus_subtype,auto)"], ["proof (state)\nthis:\n  \\<forall>Bs' fs' ms' Ts' T' m'.\n     class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n     map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "from Dleast"], ["proof (chain)\npicking this:\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P D M", "obtain Bs' fs' ms' where \"class P (last Ds) = Some(Bs',fs',ms')\" \n        and \"map_of ms' M = Some(Ts',T',m')\""], ["proof (prove)\nusing this:\n  (Ds, Ts', T', m') \\<in> MinimalMethodDefs P D M\n\ngoal (1 subgoal):\n 1. (\\<And>Bs' fs' ms'.\n        \\<lbrakk>class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>;\n         map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:MinimalMethodDefs_def MethodDefs_def)"], ["proof (state)\nthis:\n  class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "with ex"], ["proof (chain)\npicking this:\n  \\<forall>Bs' fs' ms' Ts' T' m'.\n     class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n     map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n  class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>", "have \"Ts = Ts'\" and \"P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  \\<forall>Bs' fs' ms' Ts' T' m'.\n     class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor> \\<and>\n     map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor> \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n  class P (last Ds) = \\<lfloor>(Bs', fs', ms')\\<rfloor>\n  map_of ms' M = \\<lfloor>(Ts', T', m')\\<rfloor>\n\ngoal (1 subgoal):\n 1. Ts = Ts' &&& P \\<turnstile> T' \\<le> T", "by auto"], ["proof (state)\nthis:\n  Ts = Ts'\n  P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "}"], ["proof (state)\nthis:\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  Ts = Ts'\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "ultimately"], ["proof (chain)\npicking this:\n  Ds = Cs' @\\<^sub>p Cs \\<Longrightarrow> Ts = Ts' \\<and> T' = T\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  Ts = Ts'\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T", "have \"Ts = Ts'\" and \"P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  Ds = Cs' @\\<^sub>p Cs \\<Longrightarrow> Ts = Ts' \\<and> T' = T\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  Ts = Ts'\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. Ts = Ts' &&& P \\<turnstile> T' \\<le> T", "using leq_path"], ["proof (prove)\nusing this:\n  Ds = Cs' @\\<^sub>p Cs \\<Longrightarrow> Ts = Ts' \\<and> T' = T\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  Ts = Ts'\n  (Ds, Cs' @\\<^sub>p Cs) \\<in> (leq_path1 P D)\\<^sup>+ \\<Longrightarrow>\n  P \\<turnstile> T' \\<le> T\n  P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs\n\ngoal (1 subgoal):\n 1. Ts = Ts' &&& P \\<turnstile> T' \\<le> T", "by (auto dest!:rtranclD)"], ["proof (state)\nthis:\n  Ts = Ts'\n  P \\<turnstile> T' \\<le> T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P \\<turnstile> Path D to C via ?Cs'2 ;\n   P,D \\<turnstile> Ds \\<sqsubseteq> ?Cs'2 @\\<^sub>p ?Cs2; ?Cs2 \\<noteq> [];\n   P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2\\<rbrakk>\n  \\<Longrightarrow> ?Ts2 = Ts'\n  \\<lbrakk>P \\<turnstile> Path D to C via ?Cs'2 ;\n   P,D \\<turnstile> Ds \\<sqsubseteq> ?Cs'2 @\\<^sub>p ?Cs2; ?Cs2 \\<noteq> [];\n   P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> T' \\<le> ?T2\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>P \\<turnstile> a \\<preceq>\\<^sup>* b;\n        \\<lbrakk>(Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n         wf_prog wf_md P\\<rbrakk>\n        \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                             P \\<turnstile> Path a to b via Cs'  \\<and>\n                             P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                         Cs \\<and>\n                             Cs \\<noteq> [] \\<and>\n                             P \\<turnstile> b has M = (Ts, T,\n                 m) via Cs \\<longrightarrow>\n                             Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T;\n        P \\<turnstile> b \\<prec>\\<^sup>1 c;\n        (Ds, Ts', T', m') \\<in> MinimalMethodDefs P a M;\n        wf_prog wf_md P\\<rbrakk>\n       \\<Longrightarrow> \\<forall>Ts T m Cs Cs'.\n                            P \\<turnstile> Path a to c via Cs'  \\<and>\n                            P,a \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p\n                        Cs \\<and>\n                            Cs \\<noteq> [] \\<and>\n                            P \\<turnstile> c has M = (Ts, T,\n                m) via Cs \\<longrightarrow>\n                            Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "thus \"\\<forall>Ts T m Cs Cs'. P \\<turnstile> Path D to C via Cs' \\<and> P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs \\<and> Cs \\<noteq> [] \\<and> \n                    P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow> \n                           Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\""], ["proof (prove)\nusing this:\n  \\<lbrakk>P \\<turnstile> Path D to C via ?Cs'2 ;\n   P,D \\<turnstile> Ds \\<sqsubseteq> ?Cs'2 @\\<^sub>p ?Cs2; ?Cs2 \\<noteq> [];\n   P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2\\<rbrakk>\n  \\<Longrightarrow> ?Ts2 = Ts'\n  \\<lbrakk>P \\<turnstile> Path D to C via ?Cs'2 ;\n   P,D \\<turnstile> Ds \\<sqsubseteq> ?Cs'2 @\\<^sub>p ?Cs2; ?Cs2 \\<noteq> [];\n   P \\<turnstile> C has M = (?Ts2, ?T2, ?m2) via ?Cs2\\<rbrakk>\n  \\<Longrightarrow> P \\<turnstile> T' \\<le> ?T2\n\ngoal (1 subgoal):\n 1. \\<forall>Ts T m Cs Cs'.\n       P \\<turnstile> Path D to C via Cs'  \\<and>\n       P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs \\<and>\n       Cs \\<noteq> [] \\<and>\n       P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow>\n       Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T", "by blast"], ["proof (state)\nthis:\n  \\<forall>Ts T m Cs Cs'.\n     P \\<turnstile> Path D to C via Cs'  \\<and>\n     P,D \\<turnstile> Ds \\<sqsubseteq> Cs' @\\<^sub>p Cs \\<and>\n     Cs \\<noteq> [] \\<and>\n     P \\<turnstile> C has M = (Ts, T, m) via Cs \\<longrightarrow>\n     Ts = Ts' \\<and> P \\<turnstile> T' \\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma select_least_methods_subtypes: \n  assumes select_method:\"P \\<turnstile> (C,Cs@\\<^sub>pDs) selects M = (Ts,T,pns,body) via Cs'\"\n  and least_method:\"P \\<turnstile> last Cs has least M = (Ts',T',pns',body') via Ds\"\n  and path:\"P \\<turnstile> Path C to (last Cs) via Cs\"\n  and wf:\"wf_prog wf_md P\"\n  shows \"Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "using select_method"], ["proof (prove)\nusing this:\n  P \\<turnstile> (C,Cs @\\<^sub>p Ds) selects M = (Ts, T, pns, body) via Cs'\n\ngoal (1 subgoal):\n 1. Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<turnstile> (C,Cs @\\<^sub>p\n                      Ds) selects M = (Ts, T, pns,\n body) via Cs' \\<Longrightarrow>\n    Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from path"], ["proof (chain)\npicking this:\n  P \\<turnstile> Path C to last Cs via Cs", "have sub:\"P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\""], ["proof (prove)\nusing this:\n  P \\<turnstile> Path C to last Cs via Cs \n\ngoal (1 subgoal):\n 1. P \\<turnstile> C \\<preceq>\\<^sup>* last Cs", "by(fastforce intro:Subobjs_subclass simp:path_via_def)"], ["proof (state)\nthis:\n  P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\n\ngoal (1 subgoal):\n 1. P \\<turnstile> (C,Cs @\\<^sub>p\n                      Ds) selects M = (Ts, T, pns,\n body) via Cs' \\<Longrightarrow>\n    Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from least_method"], ["proof (chain)\npicking this:\n  P \\<turnstile> last Cs has least M = (Ts', T', pns', body') via Ds", "have has:\"P \\<turnstile> last Cs has M = (Ts',T',pns',body') via Ds\""], ["proof (prove)\nusing this:\n  P \\<turnstile> last Cs has least M = (Ts', T', pns', body') via Ds\n\ngoal (1 subgoal):\n 1. P \\<turnstile> last Cs has M = (Ts', T', pns', body') via Ds", "by(rule has_least_method_has_method)"], ["proof (state)\nthis:\n  P \\<turnstile> last Cs has M = (Ts', T', pns', body') via Ds\n\ngoal (1 subgoal):\n 1. P \\<turnstile> (C,Cs @\\<^sub>p\n                      Ds) selects M = (Ts, T, pns,\n body) via Cs' \\<Longrightarrow>\n    Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from select_method"], ["proof (chain)\npicking this:\n  P \\<turnstile> (C,Cs @\\<^sub>p Ds) selects M = (Ts, T, pns, body) via Cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> (C,Cs @\\<^sub>p Ds) selects M = (Ts, T, pns, body) via Cs'\n\ngoal (1 subgoal):\n 1. Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<turnstile> C has least M = (Ts, T, pns,\n                                    body) via Cs' \\<Longrightarrow>\n    Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<lbrakk>\\<forall>mthd Cs'.\n                \\<not> P \\<turnstile> C has least M = mthd via Cs';\n     P \\<turnstile> (C, Cs @\\<^sub>p\n                        Ds) has overrider M = (Ts, T, pns,\n         body) via Cs'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "case dyn_unique"], ["proof (state)\nthis:\n  P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> C has least M = (Ts, T, pns,\n                                    body) via Cs' \\<Longrightarrow>\n    Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<lbrakk>\\<forall>mthd Cs'.\n                \\<not> P \\<turnstile> C has least M = mthd via Cs';\n     P \\<turnstile> (C, Cs @\\<^sub>p\n                        Ds) has overrider M = (Ts, T, pns,\n         body) via Cs'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "hence dyn:\"P \\<turnstile> C has least M = (Ts,T,pns,body) via Cs'\""], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs'", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs'\n\ngoal (2 subgoals):\n 1. P \\<turnstile> C has least M = (Ts, T, pns,\n                                    body) via Cs' \\<Longrightarrow>\n    Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n 2. \\<lbrakk>\\<forall>mthd Cs'.\n                \\<not> P \\<turnstile> C has least M = mthd via Cs';\n     P \\<turnstile> (C, Cs @\\<^sub>p\n                        Ds) has overrider M = (Ts, T, pns,\n         body) via Cs'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "with sub has wf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\n  P \\<turnstile> last Cs has M = (Ts', T', pns', body') via Ds\n  wf_prog wf_md P\n  P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs'", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\n  P \\<turnstile> last Cs has M = (Ts', T', pns', body') via Ds\n  wf_prog wf_md P\n  P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs'\n\ngoal (1 subgoal):\n 1. Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "by -(drule leq_method_subtypes,assumption,simp,blast)+"], ["proof (state)\nthis:\n  Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>mthd Cs'.\n                \\<not> P \\<turnstile> C has least M = mthd via Cs';\n     P \\<turnstile> (C, Cs @\\<^sub>p\n                        Ds) has overrider M = (Ts, T, pns,\n         body) via Cs'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>mthd Cs'.\n                \\<not> P \\<turnstile> C has least M = mthd via Cs';\n     P \\<turnstile> (C, Cs @\\<^sub>p\n                        Ds) has overrider M = (Ts, T, pns,\n         body) via Cs'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "case dyn_ambiguous"], ["proof (state)\nthis:\n  \\<forall>mthd Cs'. \\<not> P \\<turnstile> C has least M = mthd via Cs'\n  P \\<turnstile> (C, Cs @\\<^sub>p\n                     Ds) has overrider M = (Ts, T, pns, body) via Cs'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>mthd Cs'.\n                \\<not> P \\<turnstile> C has least M = mthd via Cs';\n     P \\<turnstile> (C, Cs @\\<^sub>p\n                        Ds) has overrider M = (Ts, T, pns,\n         body) via Cs'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "hence overrider:\"P \\<turnstile> (C,Cs@\\<^sub>pDs) has overrider M = (Ts,T,pns,body) via Cs'\""], ["proof (prove)\nusing this:\n  \\<forall>mthd Cs'. \\<not> P \\<turnstile> C has least M = mthd via Cs'\n  P \\<turnstile> (C, Cs @\\<^sub>p\n                     Ds) has overrider M = (Ts, T, pns, body) via Cs'\n\ngoal (1 subgoal):\n 1. P \\<turnstile> (C, Cs @\\<^sub>p\n                       Ds) has overrider M = (Ts, T, pns, body) via Cs'", "by simp"], ["proof (state)\nthis:\n  P \\<turnstile> (C, Cs @\\<^sub>p\n                     Ds) has overrider M = (Ts, T, pns, body) via Cs'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>mthd Cs'.\n                \\<not> P \\<turnstile> C has least M = mthd via Cs';\n     P \\<turnstile> (C, Cs @\\<^sub>p\n                        Ds) has overrider M = (Ts, T, pns,\n         body) via Cs'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from least_method"], ["proof (chain)\npicking this:\n  P \\<turnstile> last Cs has least M = (Ts', T', pns', body') via Ds", "have notempty:\"Ds \\<noteq> []\""], ["proof (prove)\nusing this:\n  P \\<turnstile> last Cs has least M = (Ts', T', pns', body') via Ds\n\ngoal (1 subgoal):\n 1. Ds \\<noteq> []", "by(auto intro!:Subobjs_nonempty simp:LeastMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>mthd Cs'.\n                \\<not> P \\<turnstile> C has least M = mthd via Cs';\n     P \\<turnstile> (C, Cs @\\<^sub>p\n                        Ds) has overrider M = (Ts, T, pns,\n         body) via Cs'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "have \"last Cs = hd Ds \\<Longrightarrow> last (Cs @ tl Ds) = last Ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last Cs = hd Ds \\<Longrightarrow> last (Cs @ tl Ds) = last Ds", "proof(cases \"tl Ds = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>last Cs = hd Ds; tl Ds = []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds\n 2. \\<lbrakk>last Cs = hd Ds; tl Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds", "case True"], ["proof (state)\nthis:\n  tl Ds = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>last Cs = hd Ds; tl Ds = []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds\n 2. \\<lbrakk>last Cs = hd Ds; tl Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds", "assume last:\"last Cs = hd Ds\""], ["proof (state)\nthis:\n  last Cs = hd Ds\n\ngoal (2 subgoals):\n 1. \\<lbrakk>last Cs = hd Ds; tl Ds = []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds\n 2. \\<lbrakk>last Cs = hd Ds; tl Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds", "with True notempty"], ["proof (chain)\npicking this:\n  tl Ds = []\n  Ds \\<noteq> []\n  last Cs = hd Ds", "have \"Ds = [last Cs]\""], ["proof (prove)\nusing this:\n  tl Ds = []\n  Ds \\<noteq> []\n  last Cs = hd Ds\n\ngoal (1 subgoal):\n 1. Ds = [last Cs]", "by (fastforce dest:hd_Cons_tl)"], ["proof (state)\nthis:\n  Ds = [last Cs]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>last Cs = hd Ds; tl Ds = []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds\n 2. \\<lbrakk>last Cs = hd Ds; tl Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds", "hence \"last Ds = last Cs\""], ["proof (prove)\nusing this:\n  Ds = [last Cs]\n\ngoal (1 subgoal):\n 1. last Ds = last Cs", "by simp"], ["proof (state)\nthis:\n  last Ds = last Cs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>last Cs = hd Ds; tl Ds = []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds\n 2. \\<lbrakk>last Cs = hd Ds; tl Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds", "with True"], ["proof (chain)\npicking this:\n  tl Ds = []\n  last Ds = last Cs", "show ?thesis"], ["proof (prove)\nusing this:\n  tl Ds = []\n  last Ds = last Cs\n\ngoal (1 subgoal):\n 1. last (Cs @ tl Ds) = last Ds", "by simp"], ["proof (state)\nthis:\n  last (Cs @ tl Ds) = last Ds\n\ngoal (1 subgoal):\n 1. \\<lbrakk>last Cs = hd Ds; tl Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>last Cs = hd Ds; tl Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds", "case False"], ["proof (state)\nthis:\n  tl Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>last Cs = hd Ds; tl Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds", "assume last:\"last Cs = hd Ds\""], ["proof (state)\nthis:\n  last Cs = hd Ds\n\ngoal (1 subgoal):\n 1. \\<lbrakk>last Cs = hd Ds; tl Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds", "from notempty False"], ["proof (chain)\npicking this:\n  Ds \\<noteq> []\n  tl Ds \\<noteq> []", "have \"last (tl Ds) = last Ds\""], ["proof (prove)\nusing this:\n  Ds \\<noteq> []\n  tl Ds \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (tl Ds) = last Ds", "by -(drule hd_Cons_tl,drule_tac x=\"hd Ds\" in last_ConsR,simp)"], ["proof (state)\nthis:\n  last (tl Ds) = last Ds\n\ngoal (1 subgoal):\n 1. \\<lbrakk>last Cs = hd Ds; tl Ds \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last (Cs @ tl Ds) = last Ds", "with False"], ["proof (chain)\npicking this:\n  tl Ds \\<noteq> []\n  last (tl Ds) = last Ds", "show ?thesis"], ["proof (prove)\nusing this:\n  tl Ds \\<noteq> []\n  last (tl Ds) = last Ds\n\ngoal (1 subgoal):\n 1. last (Cs @ tl Ds) = last Ds", "by simp"], ["proof (state)\nthis:\n  last (Cs @ tl Ds) = last Ds\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last Cs = hd Ds \\<Longrightarrow> last (Cs @ tl Ds) = last Ds\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>mthd Cs'.\n                \\<not> P \\<turnstile> C has least M = mthd via Cs';\n     P \\<turnstile> (C, Cs @\\<^sub>p\n                        Ds) has overrider M = (Ts, T, pns,\n         body) via Cs'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "hence eq:\"(Cs @\\<^sub>p Ds) @\\<^sub>p [last Ds] = (Cs @\\<^sub>p Ds)\""], ["proof (prove)\nusing this:\n  last Cs = hd Ds \\<Longrightarrow> last (Cs @ tl Ds) = last Ds\n\ngoal (1 subgoal):\n 1. (Cs @\\<^sub>p Ds) @\\<^sub>p [last Ds] = Cs @\\<^sub>p Ds", "by(simp add:appendPath_def)"], ["proof (state)\nthis:\n  (Cs @\\<^sub>p Ds) @\\<^sub>p [last Ds] = Cs @\\<^sub>p Ds\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>mthd Cs'.\n                \\<not> P \\<turnstile> C has least M = mthd via Cs';\n     P \\<turnstile> (C, Cs @\\<^sub>p\n                        Ds) has overrider M = (Ts, T, pns,\n         body) via Cs'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "from least_method wf"], ["proof (chain)\npicking this:\n  P \\<turnstile> last Cs has least M = (Ts', T', pns', body') via Ds\n  wf_prog wf_md P", "have \"P \\<turnstile> last Ds has least M = (Ts',T',pns',body') via [last Ds]\""], ["proof (prove)\nusing this:\n  P \\<turnstile> last Cs has least M = (Ts', T', pns', body') via Ds\n  wf_prog wf_md P\n\ngoal (1 subgoal):\n 1. P \\<turnstile> last\n                    Ds has least M = (Ts', T', pns', body') via [last Ds]", "by(auto dest:Subobj_last_isClass intro:Subobjs_Base subobjs_rel\n        simp:LeastMethodDef_def MethodDefs_def)"], ["proof (state)\nthis:\n  P \\<turnstile> last Ds has least M = (Ts', T', pns', body') via [last Ds]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>mthd Cs'.\n                \\<not> P \\<turnstile> C has least M = mthd via Cs';\n     P \\<turnstile> (C, Cs @\\<^sub>p\n                        Ds) has overrider M = (Ts, T, pns,\n         body) via Cs'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "with notempty"], ["proof (chain)\npicking this:\n  Ds \\<noteq> []\n  P \\<turnstile> last Ds has least M = (Ts', T', pns', body') via [last Ds]", "have \"P \\<turnstile> last (Cs@\\<^sub>pDs) has least M = (Ts',T',pns',body') via [last Ds]\""], ["proof (prove)\nusing this:\n  Ds \\<noteq> []\n  P \\<turnstile> last Ds has least M = (Ts', T', pns', body') via [last Ds]\n\ngoal (1 subgoal):\n 1. P \\<turnstile> last\n                    (Cs @\\<^sub>p\n                     Ds) has least M = (Ts', T', pns', body') via [last Ds]", "by -(drule_tac Cs'=\"Cs\" in appendPath_last,simp)"], ["proof (state)\nthis:\n  P \\<turnstile> last\n                  (Cs @\\<^sub>p\n                   Ds) has least M = (Ts', T', pns', body') via [last Ds]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>mthd Cs'.\n                \\<not> P \\<turnstile> C has least M = mthd via Cs';\n     P \\<turnstile> (C, Cs @\\<^sub>p\n                        Ds) has overrider M = (Ts, T, pns,\n         body) via Cs'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "with overrider wf eq"], ["proof (chain)\npicking this:\n  P \\<turnstile> (C, Cs @\\<^sub>p\n                     Ds) has overrider M = (Ts, T, pns, body) via Cs'\n  wf_prog wf_md P\n  (Cs @\\<^sub>p Ds) @\\<^sub>p [last Ds] = Cs @\\<^sub>p Ds\n  P \\<turnstile> last\n                  (Cs @\\<^sub>p\n                   Ds) has least M = (Ts', T', pns', body') via [last Ds]", "have \"(Cs',Ts,T,pns,body) \\<in> MinimalMethodDefs P C M\"\n      and \"P,C \\<turnstile> Cs' \\<sqsubseteq> Cs @\\<^sub>p Ds\""], ["proof (prove)\nusing this:\n  P \\<turnstile> (C, Cs @\\<^sub>p\n                     Ds) has overrider M = (Ts, T, pns, body) via Cs'\n  wf_prog wf_md P\n  (Cs @\\<^sub>p Ds) @\\<^sub>p [last Ds] = Cs @\\<^sub>p Ds\n  P \\<turnstile> last\n                  (Cs @\\<^sub>p\n                   Ds) has least M = (Ts', T', pns', body') via [last Ds]\n\ngoal (1 subgoal):\n 1. (Cs', Ts, T, pns, body) \\<in> MinimalMethodDefs P C M &&&\n    P,C \\<turnstile> Cs' \\<sqsubseteq> Cs @\\<^sub>p Ds", "by -(auto simp:FinalOverriderMethodDef_def OverriderMethodDefs_def,\n        drule wf_sees_method_fun,auto)"], ["proof (state)\nthis:\n  (Cs', Ts, T, pns, body) \\<in> MinimalMethodDefs P C M\n  P,C \\<turnstile> Cs' \\<sqsubseteq> Cs @\\<^sub>p Ds\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>mthd Cs'.\n                \\<not> P \\<turnstile> C has least M = mthd via Cs';\n     P \\<turnstile> (C, Cs @\\<^sub>p\n                        Ds) has overrider M = (Ts, T, pns,\n         body) via Cs'\\<rbrakk>\n    \\<Longrightarrow> Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "with sub wf path notempty has"], ["proof (chain)\npicking this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\n  wf_prog wf_md P\n  P \\<turnstile> Path C to last Cs via Cs \n  Ds \\<noteq> []\n  P \\<turnstile> last Cs has M = (Ts', T', pns', body') via Ds\n  (Cs', Ts, T, pns, body) \\<in> MinimalMethodDefs P C M\n  P,C \\<turnstile> Cs' \\<sqsubseteq> Cs @\\<^sub>p Ds", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> C \\<preceq>\\<^sup>* last Cs\n  wf_prog wf_md P\n  P \\<turnstile> Path C to last Cs via Cs \n  Ds \\<noteq> []\n  P \\<turnstile> last Cs has M = (Ts', T', pns', body') via Ds\n  (Cs', Ts, T, pns, body) \\<in> MinimalMethodDefs P C M\n  P,C \\<turnstile> Cs' \\<sqsubseteq> Cs @\\<^sub>p Ds\n\ngoal (1 subgoal):\n 1. Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'", "by -(drule leq_methods_subtypes,simp_all,blast)+"], ["proof (state)\nthis:\n  Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ts' = Ts \\<and> P \\<turnstile> T \\<le> T'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_syscls:\n  \"set SystemClasses \\<subseteq> set P \\<Longrightarrow> wf_syscls P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set SystemClasses \\<subseteq> set P \\<Longrightarrow> wf_syscls P", "by (simp add: image_def SystemClasses_def wf_syscls_def sys_xcpts_def\n          NullPointerC_def ClassCastC_def OutOfMemoryC_def,force intro:conjI)"], ["", "subsection\\<open>Well formedness and widen\\<close>"], ["", "lemma Class_widen: \"\\<lbrakk>P \\<turnstile> Class C \\<le> T; wf_prog wf_md P; is_class P C\\<rbrakk>  \n  \\<Longrightarrow>  \\<exists>D. T = Class D \\<and> P \\<turnstile> Path C to D unique\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<turnstile> Class C \\<le> T; wf_prog wf_md P;\n     is_class P C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>D.\n                         T = Class D \\<and>\n                         P \\<turnstile> Path C to D unique", "apply (ind_cases \"P \\<turnstile> Class C \\<le> T\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C; T = Class C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>D.\n                         T = Class D \\<and>\n                         P \\<turnstile> Path C to D unique\n 2. \\<And>D.\n       \\<lbrakk>wf_prog wf_md P; is_class P C; T = Class D;\n        P \\<turnstile> Path C to D unique\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D.\n                            T = Class D \\<and>\n                            P \\<turnstile> Path C to D unique", "apply (auto intro:path_C_to_C_unique)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Class_widen_Class [iff]: \"\\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk> \\<Longrightarrow> \n  (P \\<turnstile> Class C \\<le> Class D) = (P \\<turnstile> Path C to D unique)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Class C \\<le> Class D =\n                      (P \\<turnstile> Path C to D unique)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C;\n     P \\<turnstile> Class C \\<le> Class D\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Path C to D unique\n 2. \\<lbrakk>wf_prog wf_md P; is_class P C;\n     P \\<turnstile> Path C to D unique\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Class C \\<le> Class D", "apply (ind_cases \" P \\<turnstile> Class C \\<le> Class D\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C; D = C\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Path C to D unique\n 2. \\<lbrakk>wf_prog wf_md P; is_class P C;\n     P \\<turnstile> Path C to D unique\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Path C to D unique\n 3. \\<lbrakk>wf_prog wf_md P; is_class P C;\n     P \\<turnstile> Path C to D unique\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Class C \\<le> Class D", "apply (auto elim: widen_subcls intro:path_C_to_C_unique)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma widen_Class: \"\\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk> \\<Longrightarrow> \n  (P \\<turnstile> T \\<le> Class C) = \n    (T = NT \\<or> (\\<exists>D. T = Class D \\<and> P \\<turnstile> Path D to C unique))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> T \\<le> Class C =\n                      (T = NT \\<or>\n                       (\\<exists>D.\n                           T = Class D \\<and>\n                           P \\<turnstile> Path D to C unique))", "apply(induct T)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Void \\<le> Class C =\n                      (Void = NT \\<or>\n                       (\\<exists>D.\n                           Void = Class D \\<and>\n                           P \\<turnstile> Path D to C unique))\n 2. \\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Boolean \\<le> Class C =\n                      (Boolean = NT \\<or>\n                       (\\<exists>D.\n                           Boolean = Class D \\<and>\n                           P \\<turnstile> Path D to C unique))\n 3. \\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> Integer \\<le> Class C =\n                      (Integer = NT \\<or>\n                       (\\<exists>D.\n                           Integer = Class D \\<and>\n                           P \\<turnstile> Path D to C unique))\n 4. \\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk>\n    \\<Longrightarrow> P \\<turnstile> NT \\<le> Class C =\n                      (NT = NT \\<or>\n                       (\\<exists>D.\n                           NT = Class D \\<and>\n                           P \\<turnstile> Path D to C unique))\n 5. \\<And>x.\n       \\<lbrakk>wf_prog wf_md P; is_class P C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Class x \\<le> Class C =\n                         (Class x = NT \\<or>\n                          (\\<exists>D.\n                              Class x = Class D \\<and>\n                              P \\<turnstile> Path D to C unique))", "apply (auto intro:widen_subcls)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>wf_prog wf_md P; is_class P C;\n        P \\<turnstile> Class x \\<le> Class C\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Path x to C unique", "apply (ind_cases \"P \\<turnstile> Class D \\<le> Class C\" for D)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>wf_prog wf_md P; is_class P C; C = x\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Path x to C unique\n 2. \\<And>x.\n       \\<lbrakk>wf_prog wf_md P; is_class P C;\n        P \\<turnstile> Path x to C unique\\<rbrakk>\n       \\<Longrightarrow> P \\<turnstile> Path x to C unique", "apply (auto intro:path_C_to_C_unique)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Well formedness and well typing\\<close>"], ["", "lemma assumes wf:\"wf_prog wf_md P\" \nshows WT_determ: \"P,E \\<turnstile> e :: T \\<Longrightarrow> (\\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T')\"\nand WTs_determ: \"P,E \\<turnstile> es [::] Ts \\<Longrightarrow> (\\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P,E \\<turnstile> e :: T \\<Longrightarrow>\n     (\\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T')) &&&\n    (P,E \\<turnstile> es [::] Ts \\<Longrightarrow>\n     (\\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts'))", "proof(induct rule:WT_WTs_inducts)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>E e D C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class D;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class D = T';\n        is_class P C;\n        P \\<turnstile> Path D to C unique \\<or>\n        (\\<forall>Cs. \\<not> P \\<turnstile> Path D to C via Cs );\n        P,E \\<turnstile> Cast C e :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 3. \\<And>E e D C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class D;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class D = T';\n        is_class P C;\n        P \\<turnstile> Path D to C unique \\<or>\n        P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and>\n        (\\<forall>Cs.\n            P \\<turnstile> Path C to D via Cs  \\<longrightarrow>\n            Subobjs\\<^sub>R P C Cs);\n        P,E \\<turnstile> \\<lparr>C\\<rparr>e :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 4. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        case bop of\n        Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 8. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 10. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C';\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n         P \\<turnstile> Path C' to C unique;\n         P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n         P,E \\<turnstile> es [::] Ts';\n         \\<And>Ts'a.\n            P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n         P \\<turnstile> Ts' [\\<le>] Ts;\n         P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n        \\<Longrightarrow> T = T'\nA total of 18 subgoals...", "case (WTDynCast E e D C)"], ["proof (state)\nthis:\n  P,E \\<turnstile> e :: Class D\n  P,E \\<turnstile> e :: ?T' \\<Longrightarrow> Class D = ?T'\n  is_class P C\n  P \\<turnstile> Path D to C unique \\<or>\n  (\\<forall>Cs. \\<not> P \\<turnstile> Path D to C via Cs )\n  P,E \\<turnstile> Cast C e :: T'\n\ngoal (18 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>E e D C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class D;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class D = T';\n        is_class P C;\n        P \\<turnstile> Path D to C unique \\<or>\n        (\\<forall>Cs. \\<not> P \\<turnstile> Path D to C via Cs );\n        P,E \\<turnstile> Cast C e :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 3. \\<And>E e D C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class D;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class D = T';\n        is_class P C;\n        P \\<turnstile> Path D to C unique \\<or>\n        P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and>\n        (\\<forall>Cs.\n            P \\<turnstile> Path C to D via Cs  \\<longrightarrow>\n            Subobjs\\<^sub>R P C Cs);\n        P,E \\<turnstile> \\<lparr>C\\<rparr>e :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 4. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        case bop of\n        Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 8. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 10. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C';\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n         P \\<turnstile> Path C' to C unique;\n         P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n         P,E \\<turnstile> es [::] Ts';\n         \\<And>Ts'a.\n            P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n         P \\<turnstile> Ts' [\\<le>] Ts;\n         P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n        \\<Longrightarrow> T = T'\nA total of 18 subgoals...", "have \"P,E \\<turnstile> Cast C e :: T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,E \\<turnstile> Cast C e :: T'", "by fact"], ["proof (state)\nthis:\n  P,E \\<turnstile> Cast C e :: T'\n\ngoal (18 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>E e D C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class D;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class D = T';\n        is_class P C;\n        P \\<turnstile> Path D to C unique \\<or>\n        (\\<forall>Cs. \\<not> P \\<turnstile> Path D to C via Cs );\n        P,E \\<turnstile> Cast C e :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 3. \\<And>E e D C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class D;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class D = T';\n        is_class P C;\n        P \\<turnstile> Path D to C unique \\<or>\n        P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and>\n        (\\<forall>Cs.\n            P \\<turnstile> Path C to D via Cs  \\<longrightarrow>\n            Subobjs\\<^sub>R P C Cs);\n        P,E \\<turnstile> \\<lparr>C\\<rparr>e :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 4. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        case bop of\n        Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 8. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 10. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C';\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n         P \\<turnstile> Path C' to C unique;\n         P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n         P,E \\<turnstile> es [::] Ts';\n         \\<And>Ts'a.\n            P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n         P \\<turnstile> Ts' [\\<le>] Ts;\n         P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n        \\<Longrightarrow> T = T'\nA total of 18 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  P,E \\<turnstile> Cast C e :: T'\n\ngoal (1 subgoal):\n 1. Class C = T'", "by (fastforce elim:WT.cases)"], ["proof (state)\nthis:\n  Class C = T'\n\ngoal (17 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>E e D C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class D;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class D = T';\n        is_class P C;\n        P \\<turnstile> Path D to C unique \\<or>\n        P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and>\n        (\\<forall>Cs.\n            P \\<turnstile> Path C to D via Cs  \\<longrightarrow>\n            Subobjs\\<^sub>R P C Cs);\n        P,E \\<turnstile> \\<lparr>C\\<rparr>e :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 3. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        case bop of\n        Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 7. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 9. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>E e C M Ts T a b Cs es Ts' T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n         P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n         P,E \\<turnstile> es [::] Ts';\n         \\<And>Ts'a.\n            P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n         P \\<turnstile> Ts' [\\<le>] Ts;\n         P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n        \\<Longrightarrow> T = T'\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>E e D C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class D;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class D = T';\n        is_class P C;\n        P \\<turnstile> Path D to C unique \\<or>\n        P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and>\n        (\\<forall>Cs.\n            P \\<turnstile> Path C to D via Cs  \\<longrightarrow>\n            Subobjs\\<^sub>R P C Cs);\n        P,E \\<turnstile> \\<lparr>C\\<rparr>e :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 3. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        case bop of\n        Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 7. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 9. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>E e C M Ts T a b Cs es Ts' T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n         P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n         P,E \\<turnstile> es [::] Ts';\n         \\<And>Ts'a.\n            P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n         P \\<turnstile> Ts' [\\<le>] Ts;\n         P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n        \\<Longrightarrow> T = T'\nA total of 17 subgoals...", "case (WTStaticCast E e D C)"], ["proof (state)\nthis:\n  P,E \\<turnstile> e :: Class D\n  P,E \\<turnstile> e :: ?T' \\<Longrightarrow> Class D = ?T'\n  is_class P C\n  P \\<turnstile> Path D to C unique \\<or>\n  P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and>\n  (\\<forall>Cs.\n      P \\<turnstile> Path C to D via Cs  \\<longrightarrow>\n      Subobjs\\<^sub>R P C Cs)\n  P,E \\<turnstile> \\<lparr>C\\<rparr>e :: T'\n\ngoal (17 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>E e D C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class D;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class D = T';\n        is_class P C;\n        P \\<turnstile> Path D to C unique \\<or>\n        P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and>\n        (\\<forall>Cs.\n            P \\<turnstile> Path C to D via Cs  \\<longrightarrow>\n            Subobjs\\<^sub>R P C Cs);\n        P,E \\<turnstile> \\<lparr>C\\<rparr>e :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 3. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        case bop of\n        Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 7. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 9. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>E e C M Ts T a b Cs es Ts' T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n         P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n         P,E \\<turnstile> es [::] Ts';\n         \\<And>Ts'a.\n            P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n         P \\<turnstile> Ts' [\\<le>] Ts;\n         P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n        \\<Longrightarrow> T = T'\nA total of 17 subgoals...", "have \"P,E \\<turnstile> \\<lparr>C\\<rparr>e :: T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,E \\<turnstile> \\<lparr>C\\<rparr>e :: T'", "by fact"], ["proof (state)\nthis:\n  P,E \\<turnstile> \\<lparr>C\\<rparr>e :: T'\n\ngoal (17 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>E e D C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class D;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class D = T';\n        is_class P C;\n        P \\<turnstile> Path D to C unique \\<or>\n        P \\<turnstile> C \\<preceq>\\<^sup>* D \\<and>\n        (\\<forall>Cs.\n            P \\<turnstile> Path C to D via Cs  \\<longrightarrow>\n            Subobjs\\<^sub>R P C Cs);\n        P,E \\<turnstile> \\<lparr>C\\<rparr>e :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 3. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        case bop of\n        Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 7. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 9. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>E e C M Ts T a b Cs es Ts' T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n         P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n         P,E \\<turnstile> es [::] Ts';\n         \\<And>Ts'a.\n            P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n         P \\<turnstile> Ts' [\\<le>] Ts;\n         P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n        \\<Longrightarrow> T = T'\nA total of 17 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  P,E \\<turnstile> \\<lparr>C\\<rparr>e :: T'\n\ngoal (1 subgoal):\n 1. Class C = T'", "by (fastforce elim:WT.cases)"], ["proof (state)\nthis:\n  Class C = T'\n\ngoal (16 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        case bop of\n        Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 6. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 8. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>T E V e T' T'a.\n        \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n         \\<And>T'a.\n            P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n            T' = T'a;\n         P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n        \\<Longrightarrow> T' = T'a\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        case bop of\n        Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 6. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 8. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>T E V e T' T'a.\n        \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n         \\<And>T'a.\n            P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n            T' = T'a;\n         P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n        \\<Longrightarrow> T' = T'a\nA total of 16 subgoals...", "case (WTBinOp E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T)"], ["proof (state)\nthis:\n  P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1\n  P,E \\<turnstile> e\\<^sub>1 :: ?T' \\<Longrightarrow> T\\<^sub>1 = ?T'\n  P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2\n  P,E \\<turnstile> e\\<^sub>2 :: ?T' \\<Longrightarrow> T\\<^sub>2 = ?T'\n  case bop of Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n  | Add \\<Rightarrow>\n      T\\<^sub>1 = Integer \\<and> T\\<^sub>2 = Integer \\<and> T = Integer\n  P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\n\ngoal (16 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        case bop of\n        Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 6. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 8. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>T E V e T' T'a.\n        \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n         \\<And>T'a.\n            P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n            T' = T'a;\n         P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n        \\<Longrightarrow> T' = T'a\nA total of 16 subgoals...", "have bop:\"case bop of Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n    | Add \\<Rightarrow> T\\<^sub>1 = Integer \\<and> T\\<^sub>2 = Integer \\<and> T = Integer\"\n    and wt:\"P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case bop of Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n    | Add \\<Rightarrow>\n        T\\<^sub>1 = Integer \\<and>\n        T\\<^sub>2 = Integer \\<and> T = Integer &&&\n    P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'", "by fact+"], ["proof (state)\nthis:\n  case bop of Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n  | Add \\<Rightarrow>\n      T\\<^sub>1 = Integer \\<and> T\\<^sub>2 = Integer \\<and> T = Integer\n  P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\n\ngoal (16 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        case bop of\n        Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 6. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 8. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>T E V e T' T'a.\n        \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n         \\<And>T'a.\n            P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n            T' = T'a;\n         P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n        \\<Longrightarrow> T' = T'a\nA total of 16 subgoals...", "from wt"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'", "obtain T1' T2' where\n    bop':\"case bop of Eq \\<Rightarrow> T1' = T2' \\<and> T' = Boolean\n    | Add \\<Rightarrow> T1' = Integer \\<and> T2' = Integer \\<and> T' = Integer\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\n\ngoal (1 subgoal):\n 1. (\\<And>T1' T2'.\n        case bop of Eq \\<Rightarrow> T1' = T2' \\<and> T' = Boolean\n        | Add \\<Rightarrow>\n            T1' = Integer \\<and>\n            T2' = Integer \\<and> T' = Integer \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  case bop of Eq \\<Rightarrow> T1' = T2' \\<and> T' = Boolean\n  | Add \\<Rightarrow> T1' = Integer \\<and> T2' = Integer \\<and> T' = Integer\n\ngoal (16 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 bop T T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        case bop of\n        Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n        | Add \\<Rightarrow>\n            T\\<^sub>1 = Integer \\<and>\n            T\\<^sub>2 = Integer \\<and> T = Integer;\n        P,E \\<turnstile> e\\<^sub>1 \\<guillemotleft>bop\\<guillemotright> e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 6. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 8. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>T E V e T' T'a.\n        \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n         \\<And>T'a.\n            P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n            T' = T'a;\n         P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n        \\<Longrightarrow> T' = T'a\nA total of 16 subgoals...", "from bop"], ["proof (chain)\npicking this:\n  case bop of Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n  | Add \\<Rightarrow>\n      T\\<^sub>1 = Integer \\<and> T\\<^sub>2 = Integer \\<and> T = Integer", "show ?case"], ["proof (prove)\nusing this:\n  case bop of Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n  | Add \\<Rightarrow>\n      T\\<^sub>1 = Integer \\<and> T\\<^sub>2 = Integer \\<and> T = Integer\n\ngoal (1 subgoal):\n 1. T = T'", "proof (cases bop)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>case bop of\n             Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n             | Add \\<Rightarrow>\n                 T\\<^sub>1 = Integer \\<and>\n                 T\\<^sub>2 = Integer \\<and> T = Integer;\n     bop = Eq\\<rbrakk>\n    \\<Longrightarrow> T = T'\n 2. \\<lbrakk>case bop of\n             Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n             | Add \\<Rightarrow>\n                 T\\<^sub>1 = Integer \\<and>\n                 T\\<^sub>2 = Integer \\<and> T = Integer;\n     bop = Add\\<rbrakk>\n    \\<Longrightarrow> T = T'", "assume Eq:\"bop = Eq\""], ["proof (state)\nthis:\n  bop = Eq\n\ngoal (2 subgoals):\n 1. \\<lbrakk>case bop of\n             Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n             | Add \\<Rightarrow>\n                 T\\<^sub>1 = Integer \\<and>\n                 T\\<^sub>2 = Integer \\<and> T = Integer;\n     bop = Eq\\<rbrakk>\n    \\<Longrightarrow> T = T'\n 2. \\<lbrakk>case bop of\n             Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n             | Add \\<Rightarrow>\n                 T\\<^sub>1 = Integer \\<and>\n                 T\\<^sub>2 = Integer \\<and> T = Integer;\n     bop = Add\\<rbrakk>\n    \\<Longrightarrow> T = T'", "with bop"], ["proof (chain)\npicking this:\n  case bop of Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n  | Add \\<Rightarrow>\n      T\\<^sub>1 = Integer \\<and> T\\<^sub>2 = Integer \\<and> T = Integer\n  bop = Eq", "have \"T = Boolean\""], ["proof (prove)\nusing this:\n  case bop of Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n  | Add \\<Rightarrow>\n      T\\<^sub>1 = Integer \\<and> T\\<^sub>2 = Integer \\<and> T = Integer\n  bop = Eq\n\ngoal (1 subgoal):\n 1. T = Boolean", "by auto"], ["proof (state)\nthis:\n  T = Boolean\n\ngoal (2 subgoals):\n 1. \\<lbrakk>case bop of\n             Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n             | Add \\<Rightarrow>\n                 T\\<^sub>1 = Integer \\<and>\n                 T\\<^sub>2 = Integer \\<and> T = Integer;\n     bop = Eq\\<rbrakk>\n    \\<Longrightarrow> T = T'\n 2. \\<lbrakk>case bop of\n             Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n             | Add \\<Rightarrow>\n                 T\\<^sub>1 = Integer \\<and>\n                 T\\<^sub>2 = Integer \\<and> T = Integer;\n     bop = Add\\<rbrakk>\n    \\<Longrightarrow> T = T'", "with Eq bop'"], ["proof (chain)\npicking this:\n  bop = Eq\n  case bop of Eq \\<Rightarrow> T1' = T2' \\<and> T' = Boolean\n  | Add \\<Rightarrow> T1' = Integer \\<and> T2' = Integer \\<and> T' = Integer\n  T = Boolean", "show ?thesis"], ["proof (prove)\nusing this:\n  bop = Eq\n  case bop of Eq \\<Rightarrow> T1' = T2' \\<and> T' = Boolean\n  | Add \\<Rightarrow> T1' = Integer \\<and> T2' = Integer \\<and> T' = Integer\n  T = Boolean\n\ngoal (1 subgoal):\n 1. T = T'", "by simp"], ["proof (state)\nthis:\n  T = T'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>case bop of\n             Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n             | Add \\<Rightarrow>\n                 T\\<^sub>1 = Integer \\<and>\n                 T\\<^sub>2 = Integer \\<and> T = Integer;\n     bop = Add\\<rbrakk>\n    \\<Longrightarrow> T = T'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>case bop of\n             Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n             | Add \\<Rightarrow>\n                 T\\<^sub>1 = Integer \\<and>\n                 T\\<^sub>2 = Integer \\<and> T = Integer;\n     bop = Add\\<rbrakk>\n    \\<Longrightarrow> T = T'", "assume Add:\"bop = Add\""], ["proof (state)\nthis:\n  bop = Add\n\ngoal (1 subgoal):\n 1. \\<lbrakk>case bop of\n             Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n             | Add \\<Rightarrow>\n                 T\\<^sub>1 = Integer \\<and>\n                 T\\<^sub>2 = Integer \\<and> T = Integer;\n     bop = Add\\<rbrakk>\n    \\<Longrightarrow> T = T'", "with bop"], ["proof (chain)\npicking this:\n  case bop of Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n  | Add \\<Rightarrow>\n      T\\<^sub>1 = Integer \\<and> T\\<^sub>2 = Integer \\<and> T = Integer\n  bop = Add", "have \"T = Integer\""], ["proof (prove)\nusing this:\n  case bop of Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n  | Add \\<Rightarrow>\n      T\\<^sub>1 = Integer \\<and> T\\<^sub>2 = Integer \\<and> T = Integer\n  bop = Add\n\ngoal (1 subgoal):\n 1. T = Integer", "by auto"], ["proof (state)\nthis:\n  T = Integer\n\ngoal (1 subgoal):\n 1. \\<lbrakk>case bop of\n             Eq \\<Rightarrow> T\\<^sub>1 = T\\<^sub>2 \\<and> T = Boolean\n             | Add \\<Rightarrow>\n                 T\\<^sub>1 = Integer \\<and>\n                 T\\<^sub>2 = Integer \\<and> T = Integer;\n     bop = Add\\<rbrakk>\n    \\<Longrightarrow> T = T'", "with Add bop'"], ["proof (chain)\npicking this:\n  bop = Add\n  case bop of Eq \\<Rightarrow> T1' = T2' \\<and> T' = Boolean\n  | Add \\<Rightarrow> T1' = Integer \\<and> T2' = Integer \\<and> T' = Integer\n  T = Integer", "show ?thesis"], ["proof (prove)\nusing this:\n  bop = Add\n  case bop of Eq \\<Rightarrow> T1' = T2' \\<and> T' = Boolean\n  | Add \\<Rightarrow> T1' = Integer \\<and> T2' = Integer \\<and> T' = Integer\n  T = Integer\n\ngoal (1 subgoal):\n 1. T = T'", "by simp"], ["proof (state)\nthis:\n  T = T'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T = T'\n\ngoal (15 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 5. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 7. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 10. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n        \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n            T\\<^sub>1 = T';\n         P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n            T\\<^sub>2 = T';\n         P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>2 = T'\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 5. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 7. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 10. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n        \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n            T\\<^sub>1 = T';\n         P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n            T\\<^sub>2 = T';\n         P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>2 = T'\nA total of 15 subgoals...", "case (WTLAss E V T e T' T'')"], ["proof (state)\nthis:\n  E V = \\<lfloor>T\\<rfloor>\n  P,E \\<turnstile> e :: T'\n  P,E \\<turnstile> e :: ?T' \\<Longrightarrow> T' = ?T'\n  P \\<turnstile> T' \\<le> T\n  P,E \\<turnstile> V:=e :: T''\n\ngoal (15 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 5. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 7. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 10. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n        \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n            T\\<^sub>1 = T';\n         P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n            T\\<^sub>2 = T';\n         P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>2 = T'\nA total of 15 subgoals...", "have \"P,E \\<turnstile> V:=e :: T''\" \n    and \"E V = Some T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P,E \\<turnstile> V:=e :: T'' &&& E V = \\<lfloor>T\\<rfloor>", "by fact+"], ["proof (state)\nthis:\n  P,E \\<turnstile> V:=e :: T''\n  E V = \\<lfloor>T\\<rfloor>\n\ngoal (15 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E V T e T' T'a.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>; P,E \\<turnstile> e :: T';\n        \\<And>T'a. P,E \\<turnstile> e :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T; P,E \\<turnstile> V:=e :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 5. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 7. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 10. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n        \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n            T\\<^sub>1 = T';\n         P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n            T\\<^sub>2 = T';\n         P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n        \\<Longrightarrow> T\\<^sub>2 = T'\nA total of 15 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  P,E \\<turnstile> V:=e :: T''\n  E V = \\<lfloor>T\\<rfloor>\n\ngoal (1 subgoal):\n 1. T = T''", "by auto"], ["proof (state)\nthis:\n  T = T''\n\ngoal (14 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 6. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 9. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 10. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n         P,E \\<turnstile> e\\<^sub>1 :: T;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> e\\<^sub>2 :: T;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n        \\<Longrightarrow> T = T'\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 6. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 9. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 10. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n         P,E \\<turnstile> e\\<^sub>1 :: T;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> e\\<^sub>2 :: T;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n        \\<Longrightarrow> T = T'\nA total of 14 subgoals...", "case (WTFAcc E e C F T Cs)"], ["proof (state)\nthis:\n  P,E \\<turnstile> e :: Class C\n  P,E \\<turnstile> e :: ?T' \\<Longrightarrow> Class C = ?T'\n  P \\<turnstile> C has least F:T via Cs\n  P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\n\ngoal (14 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 6. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 9. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 10. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n         P,E \\<turnstile> e\\<^sub>1 :: T;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> e\\<^sub>2 :: T;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n        \\<Longrightarrow> T = T'\nA total of 14 subgoals...", "have IH:\"\\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T'\"\n    and least:\"P \\<turnstile> C has least F:T via Cs\"\n    and wt:\"P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T') &&&\n    P \\<turnstile> C has least F:T via Cs &&&\n    P,E \\<turnstile> e\\<bullet>F{Cs} :: T'", "by fact+"], ["proof (state)\nthis:\n  P,E \\<turnstile> e :: ?T' \\<Longrightarrow> Class C = ?T'\n  P \\<turnstile> C has least F:T via Cs\n  P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\n\ngoal (14 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 6. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 9. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 10. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n         P,E \\<turnstile> e\\<^sub>1 :: T;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> e\\<^sub>2 :: T;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n        \\<Longrightarrow> T = T'\nA total of 14 subgoals...", "from wt"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> e\\<bullet>F{Cs} :: T'", "obtain C' where wte':\"P,E \\<turnstile> e :: Class C'\"\n    and least':\"P \\<turnstile> C' has least F:T' via Cs\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\n\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C';\n         P \\<turnstile> C' has least F:T' via Cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,E \\<turnstile> e :: Class C'\n  P \\<turnstile> C' has least F:T' via Cs\n\ngoal (14 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 6. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 9. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 10. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n         P,E \\<turnstile> e\\<^sub>1 :: T;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> e\\<^sub>2 :: T;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n        \\<Longrightarrow> T = T'\nA total of 14 subgoals...", "from IH[OF wte']"], ["proof (chain)\npicking this:\n  Class C = Class C'", "have \"C = C'\""], ["proof (prove)\nusing this:\n  Class C = Class C'\n\ngoal (1 subgoal):\n 1. C = C'", "by simp"], ["proof (state)\nthis:\n  C = C'\n\ngoal (14 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C F T Cs T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<bullet>F{Cs} :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 6. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 9. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 10. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n         P,E \\<turnstile> e\\<^sub>1 :: T;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> e\\<^sub>2 :: T;\n         \\<And>T'.\n            P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n        \\<Longrightarrow> T = T'\nA total of 14 subgoals...", "with least least'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least F:T via Cs\n  P \\<turnstile> C' has least F:T' via Cs\n  C = C'", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least F:T via Cs\n  P \\<turnstile> C' has least F:T' via Cs\n  C = C'\n\ngoal (1 subgoal):\n 1. T = T'", "by (fastforce simp:sees_field_fun)"], ["proof (state)\nthis:\n  T = T'\n\ngoal (13 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 5. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 8. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 9. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>E e c T T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n         P,E \\<turnstile> c :: T;\n         \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n        \\<Longrightarrow> Void = T'\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 5. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 8. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 9. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>E e c T T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n         P,E \\<turnstile> c :: T;\n         \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n        \\<Longrightarrow> Void = T'\nA total of 13 subgoals...", "case (WTFAss E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'')"], ["proof (state)\nthis:\n  P,E \\<turnstile> e\\<^sub>1 :: Class C\n  P,E \\<turnstile> e\\<^sub>1 :: ?T' \\<Longrightarrow> Class C = ?T'\n  P \\<turnstile> C has least F:T via Cs\n  P,E \\<turnstile> e\\<^sub>2 :: T'\n  P,E \\<turnstile> e\\<^sub>2 :: ?T' \\<Longrightarrow> T' = ?T'\n  P \\<turnstile> T' \\<le> T\n  P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T''\n\ngoal (13 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 5. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 8. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 9. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>E e c T T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n         P,E \\<turnstile> c :: T;\n         \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n        \\<Longrightarrow> Void = T'\nA total of 13 subgoals...", "have least:\"P \\<turnstile> C has least F:T via Cs\"\n    and wt:\"P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T''\" \n    and IH:\"\\<And>S. P,E \\<turnstile> e\\<^sub>1 :: S \\<Longrightarrow> Class C = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<turnstile> C has least F:T via Cs &&&\n    P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'' &&&\n    (\\<And>S. P,E \\<turnstile> e\\<^sub>1 :: S \\<Longrightarrow> Class C = S)", "by fact+"], ["proof (state)\nthis:\n  P \\<turnstile> C has least F:T via Cs\n  P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T''\n  P,E \\<turnstile> e\\<^sub>1 :: ?S \\<Longrightarrow> Class C = ?S\n\ngoal (13 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 5. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 8. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 9. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>E e c T T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n         P,E \\<turnstile> c :: T;\n         \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n        \\<Longrightarrow> Void = T'\nA total of 13 subgoals...", "from wt"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T''", "obtain C' where wte':\"P,E \\<turnstile> e\\<^sub>1 :: Class C'\" \n    and least':\"P \\<turnstile> C' has least F:T'' via Cs\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T''\n\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C';\n         P \\<turnstile> C' has least F:T'' via Cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,E \\<turnstile> e\\<^sub>1 :: Class C'\n  P \\<turnstile> C' has least F:T'' via Cs\n\ngoal (13 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 5. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 8. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 9. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>E e c T T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n         P,E \\<turnstile> c :: T;\n         \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n        \\<Longrightarrow> Void = T'\nA total of 13 subgoals...", "from IH[OF wte']"], ["proof (chain)\npicking this:\n  Class C = Class C'", "have \"C = C'\""], ["proof (prove)\nusing this:\n  Class C = Class C'\n\ngoal (1 subgoal):\n 1. C = C'", "by simp"], ["proof (state)\nthis:\n  C = C'\n\ngoal (13 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 C F T Cs e\\<^sub>2 T' T'a.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: Class C;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least F:T via Cs;\n        P,E \\<turnstile> e\\<^sub>2 :: T';\n        \\<And>T'a.\n           P,E \\<turnstile> e\\<^sub>2 :: T'a \\<Longrightarrow> T' = T'a;\n        P \\<turnstile> T' \\<le> T;\n        P,E \\<turnstile> e\\<^sub>1\\<bullet>F{Cs} := e\\<^sub>2 :: T'a\\<rbrakk>\n       \\<Longrightarrow> T = T'a\n 5. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 8. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 9. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 10. \\<And>E e c T T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n         P,E \\<turnstile> c :: T;\n         \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n        \\<Longrightarrow> Void = T'\nA total of 13 subgoals...", "with least least'"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least F:T via Cs\n  P \\<turnstile> C' has least F:T'' via Cs\n  C = C'", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least F:T via Cs\n  P \\<turnstile> C' has least F:T'' via Cs\n  C = C'\n\ngoal (1 subgoal):\n 1. T = T''", "by (fastforce simp:sees_field_fun)"], ["proof (state)\nthis:\n  T = T''\n\ngoal (12 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 7. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 8. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 10. \\<And>E e C T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n         P,E \\<turnstile> throw e :: T'\\<rbrakk>\n        \\<Longrightarrow> Void = T'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 7. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 8. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 10. \\<And>E e C T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n         P,E \\<turnstile> throw e :: T'\\<rbrakk>\n        \\<Longrightarrow> Void = T'\nA total of 12 subgoals...", "case (WTCall E e C M Ts T pns body Cs es Ts')"], ["proof (state)\nthis:\n  P,E \\<turnstile> e :: Class C\n  P,E \\<turnstile> e :: ?T' \\<Longrightarrow> Class C = ?T'\n  P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs\n  P,E \\<turnstile> es [::] Ts'\n  P,E \\<turnstile> es [::] ?Ts' \\<Longrightarrow> Ts' = ?Ts'\n  P \\<turnstile> Ts' [\\<le>] Ts\n  P,E \\<turnstile> Call e None M es :: T'\n\ngoal (12 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 7. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 8. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 10. \\<And>E e C T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n         P,E \\<turnstile> throw e :: T'\\<rbrakk>\n        \\<Longrightarrow> Void = T'\nA total of 12 subgoals...", "have IH:\"\\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T'\"\n    and least:\"P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs\"\n    and wt:\"P,E \\<turnstile> e\\<bullet>M(es) :: T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T') &&&\n    P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs &&&\n    P,E \\<turnstile> Call e None M es :: T'", "by fact+"], ["proof (state)\nthis:\n  P,E \\<turnstile> e :: ?T' \\<Longrightarrow> Class C = ?T'\n  P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs\n  P,E \\<turnstile> Call e None M es :: T'\n\ngoal (12 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 7. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 8. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 10. \\<And>E e C T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n         P,E \\<turnstile> throw e :: T'\\<rbrakk>\n        \\<Longrightarrow> Void = T'\nA total of 12 subgoals...", "from wt"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> Call e None M es :: T'", "obtain C' Ts' pns' body' Cs' where wte':\"P,E \\<turnstile> e :: Class C'\"\n    and least':\"P \\<turnstile> C' has least M = (Ts',T',pns',body') via Cs'\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> Call e None M es :: T'\n\ngoal (1 subgoal):\n 1. (\\<And>C' Ts' pns' body' Cs'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C';\n         P \\<turnstile> C' has least M = (Ts', T', pns',\n    body') via Cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P,E \\<turnstile> e :: Class C'\n  P \\<turnstile> C' has least M = (Ts', T', pns', body') via Cs'\n\ngoal (12 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 7. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 8. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 10. \\<And>E e C T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n         P,E \\<turnstile> throw e :: T'\\<rbrakk>\n        \\<Longrightarrow> Void = T'\nA total of 12 subgoals...", "from IH[OF wte']"], ["proof (chain)\npicking this:\n  Class C = Class C'", "have \"C = C'\""], ["proof (prove)\nusing this:\n  Class C = Class C'\n\ngoal (1 subgoal):\n 1. C = C'", "by simp"], ["proof (state)\nthis:\n  C = C'\n\ngoal (12 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e None M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 7. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 8. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 9. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 10. \\<And>E e C T'.\n        \\<lbrakk>P,E \\<turnstile> e :: Class C;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n         P,E \\<turnstile> throw e :: T'\\<rbrakk>\n        \\<Longrightarrow> Void = T'\nA total of 12 subgoals...", "with least least' wf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs\n  P \\<turnstile> C' has least M = (Ts', T', pns', body') via Cs'\n  wf_prog wf_md P\n  C = C'", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs\n  P \\<turnstile> C' has least M = (Ts', T', pns', body') via Cs'\n  wf_prog wf_md P\n  C = C'\n\ngoal (1 subgoal):\n 1. T = T'", "by (auto dest:wf_sees_method_fun)"], ["proof (state)\nthis:\n  T = T'\n\ngoal (11 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 6. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 7. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 9. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 10. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 6. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 7. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 9. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 10. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\nA total of 11 subgoals...", "case (WTStaticCall E e C' C M Ts T pns body Cs es Ts')"], ["proof (state)\nthis:\n  P,E \\<turnstile> e :: Class C'\n  P,E \\<turnstile> e :: ?T' \\<Longrightarrow> Class C' = ?T'\n  P \\<turnstile> Path C' to C unique\n  P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs\n  P,E \\<turnstile> es [::] Ts'\n  P,E \\<turnstile> es [::] ?Ts' \\<Longrightarrow> Ts' = ?Ts'\n  P \\<turnstile> Ts' [\\<le>] Ts\n  P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\n\ngoal (11 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 6. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 7. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 9. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 10. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\nA total of 11 subgoals...", "have IH:\"\\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T'\" \n    and unique:\"P \\<turnstile> Path C' to C unique\"\n    and least:\"P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs\"\n    and wt:\"P,E \\<turnstile> e\\<bullet>(C::)M(es) :: T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>T'.\n         P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T') &&&\n     P \\<turnstile> Path C' to C unique) &&&\n    P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs &&&\n    P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'", "by fact+"], ["proof (state)\nthis:\n  P,E \\<turnstile> e :: ?T' \\<Longrightarrow> Class C' = ?T'\n  P \\<turnstile> Path C' to C unique\n  P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs\n  P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\n\ngoal (11 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 6. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 7. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 9. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 10. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\nA total of 11 subgoals...", "from wt"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'", "obtain Ts' pns' body' Cs' \n    where \"P \\<turnstile> C has least M = (Ts',T',pns',body') via Cs'\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\n\ngoal (1 subgoal):\n 1. (\\<And>Ts' pns' body' Cs'.\n        P \\<turnstile> C has least M = (Ts', T', pns',\n  body') via Cs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<turnstile> C has least M = (Ts', T', pns', body') via Cs'\n\ngoal (11 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e C' C M Ts T a b Cs es Ts' T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C';\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C' = T';\n        P \\<turnstile> Path C' to C unique;\n        P \\<turnstile> C has least M = (Ts, T, a, b) via Cs;\n        P,E \\<turnstile> es [::] Ts';\n        \\<And>Ts'a.\n           P,E \\<turnstile> es [::] Ts'a \\<Longrightarrow> Ts' = Ts'a;\n        P \\<turnstile> Ts' [\\<le>] Ts;\n        P,E \\<turnstile> Call e \\<lfloor>C\\<rfloor> M es :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 6. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 7. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 8. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 9. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 10. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\nA total of 11 subgoals...", "with least wf"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs\n  wf_prog wf_md P\n  P \\<turnstile> C has least M = (Ts', T', pns', body') via Cs'", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has least M = (Ts, T, pns, body) via Cs\n  wf_prog wf_md P\n  P \\<turnstile> C has least M = (Ts', T', pns', body') via Cs'\n\ngoal (1 subgoal):\n 1. T = T'", "by (auto dest:wf_sees_method_fun)"], ["proof (state)\nthis:\n  T = T'\n\ngoal (10 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 5. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 6. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 8. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 9. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 10. \\<And>E e T es Ts Ts'.\n        \\<lbrakk>P,E \\<turnstile> e :: T;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> es [::] Ts;\n         \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n         P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n        \\<Longrightarrow> T # Ts = Ts'", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 5. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 6. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 8. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 9. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 10. \\<And>E e T es Ts Ts'.\n        \\<lbrakk>P,E \\<turnstile> e :: T;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> es [::] Ts;\n         \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n         P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n        \\<Longrightarrow> T # Ts = Ts'", "case WTBlock"], ["proof (state)\nthis:\n  is_type P T_\n  P,E_(V_ \\<mapsto> T_) \\<turnstile> e_ :: T'_\n  P,E_(V_ \\<mapsto> T_) \\<turnstile> e_ :: ?T' \\<Longrightarrow> T'_ = ?T'\n  P,E_ \\<turnstile> {V_:T_; e_} :: T'\n\ngoal (10 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>T E V e T' T'a.\n       \\<lbrakk>is_type P T; P,E(V \\<mapsto> T) \\<turnstile> e :: T';\n        \\<And>T'a.\n           P,E(V \\<mapsto> T) \\<turnstile> e :: T'a \\<Longrightarrow>\n           T' = T'a;\n        P,E \\<turnstile> {V:T; e} :: T'a\\<rbrakk>\n       \\<Longrightarrow> T' = T'a\n 5. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 6. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 7. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 8. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 9. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 10. \\<And>E e T es Ts Ts'.\n        \\<lbrakk>P,E \\<turnstile> e :: T;\n         \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n         P,E \\<turnstile> es [::] Ts;\n         \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n         P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n        \\<Longrightarrow> T # Ts = Ts'", "thus ?case"], ["proof (prove)\nusing this:\n  is_type P T_\n  P,E_(V_ \\<mapsto> T_) \\<turnstile> e_ :: T'_\n  P,E_(V_ \\<mapsto> T_) \\<turnstile> e_ :: ?T' \\<Longrightarrow> T'_ = ?T'\n  P,E_ \\<turnstile> {V_:T_; e_} :: T'\n\ngoal (1 subgoal):\n 1. T'_ = T'", "by (clarsimp simp del:fun_upd_apply)"], ["proof (state)\nthis:\n  T'_ = T'\n\ngoal (9 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 5. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 7. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 8. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 9. \\<And>E e T es Ts Ts'.\n       \\<lbrakk>P,E \\<turnstile> e :: T;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> es [::] Ts;\n        \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n        P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 5. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 7. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 8. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 9. \\<And>E e T es Ts Ts'.\n       \\<lbrakk>P,E \\<turnstile> e :: T;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> es [::] Ts;\n        \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n        P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "case (WTSeq E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2)"], ["proof (state)\nthis:\n  P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1\n  P,E \\<turnstile> e\\<^sub>1 :: ?T' \\<Longrightarrow> T\\<^sub>1 = ?T'\n  P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2\n  P,E \\<turnstile> e\\<^sub>2 :: ?T' \\<Longrightarrow> T\\<^sub>2 = ?T'\n  P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\n\ngoal (9 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 5. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 7. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 8. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 9. \\<And>E e T es Ts Ts'.\n       \\<lbrakk>P,E \\<turnstile> e :: T;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> es [::] Ts;\n        \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n        P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "have IH:\"\\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T\\<^sub>2 = T'\"\n    and wt:\"P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T'.\n        P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n        T\\<^sub>2 = T') &&&\n    P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'", "by fact+"], ["proof (state)\nthis:\n  P,E \\<turnstile> e\\<^sub>2 :: ?T' \\<Longrightarrow> T\\<^sub>2 = ?T'\n  P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\n\ngoal (9 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 5. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 7. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 8. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 9. \\<And>E e T es Ts Ts'.\n       \\<lbrakk>P,E \\<turnstile> e :: T;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> es [::] Ts;\n        \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n        P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "from wt"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'", "have wt':\"P,E \\<turnstile> e\\<^sub>2 :: T'\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> e\\<^sub>2 :: T'", "by auto"], ["proof (state)\nthis:\n  P,E \\<turnstile> e\\<^sub>2 :: T'\n\ngoal (9 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e\\<^sub>1 T\\<^sub>1 e\\<^sub>2 T\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e\\<^sub>1 :: T\\<^sub>1;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow>\n           T\\<^sub>1 = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T\\<^sub>2;\n        \\<And>T'.\n           P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow>\n           T\\<^sub>2 = T';\n        P,E \\<turnstile> e\\<^sub>1;; e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>2 = T'\n 5. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 6. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 7. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 8. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 9. \\<And>E e T es Ts Ts'.\n       \\<lbrakk>P,E \\<turnstile> e :: T;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> es [::] Ts;\n        \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n        P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "from IH[OF wt']"], ["proof (chain)\npicking this:\n  T\\<^sub>2 = T'", "show ?case"], ["proof (prove)\nusing this:\n  T\\<^sub>2 = T'\n\ngoal (1 subgoal):\n 1. T\\<^sub>2 = T'", "."], ["proof (state)\nthis:\n  T\\<^sub>2 = T'\n\ngoal (8 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 6. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 7. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 8. \\<And>E e T es Ts Ts'.\n       \\<lbrakk>P,E \\<turnstile> e :: T;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> es [::] Ts;\n        \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n        P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 6. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 7. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 8. \\<And>E e T es Ts Ts'.\n       \\<lbrakk>P,E \\<turnstile> e :: T;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> es [::] Ts;\n        \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n        P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "case (WTCond E e e\\<^sub>1 T e\\<^sub>2)"], ["proof (state)\nthis:\n  P,E \\<turnstile> e :: Boolean\n  P,E \\<turnstile> e :: ?T' \\<Longrightarrow> Boolean = ?T'\n  P,E \\<turnstile> e\\<^sub>1 :: T\n  P,E \\<turnstile> e\\<^sub>1 :: ?T' \\<Longrightarrow> T = ?T'\n  P,E \\<turnstile> e\\<^sub>2 :: T\n  P,E \\<turnstile> e\\<^sub>2 :: ?T' \\<Longrightarrow> T = ?T'\n  P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\n\ngoal (8 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 6. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 7. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 8. \\<And>E e T es Ts Ts'.\n       \\<lbrakk>P,E \\<turnstile> e :: T;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> es [::] Ts;\n        \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n        P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "have IH:\"\\<And>S. P,E \\<turnstile> e\\<^sub>1 :: S \\<Longrightarrow> T = S\"\n    and wt:\"P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S. P,E \\<turnstile> e\\<^sub>1 :: S \\<Longrightarrow> T = S) &&&\n    P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'", "by fact+"], ["proof (state)\nthis:\n  P,E \\<turnstile> e\\<^sub>1 :: ?S \\<Longrightarrow> T = ?S\n  P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\n\ngoal (8 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 6. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 7. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 8. \\<And>E e T es Ts Ts'.\n       \\<lbrakk>P,E \\<turnstile> e :: T;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> es [::] Ts;\n        \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n        P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "from wt"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'", "have \"P,E \\<turnstile> e\\<^sub>1 :: T'\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> e\\<^sub>1 :: T'", "by auto"], ["proof (state)\nthis:\n  P,E \\<turnstile> e\\<^sub>1 :: T'\n\ngoal (8 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e e\\<^sub>1 T e\\<^sub>2 T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> e\\<^sub>1 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>1 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> e\\<^sub>2 :: T;\n        \\<And>T'. P,E \\<turnstile> e\\<^sub>2 :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> if (e) e\\<^sub>1 else e\\<^sub>2 :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 5. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 6. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 7. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 8. \\<And>E e T es Ts Ts'.\n       \\<lbrakk>P,E \\<turnstile> e :: T;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> es [::] Ts;\n        \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n        P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  T = T'", "show ?case"], ["proof (prove)\nusing this:\n  T = T'\n\ngoal (1 subgoal):\n 1. T = T'", "."], ["proof (state)\nthis:\n  T = T'\n\ngoal (7 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 5. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 6. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 7. \\<And>E e T es Ts Ts'.\n       \\<lbrakk>P,E \\<turnstile> e :: T;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> es [::] Ts;\n        \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n        P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 5. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 6. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 7. \\<And>E e T es Ts Ts'.\n       \\<lbrakk>P,E \\<turnstile> e :: T;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> es [::] Ts;\n        \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n        P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "case (WTCons E e T es Ts)"], ["proof (state)\nthis:\n  P,E \\<turnstile> e :: T\n  P,E \\<turnstile> e :: ?T' \\<Longrightarrow> T = ?T'\n  P,E \\<turnstile> es [::] Ts\n  P,E \\<turnstile> es [::] ?Ts' \\<Longrightarrow> Ts = ?Ts'\n  P,E \\<turnstile> e # es [::] Ts'\n\ngoal (7 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 5. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 6. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 7. \\<And>E e T es Ts Ts'.\n       \\<lbrakk>P,E \\<turnstile> e :: T;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> es [::] Ts;\n        \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n        P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "have IHe:\"\\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T'\"\n    and IHes:\"\\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts'\"\n    and wt:\"P,E \\<turnstile> e # es [::] Ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T') &&&\n    (\\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts') &&&\n    P,E \\<turnstile> e # es [::] Ts'", "by fact+"], ["proof (state)\nthis:\n  P,E \\<turnstile> e :: ?T' \\<Longrightarrow> T = ?T'\n  P,E \\<turnstile> es [::] ?Ts' \\<Longrightarrow> Ts = ?Ts'\n  P,E \\<turnstile> e # es [::] Ts'\n\ngoal (7 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 5. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 6. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'\n 7. \\<And>E e T es Ts Ts'.\n       \\<lbrakk>P,E \\<turnstile> e :: T;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> es [::] Ts;\n        \\<And>Ts'. P,E \\<turnstile> es [::] Ts' \\<Longrightarrow> Ts = Ts';\n        P,E \\<turnstile> e # es [::] Ts'\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "from wt"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> e # es [::] Ts'", "show ?case"], ["proof (prove)\nusing this:\n  P,E \\<turnstile> e # es [::] Ts'\n\ngoal (1 subgoal):\n 1. T # Ts = Ts'", "proof (cases Ts')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>P,E \\<turnstile> e # es [::] Ts'; Ts' = []\\<rbrakk>\n    \\<Longrightarrow> T # Ts = Ts'\n 2. \\<And>a list.\n       \\<lbrakk>P,E \\<turnstile> e # es [::] Ts'; Ts' = a # list\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "case Nil"], ["proof (state)\nthis:\n  Ts' = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P,E \\<turnstile> e # es [::] Ts'; Ts' = []\\<rbrakk>\n    \\<Longrightarrow> T # Ts = Ts'\n 2. \\<And>a list.\n       \\<lbrakk>P,E \\<turnstile> e # es [::] Ts'; Ts' = a # list\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "with wt"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> e # es [::] Ts'\n  Ts' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  P,E \\<turnstile> e # es [::] Ts'\n  Ts' = []\n\ngoal (1 subgoal):\n 1. T # Ts = Ts'", "by simp"], ["proof (state)\nthis:\n  T # Ts = Ts'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>P,E \\<turnstile> e # es [::] Ts'; Ts' = a # list\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>P,E \\<turnstile> e # es [::] Ts'; Ts' = a # list\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "case (Cons T'' Ts'')"], ["proof (state)\nthis:\n  Ts' = T'' # Ts''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>P,E \\<turnstile> e # es [::] Ts'; Ts' = a # list\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "with wt"], ["proof (chain)\npicking this:\n  P,E \\<turnstile> e # es [::] Ts'\n  Ts' = T'' # Ts''", "have wte':\"P,E \\<turnstile> e :: T''\" and wtes':\"P,E \\<turnstile> es [::] Ts''\""], ["proof (prove)\nusing this:\n  P,E \\<turnstile> e # es [::] Ts'\n  Ts' = T'' # Ts''\n\ngoal (1 subgoal):\n 1. P,E \\<turnstile> e :: T'' &&& P,E \\<turnstile> es [::] Ts''", "by auto"], ["proof (state)\nthis:\n  P,E \\<turnstile> e :: T''\n  P,E \\<turnstile> es [::] Ts''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>P,E \\<turnstile> e # es [::] Ts'; Ts' = a # list\\<rbrakk>\n       \\<Longrightarrow> T # Ts = Ts'", "from IHe[OF wte'] IHes[OF wtes'] Cons"], ["proof (chain)\npicking this:\n  T = T''\n  Ts = Ts''\n  Ts' = T'' # Ts''", "show ?thesis"], ["proof (prove)\nusing this:\n  T = T''\n  Ts = Ts''\n  Ts' = T'' # Ts''\n\ngoal (1 subgoal):\n 1. T # Ts = Ts'", "by simp"], ["proof (state)\nthis:\n  T # Ts = Ts'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T # Ts = Ts'\n\ngoal (6 subgoals):\n 1. \\<And>C E T'.\n       \\<lbrakk>is_class P C; P,E \\<turnstile> new C :: T'\\<rbrakk>\n       \\<Longrightarrow> Class C = T'\n 2. \\<And>v T E T'.\n       \\<lbrakk>typeof v = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Val v :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 3. \\<And>E V T T'.\n       \\<lbrakk>E V = \\<lfloor>T\\<rfloor>;\n        P,E \\<turnstile> Var V :: T'\\<rbrakk>\n       \\<Longrightarrow> T = T'\n 4. \\<And>E e c T T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Boolean;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Boolean = T';\n        P,E \\<turnstile> c :: T;\n        \\<And>T'. P,E \\<turnstile> c :: T' \\<Longrightarrow> T = T';\n        P,E \\<turnstile> while (e) c :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 5. \\<And>E e C T'.\n       \\<lbrakk>P,E \\<turnstile> e :: Class C;\n        \\<And>T'. P,E \\<turnstile> e :: T' \\<Longrightarrow> Class C = T';\n        P,E \\<turnstile> throw e :: T'\\<rbrakk>\n       \\<Longrightarrow> Void = T'\n 6. \\<And>E Ts'. P,E \\<turnstile> [] [::] Ts' \\<Longrightarrow> [] = Ts'", "qed clarsimp+"], ["", "end"]]}