{"file_name": "/home/qj213/afp-2021-10-22/thys/LambdaAuth/Syntax.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LambdaAuth", "problem_names": ["lemma no_tvars_in_term[simp]: \"atom (x :: tvar) \\<sharp> (t :: term)\"", "lemma no_vars_in_ty[simp]: \"atom (x :: var) \\<sharp> (\\<tau> :: ty)\"", "lemma value_inv[simp]:\n  \"\\<not> value (Let e\\<^sub>1 x e\\<^sub>2)\"\n  \"\\<not> value (App v v')\"\n  \"\\<not> value (Case v v\\<^sub>1 v\\<^sub>2)\"\n  \"\\<not> value (Prj1 v)\"\n  \"\\<not> value (Prj2 v)\"\n  \"\\<not> value (Unroll v)\"\n  \"\\<not> value (Auth v)\"\n  \"\\<not> value (Unauth v)\""], "translations": [["", "lemma no_tvars_in_term[simp]: \"atom (x :: tvar) \\<sharp> (t :: term)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<sharp> t", "by (induct t rule: term.induct) auto"], ["", "lemma no_vars_in_ty[simp]: \"atom (x :: var) \\<sharp> (\\<tau> :: ty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<sharp> \\<tau>", "by (induct \\<tau> rule: ty.induct) auto"], ["", "inductive \"value\" :: \"term \\<Rightarrow> bool\" where\n  \"value Unit\" |\n  \"value (Var _)\" |\n  \"value (Lam _ _)\" |\n  \"value (Rec _ _)\" |\n  \"value v \\<Longrightarrow> value (Inj1 v)\" |\n  \"value v \\<Longrightarrow> value (Inj2 v)\" |\n  \"\\<lbrakk> value v\\<^sub>1; value v\\<^sub>2 \\<rbrakk> \\<Longrightarrow> value (Pair v\\<^sub>1 v\\<^sub>2)\" |\n  \"value v \\<Longrightarrow> value (Roll v)\" |\n  \"value (Hash _)\" |\n  \"value v \\<Longrightarrow> value (Hashed _ v)\""], ["", "declare value.intros[simp]"], ["", "declare value.intros[intro]"], ["", "equivariance \"value\""], ["", "lemma value_inv[simp]:\n  \"\\<not> value (Let e\\<^sub>1 x e\\<^sub>2)\"\n  \"\\<not> value (App v v')\"\n  \"\\<not> value (Case v v\\<^sub>1 v\\<^sub>2)\"\n  \"\\<not> value (Prj1 v)\"\n  \"\\<not> value (Prj2 v)\"\n  \"\\<not> value (Unroll v)\"\n  \"\\<not> value (Auth v)\"\n  \"\\<not> value (Unauth v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<not> value (Syntax.Let e\\<^sub>1 x e\\<^sub>2) &&&\n      \\<not> value (App v v')) &&&\n     \\<not> value (Case v v\\<^sub>1 v\\<^sub>2) &&&\n     \\<not> value (Prj1 v)) &&&\n    (\\<not> value (Prj2 v) &&& \\<not> value (Unroll v)) &&&\n    \\<not> value (Auth v) &&& \\<not> value (Unauth v)", "using value.cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>value ?a; ?a = Unit \\<Longrightarrow> ?P;\n   \\<And>uu_. ?a = Var uu_ \\<Longrightarrow> ?P;\n   \\<And>uv_ uw_. ?a = Lam uv_ uw_ \\<Longrightarrow> ?P;\n   \\<And>ux_ uy_. ?a = Rec ux_ uy_ \\<Longrightarrow> ?P;\n   \\<And>v. \\<lbrakk>?a = Inj1 v; value v\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>v. \\<lbrakk>?a = Inj2 v; value v\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>v\\<^sub>1 v\\<^sub>2.\n      \\<lbrakk>?a = Syntax.Pair v\\<^sub>1 v\\<^sub>2; value v\\<^sub>1;\n       value v\\<^sub>2\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v. \\<lbrakk>?a = Roll v; value v\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>uz_. ?a = Hash uz_ \\<Longrightarrow> ?P;\n   \\<And>v va_.\n      \\<lbrakk>?a = Hashed va_ v; value v\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. ((\\<not> value (Syntax.Let e\\<^sub>1 x e\\<^sub>2) &&&\n      \\<not> value (App v v')) &&&\n     \\<not> value (Case v v\\<^sub>1 v\\<^sub>2) &&&\n     \\<not> value (Prj1 v)) &&&\n    (\\<not> value (Prj2 v) &&& \\<not> value (Unroll v)) &&&\n    \\<not> value (Auth v) &&& \\<not> value (Unauth v)", "by fastforce+"], ["", "inductive_cases value_Inj1_inv[elim]: \"value (Inj1 e)\""], ["", "inductive_cases value_Inj2_inv[elim]: \"value (Inj2 e)\""], ["", "inductive_cases value_Pair_inv[elim]: \"value (Pair e\\<^sub>1 e\\<^sub>2)\""], ["", "inductive_cases value_Roll_inv[elim]: \"value (Roll e)\""], ["", "inductive_cases value_Hashed_inv[elim]: \"value (Hashed h e)\""], ["", "abbreviation closed :: \"term \\<Rightarrow> bool\" where\n  \"closed t \\<equiv> (\\<forall>x::var. atom x \\<sharp> t)\""], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}