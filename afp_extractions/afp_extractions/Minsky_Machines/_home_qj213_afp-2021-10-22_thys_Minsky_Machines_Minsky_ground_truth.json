{"file_name": "/home/qj213/afp-2021-10-22/thys/Minsky_Machines/Minsky.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Minsky_Machines", "problem_names": ["lemma deterministicD:\n  \"deterministic R \\<Longrightarrow> (x, y) \\<in> R \\<Longrightarrow> (x, z) \\<in> R \\<Longrightarrow> y = z\"", "lemma deterministic_empty [simp]:\n  \"deterministic {}\"", "lemma deterministic_singleton [simp]:\n  \"deterministic {p}\"", "lemma deterministic_imp_weak_diamond [intro]:\n  \"deterministic R \\<Longrightarrow> w\\<diamond> R\"", "lemmas deterministic_imp_CR = deterministic_imp_weak_diamond[THEN weak_diamond_imp_CR]", "lemma deterministic_union:\n  \"fst ` S \\<inter> fst ` R = {} \\<Longrightarrow> deterministic S \\<Longrightarrow> deterministic R \\<Longrightarrow> deterministic (S \\<union> R)\"", "lemma deterministic_map:\n  \"inj_on f (fst ` R) \\<Longrightarrow> deterministic R \\<Longrightarrow> deterministic (map_prod f g ` R)\"", "lemma step_mono:\n  \"M \\<subseteq> M' \\<Longrightarrow> step M \\<subseteq> step M'\"", "lemmas steps_mono = rtrancl_mono[OF step_mono]", "lemma deterministic_stepI [intro]:\n  assumes \"deterministic M\" shows \"deterministic (step M)\"", "lemma NF_stepI [intro]:\n  \"s \\<notin> fst ` M \\<Longrightarrow> (s, vs) \\<in> NF (step M)\"", "lemmas deterministic_minsky_UN =\n  join_NF_imp_eq[OF CR_divergence_imp_join[OF deterministic_imp_CR[OF deterministic_stepI]] NF_stepI NF_stepI]", "lemma map_minsky_id:\n  \"map_minsky id id M = M\"", "lemma map_minsky_comp:\n  \"map_minsky f g (map_minsky f' g' M) = map_minsky (f \\<circ> f') (g \\<circ> g') M\"", "lemma map_step:\n  assumes \"inj g\" \"vs = vs' \\<circ> g\" \"((s, vs), (t, ws)) \\<in> step M\"\n  shows \"((f s, vs'), (f t, \\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x)) \\<in> step (map_minsky f g M)\"", "lemma map_steps:\n  assumes \"inj g\" \"vs = ws \\<circ> g\" \"((s, vs), (t, vs')) \\<in> (step M)\\<^sup>*\"\n  shows \"((f s, ws), (f t, \\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x)) \\<in> (step (map_minsky f g M))\\<^sup>*\"", "lemmas mk_minsky_def = mk_minsky_wit_def", "lemma mk_minsky_mono:\n  shows \"mk_minsky P \\<Longrightarrow> (\\<And>vs vs'. P vs vs' \\<Longrightarrow> Q vs vs') \\<Longrightarrow> mk_minsky Q\"", "lemma mk_minsky_sound:\n  assumes \"mk_minsky_wit M P\" \"((Suc 0, vs), (0, vs')) \\<in> (step M)\\<^sup>*\"\n  shows \"P vs vs'\"", "lemma mk_minsky_inc:\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then Suc (vs v) else vs x))\"", "lemma mk_minsky_dec:\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then vs v - 1 else vs x))\"", "lemma mk_minsky_seq_map:\n  assumes \"mk_minsky P\" \"mk_minsky Q\" \"inj g\"\n    \"\\<And>vs vs' vs''. P vs vs' \\<Longrightarrow> Q vs' vs'' \\<Longrightarrow> R vs vs''\"\n  shows \"mk_minsky (\\<lambda>vs vs'. R (vs \\<circ> g) (vs' \\<circ> g) \\<and> (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x))\"", "lemma mk_minsky_seq:\n  assumes \"mk_minsky P\" \"mk_minsky Q\"\n    \"\\<And>vs vs' vs''. P vs vs' \\<Longrightarrow> Q vs' vs'' \\<Longrightarrow> R vs vs''\"\n  shows \"mk_minsky R\"", "lemma mk_minsky_seq':\n  assumes \"mk_minsky P\" \"mk_minsky Q\"\n  shows \"mk_minsky (\\<lambda>vs vs''. (\\<exists>vs'. P vs vs' \\<and> Q vs' vs''))\"", "lemma mk_minsky_nop:\n  \"mk_minsky (\\<lambda>vs vs'. vs = vs')\"", "lemma mk_minsky_map:\n  assumes \"mk_minsky P\" \"inj f\"\n  shows \"mk_minsky (\\<lambda>vs vs'. P (vs \\<circ> f) (vs' \\<circ> f) \\<and> (\\<forall>x. x \\<notin> range f \\<longrightarrow> vs x = vs' x))\"", "lemma inj_shift [simp]:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"inj (\\<lambda>x. if x = 0 then a else x + b)\"", "lemma mk_minsky_loop:\n  assumes \"mk_minsky P\"\n    \"\\<And>vs vs'. P vs vs' \\<Longrightarrow> vs' v = vs v\"\n    \"\\<And>vs. vs v = 0 \\<Longrightarrow> Q vs vs\"\n    \"\\<And>n vs vs' vs''. vs v = Suc n \\<Longrightarrow> P (\\<lambda>x. if x = v then n else vs x) vs' \\<Longrightarrow> Q vs' vs'' \\<Longrightarrow> Q vs vs''\"\n  shows \"mk_minsky Q\"", "lemma mk_minsky_zero:\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then 0 else vs x))\"", "lemma mk_minsky_add1:\n  assumes \"v \\<noteq> w\"\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then 0 else if x = w then vs v + vs w else vs x))\"", "lemma mk_minsky_add2:\n  assumes \"u \\<noteq> v\" \"u \\<noteq> w\" \"v \\<noteq> w\"\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' =\n    (\\<lambda>x. if x = u then 0 else if x = v then vs u + vs v else if x = w then vs u + vs w else vs x))\"", "lemma mk_minsky_copy1:\n  assumes \"v \\<noteq> w\"\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then 0 else if x = w then vs v else vs x))\"", "lemma mk_minsky_copy2:\n  assumes \"u \\<noteq> v\" \"u \\<noteq> w\" \"v \\<noteq> w\"\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' =\n    (\\<lambda>x. if x = u then 0 else if x = v then vs u else if x = w then vs u else vs x))\"", "lemma mk_minsky_copy:\n  assumes \"u \\<noteq> v\" \"u \\<noteq> w\" \"v \\<noteq> w\"\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then vs u else if x = w then 0 else vs x))\"", "lemma mk_minsky_apply3:\n  assumes \"mk_minsky3 f\" \"t < k\" \"u < k\" \"v < k\" \"w < k\"\n  shows \"mk_minsky (\\<lambda>vs vs'. \\<forall>x < k. vs' x = (if x = t then f (vs u) (vs v) (vs w) else vs x))\"", "lemma mk_minsky_comp3_3:\n  assumes \"mk_minsky3 f\" \"mk_minsky3 g\" \"mk_minsky3 h\" \"mk_minsky3 k\"\n  shows \"mk_minsky3 (\\<lambda>x y z. f (g x y z) (h x y z) (k x y z))\"", "lemma mk_minsky_prim_rec:\n  assumes \"mk_minsky1 g\" \"mk_minsky3 h\"\n  shows \"mk_minsky2 (PrimRecOp g h)\"", "lemma mk_minsky_PrimRec:\n  \"f \\<in> PrimRec1 \\<Longrightarrow> mk_minsky1 f\"\n  \"g \\<in> PrimRec2 \\<Longrightarrow> mk_minsky2 g\"\n  \"h \\<in> PrimRec3 \\<Longrightarrow> mk_minsky3 h\"", "lemma ce_set_pair_by_minsky:\n  assumes \"A \\<in> ce_sets\" \"B \\<in> ce_sets\"\n  obtains M :: \"(nat, nat) minsky\" where\n    \"finite M\" \"deterministic M\" \"0 \\<notin> fst ` M\" \"Suc 0 \\<notin> fst ` M\"\n    \"\\<And>x vs. vs 0 = x \\<Longrightarrow> vs 1 = 0 \\<Longrightarrow> x \\<in> A \\<union> B \\<Longrightarrow>\n     \\<exists>vs'. ((2, vs), (0, vs')) \\<in> (step M)\\<^sup>* \\<or> ((2, vs), (Suc 0, vs')) \\<in> (step M)\\<^sup>*\"\n    \"\\<And>x vs vs'. vs 0 = x \\<Longrightarrow> vs 1 = 0 \\<Longrightarrow> ((2, vs), (0, vs')) \\<in> (step M)\\<^sup>* \\<Longrightarrow> x \\<in> A\"\n    \"\\<And>x vs vs'. vs 0 = x \\<Longrightarrow> vs 1 = 0 \\<Longrightarrow> ((2, vs), (Suc 0, vs')) \\<in> (step M)\\<^sup>* \\<Longrightarrow> x \\<in> B\"", "lemma ce_set_by_minsky:\n  assumes \"A \\<in> ce_sets\"\n  obtains M :: \"(nat, nat) minsky\" where\n    \"finite M\" \"deterministic M\" \"0 \\<notin> fst ` M\"\n    \"\\<And>x vs. vs 0 = x \\<Longrightarrow> vs 1 = 0 \\<Longrightarrow> x \\<in> A \\<Longrightarrow> \\<exists>vs'. ((Suc 0, vs), (0, vs')) \\<in> (step M)\\<^sup>*\"\n    \"\\<And>x vs vs'. vs 0 = x \\<Longrightarrow> vs 1 = 0 \\<Longrightarrow> ((Suc 0, vs), (0, vs')) \\<in> (step M)\\<^sup>* \\<Longrightarrow> x \\<in> A\"", "lemma encode_Op_inv [simp]:\n  \"decode_Op (encode_Op x) = x\"", "lemma encode_minsky_inv [simp]:\n  \"decode_minsky (encode_minsky M) = M\"", "lemma minsky_reaching_0_not_computable:\n  \"\\<not> computable minsky_reaching_0\"", "lemma rec_inseparable_0not1_1not0:\n  \"rec_inseparable {p. 0 \\<in> nat_to_ce_set p \\<and> 1 \\<notin> nat_to_ce_set p} {p. 0 \\<notin> nat_to_ce_set p \\<and> 1 \\<in> nat_to_ce_set p}\"", "lemma ce_sets_containing_n_ce:\n  \"{p. n \\<in> nat_to_ce_set p} \\<in> ce_sets\"", "lemma rec_inseparable_fixed_minsky_reaching_0_1:\n  obtains U :: \"(nat, nat) minsky\" where\n    \"finite U\" \"deterministic U\" \"0 \\<notin> fst ` U\" \"1 \\<notin> fst ` U\"\n    \"rec_inseparable {x |x vs'. ((2, (\\<lambda>n. if n = 0 then x else 0)), (0, vs')) \\<in> (step U)\\<^sup>*}\n      {x |x vs'. ((2, (\\<lambda>n. if n = 0 then x else 0)), (1, vs')) \\<in> (step U)\\<^sup>*}\"", "lemma rec_inseparable_minsky_reaching_0_1:\n  \"rec_inseparable (minsky_reaching_s 0) (minsky_reaching_s 1)\"", "lemma minsky_reaching_s_imp_minsky_reaching_s_not_t:\n  assumes \"s \\<in> {0,1}\" \"t \\<in> {0,1}\" \"s \\<noteq> t\"\n  shows \"minsky_reaching_s s \\<subseteq> minsky_reaching_s_not_t s t\"", "lemma rec_inseparable_minsky_reaching_0_not_1_1_not_0:\n  \"rec_inseparable (minsky_reaching_s_not_t 0 1) (minsky_reaching_s_not_t 1 0)\""], "translations": [["", "lemma deterministicD:\n  \"deterministic R \\<Longrightarrow> (x, y) \\<in> R \\<Longrightarrow> (x, z) \\<in> R \\<Longrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>deterministic R; (x, y) \\<in> R; (x, z) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> y = z", "by (auto simp: deterministic_def)"], ["", "lemma deterministic_empty [simp]:\n  \"deterministic {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic {}", "by (auto simp: deterministic_def)"], ["", "lemma deterministic_singleton [simp]:\n  \"deterministic {p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic {p}", "by (auto simp: deterministic_def)"], ["", "lemma deterministic_imp_weak_diamond [intro]:\n  \"deterministic R \\<Longrightarrow> w\\<diamond> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic R \\<Longrightarrow> w\\<diamond> R", "by (auto simp: weak_diamond_def deterministic_def)"], ["", "lemmas deterministic_imp_CR = deterministic_imp_weak_diamond[THEN weak_diamond_imp_CR]"], ["", "lemma deterministic_union:\n  \"fst ` S \\<inter> fst ` R = {} \\<Longrightarrow> deterministic S \\<Longrightarrow> deterministic R \\<Longrightarrow> deterministic (S \\<union> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst ` S \\<inter> fst ` R = {}; deterministic S;\n     deterministic R\\<rbrakk>\n    \\<Longrightarrow> deterministic (S \\<union> R)", "by (fastforce simp add: deterministic_def disjoint_iff_not_equal)"], ["", "lemma deterministic_map:\n  \"inj_on f (fst ` R) \\<Longrightarrow> deterministic R \\<Longrightarrow> deterministic (map_prod f g ` R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f (fst ` R); deterministic R\\<rbrakk>\n    \\<Longrightarrow> deterministic (map_prod f g ` R)", "by (auto simp add: deterministic_def dest!: inj_onD; force)"], ["", "subsection \\<open>Minsky machine definition\\<close>"], ["", "text \\<open>A Minsky operation either decrements a register (testing for zero, with two possible\nsuccessor states), or increments a register (with one successor state). A Minsky machine is a\nset of pairs of states and operations.\\<close>"], ["", "datatype ('s, 'v) Op = Dec (op_var: 'v) 's 's | Inc (op_var: 'v) 's"], ["", "type_synonym ('s, 'v) minsky = \"('s \\<times> ('s, 'v) Op) set\""], ["", "text \\<open>Semantics: A Minsky machine operates on pairs consisting of a state and an assignment of\nthe registers; in each step, either a register is incremented, or a register is decremented,\nprovided it is non-zero. We write $\\alpha$ for assignments; $\\alpha[v]$ for the value of the\nregister $v$ in $\\alpha$ and $\\alpha[v := n]$ for the update of $v$ to $n$. Thus, the semantics\nis as follows:\n\\begin{enumerate}\n\\item if $(s, Inc\\ v\\ s') \\in M$ then $(s, \\alpha) \\to (s', \\alpha[v := \\alpha[v] + 1]$);\n\\item if $(s, Dec\\ v\\ s_n\\ s_z) \\in M$ and $\\alpha[v] > 0$ then $(s, \\alpha) \\to (s_n, \\alpha[v := \\alpha[v] - 1]$); and\n\\item if $(s, Dec\\ v\\ s_n\\ s_z) \\in M$ and $\\alpha[v] = 0$ then $(s, \\alpha) \\to (s_z, \\alpha)$.\n\\end{enumerate}\nA state is finite if there is no operation associated with it.\\<close>"], ["", "inductive_set step :: \"('s, 'v) minsky \\<Rightarrow> ('s \\<times> ('v \\<Rightarrow> nat)) rel\" for M :: \"('s, 'v) minsky\" where\n  inc: \"(s, Inc v s') \\<in> M \\<Longrightarrow> ((s, vs), (s', \\<lambda>x. if x = v then Suc (vs v) else vs x)) \\<in> step M\"\n| decn: \"(s, Dec v sn sz) \\<in> M \\<Longrightarrow> vs v = Suc n \\<Longrightarrow> ((s, vs), (sn, \\<lambda>x. if x = v then n else vs x)) \\<in> step M\"\n| decz: \"(s, Dec v sn sz) \\<in> M \\<Longrightarrow> vs v = 0 \\<Longrightarrow> ((s, vs), (sz, vs)) \\<in> step M\""], ["", "lemma step_mono:\n  \"M \\<subseteq> M' \\<Longrightarrow> step M \\<subseteq> step M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<subseteq> M' \\<Longrightarrow> step M \\<subseteq> step M'", "by (auto elim: step.cases intro: step.intros)"], ["", "lemmas steps_mono = rtrancl_mono[OF step_mono]"], ["", "text \\<open>A Minsky machine has deterministic steps if its defining relation between states and\noperations is deterministic.\\<close>"], ["", "lemma deterministic_stepI [intro]:\n  assumes \"deterministic M\" shows \"deterministic (step M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic (step M)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deterministic (step M)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. deterministic (step M)", "fix s vs s1 vs1 s2 vs2"], ["proof (state)\ngoal (1 subgoal):\n 1. deterministic (step M)", "assume s: \"((s, vs), (s1, vs1)) \\<in> step M\" \"((s, vs), (s2, vs2)) \\<in> step M\""], ["proof (state)\nthis:\n  ((s, vs), s1, vs1) \\<in> step M\n  ((s, vs), s2, vs2) \\<in> step M\n\ngoal (1 subgoal):\n 1. deterministic (step M)", "have \"(s1, vs1) = (s2, vs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s1, vs1) = (s2, vs2)", "using deterministicD[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?y) \\<in> M; (?x, ?z) \\<in> M\\<rbrakk>\n  \\<Longrightarrow> ?y = ?z\n\ngoal (1 subgoal):\n 1. (s1, vs1) = (s2, vs2)", "by (cases rule: step.cases[OF s(1)]; cases rule: step.cases[OF s(2)]) fastforce+"], ["proof (state)\nthis:\n  (s1, vs1) = (s2, vs2)\n\ngoal (1 subgoal):\n 1. deterministic (step M)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>((?s2, ?vs2), ?s1.2, ?vs1.2) \\<in> step M;\n   ((?s2, ?vs2), ?s2.2, ?vs2.2) \\<in> step M\\<rbrakk>\n  \\<Longrightarrow> (?s1.2, ?vs1.2) = (?s2.2, ?vs2.2)\n\ngoal (1 subgoal):\n 1. deterministic (step M)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>((?s2, ?vs2), ?s1.2, ?vs1.2) \\<in> step M;\n   ((?s2, ?vs2), ?s2.2, ?vs2.2) \\<in> step M\\<rbrakk>\n  \\<Longrightarrow> (?s1.2, ?vs1.2) = (?s2.2, ?vs2.2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>((?s2, ?vs2), ?s1.2, ?vs1.2) \\<in> step M;\n   ((?s2, ?vs2), ?s2.2, ?vs2.2) \\<in> step M\\<rbrakk>\n  \\<Longrightarrow> (?s1.2, ?vs1.2) = (?s2.2, ?vs2.2)\n\ngoal (1 subgoal):\n 1. deterministic (step M)", "by (auto simp: deterministic_def)"], ["proof (state)\nthis:\n  deterministic (step M)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A Minksy machine halts when it reaches a state with no associated operation.\\<close>"], ["", "lemma NF_stepI [intro]:\n  \"s \\<notin> fst ` M \\<Longrightarrow> (s, vs) \\<in> NF (step M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<notin> fst ` M \\<Longrightarrow> (s, vs) \\<in> NF (step M)", "by (auto intro!: no_step elim!: step.cases simp: rev_image_eqI)"], ["", "text \\<open>Deterministic Minsky machines enjoy unique normal forms.\\<close>"], ["", "lemmas deterministic_minsky_UN =\n  join_NF_imp_eq[OF CR_divergence_imp_join[OF deterministic_imp_CR[OF deterministic_stepI]] NF_stepI NF_stepI]"], ["", "text \\<open>We will rename states and variables.\\<close>"], ["", "definition map_minsky where\n  \"map_minsky f g M = map_prod f (map_Op f g) ` M\""], ["", "lemma map_minsky_id:\n  \"map_minsky id id M = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_minsky id id M = M", "by (simp add: map_minsky_def Op.map_id0 map_prod.id)"], ["", "lemma map_minsky_comp:\n  \"map_minsky f g (map_minsky f' g' M) = map_minsky (f \\<circ> f') (g \\<circ> g') M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_minsky f g (map_minsky f' g' M) =\n    map_minsky (f \\<circ> f') (g \\<circ> g') M", "unfolding map_minsky_def image_comp Op.map_comp map_prod.comp comp_def[of \"map_Op _ _\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_prod (f \\<circ> f') (map_Op (f \\<circ> f') (g \\<circ> g')) ` M =\n    map_prod (f \\<circ> f') (map_Op (f \\<circ> f') (g \\<circ> g')) ` M", ".."], ["", "text \\<open>When states and variables are renamed, computations carry over from the original machine,\nprovided that variables are renamed injectively.\\<close>"], ["", "lemma map_step:\n  assumes \"inj g\" \"vs = vs' \\<circ> g\" \"((s, vs), (t, ws)) \\<in> step M\"\n  shows \"((f s, vs'), (f t, \\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x)) \\<in> step (map_minsky f g M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f s, vs'), f t,\n     \\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x)\n    \\<in> step (map_minsky f g M)", "using assms(3)"], ["proof (prove)\nusing this:\n  ((s, vs), t, ws) \\<in> step M\n\ngoal (1 subgoal):\n 1. ((f s, vs'), f t,\n     \\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x)\n    \\<in> step (map_minsky f g M)", "proof (cases rule: step.cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then Suc (vs v) else vs x);\n        (s, Inc v t) \\<in> M\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 3. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "case (inc v)"], ["proof (state)\nthis:\n  ws = (\\<lambda>x. if x = v then Suc (vs v) else vs x)\n  (s, Inc v t) \\<in> M\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then Suc (vs v) else vs x);\n        (s, Inc v t) \\<in> M\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 3. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "note [simp] = inc(1)"], ["proof (state)\nthis:\n  ws = (\\<lambda>x. if x = v then Suc (vs v) else vs x)\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then Suc (vs v) else vs x);\n        (s, Inc v t) \\<in> M\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 3. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "let ?ws' = \"\\<lambda>w. if w = g v then Suc (vs' (g v)) else vs' w\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then Suc (vs v) else vs x);\n        (s, Inc v t) \\<in> M\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 3. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "have \"((f s, vs'), (f t, ?ws')) \\<in> step (map_minsky f g M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f s, vs'), f t,\n     \\<lambda>w. if w = g v then Suc (vs' (g v)) else vs' w)\n    \\<in> step (map_minsky f g M)", "using inc(2) step.inc[of \"f s\" \"g v\" \"f t\" \"map_minsky f g M\" vs']"], ["proof (prove)\nusing this:\n  (s, Inc v t) \\<in> M\n  (f s, Inc (g v) (f t)) \\<in> map_minsky f g M \\<Longrightarrow>\n  ((f s, vs'), f t, \\<lambda>x. if x = g v then Suc (vs' (g v)) else vs' x)\n  \\<in> step (map_minsky f g M)\n\ngoal (1 subgoal):\n 1. ((f s, vs'), f t,\n     \\<lambda>w. if w = g v then Suc (vs' (g v)) else vs' w)\n    \\<in> step (map_minsky f g M)", "by (force simp: map_minsky_def)"], ["proof (state)\nthis:\n  ((f s, vs'), f t, \\<lambda>w. if w = g v then Suc (vs' (g v)) else vs' w)\n  \\<in> step (map_minsky f g M)\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then Suc (vs v) else vs x);\n        (s, Inc v t) \\<in> M\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 3. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "moreover"], ["proof (state)\nthis:\n  ((f s, vs'), f t, \\<lambda>w. if w = g v then Suc (vs' (g v)) else vs' w)\n  \\<in> step (map_minsky f g M)\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then Suc (vs v) else vs x);\n        (s, Inc v t) \\<in> M\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 3. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "have \"(\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) = ?ws'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) =\n    (\\<lambda>w. if w = g v then Suc (vs' (g v)) else vs' w)", "using assms(1,2)"], ["proof (prove)\nusing this:\n  inj g\n  vs = vs' \\<circ> g\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) =\n    (\\<lambda>w. if w = g v then Suc (vs' (g v)) else vs' w)", "by (auto intro!: ext simp: injD image_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) =\n  (\\<lambda>w. if w = g v then Suc (vs' (g v)) else vs' w)\n\ngoal (3 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then Suc (vs v) else vs x);\n        (s, Inc v t) \\<in> M\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 3. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "ultimately"], ["proof (chain)\npicking this:\n  ((f s, vs'), f t, \\<lambda>w. if w = g v then Suc (vs' (g v)) else vs' w)\n  \\<in> step (map_minsky f g M)\n  (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) =\n  (\\<lambda>w. if w = g v then Suc (vs' (g v)) else vs' w)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((f s, vs'), f t, \\<lambda>w. if w = g v then Suc (vs' (g v)) else vs' w)\n  \\<in> step (map_minsky f g M)\n  (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) =\n  (\\<lambda>w. if w = g v then Suc (vs' (g v)) else vs' w)\n\ngoal (1 subgoal):\n 1. ((f s, vs'), f t,\n     \\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x)\n    \\<in> step (map_minsky f g M)", "by auto"], ["proof (state)\nthis:\n  ((f s, vs'), f t,\n   \\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x)\n  \\<in> step (map_minsky f g M)\n\ngoal (2 subgoals):\n 1. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "case (decn v sz n)"], ["proof (state)\nthis:\n  ws = (\\<lambda>x. if x = v then n else vs x)\n  (s, Dec v t sz) \\<in> M\n  vs v = Suc n\n\ngoal (2 subgoals):\n 1. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "note [simp] = decn(1)"], ["proof (state)\nthis:\n  ws = (\\<lambda>x. if x = v then n else vs x)\n\ngoal (2 subgoals):\n 1. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "let ?ws' = \"\\<lambda>x. if x = g v then n else vs' x\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "have \"((f s, vs'), (f t, ?ws')) \\<in> step (map_minsky f g M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f s, vs'), f t, \\<lambda>x. if x = g v then n else vs' x)\n    \\<in> step (map_minsky f g M)", "using assms(2) decn(2-) step.decn[of \"f s\" \"g v\" \"f t\" \"f sz\" \"map_minsky f g M\" vs' n]"], ["proof (prove)\nusing this:\n  vs = vs' \\<circ> g\n  (s, Dec v t sz) \\<in> M\n  vs v = Suc n\n  \\<lbrakk>(f s, Dec (g v) (f t) (f sz)) \\<in> map_minsky f g M;\n   vs' (g v) = Suc n\\<rbrakk>\n  \\<Longrightarrow> ((f s, vs'), f t,\n                     \\<lambda>x. if x = g v then n else vs' x)\n                    \\<in> step (map_minsky f g M)\n\ngoal (1 subgoal):\n 1. ((f s, vs'), f t, \\<lambda>x. if x = g v then n else vs' x)\n    \\<in> step (map_minsky f g M)", "by (force simp: map_minsky_def)"], ["proof (state)\nthis:\n  ((f s, vs'), f t, \\<lambda>x. if x = g v then n else vs' x)\n  \\<in> step (map_minsky f g M)\n\ngoal (2 subgoals):\n 1. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "moreover"], ["proof (state)\nthis:\n  ((f s, vs'), f t, \\<lambda>x. if x = g v then n else vs' x)\n  \\<in> step (map_minsky f g M)\n\ngoal (2 subgoals):\n 1. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "have \"(\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) = ?ws'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) =\n    (\\<lambda>x. if x = g v then n else vs' x)", "using assms(1,2)"], ["proof (prove)\nusing this:\n  inj g\n  vs = vs' \\<circ> g\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) =\n    (\\<lambda>x. if x = g v then n else vs' x)", "by (auto intro!: ext simp: injD image_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) =\n  (\\<lambda>x. if x = g v then n else vs' x)\n\ngoal (2 subgoals):\n 1. \\<And>v sz n.\n       \\<lbrakk>ws = (\\<lambda>x. if x = v then n else vs x);\n        (s, Dec v t sz) \\<in> M; vs v = Suc n\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)\n 2. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "ultimately"], ["proof (chain)\npicking this:\n  ((f s, vs'), f t, \\<lambda>x. if x = g v then n else vs' x)\n  \\<in> step (map_minsky f g M)\n  (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) =\n  (\\<lambda>x. if x = g v then n else vs' x)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((f s, vs'), f t, \\<lambda>x. if x = g v then n else vs' x)\n  \\<in> step (map_minsky f g M)\n  (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) =\n  (\\<lambda>x. if x = g v then n else vs' x)\n\ngoal (1 subgoal):\n 1. ((f s, vs'), f t,\n     \\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x)\n    \\<in> step (map_minsky f g M)", "by auto"], ["proof (state)\nthis:\n  ((f s, vs'), f t,\n   \\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x)\n  \\<in> step (map_minsky f g M)\n\ngoal (1 subgoal):\n 1. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "case (decz v sn)"], ["proof (state)\nthis:\n  ws = vs\n  (s, Dec v sn t) \\<in> M\n  vs v = 0\n\ngoal (1 subgoal):\n 1. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "note [simp] = decz(1)"], ["proof (state)\nthis:\n  ws = vs\n\ngoal (1 subgoal):\n 1. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "have \"((f s, vs'), (f t, vs')) \\<in> step (map_minsky f g M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f s, vs'), f t, vs') \\<in> step (map_minsky f g M)", "using assms(2) decz(2-) step.decz[of \"f s\" \"g v\" \"f sn\" \"f t\" \"map_minsky f g M\" vs']"], ["proof (prove)\nusing this:\n  vs = vs' \\<circ> g\n  (s, Dec v sn t) \\<in> M\n  vs v = 0\n  \\<lbrakk>(f s, Dec (g v) (f sn) (f t)) \\<in> map_minsky f g M;\n   vs' (g v) = 0\\<rbrakk>\n  \\<Longrightarrow> ((f s, vs'), f t, vs') \\<in> step (map_minsky f g M)\n\ngoal (1 subgoal):\n 1. ((f s, vs'), f t, vs') \\<in> step (map_minsky f g M)", "by (force simp: map_minsky_def)"], ["proof (state)\nthis:\n  ((f s, vs'), f t, vs') \\<in> step (map_minsky f g M)\n\ngoal (1 subgoal):\n 1. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "moreover"], ["proof (state)\nthis:\n  ((f s, vs'), f t, vs') \\<in> step (map_minsky f g M)\n\ngoal (1 subgoal):\n 1. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "have \"(\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) = vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) = vs'", "using assms(1,2)"], ["proof (prove)\nusing this:\n  inj g\n  vs = vs' \\<circ> g\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) = vs'", "by (auto intro!: ext simp: injD image_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) = vs'\n\ngoal (1 subgoal):\n 1. \\<And>v sn.\n       \\<lbrakk>ws = vs; (s, Dec v sn t) \\<in> M; vs v = 0\\<rbrakk>\n       \\<Longrightarrow> ((f s, vs'), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then ws (inv g x)\n                             else vs' x)\n                         \\<in> step (map_minsky f g M)", "ultimately"], ["proof (chain)\npicking this:\n  ((f s, vs'), f t, vs') \\<in> step (map_minsky f g M)\n  (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) = vs'", "show ?thesis"], ["proof (prove)\nusing this:\n  ((f s, vs'), f t, vs') \\<in> step (map_minsky f g M)\n  (\\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x) = vs'\n\ngoal (1 subgoal):\n 1. ((f s, vs'), f t,\n     \\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x)\n    \\<in> step (map_minsky f g M)", "by auto"], ["proof (state)\nthis:\n  ((f s, vs'), f t,\n   \\<lambda>x. if x \\<in> range g then ws (inv g x) else vs' x)\n  \\<in> step (map_minsky f g M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_steps:\n  assumes \"inj g\" \"vs = ws \\<circ> g\" \"((s, vs), (t, vs')) \\<in> (step M)\\<^sup>*\"\n  shows \"((f s, ws), (f t, \\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x)) \\<in> (step (map_minsky f g M))\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f s, ws), f t,\n     \\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x)\n    \\<in> (step (map_minsky f g M))\\<^sup>*", "using assms(3,2)"], ["proof (prove)\nusing this:\n  ((s, vs), t, vs') \\<in> (step M)\\<^sup>*\n  vs = ws \\<circ> g\n\ngoal (1 subgoal):\n 1. ((f s, ws), f t,\n     \\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x)\n    \\<in> (step (map_minsky f g M))\\<^sup>*", "proof (induct \"(s, vs)\" arbitrary: s vs ws rule: converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ws.\n       vs' = ws \\<circ> g \\<Longrightarrow>\n       ((f t, ws), f t,\n        \\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x)\n       \\<in> (step (map_minsky f g M))\\<^sup>*\n 2. \\<And>z s vs ws.\n       \\<lbrakk>((s, vs), z) \\<in> step M;\n        (z, t, vs') \\<in> (step M)\\<^sup>*;\n        \\<And>s vs ws.\n           \\<lbrakk>z = (s, vs); vs = ws \\<circ> g\\<rbrakk>\n           \\<Longrightarrow> ((f s, ws), f t,\n                              \\<lambda>x.\n                                 if x \\<in> range g then vs' (inv g x)\n                                 else ws x)\n                             \\<in> (step (map_minsky f g M))\\<^sup>*;\n        vs = ws \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> ((f s, ws), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then vs' (inv g x)\n                             else ws x)\n                         \\<in> (step (map_minsky f g M))\\<^sup>*", "case base"], ["proof (state)\nthis:\n  vs' = ws \\<circ> g\n\ngoal (2 subgoals):\n 1. \\<And>ws.\n       vs' = ws \\<circ> g \\<Longrightarrow>\n       ((f t, ws), f t,\n        \\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x)\n       \\<in> (step (map_minsky f g M))\\<^sup>*\n 2. \\<And>z s vs ws.\n       \\<lbrakk>((s, vs), z) \\<in> step M;\n        (z, t, vs') \\<in> (step M)\\<^sup>*;\n        \\<And>s vs ws.\n           \\<lbrakk>z = (s, vs); vs = ws \\<circ> g\\<rbrakk>\n           \\<Longrightarrow> ((f s, ws), f t,\n                              \\<lambda>x.\n                                 if x \\<in> range g then vs' (inv g x)\n                                 else ws x)\n                             \\<in> (step (map_minsky f g M))\\<^sup>*;\n        vs = ws \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> ((f s, ws), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then vs' (inv g x)\n                             else ws x)\n                         \\<in> (step (map_minsky f g M))\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  vs' = ws \\<circ> g", "have \"(\\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x) = ws\""], ["proof (prove)\nusing this:\n  vs' = ws \\<circ> g\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x) = ws", "using assms(1)"], ["proof (prove)\nusing this:\n  vs' = ws \\<circ> g\n  inj g\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x) = ws", "by (auto intro!: ext simp: injD image_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x) = ws\n\ngoal (2 subgoals):\n 1. \\<And>ws.\n       vs' = ws \\<circ> g \\<Longrightarrow>\n       ((f t, ws), f t,\n        \\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x)\n       \\<in> (step (map_minsky f g M))\\<^sup>*\n 2. \\<And>z s vs ws.\n       \\<lbrakk>((s, vs), z) \\<in> step M;\n        (z, t, vs') \\<in> (step M)\\<^sup>*;\n        \\<And>s vs ws.\n           \\<lbrakk>z = (s, vs); vs = ws \\<circ> g\\<rbrakk>\n           \\<Longrightarrow> ((f s, ws), f t,\n                              \\<lambda>x.\n                                 if x \\<in> range g then vs' (inv g x)\n                                 else ws x)\n                             \\<in> (step (map_minsky f g M))\\<^sup>*;\n        vs = ws \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> ((f s, ws), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then vs' (inv g x)\n                             else ws x)\n                         \\<in> (step (map_minsky f g M))\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x) = ws", "show ?case"], ["proof (prove)\nusing this:\n  (\\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x) = ws\n\ngoal (1 subgoal):\n 1. ((f t, ws), f t,\n     \\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x)\n    \\<in> (step (map_minsky f g M))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  ((f t, ws), f t,\n   \\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x)\n  \\<in> (step (map_minsky f g M))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>z s vs ws.\n       \\<lbrakk>((s, vs), z) \\<in> step M;\n        (z, t, vs') \\<in> (step M)\\<^sup>*;\n        \\<And>s vs ws.\n           \\<lbrakk>z = (s, vs); vs = ws \\<circ> g\\<rbrakk>\n           \\<Longrightarrow> ((f s, ws), f t,\n                              \\<lambda>x.\n                                 if x \\<in> range g then vs' (inv g x)\n                                 else ws x)\n                             \\<in> (step (map_minsky f g M))\\<^sup>*;\n        vs = ws \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> ((f s, ws), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then vs' (inv g x)\n                             else ws x)\n                         \\<in> (step (map_minsky f g M))\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z s vs ws.\n       \\<lbrakk>((s, vs), z) \\<in> step M;\n        (z, t, vs') \\<in> (step M)\\<^sup>*;\n        \\<And>s vs ws.\n           \\<lbrakk>z = (s, vs); vs = ws \\<circ> g\\<rbrakk>\n           \\<Longrightarrow> ((f s, ws), f t,\n                              \\<lambda>x.\n                                 if x \\<in> range g then vs' (inv g x)\n                                 else ws x)\n                             \\<in> (step (map_minsky f g M))\\<^sup>*;\n        vs = ws \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> ((f s, ws), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then vs' (inv g x)\n                             else ws x)\n                         \\<in> (step (map_minsky f g M))\\<^sup>*", "case (step y)"], ["proof (state)\nthis:\n  ((s, vs), y) \\<in> step M\n  (y, t, vs') \\<in> (step M)\\<^sup>*\n  \\<lbrakk>y = (?s, ?vs); ?vs = ?ws \\<circ> g\\<rbrakk>\n  \\<Longrightarrow> ((f ?s, ?ws), f t,\n                     \\<lambda>x.\n                        if x \\<in> range g then vs' (inv g x) else ?ws x)\n                    \\<in> (step (map_minsky f g M))\\<^sup>*\n  vs = ws \\<circ> g\n\ngoal (1 subgoal):\n 1. \\<And>z s vs ws.\n       \\<lbrakk>((s, vs), z) \\<in> step M;\n        (z, t, vs') \\<in> (step M)\\<^sup>*;\n        \\<And>s vs ws.\n           \\<lbrakk>z = (s, vs); vs = ws \\<circ> g\\<rbrakk>\n           \\<Longrightarrow> ((f s, ws), f t,\n                              \\<lambda>x.\n                                 if x \\<in> range g then vs' (inv g x)\n                                 else ws x)\n                             \\<in> (step (map_minsky f g M))\\<^sup>*;\n        vs = ws \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> ((f s, ws), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then vs' (inv g x)\n                             else ws x)\n                         \\<in> (step (map_minsky f g M))\\<^sup>*", "have \"snd y = (\\<lambda>x. if x \\<in> range g then snd y (inv g x) else ws x) \\<circ> g\" (is \"_ = ?ys' \\<circ> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd y =\n    (\\<lambda>x. if x \\<in> range g then snd y (inv g x) else ws x) \\<circ>\n    g", "using assms(1)"], ["proof (prove)\nusing this:\n  inj g\n\ngoal (1 subgoal):\n 1. snd y =\n    (\\<lambda>x. if x \\<in> range g then snd y (inv g x) else ws x) \\<circ>\n    g", "by auto"], ["proof (state)\nthis:\n  snd y =\n  (\\<lambda>x. if x \\<in> range g then snd y (inv g x) else ws x) \\<circ> g\n\ngoal (1 subgoal):\n 1. \\<And>z s vs ws.\n       \\<lbrakk>((s, vs), z) \\<in> step M;\n        (z, t, vs') \\<in> (step M)\\<^sup>*;\n        \\<And>s vs ws.\n           \\<lbrakk>z = (s, vs); vs = ws \\<circ> g\\<rbrakk>\n           \\<Longrightarrow> ((f s, ws), f t,\n                              \\<lambda>x.\n                                 if x \\<in> range g then vs' (inv g x)\n                                 else ws x)\n                             \\<in> (step (map_minsky f g M))\\<^sup>*;\n        vs = ws \\<circ> g\\<rbrakk>\n       \\<Longrightarrow> ((f s, ws), f t,\n                          \\<lambda>x.\n                             if x \\<in> range g then vs' (inv g x)\n                             else ws x)\n                         \\<in> (step (map_minsky f g M))\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  snd y =\n  (\\<lambda>x. if x \\<in> range g then snd y (inv g x) else ws x) \\<circ> g", "show ?case"], ["proof (prove)\nusing this:\n  snd y =\n  (\\<lambda>x. if x \\<in> range g then snd y (inv g x) else ws x) \\<circ> g\n\ngoal (1 subgoal):\n 1. ((f s, ws), f t,\n     \\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x)\n    \\<in> (step (map_minsky f g M))\\<^sup>*", "using map_step[OF assms(1) step(4), of s \"fst y\" \"snd y\" M f] step(1)\n    step(3)[OF prod.collapse[symmetric], of ?ys']"], ["proof (prove)\nusing this:\n  snd y =\n  (\\<lambda>x. if x \\<in> range g then snd y (inv g x) else ws x) \\<circ> g\n  ((s, vs), fst y, snd y) \\<in> step M \\<Longrightarrow>\n  ((f s, ws), f (fst y),\n   \\<lambda>x. if x \\<in> range g then snd y (inv g x) else ws x)\n  \\<in> step (map_minsky f g M)\n  ((s, vs), y) \\<in> step M\n  snd y =\n  (\\<lambda>x. if x \\<in> range g then snd y (inv g x) else ws x) \\<circ>\n  g \\<Longrightarrow>\n  ((f (fst y),\n    \\<lambda>x. if x \\<in> range g then snd y (inv g x) else ws x),\n   f t,\n   \\<lambda>x.\n      if x \\<in> range g then vs' (inv g x)\n      else if x \\<in> range g then snd y (inv g x) else ws x)\n  \\<in> (step (map_minsky f g M))\\<^sup>*\n\ngoal (1 subgoal):\n 1. ((f s, ws), f t,\n     \\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x)\n    \\<in> (step (map_minsky f g M))\\<^sup>*", "by (auto cong: if_cong)"], ["proof (state)\nthis:\n  ((f s, ws), f t,\n   \\<lambda>x. if x \\<in> range g then vs' (inv g x) else ws x)\n  \\<in> (step (map_minsky f g M))\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Concrete Minsky machines\\<close>"], ["", "text \\<open>The following definition expresses when a Minsky machine $M$ implements a specification $P$.\nWe adopt the convention that computations always start out in state $1$ and end in state $0$, which\nmust be a final state. The specification $P$ relates initial assignments to final assignments.\\<close>"], ["", "definition mk_minsky_wit :: \"(nat, nat) minsky \\<Rightarrow> ((nat \\<Rightarrow> nat) \\<Rightarrow> (nat \\<Rightarrow> nat) \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"mk_minsky_wit M P \\<equiv> finite M \\<and> deterministic M \\<and> 0 \\<notin> fst ` M \\<and>\n     (\\<forall>vs. \\<exists>vs'. ((Suc 0, vs), (0, vs')) \\<in> (step M)\\<^sup>* \\<and> P vs vs')\""], ["", "abbreviation mk_minsky :: \"((nat \\<Rightarrow> nat) \\<Rightarrow> (nat \\<Rightarrow> nat) \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"mk_minsky P \\<equiv> \\<exists>M. mk_minsky_wit M P\""], ["", "lemmas mk_minsky_def = mk_minsky_wit_def"], ["", "lemma mk_minsky_mono:\n  shows \"mk_minsky P \\<Longrightarrow> (\\<And>vs vs'. P vs vs' \\<Longrightarrow> Q vs vs') \\<Longrightarrow> mk_minsky Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mk_minsky P;\n     \\<And>vs vs'. P vs vs' \\<Longrightarrow> Q vs vs'\\<rbrakk>\n    \\<Longrightarrow> mk_minsky Q", "unfolding mk_minsky_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>M.\n                finite M \\<and>\n                deterministic M \\<and>\n                0 \\<notin> fst ` M \\<and>\n                (\\<forall>vs.\n                    \\<exists>vs'.\n                       ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and>\n                       P vs vs');\n     \\<And>vs vs'. P vs vs' \\<Longrightarrow> Q vs vs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M.\n                         finite M \\<and>\n                         deterministic M \\<and>\n                         0 \\<notin> fst ` M \\<and>\n                         (\\<forall>vs.\n                             \\<exists>vs'.\n                                ((Suc 0, vs), 0, vs')\n                                \\<in> (step M)\\<^sup>* \\<and>\n                                Q vs vs')", "by meson"], ["", "lemma mk_minsky_sound:\n  assumes \"mk_minsky_wit M P\" \"((Suc 0, vs), (0, vs')) \\<in> (step M)\\<^sup>*\"\n  shows \"P vs vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P vs vs'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P vs vs'", "have M: \"deterministic M\" \"0 \\<notin> fst ` M\" \"\\<And>vs. \\<exists>vs'. ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and> P vs vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic M &&&\n    0 \\<notin> fst ` M &&&\n    (\\<And>vs.\n        \\<exists>vs'.\n           ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and> P vs vs')", "using assms(1)"], ["proof (prove)\nusing this:\n  mk_minsky_wit M P\n\ngoal (1 subgoal):\n 1. deterministic M &&&\n    0 \\<notin> fst ` M &&&\n    (\\<And>vs.\n        \\<exists>vs'.\n           ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and> P vs vs')", "by (auto simp: mk_minsky_wit_def)"], ["proof (state)\nthis:\n  deterministic M\n  0 \\<notin> fst ` M\n  \\<exists>vs'.\n     ((Suc 0, ?vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and> P ?vs vs'\n\ngoal (1 subgoal):\n 1. P vs vs'", "obtain vs'' where vs'': \"((Suc 0, vs), (0, vs'')) \\<in> (step M)\\<^sup>*\" \"P vs vs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs''.\n        \\<lbrakk>((Suc 0, vs), 0, vs'') \\<in> (step M)\\<^sup>*;\n         P vs vs''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using M(3)"], ["proof (prove)\nusing this:\n  \\<exists>vs'.\n     ((Suc 0, ?vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and> P ?vs vs'\n\ngoal (1 subgoal):\n 1. (\\<And>vs''.\n        \\<lbrakk>((Suc 0, vs), 0, vs'') \\<in> (step M)\\<^sup>*;\n         P vs vs''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ((Suc 0, vs), 0, vs'') \\<in> (step M)\\<^sup>*\n  P vs vs''\n\ngoal (1 subgoal):\n 1. P vs vs'", "have \"(0 :: nat, vs') = (0, vs'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0, vs') = (0, vs'')", "using M(1,2)"], ["proof (prove)\nusing this:\n  deterministic M\n  0 \\<notin> fst ` M\n\ngoal (1 subgoal):\n 1. (0, vs') = (0, vs'')", "by (intro deterministic_minsky_UN[OF _ assms(2) vs''(1)])"], ["proof (state)\nthis:\n  (0, vs') = (0, vs'')\n\ngoal (1 subgoal):\n 1. P vs vs'", "then"], ["proof (chain)\npicking this:\n  (0, vs') = (0, vs'')", "show ?thesis"], ["proof (prove)\nusing this:\n  (0, vs') = (0, vs'')\n\ngoal (1 subgoal):\n 1. P vs vs'", "using vs''(2)"], ["proof (prove)\nusing this:\n  (0, vs') = (0, vs'')\n  P vs vs''\n\ngoal (1 subgoal):\n 1. P vs vs'", "by simp"], ["proof (state)\nthis:\n  P vs vs'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Realizability of $n$-ary functions for $n = 1 \\dots 3$. Here we use the convention that the\narguments are passed in registers $1 \\dots 3$, and the result is stored in register $0$.\\<close>"], ["", "abbreviation mk_minsky1 where\n  \"mk_minsky1 f \\<equiv> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (vs 1))\""], ["", "abbreviation mk_minsky2 where\n  \"mk_minsky2 f \\<equiv> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (vs 1) (vs 2))\""], ["", "abbreviation mk_minsky3 where\n  \"mk_minsky3 f \\<equiv> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (vs 1) (vs 2) (vs 3))\""], ["", "subsection \\<open>Trivial building blocks\\<close>"], ["", "text \\<open>We can increment and decrement any register.\\<close>"], ["", "lemma mk_minsky_inc:\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then Suc (vs v) else vs x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' = (\\<lambda>x. if x = v then Suc (vs v) else vs x))", "using step.inc[of \"Suc 0\" v 0]"], ["proof (prove)\nusing this:\n  (Suc 0, Inc v 0) \\<in> ?M \\<Longrightarrow>\n  ((Suc 0, ?vs), 0, \\<lambda>x. if x = v then Suc (?vs v) else ?vs x)\n  \\<in> step ?M\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' = (\\<lambda>x. if x = v then Suc (vs v) else vs x))", "by (auto simp: deterministic_def mk_minsky_def intro!: exI[of _ \"{(1, Inc v 0)} :: (nat, nat) minsky\"])"], ["", "lemma mk_minsky_dec:\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then vs v - 1 else vs x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then vs v - 1 else vs x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then vs v - 1 else vs x))", "let ?M = \"{(1, Dec v 0 0)} :: (nat, nat) minsky\""], ["proof (state)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then vs v - 1 else vs x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then vs v - 1 else vs x))", "unfolding mk_minsky_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M.\n       finite M \\<and>\n       deterministic M \\<and>\n       0 \\<notin> fst ` M \\<and>\n       (\\<forall>vs.\n           \\<exists>vs'.\n              ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and>\n              vs' = (\\<lambda>x. if x = v then vs v - 1 else vs x))", "proof (intro exI[of _ ?M] allI conjI, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite {(1, Dec v 0 0)}\n 2. deterministic {(1, Dec v 0 0)}\n 3. 0 \\<notin> fst ` {(1, Dec v 0 0)}\n 4. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs') \\<in> (step {(1, Dec v 0 0)})\\<^sup>* \\<and>\n          vs' = (\\<lambda>x. if x = v then vs v - 1 else vs x)", "case (4 vs)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. finite {(1, Dec v 0 0)}\n 2. deterministic {(1, Dec v 0 0)}\n 3. 0 \\<notin> fst ` {(1, Dec v 0 0)}\n 4. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs') \\<in> (step {(1, Dec v 0 0)})\\<^sup>* \\<and>\n          vs' = (\\<lambda>x. if x = v then vs v - 1 else vs x)", "have [simp]: \"vs v = 0 \\<Longrightarrow> (\\<lambda>x. if x = v then 0 else vs x) = vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs v = 0 \\<Longrightarrow> (\\<lambda>x. if x = v then 0 else vs x) = vs", "by auto"], ["proof (state)\nthis:\n  vs v = 0 \\<Longrightarrow> (\\<lambda>x. if x = v then 0 else vs x) = vs\n\ngoal (4 subgoals):\n 1. finite {(1, Dec v 0 0)}\n 2. deterministic {(1, Dec v 0 0)}\n 3. 0 \\<notin> fst ` {(1, Dec v 0 0)}\n 4. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs') \\<in> (step {(1, Dec v 0 0)})\\<^sup>* \\<and>\n          vs' = (\\<lambda>x. if x = v then vs v - 1 else vs x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       ((Suc 0, vs), 0, vs') \\<in> (step {(1, Dec v 0 0)})\\<^sup>* \\<and>\n       vs' = (\\<lambda>x. if x = v then vs v - 1 else vs x)", "using step.decz[of \"Suc 0\" v 0 0 ?M] step.decn[of \"Suc 0\" v 0 0 ?M]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(Suc 0, Dec v 0 0) \\<in> {(1, Dec v 0 0)}; ?vs v = 0\\<rbrakk>\n  \\<Longrightarrow> ((Suc 0, ?vs), 0, ?vs) \\<in> step {(1, Dec v 0 0)}\n  \\<lbrakk>(Suc 0, Dec v 0 0) \\<in> {(1, Dec v 0 0)};\n   ?vs v = Suc ?n\\<rbrakk>\n  \\<Longrightarrow> ((Suc 0, ?vs), 0,\n                     \\<lambda>x. if x = v then ?n else ?vs x)\n                    \\<in> step {(1, Dec v 0 0)}\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       ((Suc 0, vs), 0, vs') \\<in> (step {(1, Dec v 0 0)})\\<^sup>* \\<and>\n       vs' = (\\<lambda>x. if x = v then vs v - 1 else vs x)", "by (cases \"vs v\") (auto cong: if_cong)"], ["proof (state)\nthis:\n  \\<exists>vs'.\n     ((Suc 0, vs), 0, vs') \\<in> (step {(1, Dec v 0 0)})\\<^sup>* \\<and>\n     vs' = (\\<lambda>x. if x = v then vs v - 1 else vs x)\n\ngoal (3 subgoals):\n 1. finite {(1, Dec v 0 0)}\n 2. deterministic {(1, Dec v 0 0)}\n 3. 0 \\<notin> fst ` {(1, Dec v 0 0)}", "qed auto"], ["proof (state)\nthis:\n  mk_minsky\n   (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then vs v - 1 else vs x))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Sequential composition\\<close>"], ["", "text \\<open>The following lemma has two useful corollaries (which we prove simultaneously because they\nshare much of the proof structure): First, if $P$ and $Q$ are realizable, then so is $P \\circ Q$.\nSecondly, if we rename variables by an injective function $f$ in a Minksy machine, then the\nvariables outside the range of $f$ remain unchanged.\\<close>"], ["", "lemma mk_minsky_seq_map:\n  assumes \"mk_minsky P\" \"mk_minsky Q\" \"inj g\"\n    \"\\<And>vs vs' vs''. P vs vs' \\<Longrightarrow> Q vs' vs'' \\<Longrightarrow> R vs vs''\"\n  shows \"mk_minsky (\\<lambda>vs vs'. R (vs \\<circ> g) (vs' \\<circ> g) \\<and> (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n         (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n         (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x))", "obtain M where M: \"finite M\" \"deterministic M\" \"0 \\<notin> fst ` M\"\n    \"\\<And>vs. \\<exists>vs'. ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and> P vs vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         \\<And>vs.\n            \\<exists>vs'.\n               ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and>\n               P vs vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  mk_minsky P\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         \\<And>vs.\n            \\<exists>vs'.\n               ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and>\n               P vs vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: mk_minsky_def)"], ["proof (state)\nthis:\n  finite M\n  deterministic M\n  0 \\<notin> fst ` M\n  \\<exists>vs'.\n     ((Suc 0, ?vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and> P ?vs vs'\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n         (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x))", "obtain N where N: \"finite N\" \"deterministic N\" \"0 \\<notin> fst ` N\"\n    \"\\<And>vs. \\<exists>vs'. ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>* \\<and> Q vs vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>finite N; deterministic N; 0 \\<notin> fst ` N;\n         \\<And>vs.\n            \\<exists>vs'.\n               ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>* \\<and>\n               Q vs vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  mk_minsky Q\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>finite N; deterministic N; 0 \\<notin> fst ` N;\n         \\<And>vs.\n            \\<exists>vs'.\n               ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>* \\<and>\n               Q vs vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: mk_minsky_def)"], ["proof (state)\nthis:\n  finite N\n  deterministic N\n  0 \\<notin> fst ` N\n  \\<exists>vs'.\n     ((Suc 0, ?vs), 0, vs') \\<in> (step N)\\<^sup>* \\<and> Q ?vs vs'\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n         (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x))", "let ?fM = \"\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1\" \\<comment> \\<open>M: from 1 to 2\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n         (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x))", "let ?fN = \"\\<lambda>s. 2 * s\"                                               \\<comment> \\<open>N: from 2 to 0\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n         (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x))", "let ?M = \"map_minsky ?fM g M \\<union> map_minsky ?fN g N\""], ["proof (state)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n         (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n         (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x))", "unfolding mk_minsky_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M.\n       finite M \\<and>\n       deterministic M \\<and>\n       0 \\<notin> fst ` M \\<and>\n       (\\<forall>vs.\n           \\<exists>vs'.\n              ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and>\n              R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n              (\\<forall>x.\n                  x \\<notin> range g \\<longrightarrow> vs x = vs' x))", "proof (intro exI[of _ ?M] conjI allI, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite\n     (map_minsky\n       (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1) g\n       M \\<union>\n      map_minsky ((*) 2) g N)\n 2. deterministic\n     (map_minsky\n       (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1) g\n       M \\<union>\n      map_minsky ((*) 2) g N)\n 3. 0 \\<notin> fst `\n               (map_minsky\n                 (\\<lambda>s.\n                     if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                 g M \\<union>\n                map_minsky ((*) 2) g N)\n 4. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  (map_minsky\n                    (\\<lambda>s.\n                        if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                    g M \\<union>\n                   map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n          R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n          (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. finite\n     (map_minsky\n       (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1) g\n       M \\<union>\n      map_minsky ((*) 2) g N)\n 2. deterministic\n     (map_minsky\n       (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1) g\n       M \\<union>\n      map_minsky ((*) 2) g N)\n 3. 0 \\<notin> fst `\n               (map_minsky\n                 (\\<lambda>s.\n                     if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                 g M \\<union>\n                map_minsky ((*) 2) g N)\n 4. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  (map_minsky\n                    (\\<lambda>s.\n                        if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                    g M \\<union>\n                   map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n          R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n          (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (map_minsky\n       (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1) g\n       M \\<union>\n      map_minsky ((*) 2) g N)", "using M(1) N(1)"], ["proof (prove)\nusing this:\n  finite M\n  finite N\n\ngoal (1 subgoal):\n 1. finite\n     (map_minsky\n       (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1) g\n       M \\<union>\n      map_minsky ((*) 2) g N)", "by (auto simp: map_minsky_def)"], ["proof (state)\nthis:\n  finite\n   (map_minsky\n     (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1) g\n     M \\<union>\n    map_minsky ((*) 2) g N)\n\ngoal (3 subgoals):\n 1. deterministic\n     (map_minsky\n       (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1) g\n       M \\<union>\n      map_minsky ((*) 2) g N)\n 2. 0 \\<notin> fst `\n               (map_minsky\n                 (\\<lambda>s.\n                     if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                 g M \\<union>\n                map_minsky ((*) 2) g N)\n 3. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  (map_minsky\n                    (\\<lambda>s.\n                        if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                    g M \\<union>\n                   map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n          R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n          (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. deterministic\n     (map_minsky\n       (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1) g\n       M \\<union>\n      map_minsky ((*) 2) g N)\n 2. 0 \\<notin> fst `\n               (map_minsky\n                 (\\<lambda>s.\n                     if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                 g M \\<union>\n                map_minsky ((*) 2) g N)\n 3. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  (map_minsky\n                    (\\<lambda>s.\n                        if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                    g M \\<union>\n                   map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n          R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n          (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. deterministic\n     (map_minsky\n       (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1) g\n       M \\<union>\n      map_minsky ((*) 2) g N)\n 2. 0 \\<notin> fst `\n               (map_minsky\n                 (\\<lambda>s.\n                     if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                 g M \\<union>\n                map_minsky ((*) 2) g N)\n 3. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  (map_minsky\n                    (\\<lambda>s.\n                        if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                    g M \\<union>\n                   map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n          R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n          (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic\n     (map_minsky\n       (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1) g\n       M \\<union>\n      map_minsky ((*) 2) g N)", "using M(2,3) N(2)"], ["proof (prove)\nusing this:\n  deterministic M\n  0 \\<notin> fst ` M\n  deterministic N\n\ngoal (1 subgoal):\n 1. deterministic\n     (map_minsky\n       (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1) g\n       M \\<union>\n      map_minsky ((*) 2) g N)", "unfolding map_minsky_def"], ["proof (prove)\nusing this:\n  deterministic M\n  0 \\<notin> fst ` M\n  deterministic N\n\ngoal (1 subgoal):\n 1. deterministic\n     (map_prod\n       (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n       (map_Op\n         (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n         g) `\n      M \\<union>\n      map_prod ((*) 2) (map_Op ((*) 2) g) ` N)", "by (intro deterministic_union deterministic_map)\n        (auto simp: inj_on_def rev_image_eqI Suc_double_not_eq_double split: if_splits)"], ["proof (state)\nthis:\n  deterministic\n   (map_minsky\n     (\\<lambda>s. if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1) g\n     M \\<union>\n    map_minsky ((*) 2) g N)\n\ngoal (2 subgoals):\n 1. 0 \\<notin> fst `\n               (map_minsky\n                 (\\<lambda>s.\n                     if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                 g M \\<union>\n                map_minsky ((*) 2) g N)\n 2. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  (map_minsky\n                    (\\<lambda>s.\n                        if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                    g M \\<union>\n                   map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n          R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n          (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<notin> fst `\n               (map_minsky\n                 (\\<lambda>s.\n                     if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                 g M \\<union>\n                map_minsky ((*) 2) g N)\n 2. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  (map_minsky\n                    (\\<lambda>s.\n                        if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                    g M \\<union>\n                   map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n          R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n          (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 \\<notin> fst `\n               (map_minsky\n                 (\\<lambda>s.\n                     if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                 g M \\<union>\n                map_minsky ((*) 2) g N)\n 2. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  (map_minsky\n                    (\\<lambda>s.\n                        if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                    g M \\<union>\n                   map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n          R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n          (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> fst `\n               (map_minsky\n                 (\\<lambda>s.\n                     if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                 g M \\<union>\n                map_minsky ((*) 2) g N)", "using N(3)"], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` N\n\ngoal (1 subgoal):\n 1. 0 \\<notin> fst `\n               (map_minsky\n                 (\\<lambda>s.\n                     if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                 g M \\<union>\n                map_minsky ((*) 2) g N)", "by (auto simp: rev_image_eqI map_minsky_def split: if_splits)"], ["proof (state)\nthis:\n  0 \\<notin> fst `\n             (map_minsky\n               (\\<lambda>s.\n                   if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n               g M \\<union>\n              map_minsky ((*) 2) g N)\n\ngoal (1 subgoal):\n 1. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  (map_minsky\n                    (\\<lambda>s.\n                        if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                    g M \\<union>\n                   map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n          R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n          (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  (map_minsky\n                    (\\<lambda>s.\n                        if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                    g M \\<union>\n                   map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n          R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n          (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "case (4 vs)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  (map_minsky\n                    (\\<lambda>s.\n                        if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                    g M \\<union>\n                   map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n          R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n          (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "obtain vsM where M': \"((Suc 0, vs \\<circ> g), 0, vsM) \\<in> (step M)\\<^sup>*\" \"P (vs \\<circ> g) vsM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vsM.\n        \\<lbrakk>((Suc 0, vs \\<circ> g), 0, vsM) \\<in> (step M)\\<^sup>*;\n         P (vs \\<circ> g) vsM\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using M(4)"], ["proof (prove)\nusing this:\n  \\<exists>vs'.\n     ((Suc 0, ?vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and> P ?vs vs'\n\ngoal (1 subgoal):\n 1. (\\<And>vsM.\n        \\<lbrakk>((Suc 0, vs \\<circ> g), 0, vsM) \\<in> (step M)\\<^sup>*;\n         P (vs \\<circ> g) vsM\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ((Suc 0, vs \\<circ> g), 0, vsM) \\<in> (step M)\\<^sup>*\n  P (vs \\<circ> g) vsM\n\ngoal (1 subgoal):\n 1. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  (map_minsky\n                    (\\<lambda>s.\n                        if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                    g M \\<union>\n                   map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n          R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n          (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "obtain vsN where N': \"((Suc 0, vsM), 0, vsN) \\<in> (step N)\\<^sup>*\" \"Q vsM vsN\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vsN.\n        \\<lbrakk>((Suc 0, vsM), 0, vsN) \\<in> (step N)\\<^sup>*;\n         Q vsM vsN\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using N(4)"], ["proof (prove)\nusing this:\n  \\<exists>vs'.\n     ((Suc 0, ?vs), 0, vs') \\<in> (step N)\\<^sup>* \\<and> Q ?vs vs'\n\ngoal (1 subgoal):\n 1. (\\<And>vsN.\n        \\<lbrakk>((Suc 0, vsM), 0, vsN) \\<in> (step N)\\<^sup>*;\n         Q vsM vsN\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ((Suc 0, vsM), 0, vsN) \\<in> (step N)\\<^sup>*\n  Q vsM vsN\n\ngoal (1 subgoal):\n 1. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  (map_minsky\n                    (\\<lambda>s.\n                        if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                    g M \\<union>\n                   map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n          R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n          (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "note * = subsetD[OF steps_mono, of _ ?M]\n      map_steps[OF _ _ M'(1), of g vs ?fM, simplified]\n      map_steps[OF _ _ N'(1), of g _ ?fN, simplified]"], ["proof (state)\nthis:\n  \\<lbrakk>?M1\n           \\<subseteq> map_minsky\n                        (\\<lambda>s.\n                            if s = 0 then 2\n                            else if s = 1 then 1 else 2 * s + 1)\n                        g M \\<union>\n                       map_minsky ((*) 2) g N;\n   ?c \\<in> (step ?M1)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> (step\n                               (map_minsky\n                                 (\\<lambda>s.\n                                     if s = 0 then 2\n                                     else if s = 1 then 1 else 2 * s + 1)\n                                 g M \\<union>\n                                map_minsky ((*) 2) g N))\\<^sup>*\n  inj g \\<Longrightarrow>\n  ((Suc 0, vs), 2,\n   \\<lambda>x. if x \\<in> range g then vsM (inv g x) else vs x)\n  \\<in> (step\n          (map_minsky\n            (\\<lambda>s.\n                if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n            g M))\\<^sup>*\n  \\<lbrakk>inj g; vsM = ?ws \\<circ> g\\<rbrakk>\n  \\<Longrightarrow> ((2, ?ws), 0,\n                     \\<lambda>x.\n                        if x \\<in> range g then vsN (inv g x) else ?ws x)\n                    \\<in> (step (map_minsky ((*) 2) g N))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  (map_minsky\n                    (\\<lambda>s.\n                        if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                    g M \\<union>\n                   map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n          R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n          (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       ((Suc 0, vs), 0, vs')\n       \\<in> (step\n               (map_minsky\n                 (\\<lambda>s.\n                     if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                 g M \\<union>\n                map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n       R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n       (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "using assms(3,4) M'(2) N'(2) rtrancl_trans[OF *(1)[OF _ *(2)] *(1)[OF _ *(3)]]"], ["proof (prove)\nusing this:\n  inj g\n  \\<lbrakk>P ?vs ?vs'; Q ?vs' ?vs''\\<rbrakk> \\<Longrightarrow> R ?vs ?vs''\n  P (vs \\<circ> g) vsM\n  Q vsM vsN\n  \\<lbrakk>map_minsky\n            (\\<lambda>s.\n                if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n            g M\n           \\<subseteq> map_minsky\n                        (\\<lambda>s.\n                            if s = 0 then 2\n                            else if s = 1 then 1 else 2 * s + 1)\n                        g M \\<union>\n                       map_minsky ((*) 2) g N;\n   inj g;\n   map_minsky ((*) 2) g N\n   \\<subseteq> map_minsky\n                (\\<lambda>s.\n                    if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                g M \\<union>\n               map_minsky ((*) 2) g N;\n   inj g;\n   vsM =\n   (\\<lambda>x. if x \\<in> range g then vsM (inv g x) else vs x) \\<circ>\n   g\\<rbrakk>\n  \\<Longrightarrow> ((Suc 0, vs), 0,\n                     \\<lambda>x.\n                        if x \\<in> range g then vsN (inv g x)\n                        else if x \\<in> range g then vsM (inv g x)\n                             else vs x)\n                    \\<in> (step\n                            (map_minsky\n                              (\\<lambda>s.\n                                  if s = 0 then 2\n                                  else if s = 1 then 1 else 2 * s + 1)\n                              g M \\<union>\n                             map_minsky ((*) 2) g N))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       ((Suc 0, vs), 0, vs')\n       \\<in> (step\n               (map_minsky\n                 (\\<lambda>s.\n                     if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n                 g M \\<union>\n                map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n       R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n       (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)", "by (auto simp: comp_def)"], ["proof (state)\nthis:\n  \\<exists>vs'.\n     ((Suc 0, vs), 0, vs')\n     \\<in> (step\n             (map_minsky\n               (\\<lambda>s.\n                   if s = 0 then 2 else if s = 1 then 1 else 2 * s + 1)\n               g M \\<union>\n              map_minsky ((*) 2) g N))\\<^sup>* \\<and>\n     R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n     (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mk_minsky\n   (\\<lambda>vs vs'.\n       R (vs \\<circ> g) (vs' \\<circ> g) \\<and>\n       (\\<forall>x. x \\<notin> range g \\<longrightarrow> vs x = vs' x))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Sequential composition.\\<close>"], ["", "lemma mk_minsky_seq:\n  assumes \"mk_minsky P\" \"mk_minsky Q\"\n    \"\\<And>vs vs' vs''. P vs vs' \\<Longrightarrow> Q vs' vs'' \\<Longrightarrow> R vs vs''\"\n  shows \"mk_minsky R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky R", "using mk_minsky_seq_map[OF assms(1,2), of id] assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj id;\n   \\<And>vs vs' vs''.\n      \\<lbrakk>P vs vs'; Q vs' vs''\\<rbrakk>\n      \\<Longrightarrow> ?R vs vs''\\<rbrakk>\n  \\<Longrightarrow> mk_minsky\n                     (\\<lambda>vs vs'.\n                         ?R (vs \\<circ> id) (vs' \\<circ> id) \\<and>\n                         (\\<forall>x.\n                             x \\<notin> range id \\<longrightarrow>\n                             vs x = vs' x))\n  \\<lbrakk>P ?vs ?vs'; Q ?vs' ?vs''\\<rbrakk> \\<Longrightarrow> R ?vs ?vs''\n\ngoal (1 subgoal):\n 1. mk_minsky R", "by simp"], ["", "lemma mk_minsky_seq':\n  assumes \"mk_minsky P\" \"mk_minsky Q\"\n  shows \"mk_minsky (\\<lambda>vs vs''. (\\<exists>vs'. P vs vs' \\<and> Q vs' vs''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs''. \\<exists>vs'. P vs vs' \\<and> Q vs' vs'')", "by (intro mk_minsky_seq[OF assms]) blast"], ["", "text \\<open>We can do nothing (besides transitioning from state 1 to state 0).\\<close>"], ["", "lemma mk_minsky_nop:\n  \"mk_minsky (\\<lambda>vs vs'. vs = vs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky (=)", "by (intro mk_minsky_seq[OF mk_minsky_inc mk_minsky_dec]) auto"], ["", "text \\<open>Renaming variables.\\<close>"], ["", "lemma mk_minsky_map:\n  assumes \"mk_minsky P\" \"inj f\"\n  shows \"mk_minsky (\\<lambda>vs vs'. P (vs \\<circ> f) (vs' \\<circ> f) \\<and> (\\<forall>x. x \\<notin> range f \\<longrightarrow> vs x = vs' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         P (vs \\<circ> f) (vs' \\<circ> f) \\<and>\n         (\\<forall>x. x \\<notin> range f \\<longrightarrow> vs x = vs' x))", "using mk_minsky_seq_map[OF assms(1) mk_minsky_nop assms(2)]"], ["proof (prove)\nusing this:\n  (\\<And>vs vs' vs''.\n      \\<lbrakk>P vs vs'; vs' = vs''\\<rbrakk>\n      \\<Longrightarrow> ?R vs vs'') \\<Longrightarrow>\n  mk_minsky\n   (\\<lambda>vs vs'.\n       ?R (vs \\<circ> f) (vs' \\<circ> f) \\<and>\n       (\\<forall>x. x \\<notin> range f \\<longrightarrow> vs x = vs' x))\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         P (vs \\<circ> f) (vs' \\<circ> f) \\<and>\n         (\\<forall>x. x \\<notin> range f \\<longrightarrow> vs x = vs' x))", "by simp"], ["", "lemma inj_shift [simp]:\n  fixes a b :: nat\n  assumes \"a < b\"\n  shows \"inj (\\<lambda>x. if x = 0 then a else x + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>x. if x = 0 then a else x + b)", "using assms"], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. inj (\\<lambda>x. if x = 0 then a else x + b)", "by (auto simp: inj_on_def)"], ["", "subsection \\<open>Bounded loop\\<close>"], ["", "text \\<open>In the following lemma, $P$ is the specification of a loop body, and $Q$ the specification\nof the loop itself (a loop invariant). The loop variable is $v$. $Q$ can be realized provided that\n\\begin{enumerate}\n\\item $P$ can be realized;\n\\item $P$ ensures that the loop variable is not changed by the loop body; and\n\\item $Q$ follows by induction on the loop variable:\n  \\begin{enumerate}\n  \\item $\\alpha\\,Q\\,\\alpha$ holds when $\\alpha[v] = 0$; and\n  \\item $\\alpha[v := n]\\,P\\,\\alpha'$ and $\\alpha'\\,Q\\,\\alpha''$ imply $\\alpha\\,Q\\,alpha''$\n    when $\\alpha[v] = n+1$.\n  \\end{enumerate}\n\\end{enumerate}\\<close>"], ["", "lemma mk_minsky_loop:\n  assumes \"mk_minsky P\"\n    \"\\<And>vs vs'. P vs vs' \\<Longrightarrow> vs' v = vs v\"\n    \"\\<And>vs. vs v = 0 \\<Longrightarrow> Q vs vs\"\n    \"\\<And>n vs vs' vs''. vs v = Suc n \\<Longrightarrow> P (\\<lambda>x. if x = v then n else vs x) vs' \\<Longrightarrow> Q vs' vs'' \\<Longrightarrow> Q vs vs''\"\n  shows \"mk_minsky Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mk_minsky Q", "obtain M where M: \"finite M\" \"deterministic M\" \"0 \\<notin> fst ` M\"\n    \"\\<And>vs. \\<exists>vs'. ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and> P vs vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         \\<And>vs.\n            \\<exists>vs'.\n               ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and>\n               P vs vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  mk_minsky P\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         \\<And>vs.\n            \\<exists>vs'.\n               ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and>\n               P vs vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: mk_minsky_def)"], ["proof (state)\nthis:\n  finite M\n  deterministic M\n  0 \\<notin> fst ` M\n  \\<exists>vs'.\n     ((Suc 0, ?vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and> P ?vs vs'\n\ngoal (1 subgoal):\n 1. mk_minsky Q", "let ?M = \"{(1, Dec v 2 0)} \\<union> map_minsky Suc id M\""], ["proof (state)\ngoal (1 subgoal):\n 1. mk_minsky Q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky Q", "unfolding mk_minsky_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M.\n       finite M \\<and>\n       deterministic M \\<and>\n       0 \\<notin> fst ` M \\<and>\n       (\\<forall>vs.\n           \\<exists>vs'.\n              ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and> Q vs vs')", "proof (intro exI[of _ ?M] conjI allI, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 2. deterministic ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 3. 0 \\<notin> fst ` ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 4. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  ({(1, Dec v 2 0)} \\<union>\n                   map_minsky Suc id M))\\<^sup>* \\<and>\n          Q vs vs'", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. finite ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 2. deterministic ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 3. 0 \\<notin> fst ` ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 4. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  ({(1, Dec v 2 0)} \\<union>\n                   map_minsky Suc id M))\\<^sup>* \\<and>\n          Q vs vs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)", "using M(1)"], ["proof (prove)\nusing this:\n  finite M\n\ngoal (1 subgoal):\n 1. finite ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)", "by (auto simp: map_minsky_def)"], ["proof (state)\nthis:\n  finite ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n\ngoal (3 subgoals):\n 1. deterministic ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 2. 0 \\<notin> fst ` ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 3. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  ({(1, Dec v 2 0)} \\<union>\n                   map_minsky Suc id M))\\<^sup>* \\<and>\n          Q vs vs'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. deterministic ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 2. 0 \\<notin> fst ` ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 3. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  ({(1, Dec v 2 0)} \\<union>\n                   map_minsky Suc id M))\\<^sup>* \\<and>\n          Q vs vs'", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. deterministic ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 2. 0 \\<notin> fst ` ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 3. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  ({(1, Dec v 2 0)} \\<union>\n                   map_minsky Suc id M))\\<^sup>* \\<and>\n          Q vs vs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)", "using M(2,3)"], ["proof (prove)\nusing this:\n  deterministic M\n  0 \\<notin> fst ` M\n\ngoal (1 subgoal):\n 1. deterministic ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)", "unfolding map_minsky_def"], ["proof (prove)\nusing this:\n  deterministic M\n  0 \\<notin> fst ` M\n\ngoal (1 subgoal):\n 1. deterministic\n     ({(1, Dec v 2 0)} \\<union> map_prod Suc (map_Op Suc id) ` M)", "by (intro deterministic_union deterministic_map) (auto simp: rev_image_eqI)"], ["proof (state)\nthis:\n  deterministic ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n\ngoal (2 subgoals):\n 1. 0 \\<notin> fst ` ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 2. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  ({(1, Dec v 2 0)} \\<union>\n                   map_minsky Suc id M))\\<^sup>* \\<and>\n          Q vs vs'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<notin> fst ` ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 2. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  ({(1, Dec v 2 0)} \\<union>\n                   map_minsky Suc id M))\\<^sup>* \\<and>\n          Q vs vs'", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 \\<notin> fst ` ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n 2. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  ({(1, Dec v 2 0)} \\<union>\n                   map_minsky Suc id M))\\<^sup>* \\<and>\n          Q vs vs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> fst ` ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)", "by (auto simp: map_minsky_def)"], ["proof (state)\nthis:\n  0 \\<notin> fst ` ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n\ngoal (1 subgoal):\n 1. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  ({(1, Dec v 2 0)} \\<union>\n                   map_minsky Suc id M))\\<^sup>* \\<and>\n          Q vs vs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  ({(1, Dec v 2 0)} \\<union>\n                   map_minsky Suc id M))\\<^sup>* \\<and>\n          Q vs vs'", "case (4 vs)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>vs.\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  ({(1, Dec v 2 0)} \\<union>\n                   map_minsky Suc id M))\\<^sup>* \\<and>\n          Q vs vs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       ((Suc 0, vs), 0, vs')\n       \\<in> (step\n               ({(1, Dec v 2 0)} \\<union>\n                map_minsky Suc id M))\\<^sup>* \\<and>\n       Q vs vs'", "proof (induct \"vs v\" arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       0 = vs v \\<Longrightarrow>\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  ({(1, Dec v 2 0)} \\<union>\n                   map_minsky Suc id M))\\<^sup>* \\<and>\n          Q vs vs'\n 2. \\<And>x vs.\n       \\<lbrakk>\\<And>vs.\n                   x = vs v \\<Longrightarrow>\n                   \\<exists>vs'.\n                      ((Suc 0, vs), 0, vs')\n                      \\<in> (step\n                              ({(1, Dec v 2 0)} \\<union>\n                               map_minsky Suc id M))\\<^sup>* \\<and>\n                      Q vs vs';\n        Suc x = vs v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((Suc 0, vs), 0, vs')\n                            \\<in> (step\n                                    ({(1, Dec v 2 0)} \\<union>\n                                     map_minsky Suc id M))\\<^sup>* \\<and>\n                            Q vs vs'", "case 0"], ["proof (state)\nthis:\n  0 = vs v\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       0 = vs v \\<Longrightarrow>\n       \\<exists>vs'.\n          ((Suc 0, vs), 0, vs')\n          \\<in> (step\n                  ({(1, Dec v 2 0)} \\<union>\n                   map_minsky Suc id M))\\<^sup>* \\<and>\n          Q vs vs'\n 2. \\<And>x vs.\n       \\<lbrakk>\\<And>vs.\n                   x = vs v \\<Longrightarrow>\n                   \\<exists>vs'.\n                      ((Suc 0, vs), 0, vs')\n                      \\<in> (step\n                              ({(1, Dec v 2 0)} \\<union>\n                               map_minsky Suc id M))\\<^sup>* \\<and>\n                      Q vs vs';\n        Suc x = vs v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((Suc 0, vs), 0, vs')\n                            \\<in> (step\n                                    ({(1, Dec v 2 0)} \\<union>\n                                     map_minsky Suc id M))\\<^sup>* \\<and>\n                            Q vs vs'", "then"], ["proof (chain)\npicking this:\n  0 = vs v", "show ?case"], ["proof (prove)\nusing this:\n  0 = vs v\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       ((Suc 0, vs), 0, vs')\n       \\<in> (step\n               ({(1, Dec v 2 0)} \\<union>\n                map_minsky Suc id M))\\<^sup>* \\<and>\n       Q vs vs'", "using assms(3)[of vs] step.decz[of 1 v 2 0 ?M vs]"], ["proof (prove)\nusing this:\n  0 = vs v\n  vs v = 0 \\<Longrightarrow> Q vs vs\n  \\<lbrakk>(1, Dec v 2 0)\n           \\<in> {(1, Dec v 2 0)} \\<union> map_minsky Suc id M;\n   vs v = 0\\<rbrakk>\n  \\<Longrightarrow> ((1, vs), 0, vs)\n                    \\<in> step\n                           ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M)\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       ((Suc 0, vs), 0, vs')\n       \\<in> (step\n               ({(1, Dec v 2 0)} \\<union>\n                map_minsky Suc id M))\\<^sup>* \\<and>\n       Q vs vs'", "by (auto simp: id_def)"], ["proof (state)\nthis:\n  \\<exists>vs'.\n     ((Suc 0, vs), 0, vs')\n     \\<in> (step\n             ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M))\\<^sup>* \\<and>\n     Q vs vs'\n\ngoal (1 subgoal):\n 1. \\<And>x vs.\n       \\<lbrakk>\\<And>vs.\n                   x = vs v \\<Longrightarrow>\n                   \\<exists>vs'.\n                      ((Suc 0, vs), 0, vs')\n                      \\<in> (step\n                              ({(1, Dec v 2 0)} \\<union>\n                               map_minsky Suc id M))\\<^sup>* \\<and>\n                      Q vs vs';\n        Suc x = vs v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((Suc 0, vs), 0, vs')\n                            \\<in> (step\n                                    ({(1, Dec v 2 0)} \\<union>\n                                     map_minsky Suc id M))\\<^sup>* \\<and>\n                            Q vs vs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x vs.\n       \\<lbrakk>\\<And>vs.\n                   x = vs v \\<Longrightarrow>\n                   \\<exists>vs'.\n                      ((Suc 0, vs), 0, vs')\n                      \\<in> (step\n                              ({(1, Dec v 2 0)} \\<union>\n                               map_minsky Suc id M))\\<^sup>* \\<and>\n                      Q vs vs';\n        Suc x = vs v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((Suc 0, vs), 0, vs')\n                            \\<in> (step\n                                    ({(1, Dec v 2 0)} \\<union>\n                                     map_minsky Suc id M))\\<^sup>* \\<and>\n                            Q vs vs'", "case (Suc n)"], ["proof (state)\nthis:\n  n = ?vs v \\<Longrightarrow>\n  \\<exists>vs'.\n     ((Suc 0, ?vs), 0, vs')\n     \\<in> (step\n             ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M))\\<^sup>* \\<and>\n     Q ?vs vs'\n  Suc n = vs v\n\ngoal (1 subgoal):\n 1. \\<And>x vs.\n       \\<lbrakk>\\<And>vs.\n                   x = vs v \\<Longrightarrow>\n                   \\<exists>vs'.\n                      ((Suc 0, vs), 0, vs')\n                      \\<in> (step\n                              ({(1, Dec v 2 0)} \\<union>\n                               map_minsky Suc id M))\\<^sup>* \\<and>\n                      Q vs vs';\n        Suc x = vs v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((Suc 0, vs), 0, vs')\n                            \\<in> (step\n                                    ({(1, Dec v 2 0)} \\<union>\n                                     map_minsky Suc id M))\\<^sup>* \\<and>\n                            Q vs vs'", "obtain vs' where M': \"((Suc 0, \\<lambda>x. if x = v then n else vs x), 0, vs') \\<in> (step M)\\<^sup>*\"\n        \"P (\\<lambda>x. if x = v then n else vs x) vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs'.\n        \\<lbrakk>((Suc 0, \\<lambda>x. if x = v then n else vs x), 0, vs')\n                 \\<in> (step M)\\<^sup>*;\n         P (\\<lambda>x. if x = v then n else vs x) vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using M(4)"], ["proof (prove)\nusing this:\n  \\<exists>vs'.\n     ((Suc 0, ?vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and> P ?vs vs'\n\ngoal (1 subgoal):\n 1. (\\<And>vs'.\n        \\<lbrakk>((Suc 0, \\<lambda>x. if x = v then n else vs x), 0, vs')\n                 \\<in> (step M)\\<^sup>*;\n         P (\\<lambda>x. if x = v then n else vs x) vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ((Suc 0, \\<lambda>x. if x = v then n else vs x), 0, vs')\n  \\<in> (step M)\\<^sup>*\n  P (\\<lambda>x. if x = v then n else vs x) vs'\n\ngoal (1 subgoal):\n 1. \\<And>x vs.\n       \\<lbrakk>\\<And>vs.\n                   x = vs v \\<Longrightarrow>\n                   \\<exists>vs'.\n                      ((Suc 0, vs), 0, vs')\n                      \\<in> (step\n                              ({(1, Dec v 2 0)} \\<union>\n                               map_minsky Suc id M))\\<^sup>* \\<and>\n                      Q vs vs';\n        Suc x = vs v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((Suc 0, vs), 0, vs')\n                            \\<in> (step\n                                    ({(1, Dec v 2 0)} \\<union>\n                                     map_minsky Suc id M))\\<^sup>* \\<and>\n                            Q vs vs'", "obtain vs'' where D: \"((Suc 0, vs'), 0, vs'') \\<in> (step ?M)\\<^sup>*\" \"Q vs' vs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs''.\n        \\<lbrakk>((Suc 0, vs'), 0, vs'')\n                 \\<in> (step\n                         ({(1, Dec v 2 0)} \\<union>\n                          map_minsky Suc id M))\\<^sup>*;\n         Q vs' vs''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc(1)[of vs'] assms(2)[OF M'(2)]"], ["proof (prove)\nusing this:\n  n = vs' v \\<Longrightarrow>\n  \\<exists>vs'a.\n     ((Suc 0, vs'), 0, vs'a)\n     \\<in> (step\n             ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M))\\<^sup>* \\<and>\n     Q vs' vs'a\n  vs' v = (if v = v then n else vs v)\n\ngoal (1 subgoal):\n 1. (\\<And>vs''.\n        \\<lbrakk>((Suc 0, vs'), 0, vs'')\n                 \\<in> (step\n                         ({(1, Dec v 2 0)} \\<union>\n                          map_minsky Suc id M))\\<^sup>*;\n         Q vs' vs''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ((Suc 0, vs'), 0, vs'')\n  \\<in> (step ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M))\\<^sup>*\n  Q vs' vs''\n\ngoal (1 subgoal):\n 1. \\<And>x vs.\n       \\<lbrakk>\\<And>vs.\n                   x = vs v \\<Longrightarrow>\n                   \\<exists>vs'.\n                      ((Suc 0, vs), 0, vs')\n                      \\<in> (step\n                              ({(1, Dec v 2 0)} \\<union>\n                               map_minsky Suc id M))\\<^sup>* \\<and>\n                      Q vs vs';\n        Suc x = vs v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((Suc 0, vs), 0, vs')\n                            \\<in> (step\n                                    ({(1, Dec v 2 0)} \\<union>\n                                     map_minsky Suc id M))\\<^sup>* \\<and>\n                            Q vs vs'", "note * = subsetD[OF steps_mono, of _ ?M]\n        r_into_rtrancl[OF decn[of \"Suc 0\" v 2 0 ?M vs n]]\n        map_steps[OF _ _ M'(1), of id _ Suc, simplified, OF refl, simplified, folded numeral_2_eq_2]"], ["proof (state)\nthis:\n  \\<lbrakk>?M1 \\<subseteq> {(1, Dec v 2 0)} \\<union> map_minsky Suc id M;\n   ?c \\<in> (step ?M1)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> (step\n                               ({(1, Dec v 2 0)} \\<union>\n                                map_minsky Suc id M))\\<^sup>*\n  \\<lbrakk>(Suc 0, Dec v 2 0)\n           \\<in> {(1, Dec v 2 0)} \\<union> map_minsky Suc id M;\n   vs v = Suc n\\<rbrakk>\n  \\<Longrightarrow> ((Suc 0, vs), 2, \\<lambda>x. if x = v then n else vs x)\n                    \\<in> (step\n                            ({(1, Dec v 2 0)} \\<union>\n                             map_minsky Suc id M))\\<^sup>*\n  ((2, \\<lambda>x. if x = v then n else vs x), Suc 0, vs')\n  \\<in> (step (map_minsky Suc id M))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x vs.\n       \\<lbrakk>\\<And>vs.\n                   x = vs v \\<Longrightarrow>\n                   \\<exists>vs'.\n                      ((Suc 0, vs), 0, vs')\n                      \\<in> (step\n                              ({(1, Dec v 2 0)} \\<union>\n                               map_minsky Suc id M))\\<^sup>* \\<and>\n                      Q vs vs';\n        Suc x = vs v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((Suc 0, vs), 0, vs')\n                            \\<in> (step\n                                    ({(1, Dec v 2 0)} \\<union>\n                                     map_minsky Suc id M))\\<^sup>* \\<and>\n                            Q vs vs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       ((Suc 0, vs), 0, vs')\n       \\<in> (step\n               ({(1, Dec v 2 0)} \\<union>\n                map_minsky Suc id M))\\<^sup>* \\<and>\n       Q vs vs'", "using rtrancl_trans[OF rtrancl_trans, OF *(2) *(1)[OF _ *(3)] D(1)]\n        D(2) Suc(2) assms(4)[OF _ M'(2), of vs'']"], ["proof (prove)\nusing this:\n  \\<lbrakk>(Suc 0, Dec v 2 0)\n           \\<in> {(1, Dec v 2 0)} \\<union> map_minsky Suc id M;\n   vs v = Suc n;\n   map_minsky Suc id M\n   \\<subseteq> {(1, Dec v 2 0)} \\<union> map_minsky Suc id M\\<rbrakk>\n  \\<Longrightarrow> ((Suc 0, vs), 0, vs'')\n                    \\<in> (step\n                            ({(1, Dec v 2 0)} \\<union>\n                             map_minsky Suc id M))\\<^sup>*\n  Q vs' vs''\n  Suc n = vs v\n  \\<lbrakk>vs v = Suc n; Q vs' vs''\\<rbrakk> \\<Longrightarrow> Q vs vs''\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       ((Suc 0, vs), 0, vs')\n       \\<in> (step\n               ({(1, Dec v 2 0)} \\<union>\n                map_minsky Suc id M))\\<^sup>* \\<and>\n       Q vs vs'", "by auto"], ["proof (state)\nthis:\n  \\<exists>vs'.\n     ((Suc 0, vs), 0, vs')\n     \\<in> (step\n             ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M))\\<^sup>* \\<and>\n     Q vs vs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>vs'.\n     ((Suc 0, vs), 0, vs')\n     \\<in> (step\n             ({(1, Dec v 2 0)} \\<union> map_minsky Suc id M))\\<^sup>* \\<and>\n     Q vs vs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mk_minsky Q\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Copying values\\<close>"], ["", "text \\<open>We work up to copying values in several steps.\n\\begin{enumerate}\n\\item Clear a register. This is a loop that decrements the register until it reaches $0$.\n\\item Add a register to another one. This is a loop that decrements one register, and increments\n  the other register, until the first register reaches 0.\n\\item Add a register to two others. This is the same, except that two registers are incremented.\n\\item Move a register: set a register to 0, then add another register to it.\n\\item Copy a register destructively: clear two registers, then add another register to them.\n\\end{enumerate}\\<close>"], ["", "lemma mk_minsky_zero:\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then 0 else vs x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then 0 else vs x))", "by (intro mk_minsky_loop[where v = v, OF \\<comment> \\<open> while v[v]$--$: \\<close>\n    mk_minsky_nop]) auto                   \\<comment> \\<open>   pass          \\<close>"], ["", "lemma mk_minsky_add1:\n  assumes \"v \\<noteq> w\"\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then 0 else if x = w then vs v + vs w else vs x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' =\n         (\\<lambda>x.\n             if x = v then 0 else if x = w then vs v + vs w else vs x))", "using assms"], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' =\n         (\\<lambda>x.\n             if x = v then 0 else if x = w then vs v + vs w else vs x))", "by (intro mk_minsky_loop[where v = v, OF \\<comment> \\<open> while v[v]$--$: \\<close>\n    mk_minsky_inc[of w]]) auto                         \\<comment> \\<open>   v[w]++        \\<close>"], ["", "lemma mk_minsky_add2:\n  assumes \"u \\<noteq> v\" \"u \\<noteq> w\" \"v \\<noteq> w\"\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' =\n    (\\<lambda>x. if x = u then 0 else if x = v then vs u + vs v else if x = w then vs u + vs w else vs x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' =\n         (\\<lambda>x.\n             if x = u then 0\n             else if x = v then vs u + vs v\n                  else if x = w then vs u + vs w else vs x))", "using assms"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<noteq> w\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' =\n         (\\<lambda>x.\n             if x = u then 0\n             else if x = v then vs u + vs v\n                  else if x = w then vs u + vs w else vs x))", "by (intro mk_minsky_loop[where v = u, OF mk_minsky_seq'[OF \\<comment> \\<open> while v[u]$--$: \\<close>\n    mk_minsky_inc[of v]                                                  \\<comment> \\<open>   v[v]++        \\<close>\n    mk_minsky_inc[of w]]]) auto                                          \\<comment> \\<open>   v[w]++        \\<close>"], ["", "lemma mk_minsky_copy1:\n  assumes \"v \\<noteq> w\"\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then 0 else if x = w then vs v else vs x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' =\n         (\\<lambda>x. if x = v then 0 else if x = w then vs v else vs x))", "using assms"], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' =\n         (\\<lambda>x. if x = v then 0 else if x = w then vs v else vs x))", "by (intro mk_minsky_seq[OF\n    mk_minsky_zero[of w]          \\<comment> \\<open> v[w] := 0                      \\<close>\n    mk_minsky_add1[of v w]]) auto \\<comment> \\<open> v[w] := v[w] + v[v], v[v] := 0 \\<close>"], ["", "lemma mk_minsky_copy2:\n  assumes \"u \\<noteq> v\" \"u \\<noteq> w\" \"v \\<noteq> w\"\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' =\n    (\\<lambda>x. if x = u then 0 else if x = v then vs u else if x = w then vs u else vs x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' =\n         (\\<lambda>x.\n             if x = u then 0\n             else if x = v then vs u else if x = w then vs u else vs x))", "using assms"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<noteq> w\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' =\n         (\\<lambda>x.\n             if x = u then 0\n             else if x = v then vs u else if x = w then vs u else vs x))", "by (intro mk_minsky_seq[OF mk_minsky_seq', OF\n    mk_minsky_zero[of v]            \\<comment> \\<open> v[v] := 0                                           \\<close>\n    mk_minsky_zero[of w]            \\<comment> \\<open> v[w] := 0                                           \\<close>\n    mk_minsky_add2[of u v w]]) auto \\<comment> \\<open> v[v] := v[v] + v[u], v[w] := v[w] + v[u], v[u] := 0 \\<close>"], ["", "lemma mk_minsky_copy:\n  assumes \"u \\<noteq> v\" \"u \\<noteq> w\" \"v \\<noteq> w\"\n  shows \"mk_minsky (\\<lambda>vs vs'. vs' = (\\<lambda>x. if x = v then vs u else if x = w then 0 else vs x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' =\n         (\\<lambda>x. if x = v then vs u else if x = w then 0 else vs x))", "using assms"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  u \\<noteq> w\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' =\n         (\\<lambda>x. if x = v then vs u else if x = w then 0 else vs x))", "by (intro mk_minsky_seq[OF\n    mk_minsky_copy2[of u v w]      \\<comment> \\<open> v[v] := v[u], v[w] := v[u], v[u] := 0 \\<close>\n    mk_minsky_copy1[of w u]]) auto \\<comment> \\<open> v[u] := v[w], v[w] := 0               \\<close>"], ["", "subsection \\<open>Primitive recursive functions\\<close>"], ["", "text \\<open>Nondestructive apply: compute $f$ on arguments $\\alpha[u]$, $\\alpha[v]$, $\\alpha[w]$,\nstoring the result in $\\alpha[t]$ and preserving all other registers below $k$. This is easy\nnow that we can copy values.\\<close>"], ["", "lemma mk_minsky_apply3:\n  assumes \"mk_minsky3 f\" \"t < k\" \"u < k\" \"v < k\" \"w < k\"\n  shows \"mk_minsky (\\<lambda>vs vs'. \\<forall>x < k. vs' x = (if x = t then f (vs u) (vs v) (vs w) else vs x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         \\<forall>x<k.\n            vs' x = (if x = t then f (vs u) (vs v) (vs w) else vs x))", "using assms(2-)"], ["proof (prove)\nusing this:\n  t < k\n  u < k\n  v < k\n  w < k\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         \\<forall>x<k.\n            vs' x = (if x = t then f (vs u) (vs v) (vs w) else vs x))", "by (intro mk_minsky_seq[OF mk_minsky_seq'[OF mk_minsky_seq'], OF\n    mk_minsky_copy[of u \"1 + k\" k] \\<comment> \\<open> v[1+k] := v[u] \\<close>\n    mk_minsky_copy[of v \"2 + k\" k] \\<comment> \\<open> v[2+k] := v[v] \\<close>\n    mk_minsky_copy[of w \"3 + k\" k] \\<comment> \\<open> v[3+k] := v[w] \\<close>\n    mk_minsky_map[OF assms(1), of \"\\<lambda>x. if x = 0 then t else x + k\"]]) (auto 0 2)\n                                   \\<comment> \\<open> v[t] := f v[1+k] v[2+k] v[3+k] \\<close>"], ["", "text \\<open>Composition is just four non-destructive applies.\\<close>"], ["", "lemma mk_minsky_comp3_3:\n  assumes \"mk_minsky3 f\" \"mk_minsky3 g\" \"mk_minsky3 h\" \"mk_minsky3 k\"\n  shows \"mk_minsky3 (\\<lambda>x y z. f (g x y z) (h x y z) (k x y z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' 0 =\n         f (g (vs 1) (vs 2) (vs 3)) (h (vs 1) (vs 2) (vs 3))\n          (k (vs 1) (vs 2) (vs 3)))", "by (rule mk_minsky_seq[OF mk_minsky_seq'[OF mk_minsky_seq'], OF\n    mk_minsky_apply3[OF assms(2), of 4 7 1 2 3]        \\<comment> \\<open> v[4] := g v[1] v[2] v[3] \\<close>\n    mk_minsky_apply3[OF assms(3), of 5 7 1 2 3]        \\<comment> \\<open> v[5] := h v[1] v[2] v[3] \\<close>\n    mk_minsky_apply3[OF assms(4), of 6 7 1 2 3]        \\<comment> \\<open> v[6] := k v[1] v[2] v[3] \\<close>\n    mk_minsky_apply3[OF assms(1), of 0 7 4 5 6]]) auto \\<comment> \\<open> v[0] := f v[4] v[5] v[6] \\<close>"], ["", "text \\<open>Primitive recursion is a non-destructive apply followed by a loop with another\nnon-destructive apply. The key to the proof is the loop invariant, which we can specify\nas part of composing the various \\<open>mk_minsky_*\\<close> lemmas.\\<close>"], ["", "lemma mk_minsky_prim_rec:\n  assumes \"mk_minsky1 g\" \"mk_minsky3 h\"\n  shows \"mk_minsky2 (PrimRecOp g h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky2 (PrimRecOp g h)", "by (intro mk_minsky_seq[OF mk_minsky_seq', OF\n    mk_minsky_apply3[OF assms(1), of 0 4 2 2 2]       \\<comment> \\<open> v[0] := g v[2]             \\<close>\n    mk_minsky_zero[of 3]                              \\<comment> \\<open> v[3] := 0                  \\<close>\n    mk_minsky_loop[where v = 1, OF mk_minsky_seq', OF \\<comment> \\<open> while v[1]$--$:            \\<close>\n      mk_minsky_apply3[OF assms(2), of 0 4 3 0 2]     \\<comment> \\<open>   v[0] := h v[3] v[0] v[2] \\<close>\n      mk_minsky_inc[of 3],                            \\<comment> \\<open>   v[3]++                   \\<close>\n      of \"\\<lambda>vs vs'. vs 0 = PrimRecOp g h (vs 3) (vs 2) \\<longrightarrow> vs' 0 = PrimRecOp g h (vs 3 + vs 1) (vs 2)\"\n    ]]) auto"], ["", "text \\<open>With these building blocks we can easily show that all primitive recursive functions can\nbe realized by a Minsky machine.\\<close>"], ["", "lemma mk_minsky_PrimRec:\n  \"f \\<in> PrimRec1 \\<Longrightarrow> mk_minsky1 f\"\n  \"g \\<in> PrimRec2 \\<Longrightarrow> mk_minsky2 g\"\n  \"h \\<in> PrimRec3 \\<Longrightarrow> mk_minsky3 h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<in> PrimRec1 \\<Longrightarrow> mk_minsky1 f) &&&\n    (g \\<in> PrimRec2 \\<Longrightarrow> mk_minsky2 g) &&&\n    (h \\<in> PrimRec3 \\<Longrightarrow> mk_minsky3 h)", "proof (goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. f \\<in> PrimRec1 \\<Longrightarrow> mk_minsky1 f\n 2. g \\<in> PrimRec2 \\<Longrightarrow> mk_minsky2 g\n 3. h \\<in> PrimRec3 \\<Longrightarrow> mk_minsky3 h", "have *: \"(f \\<in> PrimRec1 \\<longrightarrow> mk_minsky1 f) \\<and> (g \\<in> PrimRec2 \\<longrightarrow> mk_minsky2 g) \\<and> (h \\<in> PrimRec3 \\<longrightarrow> mk_minsky3 h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<in> PrimRec1 \\<longrightarrow> mk_minsky1 f) \\<and>\n    (g \\<in> PrimRec2 \\<longrightarrow> mk_minsky2 g) \\<and>\n    (h \\<in> PrimRec3 \\<longrightarrow> mk_minsky3 h)", "proof (induction rule: PrimRec1_PrimRec2_PrimRec3.induct)"], ["proof (state)\ngoal (18 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = 0)\n 2. mk_minsky1 Suc\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 4. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 5. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 6. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 7. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 8. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 9. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 10. \\<And>f g.\n        \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n         mk_minsky2 g\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\nA total of 18 subgoals...", "case zero"], ["proof (state)\nthis:\n  \n\ngoal (18 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = 0)\n 2. mk_minsky1 Suc\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 4. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 5. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 6. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 7. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 8. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 9. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 10. \\<And>f g.\n        \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n         mk_minsky2 g\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\nA total of 18 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = 0)", "by (intro mk_minsky_mono[OF mk_minsky_zero]) auto"], ["proof (state)\nthis:\n  mk_minsky (\\<lambda>vs vs'. vs' 0 = 0)\n\ngoal (17 subgoals):\n 1. mk_minsky1 Suc\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 4. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 5. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 6. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 7. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 8. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 9. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 10. \\<And>f g.\n        \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n         mk_minsky3 g\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. mk_minsky1 Suc\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 4. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 5. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 6. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 7. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 8. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 9. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 10. \\<And>f g.\n        \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n         mk_minsky3 g\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\nA total of 17 subgoals...", "case suc"], ["proof (state)\nthis:\n  \n\ngoal (17 subgoals):\n 1. mk_minsky1 Suc\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 4. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 5. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 6. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 7. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 8. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 9. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 10. \\<And>f g.\n        \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n         mk_minsky3 g\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\nA total of 17 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky1 Suc", "by (intro mk_minsky_seq[OF mk_minsky_copy1[of 1 0] mk_minsky_inc[of 0]]) auto"], ["proof (state)\nthis:\n  mk_minsky1 Suc\n\ngoal (16 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 4. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 5. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 6. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 7. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 8. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 9. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 10. \\<And>f g h.\n        \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n         mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 = f (g (vs 1)) (h (vs 1)))\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 4. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 5. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 6. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 7. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 8. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 9. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 10. \\<And>f g h.\n        \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n         mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 = f (g (vs 1)) (h (vs 1)))\nA total of 16 subgoals...", "case id1_1"], ["proof (state)\nthis:\n  \n\ngoal (16 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 4. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 5. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 6. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 7. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 8. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 9. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 10. \\<And>f g h.\n        \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n         mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 = f (g (vs 1)) (h (vs 1)))\nA total of 16 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)", "by (intro mk_minsky_mono[OF mk_minsky_copy1[of 1 0]]) auto"], ["proof (state)\nthis:\n  mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n\ngoal (15 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 4. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 5. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 6. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 7. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 8. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 9. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 10. \\<And>f g h k.\n        \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n         mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n         mk_minsky1 k\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 4. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 5. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 6. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 7. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 8. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 9. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 10. \\<And>f g h k.\n        \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n         mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n         mk_minsky1 k\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\nA total of 15 subgoals...", "case id2_1"], ["proof (state)\nthis:\n  \n\ngoal (15 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 4. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 5. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 6. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 7. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 8. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 9. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 10. \\<And>f g h k.\n        \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n         mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n         mk_minsky1 k\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\nA total of 15 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)", "by (intro mk_minsky_mono[OF mk_minsky_copy1[of 1 0]]) auto"], ["proof (state)\nthis:\n  mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n\ngoal (14 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 4. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 5. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 6. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 7. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 8. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 9. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 10. \\<And>f g h.\n        \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n         mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 =\n                               f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 4. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 5. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 6. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 7. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 8. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 9. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 10. \\<And>f g h.\n        \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n         mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 =\n                               f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\nA total of 14 subgoals...", "case id2_2"], ["proof (state)\nthis:\n  \n\ngoal (14 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 4. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 5. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 6. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 7. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 8. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 9. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 10. \\<And>f g h.\n        \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n         mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 =\n                               f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\nA total of 14 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)", "by (intro mk_minsky_mono[OF mk_minsky_copy1[of 2 0]]) auto"], ["proof (state)\nthis:\n  mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n\ngoal (13 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 4. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 5. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 6. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 7. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 8. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 9. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 10. \\<And>f g h.\n        \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n         mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 =\n                               f (g (vs 1) (vs 2) (vs 3))\n                                (h (vs 1) (vs 2) (vs 3)))\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 4. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 5. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 6. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 7. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 8. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 9. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 10. \\<And>f g h.\n        \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n         mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 =\n                               f (g (vs 1) (vs 2) (vs 3))\n                                (h (vs 1) (vs 2) (vs 3)))\nA total of 13 subgoals...", "case id3_1"], ["proof (state)\nthis:\n  \n\ngoal (13 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 3. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 4. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 5. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 6. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 7. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 8. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 9. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 10. \\<And>f g h.\n        \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n         mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 =\n                               f (g (vs 1) (vs 2) (vs 3))\n                                (h (vs 1) (vs 2) (vs 3)))\nA total of 13 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)", "by (intro mk_minsky_mono[OF mk_minsky_copy1[of 1 0]]) auto"], ["proof (state)\nthis:\n  mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 1)\n\ngoal (12 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 3. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 4. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 5. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 6. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 7. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 8. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 9. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 10. \\<And>f g h k.\n        \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n         mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n         mk_minsky2 k\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 =\n                               f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                                (k (vs 1) (vs 2)))\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 3. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 4. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 5. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 6. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 7. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 8. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 9. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 10. \\<And>f g h k.\n        \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n         mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n         mk_minsky2 k\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 =\n                               f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                                (k (vs 1) (vs 2)))\nA total of 12 subgoals...", "case id3_2"], ["proof (state)\nthis:\n  \n\ngoal (12 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n 2. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 3. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 4. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 5. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 6. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 7. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 8. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 9. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 10. \\<And>f g h k.\n        \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n         mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n         mk_minsky2 k\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 =\n                               f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                                (k (vs 1) (vs 2)))\nA total of 12 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)", "by (intro mk_minsky_mono[OF mk_minsky_copy1[of 2 0]]) auto"], ["proof (state)\nthis:\n  mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 2)\n\ngoal (11 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 3. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 4. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 5. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 6. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 7. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 8. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 9. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 10. \\<And>f g h k.\n        \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n         mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n         mk_minsky3 k\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 =\n                               f (g (vs 1) (vs 2) (vs 3))\n                                (h (vs 1) (vs 2) (vs 3))\n                                (k (vs 1) (vs 2) (vs 3)))\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 3. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 4. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 5. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 6. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 7. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 8. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 9. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 10. \\<And>f g h k.\n        \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n         mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n         mk_minsky3 k\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 =\n                               f (g (vs 1) (vs 2) (vs 3))\n                                (h (vs 1) (vs 2) (vs 3))\n                                (k (vs 1) (vs 2) (vs 3)))\nA total of 11 subgoals...", "case id3_3"], ["proof (state)\nthis:\n  \n\ngoal (11 subgoals):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 3. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 4. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 5. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 6. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 7. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 8. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 9. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 10. \\<And>f g h k.\n        \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n         mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n         mk_minsky3 k\\<rbrakk>\n        \\<Longrightarrow> mk_minsky\n                           (\\<lambda>vs vs'.\n                               vs' 0 =\n                               f (g (vs 1) (vs 2) (vs 3))\n                                (h (vs 1) (vs 2) (vs 3))\n                                (k (vs 1) (vs 2) (vs 3)))\nA total of 11 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)", "by (intro mk_minsky_mono[OF mk_minsky_copy1[of 3 0]]) auto"], ["proof (state)\nthis:\n  mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 3)\n\ngoal (10 subgoals):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 3. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 4. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 5. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 6. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 7. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 8. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 9. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 10. \\<And>g h.\n        \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n         mk_minsky3 h\\<rbrakk>\n        \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 3. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 4. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 5. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 6. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 7. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 8. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 9. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 10. \\<And>g h.\n        \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n         mk_minsky3 h\\<rbrakk>\n        \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "case (comp1_1 f g)"], ["proof (state)\nthis:\n  f \\<in> PrimRec1\n  g \\<in> PrimRec1\n  mk_minsky1 f\n  mk_minsky1 g\n\ngoal (10 subgoals):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec1;\n        mk_minsky1 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 3. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 4. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 5. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 6. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 7. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 8. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 9. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 10. \\<And>g h.\n        \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n         mk_minsky3 h\\<rbrakk>\n        \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "then"], ["proof (chain)\npicking this:\n  f \\<in> PrimRec1\n  g \\<in> PrimRec1\n  mk_minsky1 f\n  mk_minsky1 g", "show ?case"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec1\n  g \\<in> PrimRec1\n  mk_minsky1 f\n  mk_minsky1 g\n\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))", "using mk_minsky_comp3_3"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec1\n  g \\<in> PrimRec1\n  mk_minsky1 f\n  mk_minsky1 g\n  \\<lbrakk>mk_minsky3 ?f; mk_minsky3 ?g; mk_minsky3 ?h;\n   mk_minsky3 ?k\\<rbrakk>\n  \\<Longrightarrow> mk_minsky\n                     (\\<lambda>vs vs'.\n                         vs' 0 =\n                         ?f (?g (vs 1) (vs 2) (vs 3))\n                          (?h (vs 1) (vs 2) (vs 3))\n                          (?k (vs 1) (vs 2) (vs 3)))\n\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))", "by fast"], ["proof (state)\nthis:\n  mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)))\n\ngoal (9 subgoals):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 3. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 4. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 5. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 6. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 7. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 8. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 9. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 3. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 4. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 5. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 6. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 7. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 8. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 9. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "case (comp1_2 f g)"], ["proof (state)\nthis:\n  f \\<in> PrimRec1\n  g \\<in> PrimRec2\n  mk_minsky1 f\n  mk_minsky2 g\n\ngoal (9 subgoals):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec2;\n        mk_minsky2 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 3. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 4. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 5. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 6. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 7. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 8. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 9. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "then"], ["proof (chain)\npicking this:\n  f \\<in> PrimRec1\n  g \\<in> PrimRec2\n  mk_minsky1 f\n  mk_minsky2 g", "show ?case"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec1\n  g \\<in> PrimRec2\n  mk_minsky1 f\n  mk_minsky2 g\n\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))", "using mk_minsky_comp3_3"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec1\n  g \\<in> PrimRec2\n  mk_minsky1 f\n  mk_minsky2 g\n  \\<lbrakk>mk_minsky3 ?f; mk_minsky3 ?g; mk_minsky3 ?h;\n   mk_minsky3 ?k\\<rbrakk>\n  \\<Longrightarrow> mk_minsky\n                     (\\<lambda>vs vs'.\n                         vs' 0 =\n                         ?f (?g (vs 1) (vs 2) (vs 3))\n                          (?h (vs 1) (vs 2) (vs 3))\n                          (?k (vs 1) (vs 2) (vs 3)))\n\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))", "by fast"], ["proof (state)\nthis:\n  mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)))\n\ngoal (8 subgoals):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 2. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 3. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 4. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 5. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 6. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 7. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 8. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 2. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 3. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 4. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 5. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 6. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 7. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 8. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "case (comp1_3 f g)"], ["proof (state)\nthis:\n  f \\<in> PrimRec1\n  g \\<in> PrimRec3\n  mk_minsky1 f\n  mk_minsky3 g\n\ngoal (8 subgoals):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> PrimRec1; mk_minsky1 f; g \\<in> PrimRec3;\n        mk_minsky3 g\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n 2. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 3. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 4. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 5. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 6. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 7. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 8. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "then"], ["proof (chain)\npicking this:\n  f \\<in> PrimRec1\n  g \\<in> PrimRec3\n  mk_minsky1 f\n  mk_minsky3 g", "show ?case"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec1\n  g \\<in> PrimRec3\n  mk_minsky1 f\n  mk_minsky3 g\n\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2) (vs 3)))", "using mk_minsky_comp3_3"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec1\n  g \\<in> PrimRec3\n  mk_minsky1 f\n  mk_minsky3 g\n  \\<lbrakk>mk_minsky3 ?f; mk_minsky3 ?g; mk_minsky3 ?h;\n   mk_minsky3 ?k\\<rbrakk>\n  \\<Longrightarrow> mk_minsky\n                     (\\<lambda>vs vs'.\n                         vs' 0 =\n                         ?f (?g (vs 1) (vs 2) (vs 3))\n                          (?h (vs 1) (vs 2) (vs 3))\n                          (?k (vs 1) (vs 2) (vs 3)))\n\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2) (vs 3)))", "by fast"], ["proof (state)\nthis:\n  mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2) (vs 3)))\n\ngoal (7 subgoals):\n 1. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 2. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 3. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 4. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 5. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 6. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 7. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 2. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 3. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 4. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 5. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 6. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 7. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "case (comp2_1 f g h)"], ["proof (state)\nthis:\n  f \\<in> PrimRec2\n  g \\<in> PrimRec1\n  h \\<in> PrimRec1\n  mk_minsky2 f\n  mk_minsky1 g\n  mk_minsky1 h\n\ngoal (7 subgoals):\n 1. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n 2. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 3. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 4. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 5. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 6. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 7. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "then"], ["proof (chain)\npicking this:\n  f \\<in> PrimRec2\n  g \\<in> PrimRec1\n  h \\<in> PrimRec1\n  mk_minsky2 f\n  mk_minsky1 g\n  mk_minsky1 h", "show ?case"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec2\n  g \\<in> PrimRec1\n  h \\<in> PrimRec1\n  mk_minsky2 f\n  mk_minsky1 g\n  mk_minsky1 h\n\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))", "using mk_minsky_comp3_3"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec2\n  g \\<in> PrimRec1\n  h \\<in> PrimRec1\n  mk_minsky2 f\n  mk_minsky1 g\n  mk_minsky1 h\n  \\<lbrakk>mk_minsky3 ?f; mk_minsky3 ?g; mk_minsky3 ?h;\n   mk_minsky3 ?k\\<rbrakk>\n  \\<Longrightarrow> mk_minsky\n                     (\\<lambda>vs vs'.\n                         vs' 0 =\n                         ?f (?g (vs 1) (vs 2) (vs 3))\n                          (?h (vs 1) (vs 2) (vs 3))\n                          (?k (vs 1) (vs 2) (vs 3)))\n\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))", "by fast"], ["proof (state)\nthis:\n  mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)))\n\ngoal (6 subgoals):\n 1. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 2. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 3. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 4. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 5. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 6. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 2. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 3. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 4. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 5. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 6. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "case (comp3_1 f g h k)"], ["proof (state)\nthis:\n  f \\<in> PrimRec3\n  g \\<in> PrimRec1\n  h \\<in> PrimRec1\n  k \\<in> PrimRec1\n  mk_minsky3 f\n  mk_minsky1 g\n  mk_minsky1 h\n  mk_minsky1 k\n\ngoal (6 subgoals):\n 1. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec1;\n        mk_minsky1 g; h \\<in> PrimRec1; mk_minsky1 h; k \\<in> PrimRec1;\n        mk_minsky1 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n 2. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 3. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 4. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 5. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 6. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "then"], ["proof (chain)\npicking this:\n  f \\<in> PrimRec3\n  g \\<in> PrimRec1\n  h \\<in> PrimRec1\n  k \\<in> PrimRec1\n  mk_minsky3 f\n  mk_minsky1 g\n  mk_minsky1 h\n  mk_minsky1 k", "show ?case"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec3\n  g \\<in> PrimRec1\n  h \\<in> PrimRec1\n  k \\<in> PrimRec1\n  mk_minsky3 f\n  mk_minsky1 g\n  mk_minsky1 h\n  mk_minsky1 k\n\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))", "using mk_minsky_comp3_3"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec3\n  g \\<in> PrimRec1\n  h \\<in> PrimRec1\n  k \\<in> PrimRec1\n  mk_minsky3 f\n  mk_minsky1 g\n  mk_minsky1 h\n  mk_minsky1 k\n  \\<lbrakk>mk_minsky3 ?f; mk_minsky3 ?g; mk_minsky3 ?h;\n   mk_minsky3 ?k\\<rbrakk>\n  \\<Longrightarrow> mk_minsky\n                     (\\<lambda>vs vs'.\n                         vs' 0 =\n                         ?f (?g (vs 1) (vs 2) (vs 3))\n                          (?h (vs 1) (vs 2) (vs 3))\n                          (?k (vs 1) (vs 2) (vs 3)))\n\ngoal (1 subgoal):\n 1. mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))", "by fast"], ["proof (state)\nthis:\n  mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1)) (h (vs 1)) (k (vs 1)))\n\ngoal (5 subgoals):\n 1. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 2. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 3. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 4. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 5. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 2. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 3. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 4. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 5. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "case (comp2_2 f g h)"], ["proof (state)\nthis:\n  f \\<in> PrimRec2\n  g \\<in> PrimRec2\n  h \\<in> PrimRec2\n  mk_minsky2 f\n  mk_minsky2 g\n  mk_minsky2 h\n\ngoal (5 subgoals):\n 1. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n 2. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 3. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 4. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 5. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "then"], ["proof (chain)\npicking this:\n  f \\<in> PrimRec2\n  g \\<in> PrimRec2\n  h \\<in> PrimRec2\n  mk_minsky2 f\n  mk_minsky2 g\n  mk_minsky2 h", "show ?case"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec2\n  g \\<in> PrimRec2\n  h \\<in> PrimRec2\n  mk_minsky2 f\n  mk_minsky2 g\n  mk_minsky2 h\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))", "using mk_minsky_comp3_3"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec2\n  g \\<in> PrimRec2\n  h \\<in> PrimRec2\n  mk_minsky2 f\n  mk_minsky2 g\n  mk_minsky2 h\n  \\<lbrakk>mk_minsky3 ?f; mk_minsky3 ?g; mk_minsky3 ?h;\n   mk_minsky3 ?k\\<rbrakk>\n  \\<Longrightarrow> mk_minsky\n                     (\\<lambda>vs vs'.\n                         vs' 0 =\n                         ?f (?g (vs 1) (vs 2) (vs 3))\n                          (?h (vs 1) (vs 2) (vs 3))\n                          (?k (vs 1) (vs 2) (vs 3)))\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))", "by fast"], ["proof (state)\nthis:\n  mk_minsky (\\<lambda>vs vs'. vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)))\n\ngoal (4 subgoals):\n 1. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 2. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 3. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 4. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 2. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 3. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 4. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "case (comp2_3 f g h)"], ["proof (state)\nthis:\n  f \\<in> PrimRec2\n  g \\<in> PrimRec3\n  h \\<in> PrimRec3\n  mk_minsky2 f\n  mk_minsky3 g\n  mk_minsky3 h\n\ngoal (4 subgoals):\n 1. \\<And>f g h.\n       \\<lbrakk>f \\<in> PrimRec2; mk_minsky2 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3)))\n 2. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 3. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 4. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "then"], ["proof (chain)\npicking this:\n  f \\<in> PrimRec2\n  g \\<in> PrimRec3\n  h \\<in> PrimRec3\n  mk_minsky2 f\n  mk_minsky3 g\n  mk_minsky3 h", "show ?case"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec2\n  g \\<in> PrimRec3\n  h \\<in> PrimRec3\n  mk_minsky2 f\n  mk_minsky3 g\n  mk_minsky3 h\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' 0 = f (g (vs 1) (vs 2) (vs 3)) (h (vs 1) (vs 2) (vs 3)))", "using mk_minsky_comp3_3"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec2\n  g \\<in> PrimRec3\n  h \\<in> PrimRec3\n  mk_minsky2 f\n  mk_minsky3 g\n  mk_minsky3 h\n  \\<lbrakk>mk_minsky3 ?f; mk_minsky3 ?g; mk_minsky3 ?h;\n   mk_minsky3 ?k\\<rbrakk>\n  \\<Longrightarrow> mk_minsky\n                     (\\<lambda>vs vs'.\n                         vs' 0 =\n                         ?f (?g (vs 1) (vs 2) (vs 3))\n                          (?h (vs 1) (vs 2) (vs 3))\n                          (?k (vs 1) (vs 2) (vs 3)))\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' 0 = f (g (vs 1) (vs 2) (vs 3)) (h (vs 1) (vs 2) (vs 3)))", "by fast"], ["proof (state)\nthis:\n  mk_minsky\n   (\\<lambda>vs vs'.\n       vs' 0 = f (g (vs 1) (vs 2) (vs 3)) (h (vs 1) (vs 2) (vs 3)))\n\ngoal (3 subgoals):\n 1. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 2. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 3. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 2. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 3. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "case (comp3_2 f g h k)"], ["proof (state)\nthis:\n  f \\<in> PrimRec3\n  g \\<in> PrimRec2\n  h \\<in> PrimRec2\n  k \\<in> PrimRec2\n  mk_minsky3 f\n  mk_minsky2 g\n  mk_minsky2 h\n  mk_minsky2 k\n\ngoal (3 subgoals):\n 1. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec2;\n        mk_minsky2 g; h \\<in> PrimRec2; mk_minsky2 h; k \\<in> PrimRec2;\n        mk_minsky2 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2)) (h (vs 1) (vs 2))\n                               (k (vs 1) (vs 2)))\n 2. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 3. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "then"], ["proof (chain)\npicking this:\n  f \\<in> PrimRec3\n  g \\<in> PrimRec2\n  h \\<in> PrimRec2\n  k \\<in> PrimRec2\n  mk_minsky3 f\n  mk_minsky2 g\n  mk_minsky2 h\n  mk_minsky2 k", "show ?case"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec3\n  g \\<in> PrimRec2\n  h \\<in> PrimRec2\n  k \\<in> PrimRec2\n  mk_minsky3 f\n  mk_minsky2 g\n  mk_minsky2 h\n  mk_minsky2 k\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)) (k (vs 1) (vs 2)))", "using mk_minsky_comp3_3"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec3\n  g \\<in> PrimRec2\n  h \\<in> PrimRec2\n  k \\<in> PrimRec2\n  mk_minsky3 f\n  mk_minsky2 g\n  mk_minsky2 h\n  mk_minsky2 k\n  \\<lbrakk>mk_minsky3 ?f; mk_minsky3 ?g; mk_minsky3 ?h;\n   mk_minsky3 ?k\\<rbrakk>\n  \\<Longrightarrow> mk_minsky\n                     (\\<lambda>vs vs'.\n                         vs' 0 =\n                         ?f (?g (vs 1) (vs 2) (vs 3))\n                          (?h (vs 1) (vs 2) (vs 3))\n                          (?k (vs 1) (vs 2) (vs 3)))\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)) (k (vs 1) (vs 2)))", "by fast"], ["proof (state)\nthis:\n  mk_minsky\n   (\\<lambda>vs vs'.\n       vs' 0 = f (g (vs 1) (vs 2)) (h (vs 1) (vs 2)) (k (vs 1) (vs 2)))\n\ngoal (2 subgoals):\n 1. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 2. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 2. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "case (comp3_3 f g h k)"], ["proof (state)\nthis:\n  f \\<in> PrimRec3\n  g \\<in> PrimRec3\n  h \\<in> PrimRec3\n  k \\<in> PrimRec3\n  mk_minsky3 f\n  mk_minsky3 g\n  mk_minsky3 h\n  mk_minsky3 k\n\ngoal (2 subgoals):\n 1. \\<And>f g h k.\n       \\<lbrakk>f \\<in> PrimRec3; mk_minsky3 f; g \\<in> PrimRec3;\n        mk_minsky3 g; h \\<in> PrimRec3; mk_minsky3 h; k \\<in> PrimRec3;\n        mk_minsky3 k\\<rbrakk>\n       \\<Longrightarrow> mk_minsky\n                          (\\<lambda>vs vs'.\n                              vs' 0 =\n                              f (g (vs 1) (vs 2) (vs 3))\n                               (h (vs 1) (vs 2) (vs 3))\n                               (k (vs 1) (vs 2) (vs 3)))\n 2. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "then"], ["proof (chain)\npicking this:\n  f \\<in> PrimRec3\n  g \\<in> PrimRec3\n  h \\<in> PrimRec3\n  k \\<in> PrimRec3\n  mk_minsky3 f\n  mk_minsky3 g\n  mk_minsky3 h\n  mk_minsky3 k", "show ?case"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec3\n  g \\<in> PrimRec3\n  h \\<in> PrimRec3\n  k \\<in> PrimRec3\n  mk_minsky3 f\n  mk_minsky3 g\n  mk_minsky3 h\n  mk_minsky3 k\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' 0 =\n         f (g (vs 1) (vs 2) (vs 3)) (h (vs 1) (vs 2) (vs 3))\n          (k (vs 1) (vs 2) (vs 3)))", "using mk_minsky_comp3_3"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec3\n  g \\<in> PrimRec3\n  h \\<in> PrimRec3\n  k \\<in> PrimRec3\n  mk_minsky3 f\n  mk_minsky3 g\n  mk_minsky3 h\n  mk_minsky3 k\n  \\<lbrakk>mk_minsky3 ?f; mk_minsky3 ?g; mk_minsky3 ?h;\n   mk_minsky3 ?k\\<rbrakk>\n  \\<Longrightarrow> mk_minsky\n                     (\\<lambda>vs vs'.\n                         vs' 0 =\n                         ?f (?g (vs 1) (vs 2) (vs 3))\n                          (?h (vs 1) (vs 2) (vs 3))\n                          (?k (vs 1) (vs 2) (vs 3)))\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' 0 =\n         f (g (vs 1) (vs 2) (vs 3)) (h (vs 1) (vs 2) (vs 3))\n          (k (vs 1) (vs 2) (vs 3)))", "by fast"], ["proof (state)\nthis:\n  mk_minsky\n   (\\<lambda>vs vs'.\n       vs' 0 =\n       f (g (vs 1) (vs 2) (vs 3)) (h (vs 1) (vs 2) (vs 3))\n        (k (vs 1) (vs 2) (vs 3)))\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "case (prim_rec g h)"], ["proof (state)\nthis:\n  g \\<in> PrimRec1\n  h \\<in> PrimRec3\n  mk_minsky1 g\n  mk_minsky3 h\n\ngoal (1 subgoal):\n 1. \\<And>g h.\n       \\<lbrakk>g \\<in> PrimRec1; mk_minsky1 g; h \\<in> PrimRec3;\n        mk_minsky3 h\\<rbrakk>\n       \\<Longrightarrow> mk_minsky2 (PrimRecOp g h)", "then"], ["proof (chain)\npicking this:\n  g \\<in> PrimRec1\n  h \\<in> PrimRec3\n  mk_minsky1 g\n  mk_minsky3 h", "show ?case"], ["proof (prove)\nusing this:\n  g \\<in> PrimRec1\n  h \\<in> PrimRec3\n  mk_minsky1 g\n  mk_minsky3 h\n\ngoal (1 subgoal):\n 1. mk_minsky2 (PrimRecOp g h)", "using mk_minsky_prim_rec"], ["proof (prove)\nusing this:\n  g \\<in> PrimRec1\n  h \\<in> PrimRec3\n  mk_minsky1 g\n  mk_minsky3 h\n  \\<lbrakk>mk_minsky1 ?g; mk_minsky3 ?h\\<rbrakk>\n  \\<Longrightarrow> mk_minsky2 (PrimRecOp ?g ?h)\n\ngoal (1 subgoal):\n 1. mk_minsky2 (PrimRecOp g h)", "by blast"], ["proof (state)\nthis:\n  mk_minsky2 (PrimRecOp g h)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f \\<in> PrimRec1 \\<longrightarrow> mk_minsky1 f) \\<and>\n  (g \\<in> PrimRec2 \\<longrightarrow> mk_minsky2 g) \\<and>\n  (h \\<in> PrimRec3 \\<longrightarrow> mk_minsky3 h)\n\ngoal (3 subgoals):\n 1. f \\<in> PrimRec1 \\<Longrightarrow> mk_minsky1 f\n 2. g \\<in> PrimRec2 \\<Longrightarrow> mk_minsky2 g\n 3. h \\<in> PrimRec3 \\<Longrightarrow> mk_minsky3 h", "{"], ["proof (state)\nthis:\n  (f \\<in> PrimRec1 \\<longrightarrow> mk_minsky1 f) \\<and>\n  (g \\<in> PrimRec2 \\<longrightarrow> mk_minsky2 g) \\<and>\n  (h \\<in> PrimRec3 \\<longrightarrow> mk_minsky3 h)\n\ngoal (3 subgoals):\n 1. f \\<in> PrimRec1 \\<Longrightarrow> mk_minsky1 f\n 2. g \\<in> PrimRec2 \\<Longrightarrow> mk_minsky2 g\n 3. h \\<in> PrimRec3 \\<Longrightarrow> mk_minsky3 h", "case 1"], ["proof (state)\nthis:\n  f \\<in> PrimRec1\n\ngoal (3 subgoals):\n 1. f \\<in> PrimRec1 \\<Longrightarrow> mk_minsky1 f\n 2. g \\<in> PrimRec2 \\<Longrightarrow> mk_minsky2 g\n 3. h \\<in> PrimRec3 \\<Longrightarrow> mk_minsky3 h", "thus ?case"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec1\n\ngoal (1 subgoal):\n 1. mk_minsky1 f", "using *"], ["proof (prove)\nusing this:\n  f \\<in> PrimRec1\n  (f \\<in> PrimRec1 \\<longrightarrow> mk_minsky1 f) \\<and>\n  (g \\<in> PrimRec2 \\<longrightarrow> mk_minsky2 g) \\<and>\n  (h \\<in> PrimRec3 \\<longrightarrow> mk_minsky3 h)\n\ngoal (1 subgoal):\n 1. mk_minsky1 f", "by blast"], ["proof (state)\nthis:\n  mk_minsky1 f\n\ngoal (2 subgoals):\n 1. g \\<in> PrimRec2 \\<Longrightarrow> mk_minsky2 g\n 2. h \\<in> PrimRec3 \\<Longrightarrow> mk_minsky3 h", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. g \\<in> PrimRec2 \\<Longrightarrow> mk_minsky2 g\n 2. h \\<in> PrimRec3 \\<Longrightarrow> mk_minsky3 h", "case 2"], ["proof (state)\nthis:\n  g \\<in> PrimRec2\n\ngoal (2 subgoals):\n 1. g \\<in> PrimRec2 \\<Longrightarrow> mk_minsky2 g\n 2. h \\<in> PrimRec3 \\<Longrightarrow> mk_minsky3 h", "thus ?case"], ["proof (prove)\nusing this:\n  g \\<in> PrimRec2\n\ngoal (1 subgoal):\n 1. mk_minsky2 g", "using *"], ["proof (prove)\nusing this:\n  g \\<in> PrimRec2\n  (f \\<in> PrimRec1 \\<longrightarrow> mk_minsky1 f) \\<and>\n  (g \\<in> PrimRec2 \\<longrightarrow> mk_minsky2 g) \\<and>\n  (h \\<in> PrimRec3 \\<longrightarrow> mk_minsky3 h)\n\ngoal (1 subgoal):\n 1. mk_minsky2 g", "by blast"], ["proof (state)\nthis:\n  mk_minsky2 g\n\ngoal (1 subgoal):\n 1. h \\<in> PrimRec3 \\<Longrightarrow> mk_minsky3 h", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. h \\<in> PrimRec3 \\<Longrightarrow> mk_minsky3 h", "case 3"], ["proof (state)\nthis:\n  h \\<in> PrimRec3\n\ngoal (1 subgoal):\n 1. h \\<in> PrimRec3 \\<Longrightarrow> mk_minsky3 h", "thus ?case"], ["proof (prove)\nusing this:\n  h \\<in> PrimRec3\n\ngoal (1 subgoal):\n 1. mk_minsky3 h", "using *"], ["proof (prove)\nusing this:\n  h \\<in> PrimRec3\n  (f \\<in> PrimRec1 \\<longrightarrow> mk_minsky1 f) \\<and>\n  (g \\<in> PrimRec2 \\<longrightarrow> mk_minsky2 g) \\<and>\n  (h \\<in> PrimRec3 \\<longrightarrow> mk_minsky3 h)\n\ngoal (1 subgoal):\n 1. mk_minsky3 h", "by blast"], ["proof (state)\nthis:\n  mk_minsky3 h\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  h \\<in> PrimRec3 \\<Longrightarrow> mk_minsky3 h\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Recursively enumerable sets as Minsky machines\\<close>"], ["", "text \\<open>The following is the most complicated lemma of this theory: Given two r.e.\\ sets $A$ and $B$\nwe want to construct a Minsky machine that reaches the final state $0$ for input $x$ if $x \\in A$\nand final state $1$ if $x \\in B$, and never reaches either of these states if $x \\notin A \\cup B$.\n(If $x \\in A \\cap B$, then either state $0$ or state $1$ may be reached.) We consider two\nr.e.\\ sets rather than one because we target recursive inseparability.\n\nFor the r.e.\\ set $A$, there is a primitive recursive function $f$ such that\n$x \\in A \\iff \\exists y.\\, f(x,y) = 0$. Similarly there is a primitive recursive function $g$ for\n$B$ such that $x \\in B \\iff \\exists y.\\, f(x,y) = 0$. Our Minsky machine takes $x$ in register\n$0$ and $y$ in register $1$ (initially $0$) and works as follows.\n\\begin{enumerate}\n\\item evaluate $f(x,y)$; if the result is $0$, transition to state $0$; otherwise,\n\\item evaluate $g(x,y)$; if the result is $0$, transition to state $1$; otherwise,\n\\item increment $y$ and start over.\n\\end{enumerate}\\<close>"], ["", "lemma ce_set_pair_by_minsky:\n  assumes \"A \\<in> ce_sets\" \"B \\<in> ce_sets\"\n  obtains M :: \"(nat, nat) minsky\" where\n    \"finite M\" \"deterministic M\" \"0 \\<notin> fst ` M\" \"Suc 0 \\<notin> fst ` M\"\n    \"\\<And>x vs. vs 0 = x \\<Longrightarrow> vs 1 = 0 \\<Longrightarrow> x \\<in> A \\<union> B \\<Longrightarrow>\n     \\<exists>vs'. ((2, vs), (0, vs')) \\<in> (step M)\\<^sup>* \\<or> ((2, vs), (Suc 0, vs')) \\<in> (step M)\\<^sup>*\"\n    \"\\<And>x vs vs'. vs 0 = x \\<Longrightarrow> vs 1 = 0 \\<Longrightarrow> ((2, vs), (0, vs')) \\<in> (step M)\\<^sup>* \\<Longrightarrow> x \\<in> A\"\n    \"\\<And>x vs vs'. vs 0 = x \\<Longrightarrow> vs 1 = 0 \\<Longrightarrow> ((2, vs), (Suc 0, vs')) \\<in> (step M)\\<^sup>* \\<Longrightarrow> x \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain g where g: \"g \\<in> PrimRec2\" \"\\<And>x. x \\<in> A \\<longleftrightarrow> (\\<exists>y. g x y = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> PrimRec2;\n         \\<And>x. (x \\<in> A) = (\\<exists>y. g x y = 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  A \\<in> ce_sets\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> PrimRec2;\n         \\<And>x. (x \\<in> A) = (\\<exists>y. g x y = 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: ce_sets_def fn_to_set_def)"], ["proof (state)\nthis:\n  g \\<in> PrimRec2\n  (?x \\<in> A) = (\\<exists>y. g ?x y = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain h where h: \"h \\<in> PrimRec2\" \"\\<And>x. x \\<in> B \\<longleftrightarrow> (\\<exists>y. h x y = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<in> PrimRec2;\n         \\<And>x. (x \\<in> B) = (\\<exists>y. h x y = 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  B \\<in> ce_sets\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<in> PrimRec2;\n         \\<And>x. (x \\<in> B) = (\\<exists>y. h x y = 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: ce_sets_def fn_to_set_def)"], ["proof (state)\nthis:\n  h \\<in> PrimRec2\n  (?x \\<in> B) = (\\<exists>y. h ?x y = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 0 \\<and> vs' 1 = vs 1 \\<and> vs' 2 = g (vs 0) (vs 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' 0 = vs 0 \\<and> vs' 1 = vs 1 \\<and> vs' 2 = g (vs 0) (vs 1))", "using mk_minsky_seq[OF\n      mk_minsky_apply3[OF mk_minsky_PrimRec(2)[OF g(1)], of 2 3 0 1 0] \\<comment> \\<open> v[2] := g v[0] v[1] \\<close>\n      mk_minsky_nop]"], ["proof (prove)\nusing this:\n  \\<lbrakk>2 < 3; 0 < 3; 1 < 3; 0 < 3;\n   \\<And>vs vs' vs''.\n      \\<lbrakk>\\<forall>x<3.\n                  vs' x = (if x = 2 then g (vs 0) (vs 1) else vs x);\n       vs' = vs''\\<rbrakk>\n      \\<Longrightarrow> ?R vs vs''\\<rbrakk>\n  \\<Longrightarrow> mk_minsky ?R\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' 0 = vs 0 \\<and> vs' 1 = vs 1 \\<and> vs' 2 = g (vs 0) (vs 1))", "by auto                                           \\<comment> \\<open> pass                \\<close>"], ["proof (state)\nthis:\n  mk_minsky\n   (\\<lambda>vs vs'.\n       vs' 0 = vs 0 \\<and> vs' 1 = vs 1 \\<and> vs' 2 = g (vs 0) (vs 1))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  mk_minsky\n   (\\<lambda>vs vs'.\n       vs' 0 = vs 0 \\<and> vs' 1 = vs 1 \\<and> vs' 2 = g (vs 0) (vs 1))", "obtain M :: \"(nat, nat) minsky\" where M: \"finite M\" \"deterministic M\" \"0 \\<notin> fst ` M\"\n    \"\\<And>vs. \\<exists>vs'. ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and>\n    vs' 0 = vs 0 \\<and> vs' 1 = vs 1 \\<and> vs' 2 = g (vs 0) (vs 1)\""], ["proof (prove)\nusing this:\n  mk_minsky\n   (\\<lambda>vs vs'.\n       vs' 0 = vs 0 \\<and> vs' 1 = vs 1 \\<and> vs' 2 = g (vs 0) (vs 1))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         \\<And>vs.\n            \\<exists>vs'.\n               ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and>\n               vs' 0 = vs 0 \\<and>\n               vs' 1 = vs 1 \\<and> vs' 2 = g (vs 0) (vs 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mk_minsky_def"], ["proof (prove)\nusing this:\n  \\<exists>M.\n     finite M \\<and>\n     deterministic M \\<and>\n     0 \\<notin> fst ` M \\<and>\n     (\\<forall>vs.\n         \\<exists>vs'.\n            ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and>\n            vs' 0 = vs 0 \\<and> vs' 1 = vs 1 \\<and> vs' 2 = g (vs 0) (vs 1))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         \\<And>vs.\n            \\<exists>vs'.\n               ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and>\n               vs' 0 = vs 0 \\<and>\n               vs' 1 = vs 1 \\<and> vs' 2 = g (vs 0) (vs 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite M\n  deterministic M\n  0 \\<notin> fst ` M\n  \\<exists>vs'.\n     ((Suc 0, ?vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and>\n     vs' 0 = ?vs 0 \\<and> vs' 1 = ?vs 1 \\<and> vs' 2 = g (?vs 0) (?vs 1)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"mk_minsky (\\<lambda>vs vs'. vs' 0 = vs 0 \\<and> vs' 1 = vs 1 + 1 \\<and> vs' 2 = h (vs 0) (vs 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' 0 = vs 0 \\<and>\n         vs' 1 = vs 1 + 1 \\<and> vs' 2 = h (vs 0) (vs 1))", "using mk_minsky_seq[OF\n      mk_minsky_apply3[OF mk_minsky_PrimRec(2)[OF h(1)], of 2 3 0 1 0] \\<comment> \\<open> v[2] := h v[0] v[1] \\<close>\n      mk_minsky_inc[of 1]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>2 < 3; 0 < 3; 1 < 3; 0 < 3;\n   \\<And>vs vs' vs''.\n      \\<lbrakk>\\<forall>x<3.\n                  vs' x = (if x = 2 then h (vs 0) (vs 1) else vs x);\n       vs'' = (\\<lambda>x. if x = 1 then Suc (vs' 1) else vs' x)\\<rbrakk>\n      \\<Longrightarrow> ?R vs vs''\\<rbrakk>\n  \\<Longrightarrow> mk_minsky ?R\n\ngoal (1 subgoal):\n 1. mk_minsky\n     (\\<lambda>vs vs'.\n         vs' 0 = vs 0 \\<and>\n         vs' 1 = vs 1 + 1 \\<and> vs' 2 = h (vs 0) (vs 1))", "by auto                                     \\<comment> \\<open> v[1] := v[1] + 1    \\<close>"], ["proof (state)\nthis:\n  mk_minsky\n   (\\<lambda>vs vs'.\n       vs' 0 = vs 0 \\<and> vs' 1 = vs 1 + 1 \\<and> vs' 2 = h (vs 0) (vs 1))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  mk_minsky\n   (\\<lambda>vs vs'.\n       vs' 0 = vs 0 \\<and> vs' 1 = vs 1 + 1 \\<and> vs' 2 = h (vs 0) (vs 1))", "obtain N :: \"(nat, nat) minsky\" where N: \"finite N\" \"deterministic N\" \"0 \\<notin> fst ` N\"\n    \"\\<And>vs. \\<exists>vs'. ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>* \\<and>\n    vs' 0 = vs 0 \\<and> vs' 1 = vs 1 + 1 \\<and> vs' 2 = h (vs 0) (vs 1)\""], ["proof (prove)\nusing this:\n  mk_minsky\n   (\\<lambda>vs vs'.\n       vs' 0 = vs 0 \\<and> vs' 1 = vs 1 + 1 \\<and> vs' 2 = h (vs 0) (vs 1))\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>finite N; deterministic N; 0 \\<notin> fst ` N;\n         \\<And>vs.\n            \\<exists>vs'.\n               ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>* \\<and>\n               vs' 0 = vs 0 \\<and>\n               vs' 1 = vs 1 + 1 \\<and> vs' 2 = h (vs 0) (vs 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mk_minsky_def"], ["proof (prove)\nusing this:\n  \\<exists>M.\n     finite M \\<and>\n     deterministic M \\<and>\n     0 \\<notin> fst ` M \\<and>\n     (\\<forall>vs.\n         \\<exists>vs'.\n            ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and>\n            vs' 0 = vs 0 \\<and>\n            vs' 1 = vs 1 + 1 \\<and> vs' 2 = h (vs 0) (vs 1))\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>finite N; deterministic N; 0 \\<notin> fst ` N;\n         \\<And>vs.\n            \\<exists>vs'.\n               ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>* \\<and>\n               vs' 0 = vs 0 \\<and>\n               vs' 1 = vs 1 + 1 \\<and> vs' 2 = h (vs 0) (vs 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite N\n  deterministic N\n  0 \\<notin> fst ` N\n  \\<exists>vs'.\n     ((Suc 0, ?vs), 0, vs') \\<in> (step N)\\<^sup>* \\<and>\n     vs' 0 = ?vs 0 \\<and> vs' 1 = ?vs 1 + 1 \\<and> vs' 2 = h (?vs 0) (?vs 1)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?f = \"\\<lambda>s. if s = 0 then 3 else 2 * s\" \\<comment> \\<open>M: from state 4 to state 3\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?g = \"\\<lambda>s. 2 * s + 5\"                  \\<comment> \\<open>N: from state 7 to state 5\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define X where \"X = map_minsky ?f id M \\<union> map_minsky ?g id N \\<union> {(3, Dec 2 7 0)} \\<union> {(5, Dec 2 2 1)}\""], ["proof (state)\nthis:\n  X =\n  map_minsky (\\<lambda>s. if s = 0 then 3 else 2 * s) id M \\<union>\n  map_minsky (\\<lambda>s. 2 * s + 5) id N \\<union>\n  {(3, Dec 2 7 0)} \\<union>\n  {(5, Dec 2 2 1)}\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have MX: \"map_minsky ?f id M \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_minsky (\\<lambda>s. if s = 0 then 3 else 2 * s) id M \\<subseteq> X", "by (auto simp: X_def)"], ["proof (state)\nthis:\n  map_minsky (\\<lambda>s. if s = 0 then 3 else 2 * s) id M \\<subseteq> X\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have NX: \"map_minsky ?g id N \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_minsky (\\<lambda>s. 2 * s + 5) id N \\<subseteq> X", "by (auto simp: X_def)"], ["proof (state)\nthis:\n  map_minsky (\\<lambda>s. 2 * s + 5) id N \\<subseteq> X\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have DX: \"(3, Dec 2 7 0) \\<in> X\" \"(5, Dec 2 2 1) \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (3, Dec 2 7 0) \\<in> X &&& (5, Dec 2 2 1) \\<in> X", "by (auto simp: X_def)"], ["proof (state)\nthis:\n  (3, Dec 2 7 0) \\<in> X\n  (5, Dec 2 2 1) \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have X1: \"finite X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X", "using M(1) N(1)"], ["proof (prove)\nusing this:\n  finite M\n  finite N\n\ngoal (1 subgoal):\n 1. finite X", "by (auto simp: map_minsky_def X_def)"], ["proof (state)\nthis:\n  finite X\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have X2: \"deterministic X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic X", "unfolding X_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic\n     (map_minsky (\\<lambda>s. if s = 0 then 3 else 2 * s) id M \\<union>\n      map_minsky (\\<lambda>s. 2 * s + 5) id N \\<union>\n      {(3, Dec 2 7 0)} \\<union>\n      {(5, Dec 2 2 1)})", "using M(2,3) N(2,3)"], ["proof (prove)\nusing this:\n  deterministic M\n  0 \\<notin> fst ` M\n  deterministic N\n  0 \\<notin> fst ` N\n\ngoal (1 subgoal):\n 1. deterministic\n     (map_minsky (\\<lambda>s. if s = 0 then 3 else 2 * s) id M \\<union>\n      map_minsky (\\<lambda>s. 2 * s + 5) id N \\<union>\n      {(3, Dec 2 7 0)} \\<union>\n      {(5, Dec 2 2 1)})", "apply (intro deterministic_union)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>deterministic M; 0 \\<notin> fst ` M; deterministic N;\n     0 \\<notin> fst ` N\\<rbrakk>\n    \\<Longrightarrow> fst `\n                      (map_minsky (\\<lambda>s. if s = 0 then 3 else 2 * s)\n                        id M \\<union>\n                       map_minsky (\\<lambda>s. 2 * s + 5) id N \\<union>\n                       {(3, Dec 2 7 0)}) \\<inter>\n                      fst ` {(5, Dec 2 2 1)} =\n                      {}\n 2. \\<lbrakk>deterministic M; 0 \\<notin> fst ` M; deterministic N;\n     0 \\<notin> fst ` N\\<rbrakk>\n    \\<Longrightarrow> fst `\n                      (map_minsky (\\<lambda>s. if s = 0 then 3 else 2 * s)\n                        id M \\<union>\n                       map_minsky (\\<lambda>s. 2 * s + 5) id N) \\<inter>\n                      fst ` {(3, Dec 2 7 0)} =\n                      {}\n 3. \\<lbrakk>deterministic M; 0 \\<notin> fst ` M; deterministic N;\n     0 \\<notin> fst ` N\\<rbrakk>\n    \\<Longrightarrow> fst `\n                      map_minsky (\\<lambda>s. if s = 0 then 3 else 2 * s) id\n                       M \\<inter>\n                      fst ` map_minsky (\\<lambda>s. 2 * s + 5) id N =\n                      {}\n 4. \\<lbrakk>deterministic M; 0 \\<notin> fst ` M; deterministic N;\n     0 \\<notin> fst ` N\\<rbrakk>\n    \\<Longrightarrow> deterministic\n                       (map_minsky (\\<lambda>s. if s = 0 then 3 else 2 * s)\n                         id M)\n 5. \\<lbrakk>deterministic M; 0 \\<notin> fst ` M; deterministic N;\n     0 \\<notin> fst ` N\\<rbrakk>\n    \\<Longrightarrow> deterministic\n                       (map_minsky (\\<lambda>s. 2 * s + 5) id N)\n 6. \\<lbrakk>deterministic M; 0 \\<notin> fst ` M; deterministic N;\n     0 \\<notin> fst ` N\\<rbrakk>\n    \\<Longrightarrow> deterministic {(3, Dec 2 7 0)}\n 7. \\<lbrakk>deterministic M; 0 \\<notin> fst ` M; deterministic N;\n     0 \\<notin> fst ` N\\<rbrakk>\n    \\<Longrightarrow> deterministic {(5, Dec 2 2 1)}", "by (auto simp: map_minsky_def rev_image_eqI inj_on_def split: if_splits\n      intro!: deterministic_map) presburger+"], ["proof (state)\nthis:\n  deterministic X\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have X3: \"0 \\<notin> fst ` X\" \"Suc 0 \\<notin> fst ` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> fst ` X &&& Suc 0 \\<notin> fst ` X", "using M(3) N(3)"], ["proof (prove)\nusing this:\n  0 \\<notin> fst ` M\n  0 \\<notin> fst ` N\n\ngoal (1 subgoal):\n 1. 0 \\<notin> fst ` X &&& Suc 0 \\<notin> fst ` X", "by (auto simp: X_def map_minsky_def split: if_splits)"], ["proof (state)\nthis:\n  0 \\<notin> fst ` X\n  Suc 0 \\<notin> fst ` X\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have X4: \"\\<exists>vs'. g (vs 0) (vs 1) = 0 \\<and> ((2, vs), (0, vs')) \\<in> (step X)\\<^sup>* \\<or>\n    h (vs 0) (vs 1) = 0 \\<and> ((2, vs), (1, vs')) \\<in> (step X)\\<^sup>* \\<or>\n    g (vs 0) (vs 1) \\<noteq> 0 \\<and> h (vs 0) (vs 1) \\<noteq> 0 \\<and> vs' 0 = vs 0 \\<and> vs' 1 = vs 1 + 1 \\<and>\n    ((2, vs), (2, vs')) \\<in> (step X)\\<^sup>+\" for vs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "guess vs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using M(4)[of vs]"], ["proof (prove)\nusing this:\n  \\<exists>vs'.\n     ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<and>\n     vs' 0 = vs 0 \\<and> vs' 1 = vs 1 \\<and> vs' 2 = g (vs 0) (vs 1)\n\ngoal (1 subgoal):\n 1. thesis", "by (elim exE conjE)"], ["proof (state)\nthis:\n  ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>*\n  vs' 0 = vs 0\n  vs' 1 = vs 1\n  vs' 2 = g (vs 0) (vs 1)\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "note vs' = this"], ["proof (state)\nthis:\n  ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>*\n  vs' 0 = vs 0\n  vs' 1 = vs 1\n  vs' 2 = g (vs 0) (vs 1)\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "have 1: \"((2, vs), (3, vs')) \\<in> (step X)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((2, vs), 3, vs') \\<in> (step X)\\<^sup>*", "using subsetD[OF steps_mono[OF MX], OF map_steps[OF _ _ vs'(1), of id vs ?f]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj id; vs = vs \\<circ> id\\<rbrakk>\n  \\<Longrightarrow> ((if Suc 0 = 0 then 3 else 2 * Suc 0, vs),\n                     if 0 = 0 then 3 else 2 * 0,\n                     \\<lambda>x.\n                        if x \\<in> range id then vs' (inv id x) else vs x)\n                    \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. ((2, vs), 3, vs') \\<in> (step X)\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  ((2, vs), 3, vs') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "proof (cases \"vs' 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. vs' 2 = 0 \\<Longrightarrow>\n    \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n 2. \\<And>nat.\n       vs' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "case 0"], ["proof (state)\nthis:\n  vs' 2 = 0\n\ngoal (2 subgoals):\n 1. vs' 2 = 0 \\<Longrightarrow>\n    \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n 2. \\<And>nat.\n       vs' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  vs' 2 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  vs' 2 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "using decz[OF DX(1), of vs'] vs' 1"], ["proof (prove)\nusing this:\n  vs' 2 = 0\n  vs' 2 = 0 \\<Longrightarrow> ((3, vs'), 0, vs') \\<in> step X\n  ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>*\n  vs' 0 = vs 0\n  vs' 1 = vs 1\n  vs' 2 = g (vs 0) (vs 1)\n  ((2, vs), 3, vs') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "by (auto intro: rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  \\<exists>vs'.\n     g (vs 0) (vs 1) = 0 \\<and>\n     ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n     h (vs 0) (vs 1) = 0 \\<and>\n     ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n     g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n     h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n     vs' 0 = vs 0 \\<and>\n     vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       vs' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       vs' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "case (Suc n)"], ["proof (state)\nthis:\n  vs' 2 = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       vs' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "note Suc' = Suc"], ["proof (state)\nthis:\n  vs' 2 = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       vs' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "let ?vs = \"\\<lambda>x. if x = 2 then n else vs' x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       vs' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "have 2: \"((2, vs), (7, ?vs)) \\<in> (step X)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((2, vs), 7, \\<lambda>x. if x = 2 then n else vs' x)\n    \\<in> (step X)\\<^sup>*", "using 1 decn[OF DX(1), of vs'] Suc"], ["proof (prove)\nusing this:\n  ((2, vs), 3, vs') \\<in> (step X)\\<^sup>*\n  vs' 2 = Suc ?n \\<Longrightarrow>\n  ((3, vs'), 7, \\<lambda>x. if x = 2 then ?n else vs' x) \\<in> step X\n  vs' 2 = Suc n\n\ngoal (1 subgoal):\n 1. ((2, vs), 7, \\<lambda>x. if x = 2 then n else vs' x)\n    \\<in> (step X)\\<^sup>*", "by (auto intro: rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  ((2, vs), 7, \\<lambda>x. if x = 2 then n else vs' x)\n  \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       vs' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "guess vs''"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using N(4)[of \"?vs\"]"], ["proof (prove)\nusing this:\n  \\<exists>vs'a.\n     ((Suc 0, \\<lambda>x. if x = 2 then n else vs' x), 0, vs'a)\n     \\<in> (step N)\\<^sup>* \\<and>\n     vs'a 0 = (if 0 = 2 then n else vs' 0) \\<and>\n     vs'a 1 = (if 1 = 2 then n else vs' 1) + 1 \\<and>\n     vs'a 2 = h (if 0 = 2 then n else vs' 0) (if 1 = 2 then n else vs' 1)\n\ngoal (1 subgoal):\n 1. thesis", "by (elim exE conjE)"], ["proof (state)\nthis:\n  ((Suc 0, \\<lambda>x. if x = 2 then n else vs' x), 0, vs'')\n  \\<in> (step N)\\<^sup>*\n  vs'' 0 = (if 0 = 2 then n else vs' 0)\n  vs'' 1 = (if 1 = 2 then n else vs' 1) + 1\n  vs'' 2 = h (if 0 = 2 then n else vs' 0) (if 1 = 2 then n else vs' 1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       vs' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "note vs'' = this"], ["proof (state)\nthis:\n  ((Suc 0, \\<lambda>x. if x = 2 then n else vs' x), 0, vs'')\n  \\<in> (step N)\\<^sup>*\n  vs'' 0 = (if 0 = 2 then n else vs' 0)\n  vs'' 1 = (if 1 = 2 then n else vs' 1) + 1\n  vs'' 2 = h (if 0 = 2 then n else vs' 0) (if 1 = 2 then n else vs' 1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       vs' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "have 3: \"((2, vs), (5, vs'')) \\<in> (step X)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((2, vs), 5, vs'') \\<in> (step X)\\<^sup>*", "using 2 subsetD[OF steps_mono[OF NX], OF map_steps[OF _ _ vs''(1), of id ?vs ?g]]"], ["proof (prove)\nusing this:\n  ((2, vs), 7, \\<lambda>x. if x = 2 then n else vs' x)\n  \\<in> (step X)\\<^sup>*\n  \\<lbrakk>inj id;\n   (\\<lambda>x. if x = 2 then n else vs' x) =\n   (\\<lambda>x. if x = 2 then n else vs' x) \\<circ> id\\<rbrakk>\n  \\<Longrightarrow> ((2 * Suc 0 + 5,\n                      \\<lambda>x. if x = 2 then n else vs' x),\n                     2 * 0 + 5,\n                     \\<lambda>x.\n                        if x \\<in> range id then vs'' (inv id x)\n                        else if x = 2 then n else vs' x)\n                    \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. ((2, vs), 5, vs'') \\<in> (step X)\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  ((2, vs), 5, vs'') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       vs' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "proof (cases \"vs'' 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. vs'' 2 = 0 \\<Longrightarrow>\n    \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n 2. \\<And>nat.\n       vs'' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "case 0"], ["proof (state)\nthis:\n  vs'' 2 = 0\n\ngoal (2 subgoals):\n 1. vs'' 2 = 0 \\<Longrightarrow>\n    \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n 2. \\<And>nat.\n       vs'' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  vs'' 2 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  vs'' 2 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "using 3 decz[OF DX(2), of vs''] vs''(2-) vs'(2-)"], ["proof (prove)\nusing this:\n  vs'' 2 = 0\n  ((2, vs), 5, vs'') \\<in> (step X)\\<^sup>*\n  vs'' 2 = 0 \\<Longrightarrow> ((5, vs''), 1, vs'') \\<in> step X\n  vs'' 0 = (if 0 = 2 then n else vs' 0)\n  vs'' 1 = (if 1 = 2 then n else vs' 1) + 1\n  vs'' 2 = h (if 0 = 2 then n else vs' 0) (if 1 = 2 then n else vs' 1)\n  vs' 0 = vs 0\n  vs' 1 = vs 1\n  vs' 2 = g (vs 0) (vs 1)\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "by (auto intro: rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  \\<exists>vs'.\n     g (vs 0) (vs 1) = 0 \\<and>\n     ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n     h (vs 0) (vs 1) = 0 \\<and>\n     ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n     g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n     h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n     vs' 0 = vs 0 \\<and>\n     vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       vs'' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       vs'' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "case (Suc m)"], ["proof (state)\nthis:\n  vs'' 2 = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       vs'' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "let ?vs = \"\\<lambda>x. if x = 2 then m else vs'' x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       vs'' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "have 4: \"((2, vs), (2, ?vs)) \\<in> (step X)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((2, vs), 2, \\<lambda>x. if x = 2 then m else vs'' x)\n    \\<in> (step X)\\<^sup>+", "using 3 decn[OF DX(2), of vs'' m] Suc"], ["proof (prove)\nusing this:\n  ((2, vs), 5, vs'') \\<in> (step X)\\<^sup>*\n  vs'' 2 = Suc m \\<Longrightarrow>\n  ((5, vs''), 2, \\<lambda>x. if x = 2 then m else vs'' x) \\<in> step X\n  vs'' 2 = Suc m\n\ngoal (1 subgoal):\n 1. ((2, vs), 2, \\<lambda>x. if x = 2 then m else vs'' x)\n    \\<in> (step X)\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  ((2, vs), 2, \\<lambda>x. if x = 2 then m else vs'' x)\n  \\<in> (step X)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       vs'' 2 = Suc nat \\<Longrightarrow>\n       \\<exists>vs'.\n          g (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n          h (vs 0) (vs 1) = 0 \\<and>\n          ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n          g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n          vs' 0 = vs 0 \\<and>\n          vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "then"], ["proof (chain)\npicking this:\n  ((2, vs), 2, \\<lambda>x. if x = 2 then m else vs'' x)\n  \\<in> (step X)\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  ((2, vs), 2, \\<lambda>x. if x = 2 then m else vs'' x)\n  \\<in> (step X)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "using vs''(2-) vs'(2-) Suc Suc'"], ["proof (prove)\nusing this:\n  ((2, vs), 2, \\<lambda>x. if x = 2 then m else vs'' x)\n  \\<in> (step X)\\<^sup>+\n  vs'' 0 = (if 0 = 2 then n else vs' 0)\n  vs'' 1 = (if 1 = 2 then n else vs' 1) + 1\n  vs'' 2 = h (if 0 = 2 then n else vs' 0) (if 1 = 2 then n else vs' 1)\n  vs' 0 = vs 0\n  vs' 1 = vs 1\n  vs' 2 = g (vs 0) (vs 1)\n  vs'' 2 = Suc m\n  vs' 2 = Suc n\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       g (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       h (vs 0) (vs 1) = 0 \\<and>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n       g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n       vs' 0 = vs 0 \\<and>\n       vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "by (auto intro!: exI[of _ ?vs])"], ["proof (state)\nthis:\n  \\<exists>vs'.\n     g (vs 0) (vs 1) = 0 \\<and>\n     ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n     h (vs 0) (vs 1) = 0 \\<and>\n     ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n     g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n     h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n     vs' 0 = vs 0 \\<and>\n     vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>vs'.\n     g (vs 0) (vs 1) = 0 \\<and>\n     ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n     h (vs 0) (vs 1) = 0 \\<and>\n     ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n     g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n     h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n     vs' 0 = vs 0 \\<and>\n     vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>vs'.\n     g (vs 0) (vs 1) = 0 \\<and>\n     ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n     h (vs 0) (vs 1) = 0 \\<and>\n     ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n     g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n     h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n     vs' 0 = vs 0 \\<and>\n     vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>vs'.\n     g (?vs2 0) (?vs2 1) = 0 \\<and>\n     ((2, ?vs2), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n     h (?vs2 0) (?vs2 1) = 0 \\<and>\n     ((2, ?vs2), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n     g (?vs2 0) (?vs2 1) \\<noteq> 0 \\<and>\n     h (?vs2 0) (?vs2 1) \\<noteq> 0 \\<and>\n     vs' 0 = ?vs2 0 \\<and>\n     vs' 1 = ?vs2 1 + 1 \\<and> ((2, ?vs2), 2, vs') \\<in> (step X)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have *: \"vs 1 \\<le> y \\<Longrightarrow> g (vs 0) y = 0 \\<or> h (vs 0) y = 0 \\<Longrightarrow>\n    \\<exists>vs'. ((2, vs), (0, vs')) \\<in> (step X)\\<^sup>* \\<or> ((2, vs), (1, vs')) \\<in> (step X)\\<^sup>*\" for vs y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs 1 \\<le> y; g (vs 0) y = 0 \\<or> h (vs 0) y = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>vs'.\n                         ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n                         ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*", "proof (induct \"vs 1\" arbitrary: vs rule: inc_induct, goal_cases base step)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>y = vs 1; g (vs 0) y = 0 \\<or> h (vs 0) y = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n                            ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*\n 2. \\<And>vsa.\n       \\<lbrakk>vs 1 \\<le> vsa 1; vsa 1 < y;\n        \\<And>vs.\n           \\<lbrakk>Suc (vsa 1) = vs 1;\n            g (vs 0) y = 0 \\<or> h (vs 0) y = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>vs'.\n                                ((2, vs), 0, vs')\n                                \\<in> (step X)\\<^sup>* \\<or>\n                                ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*;\n        g (vsa 0) y = 0 \\<or> h (vsa 0) y = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((2, vsa), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n                            ((2, vsa), 1, vs') \\<in> (step X)\\<^sup>*", "case (base vs)"], ["proof (state)\nthis:\n  y = vs 1\n  g (vs 0) y = 0 \\<or> h (vs 0) y = 0\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>y = vs 1; g (vs 0) y = 0 \\<or> h (vs 0) y = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n                            ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*\n 2. \\<And>vsa.\n       \\<lbrakk>vs__ 1 \\<le> vsa 1; vsa 1 < y;\n        \\<And>vs.\n           \\<lbrakk>Suc (vsa 1) = vs 1;\n            g (vs 0) y = 0 \\<or> h (vs 0) y = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>vs'.\n                                ((2, vs), 0, vs')\n                                \\<in> (step X)\\<^sup>* \\<or>\n                                ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*;\n        g (vsa 0) y = 0 \\<or> h (vsa 0) y = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((2, vsa), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n                            ((2, vsa), 1, vs') \\<in> (step X)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  y = vs 1\n  g (vs 0) y = 0 \\<or> h (vs 0) y = 0", "show ?case"], ["proof (prove)\nusing this:\n  y = vs 1\n  g (vs 0) y = 0 \\<or> h (vs 0) y = 0\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*", "using X4[of vs]"], ["proof (prove)\nusing this:\n  y = vs 1\n  g (vs 0) y = 0 \\<or> h (vs 0) y = 0\n  \\<exists>vs'.\n     g (vs 0) (vs 1) = 0 \\<and>\n     ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n     h (vs 0) (vs 1) = 0 \\<and>\n     ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n     g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n     h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n     vs' 0 = vs 0 \\<and>\n     vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  \\<exists>vs'.\n     ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n     ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>vsa.\n       \\<lbrakk>vs__ 1 \\<le> vsa 1; vsa 1 < y;\n        \\<And>vs.\n           \\<lbrakk>Suc (vsa 1) = vs 1;\n            g (vs 0) y = 0 \\<or> h (vs 0) y = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>vs'.\n                                ((2, vs), 0, vs')\n                                \\<in> (step X)\\<^sup>* \\<or>\n                                ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*;\n        g (vsa 0) y = 0 \\<or> h (vsa 0) y = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((2, vsa), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n                            ((2, vsa), 1, vs') \\<in> (step X)\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vsa.\n       \\<lbrakk>vs 1 \\<le> vsa 1; vsa 1 < y;\n        \\<And>vs.\n           \\<lbrakk>Suc (vsa 1) = vs 1;\n            g (vs 0) y = 0 \\<or> h (vs 0) y = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>vs'.\n                                ((2, vs), 0, vs')\n                                \\<in> (step X)\\<^sup>* \\<or>\n                                ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*;\n        g (vsa 0) y = 0 \\<or> h (vsa 0) y = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((2, vsa), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n                            ((2, vsa), 1, vs') \\<in> (step X)\\<^sup>*", "case (step vs)"], ["proof (state)\nthis:\n  vs__ 1 \\<le> vs 1\n  vs 1 < y\n  \\<lbrakk>Suc (vs 1) = ?vs2 1;\n   g (?vs2 0) y = 0 \\<or> h (?vs2 0) y = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>vs'.\n                       ((2, ?vs2), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n                       ((2, ?vs2), 1, vs') \\<in> (step X)\\<^sup>*\n  g (vs 0) y = 0 \\<or> h (vs 0) y = 0\n\ngoal (1 subgoal):\n 1. \\<And>vsa.\n       \\<lbrakk>vs__ 1 \\<le> vsa 1; vsa 1 < y;\n        \\<And>vs.\n           \\<lbrakk>Suc (vsa 1) = vs 1;\n            g (vs 0) y = 0 \\<or> h (vs 0) y = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>vs'.\n                                ((2, vs), 0, vs')\n                                \\<in> (step X)\\<^sup>* \\<or>\n                                ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*;\n        g (vsa 0) y = 0 \\<or> h (vsa 0) y = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((2, vsa), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n                            ((2, vsa), 1, vs') \\<in> (step X)\\<^sup>*", "guess vs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using X4[of vs]"], ["proof (prove)\nusing this:\n  \\<exists>vs'.\n     g (vs 0) (vs 1) = 0 \\<and>\n     ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n     h (vs 0) (vs 1) = 0 \\<and>\n     ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n     g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n     h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n     vs' 0 = vs 0 \\<and>\n     vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n\ngoal (1 subgoal):\n 1. thesis", "by (elim exE)"], ["proof (state)\nthis:\n  g (vs 0) (vs 1) = 0 \\<and> ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n  h (vs 0) (vs 1) = 0 \\<and> ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n  g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n  h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n  vs' 0 = vs 0 \\<and>\n  vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>vsa.\n       \\<lbrakk>vs__ 1 \\<le> vsa 1; vsa 1 < y;\n        \\<And>vs.\n           \\<lbrakk>Suc (vsa 1) = vs 1;\n            g (vs 0) y = 0 \\<or> h (vs 0) y = 0\\<rbrakk>\n           \\<Longrightarrow> \\<exists>vs'.\n                                ((2, vs), 0, vs')\n                                \\<in> (step X)\\<^sup>* \\<or>\n                                ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*;\n        g (vsa 0) y = 0 \\<or> h (vsa 0) y = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((2, vsa), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n                            ((2, vsa), 1, vs') \\<in> (step X)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  g (vs 0) (vs 1) = 0 \\<and> ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n  h (vs 0) (vs 1) = 0 \\<and> ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n  g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n  h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n  vs' 0 = vs 0 \\<and>\n  vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+", "show ?case"], ["proof (prove)\nusing this:\n  g (vs 0) (vs 1) = 0 \\<and> ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n  h (vs 0) (vs 1) = 0 \\<and> ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n  g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n  h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n  vs' 0 = vs 0 \\<and>\n  vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*", "unfolding ex_disj_distrib"], ["proof (prove)\nusing this:\n  g (vs 0) (vs 1) = 0 \\<and> ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n  h (vs 0) (vs 1) = 0 \\<and> ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n  g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n  h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n  vs' 0 = vs 0 \\<and>\n  vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<exists>vs'. ((2, vs), 0, vs') \\<in> (step X)\\<^sup>*) \\<or>\n    (\\<exists>vs'. ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*)", "using step(4) step(3)[of vs']"], ["proof (prove)\nusing this:\n  g (vs 0) (vs 1) = 0 \\<and> ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n  h (vs 0) (vs 1) = 0 \\<and> ((2, vs), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n  g (vs 0) (vs 1) \\<noteq> 0 \\<and>\n  h (vs 0) (vs 1) \\<noteq> 0 \\<and>\n  vs' 0 = vs 0 \\<and>\n  vs' 1 = vs 1 + 1 \\<and> ((2, vs), 2, vs') \\<in> (step X)\\<^sup>+\n  g (vs 0) y = 0 \\<or> h (vs 0) y = 0\n  \\<lbrakk>Suc (vs 1) = vs' 1;\n   g (vs' 0) y = 0 \\<or> h (vs' 0) y = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>vs'a.\n                       ((2, vs'), 0, vs'a) \\<in> (step X)\\<^sup>* \\<or>\n                       ((2, vs'), 1, vs'a) \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<exists>vs'. ((2, vs), 0, vs') \\<in> (step X)\\<^sup>*) \\<or>\n    (\\<exists>vs'. ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*)", "by (auto dest!: trancl_into_rtrancl) (meson rtrancl_trans)+"], ["proof (state)\nthis:\n  \\<exists>vs'.\n     ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n     ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?vs2 1 \\<le> ?y2;\n   g (?vs2 0) ?y2 = 0 \\<or> h (?vs2 0) ?y2 = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>vs'.\n                       ((2, ?vs2), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n                       ((2, ?vs2), 1, vs') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have **: \"((s, vs), (t, ws)) \\<in> (step X)\\<^sup>* \\<Longrightarrow> t \\<in> {0, 1} \\<Longrightarrow> ((s, vs), (2, ws')) \\<in> (step X)\\<^sup>* \\<Longrightarrow>\n    \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0\" for s t vs ws' ws"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((s, vs), t, ws) \\<in> (step X)\\<^sup>*; t \\<in> {0, 1};\n     ((s, vs), 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0", "proof (induct arbitrary: ws' rule: converse_rtrancl_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ws'.\n       \\<lbrakk>t \\<in> {0, 1};\n        ((t, ws), 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0\n 2. \\<And>a b aa ba ws'.\n       \\<lbrakk>((a, b), aa, ba) \\<in> step X;\n        ((aa, ba), t, ws) \\<in> (step X)\\<^sup>*;\n        \\<And>ws'.\n           \\<lbrakk>t \\<in> {0, 1};\n            ((aa, ba), 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y.\n                                if t = 0 then g (ws' 0) y = 0\n                                else h (ws' 0) y = 0;\n        t \\<in> {0, 1}; ((a, b), 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "case refl"], ["proof (state)\nthis:\n  t \\<in> {0, 1}\n  ((t, ws), 2, ws') \\<in> (step X)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>ws'.\n       \\<lbrakk>t \\<in> {0, 1};\n        ((t, ws), 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0\n 2. \\<And>a b aa ba ws'.\n       \\<lbrakk>((a, b), aa, ba) \\<in> step X;\n        ((aa, ba), t, ws) \\<in> (step X)\\<^sup>*;\n        \\<And>ws'.\n           \\<lbrakk>t \\<in> {0, 1};\n            ((aa, ba), 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y.\n                                if t = 0 then g (ws' 0) y = 0\n                                else h (ws' 0) y = 0;\n        t \\<in> {0, 1}; ((a, b), 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0", "using refl(1) NF_not_suc[OF refl(2) NF_stepI] X3"], ["proof (prove)\nusing this:\n  t \\<in> {0, 1}\n  t \\<notin> fst ` X \\<Longrightarrow> (t, ws) = (2, ws')\n  0 \\<notin> fst ` X\n  Suc 0 \\<notin> fst ` X\n\ngoal (1 subgoal):\n 1. \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ws'.\n       \\<lbrakk>((a, b), aa, ba) \\<in> step X;\n        ((aa, ba), t, ws) \\<in> (step X)\\<^sup>*;\n        \\<And>ws'.\n           \\<lbrakk>t \\<in> {0, 1};\n            ((aa, ba), 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y.\n                                if t = 0 then g (ws' 0) y = 0\n                                else h (ws' 0) y = 0;\n        t \\<in> {0, 1}; ((a, b), 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ws'.\n       \\<lbrakk>((a, b), aa, ba) \\<in> step X;\n        ((aa, ba), t, ws) \\<in> (step X)\\<^sup>*;\n        \\<And>ws'.\n           \\<lbrakk>t \\<in> {0, 1};\n            ((aa, ba), 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y.\n                                if t = 0 then g (ws' 0) y = 0\n                                else h (ws' 0) y = 0;\n        t \\<in> {0, 1}; ((a, b), 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "case (step s vs s' vs')"], ["proof (state)\nthis:\n  ((s, vs), s', vs') \\<in> step X\n  ((s', vs'), t, ws) \\<in> (step X)\\<^sup>*\n  \\<lbrakk>t \\<in> {0, 1};\n   ((s', vs'), 2, ?ws'2) \\<in> (step X)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y.\n                       if t = 0 then g (?ws'2 0) y = 0\n                       else h (?ws'2 0) y = 0\n  t \\<in> {0, 1}\n  ((s, vs), 2, ws') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ws'.\n       \\<lbrakk>((a, b), aa, ba) \\<in> step X;\n        ((aa, ba), t, ws) \\<in> (step X)\\<^sup>*;\n        \\<And>ws'.\n           \\<lbrakk>t \\<in> {0, 1};\n            ((aa, ba), 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n           \\<Longrightarrow> \\<exists>y.\n                                if t = 0 then g (ws' 0) y = 0\n                                else h (ws' 0) y = 0;\n        t \\<in> {0, 1}; ((a, b), 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0", "using step(5)"], ["proof (prove)\nusing this:\n  ((s, vs), 2, ws') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0", "proof (cases rule: converse_rtranclE[case_names base' step'])"], ["proof (state)\ngoal (2 subgoals):\n 1. (s, vs) = (2, ws') \\<Longrightarrow>\n    \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0\n 2. \\<And>y.\n       \\<lbrakk>((s, vs), y) \\<in> step X;\n        (y, 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "case base'"], ["proof (state)\nthis:\n  (s, vs) = (2, ws')\n\ngoal (2 subgoals):\n 1. (s, vs) = (2, ws') \\<Longrightarrow>\n    \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0\n 2. \\<And>y.\n       \\<lbrakk>((s, vs), y) \\<in> step X;\n        (y, 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "note *** = deterministic_minsky_UN[OF X2 _ _ X3]"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, 0, ?vsa) \\<in> (step X)\\<^sup>*;\n   (?x, Suc 0, ?vs) \\<in> (step X)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (0, ?vsa) = (Suc 0, ?vs)\n\ngoal (2 subgoals):\n 1. (s, vs) = (2, ws') \\<Longrightarrow>\n    \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0\n 2. \\<And>y.\n       \\<lbrakk>((s, vs), y) \\<in> step X;\n        (y, 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0", "using X4[of ws']"], ["proof (prove)\nusing this:\n  \\<exists>vs'.\n     g (ws' 0) (ws' 1) = 0 \\<and>\n     ((2, ws'), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n     h (ws' 0) (ws' 1) = 0 \\<and>\n     ((2, ws'), 1, vs') \\<in> (step X)\\<^sup>* \\<or>\n     g (ws' 0) (ws' 1) \\<noteq> 0 \\<and>\n     h (ws' 0) (ws' 1) \\<noteq> 0 \\<and>\n     vs' 0 = ws' 0 \\<and>\n     vs' 1 = ws' 1 + 1 \\<and> ((2, ws'), 2, vs') \\<in> (step X)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0", "proof (elim exE disjE conjE, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>vs'.\n       \\<lbrakk>g (ws' 0) (ws' 1) = 0;\n        ((2, ws'), 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0\n 2. \\<And>vs'.\n       \\<lbrakk>h (ws' 0) (ws' 1) = 0;\n        ((2, ws'), 1, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0\n 3. \\<And>vs'.\n       \\<lbrakk>g (ws' 0) (ws' 1) \\<noteq> 0; h (ws' 0) (ws' 1) \\<noteq> 0;\n        vs' 0 = ws' 0; vs' 1 = ws' 1 + 1;\n        ((2, ws'), 2, vs') \\<in> (step X)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "case (1 vs'')"], ["proof (state)\nthis:\n  g (ws' 0) (ws' 1) = 0\n  ((2, ws'), 0, vs'') \\<in> (step X)\\<^sup>*\n\ngoal (3 subgoals):\n 1. \\<And>vs'.\n       \\<lbrakk>g (ws' 0) (ws' 1) = 0;\n        ((2, ws'), 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0\n 2. \\<And>vs'.\n       \\<lbrakk>h (ws' 0) (ws' 1) = 0;\n        ((2, ws'), 1, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0\n 3. \\<And>vs'.\n       \\<lbrakk>g (ws' 0) (ws' 1) \\<noteq> 0; h (ws' 0) (ws' 1) \\<noteq> 0;\n        vs' 0 = ws' 0; vs' 1 = ws' 1 + 1;\n        ((2, ws'), 2, vs') \\<in> (step X)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "then"], ["proof (chain)\npicking this:\n  g (ws' 0) (ws' 1) = 0\n  ((2, ws'), 0, vs'') \\<in> (step X)\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  g (ws' 0) (ws' 1) = 0\n  ((2, ws'), 0, vs'') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0", "using step(1,2,4) ***[of \"(2,ws')\" vs'' ws]"], ["proof (prove)\nusing this:\n  g (ws' 0) (ws' 1) = 0\n  ((2, ws'), 0, vs'') \\<in> (step X)\\<^sup>*\n  ((s, vs), s', vs') \\<in> step X\n  ((s', vs'), t, ws) \\<in> (step X)\\<^sup>*\n  t \\<in> {0, 1}\n  \\<lbrakk>((2, ws'), 0, vs'') \\<in> (step X)\\<^sup>*;\n   ((2, ws'), Suc 0, ws) \\<in> (step X)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (0, vs'') = (Suc 0, ws)\n\ngoal (1 subgoal):\n 1. \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0", "by (auto simp: base' intro: converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0\n\ngoal (2 subgoals):\n 1. \\<And>vs'.\n       \\<lbrakk>h (ws' 0) (ws' 1) = 0;\n        ((2, ws'), 1, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0\n 2. \\<And>vs'.\n       \\<lbrakk>g (ws' 0) (ws' 1) \\<noteq> 0; h (ws' 0) (ws' 1) \\<noteq> 0;\n        vs' 0 = ws' 0; vs' 1 = ws' 1 + 1;\n        ((2, ws'), 2, vs') \\<in> (step X)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs'.\n       \\<lbrakk>h (ws' 0) (ws' 1) = 0;\n        ((2, ws'), 1, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0\n 2. \\<And>vs'.\n       \\<lbrakk>g (ws' 0) (ws' 1) \\<noteq> 0; h (ws' 0) (ws' 1) \\<noteq> 0;\n        vs' 0 = ws' 0; vs' 1 = ws' 1 + 1;\n        ((2, ws'), 2, vs') \\<in> (step X)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "case (2 vs'')"], ["proof (state)\nthis:\n  h (ws' 0) (ws' 1) = 0\n  ((2, ws'), 1, vs'') \\<in> (step X)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>vs'.\n       \\<lbrakk>h (ws' 0) (ws' 1) = 0;\n        ((2, ws'), 1, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0\n 2. \\<And>vs'.\n       \\<lbrakk>g (ws' 0) (ws' 1) \\<noteq> 0; h (ws' 0) (ws' 1) \\<noteq> 0;\n        vs' 0 = ws' 0; vs' 1 = ws' 1 + 1;\n        ((2, ws'), 2, vs') \\<in> (step X)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "then"], ["proof (chain)\npicking this:\n  h (ws' 0) (ws' 1) = 0\n  ((2, ws'), 1, vs'') \\<in> (step X)\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  h (ws' 0) (ws' 1) = 0\n  ((2, ws'), 1, vs'') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0", "using step(1,2,4) ***[of \"(2,ws')\" ws vs'']"], ["proof (prove)\nusing this:\n  h (ws' 0) (ws' 1) = 0\n  ((2, ws'), 1, vs'') \\<in> (step X)\\<^sup>*\n  ((s, vs), s', vs') \\<in> step X\n  ((s', vs'), t, ws) \\<in> (step X)\\<^sup>*\n  t \\<in> {0, 1}\n  \\<lbrakk>((2, ws'), 0, ws) \\<in> (step X)\\<^sup>*;\n   ((2, ws'), Suc 0, vs'') \\<in> (step X)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (0, ws) = (Suc 0, vs'')\n\ngoal (1 subgoal):\n 1. \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0", "by (auto simp: base' intro: converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0\n\ngoal (1 subgoal):\n 1. \\<And>vs'.\n       \\<lbrakk>g (ws' 0) (ws' 1) \\<noteq> 0; h (ws' 0) (ws' 1) \\<noteq> 0;\n        vs' 0 = ws' 0; vs' 1 = ws' 1 + 1;\n        ((2, ws'), 2, vs') \\<in> (step X)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs'.\n       \\<lbrakk>g (ws' 0) (ws' 1) \\<noteq> 0; h (ws' 0) (ws' 1) \\<noteq> 0;\n        vs' 0 = ws' 0; vs' 1 = ws' 1 + 1;\n        ((2, ws'), 2, vs') \\<in> (step X)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "case (3 vs'')"], ["proof (state)\nthis:\n  g (ws' 0) (ws' 1) \\<noteq> 0\n  h (ws' 0) (ws' 1) \\<noteq> 0\n  vs'' 0 = ws' 0\n  vs'' 1 = ws' 1 + 1\n  ((2, ws'), 2, vs'') \\<in> (step X)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>vs'.\n       \\<lbrakk>g (ws' 0) (ws' 1) \\<noteq> 0; h (ws' 0) (ws' 1) \\<noteq> 0;\n        vs' 0 = ws' 0; vs' 1 = ws' 1 + 1;\n        ((2, ws'), 2, vs') \\<in> (step X)\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "then"], ["proof (chain)\npicking this:\n  g (ws' 0) (ws' 1) \\<noteq> 0\n  h (ws' 0) (ws' 1) \\<noteq> 0\n  vs'' 0 = ws' 0\n  vs'' 1 = ws' 1 + 1\n  ((2, ws'), 2, vs'') \\<in> (step X)\\<^sup>+", "show ?case"], ["proof (prove)\nusing this:\n  g (ws' 0) (ws' 1) \\<noteq> 0\n  h (ws' 0) (ws' 1) \\<noteq> 0\n  vs'' 0 = ws' 0\n  vs'' 1 = ws' 1 + 1\n  ((2, ws'), 2, vs'') \\<in> (step X)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0", "using step(2) step(3)[of vs'', OF step(4)]\n          deterministicD[OF deterministic_stepI[OF X2], OF _ step(1)]"], ["proof (prove)\nusing this:\n  g (ws' 0) (ws' 1) \\<noteq> 0\n  h (ws' 0) (ws' 1) \\<noteq> 0\n  vs'' 0 = ws' 0\n  vs'' 1 = ws' 1 + 1\n  ((2, ws'), 2, vs'') \\<in> (step X)\\<^sup>+\n  ((s', vs'), t, ws) \\<in> (step X)\\<^sup>*\n  ((s', vs'), 2, vs'') \\<in> (step X)\\<^sup>* \\<Longrightarrow>\n  \\<exists>y. if t = 0 then g (vs'' 0) y = 0 else h (vs'' 0) y = 0\n  ((s, vs), ?y) \\<in> step X \\<Longrightarrow> ?y = (s', vs')\n\ngoal (1 subgoal):\n 1. \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0", "by (auto simp: base' if_bool_eq_conj trancl_unfold_left)"], ["proof (state)\nthis:\n  \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>((s, vs), y) \\<in> step X;\n        (y, 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>((s, vs), y) \\<in> step X;\n        (y, 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "case (step' y)"], ["proof (state)\nthis:\n  ((s, vs), y) \\<in> step X\n  (y, 2, ws') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>((s, vs), y) \\<in> step X;\n        (y, 2, ws') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            if t = 0 then g (ws' 0) y = 0\n                            else h (ws' 0) y = 0", "then"], ["proof (chain)\npicking this:\n  ((s, vs), y) \\<in> step X\n  (y, 2, ws') \\<in> (step X)\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  ((s, vs), y) \\<in> step X\n  (y, 2, ws') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0", "by (metis deterministicD[OF deterministic_stepI[OF X2]] step(1) step(3)[OF step(4)])"], ["proof (state)\nthis:\n  \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y. if t = 0 then g (ws' 0) y = 0 else h (ws' 0) y = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>((?s2, ?vs2), ?t2, ?ws2) \\<in> (step X)\\<^sup>*;\n   ?t2 \\<in> {0, 1}; ((?s2, ?vs2), 2, ?ws'2) \\<in> (step X)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y.\n                       if ?t2 = 0 then g (?ws'2 0) y = 0\n                       else h (?ws'2 0) y = 0\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         Suc 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((2, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>* \\<or>\n                                 ((2, vs), Suc 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (intro that[of X] X1 X2 X3, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x vs.\n       \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n                            ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*\n 2. \\<And>x vs vs'.\n       \\<lbrakk>vs 0 = x; vs 1 = 0;\n        ((2, vs), 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 3. \\<And>x vs vs'.\n       \\<lbrakk>vs 0 = x; vs 1 = 0;\n        ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> B", "case (1 x vs)"], ["proof (state)\nthis:\n  vs 0 = x\n  vs 1 = 0\n  x \\<in> A \\<union> B\n\ngoal (3 subgoals):\n 1. \\<And>x vs.\n       \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n                            ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*\n 2. \\<And>x vs vs'.\n       \\<lbrakk>vs 0 = x; vs 1 = 0;\n        ((2, vs), 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 3. \\<And>x vs vs'.\n       \\<lbrakk>vs 0 = x; vs 1 = 0;\n        ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> B", "then"], ["proof (chain)\npicking this:\n  vs 0 = x\n  vs 1 = 0\n  x \\<in> A \\<union> B", "show ?case"], ["proof (prove)\nusing this:\n  vs 0 = x\n  vs 1 = 0\n  x \\<in> A \\<union> B\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*", "using *[of vs]"], ["proof (prove)\nusing this:\n  vs 0 = x\n  vs 1 = 0\n  x \\<in> A \\<union> B\n  \\<lbrakk>vs 1 \\<le> ?y2; g (vs 0) ?y2 = 0 \\<or> h (vs 0) ?y2 = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>vs'.\n                       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n                       ((2, vs), 1, vs') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>vs'.\n       ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n       ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*", "by (auto simp: g(2) h(2))"], ["proof (state)\nthis:\n  \\<exists>vs'.\n     ((2, vs), 0, vs') \\<in> (step X)\\<^sup>* \\<or>\n     ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>x vs vs'.\n       \\<lbrakk>vs 0 = x; vs 1 = 0;\n        ((2, vs), 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x vs vs'.\n       \\<lbrakk>vs 0 = x; vs 1 = 0;\n        ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> B", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x vs vs'.\n       \\<lbrakk>vs 0 = x; vs 1 = 0;\n        ((2, vs), 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x vs vs'.\n       \\<lbrakk>vs 0 = x; vs 1 = 0;\n        ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> B", "case (2 x vs vs')"], ["proof (state)\nthis:\n  vs 0 = x\n  vs 1 = 0\n  ((2, vs), 0, vs') \\<in> (step X)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>x vs vs'.\n       \\<lbrakk>vs 0 = x; vs 1 = 0;\n        ((2, vs), 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A\n 2. \\<And>x vs vs'.\n       \\<lbrakk>vs 0 = x; vs 1 = 0;\n        ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> B", "then"], ["proof (chain)\npicking this:\n  vs 0 = x\n  vs 1 = 0\n  ((2, vs), 0, vs') \\<in> (step X)\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  vs 0 = x\n  vs 1 = 0\n  ((2, vs), 0, vs') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. x \\<in> A", "using **[of 2 vs 0 vs' vs]"], ["proof (prove)\nusing this:\n  vs 0 = x\n  vs 1 = 0\n  ((2, vs), 0, vs') \\<in> (step X)\\<^sup>*\n  \\<lbrakk>((2, vs), 0, vs') \\<in> (step X)\\<^sup>*; 0 \\<in> {0, 1};\n   ((2, vs), 2, vs) \\<in> (step X)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y.\n                       if 0 = 0 then g (vs 0) y = 0 else h (vs 0) y = 0\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by (auto simp: g(2) h(2))"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x vs vs'.\n       \\<lbrakk>vs 0 = x; vs 1 = 0;\n        ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x vs vs'.\n       \\<lbrakk>vs 0 = x; vs 1 = 0;\n        ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> B", "case (3 x vs vs')"], ["proof (state)\nthis:\n  vs 0 = x\n  vs 1 = 0\n  ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x vs vs'.\n       \\<lbrakk>vs 0 = x; vs 1 = 0;\n        ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> B", "then"], ["proof (chain)\npicking this:\n  vs 0 = x\n  vs 1 = 0\n  ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  vs 0 = x\n  vs 1 = 0\n  ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*\n\ngoal (1 subgoal):\n 1. x \\<in> B", "using **[of 2 vs 1 vs' vs]"], ["proof (prove)\nusing this:\n  vs 0 = x\n  vs 1 = 0\n  ((2, vs), Suc 0, vs') \\<in> (step X)\\<^sup>*\n  \\<lbrakk>((2, vs), 1, vs') \\<in> (step X)\\<^sup>*; 1 \\<in> {0, 1};\n   ((2, vs), 2, vs) \\<in> (step X)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y.\n                       if 1 = 0 then g (vs 0) y = 0 else h (vs 0) y = 0\n\ngoal (1 subgoal):\n 1. x \\<in> B", "by (auto simp: g(2) h(2))"], ["proof (state)\nthis:\n  x \\<in> B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>For r.e.\\ sets we obtain the following lemma as a special case (taking $B = \\varnothing$,\nand swapping states $1$ and $2$).\\<close>"], ["", "lemma ce_set_by_minsky:\n  assumes \"A \\<in> ce_sets\"\n  obtains M :: \"(nat, nat) minsky\" where\n    \"finite M\" \"deterministic M\" \"0 \\<notin> fst ` M\"\n    \"\\<And>x vs. vs 0 = x \\<Longrightarrow> vs 1 = 0 \\<Longrightarrow> x \\<in> A \\<Longrightarrow> \\<exists>vs'. ((Suc 0, vs), (0, vs')) \\<in> (step M)\\<^sup>*\"\n    \"\\<And>x vs vs'. vs 0 = x \\<Longrightarrow> vs 1 = 0 \\<Longrightarrow> ((Suc 0, vs), (0, vs')) \\<in> (step M)\\<^sup>* \\<Longrightarrow> x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((Suc 0, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((Suc 0, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "guess M"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using ce_set_pair_by_minsky[OF assms(1) ce_empty]"], ["proof (prove)\nusing this:\n  (\\<And>M.\n      \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n       Suc 0 \\<notin> fst ` M;\n       \\<And>x vs.\n          \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A \\<union> {}\\<rbrakk>\n          \\<Longrightarrow> \\<exists>vs'.\n                               ((2, vs), 0, vs')\n                               \\<in> (step M)\\<^sup>* \\<or>\n                               ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*;\n       \\<And>x vs vs'.\n          \\<lbrakk>vs 0 = x; vs 1 = 0;\n           ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n          \\<Longrightarrow> x \\<in> A;\n       \\<And>x vs vs'.\n          \\<lbrakk>vs 0 = x; vs 1 = 0;\n           ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n          \\<Longrightarrow> x \\<in> {}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  finite M\n  deterministic M\n  0 \\<notin> fst ` M\n  Suc 0 \\<notin> fst ` M\n  \\<lbrakk>?vs 0 = ?x; ?vs 1 = 0; ?x \\<in> A \\<union> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>vs'.\n                       ((2, ?vs), 0, vs') \\<in> (step M)\\<^sup>* \\<or>\n                       ((2, ?vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\n  \\<lbrakk>?vs 0 = ?x; ?vs 1 = 0;\n   ((2, ?vs), 0, ?vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> A\n  \\<lbrakk>?vs 0 = ?x; ?vs 1 = 0;\n   ((2, ?vs), Suc 0, ?vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> {}\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((Suc 0, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note M = this"], ["proof (state)\nthis:\n  finite M\n  deterministic M\n  0 \\<notin> fst ` M\n  Suc 0 \\<notin> fst ` M\n  \\<lbrakk>?vs 0 = ?x; ?vs 1 = 0; ?x \\<in> A \\<union> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>vs'.\n                       ((2, ?vs), 0, vs') \\<in> (step M)\\<^sup>* \\<or>\n                       ((2, ?vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\n  \\<lbrakk>?vs 0 = ?x; ?vs 1 = 0;\n   ((2, ?vs), 0, ?vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> A\n  \\<lbrakk>?vs 0 = ?x; ?vs 1 = 0;\n   ((2, ?vs), Suc 0, ?vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> {}\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((Suc 0, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?f = \"\\<lambda>s. if s = 1 then 2 else if s = 2 then 1 else s\" \\<comment> \\<open>swap states 1 and 2\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((Suc 0, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"?f \\<circ> ?f = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        if s = (1::'a) then 2::'a\n        else if s = (2::'a) then 1::'a else s) \\<circ>\n    (\\<lambda>s.\n        if s = (1::'a) then 2::'a else if s = (2::'a) then 1::'a else s) =\n    id", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>s.\n      if s = (1::?'a2) then 2::?'a2\n      else if s = (2::?'a2) then 1::?'a2 else s) \\<circ>\n  (\\<lambda>s.\n      if s = (1::?'a2) then 2::?'a2\n      else if s = (2::?'a2) then 1::?'a2 else s) =\n  id\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((Suc 0, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define N where \"N = map_minsky ?f id M\""], ["proof (state)\nthis:\n  N =\n  map_minsky (\\<lambda>s. if s = 1 then 2 else if s = 2 then 1 else s) id M\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((Suc 0, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have M_def: \"M = map_minsky ?f id N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M =\n    map_minsky (\\<lambda>s. if s = 1 then 2 else if s = 2 then 1 else s) id\n     N", "unfolding N_def map_minsky_comp \\<open>?f \\<circ> ?f = id\\<close> map_minsky_id o_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. M = M", ".."], ["proof (state)\nthis:\n  M =\n  map_minsky (\\<lambda>s. if s = 1 then 2 else if s = 2 then 1 else s) id N\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n         \\<And>x vs.\n            \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> A\\<rbrakk>\n            \\<Longrightarrow> \\<exists>vs'.\n                                 ((Suc 0, vs), 0, vs')\n                                 \\<in> (step M)\\<^sup>*;\n         \\<And>x vs vs'.\n            \\<lbrakk>vs 0 = x; vs 1 = 0;\n             ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n            \\<Longrightarrow> x \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using M(1-3)"], ["proof (prove)\nusing this:\n  finite M\n  deterministic M\n  0 \\<notin> fst ` M\n\ngoal (1 subgoal):\n 1. thesis", "proof (intro that[of N], goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> finite N\n 2. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> deterministic N\n 3. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> 0 \\<notin> fst ` N\n 4. \\<And>x vs.\n       \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M; vs 0 = x;\n        vs 1 = 0; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>*\n 5. \\<And>x vs vs'.\n       \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M; vs 0 = x;\n        vs 1 = 0; ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "case (4 x vs)"], ["proof (state)\nthis:\n  finite M\n  deterministic M\n  0 \\<notin> fst ` M\n  vs 0 = x\n  vs 1 = 0\n  x \\<in> A\n\ngoal (5 subgoals):\n 1. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> finite N\n 2. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> deterministic N\n 3. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> 0 \\<notin> fst ` N\n 4. \\<And>x vs.\n       \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M; vs 0 = x;\n        vs 1 = 0; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>*\n 5. \\<And>x vs vs'.\n       \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M; vs 0 = x;\n        vs 1 = 0; ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>vs'. ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>*", "using M(5)[OF 4(4,5)] 4(6) M(7)[OF 4(4,5)]\n      map_steps[of id vs vs 2 0 _ M ?f]"], ["proof (prove)\nusing this:\n  x \\<in> A \\<union> {} \\<Longrightarrow>\n  \\<exists>vs'.\n     ((2, vs), 0, vs') \\<in> (step M)\\<^sup>* \\<or>\n     ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\n  x \\<in> A\n  ((2, vs), Suc 0, ?vs') \\<in> (step M)\\<^sup>* \\<Longrightarrow> x \\<in> {}\n  \\<lbrakk>inj id; vs = vs \\<circ> id;\n   ((2, vs), 0, ?vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ((if 2 = 1 then 2 else if 2 = 2 then 1 else 2, vs),\n                     if 0 = 1 then 2 else if 0 = 2 then 1 else 0,\n                     \\<lambda>x.\n                        if x \\<in> range id then ?vs' (inv id x) else vs x)\n                    \\<in> (step\n                            (map_minsky\n                              (\\<lambda>s.\n                                  if s = 1 then 2\n                                  else if s = 2 then 1 else s)\n                              id M))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>vs'. ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>*", "by (auto simp: N_def)"], ["proof (state)\nthis:\n  \\<exists>vs'. ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>*\n\ngoal (4 subgoals):\n 1. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> finite N\n 2. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> deterministic N\n 3. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> 0 \\<notin> fst ` N\n 4. \\<And>x vs vs'.\n       \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M; vs 0 = x;\n        vs 1 = 0; ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> finite N\n 2. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> deterministic N\n 3. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> 0 \\<notin> fst ` N\n 4. \\<And>x vs vs'.\n       \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M; vs 0 = x;\n        vs 1 = 0; ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "case (5 x vs vs')"], ["proof (state)\nthis:\n  finite M\n  deterministic M\n  0 \\<notin> fst ` M\n  vs 0 = x\n  vs 1 = 0\n  ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>*\n\ngoal (4 subgoals):\n 1. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> finite N\n 2. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> deterministic N\n 3. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> 0 \\<notin> fst ` N\n 4. \\<And>x vs vs'.\n       \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M; vs 0 = x;\n        vs 1 = 0; ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A", "using M(6)[OF 5(4,5)] 5(6) map_steps[of id vs vs 1 0 _ N ?f]"], ["proof (prove)\nusing this:\n  ((2, vs), 0, ?vs') \\<in> (step M)\\<^sup>* \\<Longrightarrow> x \\<in> A\n  ((Suc 0, vs), 0, vs') \\<in> (step N)\\<^sup>*\n  \\<lbrakk>inj id; vs = vs \\<circ> id;\n   ((1, vs), 0, ?vs') \\<in> (step N)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ((if 1 = 1 then 2 else if 1 = 2 then 1 else 1, vs),\n                     if 0 = 1 then 2 else if 0 = 2 then 1 else 0,\n                     \\<lambda>x.\n                        if x \\<in> range id then ?vs' (inv id x) else vs x)\n                    \\<in> (step\n                            (map_minsky\n                              (\\<lambda>s.\n                                  if s = 1 then 2\n                                  else if s = 2 then 1 else s)\n                              id N))\\<^sup>*\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by (auto simp: M_def)"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> finite N\n 2. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> deterministic N\n 3. \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M\\<rbrakk>\n    \\<Longrightarrow> 0 \\<notin> fst ` N", "qed (auto simp: N_def map_minsky_def inj_on_def rev_image_eqI deterministic_map split: if_splits)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Encoding of Minsky machines\\<close>"], ["", "text \\<open>So far, Minsky machines have been sets of pairs of states and operations. We now provide an\nencoding of Minsky machines as natural numbers, so that we can talk about them as r.e.\\ or\ncomputable sets. First we encode operations.\\<close>"], ["", "primrec encode_Op :: \"(nat, nat) Op \\<Rightarrow> nat\" where\n  \"encode_Op (Dec v s s') = c_pair 0 (c_pair v (c_pair s s'))\"\n| \"encode_Op (Inc v s) = c_pair 1 (c_pair v s)\""], ["", "definition decode_Op :: \"nat \\<Rightarrow> (nat, nat) Op\" where\n  \"decode_Op n = (if c_fst n = 0\n   then Dec (c_fst (c_snd n)) (c_fst (c_snd (c_snd n))) (c_snd (c_snd (c_snd n)))\n   else Inc (c_fst (c_snd n)) (c_snd (c_snd n)))\""], ["", "lemma encode_Op_inv [simp]:\n  \"decode_Op (encode_Op x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decode_Op (encode_Op x) = x", "by (cases x) (auto simp: decode_Op_def)"], ["", "text \\<open>Minsky machines are encoded via lists of pairs of states and operations.\\<close>"], ["", "definition encode_minsky :: \"(nat \\<times> (nat, nat) Op) list \\<Rightarrow> nat\" where\n  \"encode_minsky M = list_to_nat (map (\\<lambda>x. c_pair (fst x) (encode_Op (snd x))) M)\""], ["", "definition decode_minsky :: \"nat \\<Rightarrow> (nat \\<times> (nat, nat) Op) list\" where\n  \"decode_minsky n = map (\\<lambda>n. (c_fst n, decode_Op (c_snd n))) (nat_to_list n)\""], ["", "lemma encode_minsky_inv [simp]:\n  \"decode_minsky (encode_minsky M) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decode_minsky (encode_minsky M) = M", "by (auto simp: encode_minsky_def decode_minsky_def comp_def)"], ["", "text \\<open>Assignments are stored as lists (starting with register 0).\\<close>"], ["", "definition decode_regs :: \"nat \\<Rightarrow> (nat \\<Rightarrow> nat)\" where\n  \"decode_regs n = (\\<lambda>i. let xs = nat_to_list n in if i < length xs then nat_to_list n ! i else 0)\""], ["", "text \\<open>The undecidability results talk about Minsky configurations (pairs of Minsky machines and\nassignments). This means that we do not have to construct any recursive functions that modify\nMinsky machines (for example in order to initialize variables), keeping the proofs simple.\\<close>"], ["", "definition decode_minsky_state :: \"nat \\<Rightarrow> ((nat, nat) minsky \\<times> (nat \\<Rightarrow> nat))\" where\n  \"decode_minsky_state n = (set (decode_minsky (c_fst n)), (decode_regs (c_snd n)))\""], ["", "subsection \\<open>Undecidablity results\\<close>"], ["", "text \\<open>We conclude with some undecidability results. First we show that it is undecidable whether\na Minksy machine starting at state 1 terminates in state 0.\\<close>"], ["", "definition minsky_reaching_0 where\n  \"minsky_reaching_0 = {n |n M vs vs'. (M, vs) = decode_minsky_state n \\<and> ((Suc 0, vs), (0, vs')) \\<in> (step M)\\<^sup>*}\""], ["", "lemma minsky_reaching_0_not_computable:\n  \"\\<not> computable minsky_reaching_0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> computable minsky_reaching_0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> computable minsky_reaching_0", "guess U"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using ce_set_by_minsky[OF univ_is_ce]"], ["proof (prove)\nusing this:\n  (\\<And>M.\n      \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n       \\<And>x vs.\n          \\<lbrakk>vs 0 = x; vs 1 = 0; x \\<in> univ_ce\\<rbrakk>\n          \\<Longrightarrow> \\<exists>vs'.\n                               ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>*;\n       \\<And>x vs vs'.\n          \\<lbrakk>vs 0 = x; vs 1 = 0;\n           ((Suc 0, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n          \\<Longrightarrow> x \\<in> univ_ce\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  finite U\n  deterministic U\n  0 \\<notin> fst ` U\n  \\<lbrakk>?vs 0 = ?x; ?vs 1 = 0; ?x \\<in> univ_ce\\<rbrakk>\n  \\<Longrightarrow> \\<exists>vs'.\n                       ((Suc 0, ?vs), 0, vs') \\<in> (step U)\\<^sup>*\n  \\<lbrakk>?vs 0 = ?x; ?vs 1 = 0;\n   ((Suc 0, ?vs), 0, ?vs') \\<in> (step U)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> univ_ce\n\ngoal (1 subgoal):\n 1. \\<not> computable minsky_reaching_0", "note U = this"], ["proof (state)\nthis:\n  finite U\n  deterministic U\n  0 \\<notin> fst ` U\n  \\<lbrakk>?vs 0 = ?x; ?vs 1 = 0; ?x \\<in> univ_ce\\<rbrakk>\n  \\<Longrightarrow> \\<exists>vs'.\n                       ((Suc 0, ?vs), 0, vs') \\<in> (step U)\\<^sup>*\n  \\<lbrakk>?vs 0 = ?x; ?vs 1 = 0;\n   ((Suc 0, ?vs), 0, ?vs') \\<in> (step U)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> univ_ce\n\ngoal (1 subgoal):\n 1. \\<not> computable minsky_reaching_0", "obtain us where [simp]: \"set us = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us. set us = U \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using finite_list[OF U(1)]"], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = U\n\ngoal (1 subgoal):\n 1. (\\<And>us. set us = U \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  set us = U\n\ngoal (1 subgoal):\n 1. \\<not> computable minsky_reaching_0", "let ?f = \"\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> computable minsky_reaching_0", "have \"?f \\<in> PrimRec1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)) \\<in> PrimRec1", "using comp2_1[OF c_pair_is_pr const_is_pr comp2_1[OF c_cons_is_pr id1_1 const_is_pr]]"], ["proof (prove)\nusing this:\n  (\\<lambda>x. c_pair ?g5 (c_cons x ?h3)) \\<in> PrimRec1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)) \\<in> PrimRec1", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)) \\<in> PrimRec1\n\ngoal (1 subgoal):\n 1. \\<not> computable minsky_reaching_0", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)) \\<in> PrimRec1\n\ngoal (1 subgoal):\n 1. \\<not> computable minsky_reaching_0", "have \"?f x \\<in> minsky_reaching_0 \\<longleftrightarrow> x \\<in> univ_ce\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_pair (encode_minsky us) (c_cons x 0) \\<in> minsky_reaching_0) =\n    (x \\<in> univ_ce)", "using U(4,5)[of \"\\<lambda>i. if i = 0 then x else 0\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(if 0 = 0 then x else 0) = ?x; (if 1 = 0 then x else 0) = 0;\n   ?x \\<in> univ_ce\\<rbrakk>\n  \\<Longrightarrow> \\<exists>vs'.\n                       ((Suc 0, \\<lambda>i. if i = 0 then x else 0), 0, vs')\n                       \\<in> (step U)\\<^sup>*\n  \\<lbrakk>(if 0 = 0 then x else 0) = ?x; (if 1 = 0 then x else 0) = 0;\n   ((Suc 0, \\<lambda>i. if i = 0 then x else 0), 0, ?vs')\n   \\<in> (step U)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> univ_ce\n\ngoal (1 subgoal):\n 1. (c_pair (encode_minsky us) (c_cons x 0) \\<in> minsky_reaching_0) =\n    (x \\<in> univ_ce)", "by (auto simp: minsky_reaching_0_def decode_minsky_state_def decode_regs_def c_cons_def cong: if_cong)"], ["proof (state)\nthis:\n  (c_pair (encode_minsky us) (c_cons ?x 0) \\<in> minsky_reaching_0) =\n  (?x \\<in> univ_ce)\n\ngoal (1 subgoal):\n 1. \\<not> computable minsky_reaching_0", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)) \\<in> PrimRec1\n  (c_pair (encode_minsky us) (c_cons ?x 0) \\<in> minsky_reaching_0) =\n  (?x \\<in> univ_ce)", "have \"many_reducible_to univ_ce minsky_reaching_0\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)) \\<in> PrimRec1\n  (c_pair (encode_minsky us) (c_cons ?x 0) \\<in> minsky_reaching_0) =\n  (?x \\<in> univ_ce)\n\ngoal (1 subgoal):\n 1. many_reducible_to univ_ce minsky_reaching_0", "by (auto simp: many_reducible_to_def many_reducible_to_via_def dest: pr_is_total_rec)"], ["proof (state)\nthis:\n  many_reducible_to univ_ce minsky_reaching_0\n\ngoal (1 subgoal):\n 1. \\<not> computable minsky_reaching_0", "then"], ["proof (chain)\npicking this:\n  many_reducible_to univ_ce minsky_reaching_0", "show ?thesis"], ["proof (prove)\nusing this:\n  many_reducible_to univ_ce minsky_reaching_0\n\ngoal (1 subgoal):\n 1. \\<not> computable minsky_reaching_0", "by (rule many_reducible_lm_1)"], ["proof (state)\nthis:\n  \\<not> computable minsky_reaching_0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The remaining results are resursive inseparability results. We start be showing that there\nis a Minksy machine $U$ with final states $0$ and $1$ such that it is not possible to recursively\nseparate inputs reaching state $0$ from inputs reaching state $1$.\\<close>"], ["", "lemma rec_inseparable_0not1_1not0:\n  \"rec_inseparable {p. 0 \\<in> nat_to_ce_set p \\<and> 1 \\<notin> nat_to_ce_set p} {p. 0 \\<notin> nat_to_ce_set p \\<and> 1 \\<in> nat_to_ce_set p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_inseparable\n     {p. 0 \\<in> nat_to_ce_set p \\<and> 1 \\<notin> nat_to_ce_set p}\n     {p. 0 \\<notin> nat_to_ce_set p \\<and> 1 \\<in> nat_to_ce_set p}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rec_inseparable\n     {p. 0 \\<in> nat_to_ce_set p \\<and> 1 \\<notin> nat_to_ce_set p}\n     {p. 0 \\<notin> nat_to_ce_set p \\<and> 1 \\<in> nat_to_ce_set p}", "obtain n where n: \"nat_to_ce_set n = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        nat_to_ce_set n = {0} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nat_to_ce_set_srj[OF ce_finite[of \"{0}\"]]"], ["proof (prove)\nusing this:\n  finite {0} \\<Longrightarrow> \\<exists>n. {0} = nat_to_ce_set n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        nat_to_ce_set n = {0} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  nat_to_ce_set n = {0}\n\ngoal (1 subgoal):\n 1. rec_inseparable\n     {p. 0 \\<in> nat_to_ce_set p \\<and> 1 \\<notin> nat_to_ce_set p}\n     {p. 0 \\<notin> nat_to_ce_set p \\<and> 1 \\<in> nat_to_ce_set p}", "obtain m where m: \"nat_to_ce_set m = {1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        nat_to_ce_set m = {1} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nat_to_ce_set_srj[OF ce_finite[of \"{1}\"]]"], ["proof (prove)\nusing this:\n  finite {1} \\<Longrightarrow> \\<exists>n. {1} = nat_to_ce_set n\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        nat_to_ce_set m = {1} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  nat_to_ce_set m = {1}\n\ngoal (1 subgoal):\n 1. rec_inseparable\n     {p. 0 \\<in> nat_to_ce_set p \\<and> 1 \\<notin> nat_to_ce_set p}\n     {p. 0 \\<notin> nat_to_ce_set p \\<and> 1 \\<in> nat_to_ce_set p}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_inseparable\n     {p. 0 \\<in> nat_to_ce_set p \\<and> 1 \\<notin> nat_to_ce_set p}\n     {p. 0 \\<notin> nat_to_ce_set p \\<and> 1 \\<in> nat_to_ce_set p}", "by (rule rec_inseparable_mono[OF Rice_rec_inseparable[of n m]]) (auto simp: n m)"], ["proof (state)\nthis:\n  rec_inseparable\n   {p. 0 \\<in> nat_to_ce_set p \\<and> 1 \\<notin> nat_to_ce_set p}\n   {p. 0 \\<notin> nat_to_ce_set p \\<and> 1 \\<in> nat_to_ce_set p}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ce_sets_containing_n_ce:\n  \"{p. n \\<in> nat_to_ce_set p} \\<in> ce_sets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. n \\<in> nat_to_ce_set p} \\<in> ce_sets", "using ce_set_lm_5[OF univ_is_ce comp2_1[OF c_pair_is_pr id1_1 const_is_pr[of n]]]"], ["proof (prove)\nusing this:\n  {x. c_pair x n \\<in> univ_ce} \\<in> ce_sets\n\ngoal (1 subgoal):\n 1. {p. n \\<in> nat_to_ce_set p} \\<in> ce_sets", "by (auto simp: univ_ce_lm_1)"], ["", "lemma rec_inseparable_fixed_minsky_reaching_0_1:\n  obtains U :: \"(nat, nat) minsky\" where\n    \"finite U\" \"deterministic U\" \"0 \\<notin> fst ` U\" \"1 \\<notin> fst ` U\"\n    \"rec_inseparable {x |x vs'. ((2, (\\<lambda>n. if n = 0 then x else 0)), (0, vs')) \\<in> (step U)\\<^sup>*}\n      {x |x vs'. ((2, (\\<lambda>n. if n = 0 then x else 0)), (1, vs')) \\<in> (step U)\\<^sup>*}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>U.\n        \\<lbrakk>finite U; deterministic U; 0 \\<notin> fst ` U;\n         1 \\<notin> fst ` U;\n         rec_inseparable\n          {uu_.\n           \\<exists>x vs'.\n              uu_ = x \\<and>\n              ((2, \\<lambda>n. if n = 0 then x else 0), 0, vs')\n              \\<in> (step U)\\<^sup>*}\n          {uu_.\n           \\<exists>x vs'.\n              uu_ = x \\<and>\n              ((2, \\<lambda>n. if n = 0 then x else 0), 1, vs')\n              \\<in> (step U)\\<^sup>*}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>U.\n        \\<lbrakk>finite U; deterministic U; 0 \\<notin> fst ` U;\n         1 \\<notin> fst ` U;\n         rec_inseparable\n          {uu_.\n           \\<exists>x vs'.\n              uu_ = x \\<and>\n              ((2, \\<lambda>n. if n = 0 then x else 0), 0, vs')\n              \\<in> (step U)\\<^sup>*}\n          {uu_.\n           \\<exists>x vs'.\n              uu_ = x \\<and>\n              ((2, \\<lambda>n. if n = 0 then x else 0), 1, vs')\n              \\<in> (step U)\\<^sup>*}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "guess U"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using ce_set_pair_by_minsky[OF ce_sets_containing_n_ce ce_sets_containing_n_ce, of 0 1]"], ["proof (prove)\nusing this:\n  (\\<And>M.\n      \\<lbrakk>finite M; deterministic M; 0 \\<notin> fst ` M;\n       Suc 0 \\<notin> fst ` M;\n       \\<And>x vs.\n          \\<lbrakk>vs 0 = x; vs 1 = 0;\n           x \\<in> {p. 0 \\<in> nat_to_ce_set p} \\<union>\n                   {p. 1 \\<in> nat_to_ce_set p}\\<rbrakk>\n          \\<Longrightarrow> \\<exists>vs'.\n                               ((2, vs), 0, vs')\n                               \\<in> (step M)\\<^sup>* \\<or>\n                               ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*;\n       \\<And>x vs vs'.\n          \\<lbrakk>vs 0 = x; vs 1 = 0;\n           ((2, vs), 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n          \\<Longrightarrow> x \\<in> {p. 0 \\<in> nat_to_ce_set p};\n       \\<And>x vs vs'.\n          \\<lbrakk>vs 0 = x; vs 1 = 0;\n           ((2, vs), Suc 0, vs') \\<in> (step M)\\<^sup>*\\<rbrakk>\n          \\<Longrightarrow> x \\<in> {p. 1 \\<in> nat_to_ce_set p}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  finite U\n  deterministic U\n  0 \\<notin> fst ` U\n  Suc 0 \\<notin> fst ` U\n  \\<lbrakk>?vs 0 = ?x; ?vs 1 = 0;\n   ?x \\<in> {p. 0 \\<in> nat_to_ce_set p} \\<union>\n            {p. 1 \\<in> nat_to_ce_set p}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>vs'.\n                       ((2, ?vs), 0, vs') \\<in> (step U)\\<^sup>* \\<or>\n                       ((2, ?vs), Suc 0, vs') \\<in> (step U)\\<^sup>*\n  \\<lbrakk>?vs 0 = ?x; ?vs 1 = 0;\n   ((2, ?vs), 0, ?vs') \\<in> (step U)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> {p. 0 \\<in> nat_to_ce_set p}\n  \\<lbrakk>?vs 0 = ?x; ?vs 1 = 0;\n   ((2, ?vs), Suc 0, ?vs') \\<in> (step U)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> {p. 1 \\<in> nat_to_ce_set p}\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        \\<lbrakk>finite U; deterministic U; 0 \\<notin> fst ` U;\n         1 \\<notin> fst ` U;\n         rec_inseparable\n          {uu_.\n           \\<exists>x vs'.\n              uu_ = x \\<and>\n              ((2, \\<lambda>n. if n = 0 then x else 0), 0, vs')\n              \\<in> (step U)\\<^sup>*}\n          {uu_.\n           \\<exists>x vs'.\n              uu_ = x \\<and>\n              ((2, \\<lambda>n. if n = 0 then x else 0), 1, vs')\n              \\<in> (step U)\\<^sup>*}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(1-4) this(5-7)[of \"\\<lambda>n. if n = 0 then _ else 0\"]"], ["proof (chain)\npicking this:\n  finite U\n  deterministic U\n  0 \\<notin> fst ` U\n  Suc 0 \\<notin> fst ` U\n  \\<lbrakk>(if 0 = 0 then ?uu4 else 0) = ?x;\n   (if 1 = 0 then ?uu4 else 0) = 0;\n   ?x \\<in> {p. 0 \\<in> nat_to_ce_set p} \\<union>\n            {p. 1 \\<in> nat_to_ce_set p}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>vs'.\n                       ((2, \\<lambda>n. if n = 0 then ?uu4 else 0), 0, vs')\n                       \\<in> (step U)\\<^sup>* \\<or>\n                       ((2, \\<lambda>n. if n = 0 then ?uu4 else 0), Suc 0,\n                        vs')\n                       \\<in> (step U)\\<^sup>*\n  \\<lbrakk>(if 0 = 0 then ?uu4 else 0) = ?x;\n   (if 1 = 0 then ?uu4 else 0) = 0;\n   ((2, \\<lambda>n. if n = 0 then ?uu4 else 0), 0, ?vs')\n   \\<in> (step U)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> {p. 0 \\<in> nat_to_ce_set p}\n  \\<lbrakk>(if 0 = 0 then ?uu4 else 0) = ?x;\n   (if 1 = 0 then ?uu4 else 0) = 0;\n   ((2, \\<lambda>n. if n = 0 then ?uu4 else 0), Suc 0, ?vs')\n   \\<in> (step U)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> {p. 1 \\<in> nat_to_ce_set p}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite U\n  deterministic U\n  0 \\<notin> fst ` U\n  Suc 0 \\<notin> fst ` U\n  \\<lbrakk>(if 0 = 0 then ?uu4 else 0) = ?x;\n   (if 1 = 0 then ?uu4 else 0) = 0;\n   ?x \\<in> {p. 0 \\<in> nat_to_ce_set p} \\<union>\n            {p. 1 \\<in> nat_to_ce_set p}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>vs'.\n                       ((2, \\<lambda>n. if n = 0 then ?uu4 else 0), 0, vs')\n                       \\<in> (step U)\\<^sup>* \\<or>\n                       ((2, \\<lambda>n. if n = 0 then ?uu4 else 0), Suc 0,\n                        vs')\n                       \\<in> (step U)\\<^sup>*\n  \\<lbrakk>(if 0 = 0 then ?uu4 else 0) = ?x;\n   (if 1 = 0 then ?uu4 else 0) = 0;\n   ((2, \\<lambda>n. if n = 0 then ?uu4 else 0), 0, ?vs')\n   \\<in> (step U)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> {p. 0 \\<in> nat_to_ce_set p}\n  \\<lbrakk>(if 0 = 0 then ?uu4 else 0) = ?x;\n   (if 1 = 0 then ?uu4 else 0) = 0;\n   ((2, \\<lambda>n. if n = 0 then ?uu4 else 0), Suc 0, ?vs')\n   \\<in> (step U)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> {p. 1 \\<in> nat_to_ce_set p}\n\ngoal (1 subgoal):\n 1. thesis", "by (auto 0 0 intro!: that[of U] rec_inseparable_mono[OF rec_inseparable_0not1_1not0]\n      pr_is_total_rec simp: rev_image_eqI cong: if_cong) meson+"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Consequently, it is impossible to separate Minsky configurations with determistic machines\nand final states $0$ and $1$ that reach state $0$ from those that reach state $1$.\\<close>"], ["", "definition minsky_reaching_s where\n  \"minsky_reaching_s s = {m |M m vs vs'. (M, vs) = decode_minsky_state m \\<and>\n    deterministic M \\<and> 0 \\<notin> fst ` M \\<and> 1 \\<notin> fst ` M \\<and> ((2, vs), (s, vs')) \\<in> (step M)\\<^sup>*}\""], ["", "lemma rec_inseparable_minsky_reaching_0_1:\n  \"rec_inseparable (minsky_reaching_s 0) (minsky_reaching_s 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_inseparable (minsky_reaching_s 0) (minsky_reaching_s 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rec_inseparable (minsky_reaching_s 0) (minsky_reaching_s 1)", "guess U"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using rec_inseparable_fixed_minsky_reaching_0_1"], ["proof (prove)\nusing this:\n  (\\<And>U.\n      \\<lbrakk>finite U; deterministic U; 0 \\<notin> fst ` U;\n       1 \\<notin> fst ` U;\n       rec_inseparable\n        {uu_.\n         \\<exists>x vs'.\n            uu_ = x \\<and>\n            ((2, \\<lambda>n. if n = 0 then x else 0), 0, vs')\n            \\<in> (step U)\\<^sup>*}\n        {uu_.\n         \\<exists>x vs'.\n            uu_ = x \\<and>\n            ((2, \\<lambda>n. if n = 0 then x else 0), 1, vs')\n            \\<in> (step U)\\<^sup>*}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  finite U\n  deterministic U\n  0 \\<notin> fst ` U\n  1 \\<notin> fst ` U\n  rec_inseparable\n   {uu_.\n    \\<exists>x vs'.\n       uu_ = x \\<and>\n       ((2, \\<lambda>n. if n = 0 then x else 0), 0, vs')\n       \\<in> (step U)\\<^sup>*}\n   {uu_.\n    \\<exists>x vs'.\n       uu_ = x \\<and>\n       ((2, \\<lambda>n. if n = 0 then x else 0), 1, vs')\n       \\<in> (step U)\\<^sup>*}\n\ngoal (1 subgoal):\n 1. rec_inseparable (minsky_reaching_s 0) (minsky_reaching_s 1)", "note U = this"], ["proof (state)\nthis:\n  finite U\n  deterministic U\n  0 \\<notin> fst ` U\n  1 \\<notin> fst ` U\n  rec_inseparable\n   {uu_.\n    \\<exists>x vs'.\n       uu_ = x \\<and>\n       ((2, \\<lambda>n. if n = 0 then x else 0), 0, vs')\n       \\<in> (step U)\\<^sup>*}\n   {uu_.\n    \\<exists>x vs'.\n       uu_ = x \\<and>\n       ((2, \\<lambda>n. if n = 0 then x else 0), 1, vs')\n       \\<in> (step U)\\<^sup>*}\n\ngoal (1 subgoal):\n 1. rec_inseparable (minsky_reaching_s 0) (minsky_reaching_s 1)", "obtain us where [simp]: \"set us = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>us. set us = U \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using finite_list[OF U(1)]"], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = U\n\ngoal (1 subgoal):\n 1. (\\<And>us. set us = U \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  set us = U\n\ngoal (1 subgoal):\n 1. rec_inseparable (minsky_reaching_s 0) (minsky_reaching_s 1)", "let ?f = \"\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_inseparable (minsky_reaching_s 0) (minsky_reaching_s 1)", "have \"?f \\<in> PrimRec1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)) \\<in> PrimRec1", "using comp2_1[OF c_pair_is_pr const_is_pr comp2_1[OF c_cons_is_pr id1_1 const_is_pr]]"], ["proof (prove)\nusing this:\n  (\\<lambda>x. c_pair ?g5 (c_cons x ?h3)) \\<in> PrimRec1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)) \\<in> PrimRec1", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)) \\<in> PrimRec1\n\ngoal (1 subgoal):\n 1. rec_inseparable (minsky_reaching_s 0) (minsky_reaching_s 1)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)) \\<in> PrimRec1", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)) \\<in> PrimRec1\n\ngoal (1 subgoal):\n 1. rec_inseparable (minsky_reaching_s 0) (minsky_reaching_s 1)", "using U(1-4) rec_inseparable_many_reducible[of ?f, OF _ rec_inseparable_mono[OF U(5)]]"], ["proof (prove)\nusing this:\n  (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)) \\<in> PrimRec1\n  finite U\n  deterministic U\n  0 \\<notin> fst ` U\n  1 \\<notin> fst ` U\n  \\<lbrakk>total_recursive\n            (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0));\n   {uu_.\n    \\<exists>x vs'.\n       uu_ = x \\<and>\n       ((2, \\<lambda>n. if n = 0 then x else 0), 0, vs')\n       \\<in> (step U)\\<^sup>*}\n   \\<subseteq> (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)) -` ?A;\n   {uu_.\n    \\<exists>x vs'.\n       uu_ = x \\<and>\n       ((2, \\<lambda>n. if n = 0 then x else 0), 1, vs')\n       \\<in> (step U)\\<^sup>*}\n   \\<subseteq> (\\<lambda>n. c_pair (encode_minsky us) (c_cons n 0)) -`\n               ?B\\<rbrakk>\n  \\<Longrightarrow> rec_inseparable ?A ?B\n\ngoal (1 subgoal):\n 1. rec_inseparable (minsky_reaching_s 0) (minsky_reaching_s 1)", "by (auto simp: pr_is_total_rec minsky_reaching_s_def decode_minsky_state_def rev_image_eqI\n      decode_regs_def c_cons_def cong: if_cong)"], ["proof (state)\nthis:\n  rec_inseparable (minsky_reaching_s 0) (minsky_reaching_s 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>As a corollary, it is impossible to separate Minsky configurations that reach state 0 but not\nstate 1 from those that reach state 1 but not state 0.\\<close>"], ["", "definition minsky_reaching_s_not_t where\n  \"minsky_reaching_s_not_t s t = {m |M m vs vs'. (M, vs) = decode_minsky_state m \\<and>\n    ((2, vs), (s, vs')) \\<in> (step M)\\<^sup>* \\<and> ((2, vs), (t, vs')) \\<notin> (step M)\\<^sup>*}\""], ["", "lemma minsky_reaching_s_imp_minsky_reaching_s_not_t:\n  assumes \"s \\<in> {0,1}\" \"t \\<in> {0,1}\" \"s \\<noteq> t\"\n  shows \"minsky_reaching_s s \\<subseteq> minsky_reaching_s_not_t s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minsky_reaching_s s \\<subseteq> minsky_reaching_s_not_t s t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. minsky_reaching_s s \\<subseteq> minsky_reaching_s_not_t s t", "have [dest!]: \"((2, vs), (0, vs')) \\<notin> (step M)\\<^sup>* \\<or> ((2, vs), (1, vs')) \\<notin> (step M)\\<^sup>*\"\n    if \"deterministic M\" \"0 \\<notin> fst ` M\" \"1 \\<notin> fst ` M\" for M :: \"(nat, nat) minsky\" and vs vs'"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((2, vs), 0, vs') \\<notin> (step M)\\<^sup>* \\<or>\n    ((2, vs), 1, vs') \\<notin> (step M)\\<^sup>*", "using deterministic_minsky_UN[OF that(1) _ _ that(2,3)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, 0, ?vsa) \\<in> (step M)\\<^sup>*;\n   (?x, 1, ?vs) \\<in> (step M)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> (0, ?vsa) = (1, ?vs)\n\ngoal (1 subgoal):\n 1. ((2, vs), 0, vs') \\<notin> (step M)\\<^sup>* \\<or>\n    ((2, vs), 1, vs') \\<notin> (step M)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>deterministic ?M; 0 \\<notin> fst ` ?M;\n   1 \\<notin> fst ` ?M\\<rbrakk>\n  \\<Longrightarrow> ((2, ?vs), 0, ?vs') \\<notin> (step ?M)\\<^sup>* \\<or>\n                    ((2, ?vs), 1, ?vs') \\<notin> (step ?M)\\<^sup>*\n\ngoal (1 subgoal):\n 1. minsky_reaching_s s \\<subseteq> minsky_reaching_s_not_t s t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. minsky_reaching_s s \\<subseteq> minsky_reaching_s_not_t s t", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> {0, 1}\n  t \\<in> {0, 1}\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. minsky_reaching_s s \\<subseteq> minsky_reaching_s_not_t s t", "by (auto simp: minsky_reaching_s_def minsky_reaching_s_not_t_def rev_image_eqI)"], ["proof (state)\nthis:\n  minsky_reaching_s s \\<subseteq> minsky_reaching_s_not_t s t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rec_inseparable_minsky_reaching_0_not_1_1_not_0:\n  \"rec_inseparable (minsky_reaching_s_not_t 0 1) (minsky_reaching_s_not_t 1 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_inseparable (minsky_reaching_s_not_t 0 1)\n     (minsky_reaching_s_not_t 1 0)", "by (intro rec_inseparable_mono[OF rec_inseparable_minsky_reaching_0_1]\n    minsky_reaching_s_imp_minsky_reaching_s_not_t) simp_all"], ["", "end"]]}