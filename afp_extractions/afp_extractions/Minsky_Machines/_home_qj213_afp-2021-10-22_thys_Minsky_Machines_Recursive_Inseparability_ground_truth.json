{"file_name": "/home/qj213/afp-2021-10-22/thys/Minsky_Machines/Recursive_Inseparability.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Minsky_Machines", "problem_names": ["lemma rec_inseparableI:\n  \"(\\<And>X. A \\<subseteq> X \\<Longrightarrow> B \\<subseteq> - X \\<Longrightarrow> computable X \\<Longrightarrow> False) \\<Longrightarrow> rec_inseparable A B\"", "lemma rec_inseparableD:\n  \"rec_inseparable A B \\<Longrightarrow> A \\<subseteq> X \\<Longrightarrow> B \\<subseteq> - X \\<Longrightarrow> computable X \\<Longrightarrow> False\"", "lemma rec_inseparable_symmetric:\n  \"rec_inseparable A B \\<Longrightarrow> rec_inseparable B A\"", "lemma rec_inseparable_mono:\n  \"rec_inseparable A B \\<Longrightarrow> A \\<subseteq> A' \\<Longrightarrow> B \\<subseteq> B' \\<Longrightarrow> rec_inseparable A' B'\"", "lemma rec_inseparable_many_reducible:\n  assumes \"total_recursive f\" \"rec_inseparable (f -` A) (f -` B)\"\n  shows \"rec_inseparable A B\"", "lemma rec_inseparable_collapse:\n  \"A \\<inter> B \\<noteq> {} \\<Longrightarrow> rec_inseparable A B\"", "lemma rec_inseparable_non_computable:\n  \"A \\<inter> B = {} \\<Longrightarrow> rec_inseparable A B \\<Longrightarrow> \\<not> computable A\"", "lemma computable_rec_inseparable_conv:\n  \"computable A \\<longleftrightarrow> \\<not> rec_inseparable A (- A)\"", "lemma c_pair_inj':\n  \"c_pair x1 y1 = c_pair x2 y2 \\<longleftrightarrow> x1 = x2 \\<and> y1 = y2\"", "lemma Rice_rec_inseparable:\n  \"rec_inseparable {k. nat_to_ce_set k = nat_to_ce_set n} {k. nat_to_ce_set k = nat_to_ce_set m}\""], "translations": [["", "lemma rec_inseparableI:\n  \"(\\<And>X. A \\<subseteq> X \\<Longrightarrow> B \\<subseteq> - X \\<Longrightarrow> computable X \\<Longrightarrow> False) \\<Longrightarrow> rec_inseparable A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>A \\<subseteq> X; B \\<subseteq> - X; computable X\\<rbrakk>\n        \\<Longrightarrow> False) \\<Longrightarrow>\n    rec_inseparable A B", "unfolding rec_inseparable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>A \\<subseteq> X; B \\<subseteq> - X; computable X\\<rbrakk>\n        \\<Longrightarrow> False) \\<Longrightarrow>\n    \\<forall>X.\n       A \\<subseteq> X \\<and> B \\<subseteq> - X \\<longrightarrow>\n       \\<not> computable X", "by blast"], ["", "lemma rec_inseparableD:\n  \"rec_inseparable A B \\<Longrightarrow> A \\<subseteq> X \\<Longrightarrow> B \\<subseteq> - X \\<Longrightarrow> computable X \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rec_inseparable A B; A \\<subseteq> X; B \\<subseteq> - X;\n     computable X\\<rbrakk>\n    \\<Longrightarrow> False", "unfolding rec_inseparable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>X.\n                A \\<subseteq> X \\<and> B \\<subseteq> - X \\<longrightarrow>\n                \\<not> computable X;\n     A \\<subseteq> X; B \\<subseteq> - X; computable X\\<rbrakk>\n    \\<Longrightarrow> False", "by blast"], ["", "text \\<open>Recursive inseperability is symmetric and enjoys a monotonicity property.\\<close>"], ["", "lemma rec_inseparable_symmetric:\n  \"rec_inseparable A B \\<Longrightarrow> rec_inseparable B A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_inseparable A B \\<Longrightarrow> rec_inseparable B A", "unfolding rec_inseparable_def computable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X.\n       A \\<subseteq> X \\<and> B \\<subseteq> - X \\<longrightarrow>\n       \\<not> (X \\<in> ce_sets \\<and> - X \\<in> ce_sets) \\<Longrightarrow>\n    \\<forall>X.\n       B \\<subseteq> X \\<and> A \\<subseteq> - X \\<longrightarrow>\n       \\<not> (X \\<in> ce_sets \\<and> - X \\<in> ce_sets)", "by (metis double_compl)"], ["", "lemma rec_inseparable_mono:\n  \"rec_inseparable A B \\<Longrightarrow> A \\<subseteq> A' \\<Longrightarrow> B \\<subseteq> B' \\<Longrightarrow> rec_inseparable A' B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rec_inseparable A B; A \\<subseteq> A';\n     B \\<subseteq> B'\\<rbrakk>\n    \\<Longrightarrow> rec_inseparable A' B'", "unfolding rec_inseparable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>X.\n                A \\<subseteq> X \\<and> B \\<subseteq> - X \\<longrightarrow>\n                \\<not> computable X;\n     A \\<subseteq> A'; B \\<subseteq> B'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>X.\n                         A' \\<subseteq> X \\<and>\n                         B' \\<subseteq> - X \\<longrightarrow>\n                         \\<not> computable X", "by (meson subset_trans)"], ["", "text \\<open>Many-to-one reductions apply to recursive inseparability as well.\\<close>"], ["", "lemma rec_inseparable_many_reducible:\n  assumes \"total_recursive f\" \"rec_inseparable (f -` A) (f -` B)\"\n  shows \"rec_inseparable A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_inseparable A B", "proof (intro rec_inseparableI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>A \\<subseteq> X; B \\<subseteq> - X; computable X\\<rbrakk>\n       \\<Longrightarrow> False", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>A \\<subseteq> X; B \\<subseteq> - X; computable X\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"A \\<subseteq> X\" \"B \\<subseteq> - X\" \"computable X\""], ["proof (state)\nthis:\n  A \\<subseteq> X\n  B \\<subseteq> - X\n  computable X\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>A \\<subseteq> X; B \\<subseteq> - X; computable X\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  A \\<subseteq> X\n  B \\<subseteq> - X\n  computable X\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>A \\<subseteq> X; B \\<subseteq> - X; computable X\\<rbrakk>\n       \\<Longrightarrow> False", "have \"many_reducible_to (f -` X) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. many_reducible_to (f -` X) X", "using assms(1)"], ["proof (prove)\nusing this:\n  total_recursive f\n\ngoal (1 subgoal):\n 1. many_reducible_to (f -` X) X", "by (auto simp: many_reducible_to_def many_reducible_to_via_def)"], ["proof (state)\nthis:\n  many_reducible_to (f -` X) X\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>A \\<subseteq> X; B \\<subseteq> - X; computable X\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  A \\<subseteq> X\n  B \\<subseteq> - X\n  computable X\n  many_reducible_to (f -` X) X", "have \"computable (f -` X)\" and \"(f -` A) \\<subseteq> (f -` X)\" and \"(f -` B) \\<subseteq> - (f -` X)\""], ["proof (prove)\nusing this:\n  A \\<subseteq> X\n  B \\<subseteq> - X\n  computable X\n  many_reducible_to (f -` X) X\n\ngoal (1 subgoal):\n 1. computable (f -` X) &&&\n    f -` A \\<subseteq> f -` X &&& f -` B \\<subseteq> - f -` X", "by (auto dest!: m_red_to_comp)"], ["proof (state)\nthis:\n  computable (f -` X)\n  f -` A \\<subseteq> f -` X\n  f -` B \\<subseteq> - f -` X\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>A \\<subseteq> X; B \\<subseteq> - X; computable X\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  computable (f -` X)\n  f -` A \\<subseteq> f -` X\n  f -` B \\<subseteq> - f -` X", "show \"False\""], ["proof (prove)\nusing this:\n  computable (f -` X)\n  f -` A \\<subseteq> f -` X\n  f -` B \\<subseteq> - f -` X\n\ngoal (1 subgoal):\n 1. False", "using assms(2)"], ["proof (prove)\nusing this:\n  computable (f -` X)\n  f -` A \\<subseteq> f -` X\n  f -` B \\<subseteq> - f -` X\n  rec_inseparable (f -` A) (f -` B)\n\ngoal (1 subgoal):\n 1. False", "unfolding rec_inseparable_def"], ["proof (prove)\nusing this:\n  computable (f -` X)\n  f -` A \\<subseteq> f -` X\n  f -` B \\<subseteq> - f -` X\n  \\<forall>X.\n     f -` A \\<subseteq> X \\<and> f -` B \\<subseteq> - X \\<longrightarrow>\n     \\<not> computable X\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Recursive inseparability of $A$ and $B$ holds vacuously if $A$ and $B$ are not disjoint.\\<close>"], ["", "lemma rec_inseparable_collapse:\n  \"A \\<inter> B \\<noteq> {} \\<Longrightarrow> rec_inseparable A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow> rec_inseparable A B", "by (auto simp: rec_inseparable_def)"], ["", "text \\<open>Recursive inseparability is intimately connected to non-computability.\\<close>"], ["", "lemma rec_inseparable_non_computable:\n  \"A \\<inter> B = {} \\<Longrightarrow> rec_inseparable A B \\<Longrightarrow> \\<not> computable A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<inter> B = {}; rec_inseparable A B\\<rbrakk>\n    \\<Longrightarrow> \\<not> computable A", "by (auto simp: rec_inseparable_def)"], ["", "lemma computable_rec_inseparable_conv:\n  \"computable A \\<longleftrightarrow> \\<not> rec_inseparable A (- A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. computable A = (\\<not> rec_inseparable A (- A))", "by (auto simp: computable_def rec_inseparable_def)"], ["", "subsection \\<open>Rice's theorem\\<close>"], ["", "text \\<open>We provide a stronger version of Rice's theorem compared to @{cite RTI}.\nUnfolding the definition of recursive inseparability, it states that there are no decidable\nsets $X$ such that\n\\begin{itemize}\n\\item there is a r.e.\\ set such that all its indices are elements of $X$; and\n\\item there is a r.e.\\ set such that none of its indices are elements of $X$.\n\\end{itemize}\nThis is true even if $X$ is not an index set (i.e., if an index of a r.e.\\ set is an element\nof $X$, then $X$ contains all indices of that r.e.\\ set), which is a requirement of Rice's\ntheorem in @{cite RTI}.\\<close>"], ["", "lemma c_pair_inj':\n  \"c_pair x1 y1 = c_pair x2 y2 \\<longleftrightarrow> x1 = x2 \\<and> y1 = y2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_pair x1 y1 = c_pair x2 y2) = (x1 = x2 \\<and> y1 = y2)", "by (metis c_fst_of_c_pair c_snd_of_c_pair)"], ["", "lemma Rice_rec_inseparable:\n  \"rec_inseparable {k. nat_to_ce_set k = nat_to_ce_set n} {k. nat_to_ce_set k = nat_to_ce_set m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_inseparable {k. nat_to_ce_set k = nat_to_ce_set n}\n     {k. nat_to_ce_set k = nat_to_ce_set m}", "proof (intro rec_inseparableI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>{k. nat_to_ce_set k = nat_to_ce_set n} \\<subseteq> X;\n        {k. nat_to_ce_set k = nat_to_ce_set m} \\<subseteq> - X;\n        computable X\\<rbrakk>\n       \\<Longrightarrow> False", "case (1 X)"], ["proof (state)\nthis:\n  {k. nat_to_ce_set k = nat_to_ce_set n} \\<subseteq> X\n  {k. nat_to_ce_set k = nat_to_ce_set m} \\<subseteq> - X\n  computable X\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>{k. nat_to_ce_set k = nat_to_ce_set n} \\<subseteq> X;\n        {k. nat_to_ce_set k = nat_to_ce_set m} \\<subseteq> - X;\n        computable X\\<rbrakk>\n       \\<Longrightarrow> False", "text \\<open>Note that @{thm Rice_2} is not applicable because X may not be an index set.\\<close>"], ["proof (state)\nthis:\n  {k. nat_to_ce_set k = nat_to_ce_set n} \\<subseteq> X\n  {k. nat_to_ce_set k = nat_to_ce_set m} \\<subseteq> - X\n  computable X\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>{k. nat_to_ce_set k = nat_to_ce_set n} \\<subseteq> X;\n        {k. nat_to_ce_set k = nat_to_ce_set m} \\<subseteq> - X;\n        computable X\\<rbrakk>\n       \\<Longrightarrow> False", "let ?Q = \"{q. s_ce q q \\<in> X} \\<times> nat_to_ce_set m \\<union> {q. s_ce q q \\<in> - X} \\<times> nat_to_ce_set n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>{k. nat_to_ce_set k = nat_to_ce_set n} \\<subseteq> X;\n        {k. nat_to_ce_set k = nat_to_ce_set m} \\<subseteq> - X;\n        computable X\\<rbrakk>\n       \\<Longrightarrow> False", "have \"?Q \\<in> ce_rels\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {q. s_ce q q \\<in> X} \\<times> nat_to_ce_set m \\<union>\n    {q. s_ce q q \\<in> - X} \\<times> nat_to_ce_set n\n    \\<in> ce_rels", "using 1(3) ce_set_lm_5 comp2_1[OF s_ce_is_pr id1_1 id1_1]"], ["proof (prove)\nusing this:\n  computable X\n  \\<lbrakk>?A \\<in> ce_sets; ?p \\<in> PrimRec1\\<rbrakk>\n  \\<Longrightarrow> {x. ?p x \\<in> ?A} \\<in> ce_sets\n  (\\<lambda>x. s_ce x x) \\<in> PrimRec1\n\ngoal (1 subgoal):\n 1. {q. s_ce q q \\<in> X} \\<times> nat_to_ce_set m \\<union>\n    {q. s_ce q q \\<in> - X} \\<times> nat_to_ce_set n\n    \\<in> ce_rels", "unfolding computable_def"], ["proof (prove)\nusing this:\n  X \\<in> ce_sets \\<and> - X \\<in> ce_sets\n  \\<lbrakk>?A \\<in> ce_sets; ?p \\<in> PrimRec1\\<rbrakk>\n  \\<Longrightarrow> {x. ?p x \\<in> ?A} \\<in> ce_sets\n  (\\<lambda>x. s_ce x x) \\<in> PrimRec1\n\ngoal (1 subgoal):\n 1. {q. s_ce q q \\<in> X} \\<times> nat_to_ce_set m \\<union>\n    {q. s_ce q q \\<in> - X} \\<times> nat_to_ce_set n\n    \\<in> ce_rels", "by (intro ce_union[of \"ce_rel_to_set _\" \"ce_rel_to_set _\", folded ce_rel_lm_32 ce_rel_lm_8]\n      ce_rel_lm_29 nat_to_ce_set_into_ce) blast+"], ["proof (state)\nthis:\n  {q. s_ce q q \\<in> X} \\<times> nat_to_ce_set m \\<union>\n  {q. s_ce q q \\<in> - X} \\<times> nat_to_ce_set n\n  \\<in> ce_rels\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>{k. nat_to_ce_set k = nat_to_ce_set n} \\<subseteq> X;\n        {k. nat_to_ce_set k = nat_to_ce_set m} \\<subseteq> - X;\n        computable X\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  {q. s_ce q q \\<in> X} \\<times> nat_to_ce_set m \\<union>\n  {q. s_ce q q \\<in> - X} \\<times> nat_to_ce_set n\n  \\<in> ce_rels", "obtain q where \"nat_to_ce_set q = {c_pair q x |q x. (q, x) \\<in> ?Q}\""], ["proof (prove)\nusing this:\n  {q. s_ce q q \\<in> X} \\<times> nat_to_ce_set m \\<union>\n  {q. s_ce q q \\<in> - X} \\<times> nat_to_ce_set n\n  \\<in> ce_rels\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        nat_to_ce_set q =\n        {c_pair q x |q x.\n         (q, x)\n         \\<in> {q. s_ce q q \\<in> X} \\<times> nat_to_ce_set m \\<union>\n               {q. s_ce q q \\<in> - X} \\<times>\n               nat_to_ce_set n} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding ce_rel_lm_8 ce_rel_to_set_def"], ["proof (prove)\nusing this:\n  {c_pair x y |x y.\n   (x, y)\n   \\<in> {q. s_ce q q \\<in> X} \\<times> nat_to_ce_set m \\<union>\n         {q. s_ce q q \\<in> - X} \\<times> nat_to_ce_set n}\n  \\<in> ce_sets\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        nat_to_ce_set q =\n        {c_pair q x |q x.\n         (q, x)\n         \\<in> {q. s_ce q q \\<in> X} \\<times> nat_to_ce_set m \\<union>\n               {q. s_ce q q \\<in> - X} \\<times>\n               nat_to_ce_set n} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) nat_to_ce_set_srj)"], ["proof (state)\nthis:\n  nat_to_ce_set q =\n  {c_pair q x |q x.\n   (q, x)\n   \\<in> {q. s_ce q q \\<in> X} \\<times> nat_to_ce_set m \\<union>\n         {q. s_ce q q \\<in> - X} \\<times> nat_to_ce_set n}\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>{k. nat_to_ce_set k = nat_to_ce_set n} \\<subseteq> X;\n        {k. nat_to_ce_set k = nat_to_ce_set m} \\<subseteq> - X;\n        computable X\\<rbrakk>\n       \\<Longrightarrow> False", "from eqset_imp_iff[OF this, of \"c_pair q _\"]"], ["proof (chain)\npicking this:\n  (c_pair q ?uu3 \\<in> nat_to_ce_set q) =\n  (c_pair q ?uu3\n   \\<in> {c_pair q x |q x.\n          (q, x)\n          \\<in> {q. s_ce q q \\<in> X} \\<times> nat_to_ce_set m \\<union>\n                {q. s_ce q q \\<in> - X} \\<times> nat_to_ce_set n})", "have \"nat_to_ce_set (s_ce q q) = (if s_ce q q \\<in> X then nat_to_ce_set m else nat_to_ce_set n)\""], ["proof (prove)\nusing this:\n  (c_pair q ?uu3 \\<in> nat_to_ce_set q) =\n  (c_pair q ?uu3\n   \\<in> {c_pair q x |q x.\n          (q, x)\n          \\<in> {q. s_ce q q \\<in> X} \\<times> nat_to_ce_set m \\<union>\n                {q. s_ce q q \\<in> - X} \\<times> nat_to_ce_set n})\n\ngoal (1 subgoal):\n 1. nat_to_ce_set (s_ce q q) =\n    (if s_ce q q \\<in> X then nat_to_ce_set m else nat_to_ce_set n)", "by (auto simp: s_lm c_pair_inj' nat_to_ce_set_def fn_to_set_def pr_conv_1_to_2_def)"], ["proof (state)\nthis:\n  nat_to_ce_set (s_ce q q) =\n  (if s_ce q q \\<in> X then nat_to_ce_set m else nat_to_ce_set n)\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>{k. nat_to_ce_set k = nat_to_ce_set n} \\<subseteq> X;\n        {k. nat_to_ce_set k = nat_to_ce_set m} \\<subseteq> - X;\n        computable X\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  nat_to_ce_set (s_ce q q) =\n  (if s_ce q q \\<in> X then nat_to_ce_set m else nat_to_ce_set n)", "show ?case"], ["proof (prove)\nusing this:\n  nat_to_ce_set (s_ce q q) =\n  (if s_ce q q \\<in> X then nat_to_ce_set m else nat_to_ce_set n)\n\ngoal (1 subgoal):\n 1. False", "using 1(1,2)[THEN subsetD, of \"s_ce q q\"]"], ["proof (prove)\nusing this:\n  nat_to_ce_set (s_ce q q) =\n  (if s_ce q q \\<in> X then nat_to_ce_set m else nat_to_ce_set n)\n  s_ce q q \\<in> {k. nat_to_ce_set k = nat_to_ce_set n} \\<Longrightarrow>\n  s_ce q q \\<in> X\n  s_ce q q \\<in> {k. nat_to_ce_set k = nat_to_ce_set m} \\<Longrightarrow>\n  s_ce q q \\<in> - X\n\ngoal (1 subgoal):\n 1. False", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}