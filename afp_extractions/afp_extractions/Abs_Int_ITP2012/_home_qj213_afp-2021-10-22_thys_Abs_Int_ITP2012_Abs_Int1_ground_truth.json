{"file_name": "/home/qj213/afp-2021-10-22/thys/Abs_Int_ITP2012/Abs_Int1.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Abs_Int_ITP2012", "problem_names": ["lemma aval'_sound: \"s : \\<gamma>\\<^sub>f S \\<Longrightarrow> aval a s : \\<gamma>(aval' a S)\"", "lemma strip_step'[simp]: \"strip(step' S c) = strip c\"", "lemma in_gamma_update:\n  \"\\<lbrakk> s : \\<gamma>\\<^sub>f S; i : \\<gamma> a \\<rbrakk> \\<Longrightarrow> s(x := i) : \\<gamma>\\<^sub>f(update S x a)\"", "lemma step_preserves_le:\n  \"\\<lbrakk> S \\<subseteq> \\<gamma>\\<^sub>o S'; c \\<le> \\<gamma>\\<^sub>c c' \\<rbrakk> \\<Longrightarrow> step S c \\<le> \\<gamma>\\<^sub>c (step' S' c')\"", "lemma AI_sound: \"AI c = Some c' \\<Longrightarrow> CS c \\<le> \\<gamma>\\<^sub>c c'\"", "lemma mono_aval': \"S \\<sqsubseteq> S' \\<Longrightarrow> aval' e S \\<sqsubseteq> aval' e S'\"", "lemma mono_update: \"a \\<sqsubseteq> a' \\<Longrightarrow> S \\<sqsubseteq> S' \\<Longrightarrow> update S x a \\<sqsubseteq> update S' x a'\"", "lemma mono_step': \"S \\<sqsubseteq> S' \\<Longrightarrow> c \\<sqsubseteq> c' \\<Longrightarrow> step' S c \\<sqsubseteq> step' S' c'\"", "lemma strict_inv_image: \"strict(inv_image r f) = inv_image (strict r) f\"", "lemma acc_inv_image:\n  \"acc r \\<Longrightarrow> acc (inv_image r f)\"", "lemma acc_option: assumes \"acc {(x,y::'a::preord). x \\<sqsubseteq> y}\"\nshows \"acc {(x,y::'a::preord option). x \\<sqsubseteq> y}\"", "lemma measure_st: assumes \"(strict{(x,y::'a::SL_top). x \\<sqsubseteq> y})^-1 <= measure m\"\nand \"\\<forall>x y::'a::SL_top. x \\<sqsubseteq> y \\<and> y \\<sqsubseteq> x \\<longrightarrow> m x = m y\"\nshows \"(strict{(S,S'::'a::SL_top st). S \\<sqsubseteq> S'})^-1 \\<subseteq>\n  measure(%fd. \\<Sum>x| x\\<in>set(dom fd) \\<and> ~ \\<top> \\<sqsubseteq> fun fd x. m(fun fd x)+1)\"", "lemma listrel_Cons_iff:\n  \"(x#xs, y#ys) : listrel r \\<longleftrightarrow> (x,y) \\<in> r \\<and> (xs,ys) \\<in> listrel r\"", "lemma listrel_app: \"(xs1,ys1) : listrel r \\<Longrightarrow> (xs2,ys2) : listrel r\n  \\<Longrightarrow> (xs1@xs2, ys1@ys2) : listrel r\"", "lemma listrel_app_same_size: \"size xs1 = size ys1 \\<Longrightarrow> size xs2 = size ys2 \\<Longrightarrow>\n  (xs1@xs2, ys1@ys2) : listrel r \\<longleftrightarrow>\n  (xs1,ys1) : listrel r \\<and> (xs2,ys2) : listrel r\"", "lemma listrel_converse: \"listrel(r^-1) = (listrel r)^-1\"", "lemma acc_listrel: fixes r :: \"('a*'a)set\" assumes \"refl r\" and \"trans r\"\nand \"acc r\" shows \"acc (listrel r - {([],[])})\"", "lemma le_iff_le_annos: \"c1 \\<sqsubseteq> c2 \\<longleftrightarrow>\n (annos c1, annos c2) : listrel{(x,y). x \\<sqsubseteq> y} \\<and> strip c1 = strip c2\"", "lemma le_acom_subset_same_annos:\n \"(strict{(c,c'::'a::preord acom). c \\<sqsubseteq> c'})^-1 \\<subseteq>\n  (strict(inv_image (listrel{(a,a'::'a). a \\<sqsubseteq> a'} - {([],[])}) annos))^-1\"", "lemma acc_acom: \"acc {(a,a'::'a::preord). a \\<sqsubseteq> a'} \\<Longrightarrow>\n  acc {(c,c'::'a acom). c \\<sqsubseteq> c'}\"", "lemma pfp_termination:\nfixes x0 :: \"'a::preord\"\nassumes mono: \"\\<And>x y. x \\<sqsubseteq> y \\<Longrightarrow> f x \\<sqsubseteq> f y\" and \"acc {(x::'a,y). x \\<sqsubseteq> y}\"\nand \"x0 \\<sqsubseteq> f x0\" shows \"\\<exists>x. pfp f x0 = Some x\"", "lemma lpfpc_termination:\n  fixes f :: \"(('a::SL_top)option acom \\<Rightarrow> 'a option acom)\"\n  assumes \"acc {(x::'a,y). x \\<sqsubseteq> y}\" and \"\\<And>x y. x \\<sqsubseteq> y \\<Longrightarrow> f x \\<sqsubseteq> f y\"\n  and \"\\<And>c. strip(f c) = strip c\"\n  shows \"\\<exists>c'. lpfp\\<^sub>c f c = Some c'\"", "lemma AI_Some_measure:\nassumes \"(strict{(x,y::'a). x \\<sqsubseteq> y})^-1 <= measure m\"\nand \"\\<forall>x y::'a. x \\<sqsubseteq> y \\<and> y \\<sqsubseteq> x \\<longrightarrow> m x = m y\"\nshows \"\\<exists>c'. AI c = Some c'\""], "translations": [["", "lemma aval'_sound: \"s : \\<gamma>\\<^sub>f S \\<Longrightarrow> aval a s : \\<gamma>(aval' a S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> \\<gamma>\\<^sub>f S \\<Longrightarrow>\n    aval a s \\<in> \\<gamma> (aval' a S)", "by (induction a) (auto simp: gamma_num' gamma_plus' \\<gamma>_st_def lookup_def)"], ["", "end"], ["", "text\\<open>The for-clause (here and elsewhere) only serves the purpose of fixing\nthe name of the type parameter @{typ 'av} which would otherwise be renamed to\n@{typ 'a}.\\<close>"], ["", "locale Abs_Int = Gamma where \\<gamma>=\\<gamma> for \\<gamma> :: \"'av::SL_top \\<Rightarrow> val set\"\nbegin"], ["", "fun step' :: \"'av st option \\<Rightarrow> 'av st option acom \\<Rightarrow> 'av st option acom\" where\n\"step' S (SKIP {P}) = (SKIP {S})\" |\n\"step' S (x ::= e {P}) =\n  x ::= e {case S of None \\<Rightarrow> None | Some S \\<Rightarrow> Some(update S x (aval' e S))}\" |\n\"step' S (c1;; c2) = step' S c1;; step' (post c1) c2\" |\n\"step' S (IF b THEN c1 ELSE c2 {P}) =\n  (let c1' = step' S c1; c2' = step' S c2\n   in IF b THEN c1' ELSE c2' {post c1 \\<squnion> post c2})\" |\n\"step' S ({Inv} WHILE b DO c {P}) =\n   {S \\<squnion> post c} WHILE b DO step' Inv c {Inv}\""], ["", "definition AI :: \"com \\<Rightarrow> 'av st option acom option\" where\n\"AI = lpfp\\<^sub>c (step' \\<top>)\""], ["", "lemma strip_step'[simp]: \"strip(step' S c) = strip c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip (step' S c) = strip c", "by(induct c arbitrary: S) (simp_all add: Let_def)"], ["", "text\\<open>Soundness:\\<close>"], ["", "lemma in_gamma_update:\n  \"\\<lbrakk> s : \\<gamma>\\<^sub>f S; i : \\<gamma> a \\<rbrakk> \\<Longrightarrow> s(x := i) : \\<gamma>\\<^sub>f(update S x a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> \\<gamma>\\<^sub>f S; i \\<in> \\<gamma> a\\<rbrakk>\n    \\<Longrightarrow> s(x := i) \\<in> \\<gamma>\\<^sub>f (update S x a)", "by(simp add: \\<gamma>_st_def lookup_update)"], ["", "text\\<open>The soundness proofs are textually identical to the ones for the step\nfunction operating on states as functions.\\<close>"], ["", "lemma step_preserves_le:\n  \"\\<lbrakk> S \\<subseteq> \\<gamma>\\<^sub>o S'; c \\<le> \\<gamma>\\<^sub>c c' \\<rbrakk> \\<Longrightarrow> step S c \\<le> \\<gamma>\\<^sub>c (step' S' c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n     c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n    \\<Longrightarrow> step S c \\<le> \\<gamma>\\<^sub>c (step' S' c')", "proof(induction c arbitrary: c' S S')"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x c' S S'.\n       \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n        SKIP {x} \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (SKIP {x})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>x1a x2 x3 c' S S'.\n       \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n        x1a ::= x2 {x3} \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (x1a ::= x2 {x3})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 3. \\<And>c1 c2 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        c1;;\n        c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (c1;;\n                                 c2)\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 4. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 5. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "case SKIP"], ["proof (state)\nthis:\n  S \\<subseteq> \\<gamma>\\<^sub>o S'\n  SKIP {x_} \\<le> \\<gamma>\\<^sub>c c'\n\ngoal (5 subgoals):\n 1. \\<And>x c' S S'.\n       \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n        SKIP {x} \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (SKIP {x})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>x1a x2 x3 c' S S'.\n       \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n        x1a ::= x2 {x3} \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (x1a ::= x2 {x3})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 3. \\<And>c1 c2 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        c1;;\n        c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (c1;;\n                                 c2)\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 4. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 5. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "thus ?case"], ["proof (prove)\nusing this:\n  S \\<subseteq> \\<gamma>\\<^sub>o S'\n  SKIP {x_} \\<le> \\<gamma>\\<^sub>c c'\n\ngoal (1 subgoal):\n 1. step S (SKIP {x_}) \\<le> \\<gamma>\\<^sub>c (step' S' c')", "by(auto simp:SKIP_le map_acom_SKIP)"], ["proof (state)\nthis:\n  step S (SKIP {x_}) \\<le> \\<gamma>\\<^sub>c (step' S' c')\n\ngoal (4 subgoals):\n 1. \\<And>x1a x2 x3 c' S S'.\n       \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n        x1a ::= x2 {x3} \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (x1a ::= x2 {x3})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>c1 c2 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        c1;;\n        c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (c1;;\n                                 c2)\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 3. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 4. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1a x2 x3 c' S S'.\n       \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n        x1a ::= x2 {x3} \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (x1a ::= x2 {x3})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>c1 c2 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        c1;;\n        c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (c1;;\n                                 c2)\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 3. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 4. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "case Assign"], ["proof (state)\nthis:\n  S \\<subseteq> \\<gamma>\\<^sub>o S'\n  x1a_ ::= x2_ {x3_} \\<le> \\<gamma>\\<^sub>c c'\n\ngoal (4 subgoals):\n 1. \\<And>x1a x2 x3 c' S S'.\n       \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n        x1a ::= x2 {x3} \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (x1a ::= x2 {x3})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>c1 c2 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        c1;;\n        c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (c1;;\n                                 c2)\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 3. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 4. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "thus ?case"], ["proof (prove)\nusing this:\n  S \\<subseteq> \\<gamma>\\<^sub>o S'\n  x1a_ ::= x2_ {x3_} \\<le> \\<gamma>\\<^sub>c c'\n\ngoal (1 subgoal):\n 1. step S (x1a_ ::= x2_ {x3_}) \\<le> \\<gamma>\\<^sub>c (step' S' c')", "by (fastforce simp: Assign_le  map_acom_Assign intro: aval'_sound in_gamma_update\n      split: option.splits del:subsetD)"], ["proof (state)\nthis:\n  step S (x1a_ ::= x2_ {x3_}) \\<le> \\<gamma>\\<^sub>c (step' S' c')\n\ngoal (3 subgoals):\n 1. \\<And>c1 c2 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        c1;;\n        c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (c1;;\n                                 c2)\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 3. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c1 c2 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        c1;;\n        c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (c1;;\n                                 c2)\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 3. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "case Seq"], ["proof (state)\nthis:\n  \\<lbrakk>?S \\<subseteq> \\<gamma>\\<^sub>o ?S';\n   c1_ \\<le> \\<gamma>\\<^sub>c ?c'\\<rbrakk>\n  \\<Longrightarrow> step ?S c1_ \\<le> \\<gamma>\\<^sub>c (step' ?S' ?c')\n  \\<lbrakk>?S \\<subseteq> \\<gamma>\\<^sub>o ?S';\n   c2_ \\<le> \\<gamma>\\<^sub>c ?c'\\<rbrakk>\n  \\<Longrightarrow> step ?S c2_ \\<le> \\<gamma>\\<^sub>c (step' ?S' ?c')\n  S \\<subseteq> \\<gamma>\\<^sub>o S'\n  c1_;;\n  c2_ \\<le> \\<gamma>\\<^sub>c c'\n\ngoal (3 subgoals):\n 1. \\<And>c1 c2 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        c1;;\n        c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (c1;;\n                                 c2)\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 3. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?S \\<subseteq> \\<gamma>\\<^sub>o ?S';\n   c1_ \\<le> \\<gamma>\\<^sub>c ?c'\\<rbrakk>\n  \\<Longrightarrow> step ?S c1_ \\<le> \\<gamma>\\<^sub>c (step' ?S' ?c')\n  \\<lbrakk>?S \\<subseteq> \\<gamma>\\<^sub>o ?S';\n   c2_ \\<le> \\<gamma>\\<^sub>c ?c'\\<rbrakk>\n  \\<Longrightarrow> step ?S c2_ \\<le> \\<gamma>\\<^sub>c (step' ?S' ?c')\n  S \\<subseteq> \\<gamma>\\<^sub>o S'\n  c1_;;\n  c2_ \\<le> \\<gamma>\\<^sub>c c'\n\ngoal (1 subgoal):\n 1. step S (c1_;;\n            c2_)\n    \\<le> \\<gamma>\\<^sub>c (step' S' c')", "apply (auto simp: Seq_le map_acom_Seq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1a c2a.\n       \\<lbrakk>\\<And>S S' c'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1_ \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1_\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>S S' c'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2_ \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2_\n                             \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S'; c1_ \\<le> \\<gamma>\\<^sub>c c1a;\n        c2_ \\<le> \\<gamma>\\<^sub>c c2a; c' = c1a;;\n  c2a\\<rbrakk>\n       \\<Longrightarrow> step (post c1_) c2_\n                         \\<le> \\<gamma>\\<^sub>c (step' (post c1a) c2a)", "by (metis le_post post_map_acom)"], ["proof (state)\nthis:\n  step S (c1_;;\n          c2_)\n  \\<le> \\<gamma>\\<^sub>c (step' S' c')\n\ngoal (2 subgoals):\n 1. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "case (If b c1 c2 P)"], ["proof (state)\nthis:\n  \\<lbrakk>?S \\<subseteq> \\<gamma>\\<^sub>o ?S';\n   c1 \\<le> \\<gamma>\\<^sub>c ?c'\\<rbrakk>\n  \\<Longrightarrow> step ?S c1 \\<le> \\<gamma>\\<^sub>c (step' ?S' ?c')\n  \\<lbrakk>?S \\<subseteq> \\<gamma>\\<^sub>o ?S';\n   c2 \\<le> \\<gamma>\\<^sub>c ?c'\\<rbrakk>\n  \\<Longrightarrow> step ?S c2 \\<le> \\<gamma>\\<^sub>c (step' ?S' ?c')\n  S \\<subseteq> \\<gamma>\\<^sub>o S'\n  IF b THEN c1 ELSE c2\n  {P}\n  \\<le> \\<gamma>\\<^sub>c c'\n\ngoal (2 subgoals):\n 1. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?S \\<subseteq> \\<gamma>\\<^sub>o ?S';\n   c1 \\<le> \\<gamma>\\<^sub>c ?c'\\<rbrakk>\n  \\<Longrightarrow> step ?S c1 \\<le> \\<gamma>\\<^sub>c (step' ?S' ?c')\n  \\<lbrakk>?S \\<subseteq> \\<gamma>\\<^sub>o ?S';\n   c2 \\<le> \\<gamma>\\<^sub>c ?c'\\<rbrakk>\n  \\<Longrightarrow> step ?S c2 \\<le> \\<gamma>\\<^sub>c (step' ?S' ?c')\n  S \\<subseteq> \\<gamma>\\<^sub>o S'\n  IF b THEN c1 ELSE c2\n  {P}\n  \\<le> \\<gamma>\\<^sub>c c'", "obtain c1' c2' P' where\n      \"c' = IF b THEN c1' ELSE c2' {P'}\"\n      \"P \\<subseteq> \\<gamma>\\<^sub>o P'\" \"c1 \\<le> \\<gamma>\\<^sub>c c1'\" \"c2 \\<le> \\<gamma>\\<^sub>c c2'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?S \\<subseteq> \\<gamma>\\<^sub>o ?S';\n   c1 \\<le> \\<gamma>\\<^sub>c ?c'\\<rbrakk>\n  \\<Longrightarrow> step ?S c1 \\<le> \\<gamma>\\<^sub>c (step' ?S' ?c')\n  \\<lbrakk>?S \\<subseteq> \\<gamma>\\<^sub>o ?S';\n   c2 \\<le> \\<gamma>\\<^sub>c ?c'\\<rbrakk>\n  \\<Longrightarrow> step ?S c2 \\<le> \\<gamma>\\<^sub>c (step' ?S' ?c')\n  S \\<subseteq> \\<gamma>\\<^sub>o S'\n  IF b THEN c1 ELSE c2\n  {P}\n  \\<le> \\<gamma>\\<^sub>c c'\n\ngoal (1 subgoal):\n 1. (\\<And>c1' c2' P'.\n        \\<lbrakk>c' = IF b THEN c1' ELSE c2'\n                      {P'};\n         P \\<subseteq> \\<gamma>\\<^sub>o P'; c1 \\<le> \\<gamma>\\<^sub>c c1';\n         c2 \\<le> \\<gamma>\\<^sub>c c2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: If_le map_acom_If)"], ["proof (state)\nthis:\n  c' = IF b THEN c1' ELSE c2'\n       {P'}\n  P \\<subseteq> \\<gamma>\\<^sub>o P'\n  c1 \\<le> \\<gamma>\\<^sub>c c1'\n  c2 \\<le> \\<gamma>\\<^sub>c c2'\n\ngoal (2 subgoals):\n 1. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "moreover"], ["proof (state)\nthis:\n  c' = IF b THEN c1' ELSE c2'\n       {P'}\n  P \\<subseteq> \\<gamma>\\<^sub>o P'\n  c1 \\<le> \\<gamma>\\<^sub>c c1'\n  c2 \\<le> \\<gamma>\\<^sub>c c2'\n\ngoal (2 subgoals):\n 1. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "have \"post c1 \\<subseteq> \\<gamma>\\<^sub>o(post c1' \\<squnion> post c2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post c1 \\<subseteq> \\<gamma>\\<^sub>o (post c1' \\<squnion> post c2')", "by (metis (no_types) \\<open>c1 \\<le> \\<gamma>\\<^sub>c c1'\\<close> join_ge1 le_post mono_gamma_o order_trans post_map_acom)"], ["proof (state)\nthis:\n  post c1 \\<subseteq> \\<gamma>\\<^sub>o (post c1' \\<squnion> post c2')\n\ngoal (2 subgoals):\n 1. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "moreover"], ["proof (state)\nthis:\n  post c1 \\<subseteq> \\<gamma>\\<^sub>o (post c1' \\<squnion> post c2')\n\ngoal (2 subgoals):\n 1. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "have \"post c2 \\<subseteq> \\<gamma>\\<^sub>o(post c1' \\<squnion> post c2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. post c2 \\<subseteq> \\<gamma>\\<^sub>o (post c1' \\<squnion> post c2')", "by (metis (no_types) \\<open>c2 \\<le> \\<gamma>\\<^sub>c c2'\\<close> join_ge2 le_post mono_gamma_o order_trans post_map_acom)"], ["proof (state)\nthis:\n  post c2 \\<subseteq> \\<gamma>\\<^sub>o (post c1' \\<squnion> post c2')\n\ngoal (2 subgoals):\n 1. \\<And>x1a c1 c2 x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c1 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c1\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        \\<And>c' S S'.\n           \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n            c2 \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n           \\<Longrightarrow> step S c2 \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        IF x1a THEN c1 ELSE c2\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S (IF x1a THEN c1 ELSE c2\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')\n 2. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "ultimately"], ["proof (chain)\npicking this:\n  c' = IF b THEN c1' ELSE c2'\n       {P'}\n  P \\<subseteq> \\<gamma>\\<^sub>o P'\n  c1 \\<le> \\<gamma>\\<^sub>c c1'\n  c2 \\<le> \\<gamma>\\<^sub>c c2'\n  post c1 \\<subseteq> \\<gamma>\\<^sub>o (post c1' \\<squnion> post c2')\n  post c2 \\<subseteq> \\<gamma>\\<^sub>o (post c1' \\<squnion> post c2')", "show ?case"], ["proof (prove)\nusing this:\n  c' = IF b THEN c1' ELSE c2'\n       {P'}\n  P \\<subseteq> \\<gamma>\\<^sub>o P'\n  c1 \\<le> \\<gamma>\\<^sub>c c1'\n  c2 \\<le> \\<gamma>\\<^sub>c c2'\n  post c1 \\<subseteq> \\<gamma>\\<^sub>o (post c1' \\<squnion> post c2')\n  post c2 \\<subseteq> \\<gamma>\\<^sub>o (post c1' \\<squnion> post c2')\n\ngoal (1 subgoal):\n 1. step S (IF b THEN c1 ELSE c2\n            {P})\n    \\<le> \\<gamma>\\<^sub>c (step' S' c')", "using \\<open>S \\<subseteq> \\<gamma>\\<^sub>o S'\\<close>"], ["proof (prove)\nusing this:\n  c' = IF b THEN c1' ELSE c2'\n       {P'}\n  P \\<subseteq> \\<gamma>\\<^sub>o P'\n  c1 \\<le> \\<gamma>\\<^sub>c c1'\n  c2 \\<le> \\<gamma>\\<^sub>c c2'\n  post c1 \\<subseteq> \\<gamma>\\<^sub>o (post c1' \\<squnion> post c2')\n  post c2 \\<subseteq> \\<gamma>\\<^sub>o (post c1' \\<squnion> post c2')\n  S \\<subseteq> \\<gamma>\\<^sub>o S'\n\ngoal (1 subgoal):\n 1. step S (IF b THEN c1 ELSE c2\n            {P})\n    \\<le> \\<gamma>\\<^sub>c (step' S' c')", "by (simp add: If.IH subset_iff)"], ["proof (state)\nthis:\n  step S (IF b THEN c1 ELSE c2\n          {P})\n  \\<le> \\<gamma>\\<^sub>c (step' S' c')\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "case (While I b c1 P)"], ["proof (state)\nthis:\n  \\<lbrakk>?S \\<subseteq> \\<gamma>\\<^sub>o ?S';\n   c1 \\<le> \\<gamma>\\<^sub>c ?c'\\<rbrakk>\n  \\<Longrightarrow> step ?S c1 \\<le> \\<gamma>\\<^sub>c (step' ?S' ?c')\n  S \\<subseteq> \\<gamma>\\<^sub>o S'\n  {I}\n  WHILE b DO c1\n  {P}\n  \\<le> \\<gamma>\\<^sub>c c'\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?S \\<subseteq> \\<gamma>\\<^sub>o ?S';\n   c1 \\<le> \\<gamma>\\<^sub>c ?c'\\<rbrakk>\n  \\<Longrightarrow> step ?S c1 \\<le> \\<gamma>\\<^sub>c (step' ?S' ?c')\n  S \\<subseteq> \\<gamma>\\<^sub>o S'\n  {I}\n  WHILE b DO c1\n  {P}\n  \\<le> \\<gamma>\\<^sub>c c'", "obtain c1' I' P' where\n    \"c' = {I'} WHILE b DO c1' {P'}\"\n    \"I \\<subseteq> \\<gamma>\\<^sub>o I'\" \"P \\<subseteq> \\<gamma>\\<^sub>o P'\" \"c1 \\<le> \\<gamma>\\<^sub>c c1'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?S \\<subseteq> \\<gamma>\\<^sub>o ?S';\n   c1 \\<le> \\<gamma>\\<^sub>c ?c'\\<rbrakk>\n  \\<Longrightarrow> step ?S c1 \\<le> \\<gamma>\\<^sub>c (step' ?S' ?c')\n  S \\<subseteq> \\<gamma>\\<^sub>o S'\n  {I}\n  WHILE b DO c1\n  {P}\n  \\<le> \\<gamma>\\<^sub>c c'\n\ngoal (1 subgoal):\n 1. (\\<And>I' c1' P'.\n        \\<lbrakk>c' = {I'}\n                      WHILE b DO c1'\n                      {P'};\n         I \\<subseteq> \\<gamma>\\<^sub>o I';\n         P \\<subseteq> \\<gamma>\\<^sub>o P';\n         c1 \\<le> \\<gamma>\\<^sub>c c1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: map_acom_While While_le)"], ["proof (state)\nthis:\n  c' = {I'}\n       WHILE b DO c1'\n       {P'}\n  I \\<subseteq> \\<gamma>\\<^sub>o I'\n  P \\<subseteq> \\<gamma>\\<^sub>o P'\n  c1 \\<le> \\<gamma>\\<^sub>c c1'\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "moreover"], ["proof (state)\nthis:\n  c' = {I'}\n       WHILE b DO c1'\n       {P'}\n  I \\<subseteq> \\<gamma>\\<^sub>o I'\n  P \\<subseteq> \\<gamma>\\<^sub>o P'\n  c1 \\<le> \\<gamma>\\<^sub>c c1'\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "have \"S \\<union> post c1 \\<subseteq> \\<gamma>\\<^sub>o (S' \\<squnion> post c1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> post c1 \\<subseteq> \\<gamma>\\<^sub>o (S' \\<squnion> post c1')", "using \\<open>S \\<subseteq> \\<gamma>\\<^sub>o S'\\<close> le_post[OF \\<open>c1 \\<le> \\<gamma>\\<^sub>c c1'\\<close>, simplified]"], ["proof (prove)\nusing this:\n  S \\<subseteq> \\<gamma>\\<^sub>o S'\n  post c1 \\<subseteq> \\<gamma>\\<^sub>o (post c1')\n\ngoal (1 subgoal):\n 1. S \\<union> post c1 \\<subseteq> \\<gamma>\\<^sub>o (S' \\<squnion> post c1')", "by (metis (no_types) join_ge1 join_ge2 le_sup_iff mono_gamma_o order_trans)"], ["proof (state)\nthis:\n  S \\<union> post c1 \\<subseteq> \\<gamma>\\<^sub>o (S' \\<squnion> post c1')\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2 c x4 c' S S'.\n       \\<lbrakk>\\<And>c' S S'.\n                   \\<lbrakk>S \\<subseteq> \\<gamma>\\<^sub>o S';\n                    c \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n                   \\<Longrightarrow> step S c\n                                     \\<le> \\<gamma>\\<^sub>c (step' S' c');\n        S \\<subseteq> \\<gamma>\\<^sub>o S';\n        {x1a}\n        WHILE x2 DO c\n        {x4}\n        \\<le> \\<gamma>\\<^sub>c c'\\<rbrakk>\n       \\<Longrightarrow> step S ({x1a}\n                                 WHILE x2 DO c\n                                 {x4})\n                         \\<le> \\<gamma>\\<^sub>c (step' S' c')", "ultimately"], ["proof (chain)\npicking this:\n  c' = {I'}\n       WHILE b DO c1'\n       {P'}\n  I \\<subseteq> \\<gamma>\\<^sub>o I'\n  P \\<subseteq> \\<gamma>\\<^sub>o P'\n  c1 \\<le> \\<gamma>\\<^sub>c c1'\n  S \\<union> post c1 \\<subseteq> \\<gamma>\\<^sub>o (S' \\<squnion> post c1')", "show ?case"], ["proof (prove)\nusing this:\n  c' = {I'}\n       WHILE b DO c1'\n       {P'}\n  I \\<subseteq> \\<gamma>\\<^sub>o I'\n  P \\<subseteq> \\<gamma>\\<^sub>o P'\n  c1 \\<le> \\<gamma>\\<^sub>c c1'\n  S \\<union> post c1 \\<subseteq> \\<gamma>\\<^sub>o (S' \\<squnion> post c1')\n\ngoal (1 subgoal):\n 1. step S ({I}\n            WHILE b DO c1\n            {P})\n    \\<le> \\<gamma>\\<^sub>c (step' S' c')", "by (simp add: While.IH subset_iff)"], ["proof (state)\nthis:\n  step S ({I}\n          WHILE b DO c1\n          {P})\n  \\<le> \\<gamma>\\<^sub>c (step' S' c')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AI_sound: \"AI c = Some c' \\<Longrightarrow> CS c \\<le> \\<gamma>\\<^sub>c c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AI c = Some c' \\<Longrightarrow> CS c \\<le> \\<gamma>\\<^sub>c c'", "proof(simp add: CS_def AI_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. lpfp\\<^sub>c (step' \\<top>) c = Some c' \\<Longrightarrow>\n    Collecting.lfp (step UNIV) c \\<le> \\<gamma>\\<^sub>c c'", "assume 1: \"lpfp\\<^sub>c (step' \\<top>) c = Some c'\""], ["proof (state)\nthis:\n  lpfp\\<^sub>c (step' \\<top>) c = Some c'\n\ngoal (1 subgoal):\n 1. lpfp\\<^sub>c (step' \\<top>) c = Some c' \\<Longrightarrow>\n    Collecting.lfp (step UNIV) c \\<le> \\<gamma>\\<^sub>c c'", "have 2: \"step' \\<top> c' \\<sqsubseteq> c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step' \\<top> c' \\<sqsubseteq> c'", "by(rule lpfpc_pfp[OF 1])"], ["proof (state)\nthis:\n  step' \\<top> c' \\<sqsubseteq> c'\n\ngoal (1 subgoal):\n 1. lpfp\\<^sub>c (step' \\<top>) c = Some c' \\<Longrightarrow>\n    Collecting.lfp (step UNIV) c \\<le> \\<gamma>\\<^sub>c c'", "have 3: \"strip (\\<gamma>\\<^sub>c (step' \\<top> c')) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip (\\<gamma>\\<^sub>c (step' \\<top> c')) = c", "by(simp add: strip_lpfpc[OF _ 1])"], ["proof (state)\nthis:\n  strip (\\<gamma>\\<^sub>c (step' \\<top> c')) = c\n\ngoal (1 subgoal):\n 1. lpfp\\<^sub>c (step' \\<top>) c = Some c' \\<Longrightarrow>\n    Collecting.lfp (step UNIV) c \\<le> \\<gamma>\\<^sub>c c'", "have \"lfp (step UNIV) c \\<le> \\<gamma>\\<^sub>c (step' \\<top> c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collecting.lfp (step UNIV) c \\<le> \\<gamma>\\<^sub>c (step' \\<top> c')", "proof(rule lfp_lowerbound[simplified,OF 3])"], ["proof (state)\ngoal (1 subgoal):\n 1. step UNIV (\\<gamma>\\<^sub>c (step' \\<top> c'))\n    \\<le> \\<gamma>\\<^sub>c (step' \\<top> c')", "show \"step UNIV (\\<gamma>\\<^sub>c (step' \\<top> c')) \\<le> \\<gamma>\\<^sub>c (step' \\<top> c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step UNIV (\\<gamma>\\<^sub>c (step' \\<top> c'))\n    \\<le> \\<gamma>\\<^sub>c (step' \\<top> c')", "proof(rule step_preserves_le[OF _ _])"], ["proof (state)\ngoal (2 subgoals):\n 1. UNIV \\<subseteq> \\<gamma>\\<^sub>o \\<top>\n 2. \\<gamma>\\<^sub>c (step' \\<top> c') \\<le> \\<gamma>\\<^sub>c c'", "show \"UNIV \\<subseteq> \\<gamma>\\<^sub>o \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> \\<gamma>\\<^sub>o \\<top>", "by simp"], ["proof (state)\nthis:\n  UNIV \\<subseteq> \\<gamma>\\<^sub>o \\<top>\n\ngoal (1 subgoal):\n 1. \\<gamma>\\<^sub>c (step' \\<top> c') \\<le> \\<gamma>\\<^sub>c c'", "show \"\\<gamma>\\<^sub>c (step' \\<top> c') \\<le> \\<gamma>\\<^sub>c c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma>\\<^sub>c (step' \\<top> c') \\<le> \\<gamma>\\<^sub>c c'", "by(rule mono_gamma_c[OF 2])"], ["proof (state)\nthis:\n  \\<gamma>\\<^sub>c (step' \\<top> c') \\<le> \\<gamma>\\<^sub>c c'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  step UNIV (\\<gamma>\\<^sub>c (step' \\<top> c'))\n  \\<le> \\<gamma>\\<^sub>c (step' \\<top> c')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Collecting.lfp (step UNIV) c \\<le> \\<gamma>\\<^sub>c (step' \\<top> c')\n\ngoal (1 subgoal):\n 1. lpfp\\<^sub>c (step' \\<top>) c = Some c' \\<Longrightarrow>\n    Collecting.lfp (step UNIV) c \\<le> \\<gamma>\\<^sub>c c'", "from this 2"], ["proof (chain)\npicking this:\n  Collecting.lfp (step UNIV) c \\<le> \\<gamma>\\<^sub>c (step' \\<top> c')\n  step' \\<top> c' \\<sqsubseteq> c'", "show \"lfp (step UNIV) c \\<le> \\<gamma>\\<^sub>c c'\""], ["proof (prove)\nusing this:\n  Collecting.lfp (step UNIV) c \\<le> \\<gamma>\\<^sub>c (step' \\<top> c')\n  step' \\<top> c' \\<sqsubseteq> c'\n\ngoal (1 subgoal):\n 1. Collecting.lfp (step UNIV) c \\<le> \\<gamma>\\<^sub>c c'", "by (blast intro: mono_gamma_c order_trans)"], ["proof (state)\nthis:\n  Collecting.lfp (step UNIV) c \\<le> \\<gamma>\\<^sub>c c'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \"Monotonicity\""], ["", "locale Abs_Int_mono = Abs_Int +\nassumes mono_plus': \"a1 \\<sqsubseteq> b1 \\<Longrightarrow> a2 \\<sqsubseteq> b2 \\<Longrightarrow> plus' a1 a2 \\<sqsubseteq> plus' b1 b2\"\nbegin"], ["", "lemma mono_aval': \"S \\<sqsubseteq> S' \\<Longrightarrow> aval' e S \\<sqsubseteq> aval' e S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<sqsubseteq> S' \\<Longrightarrow> aval' e S \\<sqsubseteq> aval' e S'", "by(induction e) (auto simp: le_st_def lookup_def mono_plus')"], ["", "lemma mono_update: \"a \\<sqsubseteq> a' \\<Longrightarrow> S \\<sqsubseteq> S' \\<Longrightarrow> update S x a \\<sqsubseteq> update S' x a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<sqsubseteq> a'; S \\<sqsubseteq> S'\\<rbrakk>\n    \\<Longrightarrow> update S x a \\<sqsubseteq> update S' x a'", "by(auto simp add: le_st_def lookup_def update_def)"], ["", "lemma mono_step': \"S \\<sqsubseteq> S' \\<Longrightarrow> c \\<sqsubseteq> c' \\<Longrightarrow> step' S c \\<sqsubseteq> step' S' c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<sqsubseteq> S'; c \\<sqsubseteq> c'\\<rbrakk>\n    \\<Longrightarrow> step' S c \\<sqsubseteq> step' S' c'", "apply(induction c c' arbitrary: S S' rule: le_acom.induct)"], ["proof (prove)\ngoal (37 subgoals):\n 1. \\<And>S S' Sa S'a.\n       \\<lbrakk>Sa \\<sqsubseteq> S'a;\n        SKIP {S} \\<sqsubseteq> SKIP {S'}\\<rbrakk>\n       \\<Longrightarrow> step' Sa (SKIP {S}) \\<sqsubseteq>\n                         step' S'a (SKIP {S'})\n 2. \\<And>x e S x' e' S' Sa S'a.\n       \\<lbrakk>Sa \\<sqsubseteq> S'a;\n        x ::= e {S} \\<sqsubseteq> x' ::= e' {S'}\\<rbrakk>\n       \\<Longrightarrow> step' Sa (x ::= e {S}) \\<sqsubseteq>\n                         step' S'a (x' ::= e' {S'})\n 3. \\<And>c1 c2 c1' c2' S S'.\n       \\<lbrakk>\\<And>S S'.\n                   \\<lbrakk>S \\<sqsubseteq> S';\n                    c1 \\<sqsubseteq> c1'\\<rbrakk>\n                   \\<Longrightarrow> step' S c1 \\<sqsubseteq> step' S' c1';\n        \\<And>S S'.\n           \\<lbrakk>S \\<sqsubseteq> S'; c2 \\<sqsubseteq> c2'\\<rbrakk>\n           \\<Longrightarrow> step' S c2 \\<sqsubseteq> step' S' c2';\n        S \\<sqsubseteq> S'; c1;;\n                            c2 \\<sqsubseteq> c1';;\n                            c2'\\<rbrakk>\n       \\<Longrightarrow> step' S (c1;;\n                                  c2) \\<sqsubseteq>\n                         step' S' (c1';;\n                                   c2')\n 4. \\<And>b c1 c2 S b' c1' c2' S' Sa S'a.\n       \\<lbrakk>\\<And>S S'.\n                   \\<lbrakk>S \\<sqsubseteq> S';\n                    c1 \\<sqsubseteq> c1'\\<rbrakk>\n                   \\<Longrightarrow> step' S c1 \\<sqsubseteq> step' S' c1';\n        \\<And>S S'.\n           \\<lbrakk>S \\<sqsubseteq> S'; c2 \\<sqsubseteq> c2'\\<rbrakk>\n           \\<Longrightarrow> step' S c2 \\<sqsubseteq> step' S' c2';\n        Sa \\<sqsubseteq> S'a;\n        IF b THEN c1 ELSE c2\n        {S} \\<sqsubseteq>\n        IF b' THEN c1' ELSE c2'\n        {S'}\\<rbrakk>\n       \\<Longrightarrow> step' Sa (IF b THEN c1 ELSE c2\n                                   {S}) \\<sqsubseteq>\n                         step' S'a (IF b' THEN c1' ELSE c2'\n                                    {S'})\n 5. \\<And>Inv b c P Inv' b' c' P' S S'.\n       \\<lbrakk>\\<And>S S'.\n                   \\<lbrakk>S \\<sqsubseteq> S'; c \\<sqsubseteq> c'\\<rbrakk>\n                   \\<Longrightarrow> step' S c \\<sqsubseteq> step' S' c';\n        S \\<sqsubseteq> S';\n        {Inv}\n        WHILE b DO c\n        {P} \\<sqsubseteq>\n        {Inv'}\n        WHILE b' DO c'\n        {P'}\\<rbrakk>\n       \\<Longrightarrow> step' S ({Inv}\n                                  WHILE b DO c\n                                  {P}) \\<sqsubseteq>\n                         step' S' ({Inv'}\n                                   WHILE b' DO c'\n                                   {P'})\n 6. \\<And>v va vb vc S S'.\n       \\<lbrakk>S \\<sqsubseteq> S';\n        v ::= va {vb} \\<sqsubseteq> SKIP {vc}\\<rbrakk>\n       \\<Longrightarrow> step' S (v ::= va {vb}) \\<sqsubseteq>\n                         step' S' (SKIP {vc})\n 7. \\<And>v va vb vc vd S S'.\n       \\<lbrakk>S \\<sqsubseteq> S';\n        v ::= va {vb} \\<sqsubseteq> vc;;\n        vd\\<rbrakk>\n       \\<Longrightarrow> step' S (v ::= va {vb}) \\<sqsubseteq>\n                         step' S' (vc;;\n                                   vd)\n 8. \\<And>v va vb vc vd ve vf S S'.\n       \\<lbrakk>S \\<sqsubseteq> S';\n        v ::= va {vb} \\<sqsubseteq> IF vc THEN vd ELSE ve\n                                    {vf}\\<rbrakk>\n       \\<Longrightarrow> step' S (v ::= va {vb}) \\<sqsubseteq>\n                         step' S' (IF vc THEN vd ELSE ve\n                                   {vf})\n 9. \\<And>v va vb vc vd ve vf S S'.\n       \\<lbrakk>S \\<sqsubseteq> S';\n        v ::= va {vb} \\<sqsubseteq> {vc}\n                                    WHILE vd DO ve\n                                    {vf}\\<rbrakk>\n       \\<Longrightarrow> step' S (v ::= va {vb}) \\<sqsubseteq>\n                         step' S' ({vc}\n                                   WHILE vd DO ve\n                                   {vf})\n 10. \\<And>v va vb S S'.\n        \\<lbrakk>S \\<sqsubseteq> S'; v;;\n                                     va \\<sqsubseteq> SKIP {vb}\\<rbrakk>\n        \\<Longrightarrow> step' S (v;;\n                                   va) \\<sqsubseteq>\n                          step' S' (SKIP {vb})\nA total of 37 subgoals...", "apply (auto simp: Let_def mono_update mono_aval' mono_post le_join_disj\n            split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \"Ascending Chain Condition\""], ["", "abbreviation \"strict r == r \\<inter> -(r^-1)\""], ["", "abbreviation \"acc r == wf((strict r)^-1)\""], ["", "lemma strict_inv_image: \"strict(inv_image r f) = inv_image (strict r) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict (inv_image r f) = inv_image (strict r) f", "by(auto simp: inv_image_def)"], ["", "lemma acc_inv_image:\n  \"acc r \\<Longrightarrow> acc (inv_image r f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acc r \\<Longrightarrow> acc (inv_image r f)", "by (metis converse_inv_image strict_inv_image wf_inv_image)"], ["", "text\\<open>ACC for option type:\\<close>"], ["", "lemma acc_option: assumes \"acc {(x,y::'a::preord). x \\<sqsubseteq> y}\"\nshows \"acc {(x,y::'a::preord option). x \\<sqsubseteq> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acc {(x, y). x \\<sqsubseteq> y}", "proof(auto simp: wf_eq_minimal)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y.\n             z \\<sqsubseteq> y \\<and>\n             \\<not> y \\<sqsubseteq> z \\<longrightarrow>\n             y \\<notin> Q", "fix xo :: \"'a option\" and Qo"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y.\n             z \\<sqsubseteq> y \\<and>\n             \\<not> y \\<sqsubseteq> z \\<longrightarrow>\n             y \\<notin> Q", "assume \"xo : Qo\""], ["proof (state)\nthis:\n  xo \\<in> Qo\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y.\n             z \\<sqsubseteq> y \\<and>\n             \\<not> y \\<sqsubseteq> z \\<longrightarrow>\n             y \\<notin> Q", "let ?Q = \"{x. Some x \\<in> Qo}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       \\<exists>z\\<in>Q.\n          \\<forall>y.\n             z \\<sqsubseteq> y \\<and>\n             \\<not> y \\<sqsubseteq> z \\<longrightarrow>\n             y \\<notin> Q", "show \"\\<exists>yo\\<in>Qo. \\<forall>zo. yo \\<sqsubseteq> zo \\<and> ~ zo \\<sqsubseteq> yo \\<longrightarrow> zo \\<notin> Qo\" (is \"\\<exists>zo\\<in>Qo. ?P zo\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo", "assume \"?Q = {}\""], ["proof (state)\nthis:\n  {x. Some x \\<in> Qo} = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo", "hence \"?P None\""], ["proof (prove)\nusing this:\n  {x. Some x \\<in> Qo} = {}\n\ngoal (1 subgoal):\n 1. \\<forall>zo.\n       None \\<sqsubseteq> zo \\<and>\n       \\<not> zo \\<sqsubseteq> None \\<longrightarrow>\n       zo \\<notin> Qo", "by auto"], ["proof (state)\nthis:\n  \\<forall>zo.\n     None \\<sqsubseteq> zo \\<and>\n     \\<not> zo \\<sqsubseteq> None \\<longrightarrow>\n     zo \\<notin> Qo\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo", "moreover"], ["proof (state)\nthis:\n  \\<forall>zo.\n     None \\<sqsubseteq> zo \\<and>\n     \\<not> zo \\<sqsubseteq> None \\<longrightarrow>\n     zo \\<notin> Qo\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo", "have \"None \\<in> Qo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. None \\<in> Qo", "using \\<open>?Q = {}\\<close> \\<open>xo : Qo\\<close>"], ["proof (prove)\nusing this:\n  {x. Some x \\<in> Qo} = {}\n  xo \\<in> Qo\n\ngoal (1 subgoal):\n 1. None \\<in> Qo", "by auto (metis not_Some_eq)"], ["proof (state)\nthis:\n  None \\<in> Qo\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>zo.\n     None \\<sqsubseteq> zo \\<and>\n     \\<not> zo \\<sqsubseteq> None \\<longrightarrow>\n     zo \\<notin> Qo\n  None \\<in> Qo", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>zo.\n     None \\<sqsubseteq> zo \\<and>\n     \\<not> zo \\<sqsubseteq> None \\<longrightarrow>\n     zo \\<notin> Qo\n  None \\<in> Qo\n\ngoal (1 subgoal):\n 1. \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo", "by blast"], ["proof (state)\nthis:\n  \\<exists>yo\\<in>Qo.\n     \\<forall>zo.\n        yo \\<sqsubseteq> zo \\<and>\n        \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n        zo \\<notin> Qo\n\ngoal (1 subgoal):\n 1. {x. Some x \\<in> Qo} \\<noteq> {} \\<Longrightarrow>\n    \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. Some x \\<in> Qo} \\<noteq> {} \\<Longrightarrow>\n    \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo", "assume \"?Q \\<noteq> {}\""], ["proof (state)\nthis:\n  {x. Some x \\<in> Qo} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {x. Some x \\<in> Qo} \\<noteq> {} \\<Longrightarrow>\n    \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo", "with assms"], ["proof (chain)\npicking this:\n  acc {(x, y). x \\<sqsubseteq> y}\n  {x. Some x \\<in> Qo} \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  acc {(x, y). x \\<sqsubseteq> y}\n  {x. Some x \\<in> Qo} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>yo\\<in>Qo.\n       \\<forall>zo.\n          yo \\<sqsubseteq> zo \\<and>\n          \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n          zo \\<notin> Qo", "apply(auto simp: wf_eq_minimal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>Q.\n                   (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n                   (\\<exists>z\\<in>Q.\n                       \\<forall>y.\n                          z \\<sqsubseteq> y \\<and>\n                          \\<not> y \\<sqsubseteq> z \\<longrightarrow>\n                          y \\<notin> Q);\n        Some x \\<in> Qo\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yo\\<in>Qo.\n                            \\<forall>zo.\n                               yo \\<sqsubseteq> zo \\<and>\n                               \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n                               zo \\<notin> Qo", "apply(erule_tac x=\"?Q\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Some x \\<in> Qo;\n        (\\<exists>x. x \\<in> {x. Some x \\<in> Qo}) \\<longrightarrow>\n        (\\<exists>z\\<in>{x. Some x \\<in> Qo}.\n            \\<forall>y.\n               z \\<sqsubseteq> y \\<and>\n               \\<not> y \\<sqsubseteq> z \\<longrightarrow>\n               y \\<notin> {x. Some x \\<in> Qo})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yo\\<in>Qo.\n                            \\<forall>zo.\n                               yo \\<sqsubseteq> zo \\<and>\n                               \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n                               zo \\<notin> Qo", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z.\n       \\<lbrakk>Some x \\<in> Qo; Some z \\<in> Qo;\n        \\<forall>y.\n           z \\<sqsubseteq> y \\<and>\n           \\<not> y \\<sqsubseteq> z \\<longrightarrow>\n           Some y \\<notin> Qo\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yo\\<in>Qo.\n                            \\<forall>zo.\n                               yo \\<sqsubseteq> zo \\<and>\n                               \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n                               zo \\<notin> Qo", "apply(rule_tac x = \"Some z\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x z.\n       \\<lbrakk>Some x \\<in> Qo; Some z \\<in> Qo;\n        \\<forall>y.\n           z \\<sqsubseteq> y \\<and>\n           \\<not> y \\<sqsubseteq> z \\<longrightarrow>\n           Some y \\<notin> Qo\\<rbrakk>\n       \\<Longrightarrow> \\<forall>zo.\n                            Some z \\<sqsubseteq> zo \\<and>\n                            \\<not> zo \\<sqsubseteq> Some z \\<longrightarrow>\n                            zo \\<notin> Qo\n 2. \\<And>x z.\n       \\<lbrakk>Some x \\<in> Qo; Some z \\<in> Qo;\n        \\<forall>y.\n           z \\<sqsubseteq> y \\<and>\n           \\<not> y \\<sqsubseteq> z \\<longrightarrow>\n           Some y \\<notin> Qo\\<rbrakk>\n       \\<Longrightarrow> Some z \\<in> Qo", "by auto"], ["proof (state)\nthis:\n  \\<exists>yo\\<in>Qo.\n     \\<forall>zo.\n        yo \\<sqsubseteq> zo \\<and>\n        \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n        zo \\<notin> Qo\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>yo\\<in>Qo.\n     \\<forall>zo.\n        yo \\<sqsubseteq> zo \\<and>\n        \\<not> zo \\<sqsubseteq> yo \\<longrightarrow>\n        zo \\<notin> Qo\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>ACC for abstract states, via measure functions.\\<close>"], ["", "lemma measure_st: assumes \"(strict{(x,y::'a::SL_top). x \\<sqsubseteq> y})^-1 <= measure m\"\nand \"\\<forall>x y::'a::SL_top. x \\<sqsubseteq> y \\<and> y \\<sqsubseteq> x \\<longrightarrow> m x = m y\"\nshows \"(strict{(S,S'::'a::SL_top st). S \\<sqsubseteq> S'})^-1 \\<subseteq>\n  measure(%fd. \\<Sum>x| x\\<in>set(dom fd) \\<and> ~ \\<top> \\<sqsubseteq> fun fd x. m(fun fd x)+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "fix S S' :: \"'a st\""], ["proof (state)\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "assume \"S \\<sqsubseteq> S'\" \"~ S' \\<sqsubseteq> S\""], ["proof (state)\nthis:\n  S \\<sqsubseteq> S'\n  \\<not> S' \\<sqsubseteq> S\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "let ?X = \"set(dom S)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "let ?Y = \"set(dom S')\""], ["proof (state)\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "let ?f = \"fun S\""], ["proof (state)\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "let ?g = \"fun S'\""], ["proof (state)\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "let ?X' = \"{x:?X. ~ \\<top> \\<sqsubseteq> ?f x}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "let ?Y' = \"{y:?Y. ~ \\<top> \\<sqsubseteq> ?g y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "from \\<open>S \\<sqsubseteq> S'\\<close>"], ["proof (chain)\npicking this:\n  S \\<sqsubseteq> S'", "have \"\\<forall>y\\<in>?Y'\\<inter>?X. ?f y \\<sqsubseteq> ?g y\""], ["proof (prove)\nusing this:\n  S \\<sqsubseteq> S'\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>{y \\<in> set (Abs_State.dom S').\n                    \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                   set (Abs_State.dom S).\n       fun S y \\<sqsubseteq> fun S' y", "by(auto simp: le_st_def lookup_def)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n     fun S y \\<sqsubseteq> fun S' y\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "hence 1: \"\\<forall>y\\<in>?Y'\\<inter>?X. m(?g y)+1 \\<le> m(?f y)+1\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n     fun S y \\<sqsubseteq> fun S' y\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>{y \\<in> set (Abs_State.dom S').\n                    \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                   set (Abs_State.dom S).\n       m (fun S' y) + 1 \\<le> m (fun S y) + 1", "using assms(1,2)"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n     fun S y \\<sqsubseteq> fun S' y\n  (strict {(x, y). x \\<sqsubseteq> y})\\<inverse> \\<subseteq> measure m\n  \\<forall>x y.\n     x \\<sqsubseteq> y \\<and> y \\<sqsubseteq> x \\<longrightarrow> m x = m y\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>{y \\<in> set (Abs_State.dom S').\n                    \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                   set (Abs_State.dom S).\n       m (fun S' y) + 1 \\<le> m (fun S y) + 1", "by(fastforce)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n     m (fun S' y) + 1 \\<le> m (fun S y) + 1\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "from \\<open>~ S' \\<sqsubseteq> S\\<close>"], ["proof (chain)\npicking this:\n  \\<not> S' \\<sqsubseteq> S", "obtain u where u: \"u : ?X\" \"~ lookup S' u \\<sqsubseteq> ?f u\""], ["proof (prove)\nusing this:\n  \\<not> S' \\<sqsubseteq> S\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> set (Abs_State.dom S);\n         \\<not> lookup S' u \\<sqsubseteq> fun S u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp: le_st_def)"], ["proof (state)\nthis:\n  u \\<in> set (Abs_State.dom S)\n  \\<not> lookup S' u \\<sqsubseteq> fun S u\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "hence \"u : ?X'\""], ["proof (prove)\nusing this:\n  u \\<in> set (Abs_State.dom S)\n  \\<not> lookup S' u \\<sqsubseteq> fun S u\n\ngoal (1 subgoal):\n 1. u \\<in> {x \\<in> set (Abs_State.dom S).\n             \\<not> \\<top> \\<sqsubseteq> fun S x}", "by simp (metis preord_class.le_trans top)"], ["proof (state)\nthis:\n  u \\<in> {x \\<in> set (Abs_State.dom S).\n           \\<not> \\<top> \\<sqsubseteq> fun S x}\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "have \"?Y'-?X = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> set (Abs_State.dom S'). \\<not> \\<top> \\<sqsubseteq> fun S' y} -\n    set (Abs_State.dom S) =\n    {}", "using \\<open>S \\<sqsubseteq> S'\\<close>"], ["proof (prove)\nusing this:\n  S \\<sqsubseteq> S'\n\ngoal (1 subgoal):\n 1. {y \\<in> set (Abs_State.dom S'). \\<not> \\<top> \\<sqsubseteq> fun S' y} -\n    set (Abs_State.dom S) =\n    {}", "by(fastforce simp: le_st_def lookup_def)"], ["proof (state)\nthis:\n  {y \\<in> set (Abs_State.dom S'). \\<not> \\<top> \\<sqsubseteq> fun S' y} -\n  set (Abs_State.dom S) =\n  {}\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "have \"?Y'\\<inter>?X <= ?X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> set (Abs_State.dom S').\n     \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n    set (Abs_State.dom S)\n    \\<subseteq> {x \\<in> set (Abs_State.dom S).\n                 \\<not> \\<top> \\<sqsubseteq> fun S x}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (Abs_State.dom S);\n        x \\<in> set (Abs_State.dom S');\n        \\<not> \\<top> \\<sqsubseteq> fun S' x;\n        \\<top> \\<sqsubseteq> fun S x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis \\<open>S \\<sqsubseteq> S'\\<close> le_st_def lookup_def preord_class.le_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {y \\<in> set (Abs_State.dom S').\n   \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n  set (Abs_State.dom S)\n  \\<subseteq> {x \\<in> set (Abs_State.dom S).\n               \\<not> \\<top> \\<sqsubseteq> fun S x}\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "have \"(\\<Sum>y\\<in>?Y'. m(?g y)+1) = (\\<Sum>y\\<in>(?Y'-?X) \\<union> (?Y'\\<inter>?X). m(?g y)+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y | y \\<in> set (Abs_State.dom S') \\<and>\n               \\<not> \\<top> \\<sqsubseteq> fun S' y.\n       m (fun S' y) + 1) =\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} -\n                 set (Abs_State.dom S) \\<union>\n                 {y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)", "by (metis Un_Diff_Int)"], ["proof (state)\nthis:\n  (\\<Sum>y | y \\<in> set (Abs_State.dom S') \\<and>\n             \\<not> \\<top> \\<sqsubseteq> fun S' y.\n     m (fun S' y) + 1) =\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} -\n               set (Abs_State.dom S) \\<union>\n               {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1)\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>y | y \\<in> set (Abs_State.dom S') \\<and>\n             \\<not> \\<top> \\<sqsubseteq> fun S' y.\n     m (fun S' y) + 1) =\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} -\n               set (Abs_State.dom S) \\<union>\n               {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1)\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "have \"\\<dots> = (\\<Sum>y\\<in>?Y'\\<inter>?X. m(?g y)+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} -\n                 set (Abs_State.dom S) \\<union>\n                 {y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1) =\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)", "using \\<open>?Y'-?X = {}\\<close>"], ["proof (prove)\nusing this:\n  {y \\<in> set (Abs_State.dom S'). \\<not> \\<top> \\<sqsubseteq> fun S' y} -\n  set (Abs_State.dom S) =\n  {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} -\n                 set (Abs_State.dom S) \\<union>\n                 {y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1) =\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)", "by (metis Un_empty_left)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} -\n               set (Abs_State.dom S) \\<union>\n               {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1) =\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1)\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} -\n               set (Abs_State.dom S) \\<union>\n               {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1) =\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1)\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "have \"\\<dots> < (\\<Sum>x\\<in>?X'. m(?f x)+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)\n 2. \\<not> ?P \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "assume \"u \\<in> ?Y'\""], ["proof (state)\nthis:\n  u \\<in> {y \\<in> set (Abs_State.dom S').\n           \\<not> \\<top> \\<sqsubseteq> fun S' y}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)\n 2. \\<not> ?P \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "hence \"m(?g u) < m(?f u)\""], ["proof (prove)\nusing this:\n  u \\<in> {y \\<in> set (Abs_State.dom S').\n           \\<not> \\<top> \\<sqsubseteq> fun S' y}\n\ngoal (1 subgoal):\n 1. m (fun S' u) < m (fun S u)", "using assms(1) \\<open>S \\<sqsubseteq> S'\\<close> u"], ["proof (prove)\nusing this:\n  u \\<in> {y \\<in> set (Abs_State.dom S').\n           \\<not> \\<top> \\<sqsubseteq> fun S' y}\n  (strict {(x, y). x \\<sqsubseteq> y})\\<inverse> \\<subseteq> measure m\n  S \\<sqsubseteq> S'\n  u \\<in> set (Abs_State.dom S)\n  \\<not> lookup S' u \\<sqsubseteq> fun S u\n\ngoal (1 subgoal):\n 1. m (fun S' u) < m (fun S u)", "by (fastforce simp: le_st_def lookup_def)"], ["proof (state)\nthis:\n  m (fun S' u) < m (fun S u)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)\n 2. \\<not> ?P \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "have \"(\\<Sum>y\\<in>?Y'\\<inter>?X. m(?g y)+1) < (\\<Sum>y\\<in>?Y'\\<inter>?X. m(?f y)+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                    \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                   set (Abs_State.dom S).\n         m (fun S y) + 1)", "using \\<open>u:?X\\<close> \\<open>u:?Y'\\<close> \\<open>m(?g u) < m(?f u)\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> set (Abs_State.dom S)\n  u \\<in> {y \\<in> set (Abs_State.dom S').\n           \\<not> \\<top> \\<sqsubseteq> fun S' y}\n  m (fun S' u) < m (fun S u)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                    \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                   set (Abs_State.dom S).\n         m (fun S y) + 1)", "by(fastforce intro!: sum_strict_mono_ex1[OF _ 1])"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1)\n  < (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S y) + 1)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)\n 2. \\<not> ?P \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1)\n  < (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S y) + 1)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)\n 2. \\<not> ?P \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "have \"\\<dots> \\<le> (\\<Sum>y\\<in>?X'. m(?f y)+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S y) + 1)\n    \\<le> (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                        \\<not> \\<top> \\<sqsubseteq> fun S x}.\n             m (fun S y) + 1)", "by(simp add: sum_mono2[OF _ \\<open>?Y'\\<inter>?X <= ?X'\\<close>])"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S y) + 1)\n  \\<le> (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                      \\<not> \\<top> \\<sqsubseteq> fun S x}.\n           m (fun S y) + 1)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)\n 2. \\<not> ?P \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1)\n  < (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                  \\<not> \\<top> \\<sqsubseteq> fun S x}.\n       m (fun S y) + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1)\n  < (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                  \\<not> \\<top> \\<sqsubseteq> fun S x}.\n       m (fun S y) + 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "."], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1)\n  < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n               \\<not> \\<top> \\<sqsubseteq> fun S x.\n       m (fun S x) + 1)\n\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "assume \"u \\<notin> ?Y'\""], ["proof (state)\nthis:\n  u \\<notin> {y \\<in> set (Abs_State.dom S').\n              \\<not> \\<top> \\<sqsubseteq> fun S' y}\n\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "with \\<open>?Y'\\<inter>?X <= ?X'\\<close>"], ["proof (chain)\npicking this:\n  {y \\<in> set (Abs_State.dom S').\n   \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n  set (Abs_State.dom S)\n  \\<subseteq> {x \\<in> set (Abs_State.dom S).\n               \\<not> \\<top> \\<sqsubseteq> fun S x}\n  u \\<notin> {y \\<in> set (Abs_State.dom S').\n              \\<not> \\<top> \\<sqsubseteq> fun S' y}", "have \"?Y'\\<inter>?X - {u} <= ?X' - {u}\""], ["proof (prove)\nusing this:\n  {y \\<in> set (Abs_State.dom S').\n   \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n  set (Abs_State.dom S)\n  \\<subseteq> {x \\<in> set (Abs_State.dom S).\n               \\<not> \\<top> \\<sqsubseteq> fun S x}\n  u \\<notin> {y \\<in> set (Abs_State.dom S').\n              \\<not> \\<top> \\<sqsubseteq> fun S' y}\n\ngoal (1 subgoal):\n 1. {y \\<in> set (Abs_State.dom S').\n     \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n    set (Abs_State.dom S) -\n    {u}\n    \\<subseteq> {x \\<in> set (Abs_State.dom S).\n                 \\<not> \\<top> \\<sqsubseteq> fun S x} -\n                {u}", "by blast"], ["proof (state)\nthis:\n  {y \\<in> set (Abs_State.dom S').\n   \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n  set (Abs_State.dom S) -\n  {u}\n  \\<subseteq> {x \\<in> set (Abs_State.dom S).\n               \\<not> \\<top> \\<sqsubseteq> fun S x} -\n              {u}\n\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "have \"(\\<Sum>y\\<in>?Y'\\<inter>?X. m(?g y)+1) = (\\<Sum>y\\<in>?Y'\\<inter>?X - {u}. m(?g y)+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1) =\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S) -\n                 {u}.\n       m (fun S' y) + 1)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1) =\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S) -\n                 {u}.\n       m (fun S' y) + 1)", "have \"?Y'\\<inter>?X = ?Y'\\<inter>?X - {u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> set (Abs_State.dom S').\n     \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n    set (Abs_State.dom S) =\n    {y \\<in> set (Abs_State.dom S').\n     \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n    set (Abs_State.dom S) -\n    {u}", "using \\<open>u \\<notin> ?Y'\\<close>"], ["proof (prove)\nusing this:\n  u \\<notin> {y \\<in> set (Abs_State.dom S').\n              \\<not> \\<top> \\<sqsubseteq> fun S' y}\n\ngoal (1 subgoal):\n 1. {y \\<in> set (Abs_State.dom S').\n     \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n    set (Abs_State.dom S) =\n    {y \\<in> set (Abs_State.dom S').\n     \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n    set (Abs_State.dom S) -\n    {u}", "by auto"], ["proof (state)\nthis:\n  {y \\<in> set (Abs_State.dom S').\n   \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n  set (Abs_State.dom S) =\n  {y \\<in> set (Abs_State.dom S').\n   \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n  set (Abs_State.dom S) -\n  {u}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1) =\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S) -\n                 {u}.\n       m (fun S' y) + 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  {y \\<in> set (Abs_State.dom S').\n   \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n  set (Abs_State.dom S) =\n  {y \\<in> set (Abs_State.dom S').\n   \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n  set (Abs_State.dom S) -\n  {u}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1) =\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S) -\n                 {u}.\n       m (fun S' y) + 1)", "by metis"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1) =\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S) -\n               {u}.\n     m (fun S' y) + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1) =\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S) -\n               {u}.\n     m (fun S' y) + 1)\n\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1) =\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S) -\n               {u}.\n     m (fun S' y) + 1)\n\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "have \"\\<dots> < (\\<Sum>y\\<in>?Y'\\<inter>?X-{u}. m(?g y)+1) + (\\<Sum>y\\<in>{u}. m(?f y)+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S) -\n                 {u}.\n       m (fun S' y) + 1)\n    < (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                    \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                   set (Abs_State.dom S) -\n                   {u}.\n         m (fun S' y) + 1) +\n      (\\<Sum>y\\<in>{u}. m (fun S y) + 1)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S) -\n               {u}.\n     m (fun S' y) + 1)\n  < (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S) -\n                 {u}.\n       m (fun S' y) + 1) +\n    (\\<Sum>y\\<in>{u}. m (fun S y) + 1)\n\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S) -\n               {u}.\n     m (fun S' y) + 1)\n  < (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S) -\n                 {u}.\n       m (fun S' y) + 1) +\n    (\\<Sum>y\\<in>{u}. m (fun S y) + 1)\n\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "have \"(\\<Sum>y\\<in>?Y'\\<inter>?X-{u}. m(?g y)+1) \\<le> (\\<Sum>y\\<in>?Y'\\<inter>?X-{u}. m(?f y)+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S) -\n                 {u}.\n       m (fun S' y) + 1)\n    \\<le> (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                        \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                       set (Abs_State.dom S) -\n                       {u}.\n             m (fun S y) + 1)", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n     m (fun S' y) + 1 \\<le> m (fun S y) + 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S) -\n                 {u}.\n       m (fun S' y) + 1)\n    \\<le> (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                        \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                       set (Abs_State.dom S) -\n                       {u}.\n             m (fun S y) + 1)", "by(blast intro: sum_mono)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S) -\n               {u}.\n     m (fun S' y) + 1)\n  \\<le> (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                      \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                     set (Abs_State.dom S) -\n                     {u}.\n           m (fun S y) + 1)\n\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S) -\n               {u}.\n     m (fun S' y) + 1)\n  \\<le> (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                      \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                     set (Abs_State.dom S) -\n                     {u}.\n           m (fun S y) + 1)\n\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "have \"\\<dots> \\<le> (\\<Sum>y\\<in>?X'-{u}. m(?f y)+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S) -\n                 {u}.\n       m (fun S y) + 1)\n    \\<le> (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                        \\<not> \\<top> \\<sqsubseteq> fun S x} -\n                       {u}.\n             m (fun S y) + 1)", "by(simp add: sum_mono2[OF _ \\<open>?Y'\\<inter>?X-{u} <= ?X'-{u}\\<close>])"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S) -\n               {u}.\n     m (fun S y) + 1)\n  \\<le> (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                      \\<not> \\<top> \\<sqsubseteq> fun S x} -\n                     {u}.\n           m (fun S y) + 1)\n\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S) -\n               {u}.\n     m (fun S y) + 1)\n  \\<le> (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                      \\<not> \\<top> \\<sqsubseteq> fun S x} -\n                     {u}.\n           m (fun S y) + 1)\n\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "have \"\\<dots> + (\\<Sum>y\\<in>{u}. m(?f y)+1)= (\\<Sum>y\\<in>(?X'-{u}) \\<union> {u}. m(?f y)+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                  \\<not> \\<top> \\<sqsubseteq> fun S x} -\n                 {u}.\n       m (fun S y) + 1) +\n    (\\<Sum>y\\<in>{u}. m (fun S y) + 1) =\n    (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                  \\<not> \\<top> \\<sqsubseteq> fun S x} -\n                 {u} \\<union>\n                 {u}.\n       m (fun S y) + 1)", "using \\<open>u:?X'\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> {x \\<in> set (Abs_State.dom S).\n           \\<not> \\<top> \\<sqsubseteq> fun S x}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                  \\<not> \\<top> \\<sqsubseteq> fun S x} -\n                 {u}.\n       m (fun S y) + 1) +\n    (\\<Sum>y\\<in>{u}. m (fun S y) + 1) =\n    (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                  \\<not> \\<top> \\<sqsubseteq> fun S x} -\n                 {u} \\<union>\n                 {u}.\n       m (fun S y) + 1)", "by(subst sum.union_disjoint[symmetric]) auto"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                \\<not> \\<top> \\<sqsubseteq> fun S x} -\n               {u}.\n     m (fun S y) + 1) +\n  (\\<Sum>y\\<in>{u}. m (fun S y) + 1) =\n  (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                \\<not> \\<top> \\<sqsubseteq> fun S x} -\n               {u} \\<union>\n               {u}.\n     m (fun S y) + 1)\n\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                \\<not> \\<top> \\<sqsubseteq> fun S x} -\n               {u}.\n     m (fun S y) + 1) +\n  (\\<Sum>y\\<in>{u}. m (fun S y) + 1) =\n  (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                \\<not> \\<top> \\<sqsubseteq> fun S x} -\n               {u} \\<union>\n               {u}.\n     m (fun S y) + 1)\n\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "have \"\\<dots> = (\\<Sum>x\\<in>?X'. m(?f x)+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                  \\<not> \\<top> \\<sqsubseteq> fun S x} -\n                 {u} \\<union>\n                 {u}.\n       m (fun S y) + 1) =\n    (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n               \\<not> \\<top> \\<sqsubseteq> fun S x.\n       m (fun S x) + 1)", "using \\<open>u : ?X'\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> {x \\<in> set (Abs_State.dom S).\n           \\<not> \\<top> \\<sqsubseteq> fun S x}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                  \\<not> \\<top> \\<sqsubseteq> fun S x} -\n                 {u} \\<union>\n                 {u}.\n       m (fun S y) + 1) =\n    (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n               \\<not> \\<top> \\<sqsubseteq> fun S x.\n       m (fun S x) + 1)", "by(simp add:insert_absorb)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{x \\<in> set (Abs_State.dom S).\n                \\<not> \\<top> \\<sqsubseteq> fun S x} -\n               {u} \\<union>\n               {u}.\n     m (fun S y) + 1) =\n  (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n             \\<not> \\<top> \\<sqsubseteq> fun S x.\n     m (fun S x) + 1)\n\ngoal (1 subgoal):\n 1. u \\<notin> {y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<Longrightarrow>\n    (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + (\\<Sum>y\\<in>{u}. m (fun S y) + 1)\n              \\<le> y + (\\<Sum>y\\<in>{u}. m (fun S y) + 1);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + (\\<Sum>y\\<in>{u}. m (fun S y) + 1)\n      \\<le> y + (\\<Sum>y\\<in>{u}. m (fun S y) + 1)\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                                  \\<not> \\<top> \\<sqsubseteq>\n   fun S' y} \\<inter>\n                                 set (Abs_State.dom S).\n                       m (fun S' y) + 1)\n                    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n                         m (fun S x) + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + (\\<Sum>y\\<in>{u}. m (fun S y) + 1)\n              \\<le> y + (\\<Sum>y\\<in>{u}. m (fun S y) + 1);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + (\\<Sum>y\\<in>{u}. m (fun S y) + 1)\n      \\<le> y + (\\<Sum>y\\<in>{u}. m (fun S y) + 1)\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                                  \\<not> \\<top> \\<sqsubseteq>\n   fun S' y} \\<inter>\n                                 set (Abs_State.dom S).\n                       m (fun S' y) + 1)\n                    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n                         m (fun S x) + 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                  \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n                 set (Abs_State.dom S).\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "by (blast intro: add_right_mono)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1)\n  < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n               \\<not> \\<top> \\<sqsubseteq> fun S x.\n       m (fun S x) + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{y \\<in> set (Abs_State.dom S').\n                \\<not> \\<top> \\<sqsubseteq> fun S' y} \\<inter>\n               set (Abs_State.dom S).\n     m (fun S' y) + 1)\n  < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n               \\<not> \\<top> \\<sqsubseteq> fun S x.\n       m (fun S x) + 1)\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>y | y \\<in> set (Abs_State.dom S') \\<and>\n             \\<not> \\<top> \\<sqsubseteq> fun S' y.\n     m (fun S' y) + 1)\n  < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n               \\<not> \\<top> \\<sqsubseteq> fun S x.\n       m (fun S x) + 1)", "have \"(\\<Sum>y\\<in>?Y'. m(?g y)+1) < (\\<Sum>x\\<in>?X'. m(?f x)+1)\""], ["proof (prove)\nusing this:\n  (\\<Sum>y | y \\<in> set (Abs_State.dom S') \\<and>\n             \\<not> \\<top> \\<sqsubseteq> fun S' y.\n     m (fun S' y) + 1)\n  < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n               \\<not> \\<top> \\<sqsubseteq> fun S x.\n       m (fun S x) + 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y | y \\<in> set (Abs_State.dom S') \\<and>\n               \\<not> \\<top> \\<sqsubseteq> fun S' y.\n       m (fun S' y) + 1)\n    < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n                 \\<not> \\<top> \\<sqsubseteq> fun S x.\n         m (fun S x) + 1)", "."], ["proof (state)\nthis:\n  (\\<Sum>y | y \\<in> set (Abs_State.dom S') \\<and>\n             \\<not> \\<top> \\<sqsubseteq> fun S' y.\n     m (fun S' y) + 1)\n  < (\\<Sum>x | x \\<in> set (Abs_State.dom S) \\<and>\n               \\<not> \\<top> \\<sqsubseteq> fun S x.\n       m (fun S x) + 1)\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?S2 \\<sqsubseteq> ?S'2; \\<not> ?S'2 \\<sqsubseteq> ?S2\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>y | y \\<in> set (Abs_State.dom ?S'2) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun ?S'2 y.\n                       m (fun ?S'2 y) + 1)\n                    < (\\<Sum>x | x \\<in> set (Abs_State.dom ?S2) \\<and>\n                                 \\<not> \\<top> \\<sqsubseteq> fun ?S2 x.\n                         m (fun ?S2 x) + 1)\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?S2 \\<sqsubseteq> ?S'2; \\<not> ?S'2 \\<sqsubseteq> ?S2\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>y | y \\<in> set (Abs_State.dom ?S'2) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun ?S'2 y.\n                       m (fun ?S'2 y) + 1)\n                    < (\\<Sum>x | x \\<in> set (Abs_State.dom ?S2) \\<and>\n                                 \\<not> \\<top> \\<sqsubseteq> fun ?S2 x.\n                         m (fun ?S2 x) + 1)\n\ngoal (1 subgoal):\n 1. (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n    \\<subseteq> measure\n                 (\\<lambda>fd.\n                     \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                               \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                       m (fun fd x) + 1)", "by(auto simp add: measure_def inv_image_def)"], ["proof (state)\nthis:\n  (strict {(S, S'). S \\<sqsubseteq> S'})\\<inverse>\n  \\<subseteq> measure\n               (\\<lambda>fd.\n                   \\<Sum>x | x \\<in> set (Abs_State.dom fd) \\<and>\n                             \\<not> \\<top> \\<sqsubseteq> fun fd x.\n                     m (fun fd x) + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>ACC for acom. First the ordering on acom is related to an ordering on\nlists of annotations.\\<close>"], ["", "(* FIXME mv and add [simp] *)"], ["", "lemma listrel_Cons_iff:\n  \"(x#xs, y#ys) : listrel r \\<longleftrightarrow> (x,y) \\<in> r \\<and> (xs,ys) \\<in> listrel r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x # xs, y # ys) \\<in> listrel r) =\n    ((x, y) \\<in> r \\<and> (xs, ys) \\<in> listrel r)", "by (blast intro:listrel.Cons)"], ["", "lemma listrel_app: \"(xs1,ys1) : listrel r \\<Longrightarrow> (xs2,ys2) : listrel r\n  \\<Longrightarrow> (xs1@xs2, ys1@ys2) : listrel r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xs1, ys1) \\<in> listrel r; (xs2, ys2) \\<in> listrel r\\<rbrakk>\n    \\<Longrightarrow> (xs1 @ xs2, ys1 @ ys2) \\<in> listrel r", "by(auto simp add: listrel_iff_zip)"], ["", "lemma listrel_app_same_size: \"size xs1 = size ys1 \\<Longrightarrow> size xs2 = size ys2 \\<Longrightarrow>\n  (xs1@xs2, ys1@ys2) : listrel r \\<longleftrightarrow>\n  (xs1,ys1) : listrel r \\<and> (xs2,ys2) : listrel r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs1 = length ys1; length xs2 = length ys2\\<rbrakk>\n    \\<Longrightarrow> ((xs1 @ xs2, ys1 @ ys2) \\<in> listrel r) =\n                      ((xs1, ys1) \\<in> listrel r \\<and>\n                       (xs2, ys2) \\<in> listrel r)", "by(auto simp add: listrel_iff_zip)"], ["", "lemma listrel_converse: \"listrel(r^-1) = (listrel r)^-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. listrel (r\\<inverse>) = (listrel r)\\<inverse>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. listrel (r\\<inverse>) = (listrel r)\\<inverse>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. listrel (r\\<inverse>) = (listrel r)\\<inverse>", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. listrel (r\\<inverse>) = (listrel r)\\<inverse>", "have \"(xs,ys) : listrel(r^-1) \\<longleftrightarrow> (ys,xs) : listrel r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((xs, ys) \\<in> listrel (r\\<inverse>)) = ((ys, xs) \\<in> listrel r)", "apply(induct xs arbitrary: ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       (([], ys) \\<in> listrel (r\\<inverse>)) = ((ys, []) \\<in> listrel r)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           ((xs, ys) \\<in> listrel (r\\<inverse>)) =\n           ((ys, xs) \\<in> listrel r)) \\<Longrightarrow>\n       ((a # xs, ys) \\<in> listrel (r\\<inverse>)) =\n       ((ys, a # xs) \\<in> listrel r)", "apply (fastforce simp: listrel.Nil)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           ((xs, ys) \\<in> listrel (r\\<inverse>)) =\n           ((ys, xs) \\<in> listrel r)) \\<Longrightarrow>\n       ((a # xs, ys) \\<in> listrel (r\\<inverse>)) =\n       ((ys, a # xs) \\<in> listrel r)", "apply (fastforce simp: listrel_Cons_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((xs, ys) \\<in> listrel (r\\<inverse>)) = ((ys, xs) \\<in> listrel r)\n\ngoal (1 subgoal):\n 1. listrel (r\\<inverse>) = (listrel r)\\<inverse>", "}"], ["proof (state)\nthis:\n  ((?xs2, ?ys2) \\<in> listrel (r\\<inverse>)) =\n  ((?ys2, ?xs2) \\<in> listrel r)\n\ngoal (1 subgoal):\n 1. listrel (r\\<inverse>) = (listrel r)\\<inverse>", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((?xs2, ?ys2) \\<in> listrel (r\\<inverse>)) =\n  ((?ys2, ?xs2) \\<in> listrel r)\n\ngoal (1 subgoal):\n 1. listrel (r\\<inverse>) = (listrel r)\\<inverse>", "by auto"], ["proof (state)\nthis:\n  listrel (r\\<inverse>) = (listrel r)\\<inverse>\n\ngoal:\nNo subgoals!", "qed"], ["", "(* It would be nice to get rid of refl & trans and build them into the proof *)"], ["", "lemma acc_listrel: fixes r :: \"('a*'a)set\" assumes \"refl r\" and \"trans r\"\nand \"acc r\" shows \"acc (listrel r - {([],[])})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acc (listrel r - {([], [])})", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. acc (listrel r - {([], [])})", "have refl: \"!!x. (x,x) : r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (x, x) \\<in> r", "using \\<open>refl r\\<close>"], ["proof (prove)\nusing this:\n  refl r\n\ngoal (1 subgoal):\n 1. \\<And>x. (x, x) \\<in> r", "unfolding refl_on_def"], ["proof (prove)\nusing this:\n  r \\<subseteq> UNIV \\<times> UNIV \\<and>\n  (\\<forall>x\\<in>UNIV. (x, x) \\<in> r)\n\ngoal (1 subgoal):\n 1. \\<And>x. (x, x) \\<in> r", "by blast"], ["proof (state)\nthis:\n  (?x, ?x) \\<in> r\n\ngoal (1 subgoal):\n 1. acc (listrel r - {([], [])})", "have trans: \"!!x y z. (x,y) : r \\<Longrightarrow> (y,z) : r \\<Longrightarrow> (x,z) : r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, z) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r", "using \\<open>trans r\\<close>"], ["proof (prove)\nusing this:\n  trans r\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, z) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r", "unfolding trans_def"], ["proof (prove)\nusing this:\n  \\<forall>x y z.\n     (x, y) \\<in> r \\<longrightarrow>\n     (y, z) \\<in> r \\<longrightarrow> (x, z) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> r; (y, z) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, ?y) \\<in> r; (?y, ?z) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> r\n\ngoal (1 subgoal):\n 1. acc (listrel r - {([], [])})", "from assms(3)"], ["proof (chain)\npicking this:\n  acc r", "obtain mx :: \"'a set \\<Rightarrow> 'a\" where\n    mx: \"!!S x. x:S \\<Longrightarrow> mx S : S \\<and> (\\<forall>y. (mx S,y) : strict r \\<longrightarrow> y \\<notin> S)\""], ["proof (prove)\nusing this:\n  acc r\n\ngoal (1 subgoal):\n 1. (\\<And>mx.\n        (\\<And>S x.\n            x \\<in> S \\<Longrightarrow>\n            mx S \\<in> S \\<and>\n            (\\<forall>y.\n                (mx S, y) \\<in> strict r \\<longrightarrow>\n                y \\<notin> S)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(simp add: wf_eq_minimal) metis"], ["proof (state)\nthis:\n  ?x \\<in> ?S \\<Longrightarrow>\n  mx ?S \\<in> ?S \\<and>\n  (\\<forall>y. (mx ?S, y) \\<in> strict r \\<longrightarrow> y \\<notin> ?S)\n\ngoal (1 subgoal):\n 1. acc (listrel r - {([], [])})", "let ?R = \"listrel r - {([], [])}\""], ["proof (state)\ngoal (1 subgoal):\n 1. acc (listrel r - {([], [])})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. acc (listrel r - {([], [])})", "fix Q and xs :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. acc (listrel r - {([], [])})", "have \"xs \\<in> Q \\<Longrightarrow> \\<exists>ys. ys\\<in>Q \\<and> (\\<forall>zs. (ys, zs) \\<in> strict ?R \\<longrightarrow> zs \\<notin> Q)\"\n      (is \"_ \\<Longrightarrow> \\<exists>ys. ?P Q ys\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> Q \\<Longrightarrow>\n    \\<exists>ys.\n       ys \\<in> Q \\<and>\n       (\\<forall>zs.\n           (ys, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n           zs \\<notin> Q)", "proof(induction xs arbitrary: Q rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs Q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       ys \\<in> x \\<longrightarrow>\n                       (\\<exists>ys.\n                           ys \\<in> x \\<and>\n                           (\\<forall>zs.\n                               (ys, zs)\n                               \\<in> strict\n(listrel r - {([], [])}) \\<longrightarrow>\n                               zs \\<notin> x)));\n        xs \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            ys \\<in> Q \\<and>\n                            (\\<forall>zs.\n                                (ys, zs)\n                                \\<in> strict\n (listrel r - {([], [])}) \\<longrightarrow>\n                                zs \\<notin> Q)", "case (1 xs)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     (\\<forall>x.\n         ys \\<in> x \\<longrightarrow>\n         (\\<exists>ys.\n             ys \\<in> x \\<and>\n             (\\<forall>zs.\n                 (ys, zs)\n                 \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n                 zs \\<notin> x)))\n  xs \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>xs Q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       ys \\<in> x \\<longrightarrow>\n                       (\\<exists>ys.\n                           ys \\<in> x \\<and>\n                           (\\<forall>zs.\n                               (ys, zs)\n                               \\<in> strict\n(listrel r - {([], [])}) \\<longrightarrow>\n                               zs \\<notin> x)));\n        xs \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            ys \\<in> Q \\<and>\n                            (\\<forall>zs.\n                                (ys, zs)\n                                \\<in> strict\n (listrel r - {([], [])}) \\<longrightarrow>\n                                zs \\<notin> Q)", "{"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     (\\<forall>x.\n         ys \\<in> x \\<longrightarrow>\n         (\\<exists>ys.\n             ys \\<in> x \\<and>\n             (\\<forall>zs.\n                 (ys, zs)\n                 \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n                 zs \\<notin> x)))\n  xs \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>xs Q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       ys \\<in> x \\<longrightarrow>\n                       (\\<exists>ys.\n                           ys \\<in> x \\<and>\n                           (\\<forall>zs.\n                               (ys, zs)\n                               \\<in> strict\n(listrel r - {([], [])}) \\<longrightarrow>\n                               zs \\<notin> x)));\n        xs \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            ys \\<in> Q \\<and>\n                            (\\<forall>zs.\n                                (ys, zs)\n                                \\<in> strict\n (listrel r - {([], [])}) \\<longrightarrow>\n                                zs \\<notin> Q)", "have \"!!ys Q. size ys < size xs \\<Longrightarrow> ys : Q \\<Longrightarrow> \\<exists>ms. ?P Q ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys Q.\n       \\<lbrakk>length ys < length xs; ys \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms.\n                            ms \\<in> Q \\<and>\n                            (\\<forall>zs.\n                                (ms, zs)\n                                \\<in> strict\n (listrel r - {([], [])}) \\<longrightarrow>\n                                zs \\<notin> Q)", "using \"1.IH\""], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     (\\<forall>x.\n         ys \\<in> x \\<longrightarrow>\n         (\\<exists>ys.\n             ys \\<in> x \\<and>\n             (\\<forall>zs.\n                 (ys, zs)\n                 \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n                 zs \\<notin> x)))\n\ngoal (1 subgoal):\n 1. \\<And>ys Q.\n       \\<lbrakk>length ys < length xs; ys \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms.\n                            ms \\<in> Q \\<and>\n                            (\\<forall>zs.\n                                (ms, zs)\n                                \\<in> strict\n (listrel r - {([], [])}) \\<longrightarrow>\n                                zs \\<notin> Q)", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ys < length xs; ?ys \\<in> ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ms.\n                       ms \\<in> ?Q \\<and>\n                       (\\<forall>zs.\n                           (ms, zs)\n                           \\<in> strict\n                                  (listrel r - {([], [])}) \\<longrightarrow>\n                           zs \\<notin> ?Q)\n\ngoal (1 subgoal):\n 1. \\<And>xs Q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       ys \\<in> x \\<longrightarrow>\n                       (\\<exists>ys.\n                           ys \\<in> x \\<and>\n                           (\\<forall>zs.\n                               (ys, zs)\n                               \\<in> strict\n(listrel r - {([], [])}) \\<longrightarrow>\n                               zs \\<notin> x)));\n        xs \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            ys \\<in> Q \\<and>\n                            (\\<forall>zs.\n                                (ys, zs)\n                                \\<in> strict\n (listrel r - {([], [])}) \\<longrightarrow>\n                                zs \\<notin> Q)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ys < length xs; ?ys \\<in> ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ms.\n                       ms \\<in> ?Q \\<and>\n                       (\\<forall>zs.\n                           (ms, zs)\n                           \\<in> strict\n                                  (listrel r - {([], [])}) \\<longrightarrow>\n                           zs \\<notin> ?Q)\n\ngoal (1 subgoal):\n 1. \\<And>xs Q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       ys \\<in> x \\<longrightarrow>\n                       (\\<exists>ys.\n                           ys \\<in> x \\<and>\n                           (\\<forall>zs.\n                               (ys, zs)\n                               \\<in> strict\n(listrel r - {([], [])}) \\<longrightarrow>\n                               zs \\<notin> x)));\n        xs \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            ys \\<in> Q \\<and>\n                            (\\<forall>zs.\n                                (ys, zs)\n                                \\<in> strict\n (listrel r - {([], [])}) \\<longrightarrow>\n                                zs \\<notin> Q)", "note IH = this"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ys < length xs; ?ys \\<in> ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ms.\n                       ms \\<in> ?Q \\<and>\n                       (\\<forall>zs.\n                           (ms, zs)\n                           \\<in> strict\n                                  (listrel r - {([], [])}) \\<longrightarrow>\n                           zs \\<notin> ?Q)\n\ngoal (1 subgoal):\n 1. \\<And>xs Q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       ys \\<in> x \\<longrightarrow>\n                       (\\<exists>ys.\n                           ys \\<in> x \\<and>\n                           (\\<forall>zs.\n                               (ys, zs)\n                               \\<in> strict\n(listrel r - {([], [])}) \\<longrightarrow>\n                               zs \\<notin> x)));\n        xs \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            ys \\<in> Q \\<and>\n                            (\\<forall>zs.\n                                (ys, zs)\n                                \\<in> strict\n (listrel r - {([], [])}) \\<longrightarrow>\n                                zs \\<notin> Q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       ys \\<in> Q \\<and>\n       (\\<forall>zs.\n           (ys, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n           zs \\<notin> Q)", "proof(cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    \\<exists>ys.\n       ys \\<in> Q \\<and>\n       (\\<forall>zs.\n           (ys, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n           zs \\<notin> Q)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    \\<exists>ys.\n       ys \\<in> Q \\<and>\n       (\\<forall>zs.\n           (ys, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n           zs \\<notin> Q)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "with \\<open>xs : Q\\<close>"], ["proof (chain)\npicking this:\n  xs \\<in> Q\n  xs = []", "have \"?P Q []\""], ["proof (prove)\nusing this:\n  xs \\<in> Q\n  xs = []\n\ngoal (1 subgoal):\n 1. [] \\<in> Q \\<and>\n    (\\<forall>zs.\n        ([], zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n        zs \\<notin> Q)", "by auto"], ["proof (state)\nthis:\n  [] \\<in> Q \\<and>\n  (\\<forall>zs.\n      ([], zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n      zs \\<notin> Q)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    \\<exists>ys.\n       ys \\<in> Q \\<and>\n       (\\<forall>zs.\n           (ys, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n           zs \\<notin> Q)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [] \\<in> Q \\<and>\n  (\\<forall>zs.\n      ([], zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n      zs \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       ys \\<in> Q \\<and>\n       (\\<forall>zs.\n           (ys, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n           zs \\<notin> Q)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys.\n     ys \\<in> Q \\<and>\n     (\\<forall>zs.\n         (ys, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n         zs \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "case (Cons x ys)"], ["proof (state)\nthis:\n  xs = x # ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "let ?Q1 = \"{a. \\<exists>bs. size bs = size ys \\<and> a#bs : Q}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "have \"x : ?Q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {a. \\<exists>bs. length bs = length ys \\<and> a # bs \\<in> Q}", "using \\<open>xs : Q\\<close> Cons"], ["proof (prove)\nusing this:\n  xs \\<in> Q\n  xs = x # ys\n\ngoal (1 subgoal):\n 1. x \\<in> {a. \\<exists>bs. length bs = length ys \\<and> a # bs \\<in> Q}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {a. \\<exists>bs. length bs = length ys \\<and> a # bs \\<in> Q}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "from mx[OF this]"], ["proof (chain)\npicking this:\n  mx {a. \\<exists>bs. length bs = length ys \\<and> a # bs \\<in> Q}\n  \\<in> {a. \\<exists>bs. length bs = length ys \\<and> a # bs \\<in> Q} \\<and>\n  (\\<forall>y.\n      (mx {a. \\<exists>bs. length bs = length ys \\<and> a # bs \\<in> Q}, y)\n      \\<in> strict r \\<longrightarrow>\n      y \\<notin> {a. \\<exists>bs.\n                        length bs = length ys \\<and> a # bs \\<in> Q})", "obtain m1 where\n          1: \"m1 \\<in> ?Q1 \\<and> (\\<forall>y. (m1,y) \\<in> strict r \\<longrightarrow> y \\<notin> ?Q1)\""], ["proof (prove)\nusing this:\n  mx {a. \\<exists>bs. length bs = length ys \\<and> a # bs \\<in> Q}\n  \\<in> {a. \\<exists>bs. length bs = length ys \\<and> a # bs \\<in> Q} \\<and>\n  (\\<forall>y.\n      (mx {a. \\<exists>bs. length bs = length ys \\<and> a # bs \\<in> Q}, y)\n      \\<in> strict r \\<longrightarrow>\n      y \\<notin> {a. \\<exists>bs.\n                        length bs = length ys \\<and> a # bs \\<in> Q})\n\ngoal (1 subgoal):\n 1. (\\<And>m1.\n        m1 \\<in> {a. \\<exists>bs.\n                        length bs = length ys \\<and> a # bs \\<in> Q} \\<and>\n        (\\<forall>y.\n            (m1, y) \\<in> strict r \\<longrightarrow>\n            y \\<notin> {a. \\<exists>bs.\n                              length bs = length ys \\<and>\n                              a # bs \\<in> Q}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m1 \\<in> {a. \\<exists>bs.\n                  length bs = length ys \\<and> a # bs \\<in> Q} \\<and>\n  (\\<forall>y.\n      (m1, y) \\<in> strict r \\<longrightarrow>\n      y \\<notin> {a. \\<exists>bs.\n                        length bs = length ys \\<and> a # bs \\<in> Q})\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "then"], ["proof (chain)\npicking this:\n  m1 \\<in> {a. \\<exists>bs.\n                  length bs = length ys \\<and> a # bs \\<in> Q} \\<and>\n  (\\<forall>y.\n      (m1, y) \\<in> strict r \\<longrightarrow>\n      y \\<notin> {a. \\<exists>bs.\n                        length bs = length ys \\<and> a # bs \\<in> Q})", "obtain ms1 where \"size ms1 = size ys\" \"m1#ms1 : Q\""], ["proof (prove)\nusing this:\n  m1 \\<in> {a. \\<exists>bs.\n                  length bs = length ys \\<and> a # bs \\<in> Q} \\<and>\n  (\\<forall>y.\n      (m1, y) \\<in> strict r \\<longrightarrow>\n      y \\<notin> {a. \\<exists>bs.\n                        length bs = length ys \\<and> a # bs \\<in> Q})\n\ngoal (1 subgoal):\n 1. (\\<And>ms1.\n        \\<lbrakk>length ms1 = length ys; m1 # ms1 \\<in> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast+"], ["proof (state)\nthis:\n  length ms1 = length ys\n  m1 # ms1 \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "hence \"size ms1 < size xs\""], ["proof (prove)\nusing this:\n  length ms1 = length ys\n  m1 # ms1 \\<in> Q\n\ngoal (1 subgoal):\n 1. length ms1 < length xs", "using Cons"], ["proof (prove)\nusing this:\n  length ms1 = length ys\n  m1 # ms1 \\<in> Q\n  xs = x # ys\n\ngoal (1 subgoal):\n 1. length ms1 < length xs", "by auto"], ["proof (state)\nthis:\n  length ms1 < length xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "let ?Q2 = \"{bs. \\<exists>m1'. (m1',m1):r \\<and> (m1,m1'):r \\<and> m1'#bs : Q \\<and> size bs = size ms1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "have \"ms1 : ?Q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ms1\n    \\<in> {bs.\n           \\<exists>m1'.\n              (m1', m1) \\<in> r \\<and>\n              (m1, m1') \\<in> r \\<and>\n              m1' # bs \\<in> Q \\<and> length bs = length ms1}", "using \\<open>m1#ms1 : Q\\<close>"], ["proof (prove)\nusing this:\n  m1 # ms1 \\<in> Q\n\ngoal (1 subgoal):\n 1. ms1\n    \\<in> {bs.\n           \\<exists>m1'.\n              (m1', m1) \\<in> r \\<and>\n              (m1, m1') \\<in> r \\<and>\n              m1' # bs \\<in> Q \\<and> length bs = length ms1}", "by(blast intro: refl)"], ["proof (state)\nthis:\n  ms1\n  \\<in> {bs.\n         \\<exists>m1'.\n            (m1', m1) \\<in> r \\<and>\n            (m1, m1') \\<in> r \\<and>\n            m1' # bs \\<in> Q \\<and> length bs = length ms1}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "from IH[OF \\<open>size ms1 < size xs\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>ms.\n     ms \\<in> {bs.\n               \\<exists>m1'.\n                  (m1', m1) \\<in> r \\<and>\n                  (m1, m1') \\<in> r \\<and>\n                  m1' # bs \\<in> Q \\<and> length bs = length ms1} \\<and>\n     (\\<forall>zs.\n         (ms, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n         zs \\<notin> {bs.\n                      \\<exists>m1'.\n                         (m1', m1) \\<in> r \\<and>\n                         (m1, m1') \\<in> r \\<and>\n                         m1' # bs \\<in> Q \\<and> length bs = length ms1})", "obtain ms where 2: \"?P ?Q2 ms\""], ["proof (prove)\nusing this:\n  \\<exists>ms.\n     ms \\<in> {bs.\n               \\<exists>m1'.\n                  (m1', m1) \\<in> r \\<and>\n                  (m1, m1') \\<in> r \\<and>\n                  m1' # bs \\<in> Q \\<and> length bs = length ms1} \\<and>\n     (\\<forall>zs.\n         (ms, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n         zs \\<notin> {bs.\n                      \\<exists>m1'.\n                         (m1', m1) \\<in> r \\<and>\n                         (m1, m1') \\<in> r \\<and>\n                         m1' # bs \\<in> Q \\<and> length bs = length ms1})\n\ngoal (1 subgoal):\n 1. (\\<And>ms.\n        ms \\<in> {bs.\n                  \\<exists>m1'.\n                     (m1', m1) \\<in> r \\<and>\n                     (m1, m1') \\<in> r \\<and>\n                     m1' # bs \\<in> Q \\<and> length bs = length ms1} \\<and>\n        (\\<forall>zs.\n            (ms, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n            zs \\<notin> {bs.\n                         \\<exists>m1'.\n                            (m1', m1) \\<in> r \\<and>\n                            (m1, m1') \\<in> r \\<and>\n                            m1' # bs \\<in> Q \\<and>\n                            length bs = length ms1}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ms \\<in> {bs.\n            \\<exists>m1'.\n               (m1', m1) \\<in> r \\<and>\n               (m1, m1') \\<in> r \\<and>\n               m1' # bs \\<in> Q \\<and> length bs = length ms1} \\<and>\n  (\\<forall>zs.\n      (ms, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n      zs \\<notin> {bs.\n                   \\<exists>m1'.\n                      (m1', m1) \\<in> r \\<and>\n                      (m1, m1') \\<in> r \\<and>\n                      m1' # bs \\<in> Q \\<and> length bs = length ms1})\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "then"], ["proof (chain)\npicking this:\n  ms \\<in> {bs.\n            \\<exists>m1'.\n               (m1', m1) \\<in> r \\<and>\n               (m1, m1') \\<in> r \\<and>\n               m1' # bs \\<in> Q \\<and> length bs = length ms1} \\<and>\n  (\\<forall>zs.\n      (ms, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n      zs \\<notin> {bs.\n                   \\<exists>m1'.\n                      (m1', m1) \\<in> r \\<and>\n                      (m1, m1') \\<in> r \\<and>\n                      m1' # bs \\<in> Q \\<and> length bs = length ms1})", "obtain m1' where m1': \"(m1',m1) : r \\<and> (m1,m1') : r \\<and> m1'#ms : Q\""], ["proof (prove)\nusing this:\n  ms \\<in> {bs.\n            \\<exists>m1'.\n               (m1', m1) \\<in> r \\<and>\n               (m1, m1') \\<in> r \\<and>\n               m1' # bs \\<in> Q \\<and> length bs = length ms1} \\<and>\n  (\\<forall>zs.\n      (ms, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n      zs \\<notin> {bs.\n                   \\<exists>m1'.\n                      (m1', m1) \\<in> r \\<and>\n                      (m1, m1') \\<in> r \\<and>\n                      m1' # bs \\<in> Q \\<and> length bs = length ms1})\n\ngoal (1 subgoal):\n 1. (\\<And>m1'.\n        (m1', m1) \\<in> r \\<and>\n        (m1, m1') \\<in> r \\<and> m1' # ms \\<in> Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (m1', m1) \\<in> r \\<and> (m1, m1') \\<in> r \\<and> m1' # ms \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "hence \"\\<forall>ab. (m1'#ms,ab) : strict ?R \\<longrightarrow> ab \\<notin> Q\""], ["proof (prove)\nusing this:\n  (m1', m1) \\<in> r \\<and> (m1, m1') \\<in> r \\<and> m1' # ms \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<forall>ab.\n       (m1' # ms, ab)\n       \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n       ab \\<notin> Q", "using 1 2"], ["proof (prove)\nusing this:\n  (m1', m1) \\<in> r \\<and> (m1, m1') \\<in> r \\<and> m1' # ms \\<in> Q\n  m1 \\<in> {a. \\<exists>bs.\n                  length bs = length ys \\<and> a # bs \\<in> Q} \\<and>\n  (\\<forall>y.\n      (m1, y) \\<in> strict r \\<longrightarrow>\n      y \\<notin> {a. \\<exists>bs.\n                        length bs = length ys \\<and> a # bs \\<in> Q})\n  ms \\<in> {bs.\n            \\<exists>m1'.\n               (m1', m1) \\<in> r \\<and>\n               (m1, m1') \\<in> r \\<and>\n               m1' # bs \\<in> Q \\<and> length bs = length ms1} \\<and>\n  (\\<forall>zs.\n      (ms, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n      zs \\<notin> {bs.\n                   \\<exists>m1'.\n                      (m1', m1) \\<in> r \\<and>\n                      (m1, m1') \\<in> r \\<and>\n                      m1' # bs \\<in> Q \\<and> length bs = length ms1})\n\ngoal (1 subgoal):\n 1. \\<forall>ab.\n       (m1' # ms, ab)\n       \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n       ab \\<notin> Q", "apply (auto simp: listrel_Cons_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs m1'a y ysa.\n       \\<lbrakk>(m1', m1) \\<in> r;\n        \\<forall>y.\n           (m1, y) \\<in> r \\<and> (y, m1) \\<notin> r \\<longrightarrow>\n           (\\<forall>bs.\n               length bs = length ys \\<longrightarrow> y # bs \\<notin> Q);\n        \\<forall>zs.\n           (ms, zs) \\<in> listrel r \\<and>\n           (ms = [] \\<longrightarrow> zs \\<noteq> []) \\<and>\n           ((zs, ms) \\<in> listrel r \\<longrightarrow>\n            zs = [] \\<and> ms = []) \\<longrightarrow>\n           (\\<forall>m1'.\n               m1' # zs \\<in> Q \\<longrightarrow>\n               (m1, m1') \\<in> r \\<longrightarrow>\n               (m1', m1) \\<in> r \\<longrightarrow>\n               length zs \\<noteq> length ms1);\n        (m1, m1') \\<in> r; m1' # ms \\<in> Q; length bs = length ys;\n        m1 # bs \\<in> Q; (m1'a, m1) \\<in> r; (m1, m1'a) \\<in> r;\n        m1'a # ms \\<in> Q; length ms = length ms1; (m1', y) \\<in> r;\n        (ms, ysa) \\<in> listrel r; y # ysa \\<in> Q;\n        (y, m1') \\<notin> r\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>bs m1'a y ysa.\n       \\<lbrakk>(m1', m1) \\<in> r;\n        \\<forall>y.\n           (m1, y) \\<in> r \\<and> (y, m1) \\<notin> r \\<longrightarrow>\n           (\\<forall>bs.\n               length bs = length ys \\<longrightarrow> y # bs \\<notin> Q);\n        \\<forall>zs.\n           (ms, zs) \\<in> listrel r \\<and>\n           (ms = [] \\<longrightarrow> zs \\<noteq> []) \\<and>\n           ((zs, ms) \\<in> listrel r \\<longrightarrow>\n            zs = [] \\<and> ms = []) \\<longrightarrow>\n           (\\<forall>m1'.\n               m1' # zs \\<in> Q \\<longrightarrow>\n               (m1, m1') \\<in> r \\<longrightarrow>\n               (m1', m1) \\<in> r \\<longrightarrow>\n               length zs \\<noteq> length ms1);\n        (m1, m1') \\<in> r; m1' # ms \\<in> Q; length bs = length ys;\n        m1 # bs \\<in> Q; (m1'a, m1) \\<in> r; (m1, m1'a) \\<in> r;\n        m1'a # ms \\<in> Q; length ms = length ms1; (m1', y) \\<in> r;\n        (ms, ysa) \\<in> listrel r; y # ysa \\<in> Q;\n        (ysa, ms) \\<notin> listrel r\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis \\<open>length ms1 = length ys\\<close> listrel_eq_len trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bs m1'a y ysa.\n       \\<lbrakk>(m1', m1) \\<in> r;\n        \\<forall>y.\n           (m1, y) \\<in> r \\<and> (y, m1) \\<notin> r \\<longrightarrow>\n           (\\<forall>bs.\n               length bs = length ys \\<longrightarrow> y # bs \\<notin> Q);\n        \\<forall>zs.\n           (ms, zs) \\<in> listrel r \\<and>\n           (ms = [] \\<longrightarrow> zs \\<noteq> []) \\<and>\n           ((zs, ms) \\<in> listrel r \\<longrightarrow>\n            zs = [] \\<and> ms = []) \\<longrightarrow>\n           (\\<forall>m1'.\n               m1' # zs \\<in> Q \\<longrightarrow>\n               (m1, m1') \\<in> r \\<longrightarrow>\n               (m1', m1) \\<in> r \\<longrightarrow>\n               length zs \\<noteq> length ms1);\n        (m1, m1') \\<in> r; m1' # ms \\<in> Q; length bs = length ys;\n        m1 # bs \\<in> Q; (m1'a, m1) \\<in> r; (m1, m1'a) \\<in> r;\n        m1'a # ms \\<in> Q; length ms = length ms1; (m1', y) \\<in> r;\n        (ms, ysa) \\<in> listrel r; y # ysa \\<in> Q;\n        (ysa, ms) \\<notin> listrel r\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis \\<open>length ms1 = length ys\\<close> listrel_eq_len trans)"], ["proof (state)\nthis:\n  \\<forall>ab.\n     (m1' # ms, ab) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n     ab \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       \\<exists>ys.\n          ys \\<in> Q \\<and>\n          (\\<forall>zs.\n              (ys, zs)\n              \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n              zs \\<notin> Q)", "with m1'"], ["proof (chain)\npicking this:\n  (m1', m1) \\<in> r \\<and> (m1, m1') \\<in> r \\<and> m1' # ms \\<in> Q\n  \\<forall>ab.\n     (m1' # ms, ab) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n     ab \\<notin> Q", "show ?thesis"], ["proof (prove)\nusing this:\n  (m1', m1) \\<in> r \\<and> (m1, m1') \\<in> r \\<and> m1' # ms \\<in> Q\n  \\<forall>ab.\n     (m1' # ms, ab) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n     ab \\<notin> Q\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       ys \\<in> Q \\<and>\n       (\\<forall>zs.\n           (ys, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n           zs \\<notin> Q)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys.\n     ys \\<in> Q \\<and>\n     (\\<forall>zs.\n         (ys, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n         zs \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ys.\n     ys \\<in> Q \\<and>\n     (\\<forall>zs.\n         (ys, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n         zs \\<notin> Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs \\<in> Q \\<Longrightarrow>\n  \\<exists>ys.\n     ys \\<in> Q \\<and>\n     (\\<forall>zs.\n         (ys, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n         zs \\<notin> Q)\n\ngoal (1 subgoal):\n 1. acc (listrel r - {([], [])})", "}"], ["proof (state)\nthis:\n  ?xs2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>ys.\n     ys \\<in> ?Q2 \\<and>\n     (\\<forall>zs.\n         (ys, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n         zs \\<notin> ?Q2)\n\ngoal (1 subgoal):\n 1. acc (listrel r - {([], [])})", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?xs2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>ys.\n     ys \\<in> ?Q2 \\<and>\n     (\\<forall>zs.\n         (ys, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n         zs \\<notin> ?Q2)\n\ngoal (1 subgoal):\n 1. acc (listrel r - {([], [])})", "unfolding wf_eq_minimal"], ["proof (prove)\nusing this:\n  ?xs2 \\<in> ?Q2 \\<Longrightarrow>\n  \\<exists>ys.\n     ys \\<in> ?Q2 \\<and>\n     (\\<forall>zs.\n         (ys, zs) \\<in> strict (listrel r - {([], [])}) \\<longrightarrow>\n         zs \\<notin> ?Q2)\n\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z)\n              \\<in> (strict\n                      (listrel r - {([], [])}))\\<inverse> \\<longrightarrow>\n              y \\<notin> Q)", "by (metis converse_iff)"], ["proof (state)\nthis:\n  acc (listrel r - {([], [])})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_iff_le_annos: \"c1 \\<sqsubseteq> c2 \\<longleftrightarrow>\n (annos c1, annos c2) : listrel{(x,y). x \\<sqsubseteq> y} \\<and> strip c1 = strip c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c1 \\<sqsubseteq> c2) =\n    ((annos c1, annos c2) \\<in> listrel {(x, y). x \\<sqsubseteq> y} \\<and>\n     strip c1 = strip c2)", "apply(induct c1 c2 rule: le_acom.induct)"], ["proof (prove)\ngoal (37 subgoals):\n 1. \\<And>S S'.\n       (SKIP {S} \\<sqsubseteq> SKIP {S'}) =\n       ((annos (SKIP {S}), annos (SKIP {S'}))\n        \\<in> listrel\n               {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y} \\<and>\n        strip (SKIP {S}) = strip (SKIP {S'}))\n 2. \\<And>x e S x' e' S'.\n       (x ::= e {S} \\<sqsubseteq> x' ::= e' {S'}) =\n       ((annos (x ::= e {S}), annos (x' ::= e' {S'}))\n        \\<in> listrel\n               {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y} \\<and>\n        strip (x ::= e {S}) = strip (x' ::= e' {S'}))\n 3. \\<And>c1 c2 c1' c2'.\n       \\<lbrakk>(c1 \\<sqsubseteq> c1') =\n                ((annos c1, annos c1')\n                 \\<in> listrel\n                        {a. case a of\n                            (x, y) \\<Rightarrow> x \\<sqsubseteq> y} \\<and>\n                 strip c1 = strip c1');\n        (c2 \\<sqsubseteq> c2') =\n        ((annos c2, annos c2')\n         \\<in> listrel\n                {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y} \\<and>\n         strip c2 = strip c2')\\<rbrakk>\n       \\<Longrightarrow> (c1;;\n                          c2 \\<sqsubseteq> c1';;\n                          c2') =\n                         ((annos (c1;;\n                                  c2),\n                           annos (c1';;\n                                  c2'))\n                          \\<in> listrel\n                                 {a. case a of\n                                     (x, y) \\<Rightarrow>\n x \\<sqsubseteq> y} \\<and>\n                          strip (c1;;\n                                 c2) =\n                          strip (c1';;\n                                 c2'))\n 4. \\<And>b c1 c2 S b' c1' c2' S'.\n       \\<lbrakk>(c1 \\<sqsubseteq> c1') =\n                ((annos c1, annos c1')\n                 \\<in> listrel\n                        {a. case a of\n                            (x, y) \\<Rightarrow> x \\<sqsubseteq> y} \\<and>\n                 strip c1 = strip c1');\n        (c2 \\<sqsubseteq> c2') =\n        ((annos c2, annos c2')\n         \\<in> listrel\n                {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y} \\<and>\n         strip c2 = strip c2')\\<rbrakk>\n       \\<Longrightarrow> (IF b THEN c1 ELSE c2\n                          {S} \\<sqsubseteq>\n                          IF b' THEN c1' ELSE c2'\n                          {S'}) =\n                         ((annos (IF b THEN c1 ELSE c2\n                                  {S}),\n                           annos (IF b' THEN c1' ELSE c2'\n                                  {S'}))\n                          \\<in> listrel\n                                 {a. case a of\n                                     (x, y) \\<Rightarrow>\n x \\<sqsubseteq> y} \\<and>\n                          strip (IF b THEN c1 ELSE c2\n                                 {S}) =\n                          strip (IF b' THEN c1' ELSE c2'\n                                 {S'}))\n 5. \\<And>Inv b c P Inv' b' c' P'.\n       (c \\<sqsubseteq> c') =\n       ((annos c, annos c')\n        \\<in> listrel\n               {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y} \\<and>\n        strip c = strip c') \\<Longrightarrow>\n       ({Inv}\n        WHILE b DO c\n        {P} \\<sqsubseteq>\n        {Inv'}\n        WHILE b' DO c'\n        {P'}) =\n       ((annos ({Inv}\n                WHILE b DO c\n                {P}),\n         annos ({Inv'}\n                WHILE b' DO c'\n                {P'}))\n        \\<in> listrel\n               {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y} \\<and>\n        strip ({Inv}\n               WHILE b DO c\n               {P}) =\n        strip ({Inv'}\n               WHILE b' DO c'\n               {P'}))\n 6. \\<And>v va vb vc.\n       (v ::= va {vb} \\<sqsubseteq> SKIP {vc}) =\n       ((annos (v ::= va {vb}), annos (SKIP {vc}))\n        \\<in> listrel\n               {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y} \\<and>\n        strip (v ::= va {vb}) = strip (SKIP {vc}))\n 7. \\<And>v va vb vc vd.\n       (v ::= va {vb} \\<sqsubseteq> vc;;\n        vd) =\n       ((annos (v ::= va {vb}), annos (vc;;\n vd))\n        \\<in> listrel\n               {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y} \\<and>\n        strip (v ::= va {vb}) = strip (vc;;\n vd))\n 8. \\<And>v va vb vc vd ve vf.\n       (v ::= va {vb} \\<sqsubseteq> IF vc THEN vd ELSE ve\n                                    {vf}) =\n       ((annos (v ::= va {vb}), annos (IF vc THEN vd ELSE ve\n {vf}))\n        \\<in> listrel\n               {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y} \\<and>\n        strip (v ::= va {vb}) = strip (IF vc THEN vd ELSE ve\n {vf}))\n 9. \\<And>v va vb vc vd ve vf.\n       (v ::= va {vb} \\<sqsubseteq> {vc}\n                                    WHILE vd DO ve\n                                    {vf}) =\n       ((annos (v ::= va {vb}), annos ({vc}\n WHILE vd DO ve\n {vf}))\n        \\<in> listrel\n               {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y} \\<and>\n        strip (v ::= va {vb}) = strip ({vc}\n WHILE vd DO ve\n {vf}))\n 10. \\<And>v va vb.\n        (v;;\n         va \\<sqsubseteq> SKIP {vb}) =\n        ((annos (v;;\n                 va),\n          annos (SKIP {vb}))\n         \\<in> listrel\n                {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y} \\<and>\n         strip (v;;\n                va) =\n         strip (SKIP {vb}))\nA total of 37 subgoals...", "apply (auto simp: listrel.Nil listrel_Cons_iff listrel_app size_annos_same2)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>c1 c2 c1' c2'.\n       \\<lbrakk>c1 \\<sqsubseteq> c1';\n        (annos c1, annos c1')\n        \\<in> listrel {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y};\n        \\<not> c2 \\<sqsubseteq> c2';\n        (annos c2, annos c2') \\<notin> listrel {(x, y). x \\<sqsubseteq> y};\n        (annos c1 @ annos c2, annos c1' @ annos c2')\n        \\<in> listrel {(x, y). x \\<sqsubseteq> y};\n        strip c1 = strip c1'; strip c2 = strip c2'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c1 c2 c1' c2'.\n       \\<lbrakk>\\<not> c1 \\<sqsubseteq> c1'; c2 \\<sqsubseteq> c2';\n        (annos c2, annos c2')\n        \\<in> listrel {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y};\n        (annos c1, annos c1') \\<notin> listrel {(x, y). x \\<sqsubseteq> y};\n        (annos c1 @ annos c2, annos c1' @ annos c2')\n        \\<in> listrel {(x, y). x \\<sqsubseteq> y};\n        strip c1 = strip c1'; strip c2 = strip c2'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c1 c2 c1' c2'.\n       \\<lbrakk>\\<not> c1 \\<sqsubseteq> c1'; \\<not> c2 \\<sqsubseteq> c2';\n        (annos c1, annos c1')\n        \\<notin> listrel\n                  {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y};\n        (annos c2, annos c2')\n        \\<notin> listrel\n                  {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y};\n        (annos c1 @ annos c2, annos c1' @ annos c2')\n        \\<in> listrel {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y};\n        strip c1 = strip c1'; strip c2 = strip c2'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>c1 c2 c1' c2'.\n       \\<lbrakk>\\<not> c1 \\<sqsubseteq> c1'; \\<not> c2 \\<sqsubseteq> c2';\n        (annos c1, annos c1')\n        \\<notin> listrel\n                  {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y};\n        (annos c2, annos c2')\n        \\<notin> listrel\n                  {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y};\n        (annos c1 @ annos c2, annos c1' @ annos c2')\n        \\<in> listrel {a. case a of (x, y) \\<Rightarrow> x \\<sqsubseteq> y};\n        strip c1 = strip c1'; strip c2 = strip c2'\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>c1 c2 S c1' c2' S'.\n       \\<lbrakk>c1 \\<sqsubseteq> c1';\n        (annos c1, annos c1') \\<in> listrel {(x, y). x \\<sqsubseteq> y};\n        \\<not> c2 \\<sqsubseteq> c2';\n        (annos c2, annos c2') \\<notin> listrel {(x, y). x \\<sqsubseteq> y};\n        S \\<sqsubseteq> S';\n        (annos c1 @ annos c2, annos c1' @ annos c2')\n        \\<in> listrel {(x, y). x \\<sqsubseteq> y};\n        strip c1 = strip c1'; strip c2 = strip c2'\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>c1 c2 S c1' c2' S'.\n       \\<lbrakk>\\<not> c1 \\<sqsubseteq> c1'; c2 \\<sqsubseteq> c2';\n        (annos c2, annos c2') \\<in> listrel {(x, y). x \\<sqsubseteq> y};\n        (annos c1, annos c1') \\<notin> listrel {(x, y). x \\<sqsubseteq> y};\n        S \\<sqsubseteq> S';\n        (annos c1 @ annos c2, annos c1' @ annos c2')\n        \\<in> listrel {(x, y). x \\<sqsubseteq> y};\n        strip c1 = strip c1'; strip c2 = strip c2'\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>c1 c2 S c1' c2' S'.\n       \\<lbrakk>\\<not> c1 \\<sqsubseteq> c1'; \\<not> c2 \\<sqsubseteq> c2';\n        (annos c1, annos c1') \\<notin> listrel {(x, y). x \\<sqsubseteq> y};\n        (annos c2, annos c2') \\<notin> listrel {(x, y). x \\<sqsubseteq> y};\n        S \\<sqsubseteq> S';\n        (annos c1 @ annos c2, annos c1' @ annos c2')\n        \\<in> listrel {(x, y). x \\<sqsubseteq> y};\n        strip c1 = strip c1'; strip c2 = strip c2'\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>c1 c2 S c1' c2' S'.\n       \\<lbrakk>\\<not> c1 \\<sqsubseteq> c1'; \\<not> c2 \\<sqsubseteq> c2';\n        (annos c1, annos c1') \\<notin> listrel {(x, y). x \\<sqsubseteq> y};\n        (annos c2, annos c2') \\<notin> listrel {(x, y). x \\<sqsubseteq> y};\n        S \\<sqsubseteq> S';\n        (annos c1 @ annos c2, annos c1' @ annos c2')\n        \\<in> listrel {(x, y). x \\<sqsubseteq> y};\n        strip c1 = strip c1'; strip c2 = strip c2'\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis listrel_app_same_size size_annos_same)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma le_acom_subset_same_annos:\n \"(strict{(c,c'::'a::preord acom). c \\<sqsubseteq> c'})^-1 \\<subseteq>\n  (strict(inv_image (listrel{(a,a'::'a). a \\<sqsubseteq> a'} - {([],[])}) annos))^-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (strict {(c, c'). c \\<sqsubseteq> c'})\\<inverse>\n    \\<subseteq> (strict\n                  (inv_image\n                    (listrel {(a, a'). a \\<sqsubseteq> a'} - {([], [])})\n                    annos))\\<inverse>", "by(auto simp: le_iff_le_annos)"], ["", "lemma acc_acom: \"acc {(a,a'::'a::preord). a \\<sqsubseteq> a'} \\<Longrightarrow>\n  acc {(c,c'::'a acom). c \\<sqsubseteq> c'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acc {(a, a'). a \\<sqsubseteq> a'} \\<Longrightarrow>\n    acc {(c, c'). c \\<sqsubseteq> c'}", "apply(rule wf_subset[OF _ le_acom_subset_same_annos])"], ["proof (prove)\ngoal (1 subgoal):\n 1. acc {(a, a'). a \\<sqsubseteq> a'} \\<Longrightarrow>\n    acc (inv_image (listrel {(a, a'). a \\<sqsubseteq> a'} - {([], [])})\n          annos)", "apply(rule acc_inv_image[OF acc_listrel])"], ["proof (prove)\ngoal (3 subgoals):\n 1. acc {(a, a'). a \\<sqsubseteq> a'} \\<Longrightarrow>\n    refl {(a, a'). a \\<sqsubseteq> a'}\n 2. acc {(a, a'). a \\<sqsubseteq> a'} \\<Longrightarrow>\n    trans {(a, a'). a \\<sqsubseteq> a'}\n 3. acc {(a, a'). a \\<sqsubseteq> a'} \\<Longrightarrow>\n    acc {(a, a'). a \\<sqsubseteq> a'}", "apply(auto simp: refl_on_def trans_def intro: le_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Termination of the fixed-point finders, assuming monotone functions:\\<close>"], ["", "lemma pfp_termination:\nfixes x0 :: \"'a::preord\"\nassumes mono: \"\\<And>x y. x \\<sqsubseteq> y \\<Longrightarrow> f x \\<sqsubseteq> f y\" and \"acc {(x::'a,y). x \\<sqsubseteq> y}\"\nand \"x0 \\<sqsubseteq> f x0\" shows \"\\<exists>x. pfp f x0 = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. pfp f x0 = Some x", "proof(simp add: pfp_def, rule wf_while_option_Some[where P = \"%x. x \\<sqsubseteq> f x\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. wf {(x, s).\n        (s \\<sqsubseteq> f s \\<and> \\<not> f s \\<sqsubseteq> s) \\<and>\n        x = f s}\n 2. \\<And>s.\n       \\<lbrakk>s \\<sqsubseteq> f s; \\<not> f s \\<sqsubseteq> s\\<rbrakk>\n       \\<Longrightarrow> f s \\<sqsubseteq> f (f s)\n 3. x0 \\<sqsubseteq> f x0", "show \"wf {(x, s). (s \\<sqsubseteq> f s \\<and> \\<not> f s \\<sqsubseteq> s) \\<and> x = f s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(x, s).\n        (s \\<sqsubseteq> f s \\<and> \\<not> f s \\<sqsubseteq> s) \\<and>\n        x = f s}", "by(rule wf_subset[OF assms(2)]) auto"], ["proof (state)\nthis:\n  wf {(x, s).\n      (s \\<sqsubseteq> f s \\<and> \\<not> f s \\<sqsubseteq> s) \\<and>\n      x = f s}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<sqsubseteq> f s; \\<not> f s \\<sqsubseteq> s\\<rbrakk>\n       \\<Longrightarrow> f s \\<sqsubseteq> f (f s)\n 2. x0 \\<sqsubseteq> f x0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<sqsubseteq> f s; \\<not> f s \\<sqsubseteq> s\\<rbrakk>\n       \\<Longrightarrow> f s \\<sqsubseteq> f (f s)\n 2. x0 \\<sqsubseteq> f x0", "show \"x0 \\<sqsubseteq> f x0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x0 \\<sqsubseteq> f x0", "by(rule assms)"], ["proof (state)\nthis:\n  x0 \\<sqsubseteq> f x0\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<sqsubseteq> f s; \\<not> f s \\<sqsubseteq> s\\<rbrakk>\n       \\<Longrightarrow> f s \\<sqsubseteq> f (f s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<sqsubseteq> f s; \\<not> f s \\<sqsubseteq> s\\<rbrakk>\n       \\<Longrightarrow> f s \\<sqsubseteq> f (f s)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<sqsubseteq> f s; \\<not> f s \\<sqsubseteq> s\\<rbrakk>\n       \\<Longrightarrow> f s \\<sqsubseteq> f (f s)", "assume \"x \\<sqsubseteq> f x\""], ["proof (state)\nthis:\n  x \\<sqsubseteq> f x\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<sqsubseteq> f s; \\<not> f s \\<sqsubseteq> s\\<rbrakk>\n       \\<Longrightarrow> f s \\<sqsubseteq> f (f s)", "thus \"f x \\<sqsubseteq> f(f x)\""], ["proof (prove)\nusing this:\n  x \\<sqsubseteq> f x\n\ngoal (1 subgoal):\n 1. f x \\<sqsubseteq> f (f x)", "by(rule mono)"], ["proof (state)\nthis:\n  f x \\<sqsubseteq> f (f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lpfpc_termination:\n  fixes f :: \"(('a::SL_top)option acom \\<Rightarrow> 'a option acom)\"\n  assumes \"acc {(x::'a,y). x \\<sqsubseteq> y}\" and \"\\<And>x y. x \\<sqsubseteq> y \\<Longrightarrow> f x \\<sqsubseteq> f y\"\n  and \"\\<And>c. strip(f c) = strip c\"\n  shows \"\\<exists>c'. lpfp\\<^sub>c f c = Some c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c'. lpfp\\<^sub>c f c = Some c'", "unfolding lpfp\\<^sub>c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c'. pfp f (\\<bottom>\\<^sub>c c) = Some c'", "apply(rule pfp_termination)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c' y. c' \\<sqsubseteq> y \\<Longrightarrow> f c' \\<sqsubseteq> f y\n 2. acc {(c', y). c' \\<sqsubseteq> y}\n 3. \\<bottom>\\<^sub>c c \\<sqsubseteq> f (\\<bottom>\\<^sub>c c)", "apply(erule assms(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. acc {(c', y). c' \\<sqsubseteq> y}\n 2. \\<bottom>\\<^sub>c c \\<sqsubseteq> f (\\<bottom>\\<^sub>c c)", "apply(rule acc_acom[OF acc_option[OF assms(1)]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom>\\<^sub>c c \\<sqsubseteq> f (\\<bottom>\\<^sub>c c)", "apply(simp add: bot_acom assms(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context Abs_Int_mono\nbegin"], ["", "lemma AI_Some_measure:\nassumes \"(strict{(x,y::'a). x \\<sqsubseteq> y})^-1 <= measure m\"\nand \"\\<forall>x y::'a. x \\<sqsubseteq> y \\<and> y \\<sqsubseteq> x \\<longrightarrow> m x = m y\"\nshows \"\\<exists>c'. AI c = Some c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c'. AI c = Some c'", "unfolding AI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c'. lpfp\\<^sub>c (step' \\<top>) c = Some c'", "apply(rule lpfpc_termination)"], ["proof (prove)\ngoal (3 subgoals):\n 1. acc {(x, y). x \\<sqsubseteq> y}\n 2. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       step' \\<top> x \\<sqsubseteq> step' \\<top> y\n 3. \\<And>c. strip (step' \\<top> c) = strip c", "apply(rule wf_subset[OF wf_measure measure_st[OF assms]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       step' \\<top> x \\<sqsubseteq> step' \\<top> y\n 2. \\<And>c. strip (step' \\<top> c) = strip c", "apply(erule mono_step'[OF le_refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. strip (step' \\<top> c) = strip c", "apply(rule strip_step')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}