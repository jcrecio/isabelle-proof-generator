{"file_name": "/home/qj213/afp-2021-10-22/thys/Abs_Int_ITP2012/Abs_State.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Abs_Int_ITP2012", "problem_names": ["lemma lookup_update: \"lookup (update S x y) = (lookup S)(x:=y)\"", "lemma mono_lookup: \"F \\<sqsubseteq> F' \\<Longrightarrow> lookup F x \\<sqsubseteq> lookup F' x\"", "lemma mono_update: \"a \\<sqsubseteq> a' \\<Longrightarrow> S \\<sqsubseteq> S' \\<Longrightarrow> update S x a \\<sqsubseteq> update S' x a'\"", "lemma gamma_f_Top[simp]: \"\\<gamma>\\<^sub>f Top = UNIV\"", "lemma gamma_o_Top[simp]: \"\\<gamma>\\<^sub>o Top = UNIV\"", "lemma mono_gamma_f: \"f \\<sqsubseteq> g \\<Longrightarrow> \\<gamma>\\<^sub>f f \\<subseteq> \\<gamma>\\<^sub>f g\"", "lemma mono_gamma_o:\n  \"sa \\<sqsubseteq> sa' \\<Longrightarrow> \\<gamma>\\<^sub>o sa \\<subseteq> \\<gamma>\\<^sub>o sa'\"", "lemma mono_gamma_c: \"ca \\<sqsubseteq> ca' \\<Longrightarrow> \\<gamma>\\<^sub>c ca \\<le> \\<gamma>\\<^sub>c ca'\"", "lemma in_gamma_option_iff:\n  \"x : \\<gamma>_option r u \\<longleftrightarrow> (\\<exists>u'. u = Some u' \\<and> x : r u')\""], "translations": [["", "lemma lookup_update: \"lookup (update S x y) = (lookup S)(x:=y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (update S x y) = (lookup S)(x := y)", "by(rule ext)(auto simp: lookup_def update_def)"], ["", "definition \"\\<gamma>_st \\<gamma> F = {f. \\<forall>x. f x \\<in> \\<gamma>(lookup F x)}\""], ["", "instantiation st :: (SL_top) SL_top\nbegin"], ["", "definition \"le_st F G = (\\<forall>x \\<in> set(dom G). lookup F x \\<sqsubseteq> fun G x)\""], ["", "definition\n\"join_st F G =\n FunDom (\\<lambda>x. fun F x \\<squnion> fun G x) (inter_list (dom F) (dom G))\""], ["", "definition \"\\<top> = FunDom (\\<lambda>x. \\<top>) []\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Abs_State.st, SL_top_class)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x. x \\<sqsubseteq> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 3. \\<And>x y. x \\<sqsubseteq> x \\<squnion> y\n 4. \\<And>y x. y \\<sqsubseteq> x \\<squnion> y\n 5. \\<And>x z y.\n       \\<lbrakk>x \\<sqsubseteq> z; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqsubseteq> z\n 6. \\<And>x. x \\<sqsubseteq> \\<top>", "case 2"], ["proof (state)\nthis:\n  x_ \\<sqsubseteq> y_\n  y_ \\<sqsubseteq> z_\n\ngoal (6 subgoals):\n 1. \\<And>x. x \\<sqsubseteq> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 3. \\<And>x y. x \\<sqsubseteq> x \\<squnion> y\n 4. \\<And>y x. y \\<sqsubseteq> x \\<squnion> y\n 5. \\<And>x z y.\n       \\<lbrakk>x \\<sqsubseteq> z; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqsubseteq> z\n 6. \\<And>x. x \\<sqsubseteq> \\<top>", "thus ?case"], ["proof (prove)\nusing this:\n  x_ \\<sqsubseteq> y_\n  y_ \\<sqsubseteq> z_\n\ngoal (1 subgoal):\n 1. x_ \\<sqsubseteq> z_", "apply(auto simp: le_st_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xa\\<in>set (Abs_State.dom y_).\n                   lookup x_ xa \\<sqsubseteq> fun y_ xa;\n        \\<forall>x\\<in>set (Abs_State.dom z_).\n           lookup y_ x \\<sqsubseteq> fun z_ x;\n        xa \\<in> set (Abs_State.dom z_)\\<rbrakk>\n       \\<Longrightarrow> lookup x_ xa \\<sqsubseteq> fun z_ xa", "by (metis lookup_def preord_class.le_trans top)"], ["proof (state)\nthis:\n  x_ \\<sqsubseteq> z_\n\ngoal (5 subgoals):\n 1. \\<And>x. x \\<sqsubseteq> x\n 2. \\<And>x y. x \\<sqsubseteq> x \\<squnion> y\n 3. \\<And>y x. y \\<sqsubseteq> x \\<squnion> y\n 4. \\<And>x z y.\n       \\<lbrakk>x \\<sqsubseteq> z; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> y \\<sqsubseteq> z\n 5. \\<And>x. x \\<sqsubseteq> \\<top>", "qed (auto simp: le_st_def lookup_def join_st_def Top_st_def)"], ["", "end"], ["", "lemma mono_lookup: \"F \\<sqsubseteq> F' \\<Longrightarrow> lookup F x \\<sqsubseteq> lookup F' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<sqsubseteq> F' \\<Longrightarrow>\n    lookup F x \\<sqsubseteq> lookup F' x", "by(auto simp add: lookup_def le_st_def)"], ["", "lemma mono_update: \"a \\<sqsubseteq> a' \\<Longrightarrow> S \\<sqsubseteq> S' \\<Longrightarrow> update S x a \\<sqsubseteq> update S' x a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<sqsubseteq> a'; S \\<sqsubseteq> S'\\<rbrakk>\n    \\<Longrightarrow> update S x a \\<sqsubseteq> update S' x a'", "by(auto simp add: le_st_def lookup_def update_def)"], ["", "locale Gamma = Val_abs where \\<gamma>=\\<gamma> for \\<gamma> :: \"'av::SL_top \\<Rightarrow> val set\"\nbegin"], ["", "abbreviation \\<gamma>\\<^sub>f :: \"'av st \\<Rightarrow> state set\"\nwhere \"\\<gamma>\\<^sub>f == \\<gamma>_st \\<gamma>\""], ["", "abbreviation \\<gamma>\\<^sub>o :: \"'av st option \\<Rightarrow> state set\"\nwhere \"\\<gamma>\\<^sub>o == \\<gamma>_option \\<gamma>\\<^sub>f\""], ["", "abbreviation \\<gamma>\\<^sub>c :: \"'av st option acom \\<Rightarrow> state set acom\"\nwhere \"\\<gamma>\\<^sub>c == map_acom \\<gamma>\\<^sub>o\""], ["", "lemma gamma_f_Top[simp]: \"\\<gamma>\\<^sub>f Top = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma>\\<^sub>f \\<top> = UNIV", "by(auto simp: Top_st_def \\<gamma>_st_def lookup_def)"], ["", "lemma gamma_o_Top[simp]: \"\\<gamma>\\<^sub>o Top = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma>\\<^sub>o \\<top> = UNIV", "by (simp add: Top_option_def)"], ["", "(* FIXME (maybe also le \\<rightarrow> sqle?) *)"], ["", "lemma mono_gamma_f: \"f \\<sqsubseteq> g \\<Longrightarrow> \\<gamma>\\<^sub>f f \\<subseteq> \\<gamma>\\<^sub>f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<sqsubseteq> g \\<Longrightarrow>\n    \\<gamma>\\<^sub>f f \\<subseteq> \\<gamma>\\<^sub>f g", "apply(simp add:\\<gamma>_st_def subset_iff lookup_def le_st_def split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (Abs_State.dom g).\n       (x \\<in> set (Abs_State.dom f) \\<longrightarrow>\n        fun f x \\<sqsubseteq> fun g x) \\<and>\n       (x \\<in> set (Abs_State.dom f) \\<or>\n        \\<top> \\<sqsubseteq> fun g x) \\<Longrightarrow>\n    \\<forall>t.\n       (\\<forall>x.\n           x \\<in> set (Abs_State.dom f) \\<longrightarrow>\n           t x \\<in> \\<gamma> (fun f x)) \\<longrightarrow>\n       (\\<forall>x.\n           x \\<in> set (Abs_State.dom g) \\<longrightarrow>\n           t x \\<in> \\<gamma> (fun g x))", "by (metis UNIV_I mono_gamma gamma_Top subsetD)"], ["", "lemma mono_gamma_o:\n  \"sa \\<sqsubseteq> sa' \\<Longrightarrow> \\<gamma>\\<^sub>o sa \\<subseteq> \\<gamma>\\<^sub>o sa'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sa \\<sqsubseteq> sa' \\<Longrightarrow>\n    \\<gamma>\\<^sub>o sa \\<subseteq> \\<gamma>\\<^sub>o sa'", "by(induction sa sa' rule: le_option.induct)(simp_all add: mono_gamma_f)"], ["", "lemma mono_gamma_c: \"ca \\<sqsubseteq> ca' \\<Longrightarrow> \\<gamma>\\<^sub>c ca \\<le> \\<gamma>\\<^sub>c ca'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ca \\<sqsubseteq> ca' \\<Longrightarrow>\n    \\<gamma>\\<^sub>c ca \\<le> \\<gamma>\\<^sub>c ca'", "by (induction ca ca' rule: le_acom.induct) (simp_all add:mono_gamma_o)"], ["", "lemma in_gamma_option_iff:\n  \"x : \\<gamma>_option r u \\<longleftrightarrow> (\\<exists>u'. u = Some u' \\<and> x : r u')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> \\<gamma>_option r u) =\n    (\\<exists>u'. u = Some u' \\<and> x \\<in> r u')", "by (cases u) auto"], ["", "end"], ["", "end"]]}