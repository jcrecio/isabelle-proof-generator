{"file_name": "/home/qj213/afp-2021-10-22/thys/Sturm_Tarski/Sturm_Tarski.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sturm_Tarski", "problem_names": ["lemma eventually_at_right:\n  fixes x::\"'a::{archimedean_field,linorder_topology}\"\n  shows \"eventually P (at_right x) \\<longleftrightarrow> (\\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> P y)\"", "lemma eventually_at_left:\n  fixes x::\"'a::{archimedean_field,linorder_topology}\"\n  shows \"eventually P (at_left x) \\<longleftrightarrow> (\\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> P y)\"", "lemma eventually_neg:\n  assumes \"F\\<noteq>bot\"  and eve:\"eventually (\\<lambda>x. P x) F\"\n  shows \"\\<not> eventually (\\<lambda>x. \\<not> P x) F\"", "lemma poly_tendsto[simp]:\n    \"(poly p \\<longlongrightarrow> poly p x) (at (x::real))\" \n    \"(poly p \\<longlongrightarrow> poly p x) (at_left (x::real))\"\n    \"(poly p \\<longlongrightarrow> poly p x) (at_right (x::real))\"", "lemma not_eq_pos_or_neg_iff_1:\n  fixes p::\"real poly\" \n  shows \"(\\<forall>z. lb<z\\<and>z\\<le>ub\\<longrightarrow>poly p z\\<noteq>0) \\<longleftrightarrow> \n    (\\<forall>z. lb<z\\<and>z\\<le>ub\\<longrightarrow>poly p z>0)\\<or>(\\<forall>z. lb<z\\<and>z\\<le>ub\\<longrightarrow>poly p z<0)\" (is \"?Q \\<longleftrightarrow> ?P\")", "lemma not_eq_pos_or_neg_iff_2:\n  fixes p::\"real poly\" \n  shows \"(\\<forall>z. lb\\<le>z\\<and>z<ub\\<longrightarrow>poly p z\\<noteq>0) \n    \\<longleftrightarrow>(\\<forall>z. lb\\<le>z\\<and>z<ub\\<longrightarrow>poly p z>0)\\<or>(\\<forall>z. lb\\<le>z\\<and>z<ub\\<longrightarrow>poly p z<0)\" (is \"?Q\\<longleftrightarrow>?P\")", "lemma next_non_root_interval:\n  fixes p::\"real poly\"\n  assumes \"p\\<noteq>0\"\n  obtains ub where \"ub>lb\" and \"(\\<forall>z. lb<z\\<and>z\\<le>ub\\<longrightarrow>poly p z\\<noteq>0)\"", "lemma last_non_root_interval:\n  fixes p::\"real poly\"\n  assumes \"p\\<noteq>0\"\n  obtains lb where \"lb<ub\" and \"(\\<forall>z. lb\\<le>z\\<and>z<ub\\<longrightarrow>poly p z\\<noteq>0)\"", "lemma sgn_inf_sym:\n  fixes p::\"real poly\"\n  shows \"sgn_pos_inf (pcompose p [:0,-1:]) = sgn_neg_inf p\" (is \"?L=?R\")", "lemma poly_pinfty_gt_lc:\n  fixes p:: \"real poly\"\n  assumes  \"lead_coeff p > 0\" \n  shows \"\\<exists> n. \\<forall> x \\<ge> n. poly p x \\<ge> lead_coeff p\"", "lemma poly_sgn_eventually_at_top:\n  fixes p::\"real poly\"\n  shows \"eventually (\\<lambda>x. sgn (poly p x) = sgn_pos_inf p) at_top\"", "lemma poly_sgn_eventually_at_bot:\n  fixes p::\"real poly\"\n  shows \"eventually (\\<lambda>x. sgn (poly p x) = sgn_neg_inf p) at_bot\"", "lemma root_ub:\n  fixes p:: \"real poly\"\n  assumes \"p\\<noteq>0\"\n  obtains ub where \"\\<forall>x. poly p x=0 \\<longrightarrow> x<ub\"\n    and \"\\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p\"", "lemma root_lb:\n  fixes p:: \"real poly\"\n  assumes \"p\\<noteq>0\"\n  obtains lb where \"\\<forall>x. poly p x=0 \\<longrightarrow> x>lb\"\n    and \"\\<forall>x\\<le>lb. sgn (poly p x) = sgn_neg_inf p\"", "lemma sign_simps[simp]:\n  \"x>0 \\<Longrightarrow> sign x=1\"\n  \"x=0 \\<Longrightarrow> sign x=0\"\n  \"x<0 \\<Longrightarrow> sign x=-1\"", "lemma sign_cases [case_names neg zero pos]:\n  \"(sign x = -1 \\<Longrightarrow> P) \\<Longrightarrow> (sign x = 0 \\<Longrightarrow> P) \\<Longrightarrow> (sign x =1 \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma sign_times:\n  fixes x::\"'a::linordered_ring_strict\"\n  shows \"sign (x*y) = sign x * sign y\"", "lemma sign_power:\n  fixes x::\"'a::linordered_idom\"\n  shows \"sign (x^n) = (if n=0 then 1 else if even n then \\<bar>sign x\\<bar> else sign x)\"", "lemma sgn_sign_eq:\n  fixes x::\"'a::{linordered_idom}\"\n  shows \"sgn x = of_int (sign x)\"", "lemma variation_0[simp]: \"variation 0 y=0\" \"variation x 0=0\"", "lemma variation_comm: \"variation x y= - variation y x\"", "lemma cross_0[simp]: \"cross 0 a b=0\"", "lemma variation_cases:\n  \"\\<lbrakk>x>0;y>0\\<rbrakk>\\<Longrightarrow>variation x y = 0\" \n  \"\\<lbrakk>x>0;y<0\\<rbrakk>\\<Longrightarrow>variation x y = -1\"\n  \"\\<lbrakk>x<0;y>0\\<rbrakk>\\<Longrightarrow>variation x y = 1\"\n  \"\\<lbrakk>x<0;y<0\\<rbrakk>\\<Longrightarrow>variation x y = 0\"", "lemma variation_congr:\n  assumes \"sgn x=sgn x'\" \"sgn y=sgn y'\"\n  shows \"variation x y=variation x' y'\"", "lemma variation_mult_pos: \n  assumes \"c>0\"  \n  shows \"variation (c*x) y =variation x y\" and \"variation x (c*y) =variation x y\"", "lemma variation_mult_neg_1: \n  assumes \"c<0\"  \n  shows \"variation (c*x) y =variation x y + (if y=0 then 0 else sign x)\"", "lemma variation_mult_neg_2: \n  assumes \"c<0\"  \n  shows \"variation x (c*y) = variation x y + (if x=0 then 0 else - sign y)\"", "lemma cross_no_root:\n  assumes \"a<b\" and no_root:\"\\<forall>x. a<x\\<and>x<b \\<longrightarrow> poly p x\\<noteq>0\"\n  shows \"cross p a b=0\"", "lemma sign_r_pos_rec:\n  fixes p:: \"real poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"sign_r_pos p x= (if poly p x=0 then sign_r_pos (pderiv p) x else poly p x>0 )\"", "lemma sign_r_pos_0[simp]:\"\\<not> sign_r_pos 0 (x::real)\"", "lemma sign_r_pos_minus:\n  fixes p:: \"real poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"sign_r_pos p x = (\\<not> sign_r_pos (-p) x)\"", "lemma sign_r_pos_smult:\n  fixes p :: \"real poly\"\n  assumes \"c\\<noteq>0\" \"p\\<noteq>0\"\n  shows \"sign_r_pos (smult c p) x= (if c>0 then sign_r_pos p x else \\<not> sign_r_pos p x)\"\n  (is \"?L=?R\")", "lemma sign_r_pos_mult:\n  fixes p q :: \"real poly\"\n  assumes \"p\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"sign_r_pos (p*q) x= (sign_r_pos p x \\<longleftrightarrow> sign_r_pos q x)\"", "lemma sign_r_pos_add:\n  fixes p q :: \"real poly\"\n  assumes \"poly p x=0\" \"poly q x\\<noteq>0\"\n  shows \"sign_r_pos (p+q) x=sign_r_pos q x\"", "lemma sign_r_pos_mod:\n  fixes p q :: \"real poly\"\n  assumes \"poly p x=0\" \"poly q x\\<noteq>0\"\n  shows \"sign_r_pos (q mod p) x=sign_r_pos q x\"", "lemma sign_r_pos_pderiv:\n  fixes p:: \"real poly\"\n  assumes \"poly p x=0\" \"p\\<noteq>0\"\n  shows \"sign_r_pos (pderiv p * p) x\"", "lemma sign_r_pos_power:\n  fixes p:: \"real poly\" and a::real\n  shows \"sign_r_pos ([:-a,1:]^n) a\"", "lemma jump_poly_not_root:\"poly p x\\<noteq>0\\<Longrightarrow> jump_poly q p x=0\"", "lemma jump_poly0[simp]: \n    \"jump_poly 0 p x = 0\"\n    \"jump_poly q 0 x = 0\"", "lemma jump_poly_smult_1:\n  fixes p q::\"real poly\" and c::real\n  shows \"jump_poly (smult c q) p x= sign c * jump_poly q p x\" (is \"?L=?R\")", "lemma jump_poly_mult:\n  fixes p q p'::\"real poly\"\n  assumes \"p'\\<noteq>0\"\n  shows \"jump_poly (p'*q) (p'*p) x= jump_poly q p x\"", "lemma jump_poly_1_mult:\n  fixes p1 p2::\"real poly\"\n  assumes \"poly p1 x\\<noteq>0 \\<or> poly p2 x\\<noteq>0\" \n  shows \"jump_poly 1 (p1*p2) x= sign (poly p2 x) * jump_poly 1 p1 x \n            + sign (poly p1 x) * jump_poly 1 p2 x\" (is \"?L=?R\")", "lemma jump_poly_mod:\n  fixes p q::\"real poly\" \n  shows \"jump_poly q p x= jump_poly (q mod p) p x\"", "lemma jump_poly_coprime:\n  fixes p q:: \"real poly\"\n  assumes \"poly p x=0\" \"coprime p q\"\n  shows \"jump_poly q p x= jump_poly 1 (q*p) x\"", "lemma jump_poly_sgn:\n  fixes p q:: \"real poly\"\n  assumes \"p\\<noteq>0\" \"poly p x=0\"\n  shows \"jump_poly (pderiv p * q) p x = sign (poly q x)\"", "lemma cindex_poly_0[simp]: \"cindex_poly a b 0 p = 0\" \"cindex_poly a b q 0 = 0\"", "lemma cindex_poly_cross:\n  fixes p::\"real poly\" and a b::real\n  assumes  \"a<b\" \"poly p a\\<noteq>0\" \"poly p b\\<noteq>0\"\n  shows \"cindex_poly a b 1 p = cross p a b\"", "lemma cindex_poly_mult:\n  fixes p q p'::\"real poly\"\n  assumes \"p'\\<noteq> 0\"  \n  shows \"cindex_poly a b (p' * q ) (p' * p) = cindex_poly a b q p\"", "lemma cindex_poly_smult_1: \n  fixes p q::\"real poly\" and c::real\n  shows \"cindex_poly a b (smult c q) p =  (sign c) * cindex_poly a b q p\"", "lemma cindex_poly_mod:\n  fixes p q::\"real poly\" \n  shows \"cindex_poly a b q p =  cindex_poly a b (q mod p) p\"", "lemma cindex_poly_inverse_add:\n  fixes p q::\"real poly\" \n  assumes \"coprime p q\"\n  shows \"cindex_poly a b q p + cindex_poly a b p q=cindex_poly a b 1 (q*p)\"\n    (is \"?L=?R\")", "lemma cindex_poly_inverse_add_cross:\n  fixes p q::\"real poly\"\n  assumes \"a < b\" \"poly (p * q) a \\<noteq>0\" \"poly (p * q) b \\<noteq>0\"\n  shows \"cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b\" (is \"?L=?R\")", "lemma cindex_poly_rec:\n  fixes p q::\"real poly\"\n  assumes \"a < b\" \"poly (p * q) a \\<noteq>0\" \"poly (p * q) b \\<noteq>0\"\n  shows \"cindex_poly a b q p  = cross (p * q) a b  +  cindex_poly a b (- (p mod q)) q\" (is \"?L=?R\")", "lemma cindex_poly_congr:\n  fixes p q:: \"real poly\"\n  assumes \"a<a'\" \"a'<b'\" \"b'<b\" \n  assumes \"\\<forall>x. ((a<x\\<and>x\\<le>a') \\<or> (b'\\<le>x \\<and> x<b)) \\<longrightarrow> poly p x \\<noteq>0\"\n  shows \"cindex_poly a b q p=cindex_poly a' b' q p\"", "lemma greaterThanLessThan_unfold:\"{a<..<b} = {x. a<x \\<and> x<b}\"", "lemma cindex_poly_taq:\n  fixes p q::\"real poly\"\n  shows \"taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q=cindex_poly a b (pderiv p * q) p\"", "lemma smods_nil_eq:\"smods p q = [] \\<longleftrightarrow> (p=0)\"", "lemma smods_singleton:\"[x] = smods p q \\<Longrightarrow> (p\\<noteq>0 \\<and> q=0 \\<and> x=p)\"", "lemma smods_0[simp]:\n  \"smods 0 q = []\"\n  \"smods p 0 = (if p=0 then [] else [p])\"", "lemma no_0_in_smods: \"0\\<notin>set (smods p q)\"", "lemma changes_map_sgn_eq:\n  \"changes xs = changes (map sgn xs)\"", "lemma changes_poly_at_0[simp]:  \n  \"changes_poly_at [] a =0\"\n  \"changes_poly_at [p] a=0\"", "lemma changes_R_smods_0[simp]:\n    \"changes_R_smods 0 q = 0\"\n    \"changes_R_smods p 0 = 0\"", "lemma changes_itv_smods_0[simp]:\n  \"changes_itv_smods a b 0 q = 0\"\n  \"changes_itv_smods a b p 0 = 0\"", "lemma changes_itv_smods_rec:\n  assumes \"a<b\" \"poly (p*q) a\\<noteq>0\" \"poly (p*q) b\\<noteq>0\"\n  shows \"changes_itv_smods a b p q  = cross (p*q) a b + changes_itv_smods a b q (-(p mod q))\"", "lemma changes_smods_congr:\n  fixes p q:: \"real poly\"\n  assumes \"a\\<noteq>a'\" \"poly p a\\<noteq>0\"\n  assumes \"\\<forall>p\\<in>set (smods p q). \\<forall>x. ((a<x\\<and>x\\<le>a') \\<or> (a'\\<le>x \\<and> x<a)) \\<longrightarrow> poly p x \\<noteq>0\"\n  shows \"changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\"", "lemma changes_itv_smods_congr:\n  fixes p q:: \"real poly\"\n  assumes \"a<a'\" \"a'<b'\" \"b'<b\" \"poly p a\\<noteq>0\" \"poly p b\\<noteq>0\"\n  assumes no_root:\"\\<forall>p\\<in>set (smods p q). \\<forall>x. ((a<x\\<and>x\\<le>a') \\<or> (b'\\<le>x \\<and> x<b)) \\<longrightarrow> poly p x \\<noteq>0\"\n  shows \"changes_itv_smods a b p q=changes_itv_smods a' b' p q\"", "lemma cindex_poly_changes_itv_mods: \n  assumes \"a<b\" \"poly p a\\<noteq>0\" \"poly p b\\<noteq>0\"\n  shows \"cindex_poly a b q p = changes_itv_smods a b p q\"", "lemma root_list_ub:\n  fixes ps:: \"(real poly) list\" and a::real\n  assumes \"0\\<notin>set ps\"\n  obtains ub where \"\\<forall>p\\<in>set ps. \\<forall>x. poly p x=0 \\<longrightarrow> x<ub\"\n    and \"\\<forall>x\\<ge>ub. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\" and \"ub>a\"", "lemma root_list_lb:\n  fixes ps:: \"(real poly) list\" and b::real\n  assumes \"0\\<notin>set ps\"\n  obtains lb where \"\\<forall>p\\<in>set ps. \\<forall>x. poly p x=0 \\<longrightarrow> x>lb\"\n    and \"\\<forall>x\\<le>lb. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\" and \"lb<b\"", "theorem sturm_tarski_interval: \n  assumes \"a<b\" \"poly p a\\<noteq>0\" \"poly p b\\<noteq>0\"\n  shows \"taq {x. poly p x=0 \\<and> a<x \\<and> x<b} q = changes_itv_smods a b p (pderiv p * q)\"", "theorem sturm_tarski_above: \n  assumes \"poly p a\\<noteq>0\" \n  shows \"taq {x. poly p x=0 \\<and> a<x} q = changes_gt_smods a p (pderiv p * q)\"", "theorem sturm_tarski_below: \n  assumes \"poly p b\\<noteq>0\" \n  shows \"taq {x. poly p x=0 \\<and> x<b} q = changes_le_smods b p (pderiv p * q)\"", "theorem sturm_tarski_R: \n  shows \"taq {x. poly p x=0} q = changes_R_smods p (pderiv p * q)\"", "theorem sturm_interval:\n  assumes \"a < b\" \"poly p a \\<noteq> 0\" \"poly p b \\<noteq> 0\"\n  shows \"card {x. poly p x = 0 \\<and> a < x \\<and> x < b} = changes_itv_smods a b p (pderiv p)\"", "theorem sturm_above:\n  assumes \"poly p a \\<noteq> 0\" \n  shows \"card {x. poly p x = 0 \\<and> a < x} = changes_gt_smods a p (pderiv p)\"", "theorem sturm_below:\n  assumes \"poly p b \\<noteq> 0\"\n  shows \"card {x. poly p x = 0 \\<and> x < b} = changes_le_smods b p (pderiv p)\"", "theorem sturm_R:\n  shows \"card {x. poly p x=0} =  changes_R_smods p (pderiv p)\""], "translations": [["", "lemma eventually_at_right:\n  fixes x::\"'a::{archimedean_field,linorder_topology}\"\n  shows \"eventually P (at_right x) \\<longleftrightarrow> (\\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually P (at_right x) =\n    (\\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> P y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eventually P (at_right x) =\n    (\\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> P y)", "obtain y where \"y>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. x < y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using ex_less_of_int"], ["proof (prove)\nusing this:\n  \\<exists>z. ?x < of_int z\n\ngoal (1 subgoal):\n 1. (\\<And>y. x < y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x < y\n\ngoal (1 subgoal):\n 1. eventually P (at_right x) =\n    (\\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> P y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x < y\n\ngoal (1 subgoal):\n 1. eventually P (at_right x) =\n    (\\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> P y)", "using eventually_at_right[OF \\<open>y>x\\<close>]"], ["proof (prove)\nusing this:\n  x < y\n  eventually ?P (at_right x) =\n  (\\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> ?P y)\n\ngoal (1 subgoal):\n 1. eventually P (at_right x) =\n    (\\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> P y)", "by auto"], ["proof (state)\nthis:\n  eventually P (at_right x) =\n  (\\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> P y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eventually_at_left:\n  fixes x::\"'a::{archimedean_field,linorder_topology}\"\n  shows \"eventually P (at_left x) \\<longleftrightarrow> (\\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually P (at_left x) =\n    (\\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> P y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eventually P (at_left x) =\n    (\\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> P y)", "obtain y where \"y<x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. y < x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using linordered_field_no_lb"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<exists>y. y < x\n\ngoal (1 subgoal):\n 1. (\\<And>y. y < x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  y < x\n\ngoal (1 subgoal):\n 1. eventually P (at_left x) =\n    (\\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> P y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y < x\n\ngoal (1 subgoal):\n 1. eventually P (at_left x) =\n    (\\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> P y)", "using eventually_at_left[OF \\<open>y<x\\<close>]"], ["proof (prove)\nusing this:\n  y < x\n  eventually ?P (at_left x) =\n  (\\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> ?P y)\n\ngoal (1 subgoal):\n 1. eventually P (at_left x) =\n    (\\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> P y)", "by auto"], ["proof (state)\nthis:\n  eventually P (at_left x) =\n  (\\<exists>b<x. \\<forall>y>b. y < x \\<longrightarrow> P y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eventually_neg:\n  assumes \"F\\<noteq>bot\"  and eve:\"eventually (\\<lambda>x. P x) F\"\n  shows \"\\<not> eventually (\\<lambda>x. \\<not> P x) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>\\<^sub>F x in F. \\<not> P x)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<forall>\\<^sub>F x in F. \\<not> P x) \\<Longrightarrow>\n    False", "assume \"\\<not> \\<not> eventually (\\<lambda>x. \\<not> P x) F\""], ["proof (state)\nthis:\n  \\<not> \\<not> (\\<forall>\\<^sub>F x in F. \\<not> P x)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<forall>\\<^sub>F x in F. \\<not> P x) \\<Longrightarrow>\n    False", "hence \"eventually (\\<lambda>x. \\<not> P x) F\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<forall>\\<^sub>F x in F. \\<not> P x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. \\<not> P x", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. \\<not> P x\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<forall>\\<^sub>F x in F. \\<not> P x) \\<Longrightarrow>\n    False", "hence \"eventually (\\<lambda>x. False) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. \\<not> P x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. False", "using eventually_conj[OF eve,of \"(\\<lambda>x. \\<not> P x)\"]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. \\<not> P x\n  \\<forall>\\<^sub>F x in F. \\<not> P x \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in F. P x \\<and> \\<not> P x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. False", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in F. False\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<forall>\\<^sub>F x in F. \\<not> P x) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. False\n\ngoal (1 subgoal):\n 1. False", "using \\<open>F\\<noteq>bot\\<close> eventually_False"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in F. False\n  F \\<noteq> bot\n  (\\<forall>\\<^sub>F x in ?F. False) = (?F = bot)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_tendsto[simp]:\n    \"(poly p \\<longlongrightarrow> poly p x) (at (x::real))\" \n    \"(poly p \\<longlongrightarrow> poly p x) (at_left (x::real))\"\n    \"(poly p \\<longlongrightarrow> poly p x) (at_right (x::real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p \\<midarrow>x\\<rightarrow> poly p x &&&\n    (poly p \\<longlongrightarrow> poly p x) (at_left x) &&&\n    (poly p \\<longlongrightarrow> poly p x) (at_right x)", "using isCont_def[where f=\"poly p\"]"], ["proof (prove)\nusing this:\n  isCont (poly p) ?a = poly p \\<midarrow>?a\\<rightarrow> poly p ?a\n\ngoal (1 subgoal):\n 1. poly p \\<midarrow>x\\<rightarrow> poly p x &&&\n    (poly p \\<longlongrightarrow> poly p x) (at_left x) &&&\n    (poly p \\<longlongrightarrow> poly p x) (at_right x)", "by (auto simp add:filterlim_at_split)"], ["", "lemma not_eq_pos_or_neg_iff_1:\n  fixes p::\"real poly\" \n  shows \"(\\<forall>z. lb<z\\<and>z\\<le>ub\\<longrightarrow>poly p z\\<noteq>0) \\<longleftrightarrow> \n    (\\<forall>z. lb<z\\<and>z\\<le>ub\\<longrightarrow>poly p z>0)\\<or>(\\<forall>z. lb<z\\<and>z\\<le>ub\\<longrightarrow>poly p z<0)\" (is \"?Q \\<longleftrightarrow> ?P\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0) =\n    ((\\<forall>z.\n         lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n     (\\<forall>z. lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z < 0))", "proof (rule,rule ccontr)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>z.\n                lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                poly p z \\<noteq> 0;\n     \\<not> ((\\<forall>z.\n                 lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                 0 < poly p z) \\<or>\n             (\\<forall>z.\n                 lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                 poly p z < 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n    (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow>\n        poly p z < 0) \\<Longrightarrow>\n    \\<forall>z.\n       lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0", "assume \"?Q\" \"\\<not>?P\""], ["proof (state)\nthis:\n  \\<forall>z. lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0\n  \\<not> ((\\<forall>z.\n              lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n          (\\<forall>z.\n              lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z < 0))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>z.\n                lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                poly p z \\<noteq> 0;\n     \\<not> ((\\<forall>z.\n                 lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                 0 < poly p z) \\<or>\n             (\\<forall>z.\n                 lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                 poly p z < 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n    (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow>\n        poly p z < 0) \\<Longrightarrow>\n    \\<forall>z.\n       lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>z. lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0\n  \\<not> ((\\<forall>z.\n              lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n          (\\<forall>z.\n              lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z < 0))", "obtain z1 z2 where z1:\"lb<z1\" \"z1\\<le>ub\" \"poly p z1\\<le>0\" \n                      and z2:\"lb<z2\" \"z2\\<le>ub\" \"poly p z2\\<ge>0\""], ["proof (prove)\nusing this:\n  \\<forall>z. lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0\n  \\<not> ((\\<forall>z.\n              lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n          (\\<forall>z.\n              lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z < 0))\n\ngoal (1 subgoal):\n 1. (\\<And>z1 z2.\n        \\<lbrakk>lb < z1; z1 \\<le> ub; poly p z1 \\<le> 0; lb < z2;\n         z2 \\<le> ub; 0 \\<le> poly p z2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lb < z1\n  z1 \\<le> ub\n  poly p z1 \\<le> 0\n  lb < z2\n  z2 \\<le> ub\n  0 \\<le> poly p z2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>z.\n                lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                poly p z \\<noteq> 0;\n     \\<not> ((\\<forall>z.\n                 lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                 0 < poly p z) \\<or>\n             (\\<forall>z.\n                 lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                 poly p z < 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n    (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow>\n        poly p z < 0) \\<Longrightarrow>\n    \\<forall>z.\n       lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0", "hence \"\\<exists>z. lb<z\\<and>z\\<le>ub\\<and>poly p z=0\""], ["proof (prove)\nusing this:\n  lb < z1\n  z1 \\<le> ub\n  poly p z1 \\<le> 0\n  lb < z2\n  z2 \\<le> ub\n  0 \\<le> poly p z2\n\ngoal (1 subgoal):\n 1. \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0", "proof (cases \"poly p z1 = 0 \\<or> poly p z2 =0 \\<or> z1=z2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>lb < z1; z1 \\<le> ub; poly p z1 \\<le> 0; lb < z2; z2 \\<le> ub;\n     0 \\<le> poly p z2;\n     poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0\n 2. \\<lbrakk>lb < z1; z1 \\<le> ub; poly p z1 \\<le> 0; lb < z2; z2 \\<le> ub;\n     0 \\<le> poly p z2;\n     \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0", "case True"], ["proof (state)\nthis:\n  poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lb < z1; z1 \\<le> ub; poly p z1 \\<le> 0; lb < z2; z2 \\<le> ub;\n     0 \\<le> poly p z2;\n     poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0\n 2. \\<lbrakk>lb < z1; z1 \\<le> ub; poly p z1 \\<le> 0; lb < z2; z2 \\<le> ub;\n     0 \\<le> poly p z2;\n     \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2\n\ngoal (1 subgoal):\n 1. \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0", "using z1 z2"], ["proof (prove)\nusing this:\n  poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2\n  lb < z1\n  z1 \\<le> ub\n  poly p z1 \\<le> 0\n  lb < z2\n  z2 \\<le> ub\n  0 \\<le> poly p z2\n\ngoal (1 subgoal):\n 1. \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lb < z1; z1 \\<le> ub; poly p z1 \\<le> 0; lb < z2; z2 \\<le> ub;\n     0 \\<le> poly p z2;\n     \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>lb < z1; z1 \\<le> ub; poly p z1 \\<le> 0; lb < z2; z2 \\<le> ub;\n     0 \\<le> poly p z2;\n     \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0", "case False"], ["proof (state)\nthis:\n  \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lb < z1; z1 \\<le> ub; poly p z1 \\<le> 0; lb < z2; z2 \\<le> ub;\n     0 \\<le> poly p z2;\n     \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0", "hence \"poly p z1<0\" and \"poly p z2>0\" and \"z1\\<noteq>z2\""], ["proof (prove)\nusing this:\n  \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\n\ngoal (1 subgoal):\n 1. poly p z1 < 0 &&& 0 < poly p z2 &&& z1 \\<noteq> z2", "using z1(3) z2(3)"], ["proof (prove)\nusing this:\n  \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\n  poly p z1 \\<le> 0\n  0 \\<le> poly p z2\n\ngoal (1 subgoal):\n 1. poly p z1 < 0 &&& 0 < poly p z2 &&& z1 \\<noteq> z2", "by auto"], ["proof (state)\nthis:\n  poly p z1 < 0\n  0 < poly p z2\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lb < z1; z1 \\<le> ub; poly p z1 \\<le> 0; lb < z2; z2 \\<le> ub;\n     0 \\<le> poly p z2;\n     \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0", "hence \"(\\<exists>z>z1. z < z2 \\<and> poly p z = 0) \\<or> (\\<exists>z>z2. z < z1 \\<and> poly p z = 0)\""], ["proof (prove)\nusing this:\n  poly p z1 < 0\n  0 < poly p z2\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. (\\<exists>z>z1. z < z2 \\<and> poly p z = 0) \\<or>\n    (\\<exists>z>z2. z < z1 \\<and> poly p z = 0)", "using poly_IVT_neg poly_IVT_pos"], ["proof (prove)\nusing this:\n  poly p z1 < 0\n  0 < poly p z2\n  z1 \\<noteq> z2\n  \\<lbrakk>?a < ?b; 0 < poly ?p ?a; poly ?p ?b < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>?a. x < ?b \\<and> poly ?p x = 0\n  \\<lbrakk>?a < ?b; poly ?p ?a < 0; 0 < poly ?p ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>?a. x < ?b \\<and> poly ?p x = 0\n\ngoal (1 subgoal):\n 1. (\\<exists>z>z1. z < z2 \\<and> poly p z = 0) \\<or>\n    (\\<exists>z>z2. z < z1 \\<and> poly p z = 0)", "by (subst (asm) linorder_class.neq_iff,auto)"], ["proof (state)\nthis:\n  (\\<exists>z>z1. z < z2 \\<and> poly p z = 0) \\<or>\n  (\\<exists>z>z2. z < z1 \\<and> poly p z = 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lb < z1; z1 \\<le> ub; poly p z1 \\<le> 0; lb < z2; z2 \\<le> ub;\n     0 \\<le> poly p z2;\n     \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>z>z1. z < z2 \\<and> poly p z = 0) \\<or>\n  (\\<exists>z>z2. z < z1 \\<and> poly p z = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0", "using z1(1,2) z2(1,2)"], ["proof (prove)\nusing this:\n  (\\<exists>z>z1. z < z2 \\<and> poly p z = 0) \\<or>\n  (\\<exists>z>z2. z < z1 \\<and> poly p z = 0)\n  lb < z1\n  z1 \\<le> ub\n  lb < z2\n  z2 \\<le> ub\n\ngoal (1 subgoal):\n 1. \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0", "by (metis less_eq_real_def order.strict_trans2)"], ["proof (state)\nthis:\n  \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>z.\n                lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                poly p z \\<noteq> 0;\n     \\<not> ((\\<forall>z.\n                 lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                 0 < poly p z) \\<or>\n             (\\<forall>z.\n                 lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                 poly p z < 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n    (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow>\n        poly p z < 0) \\<Longrightarrow>\n    \\<forall>z.\n       lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>?Q\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>z>lb. z \\<le> ub \\<and> poly p z = 0\n  \\<forall>z. lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n    (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow>\n        poly p z < 0) \\<Longrightarrow>\n    \\<forall>z.\n       lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n    (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow>\n        poly p z < 0) \\<Longrightarrow>\n    \\<forall>z.\n       lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0", "assume \"?P\""], ["proof (state)\nthis:\n  (\\<forall>z.\n      lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n  (\\<forall>z. lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z < 0)\n\ngoal (1 subgoal):\n 1. (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n    (\\<forall>z.\n        lb < z \\<and> z \\<le> ub \\<longrightarrow>\n        poly p z < 0) \\<Longrightarrow>\n    \\<forall>z.\n       lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0", "thus ?Q"], ["proof (prove)\nusing this:\n  (\\<forall>z.\n      lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n  (\\<forall>z. lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z < 0)\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>z. lb < z \\<and> z \\<le> ub \\<longrightarrow> poly p z \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_eq_pos_or_neg_iff_2:\n  fixes p::\"real poly\" \n  shows \"(\\<forall>z. lb\\<le>z\\<and>z<ub\\<longrightarrow>poly p z\\<noteq>0) \n    \\<longleftrightarrow>(\\<forall>z. lb\\<le>z\\<and>z<ub\\<longrightarrow>poly p z>0)\\<or>(\\<forall>z. lb\\<le>z\\<and>z<ub\\<longrightarrow>poly p z<0)\" (is \"?Q\\<longleftrightarrow>?P\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0) =\n    ((\\<forall>z.\n         lb \\<le> z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n     (\\<forall>z. lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z < 0))", "proof (rule,rule ccontr)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>z.\n                lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                poly p z \\<noteq> 0;\n     \\<not> ((\\<forall>z.\n                 lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                 0 < poly p z) \\<or>\n             (\\<forall>z.\n                 lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                 poly p z < 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n    (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow>\n        poly p z < 0) \\<Longrightarrow>\n    \\<forall>z.\n       lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0", "assume \"?Q\" \"\\<not>?P\""], ["proof (state)\nthis:\n  \\<forall>z. lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0\n  \\<not> ((\\<forall>z.\n              lb \\<le> z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n          (\\<forall>z.\n              lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z < 0))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>z.\n                lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                poly p z \\<noteq> 0;\n     \\<not> ((\\<forall>z.\n                 lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                 0 < poly p z) \\<or>\n             (\\<forall>z.\n                 lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                 poly p z < 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n    (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow>\n        poly p z < 0) \\<Longrightarrow>\n    \\<forall>z.\n       lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>z. lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0\n  \\<not> ((\\<forall>z.\n              lb \\<le> z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n          (\\<forall>z.\n              lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z < 0))", "obtain z1 z2 where z1:\"lb\\<le>z1\" \"z1<ub\" \"poly p z1\\<le>0\" \n                      and z2:\"lb\\<le>z2\" \"z2<ub\" \"poly p z2\\<ge>0\""], ["proof (prove)\nusing this:\n  \\<forall>z. lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0\n  \\<not> ((\\<forall>z.\n              lb \\<le> z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n          (\\<forall>z.\n              lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z < 0))\n\ngoal (1 subgoal):\n 1. (\\<And>z1 z2.\n        \\<lbrakk>lb \\<le> z1; z1 < ub; poly p z1 \\<le> 0; lb \\<le> z2;\n         z2 < ub; 0 \\<le> poly p z2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lb \\<le> z1\n  z1 < ub\n  poly p z1 \\<le> 0\n  lb \\<le> z2\n  z2 < ub\n  0 \\<le> poly p z2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>z.\n                lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                poly p z \\<noteq> 0;\n     \\<not> ((\\<forall>z.\n                 lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                 0 < poly p z) \\<or>\n             (\\<forall>z.\n                 lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                 poly p z < 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n    (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow>\n        poly p z < 0) \\<Longrightarrow>\n    \\<forall>z.\n       lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0", "hence \"\\<exists>z. lb\\<le>z\\<and>z<ub\\<and>poly p z=0\""], ["proof (prove)\nusing this:\n  lb \\<le> z1\n  z1 < ub\n  poly p z1 \\<le> 0\n  lb \\<le> z2\n  z2 < ub\n  0 \\<le> poly p z2\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0", "proof (cases \"poly p z1 = 0 \\<or> poly p z2 =0 \\<or> z1=z2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>lb \\<le> z1; z1 < ub; poly p z1 \\<le> 0; lb \\<le> z2; z2 < ub;\n     0 \\<le> poly p z2;\n     poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0\n 2. \\<lbrakk>lb \\<le> z1; z1 < ub; poly p z1 \\<le> 0; lb \\<le> z2; z2 < ub;\n     0 \\<le> poly p z2;\n     \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0", "case True"], ["proof (state)\nthis:\n  poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lb \\<le> z1; z1 < ub; poly p z1 \\<le> 0; lb \\<le> z2; z2 < ub;\n     0 \\<le> poly p z2;\n     poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0\n 2. \\<lbrakk>lb \\<le> z1; z1 < ub; poly p z1 \\<le> 0; lb \\<le> z2; z2 < ub;\n     0 \\<le> poly p z2;\n     \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0", "using z1 z2"], ["proof (prove)\nusing this:\n  poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2\n  lb \\<le> z1\n  z1 < ub\n  poly p z1 \\<le> 0\n  lb \\<le> z2\n  z2 < ub\n  0 \\<le> poly p z2\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lb \\<le> z1; z1 < ub; poly p z1 \\<le> 0; lb \\<le> z2; z2 < ub;\n     0 \\<le> poly p z2;\n     \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>lb \\<le> z1; z1 < ub; poly p z1 \\<le> 0; lb \\<le> z2; z2 < ub;\n     0 \\<le> poly p z2;\n     \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0", "case False"], ["proof (state)\nthis:\n  \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lb \\<le> z1; z1 < ub; poly p z1 \\<le> 0; lb \\<le> z2; z2 < ub;\n     0 \\<le> poly p z2;\n     \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0", "hence \"poly p z1<0\" and \"poly p z2>0\" and \"z1\\<noteq>z2\""], ["proof (prove)\nusing this:\n  \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\n\ngoal (1 subgoal):\n 1. poly p z1 < 0 &&& 0 < poly p z2 &&& z1 \\<noteq> z2", "using z1(3) z2(3)"], ["proof (prove)\nusing this:\n  \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\n  poly p z1 \\<le> 0\n  0 \\<le> poly p z2\n\ngoal (1 subgoal):\n 1. poly p z1 < 0 &&& 0 < poly p z2 &&& z1 \\<noteq> z2", "by auto"], ["proof (state)\nthis:\n  poly p z1 < 0\n  0 < poly p z2\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lb \\<le> z1; z1 < ub; poly p z1 \\<le> 0; lb \\<le> z2; z2 < ub;\n     0 \\<le> poly p z2;\n     \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0", "hence \"(\\<exists>z>z1. z < z2 \\<and> poly p z = 0) \\<or> (\\<exists>z>z2. z < z1 \\<and> poly p z = 0)\""], ["proof (prove)\nusing this:\n  poly p z1 < 0\n  0 < poly p z2\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. (\\<exists>z>z1. z < z2 \\<and> poly p z = 0) \\<or>\n    (\\<exists>z>z2. z < z1 \\<and> poly p z = 0)", "using poly_IVT_neg poly_IVT_pos"], ["proof (prove)\nusing this:\n  poly p z1 < 0\n  0 < poly p z2\n  z1 \\<noteq> z2\n  \\<lbrakk>?a < ?b; 0 < poly ?p ?a; poly ?p ?b < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>?a. x < ?b \\<and> poly ?p x = 0\n  \\<lbrakk>?a < ?b; poly ?p ?a < 0; 0 < poly ?p ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>?a. x < ?b \\<and> poly ?p x = 0\n\ngoal (1 subgoal):\n 1. (\\<exists>z>z1. z < z2 \\<and> poly p z = 0) \\<or>\n    (\\<exists>z>z2. z < z1 \\<and> poly p z = 0)", "by (subst (asm) linorder_class.neq_iff,auto)"], ["proof (state)\nthis:\n  (\\<exists>z>z1. z < z2 \\<and> poly p z = 0) \\<or>\n  (\\<exists>z>z2. z < z1 \\<and> poly p z = 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lb \\<le> z1; z1 < ub; poly p z1 \\<le> 0; lb \\<le> z2; z2 < ub;\n     0 \\<le> poly p z2;\n     \\<not> (poly p z1 = 0 \\<or> poly p z2 = 0 \\<or> z1 = z2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>z>z1. z < z2 \\<and> poly p z = 0) \\<or>\n  (\\<exists>z>z2. z < z1 \\<and> poly p z = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0", "using z1(1,2) z2(1,2)"], ["proof (prove)\nusing this:\n  (\\<exists>z>z1. z < z2 \\<and> poly p z = 0) \\<or>\n  (\\<exists>z>z2. z < z1 \\<and> poly p z = 0)\n  lb \\<le> z1\n  z1 < ub\n  lb \\<le> z2\n  z2 < ub\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0", "by (meson dual_order.strict_trans not_le)"], ["proof (state)\nthis:\n  \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>z.\n                lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                poly p z \\<noteq> 0;\n     \\<not> ((\\<forall>z.\n                 lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                 0 < poly p z) \\<or>\n             (\\<forall>z.\n                 lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                 poly p z < 0))\\<rbrakk>\n    \\<Longrightarrow> False\n 2. (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n    (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow>\n        poly p z < 0) \\<Longrightarrow>\n    \\<forall>z.\n       lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>?Q\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>z\\<ge>lb. z < ub \\<and> poly p z = 0\n  \\<forall>z. lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n    (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow>\n        poly p z < 0) \\<Longrightarrow>\n    \\<forall>z.\n       lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n    (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow>\n        poly p z < 0) \\<Longrightarrow>\n    \\<forall>z.\n       lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0", "assume \"?P\""], ["proof (state)\nthis:\n  (\\<forall>z.\n      lb \\<le> z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n  (\\<forall>z. lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z < 0)\n\ngoal (1 subgoal):\n 1. (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n    (\\<forall>z.\n        lb \\<le> z \\<and> z < ub \\<longrightarrow>\n        poly p z < 0) \\<Longrightarrow>\n    \\<forall>z.\n       lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0", "thus ?Q"], ["proof (prove)\nusing this:\n  (\\<forall>z.\n      lb \\<le> z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n  (\\<forall>z. lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z < 0)\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>z. lb \\<le> z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma next_non_root_interval:\n  fixes p::\"real poly\"\n  assumes \"p\\<noteq>0\"\n  obtains ub where \"ub>lb\" and \"(\\<forall>z. lb<z\\<and>z\\<le>ub\\<longrightarrow>poly p z\\<noteq>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>lb < ub;\n         \\<forall>z.\n            lb < z \\<and> z \\<le> ub \\<longrightarrow>\n            poly p z \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"(\\<exists> r. poly p r=0 \\<and> r>lb)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ub.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>r. poly p r = 0 \\<and> lb < r\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ub.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<nexists>r. poly p r = 0 \\<and> lb < r\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<nexists>r. poly p r = 0 \\<and> lb < r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ub.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>r. poly p r = 0 \\<and> lb < r\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ub.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<nexists>r. poly p r = 0 \\<and> lb < r\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>r. poly p r = 0 \\<and> lb < r\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of \"lb+1\"],auto)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>r. poly p r = 0 \\<and> lb < r\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>r. poly p r = 0 \\<and> lb < r\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  \\<exists>r. poly p r = 0 \\<and> lb < r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>r. poly p r = 0 \\<and> lb < r\\<rbrakk>\n    \\<Longrightarrow> thesis", "define lr where \"lr\\<equiv>Min {r . poly p r=0 \\<and> r>lb}\""], ["proof (state)\nthis:\n  lr \\<equiv> Min {r. poly p r = 0 \\<and> lb < r}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>r. poly p r = 0 \\<and> lb < r\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<forall>z. lb<z\\<and>z<lr\\<longrightarrow>poly p z\\<noteq>0\" and \"lr>lb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       lb < z \\<and> z < lr \\<longrightarrow> poly p z \\<noteq> 0 &&&\n    lb < lr", "using True lr_def poly_roots_finite[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>r. poly p r = 0 \\<and> lb < r\n  lr \\<equiv> Min {r. poly p r = 0 \\<and> lb < r}\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       lb < z \\<and> z < lr \\<longrightarrow> poly p z \\<noteq> 0 &&&\n    lb < lr", "by auto"], ["proof (state)\nthis:\n  \\<forall>z. lb < z \\<and> z < lr \\<longrightarrow> poly p z \\<noteq> 0\n  lb < lr\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb < z \\<and> z \\<le> ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>r. poly p r = 0 \\<and> lb < r\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>z. lb < z \\<and> z < lr \\<longrightarrow> poly p z \\<noteq> 0\n  lb < lr\n\ngoal (1 subgoal):\n 1. thesis", "using that[of \"(lb+lr)/2\"]"], ["proof (prove)\nusing this:\n  \\<forall>z. lb < z \\<and> z < lr \\<longrightarrow> poly p z \\<noteq> 0\n  lb < lr\n  \\<lbrakk>lb < (lb + lr) / 2;\n   \\<forall>z.\n      lb < z \\<and> z \\<le> (lb + lr) / 2 \\<longrightarrow>\n      poly p z \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma last_non_root_interval:\n  fixes p::\"real poly\"\n  assumes \"p\\<noteq>0\"\n  obtains lb where \"lb<ub\" and \"(\\<forall>z. lb\\<le>z\\<and>z<ub\\<longrightarrow>poly p z\\<noteq>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>lb < ub;\n         \\<forall>z.\n            lb \\<le> z \\<and> z < ub \\<longrightarrow>\n            poly p z \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"(\\<exists> r. poly p r=0 \\<and> r<ub)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>lb.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>r. poly p r = 0 \\<and> r < ub\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>lb.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<nexists>r. poly p r = 0 \\<and> r < ub\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<nexists>r. poly p r = 0 \\<and> r < ub\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>lb.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>r. poly p r = 0 \\<and> r < ub\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>lb.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<nexists>r. poly p r = 0 \\<and> r < ub\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>r. poly p r = 0 \\<and> r < ub\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of \"ub - 1\"]) auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>lb.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>r. poly p r = 0 \\<and> r < ub\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>lb.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>r. poly p r = 0 \\<and> r < ub\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  \\<exists>r. poly p r = 0 \\<and> r < ub\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>lb.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>r. poly p r = 0 \\<and> r < ub\\<rbrakk>\n    \\<Longrightarrow> thesis", "define mr where  \"mr\\<equiv>Max {r . poly p r=0 \\<and> r<ub}\""], ["proof (state)\nthis:\n  mr \\<equiv> Max {r. poly p r = 0 \\<and> r < ub}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>lb.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>r. poly p r = 0 \\<and> r < ub\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<forall>z. mr<z\\<and>z<ub\\<longrightarrow>poly p z\\<noteq>0\" and \"mr<ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       mr < z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0 &&&\n    mr < ub", "using True mr_def poly_roots_finite[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>r. poly p r = 0 \\<and> r < ub\n  mr \\<equiv> Max {r. poly p r = 0 \\<and> r < ub}\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       mr < z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0 &&&\n    mr < ub", "by auto"], ["proof (state)\nthis:\n  \\<forall>z. mr < z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0\n  mr < ub\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>lb.\n                \\<lbrakk>lb < ub;\n                 \\<forall>z.\n                    lb \\<le> z \\<and> z < ub \\<longrightarrow>\n                    poly p z \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>r. poly p r = 0 \\<and> r < ub\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>z. mr < z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0\n  mr < ub\n\ngoal (1 subgoal):\n 1. thesis", "using that[of \"(mr+ub)/2\"] \\<open>mr<ub\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>z. mr < z \\<and> z < ub \\<longrightarrow> poly p z \\<noteq> 0\n  mr < ub\n  \\<lbrakk>(mr + ub) / 2 < ub;\n   \\<forall>z.\n      (mr + ub) / 2 \\<le> z \\<and> z < ub \\<longrightarrow>\n      poly p z \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> thesis\n  mr < ub\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "section\\<open>Bound of polynomials\\<close>"], ["", "definition sgn_pos_inf :: \"('a ::linordered_idom) poly \\<Rightarrow> 'a\" where \n  \"sgn_pos_inf p \\<equiv> sgn (lead_coeff p)\""], ["", "definition sgn_neg_inf :: \"('a ::linordered_idom) poly \\<Rightarrow> 'a\" where \n  \"sgn_neg_inf p \\<equiv> if even (degree p) then sgn (lead_coeff p) else -sgn (lead_coeff p)\""], ["", "lemma sgn_inf_sym:\n  fixes p::\"real poly\"\n  shows \"sgn_pos_inf (pcompose p [:0,-1:]) = sgn_neg_inf p\" (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn_pos_inf (p \\<circ>\\<^sub>p [:0, - 1:]) = sgn_neg_inf p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgn_pos_inf (p \\<circ>\\<^sub>p [:0, - 1:]) = sgn_neg_inf p", "have \"?L= sgn (lead_coeff p * (- 1) ^ degree p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn_pos_inf (p \\<circ>\\<^sub>p [:0, - 1:]) =\n    sgn (lead_coeff p * (- 1) ^ degree p)", "unfolding sgn_pos_inf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (lead_coeff (p \\<circ>\\<^sub>p [:0, - 1:])) =\n    sgn (lead_coeff p * (- 1) ^ degree p)", "by (subst lead_coeff_comp,auto)"], ["proof (state)\nthis:\n  sgn_pos_inf (p \\<circ>\\<^sub>p [:0, - 1:]) =\n  sgn (lead_coeff p * (- 1) ^ degree p)\n\ngoal (1 subgoal):\n 1. sgn_pos_inf (p \\<circ>\\<^sub>p [:0, - 1:]) = sgn_neg_inf p", "thus ?thesis"], ["proof (prove)\nusing this:\n  sgn_pos_inf (p \\<circ>\\<^sub>p [:0, - 1:]) =\n  sgn (lead_coeff p * (- 1) ^ degree p)\n\ngoal (1 subgoal):\n 1. sgn_pos_inf (p \\<circ>\\<^sub>p [:0, - 1:]) = sgn_neg_inf p", "unfolding sgn_neg_inf_def"], ["proof (prove)\nusing this:\n  sgn_pos_inf (p \\<circ>\\<^sub>p [:0, - 1:]) =\n  sgn (lead_coeff p * (- 1) ^ degree p)\n\ngoal (1 subgoal):\n 1. sgn_pos_inf (p \\<circ>\\<^sub>p [:0, - 1:]) =\n    (if even (degree p) then sgn (lead_coeff p) else - sgn (lead_coeff p))", "by (metis mult.right_neutral mult_minus1_right neg_one_even_power neg_one_odd_power sgn_minus)"], ["proof (state)\nthis:\n  sgn_pos_inf (p \\<circ>\\<^sub>p [:0, - 1:]) = sgn_neg_inf p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_pinfty_gt_lc:\n  fixes p:: \"real poly\"\n  assumes  \"lead_coeff p > 0\" \n  shows \"\\<exists> n. \\<forall> x \\<ge> n. poly p x \\<ge> lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x", "using assms"], ["proof (prove)\nusing this:\n  0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < lead_coeff 0 \\<Longrightarrow>\n    \\<exists>n. \\<forall>x\\<ge>n. lead_coeff 0 \\<le> poly 0 x\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        0 < lead_coeff p \\<Longrightarrow>\n        \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x;\n        0 < lead_coeff (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>x\\<ge>n.\n                               lead_coeff (pCons a p)\n                               \\<le> poly (pCons a p) x", "case 0"], ["proof (state)\nthis:\n  0 < lead_coeff 0\n\ngoal (2 subgoals):\n 1. 0 < lead_coeff 0 \\<Longrightarrow>\n    \\<exists>n. \\<forall>x\\<ge>n. lead_coeff 0 \\<le> poly 0 x\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        0 < lead_coeff p \\<Longrightarrow>\n        \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x;\n        0 < lead_coeff (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>x\\<ge>n.\n                               lead_coeff (pCons a p)\n                               \\<le> poly (pCons a p) x", "thus ?case"], ["proof (prove)\nusing this:\n  0 < lead_coeff 0\n\ngoal (1 subgoal):\n 1. \\<exists>n. \\<forall>x\\<ge>n. lead_coeff 0 \\<le> poly 0 x", "by auto"], ["proof (state)\nthis:\n  \\<exists>n. \\<forall>x\\<ge>n. lead_coeff 0 \\<le> poly 0 x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        0 < lead_coeff p \\<Longrightarrow>\n        \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x;\n        0 < lead_coeff (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>x\\<ge>n.\n                               lead_coeff (pCons a p)\n                               \\<le> poly (pCons a p) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        0 < lead_coeff p \\<Longrightarrow>\n        \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x;\n        0 < lead_coeff (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>x\\<ge>n.\n                               lead_coeff (pCons a p)\n                               \\<le> poly (pCons a p) x", "case (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n  0 < lead_coeff p \\<Longrightarrow>\n  \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x\n  0 < lead_coeff (pCons a p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        0 < lead_coeff p \\<Longrightarrow>\n        \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x;\n        0 < lead_coeff (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>x\\<ge>n.\n                               lead_coeff (pCons a p)\n                               \\<le> poly (pCons a p) x", "have \"\\<lbrakk>a\\<noteq>0;p=0\\<rbrakk> \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; p = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n.\n                         \\<forall>x\\<ge>n.\n                            lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; p = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n.\n                       \\<forall>x\\<ge>n.\n                          lead_coeff (pCons a p) \\<le> poly (pCons a p) x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        0 < lead_coeff p \\<Longrightarrow>\n        \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x;\n        0 < lead_coeff (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>x\\<ge>n.\n                               lead_coeff (pCons a p)\n                               \\<le> poly (pCons a p) x", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> 0; p = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n.\n                       \\<forall>x\\<ge>n.\n                          lead_coeff (pCons a p) \\<le> poly (pCons a p) x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        0 < lead_coeff p \\<Longrightarrow>\n        \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x;\n        0 < lead_coeff (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>x\\<ge>n.\n                               lead_coeff (pCons a p)\n                               \\<le> poly (pCons a p) x", "have \"p\\<noteq>0 \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>n.\n       \\<forall>x\\<ge>n. lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>n.\n       \\<forall>x\\<ge>n. lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "assume \"p\\<noteq>0\""], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>n.\n       \\<forall>x\\<ge>n. lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "obtain n1 where gte_lcoeff:\"\\<forall>x\\<ge>n1. lead_coeff p \\<le> poly p x\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>n1.\n        \\<forall>x\\<ge>n1. lead_coeff p \\<le> poly p x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using that pCons"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  \\<forall>x\\<ge>?n1.0. lead_coeff p \\<le> poly p x \\<Longrightarrow> thesis\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n  0 < lead_coeff p \\<Longrightarrow>\n  \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x\n  0 < lead_coeff (pCons a p)\n\ngoal (1 subgoal):\n 1. (\\<And>n1.\n        \\<forall>x\\<ge>n1. lead_coeff p \\<le> poly p x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<ge>n1. lead_coeff p \\<le> poly p x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>n.\n       \\<forall>x\\<ge>n. lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "have gt_0:\"lead_coeff p >0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lead_coeff p", "using pCons(3) \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  0 < lead_coeff (pCons a p)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff p", "by auto"], ["proof (state)\nthis:\n  0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>n.\n       \\<forall>x\\<ge>n. lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "define n where \"n\\<equiv>max n1 (1+ \\<bar>a\\<bar>/(lead_coeff p))\""], ["proof (state)\nthis:\n  n \\<equiv> max n1 (1 + \\<bar>a\\<bar> / lead_coeff p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>n.\n       \\<forall>x\\<ge>n. lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       \\<forall>x\\<ge>n. lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "proof (rule_tac x=n in exI,rule,rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       n \\<le> x \\<Longrightarrow>\n       lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       n \\<le> x \\<Longrightarrow>\n       lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "assume \"n \\<le> x\""], ["proof (state)\nthis:\n  n \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       n \\<le> x \\<Longrightarrow>\n       lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "hence \"lead_coeff p \\<le> poly p x\""], ["proof (prove)\nusing this:\n  n \\<le> x\n\ngoal (1 subgoal):\n 1. lead_coeff p \\<le> poly p x", "using gte_lcoeff"], ["proof (prove)\nusing this:\n  n \\<le> x\n  \\<forall>x\\<ge>n1. lead_coeff p \\<le> poly p x\n\ngoal (1 subgoal):\n 1. lead_coeff p \\<le> poly p x", "unfolding n_def"], ["proof (prove)\nusing this:\n  max n1 (1 + \\<bar>a\\<bar> / lead_coeff p) \\<le> x\n  \\<forall>x\\<ge>n1. lead_coeff p \\<le> poly p x\n\ngoal (1 subgoal):\n 1. lead_coeff p \\<le> poly p x", "by auto"], ["proof (state)\nthis:\n  lead_coeff p \\<le> poly p x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       n \\<le> x \\<Longrightarrow>\n       lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "hence \" \\<bar>a\\<bar>/(lead_coeff p) \\<ge> \\<bar>a\\<bar>/(poly p x)\" and \"poly p x>0\""], ["proof (prove)\nusing this:\n  lead_coeff p \\<le> poly p x\n\ngoal (1 subgoal):\n 1. \\<bar>a\\<bar> / poly p x \\<le> \\<bar>a\\<bar> / lead_coeff p &&&\n    0 < poly p x", "using gt_0"], ["proof (prove)\nusing this:\n  lead_coeff p \\<le> poly p x\n  0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. \\<bar>a\\<bar> / poly p x \\<le> \\<bar>a\\<bar> / lead_coeff p &&&\n    0 < poly p x", "by (intro frac_le,auto)"], ["proof (state)\nthis:\n  \\<bar>a\\<bar> / poly p x \\<le> \\<bar>a\\<bar> / lead_coeff p\n  0 < poly p x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       n \\<le> x \\<Longrightarrow>\n       lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "hence \"x\\<ge>1+ \\<bar>a\\<bar>/(poly p x)\""], ["proof (prove)\nusing this:\n  \\<bar>a\\<bar> / poly p x \\<le> \\<bar>a\\<bar> / lead_coeff p\n  0 < poly p x\n\ngoal (1 subgoal):\n 1. 1 + \\<bar>a\\<bar> / poly p x \\<le> x", "using \\<open>n\\<le>x\\<close>[unfolded n_def]"], ["proof (prove)\nusing this:\n  \\<bar>a\\<bar> / poly p x \\<le> \\<bar>a\\<bar> / lead_coeff p\n  0 < poly p x\n  max n1 (1 + \\<bar>a\\<bar> / lead_coeff p) \\<le> x\n\ngoal (1 subgoal):\n 1. 1 + \\<bar>a\\<bar> / poly p x \\<le> x", "by auto"], ["proof (state)\nthis:\n  1 + \\<bar>a\\<bar> / poly p x \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       n \\<le> x \\<Longrightarrow>\n       lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "thus \"lead_coeff (pCons a p) \\<le> poly (pCons a p) x\""], ["proof (prove)\nusing this:\n  1 + \\<bar>a\\<bar> / poly p x \\<le> x\n\ngoal (1 subgoal):\n 1. lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "using \\<open>lead_coeff p \\<le> poly p x\\<close> \\<open>poly p x>0\\<close> \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  1 + \\<bar>a\\<bar> / poly p x \\<le> x\n  lead_coeff p \\<le> poly p x\n  0 < poly p x\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  lead_coeff (pCons a p) \\<le> poly (pCons a p) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n.\n     \\<forall>x\\<ge>n. lead_coeff (pCons a p) \\<le> poly (pCons a p) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>n.\n     \\<forall>x\\<ge>n. lead_coeff (pCons a p) \\<le> poly (pCons a p) x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        0 < lead_coeff p \\<Longrightarrow>\n        \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x;\n        0 < lead_coeff (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>x\\<ge>n.\n                               lead_coeff (pCons a p)\n                               \\<le> poly (pCons a p) x", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>a \\<noteq> 0; p = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n.\n                       \\<forall>x\\<ge>n.\n                          lead_coeff (pCons a p) \\<le> poly (pCons a p) x\n  p \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>n.\n     \\<forall>x\\<ge>n. lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> 0; p = 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n.\n                       \\<forall>x\\<ge>n.\n                          lead_coeff (pCons a p) \\<le> poly (pCons a p) x\n  p \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>n.\n     \\<forall>x\\<ge>n. lead_coeff (pCons a p) \\<le> poly (pCons a p) x\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       \\<forall>x\\<ge>n. lead_coeff (pCons a p) \\<le> poly (pCons a p) x", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>n.\n     \\<forall>x\\<ge>n. lead_coeff (pCons a p) \\<le> poly (pCons a p) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_sgn_eventually_at_top:\n  fixes p::\"real poly\"\n  shows \"eventually (\\<lambda>x. sgn (poly p x) = sgn_pos_inf p) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. sgn (poly p x) = sgn_pos_inf p", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. sgn (poly p x) = sgn_pos_inf p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. sgn (poly p x) = sgn_pos_inf p", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. sgn (poly p x) = sgn_pos_inf p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. sgn (poly p x) = sgn_pos_inf p", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. sgn (poly p x) = sgn_pos_inf p", "unfolding sgn_pos_inf_def"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. sgn (poly p x) = sgn (lead_coeff p)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. sgn (poly p x) = sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. sgn (poly p x) = sgn_pos_inf p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. sgn (poly p x) = sgn_pos_inf p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. sgn (poly p x) = sgn_pos_inf p", "obtain ub where ub:\"\\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"lead_coeff p>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ub.\n                \\<forall>x\\<ge>ub.\n                   sgn (poly p x) = sgn_pos_inf p \\<Longrightarrow>\n                thesis;\n     0 < lead_coeff p\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ub.\n                \\<forall>x\\<ge>ub.\n                   sgn (poly p x) = sgn_pos_inf p \\<Longrightarrow>\n                thesis;\n     \\<not> 0 < lead_coeff p\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  0 < lead_coeff p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ub.\n                \\<forall>x\\<ge>ub.\n                   sgn (poly p x) = sgn_pos_inf p \\<Longrightarrow>\n                thesis;\n     0 < lead_coeff p\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ub.\n                \\<forall>x\\<ge>ub.\n                   sgn (poly p x) = sgn_pos_inf p \\<Longrightarrow>\n                thesis;\n     \\<not> 0 < lead_coeff p\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. thesis", "using that poly_pinfty_gt_lc[of p]"], ["proof (prove)\nusing this:\n  0 < lead_coeff p\n  \\<forall>x\\<ge>?ub. sgn (poly p x) = sgn_pos_inf p \\<Longrightarrow>\n  thesis\n  0 < lead_coeff p \\<Longrightarrow>\n  \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x\n\ngoal (1 subgoal):\n 1. thesis", "unfolding sgn_pos_inf_def"], ["proof (prove)\nusing this:\n  0 < lead_coeff p\n  \\<forall>x\\<ge>?ub. sgn (poly p x) = sgn (lead_coeff p) \\<Longrightarrow>\n  thesis\n  0 < lead_coeff p \\<Longrightarrow>\n  \\<exists>n. \\<forall>x\\<ge>n. lead_coeff p \\<le> poly p x\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub.\n                \\<forall>x\\<ge>ub.\n                   sgn (poly p x) = sgn_pos_inf p \\<Longrightarrow>\n                thesis;\n     \\<not> 0 < lead_coeff p\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub.\n                \\<forall>x\\<ge>ub.\n                   sgn (poly p x) = sgn_pos_inf p \\<Longrightarrow>\n                thesis;\n     \\<not> 0 < lead_coeff p\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub.\n                \\<forall>x\\<ge>ub.\n                   sgn (poly p x) = sgn_pos_inf p \\<Longrightarrow>\n                thesis;\n     \\<not> 0 < lead_coeff p\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"lead_coeff (-p) > 0\" and \"lead_coeff p < 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff (- p) &&& lead_coeff p < 0", "unfolding lead_coeff_minus"], ["proof (prove)\nusing this:\n  \\<not> 0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. 0 < - lead_coeff p &&& lead_coeff p < 0", "using leading_coeff_neq_0[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  \\<not> 0 < lead_coeff p\n  lead_coeff p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < - lead_coeff p &&& lead_coeff p < 0", "by (auto simp add:not_less_iff_gr_or_eq)"], ["proof (state)\nthis:\n  0 < lead_coeff (- p)\n  lead_coeff p < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub.\n                \\<forall>x\\<ge>ub.\n                   sgn (poly p x) = sgn_pos_inf p \\<Longrightarrow>\n                thesis;\n     \\<not> 0 < lead_coeff p\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  0 < lead_coeff (- p)\n  lead_coeff p < 0", "obtain n where \"\\<forall>x\\<ge>n. lead_coeff p \\<ge> poly p x\""], ["proof (prove)\nusing this:\n  0 < lead_coeff (- p)\n  lead_coeff p < 0\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<forall>x\\<ge>n. poly p x \\<le> lead_coeff p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using poly_pinfty_gt_lc[of \"-p\"]"], ["proof (prove)\nusing this:\n  0 < lead_coeff (- p)\n  lead_coeff p < 0\n  0 < lead_coeff (- p) \\<Longrightarrow>\n  \\<exists>n. \\<forall>x\\<ge>n. lead_coeff (- p) \\<le> poly (- p) x\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<forall>x\\<ge>n. poly p x \\<le> lead_coeff p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding lead_coeff_minus"], ["proof (prove)\nusing this:\n  0 < - lead_coeff p\n  lead_coeff p < 0\n  0 < - lead_coeff p \\<Longrightarrow>\n  \\<exists>n. \\<forall>x\\<ge>n. - lead_coeff p \\<le> poly (- p) x\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<forall>x\\<ge>n. poly p x \\<le> lead_coeff p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<ge>n. poly p x \\<le> lead_coeff p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub.\n                \\<forall>x\\<ge>ub.\n                   sgn (poly p x) = sgn_pos_inf p \\<Longrightarrow>\n                thesis;\n     \\<not> 0 < lead_coeff p\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<ge>n. poly p x \\<le> lead_coeff p\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>lead_coeff p<0\\<close> that[of n]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<ge>n. poly p x \\<le> lead_coeff p\n  lead_coeff p < 0\n  \\<forall>x\\<ge>n. sgn (poly p x) = sgn_pos_inf p \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "unfolding sgn_pos_inf_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<ge>n. poly p x \\<le> lead_coeff p\n  lead_coeff p < 0\n  \\<forall>x\\<ge>n. sgn (poly p x) = sgn (lead_coeff p) \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top. sgn (poly p x) = sgn_pos_inf p", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. sgn (poly p x) = sgn_pos_inf p", "unfolding eventually_at_top_linorder"], ["proof (prove)\nusing this:\n  \\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. sgn (poly p n) = sgn_pos_inf p", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. sgn (poly p x) = sgn_pos_inf p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_sgn_eventually_at_bot:\n  fixes p::\"real poly\"\n  shows \"eventually (\\<lambda>x. sgn (poly p x) = sgn_neg_inf p) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_bot. sgn (poly p x) = sgn_neg_inf p", "using \n  poly_sgn_eventually_at_top[of \"pcompose p [:0,-1:]\",unfolded poly_pcompose sgn_inf_sym,simplified]\n  eventually_filtermap[of _ uminus \"at_bot::real filter\",folded at_top_mirror]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. sgn (poly p (- x)) = sgn_neg_inf p\n  eventually ?P at_top = (\\<forall>\\<^sub>F x in at_bot. ?P (- x))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_bot. sgn (poly p x) = sgn_neg_inf p", "by auto"], ["", "lemma root_ub:\n  fixes p:: \"real poly\"\n  assumes \"p\\<noteq>0\"\n  obtains ub where \"\\<forall>x. poly p x=0 \\<longrightarrow> x<ub\"\n    and \"\\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain ub1 where ub1:\"\\<forall>x. poly p x=0 \\<longrightarrow> x<ub1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub1.\n        \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"\\<exists> r. poly p r=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ub1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> x < ub1 \\<Longrightarrow>\n                thesis;\n     \\<exists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ub1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> x < ub1 \\<Longrightarrow>\n                thesis;\n     \\<nexists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<nexists>r. poly p r = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ub1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> x < ub1 \\<Longrightarrow>\n                thesis;\n     \\<exists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ub1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> x < ub1 \\<Longrightarrow>\n                thesis;\n     \\<nexists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>r. poly p r = 0\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<nexists>r. poly p r = 0\n  \\<forall>x. poly p x = 0 \\<longrightarrow> x < ?ub1.0 \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> x < ub1 \\<Longrightarrow>\n                thesis;\n     \\<exists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> x < ub1 \\<Longrightarrow>\n                thesis;\n     \\<exists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  \\<exists>r. poly p r = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> x < ub1 \\<Longrightarrow>\n                thesis;\n     \\<exists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "define max_r where \"max_r\\<equiv>Max {x . poly p x=0}\""], ["proof (state)\nthis:\n  max_r \\<equiv> Max {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> x < ub1 \\<Longrightarrow>\n                thesis;\n     \\<exists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<forall>x. poly p x=0 \\<longrightarrow> x\\<le>max_r\""], ["proof (prove)\nusing this:\n  max_r \\<equiv> Max {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<forall>x. poly p x = 0 \\<longrightarrow> x \\<le> max_r", "using  poly_roots_finite[OF \\<open>p\\<noteq>0\\<close>] True"], ["proof (prove)\nusing this:\n  max_r \\<equiv> Max {x. poly p x = 0}\n  finite {x. poly p x = 0}\n  \\<exists>r. poly p r = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x. poly p x = 0 \\<longrightarrow> x \\<le> max_r", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> x \\<le> max_r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ub1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> x < ub1 \\<Longrightarrow>\n                thesis;\n     \\<exists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> x \\<le> max_r\n\ngoal (1 subgoal):\n 1. thesis", "using that[of \"max_r+1\"]"], ["proof (prove)\nusing this:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> x \\<le> max_r\n  \\<forall>x. poly p x = 0 \\<longrightarrow> x < max_r + 1 \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (metis add.commute add_strict_increasing zero_less_one)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub1\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain ub2 where ub2:\"\\<forall>x\\<ge>ub2. sgn (poly p x) = sgn_pos_inf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub2.\n        \\<forall>x\\<ge>ub2. sgn (poly p x) = sgn_pos_inf p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using poly_sgn_eventually_at_top[unfolded eventually_at_top_linorder]"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. sgn (poly ?p n) = sgn_pos_inf ?p\n\ngoal (1 subgoal):\n 1. (\\<And>ub2.\n        \\<forall>x\\<ge>ub2. sgn (poly p x) = sgn_pos_inf p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<ge>ub2. sgn (poly p x) = sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define ub where \"ub\\<equiv>max ub1 ub2\""], ["proof (state)\nthis:\n  ub \\<equiv> max ub1 ub2\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall>x. poly p x=0 \\<longrightarrow> x<ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub", "using ub1 ub_def"], ["proof (prove)\nusing this:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub1\n  ub \\<equiv> max ub1 ub2\n\ngoal (1 subgoal):\n 1. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub", "by (metis eq_iff less_eq_real_def less_linear max.bounded_iff)"], ["proof (state)\nthis:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n\ngoal (1 subgoal):\n 1. thesis", "using that[of ub] ub2 ub_def"], ["proof (prove)\nusing this:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n  \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n   \\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<forall>x\\<ge>ub2. sgn (poly p x) = sgn_pos_inf p\n  ub \\<equiv> max ub1 ub2\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_lb:\n  fixes p:: \"real poly\"\n  assumes \"p\\<noteq>0\"\n  obtains lb where \"\\<forall>x. poly p x=0 \\<longrightarrow> x>lb\"\n    and \"\\<forall>x\\<le>lb. sgn (poly p x) = sgn_neg_inf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb. sgn (poly p x) = sgn_neg_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb. sgn (poly p x) = sgn_neg_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain lb1 where lb1:\"\\<forall>x. poly p x=0 \\<longrightarrow> x>lb1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb1.\n        \\<forall>x. poly p x = 0 \\<longrightarrow> lb1 < x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"\\<exists> r. poly p r=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>lb1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> lb1 < x \\<Longrightarrow>\n                thesis;\n     \\<exists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>lb1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> lb1 < x \\<Longrightarrow>\n                thesis;\n     \\<nexists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<nexists>r. poly p r = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>lb1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> lb1 < x \\<Longrightarrow>\n                thesis;\n     \\<exists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>lb1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> lb1 < x \\<Longrightarrow>\n                thesis;\n     \\<nexists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>r. poly p r = 0\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<nexists>r. poly p r = 0\n  \\<forall>x. poly p x = 0 \\<longrightarrow> ?lb1.0 < x \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>lb1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> lb1 < x \\<Longrightarrow>\n                thesis;\n     \\<exists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>lb1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> lb1 < x \\<Longrightarrow>\n                thesis;\n     \\<exists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  \\<exists>r. poly p r = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>lb1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> lb1 < x \\<Longrightarrow>\n                thesis;\n     \\<exists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "define min_r where \"min_r\\<equiv>Min {x . poly p x=0}\""], ["proof (state)\nthis:\n  min_r \\<equiv> Min {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>lb1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> lb1 < x \\<Longrightarrow>\n                thesis;\n     \\<exists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<forall>x. poly p x=0 \\<longrightarrow> x\\<ge>min_r\""], ["proof (prove)\nusing this:\n  min_r \\<equiv> Min {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. \\<forall>x. poly p x = 0 \\<longrightarrow> min_r \\<le> x", "using  poly_roots_finite[OF \\<open>p\\<noteq>0\\<close>] True"], ["proof (prove)\nusing this:\n  min_r \\<equiv> Min {x. poly p x = 0}\n  finite {x. poly p x = 0}\n  \\<exists>r. poly p r = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x. poly p x = 0 \\<longrightarrow> min_r \\<le> x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> min_r \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>lb1.\n                \\<forall>x.\n                   poly p x = 0 \\<longrightarrow> lb1 < x \\<Longrightarrow>\n                thesis;\n     \\<exists>r. poly p r = 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> min_r \\<le> x\n\ngoal (1 subgoal):\n 1. thesis", "using that[of \"min_r - 1\"]"], ["proof (prove)\nusing this:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> min_r \\<le> x\n  \\<forall>x. poly p x = 0 \\<longrightarrow> min_r - 1 < x \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (metis lt_ex order.strict_trans2 that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> lb1 < x\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb. sgn (poly p x) = sgn_neg_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain lb2 where lb2:\"\\<forall>x\\<le>lb2. sgn (poly p x) = sgn_neg_inf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb2.\n        \\<forall>x\\<le>lb2. sgn (poly p x) = sgn_neg_inf p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using poly_sgn_eventually_at_bot[unfolded eventually_at_bot_linorder]"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<le>N. sgn (poly ?p n) = sgn_neg_inf ?p\n\ngoal (1 subgoal):\n 1. (\\<And>lb2.\n        \\<forall>x\\<le>lb2. sgn (poly p x) = sgn_neg_inf p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<le>lb2. sgn (poly p x) = sgn_neg_inf p\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb. sgn (poly p x) = sgn_neg_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define lb where  \"lb\\<equiv>min lb1 lb2\""], ["proof (state)\nthis:\n  lb \\<equiv> min lb1 lb2\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb. sgn (poly p x) = sgn_neg_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall>x. poly p x=0 \\<longrightarrow> x>lb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x", "using lb1 lb_def"], ["proof (prove)\nusing this:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> lb1 < x\n  lb \\<equiv> min lb1 lb2\n\ngoal (1 subgoal):\n 1. \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x", "by (metis (poly_guards_query) less_not_sym min_less_iff_conj neq_iff)"], ["proof (state)\nthis:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb. sgn (poly p x) = sgn_neg_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n\ngoal (1 subgoal):\n 1. thesis", "using that[of lb] lb2 lb_def"], ["proof (prove)\nusing this:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n  \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n   \\<forall>x\\<le>lb. sgn (poly p x) = sgn_neg_inf p\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<forall>x\\<le>lb2. sgn (poly p x) = sgn_neg_inf p\n  lb \\<equiv> min lb1 lb2\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "section\\<open>Sign\\<close>"], ["", "definition sign:: \"'a::{zero,linorder} \\<Rightarrow> int\" where\n  \"sign x\\<equiv>(if x>0 then 1 else if x=0 then 0 else -1)\""], ["", "lemma sign_simps[simp]:\n  \"x>0 \\<Longrightarrow> sign x=1\"\n  \"x=0 \\<Longrightarrow> sign x=0\"\n  \"x<0 \\<Longrightarrow> sign x=-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0::'a) < x \\<Longrightarrow> sign x = 1) &&&\n    (x = (0::'a) \\<Longrightarrow> sign x = 0) &&&\n    (x < (0::'a) \\<Longrightarrow> sign x = - 1)", "unfolding sign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0::'a) < x \\<Longrightarrow>\n     (if (0::'a) < x then 1 else if x = (0::'a) then 0 else - 1) = 1) &&&\n    (x = (0::'a) \\<Longrightarrow>\n     (if (0::'a) < x then 1 else if x = (0::'a) then 0 else - 1) = 0) &&&\n    (x < (0::'a) \\<Longrightarrow>\n     (if (0::'a) < x then 1 else if x = (0::'a) then 0 else - 1) = - 1)", "by auto"], ["", "lemma sign_cases [case_names neg zero pos]:\n  \"(sign x = -1 \\<Longrightarrow> P) \\<Longrightarrow> (sign x = 0 \\<Longrightarrow> P) \\<Longrightarrow> (sign x =1 \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sign x = - 1 \\<Longrightarrow> P;\n     sign x = 0 \\<Longrightarrow> P; sign x = 1 \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "unfolding Sturm_Tarski.sign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if (0::'a) < x then 1 else if x = (0::'a) then 0 else - 1) =\n             - 1 \\<Longrightarrow>\n             P;\n     (if (0::'a) < x then 1 else if x = (0::'a) then 0 else - 1) =\n     0 \\<Longrightarrow>\n     P;\n     (if (0::'a) < x then 1 else if x = (0::'a) then 0 else - 1) =\n     1 \\<Longrightarrow>\n     P\\<rbrakk>\n    \\<Longrightarrow> P", "by argo"], ["", "lemma sign_times:\n  fixes x::\"'a::linordered_ring_strict\"\n  shows \"sign (x*y) = sign x * sign y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (x * y) = sign x * sign y", "unfolding Sturm_Tarski.sign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (0::'a) < x * y then 1 else if x * y = (0::'a) then 0 else - 1) =\n    (if (0::'a) < x then 1 else if x = (0::'a) then 0 else - 1) *\n    (if (0::'a) < y then 1 else if y = (0::'a) then 0 else - 1)", "by (auto simp add:zero_less_mult_iff)"], ["", "lemma sign_power:\n  fixes x::\"'a::linordered_idom\"\n  shows \"sign (x^n) = (if n=0 then 1 else if even n then \\<bar>sign x\\<bar> else sign x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (x ^ n) =\n    (if n = 0 then 1 else if even n then \\<bar>sign x\\<bar> else sign x)", "by (simp add: Sturm_Tarski.sign_def zero_less_power_eq)"], ["", "lemma sgn_sign_eq:\n  fixes x::\"'a::{linordered_idom}\"\n  shows \"sgn x = of_int (sign x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn x = of_int (sign x)", "unfolding sgn_if"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = (0::'a) then 0::'a\n     else if (0::'a) < x then 1::'a else - (1::'a)) =\n    of_int (sign x)", "by auto"], ["", "section \\<open>Variation and cross\\<close>"], ["", "definition variation :: \"real \\<Rightarrow>  real \\<Rightarrow> int\" where\n  \"variation x y=(if x*y\\<ge>0 then 0 else if x<y then 1 else -1)\""], ["", "definition cross :: \"real poly \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> int\" where\n  \"cross p a b=variation (poly p a) (poly p b)\""], ["", "lemma variation_0[simp]: \"variation 0 y=0\" \"variation x 0=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. variation 0 y = 0 &&& variation x 0 = 0", "unfolding variation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 \\<le> 0 * y then 0 else if 0 < y then 1 else - 1) = 0 &&&\n    (if 0 \\<le> x * 0 then 0 else if x < 0 then 1 else - 1) = 0", "by auto"], ["", "lemma variation_comm: \"variation x y= - variation y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. variation x y = - variation y x", "unfolding variation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 \\<le> x * y then 0 else if x < y then 1 else - 1) =\n    - (if 0 \\<le> y * x then 0 else if y < x then 1 else - 1)", "by (auto simp add: mult.commute)"], ["", "lemma cross_0[simp]: \"cross 0 a b=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross 0 a b = 0", "unfolding cross_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. variation (poly 0 a) (poly 0 b) = 0", "by auto"], ["", "lemma variation_cases:\n  \"\\<lbrakk>x>0;y>0\\<rbrakk>\\<Longrightarrow>variation x y = 0\" \n  \"\\<lbrakk>x>0;y<0\\<rbrakk>\\<Longrightarrow>variation x y = -1\"\n  \"\\<lbrakk>x<0;y>0\\<rbrakk>\\<Longrightarrow>variation x y = 1\"\n  \"\\<lbrakk>x<0;y<0\\<rbrakk>\\<Longrightarrow>variation x y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>0 < x; 0 < y\\<rbrakk>\n      \\<Longrightarrow> variation x y = 0) &&&\n     (\\<lbrakk>0 < x; y < 0\\<rbrakk>\n      \\<Longrightarrow> variation x y = - 1)) &&&\n    (\\<lbrakk>x < 0; 0 < y\\<rbrakk> \\<Longrightarrow> variation x y = 1) &&&\n    (\\<lbrakk>x < 0; y < 0\\<rbrakk> \\<Longrightarrow> variation x y = 0)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < x; 0 < y\\<rbrakk> \\<Longrightarrow> variation x y = 0\n 2. \\<lbrakk>0 < x; y < 0\\<rbrakk> \\<Longrightarrow> variation x y = - 1\n 3. \\<lbrakk>x < 0; 0 < y\\<rbrakk> \\<Longrightarrow> variation x y = 1\n 4. \\<lbrakk>x < 0; y < 0\\<rbrakk> \\<Longrightarrow> variation x y = 0", "show \"\\<lbrakk>x>0;y>0\\<rbrakk>\\<Longrightarrow>variation x y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; 0 < y\\<rbrakk> \\<Longrightarrow> variation x y = 0", "unfolding variation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; 0 < y\\<rbrakk>\n    \\<Longrightarrow> (if 0 \\<le> x * y then 0\n                       else if x < y then 1 else - 1) =\n                      0", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < x; 0 < y\\<rbrakk> \\<Longrightarrow> variation x y = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < x; y < 0\\<rbrakk> \\<Longrightarrow> variation x y = - 1\n 2. \\<lbrakk>x < 0; 0 < y\\<rbrakk> \\<Longrightarrow> variation x y = 1\n 3. \\<lbrakk>x < 0; y < 0\\<rbrakk> \\<Longrightarrow> variation x y = 0", "show \"\\<lbrakk>x>0;y<0\\<rbrakk>\\<Longrightarrow>variation x y = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; y < 0\\<rbrakk> \\<Longrightarrow> variation x y = - 1", "unfolding variation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; y < 0\\<rbrakk>\n    \\<Longrightarrow> (if 0 \\<le> x * y then 0\n                       else if x < y then 1 else - 1) =\n                      - 1", "using mult_pos_neg"], ["proof (prove)\nusing this:\n  \\<lbrakk>(0::?'a) < ?a; ?b < (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?a * ?b < (0::?'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; y < 0\\<rbrakk>\n    \\<Longrightarrow> (if 0 \\<le> x * y then 0\n                       else if x < y then 1 else - 1) =\n                      - 1", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>0 < x; y < 0\\<rbrakk> \\<Longrightarrow> variation x y = - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x < 0; 0 < y\\<rbrakk> \\<Longrightarrow> variation x y = 1\n 2. \\<lbrakk>x < 0; y < 0\\<rbrakk> \\<Longrightarrow> variation x y = 0", "show \"\\<lbrakk>x<0;y>0\\<rbrakk>\\<Longrightarrow>variation x y = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 0; 0 < y\\<rbrakk> \\<Longrightarrow> variation x y = 1", "unfolding variation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 0; 0 < y\\<rbrakk>\n    \\<Longrightarrow> (if 0 \\<le> x * y then 0\n                       else if x < y then 1 else - 1) =\n                      1", "using mult_neg_pos"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < (0::?'a); (0::?'a) < ?b\\<rbrakk>\n  \\<Longrightarrow> ?a * ?b < (0::?'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 0; 0 < y\\<rbrakk>\n    \\<Longrightarrow> (if 0 \\<le> x * y then 0\n                       else if x < y then 1 else - 1) =\n                      1", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>x < 0; 0 < y\\<rbrakk> \\<Longrightarrow> variation x y = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 0; y < 0\\<rbrakk> \\<Longrightarrow> variation x y = 0", "show \"\\<lbrakk>x<0;y<0\\<rbrakk>\\<Longrightarrow>variation x y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 0; y < 0\\<rbrakk> \\<Longrightarrow> variation x y = 0", "unfolding variation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 0; y < 0\\<rbrakk>\n    \\<Longrightarrow> (if 0 \\<le> x * y then 0\n                       else if x < y then 1 else - 1) =\n                      0", "using mult_neg_neg"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a < (0::?'a); ?b < (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) < ?a * ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < 0; y < 0\\<rbrakk>\n    \\<Longrightarrow> (if 0 \\<le> x * y then 0\n                       else if x < y then 1 else - 1) =\n                      0", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>x < 0; y < 0\\<rbrakk> \\<Longrightarrow> variation x y = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma variation_congr:\n  assumes \"sgn x=sgn x'\" \"sgn y=sgn y'\"\n  shows \"variation x y=variation x' y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. variation x y = variation x' y'", "using assms"], ["proof (prove)\nusing this:\n  sgn x = sgn x'\n  sgn y = sgn y'\n\ngoal (1 subgoal):\n 1. variation x y = variation x' y'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sgn x = sgn x'; sgn y = sgn y'\\<rbrakk>\n    \\<Longrightarrow> variation x y = variation x' y'", "have \" 0 \\<le> x * y =  (0\\<le> x' * y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> x * y) = (0 \\<le> x' * y')", "using assms"], ["proof (prove)\nusing this:\n  sgn x = sgn x'\n  sgn y = sgn y'\n\ngoal (1 subgoal):\n 1. (0 \\<le> x * y) = (0 \\<le> x' * y')", "by (metis Real_Vector_Spaces.sgn_mult zero_le_sgn_iff)"], ["proof (state)\nthis:\n  (0 \\<le> x * y) = (0 \\<le> x' * y')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sgn x = sgn x'; sgn y = sgn y'\\<rbrakk>\n    \\<Longrightarrow> variation x y = variation x' y'", "moreover"], ["proof (state)\nthis:\n  (0 \\<le> x * y) = (0 \\<le> x' * y')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sgn x = sgn x'; sgn y = sgn y'\\<rbrakk>\n    \\<Longrightarrow> variation x y = variation x' y'", "hence \"\\<not> 0\\<le>x * y \\<Longrightarrow> x < y = (x' < y')\""], ["proof (prove)\nusing this:\n  (0 \\<le> x * y) = (0 \\<le> x' * y')\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x * y \\<Longrightarrow> (x < y) = (x' < y')", "using assms"], ["proof (prove)\nusing this:\n  (0 \\<le> x * y) = (0 \\<le> x' * y')\n  sgn x = sgn x'\n  sgn y = sgn y'\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x * y \\<Longrightarrow> (x < y) = (x' < y')", "by (metis less_eq_real_def mult_nonneg_nonneg mult_nonpos_nonpos not_le order.strict_trans2 \n      zero_le_sgn_iff)"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> x * y \\<Longrightarrow> (x < y) = (x' < y')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sgn x = sgn x'; sgn y = sgn y'\\<rbrakk>\n    \\<Longrightarrow> variation x y = variation x' y'", "ultimately"], ["proof (chain)\npicking this:\n  (0 \\<le> x * y) = (0 \\<le> x' * y')\n  \\<not> 0 \\<le> x * y \\<Longrightarrow> (x < y) = (x' < y')", "show ?thesis"], ["proof (prove)\nusing this:\n  (0 \\<le> x * y) = (0 \\<le> x' * y')\n  \\<not> 0 \\<le> x * y \\<Longrightarrow> (x < y) = (x' < y')\n\ngoal (1 subgoal):\n 1. variation x y = variation x' y'", "unfolding variation_def"], ["proof (prove)\nusing this:\n  (0 \\<le> x * y) = (0 \\<le> x' * y')\n  \\<not> 0 \\<le> x * y \\<Longrightarrow> (x < y) = (x' < y')\n\ngoal (1 subgoal):\n 1. (if 0 \\<le> x * y then 0 else if x < y then 1 else - 1) =\n    (if 0 \\<le> x' * y' then 0 else if x' < y' then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  variation x y = variation x' y'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma variation_mult_pos: \n  assumes \"c>0\"  \n  shows \"variation (c*x) y =variation x y\" and \"variation x (c*y) =variation x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. variation (c * x) y = variation x y &&&\n    variation x (c * y) = variation x y", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. variation (c * x) y = variation x y\n 2. variation x (c * y) = variation x y", "have \"sgn (c*x) = sgn x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (c * x) = sgn x", "using \\<open>c>0\\<close>"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. sgn (c * x) = sgn x", "by (simp add: Real_Vector_Spaces.sgn_mult)"], ["proof (state)\nthis:\n  sgn (c * x) = sgn x\n\ngoal (2 subgoals):\n 1. variation (c * x) y = variation x y\n 2. variation x (c * y) = variation x y", "thus \"variation (c*x) y =variation x y\""], ["proof (prove)\nusing this:\n  sgn (c * x) = sgn x\n\ngoal (1 subgoal):\n 1. variation (c * x) y = variation x y", "using variation_congr"], ["proof (prove)\nusing this:\n  sgn (c * x) = sgn x\n  \\<lbrakk>sgn ?x = sgn ?x'; sgn ?y = sgn ?y'\\<rbrakk>\n  \\<Longrightarrow> variation ?x ?y = variation ?x' ?y'\n\ngoal (1 subgoal):\n 1. variation (c * x) y = variation x y", "by blast"], ["proof (state)\nthis:\n  variation (c * x) y = variation x y\n\ngoal (1 subgoal):\n 1. variation x (c * y) = variation x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. variation x (c * y) = variation x y", "have \"sgn (c*y) = sgn y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (c * y) = sgn y", "using \\<open>c>0\\<close>"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. sgn (c * y) = sgn y", "by (simp add: Real_Vector_Spaces.sgn_mult)"], ["proof (state)\nthis:\n  sgn (c * y) = sgn y\n\ngoal (1 subgoal):\n 1. variation x (c * y) = variation x y", "thus \"variation x (c*y) =variation x y\""], ["proof (prove)\nusing this:\n  sgn (c * y) = sgn y\n\ngoal (1 subgoal):\n 1. variation x (c * y) = variation x y", "using variation_congr"], ["proof (prove)\nusing this:\n  sgn (c * y) = sgn y\n  \\<lbrakk>sgn ?x = sgn ?x'; sgn ?y = sgn ?y'\\<rbrakk>\n  \\<Longrightarrow> variation ?x ?y = variation ?x' ?y'\n\ngoal (1 subgoal):\n 1. variation x (c * y) = variation x y", "by blast"], ["proof (state)\nthis:\n  variation x (c * y) = variation x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma variation_mult_neg_1: \n  assumes \"c<0\"  \n  shows \"variation (c*x) y =variation x y + (if y=0 then 0 else sign x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. variation (c * x) y = variation x y + (if y = 0 then 0 else sign x)", "apply (cases x  rule:linorder_cases[of 0] )"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < x \\<Longrightarrow>\n    variation (c * x) y = variation x y + (if y = 0 then 0 else sign x)\n 2. 0 = x \\<Longrightarrow>\n    variation (c * x) y = variation x y + (if y = 0 then 0 else sign x)\n 3. x < 0 \\<Longrightarrow>\n    variation (c * x) y = variation x y + (if y = 0 then 0 else sign x)", "apply (cases y  rule:linorder_cases[of 0], auto simp add: \n    variation_cases mult_neg_pos[OF \\<open>c<0\\<close>,of x]  mult_neg_neg[OF \\<open>c<0\\<close>,of x])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma variation_mult_neg_2: \n  assumes \"c<0\"  \n  shows \"variation x (c*y) = variation x y + (if x=0 then 0 else - sign y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. variation x (c * y) = variation x y + (if x = 0 then 0 else - sign y)", "unfolding variation_comm[of x \"c*y\", unfolded variation_mult_neg_1[OF \\<open>c<0\\<close>, of y x] ]"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (variation y x + (if x = 0 then 0 else sign y)) =\n    variation x y + (if x = 0 then 0 else - sign y)", "by (auto,subst variation_comm,simp)"], ["", "lemma cross_no_root:\n  assumes \"a<b\" and no_root:\"\\<forall>x. a<x\\<and>x<b \\<longrightarrow> poly p x\\<noteq>0\"\n  shows \"cross p a b=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross p a b = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cross p a b = 0", "have \"\\<lbrakk>poly p a>0;poly p b<0\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < poly p a; poly p b < 0\\<rbrakk> \\<Longrightarrow> False", "using poly_IVT_neg[OF \\<open>a<b\\<close>] no_root"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < poly ?p a; poly ?p b < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly ?p x = 0\n  \\<forall>x. a < x \\<and> x < b \\<longrightarrow> poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < poly p a; poly p b < 0\\<rbrakk> \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < poly p a; poly p b < 0\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. cross p a b = 0", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < poly p a; poly p b < 0\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. cross p a b = 0", "have \"\\<lbrakk>poly p a<0;poly p b>0\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly p a < 0; 0 < poly p b\\<rbrakk> \\<Longrightarrow> False", "using poly_IVT_pos[OF \\<open>a<b\\<close>] no_root"], ["proof (prove)\nusing this:\n  \\<lbrakk>poly ?p a < 0; 0 < poly ?p b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < b \\<and> poly ?p x = 0\n  \\<forall>x. a < x \\<and> x < b \\<longrightarrow> poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>poly p a < 0; 0 < poly p b\\<rbrakk> \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>poly p a < 0; 0 < poly p b\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. cross p a b = 0", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < poly p a; poly p b < 0\\<rbrakk> \\<Longrightarrow> False\n  \\<lbrakk>poly p a < 0; 0 < poly p b\\<rbrakk> \\<Longrightarrow> False", "have \"0 \\<le> poly p a * poly p b\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < poly p a; poly p b < 0\\<rbrakk> \\<Longrightarrow> False\n  \\<lbrakk>poly p a < 0; 0 < poly p b\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. 0 \\<le> poly p a * poly p b", "by (metis less_eq_real_def linorder_neqE_linordered_idom mult_less_0_iff)"], ["proof (state)\nthis:\n  0 \\<le> poly p a * poly p b\n\ngoal (1 subgoal):\n 1. cross p a b = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> poly p a * poly p b\n\ngoal (1 subgoal):\n 1. cross p a b = 0", "unfolding cross_def variation_def"], ["proof (prove)\nusing this:\n  0 \\<le> poly p a * poly p b\n\ngoal (1 subgoal):\n 1. (if 0 \\<le> poly p a * poly p b then 0\n     else if poly p a < poly p b then 1 else - 1) =\n    0", "by simp"], ["proof (state)\nthis:\n  cross p a b = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Tarski query\\<close>"], ["", "definition taq :: \"'a::linordered_idom set \\<Rightarrow> 'a poly \\<Rightarrow> int\" where\n  \"taq s q \\<equiv> \\<Sum>x\\<in>s. sign (poly q x)\""], ["", "section \\<open>Sign at the right\\<close>"], ["", "definition sign_r_pos :: \"real poly \\<Rightarrow> real \\<Rightarrow> bool \" \n  where\n  \"sign_r_pos p x\\<equiv> (eventually (\\<lambda>x. poly p x>0) (at_right x))\""], ["", "lemma sign_r_pos_rec:\n  fixes p:: \"real poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"sign_r_pos p x= (if poly p x=0 then sign_r_pos (pderiv p) x else poly p x>0 )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "proof (cases \"poly p x=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly p x = 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)\n 2. poly p x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "case True"], ["proof (state)\nthis:\n  poly p x = 0\n\ngoal (2 subgoals):\n 1. poly p x = 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)\n 2. poly p x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "have \"sign_r_pos (pderiv p) x \\<Longrightarrow> sign_r_pos p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p) x \\<Longrightarrow> sign_r_pos p x", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_r_pos (pderiv p) x; \\<not> sign_r_pos p x\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"sign_r_pos (pderiv p) x\" \"\\<not> sign_r_pos p x\""], ["proof (state)\nthis:\n  sign_r_pos (pderiv p) x\n  \\<not> sign_r_pos p x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_r_pos (pderiv p) x; \\<not> sign_r_pos p x\\<rbrakk>\n    \\<Longrightarrow> False", "obtain b where \"b>x\" and b:\"\\<forall>z. x < z \\<and> z < b \\<longrightarrow> 0 < poly (pderiv p) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>x < b;\n         \\<forall>z.\n            x < z \\<and> z < b \\<longrightarrow>\n            0 < poly (pderiv p) z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>sign_r_pos (pderiv p) x\\<close>"], ["proof (prove)\nusing this:\n  sign_r_pos (pderiv p) x\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>x < b;\n         \\<forall>z.\n            x < z \\<and> z < b \\<longrightarrow>\n            0 < poly (pderiv p) z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding sign_r_pos_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly (pderiv p) y\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>x < b;\n         \\<forall>z.\n            x < z \\<and> z < b \\<longrightarrow>\n            0 < poly (pderiv p) z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x < b\n  \\<forall>z. x < z \\<and> z < b \\<longrightarrow> 0 < poly (pderiv p) z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_r_pos (pderiv p) x; \\<not> sign_r_pos p x\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<forall>b>x. \\<exists>z>x. z < b \\<and> \\<not> 0 < poly p z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b>x. \\<exists>z>x. z < b \\<and> \\<not> 0 < poly p z", "using \\<open>\\<not> sign_r_pos p x\\<close>"], ["proof (prove)\nusing this:\n  \\<not> sign_r_pos p x\n\ngoal (1 subgoal):\n 1. \\<forall>b>x. \\<exists>z>x. z < b \\<and> \\<not> 0 < poly p z", "unfolding sign_r_pos_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly p y)\n\ngoal (1 subgoal):\n 1. \\<forall>b>x. \\<exists>z>x. z < b \\<and> \\<not> 0 < poly p z", "by auto"], ["proof (state)\nthis:\n  \\<forall>b>x. \\<exists>z>x. z < b \\<and> \\<not> 0 < poly p z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_r_pos (pderiv p) x; \\<not> sign_r_pos p x\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>b>x. \\<exists>z>x. z < b \\<and> \\<not> 0 < poly p z", "obtain z where \"z>x\" and \"z<b\" and \"poly p z\\<le>0\""], ["proof (prove)\nusing this:\n  \\<forall>b>x. \\<exists>z>x. z < b \\<and> \\<not> 0 < poly p z\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>x < z; z < b; poly p z \\<le> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>b>x\\<close> b"], ["proof (prove)\nusing this:\n  \\<forall>b>x. \\<exists>z>x. z < b \\<and> \\<not> 0 < poly p z\n  x < b\n  \\<forall>z. x < z \\<and> z < b \\<longrightarrow> 0 < poly (pderiv p) z\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>x < z; z < b; poly p z \\<le> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x < z\n  z < b\n  poly p z \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_r_pos (pderiv p) x; \\<not> sign_r_pos p x\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"\\<exists>z'>x. z' < z \\<and> poly p z = (z - x) * poly (pderiv p) z'\""], ["proof (prove)\nusing this:\n  x < z\n  z < b\n  poly p z \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<exists>z'>x. z' < z \\<and> poly p z = (z - x) * poly (pderiv p) z'", "using poly_MVT[OF \\<open>z>x\\<close>] True"], ["proof (prove)\nusing this:\n  x < z\n  z < b\n  poly p z \\<le> 0\n  \\<exists>xa>x.\n     xa < z \\<and> poly ?p z - poly ?p x = (z - x) * poly (pderiv ?p) xa\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>z'>x. z' < z \\<and> poly p z = (z - x) * poly (pderiv p) z'", "by (metis diff_0_right)"], ["proof (state)\nthis:\n  \\<exists>z'>x. z' < z \\<and> poly p z = (z - x) * poly (pderiv p) z'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_r_pos (pderiv p) x; \\<not> sign_r_pos p x\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"\\<exists>z'>x. z' < z \\<and> poly (pderiv p) z' \\<le>0\""], ["proof (prove)\nusing this:\n  \\<exists>z'>x. z' < z \\<and> poly p z = (z - x) * poly (pderiv p) z'\n\ngoal (1 subgoal):\n 1. \\<exists>z'>x. z' < z \\<and> poly (pderiv p) z' \\<le> 0", "using \\<open>poly p z\\<le>0\\<close>\\<open>z>x\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>z'>x. z' < z \\<and> poly p z = (z - x) * poly (pderiv p) z'\n  poly p z \\<le> 0\n  x < z\n\ngoal (1 subgoal):\n 1. \\<exists>z'>x. z' < z \\<and> poly (pderiv p) z' \\<le> 0", "by (metis leD le_iff_diff_le_0 mult_le_0_iff)"], ["proof (state)\nthis:\n  \\<exists>z'>x. z' < z \\<and> poly (pderiv p) z' \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_r_pos (pderiv p) x; \\<not> sign_r_pos p x\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>z'>x. z' < z \\<and> poly (pderiv p) z' \\<le> 0\n\ngoal (1 subgoal):\n 1. False", "using b"], ["proof (prove)\nusing this:\n  \\<exists>z'>x. z' < z \\<and> poly (pderiv p) z' \\<le> 0\n  \\<forall>z. x < z \\<and> z < b \\<longrightarrow> 0 < poly (pderiv p) z\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>z < b\\<close> dual_order.strict_trans not_le)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign_r_pos (pderiv p) x \\<Longrightarrow> sign_r_pos p x\n\ngoal (2 subgoals):\n 1. poly p x = 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)\n 2. poly p x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "moreover"], ["proof (state)\nthis:\n  sign_r_pos (pderiv p) x \\<Longrightarrow> sign_r_pos p x\n\ngoal (2 subgoals):\n 1. poly p x = 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)\n 2. poly p x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "have \"sign_r_pos p x \\<Longrightarrow> sign_r_pos (pderiv p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos p x \\<Longrightarrow> sign_r_pos (pderiv p) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_r_pos p x \\<Longrightarrow> sign_r_pos (pderiv p) x", "assume \"sign_r_pos p x\""], ["proof (state)\nthis:\n  sign_r_pos p x\n\ngoal (1 subgoal):\n 1. sign_r_pos p x \\<Longrightarrow> sign_r_pos (pderiv p) x", "have \"pderiv p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0", "using \\<open>poly p x=0\\<close> \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly p x = 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0", "by (metis monoid_add_class.add.right_neutral monom_0 monom_eq_0 mult_zero_right \n          pderiv_iszero poly_0 poly_pCons)"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_r_pos p x \\<Longrightarrow> sign_r_pos (pderiv p) x", "obtain ub where \"ub>x\" and ub: \"(\\<forall>z. x<z\\<and>z<ub\\<longrightarrow>poly (pderiv p) z>0) \n          \\<or> (\\<forall>z. x<z\\<and>z<ub\\<longrightarrow>poly (pderiv p) z<0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>x < ub;\n         (\\<forall>z.\n             x < z \\<and> z < ub \\<longrightarrow>\n             0 < poly (pderiv p) z) \\<or>\n         (\\<forall>z.\n             x < z \\<and> z < ub \\<longrightarrow>\n             poly (pderiv p) z < 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using next_non_root_interval[OF \\<open>pderiv p\\<noteq>0\\<close>, of x,unfolded not_eq_pos_or_neg_iff_1]"], ["proof (prove)\nusing this:\n  (\\<And>ub.\n      \\<lbrakk>x < ub;\n       (\\<forall>z.\n           x < z \\<and> z \\<le> ub \\<longrightarrow>\n           0 < poly (pderiv p) z) \\<or>\n       (\\<forall>z.\n           x < z \\<and> z \\<le> ub \\<longrightarrow>\n           poly (pderiv p) z < 0)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>x < ub;\n         (\\<forall>z.\n             x < z \\<and> z < ub \\<longrightarrow>\n             0 < poly (pderiv p) z) \\<or>\n         (\\<forall>z.\n             x < z \\<and> z < ub \\<longrightarrow>\n             poly (pderiv p) z < 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis order.strict_implies_order)"], ["proof (state)\nthis:\n  x < ub\n  (\\<forall>z.\n      x < z \\<and> z < ub \\<longrightarrow> 0 < poly (pderiv p) z) \\<or>\n  (\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly (pderiv p) z < 0)\n\ngoal (1 subgoal):\n 1. sign_r_pos p x \\<Longrightarrow> sign_r_pos (pderiv p) x", "have \"\\<forall>z. x<z\\<and>z<ub\\<longrightarrow>poly (pderiv p) z<0 \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < ub \\<longrightarrow>\n       poly (pderiv p) z < 0 \\<Longrightarrow>\n    False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < ub \\<longrightarrow>\n       poly (pderiv p) z < 0 \\<Longrightarrow>\n    False", "assume assm:\"\\<forall>z. x<z\\<and>z<ub\\<longrightarrow>poly (pderiv p) z<0\""], ["proof (state)\nthis:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly (pderiv p) z < 0\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < ub \\<longrightarrow>\n       poly (pderiv p) z < 0 \\<Longrightarrow>\n    False", "obtain ub' where \"ub'>x\" and ub':\"\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly p z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub'.\n        \\<lbrakk>x < ub';\n         \\<forall>z.\n            x < z \\<and> z < ub' \\<longrightarrow> 0 < poly p z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>sign_r_pos p x\\<close>"], ["proof (prove)\nusing this:\n  sign_r_pos p x\n\ngoal (1 subgoal):\n 1. (\\<And>ub'.\n        \\<lbrakk>x < ub';\n         \\<forall>z.\n            x < z \\<and> z < ub' \\<longrightarrow> 0 < poly p z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding sign_r_pos_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly p y\n\ngoal (1 subgoal):\n 1. (\\<And>ub'.\n        \\<lbrakk>x < ub';\n         \\<forall>z.\n            x < z \\<and> z < ub' \\<longrightarrow> 0 < poly p z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x < ub'\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly p z\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < ub \\<longrightarrow>\n       poly (pderiv p) z < 0 \\<Longrightarrow>\n    False", "obtain z' where \"x<z'\" and \"z' < (x+(min ub' ub))/2\"\n          and z':\"poly p ((x+min ub' ub)/2) = ((x+min ub' ub)/2 - x) * poly (pderiv p) z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>x < z'; z' < (x + min ub' ub) / 2;\n         poly p ((x + min ub' ub) / 2) =\n         ((x + min ub' ub) / 2 - x) * poly (pderiv p) z'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using poly_MVT[of x \"(x+min ub' ub)/2\" p] \\<open>ub'>x\\<close> \\<open>ub>x\\<close> True"], ["proof (prove)\nusing this:\n  x < (x + min ub' ub) / 2 \\<Longrightarrow>\n  \\<exists>xa>x.\n     xa < (x + min ub' ub) / 2 \\<and>\n     poly p ((x + min ub' ub) / 2) - poly p x =\n     ((x + min ub' ub) / 2 - x) * poly (pderiv p) xa\n  x < ub'\n  x < ub\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>x < z'; z' < (x + min ub' ub) / 2;\n         poly p ((x + min ub' ub) / 2) =\n         ((x + min ub' ub) / 2 - x) * poly (pderiv p) z'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x < z'\n  z' < (x + min ub' ub) / 2\n  poly p ((x + min ub' ub) / 2) =\n  ((x + min ub' ub) / 2 - x) * poly (pderiv p) z'\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < ub \\<longrightarrow>\n       poly (pderiv p) z < 0 \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  x < z'\n  z' < (x + min ub' ub) / 2\n  poly p ((x + min ub' ub) / 2) =\n  ((x + min ub' ub) / 2 - x) * poly (pderiv p) z'\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < ub \\<longrightarrow>\n       poly (pderiv p) z < 0 \\<Longrightarrow>\n    False", "have \"0 < poly p ((x+min ub' ub)/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p ((x + min ub' ub) / 2)", "using ub'[THEN HOL.spec,of \"(x+(min ub' ub))/2\"] \\<open>z' < (x+min ub' ub)/2\\<close> \\<open>x<z'\\<close>"], ["proof (prove)\nusing this:\n  x < (x + min ub' ub) / 2 \\<and>\n  (x + min ub' ub) / 2 < ub' \\<longrightarrow>\n  0 < poly p ((x + min ub' ub) / 2)\n  z' < (x + min ub' ub) / 2\n  x < z'\n\ngoal (1 subgoal):\n 1. 0 < poly p ((x + min ub' ub) / 2)", "by auto"], ["proof (state)\nthis:\n  0 < poly p ((x + min ub' ub) / 2)\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < ub \\<longrightarrow>\n       poly (pderiv p) z < 0 \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  0 < poly p ((x + min ub' ub) / 2)\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < ub \\<longrightarrow>\n       poly (pderiv p) z < 0 \\<Longrightarrow>\n    False", "have \"(x+min ub' ub)/2 - x>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (x + min ub' ub) / 2 - x", "using \\<open>ub'>x\\<close> \\<open>ub>x\\<close>"], ["proof (prove)\nusing this:\n  x < ub'\n  x < ub\n\ngoal (1 subgoal):\n 1. 0 < (x + min ub' ub) / 2 - x", "by auto"], ["proof (state)\nthis:\n  0 < (x + min ub' ub) / 2 - x\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < ub \\<longrightarrow>\n       poly (pderiv p) z < 0 \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  x < z'\n  z' < (x + min ub' ub) / 2\n  poly p ((x + min ub' ub) / 2) =\n  ((x + min ub' ub) / 2 - x) * poly (pderiv p) z'\n  0 < poly p ((x + min ub' ub) / 2)\n  0 < (x + min ub' ub) / 2 - x", "have \"poly (pderiv p) z'>0\""], ["proof (prove)\nusing this:\n  x < z'\n  z' < (x + min ub' ub) / 2\n  poly p ((x + min ub' ub) / 2) =\n  ((x + min ub' ub) / 2 - x) * poly (pderiv p) z'\n  0 < poly p ((x + min ub' ub) / 2)\n  0 < (x + min ub' ub) / 2 - x\n\ngoal (1 subgoal):\n 1. 0 < poly (pderiv p) z'", "by (metis zero_less_mult_pos)"], ["proof (state)\nthis:\n  0 < poly (pderiv p) z'\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < ub \\<longrightarrow>\n       poly (pderiv p) z < 0 \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  0 < poly (pderiv p) z'\n\ngoal (1 subgoal):\n 1. False", "using assm[THEN spec,of z'] \\<open>x<z'\\<close> \\<open>z' < (x+(min ub' ub))/2\\<close>"], ["proof (prove)\nusing this:\n  0 < poly (pderiv p) z'\n  x < z' \\<and> z' < ub \\<longrightarrow> poly (pderiv p) z' < 0\n  x < z'\n  z' < (x + min ub' ub) / 2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>z.\n     x < z \\<and> z < ub \\<longrightarrow>\n     poly (pderiv p) z < 0 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. sign_r_pos p x \\<Longrightarrow> sign_r_pos (pderiv p) x", "hence \"\\<forall>z. x<z\\<and>z<ub\\<longrightarrow>poly (pderiv p) z>0\""], ["proof (prove)\nusing this:\n  \\<forall>z.\n     x < z \\<and> z < ub \\<longrightarrow>\n     poly (pderiv p) z < 0 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly (pderiv p) z", "using ub"], ["proof (prove)\nusing this:\n  \\<forall>z.\n     x < z \\<and> z < ub \\<longrightarrow>\n     poly (pderiv p) z < 0 \\<Longrightarrow>\n  False\n  (\\<forall>z.\n      x < z \\<and> z < ub \\<longrightarrow> 0 < poly (pderiv p) z) \\<or>\n  (\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly (pderiv p) z < 0)\n\ngoal (1 subgoal):\n 1. \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly (pderiv p) z", "by auto"], ["proof (state)\nthis:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly (pderiv p) z\n\ngoal (1 subgoal):\n 1. sign_r_pos p x \\<Longrightarrow> sign_r_pos (pderiv p) x", "thus \"sign_r_pos (pderiv p) x\""], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly (pderiv p) z\n\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p) x", "unfolding sign_r_pos_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly (pderiv p) z\n\ngoal (1 subgoal):\n 1. \\<exists>b>x.\n       \\<forall>y>x. y < b \\<longrightarrow> 0 < poly (pderiv p) y", "using \\<open>ub>x\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly (pderiv p) z\n  x < ub\n\ngoal (1 subgoal):\n 1. \\<exists>b>x.\n       \\<forall>y>x. y < b \\<longrightarrow> 0 < poly (pderiv p) y", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (pderiv p) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign_r_pos p x \\<Longrightarrow> sign_r_pos (pderiv p) x\n\ngoal (2 subgoals):\n 1. poly p x = 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)\n 2. poly p x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "ultimately"], ["proof (chain)\npicking this:\n  sign_r_pos (pderiv p) x \\<Longrightarrow> sign_r_pos p x\n  sign_r_pos p x \\<Longrightarrow> sign_r_pos (pderiv p) x", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos (pderiv p) x \\<Longrightarrow> sign_r_pos p x\n  sign_r_pos p x \\<Longrightarrow> sign_r_pos (pderiv p) x\n\ngoal (1 subgoal):\n 1. sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "using True"], ["proof (prove)\nusing this:\n  sign_r_pos (pderiv p) x \\<Longrightarrow> sign_r_pos p x\n  sign_r_pos p x \\<Longrightarrow> sign_r_pos (pderiv p) x\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "by auto"], ["proof (state)\nthis:\n  sign_r_pos p x =\n  (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "case False"], ["proof (state)\nthis:\n  poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "have \"sign_r_pos p x \\<Longrightarrow> poly p x>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos p x \\<Longrightarrow> 0 < poly p x", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_r_pos p x; \\<not> 0 < poly p x\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"sign_r_pos p x\" \"\\<not> 0 < poly p x\""], ["proof (state)\nthis:\n  sign_r_pos p x\n  \\<not> 0 < poly p x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_r_pos p x; \\<not> 0 < poly p x\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  sign_r_pos p x\n  \\<not> 0 < poly p x", "obtain  ub where \"ub>x\" and ub: \"\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z\""], ["proof (prove)\nusing this:\n  sign_r_pos p x\n  \\<not> 0 < poly p x\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>x < ub;\n         \\<forall>z.\n            x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding sign_r_pos_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly p y\n  \\<not> 0 < poly p x\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>x < ub;\n         \\<forall>z.\n            x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x < ub\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_r_pos p x; \\<not> 0 < poly p x\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"poly p ((ub+x)/2) > 0\""], ["proof (prove)\nusing this:\n  x < ub\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z\n\ngoal (1 subgoal):\n 1. 0 < poly p ((ub + x) / 2)", "by auto"], ["proof (state)\nthis:\n  0 < poly p ((ub + x) / 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_r_pos p x; \\<not> 0 < poly p x\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  0 < poly p ((ub + x) / 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_r_pos p x; \\<not> 0 < poly p x\\<rbrakk>\n    \\<Longrightarrow> False", "have \"poly p x<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x < 0", "using \\<open>\\<not> 0 < poly p x\\<close> False"], ["proof (prove)\nusing this:\n  \\<not> 0 < poly p x\n  poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p x < 0", "by auto"], ["proof (state)\nthis:\n  poly p x < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_r_pos p x; \\<not> 0 < poly p x\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  0 < poly p ((ub + x) / 2)\n  poly p x < 0", "have \"\\<exists>z>x. z < (ub + x) / 2 \\<and> poly p z = 0\""], ["proof (prove)\nusing this:\n  0 < poly p ((ub + x) / 2)\n  poly p x < 0\n\ngoal (1 subgoal):\n 1. \\<exists>z>x. z < (ub + x) / 2 \\<and> poly p z = 0", "using poly_IVT_pos[of x \"((ub + x) / 2)\" p] \\<open>ub>x\\<close>"], ["proof (prove)\nusing this:\n  0 < poly p ((ub + x) / 2)\n  poly p x < 0\n  \\<lbrakk>x < (ub + x) / 2; poly p x < 0;\n   0 < poly p ((ub + x) / 2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xa>x. xa < (ub + x) / 2 \\<and> poly p xa = 0\n  x < ub\n\ngoal (1 subgoal):\n 1. \\<exists>z>x. z < (ub + x) / 2 \\<and> poly p z = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>z>x. z < (ub + x) / 2 \\<and> poly p z = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign_r_pos p x; \\<not> 0 < poly p x\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>z>x. z < (ub + x) / 2 \\<and> poly p z = 0\n\ngoal (1 subgoal):\n 1. False", "using ub"], ["proof (prove)\nusing this:\n  \\<exists>z>x. z < (ub + x) / 2 \\<and> poly p z = 0\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign_r_pos p x \\<Longrightarrow> 0 < poly p x\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "moreover"], ["proof (state)\nthis:\n  sign_r_pos p x \\<Longrightarrow> 0 < poly p x\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "have \"poly p x>0 \\<Longrightarrow> sign_r_pos p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p x \\<Longrightarrow> sign_r_pos p x", "unfolding sign_r_pos_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p x \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_right x. 0 < poly p x", "using order_tendstoD(1)[OF poly_tendsto(1),of 0 p x] eventually_at_split"], ["proof (prove)\nusing this:\n  0 < poly p x \\<Longrightarrow> \\<forall>\\<^sub>F x in at x. 0 < poly p x\n  eventually ?P (at ?x) =\n  (eventually ?P (at_left ?x) \\<and> eventually ?P (at_right ?x))\n\ngoal (1 subgoal):\n 1. 0 < poly p x \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_right x. 0 < poly p x", "by auto"], ["proof (state)\nthis:\n  0 < poly p x \\<Longrightarrow> sign_r_pos p x\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "ultimately"], ["proof (chain)\npicking this:\n  sign_r_pos p x \\<Longrightarrow> 0 < poly p x\n  0 < poly p x \\<Longrightarrow> sign_r_pos p x", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos p x \\<Longrightarrow> 0 < poly p x\n  0 < poly p x \\<Longrightarrow> sign_r_pos p x\n\ngoal (1 subgoal):\n 1. sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "using False"], ["proof (prove)\nusing this:\n  sign_r_pos p x \\<Longrightarrow> 0 < poly p x\n  0 < poly p x \\<Longrightarrow> sign_r_pos p x\n  poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_r_pos p x =\n    (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)", "by auto"], ["proof (state)\nthis:\n  sign_r_pos p x =\n  (if poly p x = 0 then sign_r_pos (pderiv p) x else 0 < poly p x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_r_pos_0[simp]:\"\\<not> sign_r_pos 0 (x::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sign_r_pos 0 x", "using eventually_False[of \"at_right x\"]"], ["proof (prove)\nusing this:\n  (\\<forall>\\<^sub>F x in at_right x. False) = (at_right x = bot)\n\ngoal (1 subgoal):\n 1. \\<not> sign_r_pos 0 x", "unfolding sign_r_pos_def"], ["proof (prove)\nusing this:\n  (\\<forall>\\<^sub>F x in at_right x. False) = (at_right x = bot)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>\\<^sub>F x in at_right x. 0 < poly 0 x)", "by auto"], ["", "lemma sign_r_pos_minus:\n  fixes p:: \"real poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"sign_r_pos p x = (\\<not> sign_r_pos (-p) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos p x = (\\<not> sign_r_pos (- p) x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_r_pos p x = (\\<not> sign_r_pos (- p) x)", "have \"sign_r_pos p x \\<or> sign_r_pos (-p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos p x \\<or> sign_r_pos (- p) x", "unfolding sign_r_pos_def eventually_at_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly p y) \\<or>\n    (\\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly (- p) y)", "using next_non_root_interval[OF \\<open>p\\<noteq>0\\<close>,unfolded not_eq_pos_or_neg_iff_1]"], ["proof (prove)\nusing this:\n  (\\<And>ub.\n      \\<lbrakk>?lb < ub;\n       (\\<forall>z.\n           ?lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n       (\\<forall>z.\n           ?lb < z \\<and> z \\<le> ub \\<longrightarrow>\n           poly p z < 0)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly p y) \\<or>\n    (\\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly (- p) y)", "by (metis (erased, hide_lams) le_less minus_zero neg_less_iff_less poly_minus)"], ["proof (state)\nthis:\n  sign_r_pos p x \\<or> sign_r_pos (- p) x\n\ngoal (1 subgoal):\n 1. sign_r_pos p x = (\\<not> sign_r_pos (- p) x)", "moreover"], ["proof (state)\nthis:\n  sign_r_pos p x \\<or> sign_r_pos (- p) x\n\ngoal (1 subgoal):\n 1. sign_r_pos p x = (\\<not> sign_r_pos (- p) x)", "have \"sign_r_pos p x \\<Longrightarrow> \\<not> sign_r_pos (-p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos p x \\<Longrightarrow> \\<not> sign_r_pos (- p) x", "unfolding sign_r_pos_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right x. 0 < poly p x \\<Longrightarrow>\n    \\<not> (\\<forall>\\<^sub>F x in at_right x. 0 < poly (- p) x)", "using eventually_neg[OF trivial_limit_at_right_real, of \"\\<lambda>x. poly p x > 0\" x] poly_minus"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly p x \\<Longrightarrow>\n  \\<not> (\\<forall>\\<^sub>F x in at_right x. \\<not> 0 < poly p x)\n  poly (- ?p) ?x = - poly ?p ?x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right x. 0 < poly p x \\<Longrightarrow>\n    \\<not> (\\<forall>\\<^sub>F x in at_right x. 0 < poly (- p) x)", "by (metis (lifting) eventually_mono less_asym neg_less_0_iff_less)"], ["proof (state)\nthis:\n  sign_r_pos p x \\<Longrightarrow> \\<not> sign_r_pos (- p) x\n\ngoal (1 subgoal):\n 1. sign_r_pos p x = (\\<not> sign_r_pos (- p) x)", "ultimately"], ["proof (chain)\npicking this:\n  sign_r_pos p x \\<or> sign_r_pos (- p) x\n  sign_r_pos p x \\<Longrightarrow> \\<not> sign_r_pos (- p) x", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos p x \\<or> sign_r_pos (- p) x\n  sign_r_pos p x \\<Longrightarrow> \\<not> sign_r_pos (- p) x\n\ngoal (1 subgoal):\n 1. sign_r_pos p x = (\\<not> sign_r_pos (- p) x)", "by auto"], ["proof (state)\nthis:\n  sign_r_pos p x = (\\<not> sign_r_pos (- p) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_r_pos_smult:\n  fixes p :: \"real poly\"\n  assumes \"c\\<noteq>0\" \"p\\<noteq>0\"\n  shows \"sign_r_pos (smult c p) x= (if c>0 then sign_r_pos p x else \\<not> sign_r_pos p x)\"\n  (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)", "proof (cases \"c>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow>\n    sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)\n 2. \\<not> 0 < c \\<Longrightarrow>\n    sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)", "assume \"c>0\""], ["proof (state)\nthis:\n  0 < c\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow>\n    sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)\n 2. \\<not> 0 < c \\<Longrightarrow>\n    sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)", "hence \"\\<forall>x. (0 < poly (smult c p) x) = (0 < poly p x)\""], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. \\<forall>x. (0 < poly (smult c p) x) = (0 < poly p x)", "by (subst poly_smult,metis mult_pos_pos zero_less_mult_pos)"], ["proof (state)\nthis:\n  \\<forall>x. (0 < poly (smult c p) x) = (0 < poly p x)\n\ngoal (2 subgoals):\n 1. 0 < c \\<Longrightarrow>\n    sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)\n 2. \\<not> 0 < c \\<Longrightarrow>\n    sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. (0 < poly (smult c p) x) = (0 < poly p x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)", "unfolding sign_r_pos_def"], ["proof (prove)\nusing this:\n  \\<forall>x. (0 < poly (smult c p) x) = (0 < poly p x)\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in at_right x. 0 < poly (smult c p) x) =\n    (if 0 < c then \\<forall>\\<^sub>F x in at_right x. 0 < poly p x\n     else \\<not> (\\<forall>\\<^sub>F x in at_right x. 0 < poly p x))", "using \\<open>c>0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x. (0 < poly (smult c p) x) = (0 < poly p x)\n  0 < c\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in at_right x. 0 < poly (smult c p) x) =\n    (if 0 < c then \\<forall>\\<^sub>F x in at_right x. 0 < poly p x\n     else \\<not> (\\<forall>\\<^sub>F x in at_right x. 0 < poly p x))", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (smult c p) x =\n  (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < c \\<Longrightarrow>\n    sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < c \\<Longrightarrow>\n    sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)", "assume \"\\<not>(c>0)\""], ["proof (state)\nthis:\n  \\<not> 0 < c\n\ngoal (1 subgoal):\n 1. \\<not> 0 < c \\<Longrightarrow>\n    sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)", "hence \"\\<forall>x. (0 < poly (smult c p) x) = (0 < poly (-p) x)\""], ["proof (prove)\nusing this:\n  \\<not> 0 < c\n\ngoal (1 subgoal):\n 1. \\<forall>x. (0 < poly (smult c p) x) = (0 < poly (- p) x)", "by (subst poly_smult, metis assms(1) linorder_neqE_linordered_idom mult_neg_neg mult_zero_right \n      neg_0_less_iff_less poly_minus zero_less_mult_pos2)"], ["proof (state)\nthis:\n  \\<forall>x. (0 < poly (smult c p) x) = (0 < poly (- p) x)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < c \\<Longrightarrow>\n    sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)", "hence \"sign_r_pos (smult c p) x=sign_r_pos (-p) x\""], ["proof (prove)\nusing this:\n  \\<forall>x. (0 < poly (smult c p) x) = (0 < poly (- p) x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (smult c p) x = sign_r_pos (- p) x", "unfolding sign_r_pos_def"], ["proof (prove)\nusing this:\n  \\<forall>x. (0 < poly (smult c p) x) = (0 < poly (- p) x)\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in at_right x. 0 < poly (smult c p) x) =\n    (\\<forall>\\<^sub>F x in at_right x. 0 < poly (- p) x)", "using \\<open>\\<not> c>0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x. (0 < poly (smult c p) x) = (0 < poly (- p) x)\n  \\<not> 0 < c\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in at_right x. 0 < poly (smult c p) x) =\n    (\\<forall>\\<^sub>F x in at_right x. 0 < poly (- p) x)", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (smult c p) x = sign_r_pos (- p) x\n\ngoal (1 subgoal):\n 1. \\<not> 0 < c \\<Longrightarrow>\n    sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos (smult c p) x = sign_r_pos (- p) x\n\ngoal (1 subgoal):\n 1. sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)", "using sign_r_pos_minus[OF \\<open>p\\<noteq>0\\<close>, of x] \\<open>\\<not> c>0\\<close>"], ["proof (prove)\nusing this:\n  sign_r_pos (smult c p) x = sign_r_pos (- p) x\n  sign_r_pos p x = (\\<not> sign_r_pos (- p) x)\n  \\<not> 0 < c\n\ngoal (1 subgoal):\n 1. sign_r_pos (smult c p) x =\n    (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (smult c p) x =\n  (if 0 < c then sign_r_pos p x else \\<not> sign_r_pos p x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_r_pos_mult:\n  fixes p q :: \"real poly\"\n  assumes \"p\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"sign_r_pos (p*q) x= (sign_r_pos p x \\<longleftrightarrow> sign_r_pos q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "obtain ub where \"ub>x\" \n      and ub:\"(\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or> (\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>x < ub;\n         (\\<forall>z.\n             x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n         (\\<forall>z.\n             x < z \\<and> z < ub \\<longrightarrow> poly p z < 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using next_non_root_interval[OF \\<open>p\\<noteq>0\\<close>,of x,unfolded not_eq_pos_or_neg_iff_1]"], ["proof (prove)\nusing this:\n  (\\<And>ub.\n      \\<lbrakk>x < ub;\n       (\\<forall>z.\n           x < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly p z) \\<or>\n       (\\<forall>z.\n           x < z \\<and> z \\<le> ub \\<longrightarrow> poly p z < 0)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>x < ub;\n         (\\<forall>z.\n             x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n         (\\<forall>z.\n             x < z \\<and> z < ub \\<longrightarrow> poly p z < 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis order.strict_implies_order)"], ["proof (state)\nthis:\n  x < ub\n  (\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n  (\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0)\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "obtain ub' where \"ub'>x\" \n      and ub':\"(\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z) \\<or> (\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub'.\n        \\<lbrakk>x < ub';\n         (\\<forall>z.\n             x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z) \\<or>\n         (\\<forall>z.\n             x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using next_non_root_interval[OF \\<open>q\\<noteq>0\\<close>,unfolded not_eq_pos_or_neg_iff_1]"], ["proof (prove)\nusing this:\n  (\\<And>ub.\n      \\<lbrakk>?lb < ub;\n       (\\<forall>z.\n           ?lb < z \\<and> z \\<le> ub \\<longrightarrow> 0 < poly q z) \\<or>\n       (\\<forall>z.\n           ?lb < z \\<and> z \\<le> ub \\<longrightarrow>\n           poly q z < 0)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ub'.\n        \\<lbrakk>x < ub';\n         (\\<forall>z.\n             x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z) \\<or>\n         (\\<forall>z.\n             x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis order.strict_implies_order)"], ["proof (state)\nthis:\n  x < ub'\n  (\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z) \\<or>\n  (\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0)\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "have \"(\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<Longrightarrow> (\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z) \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "assume \"(\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z)\" \"(\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z)\""], ["proof (state)\nthis:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "hence \"sign_r_pos p x\" and \"sign_r_pos q x\""], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\n\ngoal (1 subgoal):\n 1. sign_r_pos p x &&& sign_r_pos q x", "unfolding sign_r_pos_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\n\ngoal (1 subgoal):\n 1. \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly p y &&&\n    \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly q y", "using \\<open>ub>x\\<close> \\<open>ub'>x\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\n  x < ub\n  x < ub'\n\ngoal (1 subgoal):\n 1. \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly p y &&&\n    \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly q y", "by auto"], ["proof (state)\nthis:\n  sign_r_pos p x\n  sign_r_pos q x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "moreover"], ["proof (state)\nthis:\n  sign_r_pos p x\n  sign_r_pos q x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "hence \"eventually (\\<lambda>z. poly p z>0 \\<and> poly q z>0) (at_right x)\""], ["proof (prove)\nusing this:\n  sign_r_pos p x\n  sign_r_pos q x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_right x. 0 < poly p z \\<and> 0 < poly q z", "unfolding sign_r_pos_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly p x\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly q x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_right x. 0 < poly p z \\<and> 0 < poly q z", "using eventually_conj_iff[of _ _ \"at_right x\"]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly p x\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly q x\n  (\\<forall>\\<^sub>F x in at_right x. ?P x \\<and> ?Q x) =\n  (eventually ?P (at_right x) \\<and> eventually ?Q (at_right x))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_right x. 0 < poly p z \\<and> 0 < poly q z", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in at_right x. 0 < poly p z \\<and> 0 < poly q z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "hence \"sign_r_pos (p*q) x\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F z in at_right x. 0 < poly p z \\<and> 0 < poly q z\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x", "unfolding sign_r_pos_def poly_mult"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F z in at_right x. 0 < poly p z \\<and> 0 < poly q z\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right x. 0 < poly p x * poly q x", "by (metis (lifting, mono_tags) eventually_mono mult_pos_pos)"], ["proof (state)\nthis:\n  sign_r_pos (p * q) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "ultimately"], ["proof (chain)\npicking this:\n  sign_r_pos p x\n  sign_r_pos q x\n  sign_r_pos (p * q) x", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos p x\n  sign_r_pos q x\n  sign_r_pos (p * q) x\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "have \"(\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 > poly p z) \\<Longrightarrow> (\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z) \n      \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "assume \"(\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 > poly p z)\" \"(\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z)\""], ["proof (state)\nthis:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "hence \"sign_r_pos (-p) x\" and \"sign_r_pos q x\""], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\n\ngoal (1 subgoal):\n 1. sign_r_pos (- p) x &&& sign_r_pos q x", "unfolding sign_r_pos_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\n\ngoal (1 subgoal):\n 1. \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly (- p) y &&&\n    \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly q y", "using \\<open>ub>x\\<close> \\<open>ub'>x\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\n  x < ub\n  x < ub'\n\ngoal (1 subgoal):\n 1. \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly (- p) y &&&\n    \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly q y", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (- p) x\n  sign_r_pos q x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "moreover"], ["proof (state)\nthis:\n  sign_r_pos (- p) x\n  sign_r_pos q x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "hence \"eventually (\\<lambda>z. poly (-p) z>0 \\<and> poly q z>0) (at_right x)\""], ["proof (prove)\nusing this:\n  sign_r_pos (- p) x\n  sign_r_pos q x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_right x. 0 < poly (- p) z \\<and> 0 < poly q z", "unfolding sign_r_pos_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly (- p) x\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly q x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_right x. 0 < poly (- p) z \\<and> 0 < poly q z", "using eventually_conj_iff[of _ _ \"at_right x\"]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly (- p) x\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly q x\n  (\\<forall>\\<^sub>F x in at_right x. ?P x \\<and> ?Q x) =\n  (eventually ?P (at_right x) \\<and> eventually ?Q (at_right x))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_right x. 0 < poly (- p) z \\<and> 0 < poly q z", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in at_right x. 0 < poly (- p) z \\<and> 0 < poly q z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "hence \"sign_r_pos (- p*q) x\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F z in at_right x. 0 < poly (- p) z \\<and> 0 < poly q z\n\ngoal (1 subgoal):\n 1. sign_r_pos (- p * q) x", "unfolding sign_r_pos_def poly_mult"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F z in at_right x. 0 < poly (- p) z \\<and> 0 < poly q z\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right x. 0 < poly (- p) x * poly q x", "by (metis (lifting, mono_tags) eventually_mono mult_pos_pos)"], ["proof (state)\nthis:\n  sign_r_pos (- p * q) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "ultimately"], ["proof (chain)\npicking this:\n  sign_r_pos (- p) x\n  sign_r_pos q x\n  sign_r_pos (- p * q) x", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos (- p) x\n  sign_r_pos q x\n  sign_r_pos (- p * q) x\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "using sign_r_pos_minus \\<open>p\\<noteq>0\\<close> \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  sign_r_pos (- p) x\n  sign_r_pos q x\n  sign_r_pos (- p * q) x\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  sign_r_pos ?p ?x = (\\<not> sign_r_pos (- ?p) ?x)\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "by (metis minus_mult_left no_zero_divisors)"], ["proof (state)\nthis:\n  sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "have \"(\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<Longrightarrow> (\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 > poly q z)\n      \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "assume \"(\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z)\" \"(\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 > poly q z)\""], ["proof (state)\nthis:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "hence \"sign_r_pos p x\" and \"sign_r_pos (-q) x\""], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\n\ngoal (1 subgoal):\n 1. sign_r_pos p x &&& sign_r_pos (- q) x", "unfolding sign_r_pos_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\n\ngoal (1 subgoal):\n 1. \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly p y &&&\n    \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly (- q) y", "using \\<open>ub>x\\<close> \\<open>ub'>x\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\n  x < ub\n  x < ub'\n\ngoal (1 subgoal):\n 1. \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly p y &&&\n    \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly (- q) y", "by auto"], ["proof (state)\nthis:\n  sign_r_pos p x\n  sign_r_pos (- q) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "moreover"], ["proof (state)\nthis:\n  sign_r_pos p x\n  sign_r_pos (- q) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "hence \"eventually (\\<lambda>z. poly p z>0 \\<and> poly (-q) z>0) (at_right x)\""], ["proof (prove)\nusing this:\n  sign_r_pos p x\n  sign_r_pos (- q) x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_right x. 0 < poly p z \\<and> 0 < poly (- q) z", "unfolding sign_r_pos_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly p x\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly (- q) x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_right x. 0 < poly p z \\<and> 0 < poly (- q) z", "using eventually_conj_iff[of _ _ \"at_right x\"]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly p x\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly (- q) x\n  (\\<forall>\\<^sub>F x in at_right x. ?P x \\<and> ?Q x) =\n  (eventually ?P (at_right x) \\<and> eventually ?Q (at_right x))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_right x. 0 < poly p z \\<and> 0 < poly (- q) z", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in at_right x. 0 < poly p z \\<and> 0 < poly (- q) z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "hence \"sign_r_pos ( p * (- q)) x\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F z in at_right x. 0 < poly p z \\<and> 0 < poly (- q) z\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * - q) x", "unfolding sign_r_pos_def poly_mult"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F z in at_right x. 0 < poly p z \\<and> 0 < poly (- q) z\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right x. 0 < poly p x * poly (- q) x", "by (metis (lifting, mono_tags) eventually_mono mult_pos_pos)"], ["proof (state)\nthis:\n  sign_r_pos (p * - q) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "ultimately"], ["proof (chain)\npicking this:\n  sign_r_pos p x\n  sign_r_pos (- q) x\n  sign_r_pos (p * - q) x", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos p x\n  sign_r_pos (- q) x\n  sign_r_pos (p * - q) x\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "using sign_r_pos_minus \\<open>p\\<noteq>0\\<close> \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  sign_r_pos p x\n  sign_r_pos (- q) x\n  sign_r_pos (p * - q) x\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  sign_r_pos ?p ?x = (\\<not> sign_r_pos (- ?p) ?x)\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "by (metis minus_mult_right no_zero_divisors)"], ["proof (state)\nthis:\n  sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "have \"(\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 > poly p z) \\<Longrightarrow> (\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 > poly q z) \n      \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "assume \"(\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 > poly p z)\" \"(\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 > poly q z)\""], ["proof (state)\nthis:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "hence \"sign_r_pos (-p) x\" and \"sign_r_pos (-q) x\""], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\n\ngoal (1 subgoal):\n 1. sign_r_pos (- p) x &&& sign_r_pos (- q) x", "unfolding sign_r_pos_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\n\ngoal (1 subgoal):\n 1. \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly (- p) y &&&\n    \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly (- q) y", "using \\<open>ub>x\\<close> \\<open>ub'>x\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0\n  \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\n  x < ub\n  x < ub'\n\ngoal (1 subgoal):\n 1. \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly (- p) y &&&\n    \\<exists>b>x. \\<forall>y>x. y < b \\<longrightarrow> 0 < poly (- q) y", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (- p) x\n  sign_r_pos (- q) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "moreover"], ["proof (state)\nthis:\n  sign_r_pos (- p) x\n  sign_r_pos (- q) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "hence \"eventually (\\<lambda>z. poly (-p) z>0 \\<and> poly (-q) z>0) (at_right x)\""], ["proof (prove)\nusing this:\n  sign_r_pos (- p) x\n  sign_r_pos (- q) x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_right x.\n       0 < poly (- p) z \\<and> 0 < poly (- q) z", "unfolding sign_r_pos_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly (- p) x\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly (- q) x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_right x.\n       0 < poly (- p) z \\<and> 0 < poly (- q) z", "using eventually_conj_iff[of _ _ \"at_right x\"]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly (- p) x\n  \\<forall>\\<^sub>F x in at_right x. 0 < poly (- q) x\n  (\\<forall>\\<^sub>F x in at_right x. ?P x \\<and> ?Q x) =\n  (eventually ?P (at_right x) \\<and> eventually ?Q (at_right x))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_right x.\n       0 < poly (- p) z \\<and> 0 < poly (- q) z", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in at_right x.\n     0 < poly (- p) z \\<and> 0 < poly (- q) z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "hence \"sign_r_pos (p * q) x\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F z in at_right x.\n     0 < poly (- p) z \\<and> 0 < poly (- q) z\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x", "unfolding sign_r_pos_def poly_mult poly_minus"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F z in at_right x. 0 < - poly p z \\<and> 0 < - poly q z\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right x. 0 < poly p x * poly q x", "apply (elim eventually_mono[of _ \"at_right x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < - poly p x \\<and> 0 < - poly q x \\<Longrightarrow>\n       0 < poly p x * poly q x", "by (auto intro:mult_neg_neg)"], ["proof (state)\nthis:\n  sign_r_pos (p * q) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n     \\<forall>z.\n        x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (p * q) x =\n                      (sign_r_pos p x = sign_r_pos q x)", "ultimately"], ["proof (chain)\npicking this:\n  sign_r_pos (- p) x\n  sign_r_pos (- q) x\n  sign_r_pos (p * q) x", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos (- p) x\n  sign_r_pos (- q) x\n  sign_r_pos (p * q) x\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "using sign_r_pos_minus \\<open>p\\<noteq>0\\<close> \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  sign_r_pos (- p) x\n  sign_r_pos (- q) x\n  sign_r_pos (p * q) x\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  sign_r_pos ?p ?x = (\\<not> sign_r_pos (- ?p) ?x)\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "by metis"], ["proof (state)\nthis:\n  sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "using ub ub'"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n  \\<lbrakk>\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0;\n   \\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n  (\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> 0 < poly p z) \\<or>\n  (\\<forall>z. x < z \\<and> z < ub \\<longrightarrow> poly p z < 0)\n  (\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> 0 < poly q z) \\<or>\n  (\\<forall>z. x < z \\<and> z < ub' \\<longrightarrow> poly q z < 0)\n\ngoal (1 subgoal):\n 1. sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (p * q) x = (sign_r_pos p x = sign_r_pos q x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_r_pos_add:\n  fixes p q :: \"real poly\"\n  assumes \"poly p x=0\" \"poly q x\\<noteq>0\"\n  shows \"sign_r_pos (p+q) x=sign_r_pos q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos (p + q) x = sign_r_pos q x", "proof (cases \"poly (p+q) x=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly (p + q) x = 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x\n 2. poly (p + q) x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x", "case False"], ["proof (state)\nthis:\n  poly (p + q) x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. poly (p + q) x = 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x\n 2. poly (p + q) x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x", "hence \"p+q\\<noteq>0\""], ["proof (prove)\nusing this:\n  poly (p + q) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p + q \\<noteq> 0", "by (metis poly_0)"], ["proof (state)\nthis:\n  p + q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. poly (p + q) x = 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x\n 2. poly (p + q) x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x", "have \"sign_r_pos (p+q) x = (poly q x > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos (p + q) x = (0 < poly q x)", "using sign_r_pos_rec[OF \\<open>p+q\\<noteq>0\\<close>] False poly_add \\<open>poly p x=0\\<close>"], ["proof (prove)\nusing this:\n  sign_r_pos (p + q) ?x =\n  (if poly (p + q) ?x = 0 then sign_r_pos (pderiv (p + q)) ?x\n   else 0 < poly (p + q) ?x)\n  poly (p + q) x \\<noteq> 0\n  poly (?p + ?q) ?x = poly ?p ?x + poly ?q ?x\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. sign_r_pos (p + q) x = (0 < poly q x)", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (p + q) x = (0 < poly q x)\n\ngoal (2 subgoals):\n 1. poly (p + q) x = 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x\n 2. poly (p + q) x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x", "moreover"], ["proof (state)\nthis:\n  sign_r_pos (p + q) x = (0 < poly q x)\n\ngoal (2 subgoals):\n 1. poly (p + q) x = 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x\n 2. poly (p + q) x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x", "have \"sign_r_pos q x=(poly q x > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos q x = (0 < poly q x)", "using sign_r_pos_rec[of q x] \\<open>poly q x\\<noteq>0\\<close> poly_0"], ["proof (prove)\nusing this:\n  q \\<noteq> 0 \\<Longrightarrow>\n  sign_r_pos q x =\n  (if poly q x = 0 then sign_r_pos (pderiv q) x else 0 < poly q x)\n  poly q x \\<noteq> 0\n  poly 0 ?x = (0::?'a)\n\ngoal (1 subgoal):\n 1. sign_r_pos q x = (0 < poly q x)", "by force"], ["proof (state)\nthis:\n  sign_r_pos q x = (0 < poly q x)\n\ngoal (2 subgoals):\n 1. poly (p + q) x = 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x\n 2. poly (p + q) x \\<noteq> 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x", "ultimately"], ["proof (chain)\npicking this:\n  sign_r_pos (p + q) x = (0 < poly q x)\n  sign_r_pos q x = (0 < poly q x)", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos (p + q) x = (0 < poly q x)\n  sign_r_pos q x = (0 < poly q x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (p + q) x = sign_r_pos q x", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (p + q) x = sign_r_pos q x\n\ngoal (1 subgoal):\n 1. poly (p + q) x = 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (p + q) x = 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x", "case True"], ["proof (state)\nthis:\n  poly (p + q) x = 0\n\ngoal (1 subgoal):\n 1. poly (p + q) x = 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x", "hence False"], ["proof (prove)\nusing this:\n  poly (p + q) x = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>poly p x=0\\<close> \\<open>poly q x\\<noteq>0\\<close> poly_add"], ["proof (prove)\nusing this:\n  poly (p + q) x = 0\n  poly p x = 0\n  poly q x \\<noteq> 0\n  poly (?p + ?q) ?x = poly ?p ?x + poly ?q ?x\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. poly (p + q) x = 0 \\<Longrightarrow>\n    sign_r_pos (p + q) x = sign_r_pos q x", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. sign_r_pos (p + q) x = sign_r_pos q x", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (p + q) x = sign_r_pos q x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_r_pos_mod:\n  fixes p q :: \"real poly\"\n  assumes \"poly p x=0\" \"poly q x\\<noteq>0\"\n  shows \"sign_r_pos (q mod p) x=sign_r_pos q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos (q mod p) x = sign_r_pos q x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_r_pos (q mod p) x = sign_r_pos q x", "have \"poly (q div p * p) x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (q div p * p) x = 0", "using \\<open>poly p x=0\\<close> poly_mult"], ["proof (prove)\nusing this:\n  poly p x = 0\n  poly (?p * ?q) ?x = poly ?p ?x * poly ?q ?x\n\ngoal (1 subgoal):\n 1. poly (q div p * p) x = 0", "by auto"], ["proof (state)\nthis:\n  poly (q div p * p) x = 0\n\ngoal (1 subgoal):\n 1. sign_r_pos (q mod p) x = sign_r_pos q x", "moreover"], ["proof (state)\nthis:\n  poly (q div p * p) x = 0\n\ngoal (1 subgoal):\n 1. sign_r_pos (q mod p) x = sign_r_pos q x", "hence \"poly (q mod p) x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly (q div p * p) x = 0\n\ngoal (1 subgoal):\n 1. poly (q mod p) x \\<noteq> 0", "using \\<open>poly q x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly (q div p * p) x = 0\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (q mod p) x \\<noteq> 0", "by (simp add: assms(1) poly_mod)"], ["proof (state)\nthis:\n  poly (q mod p) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_r_pos (q mod p) x = sign_r_pos q x", "ultimately"], ["proof (chain)\npicking this:\n  poly (q div p * p) x = 0\n  poly (q mod p) x \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  poly (q div p * p) x = 0\n  poly (q mod p) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_r_pos (q mod p) x = sign_r_pos q x", "by (metis div_mult_mod_eq sign_r_pos_add)"], ["proof (state)\nthis:\n  sign_r_pos (q mod p) x = sign_r_pos q x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_r_pos_pderiv:\n  fixes p:: \"real poly\"\n  assumes \"poly p x=0\" \"p\\<noteq>0\"\n  shows \"sign_r_pos (pderiv p * p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * p) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * p) x", "have \"pderiv p \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0", "by (metis assms(1) assms(2) monoid_add_class.add.right_neutral mult_zero_right pCons_0_0 \n      pderiv_iszero poly_0 poly_pCons)"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * p) x", "have \"?thesis = (sign_r_pos (pderiv p) x \\<longleftrightarrow> sign_r_pos p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * p) x = (sign_r_pos (pderiv p) x = sign_r_pos p x)", "using sign_r_pos_mult[OF \\<open>pderiv p \\<noteq> 0\\<close> \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  sign_r_pos (pderiv p * p) ?x =\n  (sign_r_pos (pderiv p) ?x = sign_r_pos p ?x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * p) x = (sign_r_pos (pderiv p) x = sign_r_pos p x)", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (pderiv p * p) x = (sign_r_pos (pderiv p) x = sign_r_pos p x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * p) x", "also"], ["proof (state)\nthis:\n  sign_r_pos (pderiv p * p) x = (sign_r_pos (pderiv p) x = sign_r_pos p x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * p) x", "have \"...=((sign_r_pos (pderiv p) x \\<longleftrightarrow> sign_r_pos (pderiv p) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sign_r_pos (pderiv p) x = sign_r_pos p x) =\n    (sign_r_pos (pderiv p) x = sign_r_pos (pderiv p) x)", "using sign_r_pos_rec[OF \\<open>p\\<noteq>0\\<close>] \\<open>poly p x=0\\<close>"], ["proof (prove)\nusing this:\n  sign_r_pos p ?x =\n  (if poly p ?x = 0 then sign_r_pos (pderiv p) ?x else 0 < poly p ?x)\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. (sign_r_pos (pderiv p) x = sign_r_pos p x) =\n    (sign_r_pos (pderiv p) x = sign_r_pos (pderiv p) x)", "by auto"], ["proof (state)\nthis:\n  (sign_r_pos (pderiv p) x = sign_r_pos p x) =\n  (sign_r_pos (pderiv p) x = sign_r_pos (pderiv p) x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * p) x", "finally"], ["proof (chain)\npicking this:\n  sign_r_pos (pderiv p * p) x =\n  (sign_r_pos (pderiv p) x = sign_r_pos (pderiv p) x)", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos (pderiv p * p) x =\n  (sign_r_pos (pderiv p) x = sign_r_pos (pderiv p) x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * p) x", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (pderiv p * p) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_r_pos_power:\n  fixes p:: \"real poly\" and a::real\n  shows \"sign_r_pos ([:-a,1:]^n) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos ([:- a, 1:] ^ n) a", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. sign_r_pos ([:- a, 1:] ^ 0) a\n 2. \\<And>n.\n       sign_r_pos ([:- a, 1:] ^ n) a \\<Longrightarrow>\n       sign_r_pos ([:- a, 1:] ^ Suc n) a", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sign_r_pos ([:- a, 1:] ^ 0) a\n 2. \\<And>n.\n       sign_r_pos ([:- a, 1:] ^ n) a \\<Longrightarrow>\n       sign_r_pos ([:- a, 1:] ^ Suc n) a", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos ([:- a, 1:] ^ 0) a", "unfolding sign_r_pos_def eventually_at_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b>a.\n       \\<forall>y>a. y < b \\<longrightarrow> 0 < poly ([:- a, 1:] ^ 0) y", "by (simp,metis gt_ex)"], ["proof (state)\nthis:\n  sign_r_pos ([:- a, 1:] ^ 0) a\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sign_r_pos ([:- a, 1:] ^ n) a \\<Longrightarrow>\n       sign_r_pos ([:- a, 1:] ^ Suc n) a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       sign_r_pos ([:- a, 1:] ^ n) a \\<Longrightarrow>\n       sign_r_pos ([:- a, 1:] ^ Suc n) a", "case (Suc n)"], ["proof (state)\nthis:\n  sign_r_pos ([:- a, 1:] ^ n) a\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sign_r_pos ([:- a, 1:] ^ n) a \\<Longrightarrow>\n       sign_r_pos ([:- a, 1:] ^ Suc n) a", "have \"pderiv ([:-a,1:]^Suc n) = smult (Suc n) ([:-a,1:]^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv ([:- a, 1:] ^ Suc n) = smult (real (Suc n)) ([:- a, 1:] ^ n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv ([:- a, 1:] ^ Suc n) = smult (real (Suc n)) ([:- a, 1:] ^ n)", "have \"pderiv [:- a, 1::real:] = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv [:- a, 1:] = 1", "by (simp add: pderiv.simps)"], ["proof (state)\nthis:\n  pderiv [:- a, 1:] = 1\n\ngoal (1 subgoal):\n 1. pderiv ([:- a, 1:] ^ Suc n) = smult (real (Suc n)) ([:- a, 1:] ^ n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  pderiv [:- a, 1:] = 1\n\ngoal (1 subgoal):\n 1. pderiv ([:- a, 1:] ^ Suc n) = smult (real (Suc n)) ([:- a, 1:] ^ n)", "unfolding pderiv_power_Suc"], ["proof (prove)\nusing this:\n  pderiv [:- a, 1:] = 1\n\ngoal (1 subgoal):\n 1. smult (real (Suc n)) ([:- a, 1:] ^ n) * pderiv [:- a, 1:] =\n    smult (real (Suc n)) ([:- a, 1:] ^ n)", "by (metis mult_cancel_left1)"], ["proof (state)\nthis:\n  pderiv ([:- a, 1:] ^ Suc n) = smult (real (Suc n)) ([:- a, 1:] ^ n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pderiv ([:- a, 1:] ^ Suc n) = smult (real (Suc n)) ([:- a, 1:] ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sign_r_pos ([:- a, 1:] ^ n) a \\<Longrightarrow>\n       sign_r_pos ([:- a, 1:] ^ Suc n) a", "moreover"], ["proof (state)\nthis:\n  pderiv ([:- a, 1:] ^ Suc n) = smult (real (Suc n)) ([:- a, 1:] ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sign_r_pos ([:- a, 1:] ^ n) a \\<Longrightarrow>\n       sign_r_pos ([:- a, 1:] ^ Suc n) a", "have \" poly ([:- a, 1:] ^ Suc n) a=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ([:- a, 1:] ^ Suc n) a = 0", "by (metis old.nat.distinct(2) poly_power_n_eq)"], ["proof (state)\nthis:\n  poly ([:- a, 1:] ^ Suc n) a = 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sign_r_pos ([:- a, 1:] ^ n) a \\<Longrightarrow>\n       sign_r_pos ([:- a, 1:] ^ Suc n) a", "hence \"sign_r_pos ([:- a, 1:] ^ Suc n) a = sign_r_pos (smult (Suc n) ([:-a,1:]^n)) a\""], ["proof (prove)\nusing this:\n  poly ([:- a, 1:] ^ Suc n) a = 0\n\ngoal (1 subgoal):\n 1. sign_r_pos ([:- a, 1:] ^ Suc n) a =\n    sign_r_pos (smult (real (Suc n)) ([:- a, 1:] ^ n)) a", "using sign_r_pos_rec"], ["proof (prove)\nusing this:\n  poly ([:- a, 1:] ^ Suc n) a = 0\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  sign_r_pos ?p ?x =\n  (if poly ?p ?x = 0 then sign_r_pos (pderiv ?p) ?x else 0 < poly ?p ?x)\n\ngoal (1 subgoal):\n 1. sign_r_pos ([:- a, 1:] ^ Suc n) a =\n    sign_r_pos (smult (real (Suc n)) ([:- a, 1:] ^ n)) a", "by (metis (erased, hide_lams) calculation pderiv_0)"], ["proof (state)\nthis:\n  sign_r_pos ([:- a, 1:] ^ Suc n) a =\n  sign_r_pos (smult (real (Suc n)) ([:- a, 1:] ^ n)) a\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sign_r_pos ([:- a, 1:] ^ n) a \\<Longrightarrow>\n       sign_r_pos ([:- a, 1:] ^ Suc n) a", "hence \"sign_r_pos ([:- a, 1:] ^ Suc n) a = sign_r_pos  ([:-a,1:]^n) a\""], ["proof (prove)\nusing this:\n  sign_r_pos ([:- a, 1:] ^ Suc n) a =\n  sign_r_pos (smult (real (Suc n)) ([:- a, 1:] ^ n)) a\n\ngoal (1 subgoal):\n 1. sign_r_pos ([:- a, 1:] ^ Suc n) a = sign_r_pos ([:- a, 1:] ^ n) a", "using sign_r_pos_smult"], ["proof (prove)\nusing this:\n  sign_r_pos ([:- a, 1:] ^ Suc n) a =\n  sign_r_pos (smult (real (Suc n)) ([:- a, 1:] ^ n)) a\n  \\<lbrakk>?c \\<noteq> 0; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (smult ?c ?p) ?x =\n                    (if 0 < ?c then sign_r_pos ?p ?x\n                     else \\<not> sign_r_pos ?p ?x)\n\ngoal (1 subgoal):\n 1. sign_r_pos ([:- a, 1:] ^ Suc n) a = sign_r_pos ([:- a, 1:] ^ n) a", "by auto"], ["proof (state)\nthis:\n  sign_r_pos ([:- a, 1:] ^ Suc n) a = sign_r_pos ([:- a, 1:] ^ n) a\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       sign_r_pos ([:- a, 1:] ^ n) a \\<Longrightarrow>\n       sign_r_pos ([:- a, 1:] ^ Suc n) a", "ultimately"], ["proof (chain)\npicking this:\n  pderiv ([:- a, 1:] ^ Suc n) = smult (real (Suc n)) ([:- a, 1:] ^ n)\n  sign_r_pos ([:- a, 1:] ^ Suc n) a = sign_r_pos ([:- a, 1:] ^ n) a", "show ?case"], ["proof (prove)\nusing this:\n  pderiv ([:- a, 1:] ^ Suc n) = smult (real (Suc n)) ([:- a, 1:] ^ n)\n  sign_r_pos ([:- a, 1:] ^ Suc n) a = sign_r_pos ([:- a, 1:] ^ n) a\n\ngoal (1 subgoal):\n 1. sign_r_pos ([:- a, 1:] ^ Suc n) a", "using Suc.hyps"], ["proof (prove)\nusing this:\n  pderiv ([:- a, 1:] ^ Suc n) = smult (real (Suc n)) ([:- a, 1:] ^ n)\n  sign_r_pos ([:- a, 1:] ^ Suc n) a = sign_r_pos ([:- a, 1:] ^ n) a\n  sign_r_pos ([:- a, 1:] ^ n) a\n\ngoal (1 subgoal):\n 1. sign_r_pos ([:- a, 1:] ^ Suc n) a", "by auto"], ["proof (state)\nthis:\n  sign_r_pos ([:- a, 1:] ^ Suc n) a\n\ngoal:\nNo subgoals!", "qed"], ["", "section\\<open>Jump\\<close>"], ["", "definition jump_poly :: \"real poly \\<Rightarrow> real poly \\<Rightarrow>real \\<Rightarrow> int\"\n where \n \" jump_poly q p x\\<equiv> (if p\\<noteq>0 \\<and> q\\<noteq>0 \\<and> odd((order x p) - (order x q) ) then \n                  if sign_r_pos (q*p) x then 1 else -1\n                else 0 )\""], ["", "lemma jump_poly_not_root:\"poly p x\\<noteq>0\\<Longrightarrow> jump_poly q p x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0 \\<Longrightarrow> jump_poly q p x = 0", "unfolding  jump_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0 \\<Longrightarrow>\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> odd (order x p - order x q)\n     then if sign_r_pos (q * p) x then 1 else - 1 else 0) =\n    0", "by (metis even_zero order_root zero_diff)"], ["", "lemma jump_poly0[simp]: \n    \"jump_poly 0 p x = 0\"\n    \"jump_poly q 0 x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly 0 p x = 0 &&& jump_poly q 0 x = 0", "unfolding jump_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p \\<noteq> 0 \\<and> 0 \\<noteq> 0 \\<and> odd (order x p - order x 0)\n     then if sign_r_pos (0 * p) x then 1 else - 1 else 0) =\n    0 &&&\n    (if 0 \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> odd (order x 0 - order x q)\n     then if sign_r_pos (q * 0) x then 1 else - 1 else 0) =\n    0", "by auto"], ["", "lemma jump_poly_smult_1:\n  fixes p q::\"real poly\" and c::real\n  shows \"jump_poly (smult c q) p x= sign c * jump_poly q p x\" (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly (smult c q) p x = sign c * jump_poly q p x", "proof (cases \"c=0\\<or> q=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<or> q = 0 \\<Longrightarrow>\n    jump_poly (smult c q) p x = sign c * jump_poly q p x\n 2. \\<not> (c = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly (smult c q) p x = sign c * jump_poly q p x", "case True"], ["proof (state)\nthis:\n  c = 0 \\<or> q = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<or> q = 0 \\<Longrightarrow>\n    jump_poly (smult c q) p x = sign c * jump_poly q p x\n 2. \\<not> (c = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly (smult c q) p x = sign c * jump_poly q p x", "thus ?thesis"], ["proof (prove)\nusing this:\n  c = 0 \\<or> q = 0\n\ngoal (1 subgoal):\n 1. jump_poly (smult c q) p x = sign c * jump_poly q p x", "unfolding jump_poly_def"], ["proof (prove)\nusing this:\n  c = 0 \\<or> q = 0\n\ngoal (1 subgoal):\n 1. (if p \\<noteq> 0 \\<and>\n        smult c q \\<noteq> 0 \\<and> odd (order x p - order x (smult c q))\n     then if sign_r_pos (smult c q * p) x then 1 else - 1 else 0) =\n    sign c *\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> odd (order x p - order x q)\n     then if sign_r_pos (q * p) x then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  jump_poly (smult c q) p x = sign c * jump_poly q p x\n\ngoal (1 subgoal):\n 1. \\<not> (c = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly (smult c q) p x = sign c * jump_poly q p x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (c = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly (smult c q) p x = sign c * jump_poly q p x", "case False"], ["proof (state)\nthis:\n  \\<not> (c = 0 \\<or> q = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (c = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly (smult c q) p x = sign c * jump_poly q p x", "hence \"c\\<noteq>0\" and \"q\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<not> (c = 0 \\<or> q = 0)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 &&& q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (c = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly (smult c q) p x = sign c * jump_poly q p x", "thus ?thesis"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump_poly (smult c q) p x = sign c * jump_poly q p x", "unfolding jump_poly_def"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if p \\<noteq> 0 \\<and>\n        smult c q \\<noteq> 0 \\<and> odd (order x p - order x (smult c q))\n     then if sign_r_pos (smult c q * p) x then 1 else - 1 else 0) =\n    sign c *\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> odd (order x p - order x q)\n     then if sign_r_pos (q * p) x then 1 else - 1 else 0)", "using order_smult[OF \\<open>c\\<noteq>0\\<close>] sign_r_pos_smult[OF \\<open>c\\<noteq>0\\<close>, of \"q*p\" x] \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  q \\<noteq> 0\n  order ?x (smult c ?p) = order ?x ?p\n  q * p \\<noteq> 0 \\<Longrightarrow>\n  sign_r_pos (smult c (q * p)) x =\n  (if 0 < c then sign_r_pos (q * p) x else \\<not> sign_r_pos (q * p) x)\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if p \\<noteq> 0 \\<and>\n        smult c q \\<noteq> 0 \\<and> odd (order x p - order x (smult c q))\n     then if sign_r_pos (smult c q * p) x then 1 else - 1 else 0) =\n    sign c *\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> odd (order x p - order x q)\n     then if sign_r_pos (q * p) x then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  jump_poly (smult c q) p x = sign c * jump_poly q p x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jump_poly_mult:\n  fixes p q p'::\"real poly\"\n  assumes \"p'\\<noteq>0\"\n  shows \"jump_poly (p'*q) (p'*p) x= jump_poly q p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly (p' * q) (p' * p) x = jump_poly q p x", "proof (cases \"q=0 \\<or> p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q = 0 \\<or> p = 0 \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x\n 2. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x", "case True"], ["proof (state)\nthis:\n  q = 0 \\<or> p = 0\n\ngoal (2 subgoals):\n 1. q = 0 \\<or> p = 0 \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x\n 2. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x", "thus ?thesis"], ["proof (prove)\nusing this:\n  q = 0 \\<or> p = 0\n\ngoal (1 subgoal):\n 1. jump_poly (p' * q) (p' * p) x = jump_poly q p x", "unfolding jump_poly_def"], ["proof (prove)\nusing this:\n  q = 0 \\<or> p = 0\n\ngoal (1 subgoal):\n 1. (if p' * p \\<noteq> 0 \\<and>\n        p' * q \\<noteq> 0 \\<and> odd (order x (p' * p) - order x (p' * q))\n     then if sign_r_pos (p' * q * (p' * p)) x then 1 else - 1 else 0) =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> odd (order x p - order x q)\n     then if sign_r_pos (q * p) x then 1 else - 1 else 0)", "by fastforce"], ["proof (state)\nthis:\n  jump_poly (p' * q) (p' * p) x = jump_poly q p x\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x", "case False"], ["proof (state)\nthis:\n  \\<not> (q = 0 \\<or> p = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x", "then"], ["proof (chain)\npicking this:\n  \\<not> (q = 0 \\<or> p = 0)", "have \"q\\<noteq>0\" \"p\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<not> (q = 0 \\<or> p = 0)\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x", "have \"sign_r_pos (p' * q * (p' * p)) x=sign_r_pos (q * p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos (p' * q * (p' * p)) x = sign_r_pos (q * p) x", "proof (unfold sign_r_pos_def,rule eventually_subst,unfold eventually_at_right)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>b>x.\n       \\<forall>y>x.\n          y < b \\<longrightarrow>\n          (0 < poly (p' * q * (p' * p)) y) = (0 < poly (q * p) y)", "obtain b where \"b>x\" and b:\"\\<forall>z. x < z \\<and> z < b \\<longrightarrow> poly (p' * p') z >0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>x < b;\n         \\<forall>z.\n            x < z \\<and> z < b \\<longrightarrow>\n            0 < poly (p' * p') z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"\\<exists>z. poly p' z=0 \\<and> z>x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<nexists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  \\<exists>z. poly p' z = 0 \\<and> x < z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<nexists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis", "define lr where \"lr\\<equiv>Min {r . poly p' r=0 \\<and> r>x}\""], ["proof (state)\nthis:\n  lr \\<equiv> Min {r. poly p' r = 0 \\<and> x < r}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<nexists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<forall>z. x<z\\<and>z<lr\\<longrightarrow>poly p' z\\<noteq>0\" and \"lr>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < lr \\<longrightarrow> poly p' z \\<noteq> 0 &&&\n    x < lr", "using True lr_def poly_roots_finite[OF \\<open>p'\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>z. poly p' z = 0 \\<and> x < z\n  lr \\<equiv> Min {r. poly p' r = 0 \\<and> x < r}\n  finite {x. poly p' x = 0}\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < lr \\<longrightarrow> poly p' z \\<noteq> 0 &&&\n    x < lr", "by auto"], ["proof (state)\nthis:\n  \\<forall>z. x < z \\<and> z < lr \\<longrightarrow> poly p' z \\<noteq> 0\n  x < lr\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<nexists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<forall>z. x < z \\<and> z < lr \\<longrightarrow> 0 < poly (p' * p') z\""], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < lr \\<longrightarrow> poly p' z \\<noteq> 0\n  x < lr\n\ngoal (1 subgoal):\n 1. \\<forall>z. x < z \\<and> z < lr \\<longrightarrow> 0 < poly (p' * p') z", "by (metis not_real_square_gt_zero poly_mult)"], ["proof (state)\nthis:\n  \\<forall>z. x < z \\<and> z < lr \\<longrightarrow> 0 < poly (p' * p') z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<exists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<nexists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < lr \\<longrightarrow> 0 < poly (p' * p') z\n\ngoal (1 subgoal):\n 1. thesis", "using that[OF \\<open>lr>x\\<close>]"], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < lr \\<longrightarrow> 0 < poly (p' * p') z\n  \\<forall>z.\n     x < z \\<and> z < lr \\<longrightarrow>\n     0 < poly (p' * p') z \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<nexists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<nexists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<nexists>z. poly p' z = 0 \\<and> x < z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<nexists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<forall>z. x<z\\<and>z<x+1\\<longrightarrow>poly p' z\\<noteq>0\" and \"x+1>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < x + 1 \\<longrightarrow> poly p' z \\<noteq> 0 &&&\n    x < x + 1", "using False poly_roots_finite[OF \\<open>p'\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  \\<nexists>z. poly p' z = 0 \\<and> x < z\n  finite {x. poly p' x = 0}\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < x + 1 \\<longrightarrow> poly p' z \\<noteq> 0 &&&\n    x < x + 1", "by auto"], ["proof (state)\nthis:\n  \\<forall>z. x < z \\<and> z < x + 1 \\<longrightarrow> poly p' z \\<noteq> 0\n  x < x + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<nexists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<forall>z. x < z \\<and> z < x+1 \\<longrightarrow> 0 < poly (p' * p') z\""], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < x + 1 \\<longrightarrow> poly p' z \\<noteq> 0\n  x < x + 1\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       x < z \\<and> z < x + 1 \\<longrightarrow> 0 < poly (p' * p') z", "by (metis not_real_square_gt_zero poly_mult)"], ["proof (state)\nthis:\n  \\<forall>z. x < z \\<and> z < x + 1 \\<longrightarrow> 0 < poly (p' * p') z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>b.\n                \\<lbrakk>x < b;\n                 \\<forall>z.\n                    x < z \\<and> z < b \\<longrightarrow>\n                    0 < poly (p' * p') z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<nexists>z. poly p' z = 0 \\<and> x < z\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < x + 1 \\<longrightarrow> 0 < poly (p' * p') z\n\ngoal (1 subgoal):\n 1. thesis", "using that[OF \\<open>x+1>x\\<close>]"], ["proof (prove)\nusing this:\n  \\<forall>z. x < z \\<and> z < x + 1 \\<longrightarrow> 0 < poly (p' * p') z\n  \\<forall>z.\n     x < z \\<and> z < x + 1 \\<longrightarrow>\n     0 < poly (p' * p') z \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < b\n  \\<forall>z. x < z \\<and> z < b \\<longrightarrow> 0 < poly (p' * p') z\n\ngoal (1 subgoal):\n 1. \\<exists>b>x.\n       \\<forall>y>x.\n          y < b \\<longrightarrow>\n          (0 < poly (p' * q * (p' * p)) y) = (0 < poly (q * p) y)", "show \"\\<exists>b>x. \\<forall>z>x. z < b \\<longrightarrow> (0 < poly (p' * q * (p' * p)) z) = (0 < poly (q * p) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b>x.\n       \\<forall>z>x.\n          z < b \\<longrightarrow>\n          (0 < poly (p' * q * (p' * p)) z) = (0 < poly (q * p) z)", "proof (rule_tac x=\"b\" in exI, rule conjI[OF \\<open>b>x\\<close>],rule allI,rule impI,rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x < z; z < b\\<rbrakk>\n       \\<Longrightarrow> (0 < poly (p' * q * (p' * p)) z) =\n                         (0 < poly (q * p) z)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x < z; z < b\\<rbrakk>\n       \\<Longrightarrow> (0 < poly (p' * q * (p' * p)) z) =\n                         (0 < poly (q * p) z)", "assume \"x < z\"  \"z < b\""], ["proof (state)\nthis:\n  x < z\n  z < b\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x < z; z < b\\<rbrakk>\n       \\<Longrightarrow> (0 < poly (p' * q * (p' * p)) z) =\n                         (0 < poly (q * p) z)", "hence \"0<poly (p'*p') z\""], ["proof (prove)\nusing this:\n  x < z\n  z < b\n\ngoal (1 subgoal):\n 1. 0 < poly (p' * p') z", "using b"], ["proof (prove)\nusing this:\n  x < z\n  z < b\n  \\<forall>z. x < z \\<and> z < b \\<longrightarrow> 0 < poly (p' * p') z\n\ngoal (1 subgoal):\n 1. 0 < poly (p' * p') z", "by auto"], ["proof (state)\nthis:\n  0 < poly (p' * p') z\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x < z; z < b\\<rbrakk>\n       \\<Longrightarrow> (0 < poly (p' * q * (p' * p)) z) =\n                         (0 < poly (q * p) z)", "have \" (0 < poly (p' * q * (p' * p)) z)=(0<poly (p'*p') z * poly (q*p) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < poly (p' * q * (p' * p)) z) =\n    (0 < poly (p' * p') z * poly (q * p) z)", "by (simp add: mult.commute mult.left_commute)"], ["proof (state)\nthis:\n  (0 < poly (p' * q * (p' * p)) z) = (0 < poly (p' * p') z * poly (q * p) z)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x < z; z < b\\<rbrakk>\n       \\<Longrightarrow> (0 < poly (p' * q * (p' * p)) z) =\n                         (0 < poly (q * p) z)", "also"], ["proof (state)\nthis:\n  (0 < poly (p' * q * (p' * p)) z) = (0 < poly (p' * p') z * poly (q * p) z)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x < z; z < b\\<rbrakk>\n       \\<Longrightarrow> (0 < poly (p' * q * (p' * p)) z) =\n                         (0 < poly (q * p) z)", "have \"...=(0<poly (q*p) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < poly (p' * p') z * poly (q * p) z) = (0 < poly (q * p) z)", "using \\<open>0<poly (p'*p') z\\<close>"], ["proof (prove)\nusing this:\n  0 < poly (p' * p') z\n\ngoal (1 subgoal):\n 1. (0 < poly (p' * p') z * poly (q * p) z) = (0 < poly (q * p) z)", "by (metis mult_pos_pos zero_less_mult_pos)"], ["proof (state)\nthis:\n  (0 < poly (p' * p') z * poly (q * p) z) = (0 < poly (q * p) z)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>x < z; z < b\\<rbrakk>\n       \\<Longrightarrow> (0 < poly (p' * q * (p' * p)) z) =\n                         (0 < poly (q * p) z)", "finally"], ["proof (chain)\npicking this:\n  (0 < poly (p' * q * (p' * p)) z) = (0 < poly (q * p) z)", "show \"(0 < poly (p' * q * (p' * p)) z) = (0 < poly (q * p) z)\""], ["proof (prove)\nusing this:\n  (0 < poly (p' * q * (p' * p)) z) = (0 < poly (q * p) z)\n\ngoal (1 subgoal):\n 1. (0 < poly (p' * q * (p' * p)) z) = (0 < poly (q * p) z)", "."], ["proof (state)\nthis:\n  (0 < poly (p' * q * (p' * p)) z) = (0 < poly (q * p) z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>b>x.\n     \\<forall>z>x.\n        z < b \\<longrightarrow>\n        (0 < poly (p' * q * (p' * p)) z) = (0 < poly (q * p) z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign_r_pos (p' * q * (p' * p)) x = sign_r_pos (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x", "moreover"], ["proof (state)\nthis:\n  sign_r_pos (p' * q * (p' * p)) x = sign_r_pos (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x", "have \" odd (order x (p' * p) - order x (p' * q)) = odd (order x p - order x q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (order x (p' * p) - order x (p' * q)) = odd (order x p - order x q)", "using  False \\<open>p'\\<noteq>0\\<close> \\<open>p\\<noteq>0\\<close> mult_eq_0_iff order_mult"], ["proof (prove)\nusing this:\n  \\<not> (q = 0 \\<or> p = 0)\n  p' \\<noteq> 0\n  p \\<noteq> 0\n  (?a * ?b = (0::?'a)) = (?a = (0::?'a) \\<or> ?b = (0::?'a))\n  ?p * ?q \\<noteq> 0 \\<Longrightarrow>\n  order ?a (?p * ?q) = order ?a ?p + order ?a ?q\n\ngoal (1 subgoal):\n 1. odd (order x (p' * p) - order x (p' * q)) = odd (order x p - order x q)", "by (metis add_diff_cancel_left)"], ["proof (state)\nthis:\n  odd (order x (p' * p) - order x (p' * q)) = odd (order x p - order x q)\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x", "moreover"], ["proof (state)\nthis:\n  odd (order x (p' * p) - order x (p' * q)) = odd (order x p - order x q)\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x", "have \" p' * q \\<noteq> 0 \\<longleftrightarrow> q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p' * q \\<noteq> 0) = (q \\<noteq> 0)", "by (metis \\<open>p'\\<noteq>0\\<close> mult_eq_0_iff)"], ["proof (state)\nthis:\n  (p' * q \\<noteq> 0) = (q \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x", "ultimately"], ["proof (chain)\npicking this:\n  sign_r_pos (p' * q * (p' * p)) x = sign_r_pos (q * p) x\n  odd (order x (p' * p) - order x (p' * q)) = odd (order x p - order x q)\n  (p' * q \\<noteq> 0) = (q \\<noteq> 0)", "show \"jump_poly (p' * q) (p' * p) x = jump_poly q p x\""], ["proof (prove)\nusing this:\n  sign_r_pos (p' * q * (p' * p)) x = sign_r_pos (q * p) x\n  odd (order x (p' * p) - order x (p' * q)) = odd (order x p - order x q)\n  (p' * q \\<noteq> 0) = (q \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. jump_poly (p' * q) (p' * p) x = jump_poly q p x", "unfolding jump_poly_def"], ["proof (prove)\nusing this:\n  sign_r_pos (p' * q * (p' * p)) x = sign_r_pos (q * p) x\n  odd (order x (p' * p) - order x (p' * q)) = odd (order x p - order x q)\n  (p' * q \\<noteq> 0) = (q \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (if p' * p \\<noteq> 0 \\<and>\n        p' * q \\<noteq> 0 \\<and> odd (order x (p' * p) - order x (p' * q))\n     then if sign_r_pos (p' * q * (p' * p)) x then 1 else - 1 else 0) =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> odd (order x p - order x q)\n     then if sign_r_pos (q * p) x then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  jump_poly (p' * q) (p' * p) x = jump_poly q p x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jump_poly_1_mult:\n  fixes p1 p2::\"real poly\"\n  assumes \"poly p1 x\\<noteq>0 \\<or> poly p2 x\\<noteq>0\" \n  shows \"jump_poly 1 (p1*p2) x= sign (poly p2 x) * jump_poly 1 p1 x \n            + sign (poly p1 x) * jump_poly 1 p2 x\" (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "proof (cases \"p1=0 \\<or> p2 =0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p1 = 0 \\<or> p2 = 0 \\<Longrightarrow>\n    jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x\n 2. \\<not> (p1 = 0 \\<or> p2 = 0) \\<Longrightarrow>\n    jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "case True"], ["proof (state)\nthis:\n  p1 = 0 \\<or> p2 = 0\n\ngoal (2 subgoals):\n 1. p1 = 0 \\<or> p2 = 0 \\<Longrightarrow>\n    jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x\n 2. \\<not> (p1 = 0 \\<or> p2 = 0) \\<Longrightarrow>\n    jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "then"], ["proof (chain)\npicking this:\n  p1 = 0 \\<or> p2 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p1 = 0 \\<or> p2 = 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "by auto"], ["proof (state)\nthis:\n  jump_poly 1 (p1 * p2) x =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal (1 subgoal):\n 1. \\<not> (p1 = 0 \\<or> p2 = 0) \\<Longrightarrow>\n    jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p1 = 0 \\<or> p2 = 0) \\<Longrightarrow>\n    jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "case False"], ["proof (state)\nthis:\n  \\<not> (p1 = 0 \\<or> p2 = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p1 = 0 \\<or> p2 = 0) \\<Longrightarrow>\n    jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "then"], ["proof (chain)\npicking this:\n  \\<not> (p1 = 0 \\<or> p2 = 0)", "have \"p1\\<noteq>0\" \"p2\\<noteq>0\" \"p1*p2\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<not> (p1 = 0 \\<or> p2 = 0)\n\ngoal (1 subgoal):\n 1. p1 \\<noteq> 0 &&& p2 \\<noteq> 0 &&& p1 * p2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p1 \\<noteq> 0\n  p2 \\<noteq> 0\n  p1 * p2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (p1 = 0 \\<or> p2 = 0) \\<Longrightarrow>\n    jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "have ?thesis when \"poly p1 x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "have [simp]:\"order x p1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p1 = 0", "using that order_root"], ["proof (prove)\nusing this:\n  poly p1 x \\<noteq> 0\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. order x p1 = 0", "by blast"], ["proof (state)\nthis:\n  order x p1 = 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "define simpL where \"simpL\\<equiv>(if p2\\<noteq>0 \\<and> odd (order x p2) then if (poly p1 x>0) \n    \\<longleftrightarrow>  sign_r_pos p2 x then 1::int else -1 else 0)\""], ["proof (state)\nthis:\n  simpL \\<equiv>\n  if p2 \\<noteq> 0 \\<and> odd (order x p2)\n  then if (0 < poly p1 x) = sign_r_pos p2 x then 1 else - 1 else 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "have \"?L=simpL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x = simpL", "unfolding simpL_def jump_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p1 * p2 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x (p1 * p2) - order x 1)\n     then if sign_r_pos (1 * (p1 * p2)) x then 1 else - 1 else 0) =\n    (if p2 \\<noteq> 0 \\<and> odd (order x p2)\n     then if (0 < poly p1 x) = sign_r_pos p2 x then 1 else - 1 else 0)", "using order_mult[OF \\<open>p1*p2\\<noteq>0\\<close>]\n        sign_r_pos_mult[OF \\<open>p1\\<noteq>0\\<close> \\<open>p2\\<noteq>0\\<close>] sign_r_pos_rec[OF \\<open>p1\\<noteq>0\\<close>] \\<open>poly p1 x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  order ?a (p1 * p2) = order ?a p1 + order ?a p2\n  sign_r_pos (p1 * p2) ?x = (sign_r_pos p1 ?x = sign_r_pos p2 ?x)\n  sign_r_pos p1 ?x =\n  (if poly p1 ?x = 0 then sign_r_pos (pderiv p1) ?x else 0 < poly p1 ?x)\n  poly p1 x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if p1 * p2 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x (p1 * p2) - order x 1)\n     then if sign_r_pos (1 * (p1 * p2)) x then 1 else - 1 else 0) =\n    (if p2 \\<noteq> 0 \\<and> odd (order x p2)\n     then if (0 < poly p1 x) = sign_r_pos p2 x then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  jump_poly 1 (p1 * p2) x = simpL\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "moreover"], ["proof (state)\nthis:\n  jump_poly 1 (p1 * p2) x = simpL\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "have \"poly p1 x>0 \\<Longrightarrow> simpL =?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p1 x \\<Longrightarrow>\n    simpL =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "unfolding simpL_def jump_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p1 x \\<Longrightarrow>\n    (if p2 \\<noteq> 0 \\<and> odd (order x p2)\n     then if (0 < poly p1 x) = sign_r_pos p2 x then 1 else - 1 else 0) =\n    sign (poly p2 x) *\n    (if p1 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p1 - order x 1)\n     then if sign_r_pos (1 * p1) x then 1 else - 1 else 0) +\n    sign (poly p1 x) *\n    (if p2 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p2 - order x 1)\n     then if sign_r_pos (1 * p2) x then 1 else - 1 else 0)", "using jump_poly_not_root[OF \\<open>poly p1 x\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  jump_poly ?q p1 x = 0\n\ngoal (1 subgoal):\n 1. 0 < poly p1 x \\<Longrightarrow>\n    (if p2 \\<noteq> 0 \\<and> odd (order x p2)\n     then if (0 < poly p1 x) = sign_r_pos p2 x then 1 else - 1 else 0) =\n    sign (poly p2 x) *\n    (if p1 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p1 - order x 1)\n     then if sign_r_pos (1 * p1) x then 1 else - 1 else 0) +\n    sign (poly p1 x) *\n    (if p2 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p2 - order x 1)\n     then if sign_r_pos (1 * p2) x then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  0 < poly p1 x \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "moreover"], ["proof (state)\nthis:\n  0 < poly p1 x \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "have \"poly p1 x<0 \\<Longrightarrow> simpL =?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p1 x < 0 \\<Longrightarrow>\n    simpL =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "unfolding simpL_def jump_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p1 x < 0 \\<Longrightarrow>\n    (if p2 \\<noteq> 0 \\<and> odd (order x p2)\n     then if (0 < poly p1 x) = sign_r_pos p2 x then 1 else - 1 else 0) =\n    sign (poly p2 x) *\n    (if p1 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p1 - order x 1)\n     then if sign_r_pos (1 * p1) x then 1 else - 1 else 0) +\n    sign (poly p1 x) *\n    (if p2 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p2 - order x 1)\n     then if sign_r_pos (1 * p2) x then 1 else - 1 else 0)", "using jump_poly_not_root[OF \\<open>poly p1 x\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  jump_poly ?q p1 x = 0\n\ngoal (1 subgoal):\n 1. poly p1 x < 0 \\<Longrightarrow>\n    (if p2 \\<noteq> 0 \\<and> odd (order x p2)\n     then if (0 < poly p1 x) = sign_r_pos p2 x then 1 else - 1 else 0) =\n    sign (poly p2 x) *\n    (if p1 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p1 - order x 1)\n     then if sign_r_pos (1 * p1) x then 1 else - 1 else 0) +\n    sign (poly p1 x) *\n    (if p2 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p2 - order x 1)\n     then if sign_r_pos (1 * p2) x then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  poly p1 x < 0 \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "ultimately"], ["proof (chain)\npicking this:\n  jump_poly 1 (p1 * p2) x = simpL\n  0 < poly p1 x \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n  poly p1 x < 0 \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x", "show \"?L=?R\""], ["proof (prove)\nusing this:\n  jump_poly 1 (p1 * p2) x = simpL\n  0 < poly p1 x \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n  poly p1 x < 0 \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "using \\<open>poly p1 x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  jump_poly 1 (p1 * p2) x = simpL\n  0 < poly p1 x \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n  poly p1 x < 0 \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n  poly p1 x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "by (metis linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  jump_poly 1 (p1 * p2) x =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p1 x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly 1 (p1 * p2) x =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal (1 subgoal):\n 1. \\<not> (p1 = 0 \\<or> p2 = 0) \\<Longrightarrow>\n    jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "moreover"], ["proof (state)\nthis:\n  poly p1 x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly 1 (p1 * p2) x =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal (1 subgoal):\n 1. \\<not> (p1 = 0 \\<or> p2 = 0) \\<Longrightarrow>\n    jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "have ?thesis when \"poly p2 x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "have [simp]:\"order x p2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p2 = 0", "using that order_root"], ["proof (prove)\nusing this:\n  poly p2 x \\<noteq> 0\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. order x p2 = 0", "by blast"], ["proof (state)\nthis:\n  order x p2 = 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "define simpL where \"simpL\\<equiv>(if p1\\<noteq>0 \\<and> odd (order x p1) then if (poly p2 x>0) \n    \\<longleftrightarrow>  sign_r_pos p1 x then 1::int else -1 else 0)\""], ["proof (state)\nthis:\n  simpL \\<equiv>\n  if p1 \\<noteq> 0 \\<and> odd (order x p1)\n  then if (0 < poly p2 x) = sign_r_pos p1 x then 1 else - 1 else 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "have \"?L=simpL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x = simpL", "unfolding simpL_def jump_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p1 * p2 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x (p1 * p2) - order x 1)\n     then if sign_r_pos (1 * (p1 * p2)) x then 1 else - 1 else 0) =\n    (if p1 \\<noteq> 0 \\<and> odd (order x p1)\n     then if (0 < poly p2 x) = sign_r_pos p1 x then 1 else - 1 else 0)", "using order_mult[OF \\<open>p1*p2\\<noteq>0\\<close>]\n        sign_r_pos_mult[OF \\<open>p1\\<noteq>0\\<close> \\<open>p2\\<noteq>0\\<close>] sign_r_pos_rec[OF \\<open>p2\\<noteq>0\\<close>] \\<open>poly p2 x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  order ?a (p1 * p2) = order ?a p1 + order ?a p2\n  sign_r_pos (p1 * p2) ?x = (sign_r_pos p1 ?x = sign_r_pos p2 ?x)\n  sign_r_pos p2 ?x =\n  (if poly p2 ?x = 0 then sign_r_pos (pderiv p2) ?x else 0 < poly p2 ?x)\n  poly p2 x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if p1 * p2 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x (p1 * p2) - order x 1)\n     then if sign_r_pos (1 * (p1 * p2)) x then 1 else - 1 else 0) =\n    (if p1 \\<noteq> 0 \\<and> odd (order x p1)\n     then if (0 < poly p2 x) = sign_r_pos p1 x then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  jump_poly 1 (p1 * p2) x = simpL\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "moreover"], ["proof (state)\nthis:\n  jump_poly 1 (p1 * p2) x = simpL\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "have \"poly p2 x>0 \\<Longrightarrow> simpL =?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p2 x \\<Longrightarrow>\n    simpL =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "unfolding simpL_def jump_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p2 x \\<Longrightarrow>\n    (if p1 \\<noteq> 0 \\<and> odd (order x p1)\n     then if (0 < poly p2 x) = sign_r_pos p1 x then 1 else - 1 else 0) =\n    sign (poly p2 x) *\n    (if p1 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p1 - order x 1)\n     then if sign_r_pos (1 * p1) x then 1 else - 1 else 0) +\n    sign (poly p1 x) *\n    (if p2 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p2 - order x 1)\n     then if sign_r_pos (1 * p2) x then 1 else - 1 else 0)", "using jump_poly_not_root[OF \\<open>poly p2 x\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  jump_poly ?q p2 x = 0\n\ngoal (1 subgoal):\n 1. 0 < poly p2 x \\<Longrightarrow>\n    (if p1 \\<noteq> 0 \\<and> odd (order x p1)\n     then if (0 < poly p2 x) = sign_r_pos p1 x then 1 else - 1 else 0) =\n    sign (poly p2 x) *\n    (if p1 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p1 - order x 1)\n     then if sign_r_pos (1 * p1) x then 1 else - 1 else 0) +\n    sign (poly p1 x) *\n    (if p2 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p2 - order x 1)\n     then if sign_r_pos (1 * p2) x then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  0 < poly p2 x \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "moreover"], ["proof (state)\nthis:\n  0 < poly p2 x \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "have \"poly p2 x<0 \\<Longrightarrow> simpL =?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p2 x < 0 \\<Longrightarrow>\n    simpL =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "unfolding simpL_def jump_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p2 x < 0 \\<Longrightarrow>\n    (if p1 \\<noteq> 0 \\<and> odd (order x p1)\n     then if (0 < poly p2 x) = sign_r_pos p1 x then 1 else - 1 else 0) =\n    sign (poly p2 x) *\n    (if p1 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p1 - order x 1)\n     then if sign_r_pos (1 * p1) x then 1 else - 1 else 0) +\n    sign (poly p1 x) *\n    (if p2 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p2 - order x 1)\n     then if sign_r_pos (1 * p2) x then 1 else - 1 else 0)", "using jump_poly_not_root[OF \\<open>poly p2 x\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  jump_poly ?q p2 x = 0\n\ngoal (1 subgoal):\n 1. poly p2 x < 0 \\<Longrightarrow>\n    (if p1 \\<noteq> 0 \\<and> odd (order x p1)\n     then if (0 < poly p2 x) = sign_r_pos p1 x then 1 else - 1 else 0) =\n    sign (poly p2 x) *\n    (if p1 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p1 - order x 1)\n     then if sign_r_pos (1 * p1) x then 1 else - 1 else 0) +\n    sign (poly p1 x) *\n    (if p2 \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x p2 - order x 1)\n     then if sign_r_pos (1 * p2) x then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  poly p2 x < 0 \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "ultimately"], ["proof (chain)\npicking this:\n  jump_poly 1 (p1 * p2) x = simpL\n  0 < poly p2 x \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n  poly p2 x < 0 \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x", "show \"?L=?R\""], ["proof (prove)\nusing this:\n  jump_poly 1 (p1 * p2) x = simpL\n  0 < poly p2 x \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n  poly p2 x < 0 \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "using \\<open>poly p2 x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  jump_poly 1 (p1 * p2) x = simpL\n  0 < poly p2 x \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n  poly p2 x < 0 \\<Longrightarrow>\n  simpL =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n  poly p2 x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "by (metis linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  jump_poly 1 (p1 * p2) x =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p2 x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly 1 (p1 * p2) x =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal (1 subgoal):\n 1. \\<not> (p1 = 0 \\<or> p2 = 0) \\<Longrightarrow>\n    jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "ultimately"], ["proof (chain)\npicking this:\n  poly p1 x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly 1 (p1 * p2) x =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n  poly p2 x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly 1 (p1 * p2) x =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x", "show ?thesis"], ["proof (prove)\nusing this:\n  poly p1 x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly 1 (p1 * p2) x =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n  poly p2 x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly 1 (p1 * p2) x =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "using assms"], ["proof (prove)\nusing this:\n  poly p1 x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly 1 (p1 * p2) x =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n  poly p2 x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly 1 (p1 * p2) x =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n  poly p1 x \\<noteq> 0 \\<or> poly p2 x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p1 * p2) x =\n    sign (poly p2 x) * jump_poly 1 p1 x +\n    sign (poly p1 x) * jump_poly 1 p2 x", "by auto"], ["proof (state)\nthis:\n  jump_poly 1 (p1 * p2) x =\n  sign (poly p2 x) * jump_poly 1 p1 x + sign (poly p1 x) * jump_poly 1 p2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jump_poly_mod:\n  fixes p q::\"real poly\" \n  shows \"jump_poly q p x= jump_poly (q mod p) p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly q p x = jump_poly (q mod p) p x", "proof (cases \"q=0 \\<or> p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q = 0 \\<or> p = 0 \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x\n 2. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "case True"], ["proof (state)\nthis:\n  q = 0 \\<or> p = 0\n\ngoal (2 subgoals):\n 1. q = 0 \\<or> p = 0 \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x\n 2. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "thus ?thesis"], ["proof (prove)\nusing this:\n  q = 0 \\<or> p = 0\n\ngoal (1 subgoal):\n 1. jump_poly q p x = jump_poly (q mod p) p x", "by fastforce"], ["proof (state)\nthis:\n  jump_poly q p x = jump_poly (q mod p) p x\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "case False"], ["proof (state)\nthis:\n  \\<not> (q = 0 \\<or> p = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "then"], ["proof (chain)\npicking this:\n  \\<not> (q = 0 \\<or> p = 0)", "have \"p\\<noteq>0\" \"q\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<not> (q = 0 \\<or> p = 0)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "define n where \"n\\<equiv>min (order x q) (order x p)\""], ["proof (state)\nthis:\n  n \\<equiv> min (order x q) (order x p)\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "obtain q' where q':\"q=[:-x,1:]^n * q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        q = [:- x, 1:] ^ n * q' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using n_def  power_le_dvd[OF order_1[of x q], of n]"], ["proof (prove)\nusing this:\n  n \\<equiv> min (order x q) (order x p)\n  n \\<le> order x q \\<Longrightarrow> [:- x, 1:] ^ n dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        q = [:- x, 1:] ^ n * q' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis dvdE min.cobounded2 min.commute)"], ["proof (state)\nthis:\n  q = [:- x, 1:] ^ n * q'\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "obtain p' where p':\"p=[:-x,1:]^n * p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p = [:- x, 1:] ^ n * p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using n_def  power_le_dvd[OF order_1[of x p], of n]"], ["proof (prove)\nusing this:\n  n \\<equiv> min (order x q) (order x p)\n  n \\<le> order x p \\<Longrightarrow> [:- x, 1:] ^ n dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p = [:- x, 1:] ^ n * p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis dvdE min.cobounded2)"], ["proof (state)\nthis:\n  p = [:- x, 1:] ^ n * p'\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "have \"q'\\<noteq>0\" and \"p'\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q' \\<noteq> 0 &&& p' \\<noteq> 0", "using q' p' \\<open>p\\<noteq>0\\<close> \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q = [:- x, 1:] ^ n * q'\n  p = [:- x, 1:] ^ n * p'\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q' \\<noteq> 0 &&& p' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q' \\<noteq> 0\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "have \"order x q'=0 \\<or> order x p'=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x q' = 0 \\<or> order x p' = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (order x q' = 0 \\<or> order x p' = 0) \\<Longrightarrow> False", "assume \"\\<not> (order x q' = 0 \\<or> order x p' = 0)\""], ["proof (state)\nthis:\n  \\<not> (order x q' = 0 \\<or> order x p' = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (order x q' = 0 \\<or> order x p' = 0) \\<Longrightarrow> False", "hence \"order x q' > 0\" and \"order x p' > 0\""], ["proof (prove)\nusing this:\n  \\<not> (order x q' = 0 \\<or> order x p' = 0)\n\ngoal (1 subgoal):\n 1. 0 < order x q' &&& 0 < order x p'", "by auto"], ["proof (state)\nthis:\n  0 < order x q'\n  0 < order x p'\n\ngoal (1 subgoal):\n 1. \\<not> (order x q' = 0 \\<or> order x p' = 0) \\<Longrightarrow> False", "hence \"order x q>n\" and \"order x p>n\""], ["proof (prove)\nusing this:\n  0 < order x q'\n  0 < order x p'\n\ngoal (1 subgoal):\n 1. n < order x q &&& n < order x p", "unfolding q' p'"], ["proof (prove)\nusing this:\n  0 < order x q'\n  0 < order x p'\n\ngoal (1 subgoal):\n 1. n < order x ([:- x, 1:] ^ n * q') &&& n < order x ([:- x, 1:] ^ n * p')", "using order_mult[OF \\<open>q\\<noteq>0\\<close>[unfolded q'],of x] order_mult[OF \\<open>p\\<noteq>0\\<close>[unfolded p'],of x] \n          order_power_n_n[of x n]"], ["proof (prove)\nusing this:\n  0 < order x q'\n  0 < order x p'\n  order x ([:- x, 1:] ^ n * q') = order x ([:- x, 1:] ^ n) + order x q'\n  order x ([:- x, 1:] ^ n * p') = order x ([:- x, 1:] ^ n) + order x p'\n  order x ([:- x, 1:] ^ n) = n\n\ngoal (1 subgoal):\n 1. n < order x ([:- x, 1:] ^ n * q') &&& n < order x ([:- x, 1:] ^ n * p')", "by auto"], ["proof (state)\nthis:\n  n < order x q\n  n < order x p\n\ngoal (1 subgoal):\n 1. \\<not> (order x q' = 0 \\<or> order x p' = 0) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  n < order x q\n  n < order x p\n\ngoal (1 subgoal):\n 1. False", "using n_def"], ["proof (prove)\nusing this:\n  n < order x q\n  n < order x p\n  n \\<equiv> min (order x q) (order x p)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order x q' = 0 \\<or> order x p' = 0\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "have cond:\"q' \\<noteq> 0 \\<and> odd (order x p' - order x q') \n    = (q' mod p' \\<noteq>0 \\<and> odd(order x p' - order x (q' mod p')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "proof (cases \"order x p'=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. order x p' = 0 \\<Longrightarrow>\n    q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))\n 2. order x p' \\<noteq> 0 \\<Longrightarrow>\n    q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "case True"], ["proof (state)\nthis:\n  order x p' = 0\n\ngoal (2 subgoals):\n 1. order x p' = 0 \\<Longrightarrow>\n    q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))\n 2. order x p' \\<noteq> 0 \\<Longrightarrow>\n    q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "thus ?thesis"], ["proof (prove)\nusing this:\n  order x p' = 0\n\ngoal (1 subgoal):\n 1. q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "by (metis \\<open>q' \\<noteq> 0\\<close> even_zero zero_diff)"], ["proof (state)\nthis:\n  q' \\<noteq> 0 \\<and>\n  odd (order x p' - order x q') =\n  (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))\n\ngoal (1 subgoal):\n 1. order x p' \\<noteq> 0 \\<Longrightarrow>\n    q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. order x p' \\<noteq> 0 \\<Longrightarrow>\n    q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "case False"], ["proof (state)\nthis:\n  order x p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x p' \\<noteq> 0 \\<Longrightarrow>\n    q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "hence \"order x q'=0\""], ["proof (prove)\nusing this:\n  order x p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x q' = 0", "using \\<open>order x q'=0 \\<or> order x p'=0\\<close>"], ["proof (prove)\nusing this:\n  order x p' \\<noteq> 0\n  order x q' = 0 \\<or> order x p' = 0\n\ngoal (1 subgoal):\n 1. order x q' = 0", "by auto"], ["proof (state)\nthis:\n  order x q' = 0\n\ngoal (1 subgoal):\n 1. order x p' \\<noteq> 0 \\<Longrightarrow>\n    q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "hence \"\\<not> [:-x,1:] dvd q'\""], ["proof (prove)\nusing this:\n  order x q' = 0\n\ngoal (1 subgoal):\n 1. \\<not> [:- x, 1:] dvd q'", "by (metis \\<open>q' \\<noteq> 0\\<close> order_root poly_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  \\<not> [:- x, 1:] dvd q'\n\ngoal (1 subgoal):\n 1. order x p' \\<noteq> 0 \\<Longrightarrow>\n    q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "moreover"], ["proof (state)\nthis:\n  \\<not> [:- x, 1:] dvd q'\n\ngoal (1 subgoal):\n 1. order x p' \\<noteq> 0 \\<Longrightarrow>\n    q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "have \"[:-x,1:] dvd p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- x, 1:] dvd p'", "using False"], ["proof (prove)\nusing this:\n  order x p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [:- x, 1:] dvd p'", "by (metis order_root poly_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  [:- x, 1:] dvd p'\n\ngoal (1 subgoal):\n 1. order x p' \\<noteq> 0 \\<Longrightarrow>\n    q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> [:- x, 1:] dvd q'\n  [:- x, 1:] dvd p'", "have \"\\<not> [:-x,1:] dvd (q' mod p')\""], ["proof (prove)\nusing this:\n  \\<not> [:- x, 1:] dvd q'\n  [:- x, 1:] dvd p'\n\ngoal (1 subgoal):\n 1. \\<not> [:- x, 1:] dvd q' mod p'", "by (metis dvd_mod_iff)"], ["proof (state)\nthis:\n  \\<not> [:- x, 1:] dvd q' mod p'\n\ngoal (1 subgoal):\n 1. order x p' \\<noteq> 0 \\<Longrightarrow>\n    q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "hence \"order x (q' mod p') = 0\" and \"q' mod p' \\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<not> [:- x, 1:] dvd q' mod p'\n\ngoal (1 subgoal):\n 1. order x (q' mod p') = 0 &&& q' mod p' \\<noteq> 0", "apply (metis order_root poly_eq_0_iff_dvd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q' mod p' \\<noteq> 0", "by (metis \\<open>\\<not> [:- x, 1:] dvd q' mod p'\\<close> dvd_0_right)"], ["proof (state)\nthis:\n  order x (q' mod p') = 0\n  q' mod p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x p' \\<noteq> 0 \\<Longrightarrow>\n    q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "thus ?thesis"], ["proof (prove)\nusing this:\n  order x (q' mod p') = 0\n  q' mod p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "using \\<open>order x q'=0\\<close>"], ["proof (prove)\nusing this:\n  order x (q' mod p') = 0\n  q' mod p' \\<noteq> 0\n  order x q' = 0\n\ngoal (1 subgoal):\n 1. q' \\<noteq> 0 \\<and>\n    odd (order x p' - order x q') =\n    (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))", "by auto"], ["proof (state)\nthis:\n  q' \\<noteq> 0 \\<and>\n  odd (order x p' - order x q') =\n  (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q' \\<noteq> 0 \\<and>\n  odd (order x p' - order x q') =\n  (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "moreover"], ["proof (state)\nthis:\n  q' \\<noteq> 0 \\<and>\n  odd (order x p' - order x q') =\n  (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "have \"q' mod p'\\<noteq>0 \\<Longrightarrow> poly p' x = 0  \n      \\<Longrightarrow> sign_r_pos (q' * p') x= sign_r_pos (q' mod p' * p') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' mod p' \\<noteq> 0; poly p' x = 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (q' * p') x = sign_r_pos (q' mod p' * p') x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>q' mod p' \\<noteq> 0; poly p' x = 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (q' * p') x = sign_r_pos (q' mod p' * p') x", "assume \"q' mod p'\\<noteq>0\" \"poly p' x = 0\""], ["proof (state)\nthis:\n  q' mod p' \\<noteq> 0\n  poly p' x = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q' mod p' \\<noteq> 0; poly p' x = 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (q' * p') x = sign_r_pos (q' mod p' * p') x", "hence \"poly q' x\\<noteq>0\""], ["proof (prove)\nusing this:\n  q' mod p' \\<noteq> 0\n  poly p' x = 0\n\ngoal (1 subgoal):\n 1. poly q' x \\<noteq> 0", "using \\<open>order x q'=0 \\<or> order x p'=0\\<close>"], ["proof (prove)\nusing this:\n  q' mod p' \\<noteq> 0\n  poly p' x = 0\n  order x q' = 0 \\<or> order x p' = 0\n\ngoal (1 subgoal):\n 1. poly q' x \\<noteq> 0", "by (metis \\<open>p' \\<noteq> 0\\<close> \\<open>q' \\<noteq> 0\\<close> order_root)"], ["proof (state)\nthis:\n  poly q' x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q' mod p' \\<noteq> 0; poly p' x = 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (q' * p') x = sign_r_pos (q' mod p' * p') x", "hence \"sign_r_pos q' x= sign_r_pos (q' mod p') x\""], ["proof (prove)\nusing this:\n  poly q' x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_r_pos q' x = sign_r_pos (q' mod p') x", "using sign_r_pos_mod[OF \\<open>poly p' x=0\\<close>]"], ["proof (prove)\nusing this:\n  poly q' x \\<noteq> 0\n  poly ?q x \\<noteq> 0 \\<Longrightarrow>\n  sign_r_pos (?q mod p') x = sign_r_pos ?q x\n\ngoal (1 subgoal):\n 1. sign_r_pos q' x = sign_r_pos (q' mod p') x", "by auto"], ["proof (state)\nthis:\n  sign_r_pos q' x = sign_r_pos (q' mod p') x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q' mod p' \\<noteq> 0; poly p' x = 0\\<rbrakk>\n    \\<Longrightarrow> sign_r_pos (q' * p') x = sign_r_pos (q' mod p' * p') x", "thus ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos q' x = sign_r_pos (q' mod p') x\n\ngoal (1 subgoal):\n 1. sign_r_pos (q' * p') x = sign_r_pos (q' mod p' * p') x", "unfolding sign_r_pos_mult[OF \\<open>q'\\<noteq>0\\<close> \\<open>p'\\<noteq>0\\<close>] sign_r_pos_mult[OF \\<open>q' mod p'\\<noteq>0\\<close> \\<open>p'\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  sign_r_pos q' x = sign_r_pos (q' mod p') x\n\ngoal (1 subgoal):\n 1. (sign_r_pos q' x = sign_r_pos p' x) =\n    (sign_r_pos (q' mod p') x = sign_r_pos p' x)", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (q' * p') x = sign_r_pos (q' mod p' * p') x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>q' mod p' \\<noteq> 0; poly p' x = 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (q' * p') x = sign_r_pos (q' mod p' * p') x\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>q' mod p' \\<noteq> 0; poly p' x = 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (q' * p') x = sign_r_pos (q' mod p' * p') x\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "have \"q' mod p' = 0 \\<or> poly p' x \\<noteq> 0 \\<Longrightarrow> jump_poly q' p' x = jump_poly (q' mod p') p' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q' mod p' = 0 \\<or> poly p' x \\<noteq> 0 \\<Longrightarrow>\n    jump_poly q' p' x = jump_poly (q' mod p') p' x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q' mod p' = 0 \\<or> poly p' x \\<noteq> 0 \\<Longrightarrow>\n    jump_poly q' p' x = jump_poly (q' mod p') p' x", "assume assm:\"q' mod p' = 0 \\<or> poly p' x \\<noteq> 0\""], ["proof (state)\nthis:\n  q' mod p' = 0 \\<or> poly p' x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q' mod p' = 0 \\<or> poly p' x \\<noteq> 0 \\<Longrightarrow>\n    jump_poly q' p' x = jump_poly (q' mod p') p' x", "have \"q' mod p' = 0 \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q' mod p' = 0 \\<Longrightarrow>\n    jump_poly q' p' x = jump_poly (q' mod p') p' x", "unfolding jump_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. q' mod p' = 0 \\<Longrightarrow>\n    (if p' \\<noteq> 0 \\<and>\n        q' \\<noteq> 0 \\<and> odd (order x p' - order x q')\n     then if sign_r_pos (q' * p') x then 1 else - 1 else 0) =\n    (if p' \\<noteq> 0 \\<and>\n        q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p'))\n     then if sign_r_pos (q' mod p' * p') x then 1 else - 1 else 0)", "using cond"], ["proof (prove)\nusing this:\n  q' \\<noteq> 0 \\<and>\n  odd (order x p' - order x q') =\n  (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))\n\ngoal (1 subgoal):\n 1. q' mod p' = 0 \\<Longrightarrow>\n    (if p' \\<noteq> 0 \\<and>\n        q' \\<noteq> 0 \\<and> odd (order x p' - order x q')\n     then if sign_r_pos (q' * p') x then 1 else - 1 else 0) =\n    (if p' \\<noteq> 0 \\<and>\n        q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p'))\n     then if sign_r_pos (q' mod p' * p') x then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  q' mod p' = 0 \\<Longrightarrow>\n  jump_poly q' p' x = jump_poly (q' mod p') p' x\n\ngoal (1 subgoal):\n 1. q' mod p' = 0 \\<or> poly p' x \\<noteq> 0 \\<Longrightarrow>\n    jump_poly q' p' x = jump_poly (q' mod p') p' x", "moreover"], ["proof (state)\nthis:\n  q' mod p' = 0 \\<Longrightarrow>\n  jump_poly q' p' x = jump_poly (q' mod p') p' x\n\ngoal (1 subgoal):\n 1. q' mod p' = 0 \\<or> poly p' x \\<noteq> 0 \\<Longrightarrow>\n    jump_poly q' p' x = jump_poly (q' mod p') p' x", "have \"poly p' x \\<noteq> 0 \n        \\<Longrightarrow> \\<not> odd (order x p' - order x q') \\<and> \\<not> odd(order x p' - order x (q' mod p'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p' x \\<noteq> 0 \\<Longrightarrow>\n    \\<not> odd (order x p' - order x q') \\<and>\n    \\<not> odd (order x p' - order x (q' mod p'))", "by (metis even_zero order_root zero_diff)"], ["proof (state)\nthis:\n  poly p' x \\<noteq> 0 \\<Longrightarrow>\n  \\<not> odd (order x p' - order x q') \\<and>\n  \\<not> odd (order x p' - order x (q' mod p'))\n\ngoal (1 subgoal):\n 1. q' mod p' = 0 \\<or> poly p' x \\<noteq> 0 \\<Longrightarrow>\n    jump_poly q' p' x = jump_poly (q' mod p') p' x", "hence \"poly p' x \\<noteq> 0 \\<Longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  poly p' x \\<noteq> 0 \\<Longrightarrow>\n  \\<not> odd (order x p' - order x q') \\<and>\n  \\<not> odd (order x p' - order x (q' mod p'))\n\ngoal (1 subgoal):\n 1. poly p' x \\<noteq> 0 \\<Longrightarrow>\n    jump_poly q' p' x = jump_poly (q' mod p') p' x", "unfolding jump_poly_def"], ["proof (prove)\nusing this:\n  poly p' x \\<noteq> 0 \\<Longrightarrow>\n  \\<not> odd (order x p' - order x q') \\<and>\n  \\<not> odd (order x p' - order x (q' mod p'))\n\ngoal (1 subgoal):\n 1. poly p' x \\<noteq> 0 \\<Longrightarrow>\n    (if p' \\<noteq> 0 \\<and>\n        q' \\<noteq> 0 \\<and> odd (order x p' - order x q')\n     then if sign_r_pos (q' * p') x then 1 else - 1 else 0) =\n    (if p' \\<noteq> 0 \\<and>\n        q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p'))\n     then if sign_r_pos (q' mod p' * p') x then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  poly p' x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly q' p' x = jump_poly (q' mod p') p' x\n\ngoal (1 subgoal):\n 1. q' mod p' = 0 \\<or> poly p' x \\<noteq> 0 \\<Longrightarrow>\n    jump_poly q' p' x = jump_poly (q' mod p') p' x", "ultimately"], ["proof (chain)\npicking this:\n  q' mod p' = 0 \\<Longrightarrow>\n  jump_poly q' p' x = jump_poly (q' mod p') p' x\n  poly p' x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly q' p' x = jump_poly (q' mod p') p' x", "show ?thesis"], ["proof (prove)\nusing this:\n  q' mod p' = 0 \\<Longrightarrow>\n  jump_poly q' p' x = jump_poly (q' mod p') p' x\n  poly p' x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly q' p' x = jump_poly (q' mod p') p' x\n\ngoal (1 subgoal):\n 1. jump_poly q' p' x = jump_poly (q' mod p') p' x", "using assm"], ["proof (prove)\nusing this:\n  q' mod p' = 0 \\<Longrightarrow>\n  jump_poly q' p' x = jump_poly (q' mod p') p' x\n  poly p' x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly q' p' x = jump_poly (q' mod p') p' x\n  q' mod p' = 0 \\<or> poly p' x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump_poly q' p' x = jump_poly (q' mod p') p' x", "by auto"], ["proof (state)\nthis:\n  jump_poly q' p' x = jump_poly (q' mod p') p' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q' mod p' = 0 \\<or> poly p' x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly q' p' x = jump_poly (q' mod p') p' x\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "ultimately"], ["proof (chain)\npicking this:\n  q' \\<noteq> 0 \\<and>\n  odd (order x p' - order x q') =\n  (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))\n  \\<lbrakk>q' mod p' \\<noteq> 0; poly p' x = 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (q' * p') x = sign_r_pos (q' mod p' * p') x\n  q' mod p' = 0 \\<or> poly p' x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly q' p' x = jump_poly (q' mod p') p' x", "have \" jump_poly q' p' x = jump_poly (q' mod p') p' x\""], ["proof (prove)\nusing this:\n  q' \\<noteq> 0 \\<and>\n  odd (order x p' - order x q') =\n  (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))\n  \\<lbrakk>q' mod p' \\<noteq> 0; poly p' x = 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (q' * p') x = sign_r_pos (q' mod p' * p') x\n  q' mod p' = 0 \\<or> poly p' x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly q' p' x = jump_poly (q' mod p') p' x\n\ngoal (1 subgoal):\n 1. jump_poly q' p' x = jump_poly (q' mod p') p' x", "unfolding jump_poly_def"], ["proof (prove)\nusing this:\n  q' \\<noteq> 0 \\<and>\n  odd (order x p' - order x q') =\n  (q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p')))\n  \\<lbrakk>q' mod p' \\<noteq> 0; poly p' x = 0\\<rbrakk>\n  \\<Longrightarrow> sign_r_pos (q' * p') x = sign_r_pos (q' mod p' * p') x\n  q' mod p' = 0 \\<or> poly p' x \\<noteq> 0 \\<Longrightarrow>\n  (if p' \\<noteq> 0 \\<and>\n      q' \\<noteq> 0 \\<and> odd (order x p' - order x q')\n   then if sign_r_pos (q' * p') x then 1 else - 1 else 0) =\n  (if p' \\<noteq> 0 \\<and>\n      q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p'))\n   then if sign_r_pos (q' mod p' * p') x then 1 else - 1 else 0)\n\ngoal (1 subgoal):\n 1. (if p' \\<noteq> 0 \\<and>\n        q' \\<noteq> 0 \\<and> odd (order x p' - order x q')\n     then if sign_r_pos (q' * p') x then 1 else - 1 else 0) =\n    (if p' \\<noteq> 0 \\<and>\n        q' mod p' \\<noteq> 0 \\<and> odd (order x p' - order x (q' mod p'))\n     then if sign_r_pos (q' mod p' * p') x then 1 else - 1 else 0)", "by force"], ["proof (state)\nthis:\n  jump_poly q' p' x = jump_poly (q' mod p') p' x\n\ngoal (1 subgoal):\n 1. \\<not> (q = 0 \\<or> p = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly (q mod p) p x", "thus ?thesis"], ["proof (prove)\nusing this:\n  jump_poly q' p' x = jump_poly (q' mod p') p' x\n\ngoal (1 subgoal):\n 1. jump_poly q p x = jump_poly (q mod p) p x", "using p' q' jump_poly_mult"], ["proof (prove)\nusing this:\n  jump_poly q' p' x = jump_poly (q' mod p') p' x\n  p = [:- x, 1:] ^ n * p'\n  q = [:- x, 1:] ^ n * q'\n  ?p' \\<noteq> 0 \\<Longrightarrow>\n  jump_poly (?p' * ?q) (?p' * ?p) ?x = jump_poly ?q ?p ?x\n\ngoal (1 subgoal):\n 1. jump_poly q p x = jump_poly (q mod p) p x", "by auto"], ["proof (state)\nthis:\n  jump_poly q p x = jump_poly (q mod p) p x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jump_poly_coprime:\n  fixes p q:: \"real poly\"\n  assumes \"poly p x=0\" \"coprime p q\"\n  shows \"jump_poly q p x= jump_poly 1 (q*p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly q p x = jump_poly 1 (q * p) x", "proof (cases \"p=0 \\<or> q=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    jump_poly q p x = jump_poly 1 (q * p) x\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly 1 (q * p) x", "case True"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    jump_poly q p x = jump_poly 1 (q * p) x\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  p = 0 \\<or> q = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0\n\ngoal (1 subgoal):\n 1. jump_poly q p x = jump_poly 1 (q * p) x", "by auto"], ["proof (state)\nthis:\n  jump_poly q p x = jump_poly 1 (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly 1 (q * p) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly 1 (q * p) x", "case False"], ["proof (state)\nthis:\n  \\<not> (p = 0 \\<or> q = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  \\<not> (p = 0 \\<or> q = 0)", "have \"p\\<noteq>0\" \"q\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> q = 0)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  q \\<noteq> 0", "have \"poly p x\\<noteq>0 \\<or> poly q x\\<noteq>0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0 \\<or> poly q x \\<noteq> 0", "using coprime_poly_0[OF \\<open>coprime p q\\<close>]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  poly p ?x \\<noteq> 0 \\<or> poly q ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0 \\<or> poly q x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p x \\<noteq> 0 \\<or> poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  poly p x \\<noteq> 0 \\<or> poly q x \\<noteq> 0", "have \"poly q x\\<noteq>0\""], ["proof (prove)\nusing this:\n  poly p x \\<noteq> 0 \\<or> poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0", "using \\<open>poly p x=0\\<close>"], ["proof (prove)\nusing this:\n  poly p x \\<noteq> 0 \\<or> poly q x \\<noteq> 0\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  poly q x \\<noteq> 0", "have \"order x q=0\""], ["proof (prove)\nusing this:\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x q = 0", "using order_root"], ["proof (prove)\nusing this:\n  poly q x \\<noteq> 0\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. order x q = 0", "by blast"], ["proof (state)\nthis:\n  order x q = 0\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  order x q = 0", "have \"order x p - order x q = order x (q * p)\""], ["proof (prove)\nusing this:\n  order x q = 0\n\ngoal (1 subgoal):\n 1. order x p - order x q = order x (q * p)", "using \\<open>p\\<noteq>0\\<close> \\<open>q\\<noteq>0\\<close> order_mult [of q p x]"], ["proof (prove)\nusing this:\n  order x q = 0\n  p \\<noteq> 0\n  q \\<noteq> 0\n  q * p \\<noteq> 0 \\<Longrightarrow> order x (q * p) = order x q + order x p\n\ngoal (1 subgoal):\n 1. order x p - order x q = order x (q * p)", "by auto"], ["proof (state)\nthis:\n  order x p - order x q = order x (q * p)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jump_poly q p x = jump_poly 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  order x p - order x q = order x (q * p)", "show ?thesis"], ["proof (prove)\nusing this:\n  order x p - order x q = order x (q * p)\n\ngoal (1 subgoal):\n 1. jump_poly q p x = jump_poly 1 (q * p) x", "unfolding jump_poly_def"], ["proof (prove)\nusing this:\n  order x p - order x q = order x (q * p)\n\ngoal (1 subgoal):\n 1. (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> odd (order x p - order x q)\n     then if sign_r_pos (q * p) x then 1 else - 1 else 0) =\n    (if q * p \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x (q * p) - order x 1)\n     then if sign_r_pos (1 * (q * p)) x then 1 else - 1 else 0)", "using \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  order x p - order x q = order x (q * p)\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> odd (order x p - order x q)\n     then if sign_r_pos (q * p) x then 1 else - 1 else 0) =\n    (if q * p \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order x (q * p) - order x 1)\n     then if sign_r_pos (1 * (q * p)) x then 1 else - 1 else 0)", "by auto"], ["proof (state)\nthis:\n  jump_poly q p x = jump_poly 1 (q * p) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jump_poly_sgn:\n  fixes p q:: \"real poly\"\n  assumes \"p\\<noteq>0\" \"poly p x=0\"\n  shows \"jump_poly (pderiv p * q) p x = sign (poly q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly (pderiv p * q) p x = sign (poly q x)", "proof (cases \"q=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow> jump_poly (pderiv p * q) p x = sign (poly q x)\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    jump_poly (pderiv p * q) p x = sign (poly q x)", "case True"], ["proof (state)\nthis:\n  q = 0\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow> jump_poly (pderiv p * q) p x = sign (poly q x)\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    jump_poly (pderiv p * q) p x = sign (poly q x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  q = 0\n\ngoal (1 subgoal):\n 1. jump_poly (pderiv p * q) p x = sign (poly q x)", "by auto"], ["proof (state)\nthis:\n  jump_poly (pderiv p * q) p x = sign (poly q x)\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump_poly (pderiv p * q) p x = sign (poly q x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump_poly (pderiv p * q) p x = sign (poly q x)", "case False"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump_poly (pderiv p * q) p x = sign (poly q x)", "have \"pderiv p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0", "using \\<open>p\\<noteq>0\\<close> \\<open>poly p x=0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0", "by (metis mult_poly_0_left sign_r_pos_0 sign_r_pos_pderiv)"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump_poly (pderiv p * q) p x = sign (poly q x)", "have elim_p_order: \"order x p - order x (pderiv p * q)=1 - order x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p - order x (pderiv p * q) = 1 - order x q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order x p - order x (pderiv p * q) = 1 - order x q", "have \"order x p - order x (pderiv p * q) = order x p - order x (pderiv p) - order x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p - order x (pderiv p * q) =\n    order x p - order x (pderiv p) - order x q", "using order_mult \\<open>pderiv p\\<noteq>0\\<close> False"], ["proof (prove)\nusing this:\n  ?p * ?q \\<noteq> 0 \\<Longrightarrow>\n  order ?a (?p * ?q) = order ?a ?p + order ?a ?q\n  pderiv p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x p - order x (pderiv p * q) =\n    order x p - order x (pderiv p) - order x q", "by (metis diff_diff_left mult_eq_0_iff)"], ["proof (state)\nthis:\n  order x p - order x (pderiv p * q) =\n  order x p - order x (pderiv p) - order x q\n\ngoal (1 subgoal):\n 1. order x p - order x (pderiv p * q) = 1 - order x q", "moreover"], ["proof (state)\nthis:\n  order x p - order x (pderiv p * q) =\n  order x p - order x (pderiv p) - order x q\n\ngoal (1 subgoal):\n 1. order x p - order x (pderiv p * q) = 1 - order x q", "have \"order x p - order x (pderiv p) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p - order x (pderiv p) = 1", "using order_pderiv[OF \\<open>pderiv p\\<noteq>0\\<close>, of x] \\<open>poly p x=0\\<close> order_root[of p x] \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  order x p \\<noteq> 0 \\<Longrightarrow>\n  order x p = Suc (order x (pderiv p))\n  poly p x = 0\n  (poly p x = 0) = (p = 0 \\<or> order x p \\<noteq> 0)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x p - order x (pderiv p) = 1", "by auto"], ["proof (state)\nthis:\n  order x p - order x (pderiv p) = 1\n\ngoal (1 subgoal):\n 1. order x p - order x (pderiv p * q) = 1 - order x q", "ultimately"], ["proof (chain)\npicking this:\n  order x p - order x (pderiv p * q) =\n  order x p - order x (pderiv p) - order x q\n  order x p - order x (pderiv p) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  order x p - order x (pderiv p * q) =\n  order x p - order x (pderiv p) - order x q\n  order x p - order x (pderiv p) = 1\n\ngoal (1 subgoal):\n 1. order x p - order x (pderiv p * q) = 1 - order x q", "by auto"], ["proof (state)\nthis:\n  order x p - order x (pderiv p * q) = 1 - order x q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order x p - order x (pderiv p * q) = 1 - order x q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump_poly (pderiv p * q) p x = sign (poly q x)", "have elim_p_sign_r_pos:\"sign_r_pos (pderiv p * q * p) x=sign_r_pos q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * q * p) x = sign_r_pos q x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * q * p) x = sign_r_pos q x", "have \"sign_r_pos (pderiv p * q * p) x = (sign_r_pos (pderiv p* p) x \\<longleftrightarrow> sign_r_pos q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * q * p) x =\n    (sign_r_pos (pderiv p * p) x = sign_r_pos q x)", "by (metis \\<open>q \\<noteq> 0\\<close> \\<open>pderiv p \\<noteq> 0\\<close> assms(1) no_zero_divisors sign_r_pos_mult)"], ["proof (state)\nthis:\n  sign_r_pos (pderiv p * q * p) x =\n  (sign_r_pos (pderiv p * p) x = sign_r_pos q x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * q * p) x = sign_r_pos q x", "thus ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos (pderiv p * q * p) x =\n  (sign_r_pos (pderiv p * p) x = sign_r_pos q x)\n\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * q * p) x = sign_r_pos q x", "using sign_r_pos_pderiv[OF \\<open>poly p x=0\\<close> \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  sign_r_pos (pderiv p * q * p) x =\n  (sign_r_pos (pderiv p * p) x = sign_r_pos q x)\n  sign_r_pos (pderiv p * p) x\n\ngoal (1 subgoal):\n 1. sign_r_pos (pderiv p * q * p) x = sign_r_pos q x", "by auto"], ["proof (state)\nthis:\n  sign_r_pos (pderiv p * q * p) x = sign_r_pos q x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign_r_pos (pderiv p * q * p) x = sign_r_pos q x\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump_poly (pderiv p * q) p x = sign (poly q x)", "define simpleL where \"simpleL\\<equiv>if pderiv p * q \\<noteq> 0 \\<and> odd (1 - order x q) then \n      if sign_r_pos q x then 1::int else - 1 else 0\""], ["proof (state)\nthis:\n  simpleL \\<equiv>\n  if pderiv p * q \\<noteq> 0 \\<and> odd (1 - order x q)\n  then if sign_r_pos q x then 1 else - 1 else 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump_poly (pderiv p * q) p x = sign (poly q x)", "have \" jump_poly (pderiv p * q) p x =simpleL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly (pderiv p * q) p x = simpleL", "unfolding simpleL_def jump_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p \\<noteq> 0 \\<and>\n        pderiv p * q \\<noteq> 0 \\<and>\n        odd (order x p - order x (pderiv p * q))\n     then if sign_r_pos (pderiv p * q * p) x then 1 else - 1 else 0) =\n    (if pderiv p * q \\<noteq> 0 \\<and> odd (1 - order x q)\n     then if sign_r_pos q x then 1 else - 1 else 0)", "by (subst elim_p_order, subst elim_p_sign_r_pos,simp)"], ["proof (state)\nthis:\n  jump_poly (pderiv p * q) p x = simpleL\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump_poly (pderiv p * q) p x = sign (poly q x)", "moreover"], ["proof (state)\nthis:\n  jump_poly (pderiv p * q) p x = simpleL\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump_poly (pderiv p * q) p x = sign (poly q x)", "have \"poly q x=0 \\<Longrightarrow> simpleL=sign (poly q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q x = 0 \\<Longrightarrow> simpleL = sign (poly q x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly q x = 0 \\<Longrightarrow> simpleL = sign (poly q x)", "assume \"poly q x=0\""], ["proof (state)\nthis:\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. poly q x = 0 \\<Longrightarrow> simpleL = sign (poly q x)", "hence \"1-order x q = 0\""], ["proof (prove)\nusing this:\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. 1 - order x q = 0", "using \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly q x = 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 - order x q = 0", "by (metis less_one not_gr0 order_root zero_less_diff)"], ["proof (state)\nthis:\n  1 - order x q = 0\n\ngoal (1 subgoal):\n 1. poly q x = 0 \\<Longrightarrow> simpleL = sign (poly q x)", "hence \"simpleL=0\""], ["proof (prove)\nusing this:\n  1 - order x q = 0\n\ngoal (1 subgoal):\n 1. simpleL = 0", "unfolding simpleL_def"], ["proof (prove)\nusing this:\n  1 - order x q = 0\n\ngoal (1 subgoal):\n 1. (if pderiv p * q \\<noteq> 0 \\<and> odd (1 - order x q)\n     then if sign_r_pos q x then 1 else - 1 else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  simpleL = 0\n\ngoal (1 subgoal):\n 1. poly q x = 0 \\<Longrightarrow> simpleL = sign (poly q x)", "moreover"], ["proof (state)\nthis:\n  simpleL = 0\n\ngoal (1 subgoal):\n 1. poly q x = 0 \\<Longrightarrow> simpleL = sign (poly q x)", "have \"sign (poly q x)=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (poly q x) = 0", "using \\<open>poly q x=0\\<close>"], ["proof (prove)\nusing this:\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. sign (poly q x) = 0", "by auto"], ["proof (state)\nthis:\n  sign (poly q x) = 0\n\ngoal (1 subgoal):\n 1. poly q x = 0 \\<Longrightarrow> simpleL = sign (poly q x)", "ultimately"], ["proof (chain)\npicking this:\n  simpleL = 0\n  sign (poly q x) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  simpleL = 0\n  sign (poly q x) = 0\n\ngoal (1 subgoal):\n 1. simpleL = sign (poly q x)", "by auto"], ["proof (state)\nthis:\n  simpleL = sign (poly q x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly q x = 0 \\<Longrightarrow> simpleL = sign (poly q x)\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump_poly (pderiv p * q) p x = sign (poly q x)", "moreover"], ["proof (state)\nthis:\n  poly q x = 0 \\<Longrightarrow> simpleL = sign (poly q x)\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump_poly (pderiv p * q) p x = sign (poly q x)", "have \"poly q x\\<noteq>0\\<Longrightarrow> simpleL=sign (poly q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0 \\<Longrightarrow> simpleL = sign (poly q x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0 \\<Longrightarrow> simpleL = sign (poly q x)", "assume \"poly q x\\<noteq>0\""], ["proof (state)\nthis:\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0 \\<Longrightarrow> simpleL = sign (poly q x)", "hence \"odd (1 - order x q)\""], ["proof (prove)\nusing this:\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. odd (1 - order x q)", "by (simp add: order_root)"], ["proof (state)\nthis:\n  odd (1 - order x q)\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0 \\<Longrightarrow> simpleL = sign (poly q x)", "moreover"], ["proof (state)\nthis:\n  odd (1 - order x q)\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0 \\<Longrightarrow> simpleL = sign (poly q x)", "have \"pderiv p * q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv p * q \\<noteq> 0", "by (metis False \\<open>pderiv p \\<noteq> 0\\<close> no_zero_divisors)"], ["proof (state)\nthis:\n  pderiv p * q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0 \\<Longrightarrow> simpleL = sign (poly q x)", "moreover"], ["proof (state)\nthis:\n  pderiv p * q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0 \\<Longrightarrow> simpleL = sign (poly q x)", "have \"sign_r_pos q x = (poly q x > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos q x = (0 < poly q x)", "using sign_r_pos_rec[OF False] \\<open>poly q x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  sign_r_pos q ?x =\n  (if poly q ?x = 0 then sign_r_pos (pderiv q) ?x else 0 < poly q ?x)\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign_r_pos q x = (0 < poly q x)", "by auto"], ["proof (state)\nthis:\n  sign_r_pos q x = (0 < poly q x)\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0 \\<Longrightarrow> simpleL = sign (poly q x)", "ultimately"], ["proof (chain)\npicking this:\n  odd (1 - order x q)\n  pderiv p * q \\<noteq> 0\n  sign_r_pos q x = (0 < poly q x)", "have \"simpleL=(if poly q x>0 then 1 else - 1)\""], ["proof (prove)\nusing this:\n  odd (1 - order x q)\n  pderiv p * q \\<noteq> 0\n  sign_r_pos q x = (0 < poly q x)\n\ngoal (1 subgoal):\n 1. simpleL = (if 0 < poly q x then 1 else - 1)", "unfolding simpleL_def"], ["proof (prove)\nusing this:\n  odd (1 - order x q)\n  pderiv p * q \\<noteq> 0\n  sign_r_pos q x = (0 < poly q x)\n\ngoal (1 subgoal):\n 1. (if pderiv p * q \\<noteq> 0 \\<and> odd (1 - order x q)\n     then if sign_r_pos q x then 1 else - 1 else 0) =\n    (if 0 < poly q x then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  simpleL = (if 0 < poly q x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0 \\<Longrightarrow> simpleL = sign (poly q x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  simpleL = (if 0 < poly q x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. simpleL = sign (poly q x)", "using \\<open>poly q x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  simpleL = (if 0 < poly q x then 1 else - 1)\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. simpleL = sign (poly q x)", "by auto"], ["proof (state)\nthis:\n  simpleL = sign (poly q x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly q x \\<noteq> 0 \\<Longrightarrow> simpleL = sign (poly q x)\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    jump_poly (pderiv p * q) p x = sign (poly q x)", "ultimately"], ["proof (chain)\npicking this:\n  jump_poly (pderiv p * q) p x = simpleL\n  poly q x = 0 \\<Longrightarrow> simpleL = sign (poly q x)\n  poly q x \\<noteq> 0 \\<Longrightarrow> simpleL = sign (poly q x)", "show ?thesis"], ["proof (prove)\nusing this:\n  jump_poly (pderiv p * q) p x = simpleL\n  poly q x = 0 \\<Longrightarrow> simpleL = sign (poly q x)\n  poly q x \\<noteq> 0 \\<Longrightarrow> simpleL = sign (poly q x)\n\ngoal (1 subgoal):\n 1. jump_poly (pderiv p * q) p x = sign (poly q x)", "by force"], ["proof (state)\nthis:\n  jump_poly (pderiv p * q) p x = sign (poly q x)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Cauchy index\\<close>"], ["", "definition cindex_poly:: \"real \\<Rightarrow> real \\<Rightarrow> real poly \\<Rightarrow> real poly \\<Rightarrow> int\" \n  where \n  \"cindex_poly a b q p\\<equiv> (\\<Sum>x\\<in>{x. poly p x=0 \\<and> a< x\\<and> x< b}. jump_poly q p x)\""], ["", "lemma cindex_poly_0[simp]: \"cindex_poly a b 0 p = 0\" \"cindex_poly a b q 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b 0 p = 0 &&& cindex_poly a b q 0 = 0", "unfolding cindex_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly 0 p x) =\n    0 &&&\n    (\\<Sum>x | poly 0 x = 0 \\<and> a < x \\<and> x < b. jump_poly q 0 x) = 0", "by auto"], ["", "lemma cindex_poly_cross:\n  fixes p::\"real poly\" and a b::real\n  assumes  \"a<b\" \"poly p a\\<noteq>0\" \"poly p b\\<noteq>0\"\n  shows \"cindex_poly a b 1 p = cross p a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b 1 p = cross p a b", "using \\<open>poly p a\\<noteq>0\\<close> \\<open>poly p b\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_poly a b 1 p = cross p a b", "proof (cases \"{x. poly p x=0 \\<and> a< x\\<and> x< b}\\<noteq>{}\", induct \"degree p\" arbitrary:p rule:nat_less_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "case 1"], ["proof (state)\nthis:\n  \\<forall>m<degree p.\n     \\<forall>x.\n        m = degree x \\<longrightarrow>\n        poly x a \\<noteq> 0 \\<longrightarrow>\n        poly x b \\<noteq> 0 \\<longrightarrow>\n        {xa. poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n        {} \\<longrightarrow>\n        poly x a \\<noteq> 0 \\<longrightarrow>\n        poly x b \\<noteq> 0 \\<longrightarrow>\n        cindex_poly a b 1 x = cross x a b\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n  {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "then"], ["proof (chain)\npicking this:\n  \\<forall>m<degree p.\n     \\<forall>x.\n        m = degree x \\<longrightarrow>\n        poly x a \\<noteq> 0 \\<longrightarrow>\n        poly x b \\<noteq> 0 \\<longrightarrow>\n        {xa. poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n        {} \\<longrightarrow>\n        poly x a \\<noteq> 0 \\<longrightarrow>\n        poly x b \\<noteq> 0 \\<longrightarrow>\n        cindex_poly a b 1 x = cross x a b\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n  {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0", "have \"p\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<forall>m<degree p.\n     \\<forall>x.\n        m = degree x \\<longrightarrow>\n        poly x a \\<noteq> 0 \\<longrightarrow>\n        poly x b \\<noteq> 0 \\<longrightarrow>\n        {xa. poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n        {} \\<longrightarrow>\n        poly x a \\<noteq> 0 \\<longrightarrow>\n        poly x b \\<noteq> 0 \\<longrightarrow>\n        cindex_poly a b 1 x = cross x a b\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n  {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "define roots where \"roots\\<equiv>{x.  poly p x=0 \\<and> a< x\\<and> x< b}\""], ["proof (state)\nthis:\n  roots \\<equiv> {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "have \"finite roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite roots", "unfolding roots_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. poly p x = 0 \\<and> a < x \\<and> x < b}", "using poly_roots_finite[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. poly p x = 0 \\<and> a < x \\<and> x < b}", "by auto"], ["proof (state)\nthis:\n  finite roots\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "define max_r where \"max_r\\<equiv>Max roots\""], ["proof (state)\nthis:\n  max_r \\<equiv> Max roots\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "hence \"poly p max_r=0\" and \"a<max_r\" and \"max_r<b\""], ["proof (prove)\nusing this:\n  max_r \\<equiv> Max roots\n\ngoal (1 subgoal):\n 1. poly p max_r = 0 &&& a < max_r &&& max_r < b", "using Max_in[OF \\<open>finite roots\\<close>] \"1.prems\""], ["proof (prove)\nusing this:\n  max_r \\<equiv> Max roots\n  roots \\<noteq> {} \\<Longrightarrow> Max roots \\<in> roots\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n  {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p max_r = 0 &&& a < max_r &&& max_r < b", "unfolding roots_def"], ["proof (prove)\nusing this:\n  max_r \\<equiv> Max {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n  {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {} \\<Longrightarrow>\n  Max {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n  \\<in> {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n  {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p max_r = 0 &&& a < max_r &&& max_r < b", "by auto"], ["proof (state)\nthis:\n  poly p max_r = 0\n  a < max_r\n  max_r < b\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "define max_rp where \"max_rp\\<equiv>[:-max_r,1:]^order max_r p\""], ["proof (state)\nthis:\n  max_rp \\<equiv> [:- max_r, 1:] ^ order max_r p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "then"], ["proof (chain)\npicking this:\n  max_rp \\<equiv> [:- max_r, 1:] ^ order max_r p", "obtain p' where p':\"p=p'*max_rp\" and not_dvd:\"\\<not> [:-max_r,1:] dvd p'\""], ["proof (prove)\nusing this:\n  max_rp \\<equiv> [:- max_r, 1:] ^ order max_r p\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p = p' * max_rp; \\<not> [:- max_r, 1:] dvd p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>p\\<noteq>0\\<close> mult.commute order_decomp)"], ["proof (state)\nthis:\n  p = p' * max_rp\n  \\<not> [:- max_r, 1:] dvd p'\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "hence \"p'\\<noteq>0\" and \"max_rp\\<noteq>0\" and \"poly p' a\\<noteq>0\" and \"poly p' b\\<noteq>0\" \n      and  \"poly max_rp a\\<noteq>0\" and \"poly max_rp b\\<noteq>0\""], ["proof (prove)\nusing this:\n  p = p' * max_rp\n  \\<not> [:- max_r, 1:] dvd p'\n\ngoal (1 subgoal):\n 1. (p' \\<noteq> 0 &&& max_rp \\<noteq> 0 &&& poly p' a \\<noteq> 0) &&&\n    poly p' b \\<noteq> 0 &&&\n    poly max_rp a \\<noteq> 0 &&& poly max_rp b \\<noteq> 0", "using \\<open>p\\<noteq>0\\<close> \\<open>poly p a\\<noteq>0\\<close> \\<open>poly p b\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p = p' * max_rp\n  \\<not> [:- max_r, 1:] dvd p'\n  p \\<noteq> 0\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (p' \\<noteq> 0 &&& max_rp \\<noteq> 0 &&& poly p' a \\<noteq> 0) &&&\n    poly p' b \\<noteq> 0 &&&\n    poly max_rp a \\<noteq> 0 &&& poly max_rp b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p' \\<noteq> 0\n  max_rp \\<noteq> 0\n  poly p' a \\<noteq> 0\n  poly p' b \\<noteq> 0\n  poly max_rp a \\<noteq> 0\n  poly max_rp b \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "define max_r_sign where \"max_r_sign\\<equiv>if odd(order max_r p) then -1 else 1::int\""], ["proof (state)\nthis:\n  max_r_sign \\<equiv> if odd (order max_r p) then - 1 else 1\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "define roots' where \"roots'\\<equiv>{x.  a< x\\<and> x< b \\<and> poly p' x=0}\""], ["proof (state)\nthis:\n  roots' \\<equiv> {x. a < x \\<and> x < b \\<and> poly p' x = 0}\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "have \"(\\<Sum>x\\<in>roots. jump_poly 1 p x)= (\\<Sum>x\\<in>roots'. jump_poly 1 p x)+ jump_poly 1 p max_r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "have \"roots=roots' \\<union> {x.  a< x\\<and> x< b \\<and> poly max_rp x=0 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. roots = roots' \\<union> {x. a < x \\<and> x < b \\<and> poly max_rp x = 0}", "unfolding roots_def roots'_def p'"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly (p' * max_rp) x = 0 \\<and> a < x \\<and> x < b} =\n    {x. a < x \\<and> x < b \\<and> poly p' x = 0} \\<union>\n    {x. a < x \\<and> x < b \\<and> poly max_rp x = 0}", "by auto"], ["proof (state)\nthis:\n  roots = roots' \\<union> {x. a < x \\<and> x < b \\<and> poly max_rp x = 0}\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "moreover"], ["proof (state)\nthis:\n  roots = roots' \\<union> {x. a < x \\<and> x < b \\<and> poly max_rp x = 0}\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "have \"{x.  a < x \\<and> x < b \\<and>  poly max_rp x = 0 }={max_r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {max_r}", "unfolding max_rp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. a < x \\<and>\n        x < b \\<and> poly ([:- max_r, 1:] ^ order max_r p) x = 0} =\n    {max_r}", "using \\<open>poly p max_r=0\\<close>"], ["proof (prove)\nusing this:\n  poly p max_r = 0\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and>\n        x < b \\<and> poly ([:- max_r, 1:] ^ order max_r p) x = 0} =\n    {max_r}", "by (auto simp add: \\<open>a<max_r\\<close> \\<open>max_r<b\\<close>,metis \"1.prems\"(1) neq0_conv order_root)"], ["proof (state)\nthis:\n  {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {max_r}\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "moreover"], ["proof (state)\nthis:\n  {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {max_r}\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "hence \"roots' \\<inter> {x. a< x\\<and> x< b \\<and> poly max_rp x=0} ={}\""], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {max_r}\n\ngoal (1 subgoal):\n 1. roots' \\<inter> {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {}", "unfolding roots'_def"], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {max_r}\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x < b \\<and> poly p' x = 0} \\<inter>\n    {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} =\n    {}", "using \\<open>\\<not> [:-max_r,1:] dvd p'\\<close>"], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {max_r}\n  \\<not> [:- max_r, 1:] dvd p'\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x < b \\<and> poly p' x = 0} \\<inter>\n    {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} =\n    {}", "by (metis (mono_tags) Int_insert_right_if0 inf_bot_right mem_Collect_eq poly_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  roots' \\<inter> {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {}\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "moreover"], ["proof (state)\nthis:\n  roots' \\<inter> {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {}\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "have \"finite roots'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite roots'", "using  p' \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p = p' * max_rp\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite roots'", "by (metis \\<open>finite roots\\<close> calculation(1) calculation(2) finite_Un)"], ["proof (state)\nthis:\n  finite roots'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "ultimately"], ["proof (chain)\npicking this:\n  roots = roots' \\<union> {x. a < x \\<and> x < b \\<and> poly max_rp x = 0}\n  {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {max_r}\n  roots' \\<inter> {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {}\n  finite roots'", "show ?thesis"], ["proof (prove)\nusing this:\n  roots = roots' \\<union> {x. a < x \\<and> x < b \\<and> poly max_rp x = 0}\n  {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {max_r}\n  roots' \\<inter> {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {}\n  finite roots'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "using sum.union_disjoint"], ["proof (prove)\nusing this:\n  roots = roots' \\<union> {x. a < x \\<and> x < b \\<and> poly max_rp x = 0}\n  {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {max_r}\n  roots' \\<inter> {x. a < x \\<and> x < b \\<and> poly max_rp x = 0} = {}\n  finite roots'\n  \\<lbrakk>finite ?A; finite ?B; ?A \\<inter> ?B = {}\\<rbrakk>\n  \\<Longrightarrow> sum ?g (?A \\<union> ?B) = sum ?g ?A + sum ?g ?B\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "by auto"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots =\n  sum (jump_poly 1 p) roots' + jump_poly 1 p max_r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots =\n  sum (jump_poly 1 p) roots' + jump_poly 1 p max_r\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "moreover"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots =\n  sum (jump_poly 1 p) roots' + jump_poly 1 p max_r\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "have \"(\\<Sum>x\\<in>roots'. jump_poly 1 p x) = max_r_sign * cross p' a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b", "have \"(\\<Sum>x\\<in>roots'. jump_poly 1 p x) = (\\<Sum>x\\<in>roots'. max_r_sign * jump_poly 1 p' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' =\n    (\\<Sum>x\\<in>roots'. max_r_sign * jump_poly 1 p' x)", "proof (rule sum.cong,rule refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "assume \"x \\<in> roots'\""], ["proof (state)\nthis:\n  x \\<in> roots'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "hence \"x\\<noteq>max_r\""], ["proof (prove)\nusing this:\n  x \\<in> roots'\n\ngoal (1 subgoal):\n 1. x \\<noteq> max_r", "using not_dvd"], ["proof (prove)\nusing this:\n  x \\<in> roots'\n  \\<not> [:- max_r, 1:] dvd p'\n\ngoal (1 subgoal):\n 1. x \\<noteq> max_r", "unfolding roots'_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. a < x \\<and> x < b \\<and> poly p' x = 0}\n  \\<not> [:- max_r, 1:] dvd p'\n\ngoal (1 subgoal):\n 1. x \\<noteq> max_r", "by (metis (mono_tags, lifting) mem_Collect_eq poly_eq_0_iff_dvd )"], ["proof (state)\nthis:\n  x \\<noteq> max_r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "hence \"poly max_rp x\\<noteq>0\""], ["proof (prove)\nusing this:\n  x \\<noteq> max_r\n\ngoal (1 subgoal):\n 1. poly max_rp x \\<noteq> 0", "using poly_power_n_eq"], ["proof (prove)\nusing this:\n  x \\<noteq> max_r\n  ?n \\<noteq> 0 \\<Longrightarrow>\n  (poly ([:- ?a, 1::?'a:] ^ ?n) ?x = (0::?'a)) = (?x = ?a)\n\ngoal (1 subgoal):\n 1. poly max_rp x \\<noteq> 0", "unfolding max_rp_def"], ["proof (prove)\nusing this:\n  x \\<noteq> max_r\n  ?n \\<noteq> 0 \\<Longrightarrow>\n  (poly ([:- ?a, 1::?'a:] ^ ?n) ?x = (0::?'a)) = (?x = ?a)\n\ngoal (1 subgoal):\n 1. poly ([:- max_r, 1:] ^ order max_r p) x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly max_rp x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "hence \"order x max_rp=0\""], ["proof (prove)\nusing this:\n  poly max_rp x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x max_rp = 0", "by (metis order_root)"], ["proof (state)\nthis:\n  order x max_rp = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "moreover"], ["proof (state)\nthis:\n  order x max_rp = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "have \"jump_poly 1 max_rp x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly 1 max_rp x = 0", "using \\<open>poly max_rp x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly max_rp x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 max_rp x = 0", "by (metis jump_poly_not_root)"], ["proof (state)\nthis:\n  jump_poly 1 max_rp x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "moreover"], ["proof (state)\nthis:\n  jump_poly 1 max_rp x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "have \"x\\<in>roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> roots", "using \\<open>x \\<in> roots'\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> roots'\n\ngoal (1 subgoal):\n 1. x \\<in> roots", "unfolding roots_def roots'_def p'"], ["proof (prove)\nusing this:\n  x \\<in> {x. a < x \\<and> x < b \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. x \\<in> {x. poly (p' * max_rp) x = 0 \\<and> a < x \\<and> x < b}", "by auto"], ["proof (state)\nthis:\n  x \\<in> roots\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "hence \"x<max_r\""], ["proof (prove)\nusing this:\n  x \\<in> roots\n\ngoal (1 subgoal):\n 1. x < max_r", "using Max_ge[OF \\<open>finite roots\\<close>,of x] \\<open>x\\<noteq>max_r\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> roots\n  x \\<in> roots \\<Longrightarrow> x \\<le> Max roots\n  x \\<noteq> max_r\n\ngoal (1 subgoal):\n 1. x < max_r", "by (fold max_r_def,auto)"], ["proof (state)\nthis:\n  x < max_r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "hence \"sign (poly max_rp x) = max_r_sign\""], ["proof (prove)\nusing this:\n  x < max_r\n\ngoal (1 subgoal):\n 1. sign (poly max_rp x) = max_r_sign", "using \\<open>poly max_rp x \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  x < max_r\n  poly max_rp x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign (poly max_rp x) = max_r_sign", "unfolding max_r_sign_def max_rp_def sign_def"], ["proof (prove)\nusing this:\n  x < max_r\n  poly ([:- max_r, 1:] ^ order max_r p) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if 0 < poly ([:- max_r, 1:] ^ order max_r p) x then 1\n     else if poly ([:- max_r, 1:] ^ order max_r p) x = 0 then 0 else - 1) =\n    (if odd (order max_r p) then - 1 else 1)", "by (subst poly_power,simp add:linorder_class.not_less zero_less_power_eq)"], ["proof (state)\nthis:\n  sign (poly max_rp x) = max_r_sign\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "ultimately"], ["proof (chain)\npicking this:\n  order x max_rp = 0\n  jump_poly 1 max_rp x = 0\n  sign (poly max_rp x) = max_r_sign", "show \"jump_poly 1 p x = max_r_sign * jump_poly 1 p' x\""], ["proof (prove)\nusing this:\n  order x max_rp = 0\n  jump_poly 1 max_rp x = 0\n  sign (poly max_rp x) = max_r_sign\n\ngoal (1 subgoal):\n 1. jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "using jump_poly_1_mult[of p' x max_rp]"], ["proof (prove)\nusing this:\n  order x max_rp = 0\n  jump_poly 1 max_rp x = 0\n  sign (poly max_rp x) = max_r_sign\n  poly p' x \\<noteq> 0 \\<or> poly max_rp x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly 1 (p' * max_rp) x =\n  sign (poly max_rp x) * jump_poly 1 p' x +\n  sign (poly p' x) * jump_poly 1 max_rp x\n\ngoal (1 subgoal):\n 1. jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "unfolding p'"], ["proof (prove)\nusing this:\n  order x max_rp = 0\n  jump_poly 1 max_rp x = 0\n  sign (poly max_rp x) = max_r_sign\n  poly p' x \\<noteq> 0 \\<or> poly max_rp x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly 1 (p' * max_rp) x =\n  sign (poly max_rp x) * jump_poly 1 p' x +\n  sign (poly p' x) * jump_poly 1 max_rp x\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p' * max_rp) x = max_r_sign * jump_poly 1 p' x", "by (simp add: \\<open>poly max_rp x \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  jump_poly 1 p x = max_r_sign * jump_poly 1 p' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots' =\n  (\\<Sum>x\\<in>roots'. max_r_sign * jump_poly 1 p' x)\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b", "also"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots' =\n  (\\<Sum>x\\<in>roots'. max_r_sign * jump_poly 1 p' x)\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b", "have \"... = max_r_sign * (\\<Sum>x\\<in>roots'. jump_poly 1 p' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>roots'. max_r_sign * jump_poly 1 p' x) =\n    max_r_sign * sum (jump_poly 1 p') roots'", "by (simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>roots'. max_r_sign * jump_poly 1 p' x) =\n  max_r_sign * sum (jump_poly 1 p') roots'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>roots'. max_r_sign * jump_poly 1 p' x) =\n  max_r_sign * sum (jump_poly 1 p') roots'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b", "have \"... = max_r_sign * cross p' a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "proof (cases \"roots'={}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. roots' = {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b\n 2. roots' \\<noteq> {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "case True"], ["proof (state)\nthis:\n  roots' = {}\n\ngoal (2 subgoals):\n 1. roots' = {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b\n 2. roots' \\<noteq> {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "hence \"cross p' a b=0\""], ["proof (prove)\nusing this:\n  roots' = {}\n\ngoal (1 subgoal):\n 1. cross p' a b = 0", "unfolding roots'_def"], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x < b \\<and> poly p' x = 0} = {}\n\ngoal (1 subgoal):\n 1. cross p' a b = 0", "using cross_no_root[OF \\<open>a<b\\<close>]"], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x < b \\<and> poly p' x = 0} = {}\n  \\<forall>x.\n     a < x \\<and> x < b \\<longrightarrow>\n     poly ?p x \\<noteq> 0 \\<Longrightarrow>\n  cross ?p a b = 0\n\ngoal (1 subgoal):\n 1. cross p' a b = 0", "by auto"], ["proof (state)\nthis:\n  cross p' a b = 0\n\ngoal (2 subgoals):\n 1. roots' = {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b\n 2. roots' \\<noteq> {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  cross p' a b = 0\n\ngoal (1 subgoal):\n 1. max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "using True"], ["proof (prove)\nusing this:\n  cross p' a b = 0\n  roots' = {}\n\ngoal (1 subgoal):\n 1. max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "by simp"], ["proof (state)\nthis:\n  max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b\n\ngoal (1 subgoal):\n 1. roots' \\<noteq> {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. roots' \\<noteq> {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "case False"], ["proof (state)\nthis:\n  roots' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. roots' \\<noteq> {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "moreover"], ["proof (state)\nthis:\n  roots' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. roots' \\<noteq> {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "have \"degree max_rp\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree max_rp \\<noteq> 0", "unfolding max_rp_def degree_linear_power"], ["proof (prove)\ngoal (1 subgoal):\n 1. order max_r p \\<noteq> 0", "by (metis \"1.prems\"(1) \\<open>poly p max_r = 0\\<close> order_root)"], ["proof (state)\nthis:\n  degree max_rp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. roots' \\<noteq> {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "hence  \"degree p' < degree p\""], ["proof (prove)\nusing this:\n  degree max_rp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p' < degree p", "unfolding p' degree_mult_eq[OF \\<open>p'\\<noteq>0\\<close> \\<open>max_rp\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  degree max_rp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p' < degree p' + degree max_rp", "by auto"], ["proof (state)\nthis:\n  degree p' < degree p\n\ngoal (1 subgoal):\n 1. roots' \\<noteq> {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "ultimately"], ["proof (chain)\npicking this:\n  roots' \\<noteq> {}\n  degree p' < degree p", "have \"cindex_poly a b 1 p' = cross p' a b\""], ["proof (prove)\nusing this:\n  roots' \\<noteq> {}\n  degree p' < degree p\n\ngoal (1 subgoal):\n 1. cindex_poly a b 1 p' = cross p' a b", "unfolding roots'_def"], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x < b \\<and> poly p' x = 0} \\<noteq> {}\n  degree p' < degree p\n\ngoal (1 subgoal):\n 1. cindex_poly a b 1 p' = cross p' a b", "using \"1.hyps\"[rule_format,of \"degree p'\" p'] \\<open>p'\\<noteq>0\\<close> \\<open>poly p' a\\<noteq>0\\<close> \\<open>poly p' b\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x < b \\<and> poly p' x = 0} \\<noteq> {}\n  degree p' < degree p\n  \\<lbrakk>degree p' < degree p; degree p' = degree p';\n   poly p' a \\<noteq> 0; poly p' b \\<noteq> 0;\n   {x. poly p' x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n   poly p' a \\<noteq> 0; poly p' b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> cindex_poly a b 1 p' = cross p' a b\n  p' \\<noteq> 0\n  poly p' a \\<noteq> 0\n  poly p' b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_poly a b 1 p' = cross p' a b", "by auto"], ["proof (state)\nthis:\n  cindex_poly a b 1 p' = cross p' a b\n\ngoal (1 subgoal):\n 1. roots' \\<noteq> {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "moreover"], ["proof (state)\nthis:\n  cindex_poly a b 1 p' = cross p' a b\n\ngoal (1 subgoal):\n 1. roots' \\<noteq> {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "have \"cindex_poly a b 1 p' = sum (jump_poly 1 p') roots'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b 1 p' = sum (jump_poly 1 p') roots'", "unfolding cindex_poly_def roots'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p' x = 0 \\<and> a < x \\<and> x < b. jump_poly 1 p' x) =\n    sum (jump_poly 1 p') {x. a < x \\<and> x < b \\<and> poly p' x = 0}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p' x = 0 \\<and> a < x \\<and> x < b. jump_poly 1 p' x) =\n    (\\<Sum>x | a < x \\<and> x < b \\<and> poly p' x = 0. jump_poly 1 p' x)", "by (metis (no_types, lifting) )"], ["proof (state)\nthis:\n  cindex_poly a b 1 p' = sum (jump_poly 1 p') roots'\n\ngoal (1 subgoal):\n 1. roots' \\<noteq> {} \\<Longrightarrow>\n    max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "ultimately"], ["proof (chain)\npicking this:\n  cindex_poly a b 1 p' = cross p' a b\n  cindex_poly a b 1 p' = sum (jump_poly 1 p') roots'", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_poly a b 1 p' = cross p' a b\n  cindex_poly a b 1 p' = sum (jump_poly 1 p') roots'\n\ngoal (1 subgoal):\n 1. max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b", "by auto"], ["proof (state)\nthis:\n  max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  max_r_sign * sum (jump_poly 1 p') roots' = max_r_sign * cross p' a b\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b", "finally"], ["proof (chain)\npicking this:\n  sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b", "show ?thesis"], ["proof (prove)\nusing this:\n  sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b", "."], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "moreover"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "have \"max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\" (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "proof (cases \"odd (order max_r p)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\n 2. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "case True"], ["proof (state)\nthis:\n  odd (order max_r p)\n\ngoal (2 subgoals):\n 1. odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\n 2. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "have \"poly max_rp a < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly max_rp a < 0", "using poly_power_n_odd[OF True,of max_r a] \\<open>poly max_rp a\\<noteq>0\\<close> \\<open>max_r>a\\<close>"], ["proof (prove)\nusing this:\n  (0 < poly ([:- max_r, 1:] ^ order max_r p) a) = (max_r < a)\n  poly max_rp a \\<noteq> 0\n  a < max_r\n\ngoal (1 subgoal):\n 1. poly max_rp a < 0", "unfolding max_rp_def"], ["proof (prove)\nusing this:\n  (0 < poly ([:- max_r, 1:] ^ order max_r p) a) = (max_r < a)\n  poly ([:- max_r, 1:] ^ order max_r p) a \\<noteq> 0\n  a < max_r\n\ngoal (1 subgoal):\n 1. poly ([:- max_r, 1:] ^ order max_r p) a < 0", "by linarith"], ["proof (state)\nthis:\n  poly max_rp a < 0\n\ngoal (2 subgoals):\n 1. odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\n 2. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "moreover"], ["proof (state)\nthis:\n  poly max_rp a < 0\n\ngoal (2 subgoals):\n 1. odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\n 2. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "have \"poly max_rp b>0 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly max_rp b", "using poly_power_n_odd[OF True,of max_r b] \\<open>max_r<b\\<close>"], ["proof (prove)\nusing this:\n  (0 < poly ([:- max_r, 1:] ^ order max_r p) b) = (max_r < b)\n  max_r < b\n\ngoal (1 subgoal):\n 1. 0 < poly max_rp b", "unfolding max_rp_def"], ["proof (prove)\nusing this:\n  (0 < poly ([:- max_r, 1:] ^ order max_r p) b) = (max_r < b)\n  max_r < b\n\ngoal (1 subgoal):\n 1. 0 < poly ([:- max_r, 1:] ^ order max_r p) b", "by linarith"], ["proof (state)\nthis:\n  0 < poly max_rp b\n\ngoal (2 subgoals):\n 1. odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\n 2. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "ultimately"], ["proof (chain)\npicking this:\n  poly max_rp a < 0\n  0 < poly max_rp b", "have \"?R=cross p' a b + sign (poly p' a)\""], ["proof (prove)\nusing this:\n  poly max_rp a < 0\n  0 < poly max_rp b\n\ngoal (1 subgoal):\n 1. cross p a b = cross p' a b + sign (poly p' a)", "unfolding p' cross_def poly_mult"], ["proof (prove)\nusing this:\n  poly max_rp a < 0\n  0 < poly max_rp b\n\ngoal (1 subgoal):\n 1. variation (poly p' a * poly max_rp a) (poly p' b * poly max_rp b) =\n    variation (poly p' a) (poly p' b) + sign (poly p' a)", "using variation_mult_neg_1[of \"poly max_rp a\", simplified mult.commute]\n          variation_mult_pos(2)[of \"poly max_rp b\", simplified mult.commute] \\<open>poly p' b\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly max_rp a < 0\n  0 < poly max_rp b\n  poly max_rp a < 0 \\<Longrightarrow>\n  variation (?x * poly max_rp a) ?y =\n  variation ?x ?y + (if ?y = 0 then 0 else sign ?x)\n  0 < poly max_rp b \\<Longrightarrow>\n  variation ?x (?y * poly max_rp b) = variation ?x ?y\n  poly p' b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. variation (poly p' a * poly max_rp a) (poly p' b * poly max_rp b) =\n    variation (poly p' a) (poly p' b) + sign (poly p' a)", "by auto"], ["proof (state)\nthis:\n  cross p a b = cross p' a b + sign (poly p' a)\n\ngoal (2 subgoals):\n 1. odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\n 2. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "moreover"], ["proof (state)\nthis:\n  cross p a b = cross p' a b + sign (poly p' a)\n\ngoal (2 subgoals):\n 1. odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\n 2. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "have \"?L=- cross p' a b + sign (poly p' b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_r_sign * cross p' a b + jump_poly 1 p max_r =\n    - cross p' a b + sign (poly p' b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. max_r_sign * cross p' a b + jump_poly 1 p max_r =\n    - cross p' a b + sign (poly p' b)", "have \" sign_r_pos p' max_r = (poly p' max_r >0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos p' max_r = (0 < poly p' max_r)", "using sign_r_pos_rec[OF \\<open>p'\\<noteq>0\\<close>] not_dvd"], ["proof (prove)\nusing this:\n  sign_r_pos p' ?x =\n  (if poly p' ?x = 0 then sign_r_pos (pderiv p') ?x else 0 < poly p' ?x)\n  \\<not> [:- max_r, 1:] dvd p'\n\ngoal (1 subgoal):\n 1. sign_r_pos p' max_r = (0 < poly p' max_r)", "by (metis poly_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  sign_r_pos p' max_r = (0 < poly p' max_r)\n\ngoal (1 subgoal):\n 1. max_r_sign * cross p' a b + jump_poly 1 p max_r =\n    - cross p' a b + sign (poly p' b)", "moreover"], ["proof (state)\nthis:\n  sign_r_pos p' max_r = (0 < poly p' max_r)\n\ngoal (1 subgoal):\n 1. max_r_sign * cross p' a b + jump_poly 1 p max_r =\n    - cross p' a b + sign (poly p' b)", "have \"(poly p' max_r>0) = (poly p' b>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < poly p' max_r) = (0 < poly p' b)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. (0 < poly p' max_r) \\<noteq> (0 < poly p' b) \\<Longrightarrow> False", "assume \"(0 < poly p' max_r) \\<noteq> (0 < poly p' b)\""], ["proof (state)\nthis:\n  (0 < poly p' max_r) \\<noteq> (0 < poly p' b)\n\ngoal (1 subgoal):\n 1. (0 < poly p' max_r) \\<noteq> (0 < poly p' b) \\<Longrightarrow> False", "hence \"poly p' max_r * poly p' b <0\""], ["proof (prove)\nusing this:\n  (0 < poly p' max_r) \\<noteq> (0 < poly p' b)\n\ngoal (1 subgoal):\n 1. poly p' max_r * poly p' b < 0", "using \\<open>poly p' b\\<noteq>0\\<close> not_dvd[folded poly_eq_0_iff_dvd]"], ["proof (prove)\nusing this:\n  (0 < poly p' max_r) \\<noteq> (0 < poly p' b)\n  poly p' b \\<noteq> 0\n  poly p' max_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p' max_r * poly p' b < 0", "by (metis (poly_guards_query) linorder_neqE_linordered_idom mult_less_0_iff)"], ["proof (state)\nthis:\n  poly p' max_r * poly p' b < 0\n\ngoal (1 subgoal):\n 1. (0 < poly p' max_r) \\<noteq> (0 < poly p' b) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  poly p' max_r * poly p' b < 0", "obtain r where \"r>max_r\" and \"r<b\" and \"poly p' r=0\""], ["proof (prove)\nusing this:\n  poly p' max_r * poly p' b < 0\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>max_r < r; r < b; poly p' r = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using poly_IVT[OF \\<open>max_r<b\\<close>]"], ["proof (prove)\nusing this:\n  poly p' max_r * poly p' b < 0\n  poly ?p max_r * poly ?p b < 0 \\<Longrightarrow>\n  \\<exists>x>max_r. x < b \\<and> poly ?p x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>max_r < r; r < b; poly p' r = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  max_r < r\n  r < b\n  poly p' r = 0\n\ngoal (1 subgoal):\n 1. (0 < poly p' max_r) \\<noteq> (0 < poly p' b) \\<Longrightarrow> False", "hence \"r\\<in>roots\""], ["proof (prove)\nusing this:\n  max_r < r\n  r < b\n  poly p' r = 0\n\ngoal (1 subgoal):\n 1. r \\<in> roots", "unfolding roots_def p'"], ["proof (prove)\nusing this:\n  max_r < r\n  r < b\n  poly p' r = 0\n\ngoal (1 subgoal):\n 1. r \\<in> {x. poly (p' * max_rp) x = 0 \\<and> a < x \\<and> x < b}", "using \\<open>max_r>a\\<close>"], ["proof (prove)\nusing this:\n  max_r < r\n  r < b\n  poly p' r = 0\n  a < max_r\n\ngoal (1 subgoal):\n 1. r \\<in> {x. poly (p' * max_rp) x = 0 \\<and> a < x \\<and> x < b}", "by auto"], ["proof (state)\nthis:\n  r \\<in> roots\n\ngoal (1 subgoal):\n 1. (0 < poly p' max_r) \\<noteq> (0 < poly p' b) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  r \\<in> roots\n\ngoal (1 subgoal):\n 1. False", "using \\<open>r>max_r\\<close> Max_ge[OF \\<open>finite roots\\<close>,of r]"], ["proof (prove)\nusing this:\n  r \\<in> roots\n  max_r < r\n  r \\<in> roots \\<Longrightarrow> r \\<le> Max roots\n\ngoal (1 subgoal):\n 1. False", "unfolding max_r_def"], ["proof (prove)\nusing this:\n  r \\<in> roots\n  Max roots < r\n  r \\<in> roots \\<Longrightarrow> r \\<le> Max roots\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0 < poly p' max_r) = (0 < poly p' b)\n\ngoal (1 subgoal):\n 1. max_r_sign * cross p' a b + jump_poly 1 p max_r =\n    - cross p' a b + sign (poly p' b)", "moreover"], ["proof (state)\nthis:\n  (0 < poly p' max_r) = (0 < poly p' b)\n\ngoal (1 subgoal):\n 1. max_r_sign * cross p' a b + jump_poly 1 p max_r =\n    - cross p' a b + sign (poly p' b)", "have \"sign_r_pos max_rp max_r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos max_rp max_r", "using sign_r_pos_power"], ["proof (prove)\nusing this:\n  sign_r_pos ([:- ?a, 1:] ^ ?n) ?a\n\ngoal (1 subgoal):\n 1. sign_r_pos max_rp max_r", "unfolding max_rp_def"], ["proof (prove)\nusing this:\n  sign_r_pos ([:- ?a, 1:] ^ ?n) ?a\n\ngoal (1 subgoal):\n 1. sign_r_pos ([:- max_r, 1:] ^ order max_r p) max_r", "by auto"], ["proof (state)\nthis:\n  sign_r_pos max_rp max_r\n\ngoal (1 subgoal):\n 1. max_r_sign * cross p' a b + jump_poly 1 p max_r =\n    - cross p' a b + sign (poly p' b)", "ultimately"], ["proof (chain)\npicking this:\n  sign_r_pos p' max_r = (0 < poly p' max_r)\n  (0 < poly p' max_r) = (0 < poly p' b)\n  sign_r_pos max_rp max_r", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos p' max_r = (0 < poly p' max_r)\n  (0 < poly p' max_r) = (0 < poly p' b)\n  sign_r_pos max_rp max_r\n\ngoal (1 subgoal):\n 1. max_r_sign * cross p' a b + jump_poly 1 p max_r =\n    - cross p' a b + sign (poly p' b)", "using True \\<open>poly p' b\\<noteq>0\\<close> \\<open>max_rp\\<noteq>0\\<close> \\<open>p'\\<noteq>0\\<close> sign_r_pos_mult[OF \\<open>p'\\<noteq>0\\<close> \\<open>max_rp\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  sign_r_pos p' max_r = (0 < poly p' max_r)\n  (0 < poly p' max_r) = (0 < poly p' b)\n  sign_r_pos max_rp max_r\n  odd (order max_r p)\n  poly p' b \\<noteq> 0\n  max_rp \\<noteq> 0\n  p' \\<noteq> 0\n  sign_r_pos (p' * max_rp) ?x = (sign_r_pos p' ?x = sign_r_pos max_rp ?x)\n\ngoal (1 subgoal):\n 1. max_r_sign * cross p' a b + jump_poly 1 p max_r =\n    - cross p' a b + sign (poly p' b)", "unfolding max_r_sign_def  p' jump_poly_def"], ["proof (prove)\nusing this:\n  sign_r_pos p' max_r = (0 < poly p' max_r)\n  (0 < poly p' max_r) = (0 < poly p' b)\n  sign_r_pos max_rp max_r\n  odd (order max_r (p' * max_rp))\n  poly p' b \\<noteq> 0\n  max_rp \\<noteq> 0\n  p' \\<noteq> 0\n  sign_r_pos (p' * max_rp) ?x = (sign_r_pos p' ?x = sign_r_pos max_rp ?x)\n\ngoal (1 subgoal):\n 1. (if odd (order max_r (p' * max_rp)) then - 1 else 1) * cross p' a b +\n    (if p' * max_rp \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order max_r (p' * max_rp) - order max_r 1)\n     then if sign_r_pos (1 * (p' * max_rp)) max_r then 1 else - 1 else 0) =\n    - cross p' a b + sign (poly p' b)", "by simp"], ["proof (state)\nthis:\n  max_r_sign * cross p' a b + jump_poly 1 p max_r =\n  - cross p' a b + sign (poly p' b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  max_r_sign * cross p' a b + jump_poly 1 p max_r =\n  - cross p' a b + sign (poly p' b)\n\ngoal (2 subgoals):\n 1. odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\n 2. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "moreover"], ["proof (state)\nthis:\n  max_r_sign * cross p' a b + jump_poly 1 p max_r =\n  - cross p' a b + sign (poly p' b)\n\ngoal (2 subgoals):\n 1. odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\n 2. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "have \"variation (poly p' a) (poly p' b) + sign (poly p' a) \n          = - variation (poly p' a) (poly p' b) + sign (poly p' b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. variation (poly p' a) (poly p' b) + sign (poly p' a) =\n    - variation (poly p' a) (poly p' b) + sign (poly p' b)", "unfolding cross_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. variation (poly p' a) (poly p' b) + sign (poly p' a) =\n    - variation (poly p' a) (poly p' b) + sign (poly p' b)", "by (cases \"poly p' b\" rule:linorder_cases[of 0], (cases \"poly p' a\" rule:linorder_cases[of 0], \n          auto simp add:variation_cases \\<open>poly p' a \\<noteq> 0\\<close> \\<open>poly p' b \\<noteq> 0\\<close>)+)"], ["proof (state)\nthis:\n  variation (poly p' a) (poly p' b) + sign (poly p' a) =\n  - variation (poly p' a) (poly p' b) + sign (poly p' b)\n\ngoal (2 subgoals):\n 1. odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\n 2. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "ultimately"], ["proof (chain)\npicking this:\n  cross p a b = cross p' a b + sign (poly p' a)\n  max_r_sign * cross p' a b + jump_poly 1 p max_r =\n  - cross p' a b + sign (poly p' b)\n  variation (poly p' a) (poly p' b) + sign (poly p' a) =\n  - variation (poly p' a) (poly p' b) + sign (poly p' b)", "show ?thesis"], ["proof (prove)\nusing this:\n  cross p a b = cross p' a b + sign (poly p' a)\n  max_r_sign * cross p' a b + jump_poly 1 p max_r =\n  - cross p' a b + sign (poly p' b)\n  variation (poly p' a) (poly p' b) + sign (poly p' a) =\n  - variation (poly p' a) (poly p' b) + sign (poly p' b)\n\ngoal (1 subgoal):\n 1. max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "unfolding cross_def"], ["proof (prove)\nusing this:\n  variation (poly p a) (poly p b) =\n  variation (poly p' a) (poly p' b) + sign (poly p' a)\n  max_r_sign * variation (poly p' a) (poly p' b) + jump_poly 1 p max_r =\n  - variation (poly p' a) (poly p' b) + sign (poly p' b)\n  variation (poly p' a) (poly p' b) + sign (poly p' a) =\n  - variation (poly p' a) (poly p' b) + sign (poly p' b)\n\ngoal (1 subgoal):\n 1. max_r_sign * variation (poly p' a) (poly p' b) + jump_poly 1 p max_r =\n    variation (poly p a) (poly p b)", "by auto"], ["proof (state)\nthis:\n  max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\n\ngoal (1 subgoal):\n 1. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "case False"], ["proof (state)\nthis:\n  \\<not> odd (order max_r p)\n\ngoal (1 subgoal):\n 1. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "hence \"poly max_rp a > 0\" and \"poly max_rp b > 0\""], ["proof (prove)\nusing this:\n  \\<not> odd (order max_r p)\n\ngoal (1 subgoal):\n 1. 0 < poly max_rp a &&& 0 < poly max_rp b", "unfolding max_rp_def poly_power"], ["proof (prove)\nusing this:\n  \\<not> odd (order max_r p)\n\ngoal (1 subgoal):\n 1. 0 < poly [:- max_r, 1:] a ^ order max_r p &&&\n    0 < poly [:- max_r, 1:] b ^ order max_r p", "using \\<open>poly max_rp a\\<noteq>0\\<close> \\<open>poly max_rp b \\<noteq> 0\\<close>  \"1.prems\"(1-2) \\<open>poly p max_r = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> odd (order max_r p)\n  poly max_rp a \\<noteq> 0\n  poly max_rp b \\<noteq> 0\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n  poly p max_r = 0\n\ngoal (1 subgoal):\n 1. 0 < poly [:- max_r, 1:] a ^ order max_r p &&&\n    0 < poly [:- max_r, 1:] b ^ order max_r p", "apply (unfold zero_less_power_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> odd (order max_r p); poly max_rp a \\<noteq> 0;\n     poly max_rp b \\<noteq> 0; poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     poly p max_r = 0\\<rbrakk>\n    \\<Longrightarrow> order max_r p = 0 \\<or>\n                      even (order max_r p) \\<and>\n                      poly [:- max_r, 1:] a \\<noteq> 0 \\<or>\n                      odd (order max_r p) \\<and> 0 < poly [:- max_r, 1:] a\n 2. \\<lbrakk>\\<not> odd (order max_r p); poly max_rp a \\<noteq> 0;\n     poly max_rp b \\<noteq> 0; poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     poly p max_r = 0\\<rbrakk>\n    \\<Longrightarrow> order max_r p = 0 \\<or>\n                      even (order max_r p) \\<and>\n                      poly [:- max_r, 1:] b \\<noteq> 0 \\<or>\n                      odd (order max_r p) \\<and> 0 < poly [:- max_r, 1:] b", "by auto"], ["proof (state)\nthis:\n  0 < poly max_rp a\n  0 < poly max_rp b\n\ngoal (1 subgoal):\n 1. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "moreover"], ["proof (state)\nthis:\n  0 < poly max_rp a\n  0 < poly max_rp b\n\ngoal (1 subgoal):\n 1. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "have \"poly max_rp b > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly max_rp b", "unfolding max_rp_def poly_power"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly [:- max_r, 1:] b ^ order max_r p", "using \\<open>poly max_rp b \\<noteq> 0\\<close> False max_rp_def poly_power \n          zero_le_even_power[of \"order max_r p\" \"b - max_r\"]"], ["proof (prove)\nusing this:\n  poly max_rp b \\<noteq> 0\n  \\<not> odd (order max_r p)\n  max_rp \\<equiv> [:- max_r, 1:] ^ order max_r p\n  poly (?p ^ ?n) ?x = poly ?p ?x ^ ?n\n  even (order max_r p) \\<Longrightarrow> 0 \\<le> (b - max_r) ^ order max_r p\n\ngoal (1 subgoal):\n 1. 0 < poly [:- max_r, 1:] b ^ order max_r p", "by (auto simp add: le_less)"], ["proof (state)\nthis:\n  0 < poly max_rp b\n\ngoal (1 subgoal):\n 1. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "ultimately"], ["proof (chain)\npicking this:\n  0 < poly max_rp a\n  0 < poly max_rp b\n  0 < poly max_rp b", "have \"?R=cross p' a b\""], ["proof (prove)\nusing this:\n  0 < poly max_rp a\n  0 < poly max_rp b\n  0 < poly max_rp b\n\ngoal (1 subgoal):\n 1. cross p a b = cross p' a b", "apply (simp only: p' mult.commute cross_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < poly max_rp a; True; 0 < poly max_rp b\\<rbrakk>\n    \\<Longrightarrow> variation (poly (max_rp * p') a)\n                       (poly (max_rp * p') b) =\n                      variation (poly p' a) (poly p' b)", "using variation_mult_pos"], ["proof (prove)\nusing this:\n  0 < ?c \\<Longrightarrow> variation (?c * ?x) ?y = variation ?x ?y\n  0 < ?c \\<Longrightarrow> variation ?x (?c * ?y) = variation ?x ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < poly max_rp a; True; 0 < poly max_rp b\\<rbrakk>\n    \\<Longrightarrow> variation (poly (max_rp * p') a)\n                       (poly (max_rp * p') b) =\n                      variation (poly p' a) (poly p' b)", "by auto"], ["proof (state)\nthis:\n  cross p a b = cross p' a b\n\ngoal (1 subgoal):\n 1. \\<not> odd (order max_r p) \\<Longrightarrow>\n    max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  cross p a b = cross p' a b\n\ngoal (1 subgoal):\n 1. max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "unfolding max_r_sign_def jump_poly_def"], ["proof (prove)\nusing this:\n  cross p a b = cross p' a b\n\ngoal (1 subgoal):\n 1. (if odd (order max_r p) then - 1 else 1) * cross p' a b +\n    (if p \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order max_r p - order max_r 1)\n     then if sign_r_pos (1 * p) max_r then 1 else - 1 else 0) =\n    cross p a b", "using False"], ["proof (prove)\nusing this:\n  cross p a b = cross p' a b\n  \\<not> odd (order max_r p)\n\ngoal (1 subgoal):\n 1. (if odd (order max_r p) then - 1 else 1) * cross p' a b +\n    (if p \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order max_r p - order max_r 1)\n     then if sign_r_pos (1 * p) max_r then 1 else - 1 else 0) =\n    cross p a b", "by auto"], ["proof (state)\nthis:\n  max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "ultimately"], ["proof (chain)\npicking this:\n  sum (jump_poly 1 p) roots =\n  sum (jump_poly 1 p) roots' + jump_poly 1 p max_r\n  sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b\n  max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b", "have \"sum (jump_poly 1 p) roots = cross p a b \""], ["proof (prove)\nusing this:\n  sum (jump_poly 1 p) roots =\n  sum (jump_poly 1 p) roots' + jump_poly 1 p max_r\n  sum (jump_poly 1 p) roots' = max_r_sign * cross p' a b\n  max_r_sign * cross p' a b + jump_poly 1 p max_r = cross p a b\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots = cross p a b", "by auto"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots = cross p a b\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>m<degree p.\n                   \\<forall>x.\n                      m = degree x \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      {xa.\n                       poly x xa = 0 \\<and> a < xa \\<and> xa < b} \\<noteq>\n                      {} \\<longrightarrow>\n                      poly x a \\<noteq> 0 \\<longrightarrow>\n                      poly x b \\<noteq> 0 \\<longrightarrow>\n                      cindex_poly a b 1 x = cross x a b;\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n        {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {};\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b 1 p = cross p a b\n 2. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "then"], ["proof (chain)\npicking this:\n  sum (jump_poly 1 p) roots = cross p a b", "show ?case"], ["proof (prove)\nusing this:\n  sum (jump_poly 1 p) roots = cross p a b\n\ngoal (1 subgoal):\n 1. cindex_poly a b 1 p = cross p a b", "unfolding roots_def cindex_poly_def"], ["proof (prove)\nusing this:\n  sum (jump_poly 1 p) {x. poly p x = 0 \\<and> a < x \\<and> x < b} =\n  cross p a b\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly 1 p x) =\n    cross p a b", "by simp"], ["proof (state)\nthis:\n  cindex_poly a b 1 p = cross p a b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "case False"], ["proof (state)\nthis:\n  \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "hence \"cross p a b=0\""], ["proof (prove)\nusing this:\n  \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. cross p a b = 0", "using cross_no_root[OF \\<open>a<b\\<close>]"], ["proof (prove)\nusing this:\n  \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\n  \\<forall>x.\n     a < x \\<and> x < b \\<longrightarrow>\n     poly ?p x \\<noteq> 0 \\<Longrightarrow>\n  cross ?p a b = 0\n\ngoal (1 subgoal):\n 1. cross p a b = 0", "by auto"], ["proof (state)\nthis:\n  cross p a b = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>poly p a \\<noteq> 0; poly p b \\<noteq> 0;\n     \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 p = cross p a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  cross p a b = 0\n\ngoal (1 subgoal):\n 1. cindex_poly a b 1 p = cross p a b", "using False"], ["proof (prove)\nusing this:\n  cross p a b = 0\n  \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. cindex_poly a b 1 p = cross p a b", "unfolding cindex_poly_def"], ["proof (prove)\nusing this:\n  cross p a b = 0\n  \\<not> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly 1 p x) =\n    cross p a b", "by (metis sum.empty)"], ["proof (state)\nthis:\n  cindex_poly a b 1 p = cross p a b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_poly_mult:\n  fixes p q p'::\"real poly\"\n  assumes \"p'\\<noteq> 0\"  \n  shows \"cindex_poly a b (p' * q ) (p' * p) = cindex_poly a b q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b (p' * q) (p' * p) = cindex_poly a b q p", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    cindex_poly a b (p' * q) (p' * p) = cindex_poly a b q p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b (p' * q) (p' * p) = cindex_poly a b q p", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    cindex_poly a b (p' * q) (p' * p) = cindex_poly a b q p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b (p' * q) (p' * p) = cindex_poly a b q p", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. cindex_poly a b (p' * q) (p' * p) = cindex_poly a b q p", "by auto"], ["proof (state)\nthis:\n  cindex_poly a b (p' * q) (p' * p) = cindex_poly a b q p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b (p' * q) (p' * p) = cindex_poly a b q p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b (p' * q) (p' * p) = cindex_poly a b q p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b (p' * q) (p' * p) = cindex_poly a b q p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b (p' * q) (p' * p) = cindex_poly a b q p", "unfolding cindex_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly (p' * p) x = 0 \\<and> a < x \\<and> x < b.\n       jump_poly (p' * q) (p' * p) x) =\n    (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly q p x)", "apply (rule sum.mono_neutral_cong_right)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite {x. poly (p' * p) x = 0 \\<and> a < x \\<and> x < b}\n 2. {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n    \\<subseteq> {x. poly (p' * p) x = 0 \\<and> a < x \\<and> x < b}\n 3. \\<forall>i\\<in>{x. poly (p' * p) x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. poly p x = 0 \\<and> a < x \\<and> x < b}.\n       jump_poly (p' * q) (p' * p) i = 0\n 4. \\<And>x.\n       x \\<in> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<Longrightarrow>\n       jump_poly (p' * q) (p' * p) x = jump_poly q p x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. poly (p' * p) x = 0 \\<and> a < x \\<and> x < b}", "using \\<open>p\\<noteq>0\\<close> \\<open>p'\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite {x. poly (p' * p) x = 0 \\<and> a < x \\<and> x < b}", "by (simp add: poly_roots_finite)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n    \\<subseteq> {x. poly (p' * p) x = 0 \\<and> a < x \\<and> x < b}\n 2. \\<forall>i\\<in>{x. poly (p' * p) x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. poly p x = 0 \\<and> a < x \\<and> x < b}.\n       jump_poly (p' * q) (p' * p) i = 0\n 3. \\<And>x.\n       x \\<in> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<Longrightarrow>\n       jump_poly (p' * q) (p' * p) x = jump_poly q p x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n    \\<subseteq> {x. poly (p' * p) x = 0 \\<and> a < x \\<and> x < b}", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>{x. poly (p' * p) x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. poly p x = 0 \\<and> a < x \\<and> x < b}.\n       jump_poly (p' * q) (p' * p) i = 0\n 2. \\<And>x.\n       x \\<in> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<Longrightarrow>\n       jump_poly (p' * q) (p' * p) x = jump_poly q p x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. poly (p' * p) x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. poly p x = 0 \\<and> a < x \\<and> x < b}.\n       jump_poly (p' * q) (p' * p) i = 0", "using jump_poly_mult jump_poly_not_root assms"], ["proof (prove)\nusing this:\n  ?p' \\<noteq> 0 \\<Longrightarrow>\n  jump_poly (?p' * ?q) (?p' * ?p) ?x = jump_poly ?q ?p ?x\n  poly ?p ?x \\<noteq> 0 \\<Longrightarrow> jump_poly ?q ?p ?x = 0\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. poly (p' * p) x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. poly p x = 0 \\<and> a < x \\<and> x < b}.\n       jump_poly (p' * q) (p' * p) i = 0", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<Longrightarrow>\n       jump_poly (p' * q) (p' * p) x = jump_poly q p x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x", "using jump_poly_mult[OF \\<open>p'\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  jump_poly (p' * ?q) (p' * ?p) ?x = jump_poly ?q ?p ?x\n\ngoal (1 subgoal):\n 1. x \\<in> {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<Longrightarrow>\n    jump_poly (p' * q) (p' * p) x = jump_poly q p x", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cindex_poly a b (p' * q) (p' * p) = cindex_poly a b q p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_poly_smult_1: \n  fixes p q::\"real poly\" and c::real\n  shows \"cindex_poly a b (smult c q) p =  (sign c) * cindex_poly a b q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b (smult c q) p = sign c * cindex_poly a b q p", "unfolding cindex_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b.\n       jump_poly (smult c q) p x) =\n    sign c *\n    (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly q p x)", "using sum_distrib_left[THEN sym, of \"sign c\" \"\\<lambda>x. jump_poly q p x\"\n    \"{x. poly p x = (0::real) \\<and> a < x \\<and> x < b}\"] jump_poly_smult_1"], ["proof (prove)\nusing this:\n  (\\<Sum>n\\<in>{x. poly p x = 0 \\<and> a < x \\<and> x < b}.\n     sign c * jump_poly q p n) =\n  sign c *\n  (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly q p x)\n  jump_poly (smult ?c ?q) ?p ?x = sign ?c * jump_poly ?q ?p ?x\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b.\n       jump_poly (smult c q) p x) =\n    sign c *\n    (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly q p x)", "by auto"], ["", "lemma cindex_poly_mod:\n  fixes p q::\"real poly\" \n  shows \"cindex_poly a b q p =  cindex_poly a b (q mod p) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b q p = cindex_poly a b (q mod p) p", "unfolding cindex_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly q p x) =\n    (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b.\n       jump_poly (q mod p) p x)", "using jump_poly_mod"], ["proof (prove)\nusing this:\n  jump_poly ?q ?p ?x = jump_poly (?q mod ?p) ?p ?x\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly q p x) =\n    (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b.\n       jump_poly (q mod p) p x)", "by auto"], ["", "lemma cindex_poly_inverse_add:\n  fixes p q::\"real poly\" \n  assumes \"coprime p q\"\n  shows \"cindex_poly a b q p + cindex_poly a b p q=cindex_poly a b 1 (q*p)\"\n    (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "proof (cases \"p=0 \\<or> q=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "case True"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "then"], ["proof (chain)\npicking this:\n  p = 0 \\<or> q = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "by auto"], ["proof (state)\nthis:\n  cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "case False"], ["proof (state)\nthis:\n  \\<not> (p = 0 \\<or> q = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "then"], ["proof (chain)\npicking this:\n  \\<not> (p = 0 \\<or> q = 0)", "have \"p\\<noteq>0\" \"q\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> q = 0)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "define A where \"A\\<equiv>{x. poly p x = 0 \\<and> a < x \\<and> x < b}\""], ["proof (state)\nthis:\n  A \\<equiv> {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "define B where \"B\\<equiv>{x. poly q x = 0 \\<and> a < x \\<and> x < b}\""], ["proof (state)\nthis:\n  B \\<equiv> {x. poly q x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "have \"?L = sum (\\<lambda>x. jump_poly 1 (q*p) x) A + sum (\\<lambda>x. jump_poly 1 (q*p) x) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q =\n    sum (jump_poly 1 (q * p)) A + sum (jump_poly 1 (q * p)) B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q =\n    sum (jump_poly 1 (q * p)) A + sum (jump_poly 1 (q * p)) B", "have \"cindex_poly a b q p = sum (\\<lambda>x. jump_poly 1 (q*p) x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b q p = sum (jump_poly 1 (q * p)) A", "unfolding A_def cindex_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly q p x) =\n    (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b.\n       jump_poly 1 (q * p) x)", "using jump_poly_coprime[OF _ \\<open>coprime p q\\<close>]"], ["proof (prove)\nusing this:\n  poly p ?x = 0 \\<Longrightarrow> jump_poly q p ?x = jump_poly 1 (q * p) ?x\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly q p x) =\n    (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b.\n       jump_poly 1 (q * p) x)", "by auto"], ["proof (state)\nthis:\n  cindex_poly a b q p = sum (jump_poly 1 (q * p)) A\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q =\n    sum (jump_poly 1 (q * p)) A + sum (jump_poly 1 (q * p)) B", "moreover"], ["proof (state)\nthis:\n  cindex_poly a b q p = sum (jump_poly 1 (q * p)) A\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q =\n    sum (jump_poly 1 (q * p)) A + sum (jump_poly 1 (q * p)) B", "have \"coprime q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime q p", "using \\<open>coprime p q\\<close>"], ["proof (prove)\nusing this:\n  coprime p q\n\ngoal (1 subgoal):\n 1. coprime q p", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  coprime q p\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q =\n    sum (jump_poly 1 (q * p)) A + sum (jump_poly 1 (q * p)) B", "hence \"cindex_poly a b p q = sum (\\<lambda>x. jump_poly 1 (q*p) x) B\""], ["proof (prove)\nusing this:\n  coprime q p\n\ngoal (1 subgoal):\n 1. cindex_poly a b p q = sum (jump_poly 1 (q * p)) B", "unfolding B_def cindex_poly_def"], ["proof (prove)\nusing this:\n  coprime q p\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly q x = 0 \\<and> a < x \\<and> x < b. jump_poly p q x) =\n    (\\<Sum>x | poly q x = 0 \\<and> a < x \\<and> x < b.\n       jump_poly 1 (q * p) x)", "using jump_poly_coprime [of q _ p]"], ["proof (prove)\nusing this:\n  coprime q p\n  \\<lbrakk>poly q ?x = 0; coprime q p\\<rbrakk>\n  \\<Longrightarrow> jump_poly p q ?x = jump_poly 1 (p * q) ?x\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly q x = 0 \\<and> a < x \\<and> x < b. jump_poly p q x) =\n    (\\<Sum>x | poly q x = 0 \\<and> a < x \\<and> x < b.\n       jump_poly 1 (q * p) x)", "by (auto simp add: ac_simps)"], ["proof (state)\nthis:\n  cindex_poly a b p q = sum (jump_poly 1 (q * p)) B\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q =\n    sum (jump_poly 1 (q * p)) A + sum (jump_poly 1 (q * p)) B", "ultimately"], ["proof (chain)\npicking this:\n  cindex_poly a b q p = sum (jump_poly 1 (q * p)) A\n  cindex_poly a b p q = sum (jump_poly 1 (q * p)) B", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_poly a b q p = sum (jump_poly 1 (q * p)) A\n  cindex_poly a b p q = sum (jump_poly 1 (q * p)) B\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q =\n    sum (jump_poly 1 (q * p)) A + sum (jump_poly 1 (q * p)) B", "by auto"], ["proof (state)\nthis:\n  cindex_poly a b q p + cindex_poly a b p q =\n  sum (jump_poly 1 (q * p)) A + sum (jump_poly 1 (q * p)) B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_poly a b q p + cindex_poly a b p q =\n  sum (jump_poly 1 (q * p)) A + sum (jump_poly 1 (q * p)) B\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "moreover"], ["proof (state)\nthis:\n  cindex_poly a b q p + cindex_poly a b p q =\n  sum (jump_poly 1 (q * p)) A + sum (jump_poly 1 (q * p)) B\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "have \"A \\<union> B= {x. poly (q*p) x=0 \\<and> a<x \\<and> x<b }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union> B = {x. poly (q * p) x = 0 \\<and> a < x \\<and> x < b}", "unfolding poly_mult A_def B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0 \\<and> a < x \\<and> x < b} \\<union>\n    {x. poly q x = 0 \\<and> a < x \\<and> x < b} =\n    {x. poly q x * poly p x = 0 \\<and> a < x \\<and> x < b}", "by auto"], ["proof (state)\nthis:\n  A \\<union> B = {x. poly (q * p) x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "moreover"], ["proof (state)\nthis:\n  A \\<union> B = {x. poly (q * p) x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "have \"A \\<inter> B={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow> False", "assume \"A \\<inter> B\\<noteq>{}\""], ["proof (state)\nthis:\n  A \\<inter> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  A \\<inter> B \\<noteq> {}", "obtain x where \"x\\<in>A\" and \"x\\<in>B\""], ["proof (prove)\nusing this:\n  A \\<inter> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> A; x \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> A\n  x \\<in> B\n\ngoal (1 subgoal):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow> False", "hence \"poly p x=0\" and \"poly q x=0\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  x \\<in> B\n\ngoal (1 subgoal):\n 1. poly p x = 0 &&& poly q x = 0", "unfolding A_def B_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n  x \\<in> {x. poly q x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. poly p x = 0 &&& poly q x = 0", "by auto"], ["proof (state)\nthis:\n  poly p x = 0\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow> False", "hence \"gcd p q\\<noteq>1\""], ["proof (prove)\nusing this:\n  poly p x = 0\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. gcd p q \\<noteq> 1", "by (metis poly_1 poly_eq_0_iff_dvd gcd_greatest zero_neq_one)"], ["proof (state)\nthis:\n  gcd p q \\<noteq> 1\n\ngoal (1 subgoal):\n 1. A \\<inter> B \\<noteq> {} \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  gcd p q \\<noteq> 1\n\ngoal (1 subgoal):\n 1. False", "using \\<open>coprime p q\\<close>"], ["proof (prove)\nusing this:\n  gcd p q \\<noteq> 1\n  coprime p q\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "moreover"], ["proof (state)\nthis:\n  A \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "have \"finite A\" and \"finite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A &&& finite B", "unfolding A_def B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. poly p x = 0 \\<and> a < x \\<and> x < b} &&&\n    finite {x. poly q x = 0 \\<and> a < x \\<and> x < b}", "using poly_roots_finite \\<open>p\\<noteq>0\\<close> \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite {x. poly p x = 0 \\<and> a < x \\<and> x < b} &&&\n    finite {x. poly q x = 0 \\<and> a < x \\<and> x < b}", "by fast+"], ["proof (state)\nthis:\n  finite A\n  finite B\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "ultimately"], ["proof (chain)\npicking this:\n  cindex_poly a b q p + cindex_poly a b p q =\n  sum (jump_poly 1 (q * p)) A + sum (jump_poly 1 (q * p)) B\n  A \\<union> B = {x. poly (q * p) x = 0 \\<and> a < x \\<and> x < b}\n  A \\<inter> B = {}\n  finite A\n  finite B", "have \"cindex_poly a b q p + cindex_poly a b p q \n      = sum (jump_poly 1 (q * p)) {x. poly (q*p) x=0 \\<and> a<x \\<and> x<b}\""], ["proof (prove)\nusing this:\n  cindex_poly a b q p + cindex_poly a b p q =\n  sum (jump_poly 1 (q * p)) A + sum (jump_poly 1 (q * p)) B\n  A \\<union> B = {x. poly (q * p) x = 0 \\<and> a < x \\<and> x < b}\n  A \\<inter> B = {}\n  finite A\n  finite B\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q =\n    sum (jump_poly 1 (q * p))\n     {x. poly (q * p) x = 0 \\<and> a < x \\<and> x < b}", "using sum.union_disjoint"], ["proof (prove)\nusing this:\n  cindex_poly a b q p + cindex_poly a b p q =\n  sum (jump_poly 1 (q * p)) A + sum (jump_poly 1 (q * p)) B\n  A \\<union> B = {x. poly (q * p) x = 0 \\<and> a < x \\<and> x < b}\n  A \\<inter> B = {}\n  finite A\n  finite B\n  \\<lbrakk>finite ?A; finite ?B; ?A \\<inter> ?B = {}\\<rbrakk>\n  \\<Longrightarrow> sum ?g (?A \\<union> ?B) = sum ?g ?A + sum ?g ?B\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q =\n    sum (jump_poly 1 (q * p))\n     {x. poly (q * p) x = 0 \\<and> a < x \\<and> x < b}", "by metis"], ["proof (state)\nthis:\n  cindex_poly a b q p + cindex_poly a b p q =\n  sum (jump_poly 1 (q * p))\n   {x. poly (q * p) x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "then"], ["proof (chain)\npicking this:\n  cindex_poly a b q p + cindex_poly a b p q =\n  sum (jump_poly 1 (q * p))\n   {x. poly (q * p) x = 0 \\<and> a < x \\<and> x < b}", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_poly a b q p + cindex_poly a b p q =\n  sum (jump_poly 1 (q * p))\n   {x. poly (q * p) x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)", "unfolding cindex_poly_def"], ["proof (prove)\nusing this:\n  (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly q p x) +\n  (\\<Sum>x | poly q x = 0 \\<and> a < x \\<and> x < b. jump_poly p q x) =\n  sum (jump_poly 1 (q * p))\n   {x. poly (q * p) x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly q p x) +\n    (\\<Sum>x | poly q x = 0 \\<and> a < x \\<and> x < b. jump_poly p q x) =\n    (\\<Sum>x | poly (q * p) x = 0 \\<and> a < x \\<and> x < b.\n       jump_poly 1 (q * p) x)", "by auto"], ["proof (state)\nthis:\n  cindex_poly a b q p + cindex_poly a b p q = cindex_poly a b 1 (q * p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_poly_inverse_add_cross:\n  fixes p q::\"real poly\"\n  assumes \"a < b\" \"poly (p * q) a \\<noteq>0\" \"poly (p * q) b \\<noteq>0\"\n  shows \"cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b\" (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "have \"p\\<noteq>0\" and \"q\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0", "using \\<open>poly (p * q) a \\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly (p * q) a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "define g where \"g\\<equiv>gcd p q\""], ["proof (state)\nthis:\n  g \\<equiv> gcd p q\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "obtain p' q' where p':\"p= p'*g\" and q':\"q=q'*g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p' q'.\n        \\<lbrakk>p = p' * g; q = q' * g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using gcd_dvd1 gcd_dvd2 dvd_def[of \"gcd p q\", simplified mult.commute] g_def"], ["proof (prove)\nusing this:\n  gcd ?a ?b dvd ?a\n  gcd ?a ?b dvd ?b\n  (gcd p q dvd ?a) = (\\<exists>k. ?a = k * gcd p q)\n  g \\<equiv> gcd p q\n\ngoal (1 subgoal):\n 1. (\\<And>p' q'.\n        \\<lbrakk>p = p' * g; q = q' * g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  p = p' * g\n  q = q' * g\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "hence \"coprime p' q'\""], ["proof (prove)\nusing this:\n  p = p' * g\n  q = q' * g\n\ngoal (1 subgoal):\n 1. coprime p' q'", "using gcd_coprime \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p = p' * g\n  q = q' * g\n  \\<lbrakk>gcd ?a ?b \\<noteq> (0::?'a); ?a = ?a' * gcd ?a ?b;\n   ?b = ?b' * gcd ?a ?b\\<rbrakk>\n  \\<Longrightarrow> coprime ?a' ?b'\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime p' q'", "unfolding g_def"], ["proof (prove)\nusing this:\n  p = p' * gcd p q\n  q = q' * gcd p q\n  \\<lbrakk>gcd ?a ?b \\<noteq> (0::?'a); ?a = ?a' * gcd ?a ?b;\n   ?b = ?b' * gcd ?a ?b\\<rbrakk>\n  \\<Longrightarrow> coprime ?a' ?b'\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime p' q'", "by auto"], ["proof (state)\nthis:\n  coprime p' q'\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "have \"p'\\<noteq>0\" \"q'\\<noteq>0\" \"g \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' \\<noteq> 0 &&& q' \\<noteq> 0 &&& g \\<noteq> 0", "using p' q' \\<open>p\\<noteq>0\\<close> \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p = p' * g\n  q = q' * g\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p' \\<noteq> 0 &&& q' \\<noteq> 0 &&& g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p' \\<noteq> 0\n  q' \\<noteq> 0\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "have \"?L=cindex_poly a b q' p' + cindex_poly a b p' q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q =\n    cindex_poly a b q' p' + cindex_poly a b p' q'", "apply (simp only: p' q' mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b (g * q') (g * p') + cindex_poly a b (g * p') (g * q') =\n    cindex_poly a b q' p' + cindex_poly a b p' q'", "using cindex_poly_mult[OF \\<open>g\\<noteq>0\\<close>] cindex_poly_mult[OF \\<open>g\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  cindex_poly ?a ?b (g * ?q) (g * ?p) = cindex_poly ?a ?b ?q ?p\n  cindex_poly ?a ?b (g * ?q) (g * ?p) = cindex_poly ?a ?b ?q ?p\n\ngoal (1 subgoal):\n 1. cindex_poly a b (g * q') (g * p') + cindex_poly a b (g * p') (g * q') =\n    cindex_poly a b q' p' + cindex_poly a b p' q'", "by auto"], ["proof (state)\nthis:\n  cindex_poly a b q p + cindex_poly a b p q =\n  cindex_poly a b q' p' + cindex_poly a b p' q'\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "also"], ["proof (state)\nthis:\n  cindex_poly a b q p + cindex_poly a b p q =\n  cindex_poly a b q' p' + cindex_poly a b p' q'\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "have \"... = cindex_poly a b 1 (q' * p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b q' p' + cindex_poly a b p' q' =\n    cindex_poly a b 1 (q' * p')", "using  cindex_poly_inverse_add[OF \\<open>coprime p' q'\\<close>, of a b]"], ["proof (prove)\nusing this:\n  cindex_poly a b q' p' + cindex_poly a b p' q' =\n  cindex_poly a b 1 (q' * p')\n\ngoal (1 subgoal):\n 1. cindex_poly a b q' p' + cindex_poly a b p' q' =\n    cindex_poly a b 1 (q' * p')", "."], ["proof (state)\nthis:\n  cindex_poly a b q' p' + cindex_poly a b p' q' =\n  cindex_poly a b 1 (q' * p')\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "also"], ["proof (state)\nthis:\n  cindex_poly a b q' p' + cindex_poly a b p' q' =\n  cindex_poly a b 1 (q' * p')\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "have \"... = cross (p' * q') a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b 1 (q' * p') = cross (p' * q') a b", "using cindex_poly_cross[OF \\<open>a<b\\<close>, of \"q'*p'\"] \\<open>p'\\<noteq>0\\<close> \\<open>q'\\<noteq>0\\<close> \n      \\<open>poly (p * q) a \\<noteq>0\\<close> \\<open>poly (p * q) b \\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>poly (q' * p') a \\<noteq> 0; poly (q' * p') b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> cindex_poly a b 1 (q' * p') = cross (q' * p') a b\n  p' \\<noteq> 0\n  q' \\<noteq> 0\n  poly (p * q) a \\<noteq> 0\n  poly (p * q) b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_poly a b 1 (q' * p') = cross (p' * q') a b", "unfolding p' q'"], ["proof (prove)\nusing this:\n  \\<lbrakk>poly (q' * p') a \\<noteq> 0; poly (q' * p') b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> cindex_poly a b 1 (q' * p') = cross (q' * p') a b\n  p' \\<noteq> 0\n  q' \\<noteq> 0\n  poly (p' * g * (q' * g)) a \\<noteq> 0\n  poly (p' * g * (q' * g)) b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_poly a b 1 (q' * p') = cross (p' * q') a b", "apply (subst (2) mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>poly (q' * p') a \\<noteq> 0;\n              poly (q' * p') b \\<noteq> 0\\<rbrakk>\n             \\<Longrightarrow> cindex_poly a b 1 (q' * p') =\n                               cross (q' * p') a b;\n     p' \\<noteq> 0; q' \\<noteq> 0; poly (p' * g * (q' * g)) a \\<noteq> 0;\n     poly (p' * g * (q' * g)) b \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cindex_poly a b 1 (q' * p') = cross (q' * p') a b", "by auto"], ["proof (state)\nthis:\n  cindex_poly a b 1 (q' * p') = cross (p' * q') a b\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "also"], ["proof (state)\nthis:\n  cindex_poly a b 1 (q' * p') = cross (p' * q') a b\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "have \"... = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross (p' * q') a b = cross (p * q) a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cross (p' * q') a b = cross (p * q) a b", "have \"poly (p * q) a = poly (g*g) a * poly (p' * q') a\"\n        and \"poly (p * q) b = poly (g*g) b * poly (p' * q') b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (p * q) a = poly (g * g) a * poly (p' * q') a &&&\n    poly (p * q) b = poly (g * g) b * poly (p' * q') b", "unfolding p' q'"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (p' * g * (q' * g)) a = poly (g * g) a * poly (p' * q') a &&&\n    poly (p' * g * (q' * g)) b = poly (g * g) b * poly (p' * q') b", "by auto"], ["proof (state)\nthis:\n  poly (p * q) a = poly (g * g) a * poly (p' * q') a\n  poly (p * q) b = poly (g * g) b * poly (p' * q') b\n\ngoal (1 subgoal):\n 1. cross (p' * q') a b = cross (p * q) a b", "moreover"], ["proof (state)\nthis:\n  poly (p * q) a = poly (g * g) a * poly (p' * q') a\n  poly (p * q) b = poly (g * g) b * poly (p' * q') b\n\ngoal (1 subgoal):\n 1. cross (p' * q') a b = cross (p * q) a b", "have \"poly g a\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly g a \\<noteq> 0", "using \\<open>poly (p * q) a \\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly (p * q) a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly g a \\<noteq> 0", "unfolding p'"], ["proof (prove)\nusing this:\n  poly (p' * g * q) a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly g a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly g a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cross (p' * q') a b = cross (p * q) a b", "hence \"poly (g*g) a>0\""], ["proof (prove)\nusing this:\n  poly g a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < poly (g * g) a", "by (metis (poly_guards_query) not_real_square_gt_zero poly_mult)"], ["proof (state)\nthis:\n  0 < poly (g * g) a\n\ngoal (1 subgoal):\n 1. cross (p' * q') a b = cross (p * q) a b", "moreover"], ["proof (state)\nthis:\n  0 < poly (g * g) a\n\ngoal (1 subgoal):\n 1. cross (p' * q') a b = cross (p * q) a b", "have \"poly g b\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly g b \\<noteq> 0", "using \\<open>poly (p * q) b \\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly (p * q) b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly g b \\<noteq> 0", "unfolding p'"], ["proof (prove)\nusing this:\n  poly (p' * g * q) b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly g b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly g b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cross (p' * q') a b = cross (p * q) a b", "hence \"poly (g*g) b>0\""], ["proof (prove)\nusing this:\n  poly g b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < poly (g * g) b", "by (metis (poly_guards_query) not_real_square_gt_zero poly_mult)"], ["proof (state)\nthis:\n  0 < poly (g * g) b\n\ngoal (1 subgoal):\n 1. cross (p' * q') a b = cross (p * q) a b", "ultimately"], ["proof (chain)\npicking this:\n  poly (p * q) a = poly (g * g) a * poly (p' * q') a\n  poly (p * q) b = poly (g * g) b * poly (p' * q') b\n  0 < poly (g * g) a\n  0 < poly (g * g) b", "show ?thesis"], ["proof (prove)\nusing this:\n  poly (p * q) a = poly (g * g) a * poly (p' * q') a\n  poly (p * q) b = poly (g * g) b * poly (p' * q') b\n  0 < poly (g * g) a\n  0 < poly (g * g) b\n\ngoal (1 subgoal):\n 1. cross (p' * q') a b = cross (p * q) a b", "unfolding cross_def"], ["proof (prove)\nusing this:\n  poly (p * q) a = poly (g * g) a * poly (p' * q') a\n  poly (p * q) b = poly (g * g) b * poly (p' * q') b\n  0 < poly (g * g) a\n  0 < poly (g * g) b\n\ngoal (1 subgoal):\n 1. variation (poly (p' * q') a) (poly (p' * q') b) =\n    variation (poly (p * q) a) (poly (p * q) b)", "using variation_mult_pos"], ["proof (prove)\nusing this:\n  poly (p * q) a = poly (g * g) a * poly (p' * q') a\n  poly (p * q) b = poly (g * g) b * poly (p' * q') b\n  0 < poly (g * g) a\n  0 < poly (g * g) b\n  0 < ?c \\<Longrightarrow> variation (?c * ?x) ?y = variation ?x ?y\n  0 < ?c \\<Longrightarrow> variation ?x (?c * ?y) = variation ?x ?y\n\ngoal (1 subgoal):\n 1. variation (poly (p' * q') a) (poly (p' * q') b) =\n    variation (poly (p * q) a) (poly (p * q) b)", "by auto"], ["proof (state)\nthis:\n  cross (p' * q') a b = cross (p * q) a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cross (p' * q') a b = cross (p * q) a b\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "finally"], ["proof (chain)\npicking this:\n  cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "show \"?L = ?R\""], ["proof (prove)\nusing this:\n  cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b", "."], ["proof (state)\nthis:\n  cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_poly_rec:\n  fixes p q::\"real poly\"\n  assumes \"a < b\" \"poly (p * q) a \\<noteq>0\" \"poly (p * q) b \\<noteq>0\"\n  shows \"cindex_poly a b q p  = cross (p * q) a b  +  cindex_poly a b (- (p mod q)) q\" (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b q p =\n    cross (p * q) a b + cindex_poly a b (- (p mod q)) q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_poly a b q p =\n    cross (p * q) a b + cindex_poly a b (- (p mod q)) q", "have \"q\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using \\<open>poly (p * q) a \\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly (p * q) a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p =\n    cross (p * q) a b + cindex_poly a b (- (p mod q)) q", "note cindex_poly_inverse_add_cross[OF assms]"], ["proof (state)\nthis:\n  cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p =\n    cross (p * q) a b + cindex_poly a b (- (p mod q)) q", "moreover"], ["proof (state)\nthis:\n  cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p =\n    cross (p * q) a b + cindex_poly a b (- (p mod q)) q", "have \"- cindex_poly a b p q = cindex_poly a b (- (p mod q)) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - cindex_poly a b p q = cindex_poly a b (- (p mod q)) q", "using cindex_poly_mod cindex_poly_smult_1[of a b \"-1\"]"], ["proof (prove)\nusing this:\n  cindex_poly ?a ?b ?q ?p = cindex_poly ?a ?b (?q mod ?p) ?p\n  cindex_poly a b (smult (- 1) ?q) ?p = sign (- 1) * cindex_poly a b ?q ?p\n\ngoal (1 subgoal):\n 1. - cindex_poly a b p q = cindex_poly a b (- (p mod q)) q", "by auto"], ["proof (state)\nthis:\n  - cindex_poly a b p q = cindex_poly a b (- (p mod q)) q\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p =\n    cross (p * q) a b + cindex_poly a b (- (p mod q)) q", "ultimately"], ["proof (chain)\npicking this:\n  cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b\n  - cindex_poly a b p q = cindex_poly a b (- (p mod q)) q", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_poly a b q p + cindex_poly a b p q = cross (p * q) a b\n  - cindex_poly a b p q = cindex_poly a b (- (p mod q)) q\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p =\n    cross (p * q) a b + cindex_poly a b (- (p mod q)) q", "by auto"], ["proof (state)\nthis:\n  cindex_poly a b q p = cross (p * q) a b + cindex_poly a b (- (p mod q)) q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_poly_congr:\n  fixes p q:: \"real poly\"\n  assumes \"a<a'\" \"a'<b'\" \"b'<b\" \n  assumes \"\\<forall>x. ((a<x\\<and>x\\<le>a') \\<or> (b'\\<le>x \\<and> x<b)) \\<longrightarrow> poly p x \\<noteq>0\"\n  shows \"cindex_poly a b q p=cindex_poly a' b' q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b q p = cindex_poly a' b' q p", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> cindex_poly a b q p = cindex_poly a' b' q p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = cindex_poly a' b' q p", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> cindex_poly a b q p = cindex_poly a' b' q p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = cindex_poly a' b' q p", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p = cindex_poly a' b' q p", "by auto"], ["proof (state)\nthis:\n  cindex_poly a b q p = cindex_poly a' b' q p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = cindex_poly a' b' q p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = cindex_poly a' b' q p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = cindex_poly a' b' q p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b q p = cindex_poly a' b' q p", "unfolding cindex_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly q p x) =\n    (\\<Sum>x | poly p x = 0 \\<and> a' < x \\<and> x < b'. jump_poly q p x)", "apply (rule sum.mono_neutral_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n 2. {x. poly p x = 0 \\<and> a' < x \\<and> x < b'}\n    \\<subseteq> {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n 3. \\<forall>i\\<in>{x. poly p x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. poly p x = 0 \\<and> a' < x \\<and> x < b'}.\n       jump_poly q p i = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. poly p x = 0 \\<and> a < x \\<and> x < b}", "using poly_roots_finite[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. poly p x = 0 \\<and> a < x \\<and> x < b}", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x. poly p x = 0 \\<and> a' < x \\<and> x < b'}\n    \\<subseteq> {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n 2. \\<forall>i\\<in>{x. poly p x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. poly p x = 0 \\<and> a' < x \\<and> x < b'}.\n       jump_poly q p i = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0 \\<and> a' < x \\<and> x < b'}\n    \\<subseteq> {x. poly p x = 0 \\<and> a < x \\<and> x < b}", "using assms"], ["proof (prove)\nusing this:\n  a < a'\n  a' < b'\n  b' < b\n  \\<forall>x.\n     a < x \\<and> x \\<le> a' \\<or> b' \\<le> x \\<and> x < b \\<longrightarrow>\n     poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0 \\<and> a' < x \\<and> x < b'}\n    \\<subseteq> {x. poly p x = 0 \\<and> a < x \\<and> x < b}", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. poly p x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. poly p x = 0 \\<and> a' < x \\<and> x < b'}.\n       jump_poly q p i = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. poly p x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. poly p x = 0 \\<and> a' < x \\<and> x < b'}.\n       jump_poly q p i = 0", "using assms(4)"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     a < x \\<and> x \\<le> a' \\<or> b' \\<le> x \\<and> x < b \\<longrightarrow>\n     poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x. poly p x = 0 \\<and> a < x \\<and> x < b} -\n                   {x. poly p x = 0 \\<and> a' < x \\<and> x < b'}.\n       jump_poly q p i = 0", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cindex_poly a b q p = cindex_poly a' b' q p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma greaterThanLessThan_unfold:\"{a<..<b} = {x. a<x \\<and> x<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a<..<b} = {x. a < x \\<and> x < b}", "by fastforce"], ["", "lemma cindex_poly_taq:\n  fixes p q::\"real poly\"\n  shows \"taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q=cindex_poly a b (pderiv p * q) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "define S where \"S={x. poly p x = 0 \\<and> a < x \\<and> x < b}\""], ["proof (state)\nthis:\n  S = {x. poly p x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "have ?thesis when \"a\\<ge>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "have \"S = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = {}", "using that"], ["proof (prove)\nusing this:\n  b \\<le> a\n\ngoal (1 subgoal):\n 1. S = {}", "unfolding S_def"], ["proof (prove)\nusing this:\n  b \\<le> a\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0 \\<and> a < x \\<and> x < b} = {}", "by auto"], ["proof (state)\nthis:\n  S = {}\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "then"], ["proof (chain)\npicking this:\n  S = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  S = {}\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "using True"], ["proof (prove)\nusing this:\n  S = {}\n  p = 0\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "unfolding taq_def"], ["proof (prove)\nusing this:\n  S = {}\n  p = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. sign (poly q x)) =\n    cindex_poly a b (pderiv p * q) p", "by (fold S_def,simp)"], ["proof (state)\nthis:\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n  cindex_poly a b (pderiv p * q) p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<le> a \\<Longrightarrow>\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n  cindex_poly a b (pderiv p * q) p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "moreover"], ["proof (state)\nthis:\n  b \\<le> a \\<Longrightarrow>\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n  cindex_poly a b (pderiv p * q) p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "have ?thesis when \"a<b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "have \"infinite {x. a<x \\<and> x<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {x. a < x \\<and> x < b}", "using infinite_Ioo[OF \\<open>a<b\\<close>]"], ["proof (prove)\nusing this:\n  infinite {a<..<b}\n\ngoal (1 subgoal):\n 1. infinite {x. a < x \\<and> x < b}", "unfolding greaterThanLessThan_unfold"], ["proof (prove)\nusing this:\n  infinite {x. a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. infinite {x. a < x \\<and> x < b}", "by simp"], ["proof (state)\nthis:\n  infinite {x. a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "then"], ["proof (chain)\npicking this:\n  infinite {x. a < x \\<and> x < b}", "have \"infinite S\""], ["proof (prove)\nusing this:\n  infinite {x. a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. infinite S", "unfolding S_def"], ["proof (prove)\nusing this:\n  infinite {x. a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. infinite {x. poly p x = 0 \\<and> a < x \\<and> x < b}", "using True"], ["proof (prove)\nusing this:\n  infinite {x. a < x \\<and> x < b}\n  p = 0\n\ngoal (1 subgoal):\n 1. infinite {x. poly p x = 0 \\<and> a < x \\<and> x < b}", "by auto"], ["proof (state)\nthis:\n  infinite S\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "then"], ["proof (chain)\npicking this:\n  infinite S", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite S\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "using True"], ["proof (prove)\nusing this:\n  infinite S\n  p = 0\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "unfolding taq_def"], ["proof (prove)\nusing this:\n  infinite S\n  p = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. sign (poly q x)) =\n    cindex_poly a b (pderiv p * q) p", "by (fold S_def,simp)"], ["proof (state)\nthis:\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n  cindex_poly a b (pderiv p * q) p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a < b \\<Longrightarrow>\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n  cindex_poly a b (pderiv p * q) p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "ultimately"], ["proof (chain)\npicking this:\n  b \\<le> a \\<Longrightarrow>\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n  cindex_poly a b (pderiv p * q) p\n  a < b \\<Longrightarrow>\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n  cindex_poly a b (pderiv p * q) p", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<le> a \\<Longrightarrow>\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n  cindex_poly a b (pderiv p * q) p\n  a < b \\<Longrightarrow>\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n  cindex_poly a b (pderiv p * q) p\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "by fastforce"], ["proof (state)\nthis:\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n  cindex_poly a b (pderiv p * q) p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    cindex_poly a b (pderiv p * q) p", "unfolding cindex_poly_def taq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. sign (poly q x)) =\n    (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b.\n       jump_poly (pderiv p * q) p x)", "by (rule sum.cong,auto simp add:jump_poly_sgn[OF \\<open>p\\<noteq>0\\<close>])"], ["proof (state)\nthis:\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n  cindex_poly a b (pderiv p * q) p\n\ngoal:\nNo subgoals!", "qed"], ["", "section\\<open>Signed remainder sequence\\<close>"], ["", "function smods:: \"real poly \\<Rightarrow> real poly \\<Rightarrow> (real poly) list\" where\n  \"smods p q= (if p=0 then [] else Cons p (smods q (-(p mod q))))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>p q. x = (p, q) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>p q pa qa.\n       (p, q) = (pa, qa) \\<Longrightarrow>\n       (if p = 0 then [] else p # smods_sumC (q, - (p mod q))) =\n       (if pa = 0 then [] else pa # smods_sumC (qa, - (pa mod qa)))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All smods_dom", "apply (relation \"measure (\\<lambda>(p,q).if p=0 then 0 else if q=0 then 1 else 2+degree q)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measure\n         (\\<lambda>(p, q).\n             if p = 0 then 0 else if q = 0 then 1 else 2 + degree q))\n 2. \\<And>p q.\n       p \\<noteq> 0 \\<Longrightarrow>\n       ((q, - (p mod q)), p, q)\n       \\<in> measure\n              (\\<lambda>(p, q).\n                  if p = 0 then 0 else if q = 0 then 1 else 2 + degree q)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       p \\<noteq> 0 \\<Longrightarrow>\n       p mod q \\<noteq> 0 \\<longrightarrow>\n       q \\<noteq> 0 \\<longrightarrow> degree (p mod q) < degree q", "apply (metis degree_mod_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma smods_nil_eq:\"smods p q = [] \\<longleftrightarrow> (p=0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (smods p q = []) = (p = 0)", "by auto"], ["", "lemma smods_singleton:\"[x] = smods p q \\<Longrightarrow> (p\\<noteq>0 \\<and> q=0 \\<and> x=p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x] = smods p q \\<Longrightarrow> p \\<noteq> 0 \\<and> q = 0 \\<and> x = p", "by (metis list.discI list.inject smods.elims)"], ["", "lemma smods_0[simp]:\n  \"smods 0 q = []\"\n  \"smods p 0 = (if p=0 then [] else [p])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smods 0 q = [] &&& smods p 0 = (if p = 0 then [] else [p])", "by auto"], ["", "lemma no_0_in_smods: \"0\\<notin>set (smods p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> set (smods p q)", "apply (induct \"smods p q\" arbitrary:p q)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p q. [] = smods p q \\<Longrightarrow> 0 \\<notin> set (smods p q)\n 2. \\<And>a x p q.\n       \\<lbrakk>\\<And>p q.\n                   x = smods p q \\<Longrightarrow>\n                   0 \\<notin> set (smods p q);\n        a # x = smods p q\\<rbrakk>\n       \\<Longrightarrow> 0 \\<notin> set (smods p q)", "by (simp,metis list.inject neq_Nil_conv set_ConsD smods.elims)"], ["", "fun changes:: \"('a ::linordered_idom) list \\<Rightarrow> int\" where\n  \"changes [] = 0\"|\n  \"changes [_] = 0\" |\n  \"changes (x1#x2#xs) = (if x1*x2<0 then 1+changes (x2#xs) \n                          else if x2=0 then changes (x1#xs) \n                          else changes (x2#xs))\""], ["", "lemma changes_map_sgn_eq:\n  \"changes xs = changes (map sgn xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes xs = changes (map sgn xs)", "proof (induct xs rule:changes.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. changes [] = changes (map sgn [])\n 2. \\<And>uu_. changes [uu_] = changes (map sgn [uu_])\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (x2 # xs) = changes (map sgn (x2 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) =\n                          changes (map sgn (x2 # xs))\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) =\n                         changes (map sgn (x1 # x2 # xs))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. changes [] = changes (map sgn [])\n 2. \\<And>uu_. changes [uu_] = changes (map sgn [uu_])\n 3. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (x2 # xs) = changes (map sgn (x2 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) =\n                          changes (map sgn (x2 # xs))\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) =\n                         changes (map sgn (x1 # x2 # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes [] = changes (map sgn [])", "by simp"], ["proof (state)\nthis:\n  changes [] = changes (map sgn [])\n\ngoal (2 subgoals):\n 1. \\<And>uu_. changes [uu_] = changes (map sgn [uu_])\n 2. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (x2 # xs) = changes (map sgn (x2 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) =\n                          changes (map sgn (x2 # xs))\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) =\n                         changes (map sgn (x1 # x2 # xs))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>uu_. changes [uu_] = changes (map sgn [uu_])\n 2. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (x2 # xs) = changes (map sgn (x2 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) =\n                          changes (map sgn (x2 # xs))\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) =\n                         changes (map sgn (x1 # x2 # xs))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>uu_. changes [uu_] = changes (map sgn [uu_])\n 2. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (x2 # xs) = changes (map sgn (x2 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) =\n                          changes (map sgn (x2 # xs))\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) =\n                         changes (map sgn (x1 # x2 # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes [uu_] = changes (map sgn [uu_])", "by simp"], ["proof (state)\nthis:\n  changes [uu_] = changes (map sgn [uu_])\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (x2 # xs) = changes (map sgn (x2 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) =\n                          changes (map sgn (x2 # xs))\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) =\n                         changes (map sgn (x1 # x2 # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (x2 # xs) = changes (map sgn (x2 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) =\n                          changes (map sgn (x2 # xs))\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) =\n                         changes (map sgn (x1 # x2 # xs))", "case (3 x1 x2 xs)"], ["proof (state)\nthis:\n  x1 * x2 < (0::'a) \\<Longrightarrow>\n  changes (x2 # xs) = changes (map sgn (x2 # xs))\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs))\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes (x2 # xs) = changes (map sgn (x2 # xs))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (x2 # xs) = changes (map sgn (x2 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) =\n                          changes (map sgn (x2 # xs))\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) =\n                         changes (map sgn (x1 # x2 # xs))", "moreover"], ["proof (state)\nthis:\n  x1 * x2 < (0::'a) \\<Longrightarrow>\n  changes (x2 # xs) = changes (map sgn (x2 # xs))\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs))\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes (x2 # xs) = changes (map sgn (x2 # xs))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (x2 # xs) = changes (map sgn (x2 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) =\n                          changes (map sgn (x2 # xs))\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) =\n                         changes (map sgn (x1 # x2 # xs))", "have \"x1*x2<0 \\<longleftrightarrow> sgn x1 * sgn x2 < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1 * x2 < (0::'a)) = (sgn x1 * sgn x2 < (0::'a))", "by (unfold mult_less_0_iff sgn_less sgn_greater,simp)"], ["proof (state)\nthis:\n  (x1 * x2 < (0::'a)) = (sgn x1 * sgn x2 < (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (x2 # xs) = changes (map sgn (x2 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) =\n                          changes (map sgn (x2 # xs))\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) =\n                         changes (map sgn (x1 # x2 # xs))", "moreover"], ["proof (state)\nthis:\n  (x1 * x2 < (0::'a)) = (sgn x1 * sgn x2 < (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (x2 # xs) = changes (map sgn (x2 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) =\n                          changes (map sgn (x2 # xs))\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) =\n                         changes (map sgn (x1 # x2 # xs))", "have \"x2=0 \\<longleftrightarrow> sgn x2 =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x2 = (0::'a)) = (sgn x2 = (0::'a))", "by (rule sgn_0_0[symmetric])"], ["proof (state)\nthis:\n  (x2 = (0::'a)) = (sgn x2 = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 xs.\n       \\<lbrakk>x1 * x2 < (0::'a) \\<Longrightarrow>\n                changes (x2 # xs) = changes (map sgn (x2 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs));\n        \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> changes (x2 # xs) =\n                          changes (map sgn (x2 # xs))\\<rbrakk>\n       \\<Longrightarrow> changes (x1 # x2 # xs) =\n                         changes (map sgn (x1 # x2 # xs))", "ultimately"], ["proof (chain)\npicking this:\n  x1 * x2 < (0::'a) \\<Longrightarrow>\n  changes (x2 # xs) = changes (map sgn (x2 # xs))\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs))\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes (x2 # xs) = changes (map sgn (x2 # xs))\n  (x1 * x2 < (0::'a)) = (sgn x1 * sgn x2 < (0::'a))\n  (x2 = (0::'a)) = (sgn x2 = (0::'a))", "show ?case"], ["proof (prove)\nusing this:\n  x1 * x2 < (0::'a) \\<Longrightarrow>\n  changes (x2 # xs) = changes (map sgn (x2 # xs))\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes (x1 # xs) = changes (map sgn (x1 # xs))\n  \\<lbrakk>\\<not> x1 * x2 < (0::'a); x2 \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> changes (x2 # xs) = changes (map sgn (x2 # xs))\n  (x1 * x2 < (0::'a)) = (sgn x1 * sgn x2 < (0::'a))\n  (x2 = (0::'a)) = (sgn x2 = (0::'a))\n\ngoal (1 subgoal):\n 1. changes (x1 # x2 # xs) = changes (map sgn (x1 # x2 # xs))", "by auto"], ["proof (state)\nthis:\n  changes (x1 # x2 # xs) = changes (map sgn (x1 # x2 # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition changes_poly_at::\"('a ::linordered_idom) poly list \\<Rightarrow> 'a \\<Rightarrow> int\" where\n  \"changes_poly_at ps a= changes (map (\\<lambda>p. poly p a) ps)\""], ["", "definition changes_poly_pos_inf:: \"('a ::linordered_idom) poly list \\<Rightarrow> int\" where\n  \"changes_poly_pos_inf ps = changes (map sgn_pos_inf ps)\""], ["", "definition changes_poly_neg_inf:: \"('a ::linordered_idom) poly list \\<Rightarrow> int\" where\n  \"changes_poly_neg_inf ps = changes (map sgn_neg_inf ps)\""], ["", "lemma changes_poly_at_0[simp]:  \n  \"changes_poly_at [] a =0\"\n  \"changes_poly_at [p] a=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at [] a = 0 &&& changes_poly_at [p] a = 0", "unfolding changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p a) []) = 0 &&&\n    changes (map (\\<lambda>p. poly p a) [p]) = 0", "by auto"], ["", "definition changes_itv_smods:: \"real \\<Rightarrow> real \\<Rightarrow>real poly \\<Rightarrow> real poly \\<Rightarrow>  int\" where\n  \"changes_itv_smods a b p q= (let ps= smods p q in changes_poly_at ps a - changes_poly_at ps b)\""], ["", "definition changes_gt_smods:: \"real \\<Rightarrow>real poly \\<Rightarrow> real poly \\<Rightarrow>  int\" where\n  \"changes_gt_smods a p q= (let ps= smods p q in changes_poly_at ps a - changes_poly_pos_inf ps)\""], ["", "definition changes_le_smods:: \"real \\<Rightarrow>real poly \\<Rightarrow> real poly \\<Rightarrow>  int\" where\n  \"changes_le_smods b p q= (let ps= smods p q in changes_poly_neg_inf ps - changes_poly_at ps b)\""], ["", "definition changes_R_smods:: \"real poly \\<Rightarrow> real poly \\<Rightarrow>  int\" where\n  \"changes_R_smods p q= (let ps= smods p q in changes_poly_neg_inf ps - changes_poly_pos_inf ps)\""], ["", "lemma changes_R_smods_0[simp]:\n    \"changes_R_smods 0 q = 0\"\n    \"changes_R_smods p 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_R_smods 0 q = 0 &&& changes_R_smods p 0 = 0", "unfolding changes_R_smods_def changes_poly_neg_inf_def changes_poly_pos_inf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ps = smods 0 q\n     in changes (map sgn_neg_inf ps) - changes (map sgn_pos_inf ps)) =\n    0 &&&\n    (let ps = smods p 0\n     in changes (map sgn_neg_inf ps) - changes (map sgn_pos_inf ps)) =\n    0", "by auto"], ["", "lemma changes_itv_smods_0[simp]:\n  \"changes_itv_smods a b 0 q = 0\"\n  \"changes_itv_smods a b p 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_itv_smods a b 0 q = 0 &&& changes_itv_smods a b p 0 = 0", "unfolding changes_itv_smods_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ps = smods 0 q in changes_poly_at ps a - changes_poly_at ps b) =\n    0 &&&\n    (let ps = smods p 0 in changes_poly_at ps a - changes_poly_at ps b) = 0", "by auto"], ["", "lemma changes_itv_smods_rec:\n  assumes \"a<b\" \"poly (p*q) a\\<noteq>0\" \"poly (p*q) b\\<noteq>0\"\n  shows \"changes_itv_smods a b p q  = cross (p*q) a b + changes_itv_smods a b q (-(p mod q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "proof (cases \"p=0 \\<or> q=0 \\<or> p mod q = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> p mod q = 0 \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "case True"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0 \\<or> p mod q = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> p mod q = 0 \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "moreover"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0 \\<or> p mod q = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> p mod q = 0 \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "have \"p=0 \\<or> q=0 \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "unfolding changes_itv_smods_def changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    (let ps = smods p q\n     in changes (map (\\<lambda>p. poly p a) ps) -\n        changes (map (\\<lambda>p. poly p b) ps)) =\n    cross (p * q) a b +\n    (let ps = smods q (- (p mod q))\n     in changes (map (\\<lambda>p. poly p a) ps) -\n        changes (map (\\<lambda>p. poly p b) ps))", "by (erule HOL.disjE,auto)"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0 \\<Longrightarrow>\n  changes_itv_smods a b p q =\n  cross (p * q) a b + changes_itv_smods a b q (- (p mod q))\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> p mod q = 0 \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "moreover"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0 \\<Longrightarrow>\n  changes_itv_smods a b p q =\n  cross (p * q) a b + changes_itv_smods a b q (- (p mod q))\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> p mod q = 0 \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "have \"p mod q = 0 \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p mod q = 0 \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "unfolding changes_itv_smods_def changes_poly_at_def cross_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p mod q = 0 \\<Longrightarrow>\n    (let ps = smods p q\n     in changes (map (\\<lambda>p. poly p a) ps) -\n        changes (map (\\<lambda>p. poly p b) ps)) =\n    variation (poly (p * q) a) (poly (p * q) b) +\n    (let ps = smods q (- (p mod q))\n     in changes (map (\\<lambda>p. poly p a) ps) -\n        changes (map (\\<lambda>p. poly p b) ps))", "apply (insert assms(2,3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p mod q = 0; poly (p * q) a \\<noteq> 0;\n     poly (p * q) b \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (let ps = smods p q\n                       in changes (map (\\<lambda>p. poly p a) ps) -\n                          changes (map (\\<lambda>p. poly p b) ps)) =\n                      variation (poly (p * q) a) (poly (p * q) b) +\n                      (let ps = smods q (- (p mod q))\n                       in changes (map (\\<lambda>p. poly p a) ps) -\n                          changes (map (\\<lambda>p. poly p b) ps))", "apply (subst (asm) (1 2) neq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p mod q = 0; poly (p * q) a < 0 \\<or> 0 < poly (p * q) a;\n     poly (p * q) b < 0 \\<or> 0 < poly (p * q) b\\<rbrakk>\n    \\<Longrightarrow> (let ps = smods p q\n                       in changes (map (\\<lambda>p. poly p a) ps) -\n                          changes (map (\\<lambda>p. poly p b) ps)) =\n                      variation (poly (p * q) a) (poly (p * q) b) +\n                      (let ps = smods q (- (p mod q))\n                       in changes (map (\\<lambda>p. poly p a) ps) -\n                          changes (map (\\<lambda>p. poly p b) ps))", "by (auto simp add: variation_cases)"], ["proof (state)\nthis:\n  p mod q = 0 \\<Longrightarrow>\n  changes_itv_smods a b p q =\n  cross (p * q) a b + changes_itv_smods a b q (- (p mod q))\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> p mod q = 0 \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "ultimately"], ["proof (chain)\npicking this:\n  p = 0 \\<or> q = 0 \\<or> p mod q = 0\n  p = 0 \\<or> q = 0 \\<Longrightarrow>\n  changes_itv_smods a b p q =\n  cross (p * q) a b + changes_itv_smods a b q (- (p mod q))\n  p mod q = 0 \\<Longrightarrow>\n  changes_itv_smods a b p q =\n  cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0 \\<or> p mod q = 0\n  p = 0 \\<or> q = 0 \\<Longrightarrow>\n  changes_itv_smods a b p q =\n  cross (p * q) a b + changes_itv_smods a b q (- (p mod q))\n  p mod q = 0 \\<Longrightarrow>\n  changes_itv_smods a b p q =\n  cross (p * q) a b + changes_itv_smods a b q (- (p mod q))\n\ngoal (1 subgoal):\n 1. changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "by auto"], ["proof (state)\nthis:\n  changes_itv_smods a b p q =\n  cross (p * q) a b + changes_itv_smods a b q (- (p mod q))\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "case False"], ["proof (state)\nthis:\n  \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "hence \"p\\<noteq>0\" \"q\\<noteq>0\" \"p mod q\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0 &&& p mod q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  p mod q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  p mod q \\<noteq> 0", "obtain ps where ps:\"smods p q=p#q#-(p mod q)#ps\" \"smods q (-(p mod q)) = q#-(p mod q)#ps\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  p mod q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>smods p q = p # q # - (p mod q) # ps;\n         smods q (- (p mod q)) = q # - (p mod q) # ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  smods p q = p # q # - (p mod q) # ps\n  smods q (- (p mod q)) = q # - (p mod q) # ps\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "define changes_diff where \"changes_diff\\<equiv>\\<lambda>x. changes_poly_at (p#q#-(p mod q)#ps) x \n    - changes_poly_at (q#-(p mod q)#ps) x\""], ["proof (state)\nthis:\n  changes_diff \\<equiv>\n  \\<lambda>x.\n     changes_poly_at (p # q # - (p mod q) # ps) x -\n     changes_poly_at (q # - (p mod q) # ps) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "have \"\\<And>x. poly p x*poly q x<0 \\<Longrightarrow> changes_diff x=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. poly p x * poly q x < 0 \\<Longrightarrow> changes_diff x = 1", "unfolding changes_diff_def changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x * poly q x < 0 \\<Longrightarrow>\n       changes (map (\\<lambda>p. poly p x) (p # q # - (p mod q) # ps)) -\n       changes (map (\\<lambda>p. poly p x) (q # - (p mod q) # ps)) =\n       1", "by auto"], ["proof (state)\nthis:\n  poly p ?x * poly q ?x < 0 \\<Longrightarrow> changes_diff ?x = 1\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "moreover"], ["proof (state)\nthis:\n  poly p ?x * poly q ?x < 0 \\<Longrightarrow> changes_diff ?x = 1\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "have \"\\<And>x. poly p x*poly q x>0 \\<Longrightarrow> changes_diff x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. 0 < poly p x * poly q x \\<Longrightarrow> changes_diff x = 0", "unfolding changes_diff_def changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < poly p x * poly q x \\<Longrightarrow>\n       changes (map (\\<lambda>p. poly p x) (p # q # - (p mod q) # ps)) -\n       changes (map (\\<lambda>p. poly p x) (q # - (p mod q) # ps)) =\n       0", "by auto"], ["proof (state)\nthis:\n  0 < poly p ?x * poly q ?x \\<Longrightarrow> changes_diff ?x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "ultimately"], ["proof (chain)\npicking this:\n  poly p ?x * poly q ?x < 0 \\<Longrightarrow> changes_diff ?x = 1\n  0 < poly p ?x * poly q ?x \\<Longrightarrow> changes_diff ?x = 0", "have \"changes_diff a - changes_diff b=cross (p*q) a b\""], ["proof (prove)\nusing this:\n  poly p ?x * poly q ?x < 0 \\<Longrightarrow> changes_diff ?x = 1\n  0 < poly p ?x * poly q ?x \\<Longrightarrow> changes_diff ?x = 0\n\ngoal (1 subgoal):\n 1. changes_diff a - changes_diff b = cross (p * q) a b", "unfolding cross_def"], ["proof (prove)\nusing this:\n  poly p ?x * poly q ?x < 0 \\<Longrightarrow> changes_diff ?x = 1\n  0 < poly p ?x * poly q ?x \\<Longrightarrow> changes_diff ?x = 0\n\ngoal (1 subgoal):\n 1. changes_diff a - changes_diff b =\n    variation (poly (p * q) a) (poly (p * q) b)", "apply (cases rule:neqE[OF \\<open>poly (p*q) a\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                poly p x * poly q x < 0 \\<Longrightarrow>\n                changes_diff x = 1;\n     \\<And>x. 0 < poly p x * poly q x \\<Longrightarrow> changes_diff x = 0;\n     poly (p * q) a < 0\\<rbrakk>\n    \\<Longrightarrow> changes_diff a - changes_diff b =\n                      variation (poly (p * q) a) (poly (p * q) b)\n 2. \\<lbrakk>\\<And>x.\n                poly p x * poly q x < 0 \\<Longrightarrow>\n                changes_diff x = 1;\n     \\<And>x. 0 < poly p x * poly q x \\<Longrightarrow> changes_diff x = 0;\n     0 < poly (p * q) a\\<rbrakk>\n    \\<Longrightarrow> changes_diff a - changes_diff b =\n                      variation (poly (p * q) a) (poly (p * q) b)", "by (cases rule:neqE[OF \\<open>poly (p*q) b\\<noteq>0\\<close>],auto simp add:variation_cases)+"], ["proof (state)\nthis:\n  changes_diff a - changes_diff b = cross (p * q) a b\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> p mod q = 0) \\<Longrightarrow>\n    changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes_diff a - changes_diff b = cross (p * q) a b\n\ngoal (1 subgoal):\n 1. changes_itv_smods a b p q =\n    cross (p * q) a b + changes_itv_smods a b q (- (p mod q))", "unfolding changes_itv_smods_def changes_diff_def changes_poly_at_def"], ["proof (prove)\nusing this:\n  changes (map (\\<lambda>p. poly p a) (p # q # - (p mod q) # ps)) -\n  changes (map (\\<lambda>p. poly p a) (q # - (p mod q) # ps)) -\n  (changes (map (\\<lambda>p. poly p b) (p # q # - (p mod q) # ps)) -\n   changes (map (\\<lambda>p. poly p b) (q # - (p mod q) # ps))) =\n  cross (p * q) a b\n\ngoal (1 subgoal):\n 1. (let ps = smods p q\n     in changes (map (\\<lambda>p. poly p a) ps) -\n        changes (map (\\<lambda>p. poly p b) ps)) =\n    cross (p * q) a b +\n    (let ps = smods q (- (p mod q))\n     in changes (map (\\<lambda>p. poly p a) ps) -\n        changes (map (\\<lambda>p. poly p b) ps))", "using ps"], ["proof (prove)\nusing this:\n  changes (map (\\<lambda>p. poly p a) (p # q # - (p mod q) # ps)) -\n  changes (map (\\<lambda>p. poly p a) (q # - (p mod q) # ps)) -\n  (changes (map (\\<lambda>p. poly p b) (p # q # - (p mod q) # ps)) -\n   changes (map (\\<lambda>p. poly p b) (q # - (p mod q) # ps))) =\n  cross (p * q) a b\n  smods p q = p # q # - (p mod q) # ps\n  smods q (- (p mod q)) = q # - (p mod q) # ps\n\ngoal (1 subgoal):\n 1. (let ps = smods p q\n     in changes (map (\\<lambda>p. poly p a) ps) -\n        changes (map (\\<lambda>p. poly p b) ps)) =\n    cross (p * q) a b +\n    (let ps = smods q (- (p mod q))\n     in changes (map (\\<lambda>p. poly p a) ps) -\n        changes (map (\\<lambda>p. poly p b) ps))", "by auto"], ["proof (state)\nthis:\n  changes_itv_smods a b p q =\n  cross (p * q) a b + changes_itv_smods a b q (- (p mod q))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma changes_smods_congr:\n  fixes p q:: \"real poly\"\n  assumes \"a\\<noteq>a'\" \"poly p a\\<noteq>0\"\n  assumes \"\\<forall>p\\<in>set (smods p q). \\<forall>x. ((a<x\\<and>x\\<le>a') \\<or> (a'\\<le>x \\<and> x<a)) \\<longrightarrow> poly p x \\<noteq>0\"\n  shows \"changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'", "using assms(2-3)"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n  \\<forall>p\\<in>set (smods p q).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'", "proof (induct \"smods p q\" arbitrary:p q rule:length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       (\\<forall>p\\<in>set (smods x xa).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              a' \\<le> x \\<and> x < a \\<longrightarrow>\n                              poly p x \\<noteq> 0) \\<longrightarrow>\n                       changes_poly_at (smods x xa) a =\n                       changes_poly_at (smods x xa) a');\n        poly p a \\<noteq> 0;\n        \\<forall>p\\<in>set (smods p q).\n           \\<forall>x.\n              a < x \\<and> x \\<le> a' \\<or>\n              a' \\<le> x \\<and> x < a \\<longrightarrow>\n              poly p x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (smods p q) a =\n                         changes_poly_at (smods p q) a'", "case 1"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length (smods p q) \\<longrightarrow>\n     (\\<forall>x xa.\n         ys = smods x xa \\<longrightarrow>\n         poly x a \\<noteq> 0 \\<longrightarrow>\n         (\\<forall>p\\<in>set (smods x xa).\n             \\<forall>x.\n                a < x \\<and> x \\<le> a' \\<or>\n                a' \\<le> x \\<and> x < a \\<longrightarrow>\n                poly p x \\<noteq> 0) \\<longrightarrow>\n         changes_poly_at (smods x xa) a = changes_poly_at (smods x xa) a')\n  poly p a \\<noteq> 0\n  \\<forall>p\\<in>set (smods p q).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       (\\<forall>p\\<in>set (smods x xa).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              a' \\<le> x \\<and> x < a \\<longrightarrow>\n                              poly p x \\<noteq> 0) \\<longrightarrow>\n                       changes_poly_at (smods x xa) a =\n                       changes_poly_at (smods x xa) a');\n        poly p a \\<noteq> 0;\n        \\<forall>p\\<in>set (smods p q).\n           \\<forall>x.\n              a < x \\<and> x \\<le> a' \\<or>\n              a' \\<le> x \\<and> x < a \\<longrightarrow>\n              poly p x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (smods p q) a =\n                         changes_poly_at (smods p q) a'", "have \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using \\<open>poly p a \\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       (\\<forall>p\\<in>set (smods x xa).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              a' \\<le> x \\<and> x < a \\<longrightarrow>\n                              poly p x \\<noteq> 0) \\<longrightarrow>\n                       changes_poly_at (smods x xa) a =\n                       changes_poly_at (smods x xa) a');\n        poly p a \\<noteq> 0;\n        \\<forall>p\\<in>set (smods p q).\n           \\<forall>x.\n              a < x \\<and> x \\<le> a' \\<or>\n              a' \\<le> x \\<and> x < a \\<longrightarrow>\n              poly p x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (smods p q) a =\n                         changes_poly_at (smods p q) a'", "define r1 where \"r1\\<equiv>- (p mod q)\""], ["proof (state)\nthis:\n  r1 \\<equiv> - (p mod q)\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       (\\<forall>p\\<in>set (smods x xa).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              a' \\<le> x \\<and> x < a \\<longrightarrow>\n                              poly p x \\<noteq> 0) \\<longrightarrow>\n                       changes_poly_at (smods x xa) a =\n                       changes_poly_at (smods x xa) a');\n        poly p a \\<noteq> 0;\n        \\<forall>p\\<in>set (smods p q).\n           \\<forall>x.\n              a < x \\<and> x \\<le> a' \\<or>\n              a' \\<le> x \\<and> x < a \\<longrightarrow>\n              poly p x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (smods p q) a =\n                         changes_poly_at (smods p q) a'", "have a_a'_rel:\"\\<forall>pp\\<in>set (smods p q). poly pp a * poly pp a' \\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>pp\\<in>set (smods p q). 0 \\<le> poly pp a * poly pp a'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>pp\\<in>set (smods p q).\n               0 \\<le> poly pp a * poly pp a') \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<forall>pp\\<in>set (smods p q). 0 \\<le> poly pp a * poly pp a')\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>pp\\<in>set (smods p q). 0 \\<le> poly pp a * poly pp a')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>pp\\<in>set (smods p q).\n               0 \\<le> poly pp a * poly pp a') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>pp\\<in>set (smods p q). 0 \\<le> poly pp a * poly pp a')", "obtain pp where pp:\"pp\\<in>set (smods p q)\" \" poly pp a * poly pp a'<0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>pp\\<in>set (smods p q). 0 \\<le> poly pp a * poly pp a')\n\ngoal (1 subgoal):\n 1. (\\<And>pp.\n        \\<lbrakk>pp \\<in> set (smods p q);\n         poly pp a * poly pp a' < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>pp\\<in>set (smods p q). 0 \\<le> poly pp a * poly pp a')\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>pp.\n        \\<lbrakk>pp \\<in> set (smods p q);\n         poly pp a * poly pp a' < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis less_eq_real_def linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  pp \\<in> set (smods p q)\n  poly pp a * poly pp a' < 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>pp\\<in>set (smods p q).\n               0 \\<le> poly pp a * poly pp a') \\<Longrightarrow>\n    False", "hence \"a<a' \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  pp \\<in> set (smods p q)\n  poly pp a * poly pp a' < 0\n\ngoal (1 subgoal):\n 1. a < a' \\<Longrightarrow> False", "using \"1.prems\"(2) poly_IVT[of a a' pp]"], ["proof (prove)\nusing this:\n  pp \\<in> set (smods p q)\n  poly pp a * poly pp a' < 0\n  \\<forall>p\\<in>set (smods p q).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n  \\<lbrakk>a < a'; poly pp a * poly pp a' < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a. x < a' \\<and> poly pp x = 0\n\ngoal (1 subgoal):\n 1. a < a' \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  a < a' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>pp\\<in>set (smods p q).\n               0 \\<le> poly pp a * poly pp a') \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  a < a' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>pp\\<in>set (smods p q).\n               0 \\<le> poly pp a * poly pp a') \\<Longrightarrow>\n    False", "have \"a'<a\\<Longrightarrow>False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' < a \\<Longrightarrow> False", "using pp[unfolded mult.commute[of \"poly pp a\"]] \"1.prems\"(2) poly_IVT[of a' a pp]"], ["proof (prove)\nusing this:\n  pp \\<in> set (smods p q)\n  poly pp a' * poly pp a < 0\n  \\<forall>p\\<in>set (smods p q).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n  \\<lbrakk>a' < a; poly pp a' * poly pp a < 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x>a'. x < a \\<and> poly pp x = 0\n\ngoal (1 subgoal):\n 1. a' < a \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  a' < a \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>pp\\<in>set (smods p q).\n               0 \\<le> poly pp a * poly pp a') \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  a < a' \\<Longrightarrow> False\n  a' < a \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  a < a' \\<Longrightarrow> False\n  a' < a \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "using \\<open>a\\<noteq>a'\\<close>"], ["proof (prove)\nusing this:\n  a < a' \\<Longrightarrow> False\n  a' < a \\<Longrightarrow> False\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>pp\\<in>set (smods p q). 0 \\<le> poly pp a * poly pp a'\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       (\\<forall>p\\<in>set (smods x xa).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              a' \\<le> x \\<and> x < a \\<longrightarrow>\n                              poly p x \\<noteq> 0) \\<longrightarrow>\n                       changes_poly_at (smods x xa) a =\n                       changes_poly_at (smods x xa) a');\n        poly p a \\<noteq> 0;\n        \\<forall>p\\<in>set (smods p q).\n           \\<forall>x.\n              a < x \\<and> x \\<le> a' \\<or>\n              a' \\<le> x \\<and> x < a \\<longrightarrow>\n              poly p x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (smods p q) a =\n                         changes_poly_at (smods p q) a'", "have \"q=0 \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = 0 \\<Longrightarrow>\n    changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'", "by auto"], ["proof (state)\nthis:\n  q = 0 \\<Longrightarrow>\n  changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       (\\<forall>p\\<in>set (smods x xa).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              a' \\<le> x \\<and> x < a \\<longrightarrow>\n                              poly p x \\<noteq> 0) \\<longrightarrow>\n                       changes_poly_at (smods x xa) a =\n                       changes_poly_at (smods x xa) a');\n        poly p a \\<noteq> 0;\n        \\<forall>p\\<in>set (smods p q).\n           \\<forall>x.\n              a < x \\<and> x \\<le> a' \\<or>\n              a' \\<le> x \\<and> x < a \\<longrightarrow>\n              poly p x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (smods p q) a =\n                         changes_poly_at (smods p q) a'", "moreover"], ["proof (state)\nthis:\n  q = 0 \\<Longrightarrow>\n  changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       (\\<forall>p\\<in>set (smods x xa).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              a' \\<le> x \\<and> x < a \\<longrightarrow>\n                              poly p x \\<noteq> 0) \\<longrightarrow>\n                       changes_poly_at (smods x xa) a =\n                       changes_poly_at (smods x xa) a');\n        poly p a \\<noteq> 0;\n        \\<forall>p\\<in>set (smods p q).\n           \\<forall>x.\n              a < x \\<and> x \\<le> a' \\<or>\n              a' \\<le> x \\<and> x < a \\<longrightarrow>\n              poly p x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (smods p q) a =\n                         changes_poly_at (smods p q) a'", "have \"\\<lbrakk>q\\<noteq>0;poly q a=0\\<rbrakk> \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "assume \"q\\<noteq>0\" \"poly q a=0\""], ["proof (state)\nthis:\n  q \\<noteq> 0\n  poly q a = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "define r2 where \"r2\\<equiv>- (q mod r1)\""], ["proof (state)\nthis:\n  r2 \\<equiv> - (q mod r1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "have \"- poly r1 a = poly p a \""], ["proof (prove)\ngoal (1 subgoal):\n 1. - poly r1 a = poly p a", "by (metis \\<open>poly q a = 0\\<close> add.inverse_inverse add.left_neutral div_mult_mod_eq \n            mult_zero_right poly_add poly_minus poly_mult r1_def)"], ["proof (state)\nthis:\n  - poly r1 a = poly p a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "hence \"r1\\<noteq>0\" and \"poly r1 a\\<noteq>0\" and \"poly p a*poly r1 a<0\""], ["proof (prove)\nusing this:\n  - poly r1 a = poly p a\n\ngoal (1 subgoal):\n 1. r1 \\<noteq> 0 &&& poly r1 a \\<noteq> 0 &&& poly p a * poly r1 a < 0", "using \\<open>poly p a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  - poly r1 a = poly p a\n  poly p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r1 \\<noteq> 0 &&& poly r1 a \\<noteq> 0 &&& poly p a * poly r1 a < 0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- poly r1 a = poly p a; poly p a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> poly p a * poly r1 a < 0", "using mult_less_0_iff"], ["proof (prove)\nusing this:\n  (?a * ?b < (0::?'a)) =\n  ((0::?'a) < ?a \\<and> ?b < (0::?'a) \\<or>\n   ?a < (0::?'a) \\<and> (0::?'a) < ?b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>- poly r1 a = poly p a; poly p a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> poly p a * poly r1 a < 0", "by fastforce"], ["proof (state)\nthis:\n  r1 \\<noteq> 0\n  poly r1 a \\<noteq> 0\n  poly p a * poly r1 a < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "then"], ["proof (chain)\npicking this:\n  r1 \\<noteq> 0\n  poly r1 a \\<noteq> 0\n  poly p a * poly r1 a < 0", "obtain ps where ps:\"smods p q=p#q#r1#ps\" \"smods r1 r2=r1#ps\""], ["proof (prove)\nusing this:\n  r1 \\<noteq> 0\n  poly r1 a \\<noteq> 0\n  poly p a * poly r1 a < 0\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>smods p q = p # q # r1 # ps; smods r1 r2 = r1 # ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>p\\<noteq>0\\<close> \\<open>q \\<noteq> 0\\<close> r1_def r2_def smods.simps)"], ["proof (state)\nthis:\n  smods p q = p # q # r1 # ps\n  smods r1 r2 = r1 # ps\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "hence \"length (smods r1 r2)<length (smods p q)\""], ["proof (prove)\nusing this:\n  smods p q = p # q # r1 # ps\n  smods r1 r2 = r1 # ps\n\ngoal (1 subgoal):\n 1. length (smods r1 r2) < length (smods p q)", "by auto"], ["proof (state)\nthis:\n  length (smods r1 r2) < length (smods p q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "moreover"], ["proof (state)\nthis:\n  length (smods r1 r2) < length (smods p q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "have \"(\\<forall>p\\<in>set (smods r1 r2). \\<forall>x. a < x \\<and> x \\<le> a' \\<or> a' \\<le> x \\<and> x < a \\<longrightarrow> poly p x \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (smods r1 r2).\n       \\<forall>x.\n          a < x \\<and> x \\<le> a' \\<or>\n          a' \\<le> x \\<and> x < a \\<longrightarrow>\n          poly p x \\<noteq> 0", "using \"1.prems\"(2)"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (smods p q).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (smods r1 r2).\n       \\<forall>x.\n          a < x \\<and> x \\<le> a' \\<or>\n          a' \\<le> x \\<and> x < a \\<longrightarrow>\n          poly p x \\<noteq> 0", "unfolding ps"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (p # q # r1 # ps).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (r1 # ps).\n       \\<forall>x.\n          a < x \\<and> x \\<le> a' \\<or>\n          a' \\<le> x \\<and> x < a \\<longrightarrow>\n          poly p x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (smods r1 r2).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "ultimately"], ["proof (chain)\npicking this:\n  length (smods r1 r2) < length (smods p q)\n  \\<forall>p\\<in>set (smods r1 r2).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0", "have \"changes_poly_at (smods r1 r2) a = changes_poly_at (smods r1 r2) a'\""], ["proof (prove)\nusing this:\n  length (smods r1 r2) < length (smods p q)\n  \\<forall>p\\<in>set (smods r1 r2).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (smods r1 r2) a = changes_poly_at (smods r1 r2) a'", "using \"1.hyps\" \\<open>r1\\<noteq>0\\<close> \\<open>poly r1 a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  length (smods r1 r2) < length (smods p q)\n  \\<forall>p\\<in>set (smods r1 r2).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n  \\<forall>ys.\n     length ys < length (smods p q) \\<longrightarrow>\n     (\\<forall>x xa.\n         ys = smods x xa \\<longrightarrow>\n         poly x a \\<noteq> 0 \\<longrightarrow>\n         (\\<forall>p\\<in>set (smods x xa).\n             \\<forall>x.\n                a < x \\<and> x \\<le> a' \\<or>\n                a' \\<le> x \\<and> x < a \\<longrightarrow>\n                poly p x \\<noteq> 0) \\<longrightarrow>\n         changes_poly_at (smods x xa) a = changes_poly_at (smods x xa) a')\n  r1 \\<noteq> 0\n  poly r1 a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (smods r1 r2) a = changes_poly_at (smods r1 r2) a'", "by metis"], ["proof (state)\nthis:\n  changes_poly_at (smods r1 r2) a = changes_poly_at (smods r1 r2) a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "moreover"], ["proof (state)\nthis:\n  changes_poly_at (smods r1 r2) a = changes_poly_at (smods r1 r2) a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "have \"changes_poly_at (smods p q) a = 1+changes_poly_at (smods r1 r2) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a = 1 + changes_poly_at (smods r1 r2) a", "unfolding ps changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p a) (p # q # r1 # ps)) =\n    1 + changes (map (\\<lambda>p. poly p a) (r1 # ps))", "using \\<open>poly q a=0\\<close> \\<open>poly p a*poly r1 a<0\\<close>"], ["proof (prove)\nusing this:\n  poly q a = 0\n  poly p a * poly r1 a < 0\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p a) (p # q # r1 # ps)) =\n    1 + changes (map (\\<lambda>p. poly p a) (r1 # ps))", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (smods p q) a = 1 + changes_poly_at (smods r1 r2) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "moreover"], ["proof (state)\nthis:\n  changes_poly_at (smods p q) a = 1 + changes_poly_at (smods r1 r2) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "have \"changes_poly_at (smods p q) a' = 1+changes_poly_at (smods r1 r2) a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a' = 1 + changes_poly_at (smods r1 r2) a'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a' = 1 + changes_poly_at (smods r1 r2) a'", "have \"poly p a * poly p a' \\<ge>0\" and \"poly r1 a*poly r1 a'\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> poly p a * poly p a' &&& 0 \\<le> poly r1 a * poly r1 a'", "using a_a'_rel"], ["proof (prove)\nusing this:\n  \\<forall>pp\\<in>set (smods p q). 0 \\<le> poly pp a * poly pp a'\n\ngoal (1 subgoal):\n 1. 0 \\<le> poly p a * poly p a' &&& 0 \\<le> poly r1 a * poly r1 a'", "unfolding ps"], ["proof (prove)\nusing this:\n  \\<forall>pp\\<in>set (p # q # r1 # ps). 0 \\<le> poly pp a * poly pp a'\n\ngoal (1 subgoal):\n 1. 0 \\<le> poly p a * poly p a' &&& 0 \\<le> poly r1 a * poly r1 a'", "by auto"], ["proof (state)\nthis:\n  0 \\<le> poly p a * poly p a'\n  0 \\<le> poly r1 a * poly r1 a'\n\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a' = 1 + changes_poly_at (smods r1 r2) a'", "moreover"], ["proof (state)\nthis:\n  0 \\<le> poly p a * poly p a'\n  0 \\<le> poly r1 a * poly r1 a'\n\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a' = 1 + changes_poly_at (smods r1 r2) a'", "have \"poly p a'\\<noteq>0\" and \"poly q a'\\<noteq>0\" and \"poly r1 a'\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p a' \\<noteq> 0 &&& poly q a' \\<noteq> 0 &&& poly r1 a' \\<noteq> 0", "using \"1.prems\"(2)[unfolded ps] \\<open>a\\<noteq>a'\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (p # q # r1 # ps).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. poly p a' \\<noteq> 0 &&& poly q a' \\<noteq> 0 &&& poly r1 a' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p a' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  poly r1 a' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a' = 1 + changes_poly_at (smods r1 r2) a'", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> poly p a * poly p a'\n  0 \\<le> poly r1 a * poly r1 a'\n  poly p a' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  poly r1 a' \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> poly p a * poly p a'\n  0 \\<le> poly r1 a * poly r1 a'\n  poly p a' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  poly r1 a' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a' = 1 + changes_poly_at (smods r1 r2) a'", "using \\<open>poly p a*poly r1 a<0\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> poly p a * poly p a'\n  0 \\<le> poly r1 a * poly r1 a'\n  poly p a' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  poly r1 a' \\<noteq> 0\n  poly p a * poly r1 a < 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a' = 1 + changes_poly_at (smods r1 r2) a'", "unfolding ps changes_poly_at_def"], ["proof (prove)\nusing this:\n  0 \\<le> poly p a * poly p a'\n  0 \\<le> poly r1 a * poly r1 a'\n  poly p a' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  poly r1 a' \\<noteq> 0\n  poly p a * poly r1 a < 0\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p a') (p # q # r1 # ps)) =\n    1 + changes (map (\\<lambda>p. poly p a') (r1 # ps))", "by (auto simp add: zero_le_mult_iff, auto simp add: mult_less_0_iff)"], ["proof (state)\nthis:\n  changes_poly_at (smods p q) a' = 1 + changes_poly_at (smods r1 r2) a'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_poly_at (smods p q) a' = 1 + changes_poly_at (smods r1 r2) a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "ultimately"], ["proof (chain)\npicking this:\n  changes_poly_at (smods r1 r2) a = changes_poly_at (smods r1 r2) a'\n  changes_poly_at (smods p q) a = 1 + changes_poly_at (smods r1 r2) a\n  changes_poly_at (smods p q) a' = 1 + changes_poly_at (smods r1 r2) a'", "show ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at (smods r1 r2) a = changes_poly_at (smods r1 r2) a'\n  changes_poly_at (smods p q) a = 1 + changes_poly_at (smods r1 r2) a\n  changes_poly_at (smods p q) a' = 1 + changes_poly_at (smods r1 r2) a'\n\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'", "by simp"], ["proof (state)\nthis:\n  changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (smods p q) a =\n                    changes_poly_at (smods p q) a'\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       (\\<forall>p\\<in>set (smods x xa).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              a' \\<le> x \\<and> x < a \\<longrightarrow>\n                              poly p x \\<noteq> 0) \\<longrightarrow>\n                       changes_poly_at (smods x xa) a =\n                       changes_poly_at (smods x xa) a');\n        poly p a \\<noteq> 0;\n        \\<forall>p\\<in>set (smods p q).\n           \\<forall>x.\n              a < x \\<and> x \\<le> a' \\<or>\n              a' \\<le> x \\<and> x < a \\<longrightarrow>\n              poly p x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (smods p q) a =\n                         changes_poly_at (smods p q) a'", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (smods p q) a =\n                    changes_poly_at (smods p q) a'\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       (\\<forall>p\\<in>set (smods x xa).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              a' \\<le> x \\<and> x < a \\<longrightarrow>\n                              poly p x \\<noteq> 0) \\<longrightarrow>\n                       changes_poly_at (smods x xa) a =\n                       changes_poly_at (smods x xa) a');\n        poly p a \\<noteq> 0;\n        \\<forall>p\\<in>set (smods p q).\n           \\<forall>x.\n              a < x \\<and> x \\<le> a' \\<or>\n              a' \\<le> x \\<and> x < a \\<longrightarrow>\n              poly p x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (smods p q) a =\n                         changes_poly_at (smods p q) a'", "have \"\\<lbrakk>q\\<noteq>0;poly q a\\<noteq>0\\<rbrakk> \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "assume \"q\\<noteq>0\" \"poly q a\\<noteq>0\""], ["proof (state)\nthis:\n  q \\<noteq> 0\n  poly q a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "then"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  poly q a \\<noteq> 0", "obtain ps where ps:\"smods p q=p#q#ps\" \"smods q r1=q#ps\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  poly q a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>smods p q = p # q # ps; smods q r1 = q # ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>p\\<noteq>0\\<close> r1_def smods.simps)"], ["proof (state)\nthis:\n  smods p q = p # q # ps\n  smods q r1 = q # ps\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "hence \"length (smods q r1) < length (smods p q)\""], ["proof (prove)\nusing this:\n  smods p q = p # q # ps\n  smods q r1 = q # ps\n\ngoal (1 subgoal):\n 1. length (smods q r1) < length (smods p q)", "by auto"], ["proof (state)\nthis:\n  length (smods q r1) < length (smods p q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "moreover"], ["proof (state)\nthis:\n  length (smods q r1) < length (smods p q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "have \"(\\<forall>p\\<in>set (smods q r1). \\<forall>x. a < x \\<and> x \\<le> a' \\<or> a' \\<le> x \\<and> x < a \\<longrightarrow> poly p x \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (smods q r1).\n       \\<forall>x.\n          a < x \\<and> x \\<le> a' \\<or>\n          a' \\<le> x \\<and> x < a \\<longrightarrow>\n          poly p x \\<noteq> 0", "using \"1.prems\"(2)"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (smods p q).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (smods q r1).\n       \\<forall>x.\n          a < x \\<and> x \\<le> a' \\<or>\n          a' \\<le> x \\<and> x < a \\<longrightarrow>\n          poly p x \\<noteq> 0", "unfolding ps"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (p # q # ps).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (q # ps).\n       \\<forall>x.\n          a < x \\<and> x \\<le> a' \\<or>\n          a' \\<le> x \\<and> x < a \\<longrightarrow>\n          poly p x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (smods q r1).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "ultimately"], ["proof (chain)\npicking this:\n  length (smods q r1) < length (smods p q)\n  \\<forall>p\\<in>set (smods q r1).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0", "have \"changes_poly_at (smods q r1) a = changes_poly_at (smods q r1) a'\""], ["proof (prove)\nusing this:\n  length (smods q r1) < length (smods p q)\n  \\<forall>p\\<in>set (smods q r1).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (smods q r1) a = changes_poly_at (smods q r1) a'", "using \"1.hyps\" \\<open>q\\<noteq>0\\<close> \\<open>poly q a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  length (smods q r1) < length (smods p q)\n  \\<forall>p\\<in>set (smods q r1).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n  \\<forall>ys.\n     length ys < length (smods p q) \\<longrightarrow>\n     (\\<forall>x xa.\n         ys = smods x xa \\<longrightarrow>\n         poly x a \\<noteq> 0 \\<longrightarrow>\n         (\\<forall>p\\<in>set (smods x xa).\n             \\<forall>x.\n                a < x \\<and> x \\<le> a' \\<or>\n                a' \\<le> x \\<and> x < a \\<longrightarrow>\n                poly p x \\<noteq> 0) \\<longrightarrow>\n         changes_poly_at (smods x xa) a = changes_poly_at (smods x xa) a')\n  q \\<noteq> 0\n  poly q a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (smods q r1) a = changes_poly_at (smods q r1) a'", "by metis"], ["proof (state)\nthis:\n  changes_poly_at (smods q r1) a = changes_poly_at (smods q r1) a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "moreover"], ["proof (state)\nthis:\n  changes_poly_at (smods q r1) a = changes_poly_at (smods q r1) a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "have \"poly p a'\\<noteq>0\" and \"poly q a'\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p a' \\<noteq> 0 &&& poly q a' \\<noteq> 0", "using \"1.prems\"(2)[unfolded ps] \\<open>a\\<noteq>a'\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (p # q # ps).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        a' \\<le> x \\<and> x < a \\<longrightarrow>\n        poly p x \\<noteq> 0\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. poly p a' \\<noteq> 0 &&& poly q a' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p a' \\<noteq> 0\n  poly q a' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "moreover"], ["proof (state)\nthis:\n  poly p a' \\<noteq> 0\n  poly q a' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "have \"poly p a * poly p a' \\<ge>0\" and \"poly q a*poly q a'\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> poly p a * poly p a' &&& 0 \\<le> poly q a * poly q a'", "using a_a'_rel"], ["proof (prove)\nusing this:\n  \\<forall>pp\\<in>set (smods p q). 0 \\<le> poly pp a * poly pp a'\n\ngoal (1 subgoal):\n 1. 0 \\<le> poly p a * poly p a' &&& 0 \\<le> poly q a * poly q a'", "unfolding ps"], ["proof (prove)\nusing this:\n  \\<forall>pp\\<in>set (p # q # ps). 0 \\<le> poly pp a * poly pp a'\n\ngoal (1 subgoal):\n 1. 0 \\<le> poly p a * poly p a' &&& 0 \\<le> poly q a * poly q a'", "by auto"], ["proof (state)\nthis:\n  0 \\<le> poly p a * poly p a'\n  0 \\<le> poly q a * poly q a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (smods p q) a =\n                      changes_poly_at (smods p q) a'", "ultimately"], ["proof (chain)\npicking this:\n  changes_poly_at (smods q r1) a = changes_poly_at (smods q r1) a'\n  poly p a' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  0 \\<le> poly p a * poly p a'\n  0 \\<le> poly q a * poly q a'", "show ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at (smods q r1) a = changes_poly_at (smods q r1) a'\n  poly p a' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  0 \\<le> poly p a * poly p a'\n  0 \\<le> poly q a * poly q a'\n\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'", "unfolding ps changes_poly_at_def"], ["proof (prove)\nusing this:\n  changes (map (\\<lambda>p. poly p a) (q # ps)) =\n  changes (map (\\<lambda>p. poly p a') (q # ps))\n  poly p a' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  0 \\<le> poly p a * poly p a'\n  0 \\<le> poly q a * poly q a'\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p a) (p # q # ps)) =\n    changes (map (\\<lambda>p. poly p a') (p # q # ps))", "using  \\<open>poly q a\\<noteq>0\\<close> \\<open>poly p a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  changes (map (\\<lambda>p. poly p a) (q # ps)) =\n  changes (map (\\<lambda>p. poly p a') (q # ps))\n  poly p a' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  0 \\<le> poly p a * poly p a'\n  0 \\<le> poly q a * poly q a'\n  poly q a \\<noteq> 0\n  poly p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p a) (p # q # ps)) =\n    changes (map (\\<lambda>p. poly p a') (p # q # ps))", "by (auto simp add: zero_le_mult_iff,auto simp add: mult_less_0_iff)"], ["proof (state)\nthis:\n  changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (smods p q) a =\n                    changes_poly_at (smods p q) a'\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       (\\<forall>p\\<in>set (smods x xa).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              a' \\<le> x \\<and> x < a \\<longrightarrow>\n                              poly p x \\<noteq> 0) \\<longrightarrow>\n                       changes_poly_at (smods x xa) a =\n                       changes_poly_at (smods x xa) a');\n        poly p a \\<noteq> 0;\n        \\<forall>p\\<in>set (smods p q).\n           \\<forall>x.\n              a < x \\<and> x \\<le> a' \\<or>\n              a' \\<le> x \\<and> x < a \\<longrightarrow>\n              poly p x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (smods p q) a =\n                         changes_poly_at (smods p q) a'", "ultimately"], ["proof (chain)\npicking this:\n  q = 0 \\<Longrightarrow>\n  changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\n  \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (smods p q) a =\n                    changes_poly_at (smods p q) a'\n  \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (smods p q) a =\n                    changes_poly_at (smods p q) a'", "show ?case"], ["proof (prove)\nusing this:\n  q = 0 \\<Longrightarrow>\n  changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\n  \\<lbrakk>q \\<noteq> 0; poly q a = 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (smods p q) a =\n                    changes_poly_at (smods p q) a'\n  \\<lbrakk>q \\<noteq> 0; poly q a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (smods p q) a =\n                    changes_poly_at (smods p q) a'\n\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'", "by blast"], ["proof (state)\nthis:\n  changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma changes_itv_smods_congr:\n  fixes p q:: \"real poly\"\n  assumes \"a<a'\" \"a'<b'\" \"b'<b\" \"poly p a\\<noteq>0\" \"poly p b\\<noteq>0\"\n  assumes no_root:\"\\<forall>p\\<in>set (smods p q). \\<forall>x. ((a<x\\<and>x\\<le>a') \\<or> (b'\\<le>x \\<and> x<b)) \\<longrightarrow> poly p x \\<noteq>0\"\n  shows \"changes_itv_smods a b p q=changes_itv_smods a' b' p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_itv_smods a b p q = changes_itv_smods a' b' p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_itv_smods a b p q = changes_itv_smods a' b' p q", "have \"changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'", "apply (rule changes_smods_congr[OF order.strict_implies_not_eq[OF \\<open>a<a'\\<close>] \\<open>poly p a\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (smods p q).\n       \\<forall>x.\n          a < x \\<and> x \\<le> a' \\<or>\n          a' \\<le> x \\<and> x < a \\<longrightarrow>\n          poly p x \\<noteq> 0", "by (metis assms(1) less_eq_real_def less_irrefl less_trans no_root)"], ["proof (state)\nthis:\n  changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\n\ngoal (1 subgoal):\n 1. changes_itv_smods a b p q = changes_itv_smods a' b' p q", "moreover"], ["proof (state)\nthis:\n  changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\n\ngoal (1 subgoal):\n 1. changes_itv_smods a b p q = changes_itv_smods a' b' p q", "have \"changes_poly_at (smods p q) b = changes_poly_at (smods p q) b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) b = changes_poly_at (smods p q) b'", "apply (rule changes_smods_congr[OF order.strict_implies_not_eq[OF \\<open>b'<b\\<close>, \n        symmetric] \\<open>poly p b\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (smods p q).\n       \\<forall>x.\n          b < x \\<and> x \\<le> b' \\<or>\n          b' \\<le> x \\<and> x < b \\<longrightarrow>\n          poly p x \\<noteq> 0", "by (metis assms(3) less_eq_real_def less_trans no_root)"], ["proof (state)\nthis:\n  changes_poly_at (smods p q) b = changes_poly_at (smods p q) b'\n\ngoal (1 subgoal):\n 1. changes_itv_smods a b p q = changes_itv_smods a' b' p q", "ultimately"], ["proof (chain)\npicking this:\n  changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\n  changes_poly_at (smods p q) b = changes_poly_at (smods p q) b'", "show ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\n  changes_poly_at (smods p q) b = changes_poly_at (smods p q) b'\n\ngoal (1 subgoal):\n 1. changes_itv_smods a b p q = changes_itv_smods a' b' p q", "unfolding changes_itv_smods_def Let_def"], ["proof (prove)\nusing this:\n  changes_poly_at (smods p q) a = changes_poly_at (smods p q) a'\n  changes_poly_at (smods p q) b = changes_poly_at (smods p q) b'\n\ngoal (1 subgoal):\n 1. changes_poly_at (smods p q) a - changes_poly_at (smods p q) b =\n    changes_poly_at (smods p q) a' - changes_poly_at (smods p q) b'", "by auto"], ["proof (state)\nthis:\n  changes_itv_smods a b p q = changes_itv_smods a' b' p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_poly_changes_itv_mods: \n  assumes \"a<b\" \"poly p a\\<noteq>0\" \"poly p b\\<noteq>0\"\n  shows \"cindex_poly a b q p = changes_itv_smods a b p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b q p = changes_itv_smods a b p q", "using assms"], ["proof (prove)\nusing this:\n  a < b\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p = changes_itv_smods a b p q", "proof (induct \"smods p q\" arbitrary:p q a b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q a b.\n       \\<lbrakk>[] = smods p q; a < b; poly p a \\<noteq> 0;\n        poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b q p = changes_itv_smods a b p q\n 2. \\<And>a x p q aa b.\n       \\<lbrakk>\\<And>p q a b.\n                   \\<lbrakk>x = smods p q; a < b; poly p a \\<noteq> 0;\n                    poly p b \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> cindex_poly a b q p =\n                                     changes_itv_smods a b p q;\n        a # x = smods p q; aa < b; poly p aa \\<noteq> 0;\n        poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly aa b q p = changes_itv_smods aa b p q", "case Nil"], ["proof (state)\nthis:\n  [] = smods p q\n  a < b\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p q a b.\n       \\<lbrakk>[] = smods p q; a < b; poly p a \\<noteq> 0;\n        poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b q p = changes_itv_smods a b p q\n 2. \\<And>a x p q aa b.\n       \\<lbrakk>\\<And>p q a b.\n                   \\<lbrakk>x = smods p q; a < b; poly p a \\<noteq> 0;\n                    poly p b \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> cindex_poly a b q p =\n                                     changes_itv_smods a b p q;\n        a # x = smods p q; aa < b; poly p aa \\<noteq> 0;\n        poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly aa b q p = changes_itv_smods aa b p q", "hence \"p=0\""], ["proof (prove)\nusing this:\n  [] = smods p q\n  a < b\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p = 0", "by (metis smods_nil_eq)"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p q a b.\n       \\<lbrakk>[] = smods p q; a < b; poly p a \\<noteq> 0;\n        poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly a b q p = changes_itv_smods a b p q\n 2. \\<And>a x p q aa b.\n       \\<lbrakk>\\<And>p q a b.\n                   \\<lbrakk>x = smods p q; a < b; poly p a \\<noteq> 0;\n                    poly p b \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> cindex_poly a b q p =\n                                     changes_itv_smods a b p q;\n        a # x = smods p q; aa < b; poly p aa \\<noteq> 0;\n        poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly aa b q p = changes_itv_smods aa b p q", "thus ?case"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p = changes_itv_smods a b p q", "using \\<open>poly p a \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  p = 0\n  poly p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p = changes_itv_smods a b p q", "by simp"], ["proof (state)\nthis:\n  cindex_poly a b q p = changes_itv_smods a b p q\n\ngoal (1 subgoal):\n 1. \\<And>a x p q aa b.\n       \\<lbrakk>\\<And>p q a b.\n                   \\<lbrakk>x = smods p q; a < b; poly p a \\<noteq> 0;\n                    poly p b \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> cindex_poly a b q p =\n                                     changes_itv_smods a b p q;\n        a # x = smods p q; aa < b; poly p aa \\<noteq> 0;\n        poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly aa b q p = changes_itv_smods aa b p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x p q aa b.\n       \\<lbrakk>\\<And>p q a b.\n                   \\<lbrakk>x = smods p q; a < b; poly p a \\<noteq> 0;\n                    poly p b \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> cindex_poly a b q p =\n                                     changes_itv_smods a b p q;\n        a # x = smods p q; aa < b; poly p aa \\<noteq> 0;\n        poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly aa b q p = changes_itv_smods aa b p q", "case (Cons x1 xs)"], ["proof (state)\nthis:\n  \\<lbrakk>xs = smods ?p ?q; ?a < ?b; poly ?p ?a \\<noteq> 0;\n   poly ?p ?b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> cindex_poly ?a ?b ?q ?p = changes_itv_smods ?a ?b ?p ?q\n  x1 # xs = smods p q\n  a < b\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a x p q aa b.\n       \\<lbrakk>\\<And>p q a b.\n                   \\<lbrakk>x = smods p q; a < b; poly p a \\<noteq> 0;\n                    poly p b \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> cindex_poly a b q p =\n                                     changes_itv_smods a b p q;\n        a # x = smods p q; aa < b; poly p aa \\<noteq> 0;\n        poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly aa b q p = changes_itv_smods aa b p q", "have \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using \\<open>poly p a \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a x p q aa b.\n       \\<lbrakk>\\<And>p q a b.\n                   \\<lbrakk>x = smods p q; a < b; poly p a \\<noteq> 0;\n                    poly p b \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> cindex_poly a b q p =\n                                     changes_itv_smods a b p q;\n        a # x = smods p q; aa < b; poly p aa \\<noteq> 0;\n        poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly aa b q p = changes_itv_smods aa b p q", "obtain a' b' where \"a<a'\" \"a'<b'\" \"b'<b\" \n      and no_root:\"\\<forall>p\\<in>set (smods p q). \\<forall>x. ((a<x\\<and>x\\<le>a') \\<or> (b'\\<le>x \\<and> x<b)) \\<longrightarrow> poly p x \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a' b'.\n        \\<lbrakk>a < a'; a' < b'; b' < b;\n         \\<forall>p\\<in>set (smods p q).\n            \\<forall>x.\n               a < x \\<and> x \\<le> a' \\<or>\n               b' \\<le> x \\<and> x < b \\<longrightarrow>\n               poly p x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct \"smods p q\" arbitrary:p q thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q thesis.\n       \\<lbrakk>[] = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  [] = smods p q\n  \\<lbrakk>a < ?a'; ?a' < ?b'; ?b' < b;\n   \\<forall>p\\<in>set (smods p q).\n      \\<forall>x.\n         a < x \\<and> x \\<le> ?a' \\<or>\n         ?b' \\<le> x \\<and> x < b \\<longrightarrow>\n         poly p x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>p q thesis.\n       \\<lbrakk>[] = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "define a' b' where \"a'\\<equiv>2/3 * a + 1/3 * b\" and \"b'\\<equiv>1/3*a + 2/3*b\""], ["proof (state)\nthis:\n  a' \\<equiv> 2 / 3 * a + 1 / 3 * b\n  b' \\<equiv> 1 / 3 * a + 2 / 3 * b\n\ngoal (2 subgoals):\n 1. \\<And>p q thesis.\n       \\<lbrakk>[] = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"a < a'\" and \"a' < b'\" and \"b' < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < a' &&& a' < b' &&& b' < b", "unfolding a'_def b'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < 2 / 3 * a + 1 / 3 * b &&&\n    2 / 3 * a + 1 / 3 * b < 1 / 3 * a + 2 / 3 * b &&&\n    1 / 3 * a + 2 / 3 * b < b", "using \\<open>a<b\\<close>"], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. a < 2 / 3 * a + 1 / 3 * b &&&\n    2 / 3 * a + 1 / 3 * b < 1 / 3 * a + 2 / 3 * b &&&\n    1 / 3 * a + 2 / 3 * b < b", "by auto"], ["proof (state)\nthis:\n  a < a'\n  a' < b'\n  b' < b\n\ngoal (2 subgoals):\n 1. \\<And>p q thesis.\n       \\<lbrakk>[] = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  a < a'\n  a' < b'\n  b' < b\n\ngoal (2 subgoals):\n 1. \\<And>p q thesis.\n       \\<lbrakk>[] = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<forall>p\\<in>set (smods p q). \\<forall>x. a < x \\<and> x \\<le> a' \\<or> b' \\<le> x \\<and> x < b \\<longrightarrow> poly p x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (smods p q).\n       \\<forall>x.\n          a < x \\<and> x \\<le> a' \\<or>\n          b' \\<le> x \\<and> x < b \\<longrightarrow>\n          poly p x \\<noteq> 0", "unfolding \\<open>[] = smods p q\\<close>[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set [].\n       \\<forall>x.\n          a < x \\<and> x \\<le> a' \\<or>\n          b' \\<le> x \\<and> x < b \\<longrightarrow>\n          poly p x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (smods p q).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        b' \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p q thesis.\n       \\<lbrakk>[] = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  a < a'\n  a' < b'\n  b' < b\n  \\<forall>p\\<in>set (smods p q).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        b' \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  a < a'\n  a' < b'\n  b' < b\n  \\<forall>p\\<in>set (smods p q).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        b' \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. thesis", "using Nil"], ["proof (prove)\nusing this:\n  a < a'\n  a' < b'\n  b' < b\n  \\<forall>p\\<in>set (smods p q).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        b' \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0\n  [] = smods p q\n  \\<lbrakk>a < ?a'; ?a' < ?b'; ?b' < b;\n   \\<forall>p\\<in>set (smods p q).\n      \\<forall>x.\n         a < x \\<and> x \\<le> ?a' \\<or>\n         ?b' \\<le> x \\<and> x < b \\<longrightarrow>\n         poly p x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons x1 xs)"], ["proof (state)\nthis:\n  \\<lbrakk>xs = smods ?p ?q;\n   \\<And>a' b'.\n      \\<lbrakk>a < a'; a' < b'; b' < b;\n       \\<forall>p\\<in>set (smods ?p ?q).\n          \\<forall>x.\n             a < x \\<and> x \\<le> a' \\<or>\n             b' \\<le> x \\<and> x < b \\<longrightarrow>\n             poly p x \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  x1 # xs = smods p q\n  \\<lbrakk>a < ?a'; ?a' < ?b'; ?b' < b;\n   \\<forall>p\\<in>set (smods p q).\n      \\<forall>x.\n         a < x \\<and> x \\<le> ?a' \\<or>\n         ?b' \\<le> x \\<and> x < b \\<longrightarrow>\n         poly p x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "define r where \"r\\<equiv>- (p mod q)\""], ["proof (state)\nthis:\n  r \\<equiv> - (p mod q)\n\ngoal (1 subgoal):\n 1. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  r \\<equiv> - (p mod q)", "have \"smods p q = p # xs\" and \"smods q r = xs\" and \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  r \\<equiv> - (p mod q)\n\ngoal (1 subgoal):\n 1. smods p q = p # xs &&& smods q r = xs &&& p \\<noteq> 0", "using \\<open>x1 # xs = smods p q\\<close>"], ["proof (prove)\nusing this:\n  r \\<equiv> - (p mod q)\n  x1 # xs = smods p q\n\ngoal (1 subgoal):\n 1. smods p q = p # xs &&& smods q r = xs &&& p \\<noteq> 0", "by (auto simp del: smods.simps simp add: smods.simps [of p q] split: if_splits)"], ["proof (state)\nthis:\n  smods p q = p # xs\n  smods q r = xs\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain a1 b1 where \n          \"a < a1\"  \"a1 < b1\"  \"b1 < b\" and  \n          a1_b1_no_root:\"\\<forall>p\\<in>set xs. \\<forall>x. a < x \\<and> x \\<le> a1 \\<or> b1 \\<le> x \\<and> x < b \\<longrightarrow> poly p x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a1 b1.\n        \\<lbrakk>a < a1; a1 < b1; b1 < b;\n         \\<forall>p\\<in>set xs.\n            \\<forall>x.\n               a < x \\<and> x \\<le> a1 \\<or>\n               b1 \\<le> x \\<and> x < b \\<longrightarrow>\n               poly p x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons(1)[OF \\<open>smods q r=xs\\<close>[symmetric]] \\<open>smods q r=xs\\<close>"], ["proof (prove)\nusing this:\n  (\\<And>a' b'.\n      \\<lbrakk>a < a'; a' < b'; b' < b;\n       \\<forall>p\\<in>set (smods q r).\n          \\<forall>x.\n             a < x \\<and> x \\<le> a' \\<or>\n             b' \\<le> x \\<and> x < b \\<longrightarrow>\n             poly p x \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  smods q r = xs\n\ngoal (1 subgoal):\n 1. (\\<And>a1 b1.\n        \\<lbrakk>a < a1; a1 < b1; b1 < b;\n         \\<forall>p\\<in>set xs.\n            \\<forall>x.\n               a < x \\<and> x \\<le> a1 \\<or>\n               b1 \\<le> x \\<and> x < b \\<longrightarrow>\n               poly p x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a < a1\n  a1 < b1\n  b1 < b\n  \\<forall>p\\<in>set xs.\n     \\<forall>x.\n        a < x \\<and> x \\<le> a1 \\<or>\n        b1 \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain a2 b2 where\n          \"a<a2\" and a2:\"\\<forall>x. a<x \\<and> x\\<le>a2 \\<longrightarrow> poly p x \\<noteq> 0\"\n          \"b2<b\" and b2:\"\\<forall>x. b2\\<le>x \\<and> x<b \\<longrightarrow> poly p x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a2 b2.\n        \\<lbrakk>a < a2;\n         \\<forall>x.\n            a < x \\<and> x \\<le> a2 \\<longrightarrow> poly p x \\<noteq> 0;\n         b2 < b;\n         \\<forall>x.\n            b2 \\<le> x \\<and> x < b \\<longrightarrow>\n            poly p x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using next_non_root_interval[OF \\<open>p\\<noteq>0\\<close>] last_non_root_interval[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  (\\<And>ub.\n      \\<lbrakk>?lb < ub;\n       \\<forall>z.\n          ?lb < z \\<and> z \\<le> ub \\<longrightarrow>\n          poly p z \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  (\\<And>lb.\n      \\<lbrakk>lb < ?ub;\n       \\<forall>z.\n          lb \\<le> z \\<and> z < ?ub \\<longrightarrow>\n          poly p z \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>a2 b2.\n        \\<lbrakk>a < a2;\n         \\<forall>x.\n            a < x \\<and> x \\<le> a2 \\<longrightarrow> poly p x \\<noteq> 0;\n         b2 < b;\n         \\<forall>x.\n            b2 \\<le> x \\<and> x < b \\<longrightarrow>\n            poly p x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis less_numeral_extra(3))"], ["proof (state)\nthis:\n  a < a2\n  \\<forall>x. a < x \\<and> x \\<le> a2 \\<longrightarrow> poly p x \\<noteq> 0\n  b2 < b\n  \\<forall>x. b2 \\<le> x \\<and> x < b \\<longrightarrow> poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "define a' b' where \"a'\\<equiv> if b2>a then Min{a1, b2, a2} else min a1 a2\" \n        and \"b'\\<equiv>if a2 <b then Max{ b1, a2, b2} else max b1 b2\""], ["proof (state)\nthis:\n  a' \\<equiv> if a < b2 then Min {a1, b2, a2} else min a1 a2\n  b' \\<equiv> if a2 < b then Max {b1, a2, b2} else max b1 b2\n\ngoal (1 subgoal):\n 1. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"a < a'\" \"a' < b'\" \"b' < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < a' &&& a' < b' &&& b' < b", "unfolding a'_def b'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < (if a < b2 then Min {a1, b2, a2} else min a1 a2) &&&\n    (if a < b2 then Min {a1, b2, a2} else min a1 a2)\n    < (if a2 < b then Max {b1, a2, b2} else max b1 b2) &&&\n    (if a2 < b then Max {b1, a2, b2} else max b1 b2) < b", "using  \\<open>a < a1\\<close> \\<open>a1 < b1\\<close> \\<open>b1 < b\\<close> \\<open>a<a2\\<close> \\<open>b2<b\\<close> \\<open>a<b\\<close>"], ["proof (prove)\nusing this:\n  a < a1\n  a1 < b1\n  b1 < b\n  a < a2\n  b2 < b\n  a < b\n\ngoal (1 subgoal):\n 1. a < (if a < b2 then Min {a1, b2, a2} else min a1 a2) &&&\n    (if a < b2 then Min {a1, b2, a2} else min a1 a2)\n    < (if a2 < b then Max {b1, a2, b2} else max b1 b2) &&&\n    (if a2 < b then Max {b1, a2, b2} else max b1 b2) < b", "by auto"], ["proof (state)\nthis:\n  a < a'\n  a' < b'\n  b' < b\n\ngoal (1 subgoal):\n 1. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  a < a'\n  a' < b'\n  b' < b\n\ngoal (1 subgoal):\n 1. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<forall>p\\<in>set xs. \\<forall>x. a < x \\<and> x \\<le> a' \\<or> b' \\<le> x \\<and> x < b \\<longrightarrow> poly p x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set xs.\n       \\<forall>x.\n          a < x \\<and> x \\<le> a' \\<or>\n          b' \\<le> x \\<and> x < b \\<longrightarrow>\n          poly p x \\<noteq> 0", "using a1_b1_no_root"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set xs.\n     \\<forall>x.\n        a < x \\<and> x \\<le> a1 \\<or>\n        b1 \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set xs.\n       \\<forall>x.\n          a < x \\<and> x \\<le> a' \\<or>\n          b' \\<le> x \\<and> x < b \\<longrightarrow>\n          poly p x \\<noteq> 0", "unfolding a'_def b'_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set xs.\n     \\<forall>x.\n        a < x \\<and> x \\<le> a1 \\<or>\n        b1 \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set xs.\n       \\<forall>x.\n          a < x \\<and>\n          x \\<le> (if a < b2 then Min {a1, b2, a2} else min a1 a2) \\<or>\n          (if a2 < b then Max {b1, a2, b2} else max b1 b2) \\<le> x \\<and>\n          x < b \\<longrightarrow>\n          poly p x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set xs.\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        b' \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set xs.\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        b' \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<forall>x. a < x \\<and> x \\<le> a' \\<or> b' \\<le> x \\<and> x < b \\<longrightarrow> poly p x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       a < x \\<and> x \\<le> a' \\<or>\n       b' \\<le> x \\<and> x < b \\<longrightarrow>\n       poly p x \\<noteq> 0", "using a2 b2"], ["proof (prove)\nusing this:\n  \\<forall>x. a < x \\<and> x \\<le> a2 \\<longrightarrow> poly p x \\<noteq> 0\n  b2 < b\n  \\<forall>x. b2 \\<le> x \\<and> x < b \\<longrightarrow> poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       a < x \\<and> x \\<le> a' \\<or>\n       b' \\<le> x \\<and> x < b \\<longrightarrow>\n       poly p x \\<noteq> 0", "unfolding a'_def b'_def"], ["proof (prove)\nusing this:\n  \\<forall>x. a < x \\<and> x \\<le> a2 \\<longrightarrow> poly p x \\<noteq> 0\n  b2 < b\n  \\<forall>x. b2 \\<le> x \\<and> x < b \\<longrightarrow> poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       a < x \\<and>\n       x \\<le> (if a < b2 then Min {a1, b2, a2} else min a1 a2) \\<or>\n       (if a2 < b then Max {b1, a2, b2} else max b1 b2) \\<le> x \\<and>\n       x < b \\<longrightarrow>\n       poly p x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     a < x \\<and> x \\<le> a' \\<or> b' \\<le> x \\<and> x < b \\<longrightarrow>\n     poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a x p q thesis.\n       \\<lbrakk>\\<And>p q thesis.\n                   \\<lbrakk>x = smods p q;\n                    \\<And>a' b'.\n                       \\<lbrakk>a < a'; a' < b'; b' < b;\n                        \\<forall>p\\<in>set (smods p q).\n                           \\<forall>x.\n                              a < x \\<and> x \\<le> a' \\<or>\n                              b' \\<le> x \\<and> x < b \\<longrightarrow>\n                              poly p x \\<noteq> 0\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a # x = smods p q;\n        \\<And>a' b'.\n           \\<lbrakk>a < a'; a' < b'; b' < b;\n            \\<forall>p\\<in>set (smods p q).\n               \\<forall>x.\n                  a < x \\<and> x \\<le> a' \\<or>\n                  b' \\<le> x \\<and> x < b \\<longrightarrow>\n                  poly p x \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  a < a'\n  a' < b'\n  b' < b\n  \\<forall>p\\<in>set xs.\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        b' \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0\n  \\<forall>x.\n     a < x \\<and> x \\<le> a' \\<or> b' \\<le> x \\<and> x < b \\<longrightarrow>\n     poly p x \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  a < a'\n  a' < b'\n  b' < b\n  \\<forall>p\\<in>set xs.\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        b' \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0\n  \\<forall>x.\n     a < x \\<and> x \\<le> a' \\<or> b' \\<le> x \\<and> x < b \\<longrightarrow>\n     poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. thesis", "using Cons(3)[unfolded \\<open>smods p q=p#xs\\<close>]"], ["proof (prove)\nusing this:\n  a < a'\n  a' < b'\n  b' < b\n  \\<forall>p\\<in>set xs.\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        b' \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0\n  \\<forall>x.\n     a < x \\<and> x \\<le> a' \\<or> b' \\<le> x \\<and> x < b \\<longrightarrow>\n     poly p x \\<noteq> 0\n  \\<lbrakk>a < ?a'; ?a' < ?b'; ?b' < b;\n   \\<forall>p\\<in>set (p # xs).\n      \\<forall>x.\n         a < x \\<and> x \\<le> ?a' \\<or>\n         ?b' \\<le> x \\<and> x < b \\<longrightarrow>\n         poly p x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a < a'\n  a' < b'\n  b' < b\n  \\<forall>p\\<in>set (smods p q).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        b' \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a x p q aa b.\n       \\<lbrakk>\\<And>p q a b.\n                   \\<lbrakk>x = smods p q; a < b; poly p a \\<noteq> 0;\n                    poly p b \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> cindex_poly a b q p =\n                                     changes_itv_smods a b p q;\n        a # x = smods p q; aa < b; poly p aa \\<noteq> 0;\n        poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly aa b q p = changes_itv_smods aa b p q", "have \"q=0 \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = 0 \\<Longrightarrow> cindex_poly a b q p = changes_itv_smods a b p q", "by simp"], ["proof (state)\nthis:\n  q = 0 \\<Longrightarrow> cindex_poly a b q p = changes_itv_smods a b p q\n\ngoal (1 subgoal):\n 1. \\<And>a x p q aa b.\n       \\<lbrakk>\\<And>p q a b.\n                   \\<lbrakk>x = smods p q; a < b; poly p a \\<noteq> 0;\n                    poly p b \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> cindex_poly a b q p =\n                                     changes_itv_smods a b p q;\n        a # x = smods p q; aa < b; poly p aa \\<noteq> 0;\n        poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly aa b q p = changes_itv_smods aa b p q", "moreover"], ["proof (state)\nthis:\n  q = 0 \\<Longrightarrow> cindex_poly a b q p = changes_itv_smods a b p q\n\ngoal (1 subgoal):\n 1. \\<And>a x p q aa b.\n       \\<lbrakk>\\<And>p q a b.\n                   \\<lbrakk>x = smods p q; a < b; poly p a \\<noteq> 0;\n                    poly p b \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> cindex_poly a b q p =\n                                     changes_itv_smods a b p q;\n        a # x = smods p q; aa < b; poly p aa \\<noteq> 0;\n        poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly aa b q p = changes_itv_smods aa b p q", "have \"q\\<noteq>0 \\<Longrightarrow> ?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = changes_itv_smods a b p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = changes_itv_smods a b p q", "assume \"q\\<noteq>0\""], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = changes_itv_smods a b p q", "define r where \"r\\<equiv>- (p mod q)\""], ["proof (state)\nthis:\n  r \\<equiv> - (p mod q)\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = changes_itv_smods a b p q", "obtain ps where ps:\"smods p q=p#q#ps\" \"smods q r=q#ps\" and \"xs=q#ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>smods p q = p # q # ps; smods q r = q # ps;\n         xs = q # ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>smods p q = p # q # ps; smods q (- (p mod q)) = q # ps;\n         xs = q # ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>q\\<noteq>0\\<close> \\<open>p\\<noteq>0\\<close> \\<open>x1 # xs = smods p q\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  p \\<noteq> 0\n  x1 # xs = smods p q\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>smods p q = p # q # ps; smods q (- (p mod q)) = q # ps;\n         xs = q # ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis list.inject smods.simps)"], ["proof (state)\nthis:\n  smods p q = p # q # ps\n  smods q r = q # ps\n  xs = q # ps\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = changes_itv_smods a b p q", "have \"poly p a' \\<noteq> 0\" \"poly p b' \\<noteq> 0\" \"poly q a' \\<noteq> 0\" \"poly q b' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p a' \\<noteq> 0 &&& poly p b' \\<noteq> 0) &&&\n    poly q a' \\<noteq> 0 &&& poly q b' \\<noteq> 0", "using no_root[unfolded ps] \\<open>a'>a\\<close> \\<open>b'<b\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (p # q # ps).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        b' \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0\n  a < a'\n  b' < b\n\ngoal (1 subgoal):\n 1. (poly p a' \\<noteq> 0 &&& poly p b' \\<noteq> 0) &&&\n    poly q a' \\<noteq> 0 &&& poly q b' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p a' \\<noteq> 0\n  poly p b' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  poly q b' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = changes_itv_smods a b p q", "moreover"], ["proof (state)\nthis:\n  poly p a' \\<noteq> 0\n  poly p b' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  poly q b' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = changes_itv_smods a b p q", "hence \n          \"changes_itv_smods a' b' p q = cross (p * q) a' b' + changes_itv_smods a' b' q r\"\n          \"cindex_poly a' b' q p = cross (p * q) a' b' + cindex_poly a' b' r q\""], ["proof (prove)\nusing this:\n  poly p a' \\<noteq> 0\n  poly p b' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  poly q b' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_itv_smods a' b' p q =\n    cross (p * q) a' b' + changes_itv_smods a' b' q r &&&\n    cindex_poly a' b' q p = cross (p * q) a' b' + cindex_poly a' b' r q", "using changes_itv_smods_rec[OF \\<open>a'<b'\\<close>,of p q,folded r_def] \n          cindex_poly_rec[OF \\<open>a'<b'\\<close>,of p q,folded r_def]"], ["proof (prove)\nusing this:\n  poly p a' \\<noteq> 0\n  poly p b' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  poly q b' \\<noteq> 0\n  \\<lbrakk>poly (p * q) a' \\<noteq> 0; poly (p * q) b' \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> changes_itv_smods a' b' p q =\n                    cross (p * q) a' b' + changes_itv_smods a' b' q r\n  \\<lbrakk>poly (p * q) a' \\<noteq> 0; poly (p * q) b' \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> cindex_poly a' b' q p =\n                    cross (p * q) a' b' + cindex_poly a' b' r q\n\ngoal (1 subgoal):\n 1. changes_itv_smods a' b' p q =\n    cross (p * q) a' b' + changes_itv_smods a' b' q r &&&\n    cindex_poly a' b' q p = cross (p * q) a' b' + cindex_poly a' b' r q", "by auto"], ["proof (state)\nthis:\n  changes_itv_smods a' b' p q =\n  cross (p * q) a' b' + changes_itv_smods a' b' q r\n  cindex_poly a' b' q p = cross (p * q) a' b' + cindex_poly a' b' r q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = changes_itv_smods a b p q", "moreover"], ["proof (state)\nthis:\n  changes_itv_smods a' b' p q =\n  cross (p * q) a' b' + changes_itv_smods a' b' q r\n  cindex_poly a' b' q p = cross (p * q) a' b' + cindex_poly a' b' r q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = changes_itv_smods a b p q", "have \"changes_itv_smods a' b' q r = cindex_poly a' b' r q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_itv_smods a' b' q r = cindex_poly a' b' r q", "using  Cons.hyps(1)[of q r a' b'] \\<open>a' < b'\\<close> \\<open>q \\<noteq> 0\\<close> \\<open>xs = q # ps\\<close> ps(2)\n          \\<open>poly q a' \\<noteq> 0\\<close> \\<open>poly q b' \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>xs = smods q r; a' < b'; poly q a' \\<noteq> 0;\n   poly q b' \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> cindex_poly a' b' r q = changes_itv_smods a' b' q r\n  a' < b'\n  q \\<noteq> 0\n  xs = q # ps\n  smods q r = q # ps\n  poly q a' \\<noteq> 0\n  poly q b' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_itv_smods a' b' q r = cindex_poly a' b' r q", "by simp"], ["proof (state)\nthis:\n  changes_itv_smods a' b' q r = cindex_poly a' b' r q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = changes_itv_smods a b p q", "ultimately"], ["proof (chain)\npicking this:\n  poly p a' \\<noteq> 0\n  poly p b' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  poly q b' \\<noteq> 0\n  changes_itv_smods a' b' p q =\n  cross (p * q) a' b' + changes_itv_smods a' b' q r\n  cindex_poly a' b' q p = cross (p * q) a' b' + cindex_poly a' b' r q\n  changes_itv_smods a' b' q r = cindex_poly a' b' r q", "have \"changes_itv_smods a' b' p q = cindex_poly a' b' q p\""], ["proof (prove)\nusing this:\n  poly p a' \\<noteq> 0\n  poly p b' \\<noteq> 0\n  poly q a' \\<noteq> 0\n  poly q b' \\<noteq> 0\n  changes_itv_smods a' b' p q =\n  cross (p * q) a' b' + changes_itv_smods a' b' q r\n  cindex_poly a' b' q p = cross (p * q) a' b' + cindex_poly a' b' r q\n  changes_itv_smods a' b' q r = cindex_poly a' b' r q\n\ngoal (1 subgoal):\n 1. changes_itv_smods a' b' p q = cindex_poly a' b' q p", "by auto"], ["proof (state)\nthis:\n  changes_itv_smods a' b' p q = cindex_poly a' b' q p\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow>\n    cindex_poly a b q p = changes_itv_smods a b p q", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes_itv_smods a' b' p q = cindex_poly a' b' q p\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p = changes_itv_smods a b p q", "using \n          changes_itv_smods_congr[OF \\<open>a<a'\\<close> \\<open>a'<b'\\<close> \\<open>b'<b\\<close> Cons(4,5),of q]\n          no_root cindex_poly_congr[OF \\<open>a<a'\\<close> \\<open>a'<b'\\<close> \\<open>b'<b\\<close> ] ps"], ["proof (prove)\nusing this:\n  changes_itv_smods a' b' p q = cindex_poly a' b' q p\n  \\<forall>p\\<in>set (smods p q).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        b' \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0 \\<Longrightarrow>\n  changes_itv_smods a b p q = changes_itv_smods a' b' p q\n  \\<forall>p\\<in>set (smods p q).\n     \\<forall>x.\n        a < x \\<and> x \\<le> a' \\<or>\n        b' \\<le> x \\<and> x < b \\<longrightarrow>\n        poly p x \\<noteq> 0\n  \\<forall>x.\n     a < x \\<and> x \\<le> a' \\<or> b' \\<le> x \\<and> x < b \\<longrightarrow>\n     poly ?p x \\<noteq> 0 \\<Longrightarrow>\n  cindex_poly a b ?q ?p = cindex_poly a' b' ?q ?p\n  smods p q = p # q # ps\n  smods q r = q # ps\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p = changes_itv_smods a b p q", "by (metis insert_iff list.set(2))"], ["proof (state)\nthis:\n  cindex_poly a b q p = changes_itv_smods a b p q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<noteq> 0 \\<Longrightarrow>\n  cindex_poly a b q p = changes_itv_smods a b p q\n\ngoal (1 subgoal):\n 1. \\<And>a x p q aa b.\n       \\<lbrakk>\\<And>p q a b.\n                   \\<lbrakk>x = smods p q; a < b; poly p a \\<noteq> 0;\n                    poly p b \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> cindex_poly a b q p =\n                                     changes_itv_smods a b p q;\n        a # x = smods p q; aa < b; poly p aa \\<noteq> 0;\n        poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> cindex_poly aa b q p = changes_itv_smods aa b p q", "ultimately"], ["proof (chain)\npicking this:\n  q = 0 \\<Longrightarrow> cindex_poly a b q p = changes_itv_smods a b p q\n  q \\<noteq> 0 \\<Longrightarrow>\n  cindex_poly a b q p = changes_itv_smods a b p q", "show ?case"], ["proof (prove)\nusing this:\n  q = 0 \\<Longrightarrow> cindex_poly a b q p = changes_itv_smods a b p q\n  q \\<noteq> 0 \\<Longrightarrow>\n  cindex_poly a b q p = changes_itv_smods a b p q\n\ngoal (1 subgoal):\n 1. cindex_poly a b q p = changes_itv_smods a b p q", "by metis"], ["proof (state)\nthis:\n  cindex_poly a b q p = changes_itv_smods a b p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_list_ub:\n  fixes ps:: \"(real poly) list\" and a::real\n  assumes \"0\\<notin>set ps\"\n  obtains ub where \"\\<forall>p\\<in>set ps. \\<forall>x. poly p x=0 \\<longrightarrow> x<ub\"\n    and \"\\<forall>x\\<ge>ub. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\" and \"ub>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         a < ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  0 \\<notin> set ps\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         a < ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct ps arbitrary:thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>ub.\n                   \\<lbrakk>\\<forall>p\\<in>set [].\n                               \\<forall>x.\n                                  poly p x = 0 \\<longrightarrow> x < ub;\n                    \\<forall>x\\<ge>ub.\n                       \\<forall>p\\<in>set [].\n                          sgn (poly p x) = sgn_pos_inf p;\n                    a < ub\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 \\<notin> set []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>aa ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>ub.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n                                \\<forall>x\\<ge>ub.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_pos_inf p;\n                                a < ub\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ub.\n           \\<lbrakk>\\<forall>p\\<in>set (aa # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n            \\<forall>x\\<ge>ub.\n               \\<forall>p\\<in>set (aa # ps). sgn (poly p x) = sgn_pos_inf p;\n            a < ub\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (aa # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>p\\<in>set [].\n              \\<forall>x. poly p x = 0 \\<longrightarrow> x < ?ub;\n   \\<forall>x\\<ge>?ub.\n      \\<forall>p\\<in>set []. sgn (poly p x) = sgn_pos_inf p;\n   a < ?ub\\<rbrakk>\n  \\<Longrightarrow> thesis\n  0 \\<notin> set []\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>ub.\n                   \\<lbrakk>\\<forall>p\\<in>set [].\n                               \\<forall>x.\n                                  poly p x = 0 \\<longrightarrow> x < ub;\n                    \\<forall>x\\<ge>ub.\n                       \\<forall>p\\<in>set [].\n                          sgn (poly p x) = sgn_pos_inf p;\n                    a < ub\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 \\<notin> set []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>aa ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>ub.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n                                \\<forall>x\\<ge>ub.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_pos_inf p;\n                                a < ub\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ub.\n           \\<lbrakk>\\<forall>p\\<in>set (aa # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n            \\<forall>x\\<ge>ub.\n               \\<forall>p\\<in>set (aa # ps). sgn (poly p x) = sgn_pos_inf p;\n            a < ub\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (aa # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using Nil(1)[of \"a+1\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>p\\<in>set [].\n              \\<forall>x. poly p x = 0 \\<longrightarrow> x < a + 1;\n   \\<forall>x\\<ge>a + 1.\n      \\<forall>p\\<in>set []. sgn (poly p x) = sgn_pos_inf p;\n   a < a + 1\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>aa ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>ub.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n                                \\<forall>x\\<ge>ub.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_pos_inf p;\n                                a < ub\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ub.\n           \\<lbrakk>\\<forall>p\\<in>set (aa # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n            \\<forall>x\\<ge>ub.\n               \\<forall>p\\<in>set (aa # ps). sgn (poly p x) = sgn_pos_inf p;\n            a < ub\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (aa # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>ub.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n                                \\<forall>x\\<ge>ub.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_pos_inf p;\n                                a < ub\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ub.\n           \\<lbrakk>\\<forall>p\\<in>set (aa # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n            \\<forall>x\\<ge>ub.\n               \\<forall>p\\<in>set (aa # ps). sgn (poly p x) = sgn_pos_inf p;\n            a < ub\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (aa # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons p ps)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>ub.\n              \\<lbrakk>\\<forall>p\\<in>set ps.\n                          \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n               \\<forall>x\\<ge>ub.\n                  \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n               a < ub\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   0 \\<notin> set ps\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>\\<forall>p\\<in>set (p # ps).\n              \\<forall>x. poly p x = 0 \\<longrightarrow> x < ?ub;\n   \\<forall>x\\<ge>?ub.\n      \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_pos_inf p;\n   a < ?ub\\<rbrakk>\n  \\<Longrightarrow> thesis\n  0 \\<notin> set (p # ps)\n\ngoal (1 subgoal):\n 1. \\<And>aa ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>ub.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n                                \\<forall>x\\<ge>ub.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_pos_inf p;\n                                a < ub\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ub.\n           \\<lbrakk>\\<forall>p\\<in>set (aa # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n            \\<forall>x\\<ge>ub.\n               \\<forall>p\\<in>set (aa # ps). sgn (poly p x) = sgn_pos_inf p;\n            a < ub\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (aa # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"p\\<noteq>0\" and \"0\\<notin>set ps\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>ub.\n              \\<lbrakk>\\<forall>p\\<in>set ps.\n                          \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n               \\<forall>x\\<ge>ub.\n                  \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n               a < ub\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   0 \\<notin> set ps\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>\\<forall>p\\<in>set (p # ps).\n              \\<forall>x. poly p x = 0 \\<longrightarrow> x < ?ub;\n   \\<forall>x\\<ge>?ub.\n      \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_pos_inf p;\n   a < ?ub\\<rbrakk>\n  \\<Longrightarrow> thesis\n  0 \\<notin> set (p # ps)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& 0 \\<notin> set ps", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  0 \\<notin> set ps\n\ngoal (1 subgoal):\n 1. \\<And>aa ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>ub.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n                                \\<forall>x\\<ge>ub.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_pos_inf p;\n                                a < ub\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ub.\n           \\<lbrakk>\\<forall>p\\<in>set (aa # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n            \\<forall>x\\<ge>ub.\n               \\<forall>p\\<in>set (aa # ps). sgn (poly p x) = sgn_pos_inf p;\n            a < ub\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (aa # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  0 \\<notin> set ps", "obtain ub1 where ub1:\"\\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub1\" and\n      ub1_sgn:\"\\<forall>x\\<ge>ub1. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\" and \"ub1>a\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  0 \\<notin> set ps\n\ngoal (1 subgoal):\n 1. (\\<And>ub1.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub1;\n         \\<forall>x\\<ge>ub1.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         a < ub1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.hyps"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  0 \\<notin> set ps\n  \\<lbrakk>\\<And>ub.\n              \\<lbrakk>\\<forall>p\\<in>set ps.\n                          \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n               \\<forall>x\\<ge>ub.\n                  \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n               a < ub\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   0 \\<notin> set ps\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ub1.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub1;\n         \\<forall>x\\<ge>ub1.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         a < ub1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub1\n  \\<forall>x\\<ge>ub1. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\n  a < ub1\n\ngoal (1 subgoal):\n 1. \\<And>aa ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>ub.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n                                \\<forall>x\\<ge>ub.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_pos_inf p;\n                                a < ub\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ub.\n           \\<lbrakk>\\<forall>p\\<in>set (aa # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n            \\<forall>x\\<ge>ub.\n               \\<forall>p\\<in>set (aa # ps). sgn (poly p x) = sgn_pos_inf p;\n            a < ub\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (aa # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain ub2 where ub2:\"\\<forall>x. poly p x = 0 \\<longrightarrow> x < ub2\" \n      and ub2_sgn: \"\\<forall>x\\<ge>ub2. sgn (poly p x) = sgn_pos_inf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub2.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> x < ub2;\n         \\<forall>x\\<ge>ub2. sgn (poly p x) = sgn_pos_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using root_ub[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  (\\<And>ub.\n      \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n       \\<forall>x\\<ge>ub. sgn (poly p x) = sgn_pos_inf p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ub2.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> x < ub2;\n         \\<forall>x\\<ge>ub2. sgn (poly p x) = sgn_pos_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub2\n  \\<forall>x\\<ge>ub2. sgn (poly p x) = sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. \\<And>aa ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>ub.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n                                \\<forall>x\\<ge>ub.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_pos_inf p;\n                                a < ub\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ub.\n           \\<lbrakk>\\<forall>p\\<in>set (aa # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n            \\<forall>x\\<ge>ub.\n               \\<forall>p\\<in>set (aa # ps). sgn (poly p x) = sgn_pos_inf p;\n            a < ub\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (aa # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "define ub where \"ub\\<equiv>max ub1 ub2\""], ["proof (state)\nthis:\n  ub \\<equiv> max ub1 ub2\n\ngoal (1 subgoal):\n 1. \\<And>aa ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>ub.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n                                \\<forall>x\\<ge>ub.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_pos_inf p;\n                                a < ub\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ub.\n           \\<lbrakk>\\<forall>p\\<in>set (aa # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n            \\<forall>x\\<ge>ub.\n               \\<forall>p\\<in>set (aa # ps). sgn (poly p x) = sgn_pos_inf p;\n            a < ub\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (aa # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<forall>p\\<in>set (p # ps). \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (p # ps).\n       \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub", "using ub1 ub2 ub_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub1\n  \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub2\n  ub \\<equiv> max ub1 ub2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (p # ps).\n       \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub", "by force"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (p # ps).\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n\ngoal (1 subgoal):\n 1. \\<And>aa ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>ub.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n                                \\<forall>x\\<ge>ub.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_pos_inf p;\n                                a < ub\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ub.\n           \\<lbrakk>\\<forall>p\\<in>set (aa # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n            \\<forall>x\\<ge>ub.\n               \\<forall>p\\<in>set (aa # ps). sgn (poly p x) = sgn_pos_inf p;\n            a < ub\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (aa # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (p # ps).\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n\ngoal (1 subgoal):\n 1. \\<And>aa ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>ub.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n                                \\<forall>x\\<ge>ub.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_pos_inf p;\n                                a < ub\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ub.\n           \\<lbrakk>\\<forall>p\\<in>set (aa # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n            \\<forall>x\\<ge>ub.\n               \\<forall>p\\<in>set (aa # ps). sgn (poly p x) = sgn_pos_inf p;\n            a < ub\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (aa # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<forall>x\\<ge>ub. \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_pos_inf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<ge>ub.\n       \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_pos_inf p", "using ub1_sgn ub2_sgn ub_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<ge>ub1. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\n  \\<forall>x\\<ge>ub2. sgn (poly p x) = sgn_pos_inf p\n  ub \\<equiv> max ub1 ub2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<ge>ub.\n       \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_pos_inf p", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<ge>ub.\n     \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. \\<And>aa ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>ub.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n                                \\<forall>x\\<ge>ub.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_pos_inf p;\n                                a < ub\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>ub.\n           \\<lbrakk>\\<forall>p\\<in>set (aa # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n            \\<forall>x\\<ge>ub.\n               \\<forall>p\\<in>set (aa # ps). sgn (poly p x) = sgn_pos_inf p;\n            a < ub\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (aa # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set (p # ps).\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n  \\<forall>x\\<ge>ub.\n     \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_pos_inf p", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (p # ps).\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n  \\<forall>x\\<ge>ub.\n     \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. thesis", "using Cons(2)[of ub] \\<open>ub1>a\\<close> ub_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (p # ps).\n     \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n  \\<forall>x\\<ge>ub.\n     \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_pos_inf p\n  \\<lbrakk>\\<forall>p\\<in>set (p # ps).\n              \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n   \\<forall>x\\<ge>ub.\n      \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_pos_inf p;\n   a < ub\\<rbrakk>\n  \\<Longrightarrow> thesis\n  a < ub1\n  ub \\<equiv> max ub1 ub2\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_list_lb:\n  fixes ps:: \"(real poly) list\" and b::real\n  assumes \"0\\<notin>set ps\"\n  obtains lb where \"\\<forall>p\\<in>set ps. \\<forall>x. poly p x=0 \\<longrightarrow> x>lb\"\n    and \"\\<forall>x\\<le>lb. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\" and \"lb<b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  0 \\<notin> set ps\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct ps arbitrary:thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>lb.\n                   \\<lbrakk>\\<forall>p\\<in>set [].\n                               \\<forall>x.\n                                  poly p x = 0 \\<longrightarrow> lb < x;\n                    \\<forall>x\\<le>lb.\n                       \\<forall>p\\<in>set [].\n                          sgn (poly p x) = sgn_neg_inf p;\n                    lb < b\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 \\<notin> set []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>lb.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n                                \\<forall>x\\<le>lb.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_neg_inf p;\n                                lb < b\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>lb.\n           \\<lbrakk>\\<forall>p\\<in>set (a # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n            \\<forall>x\\<le>lb.\n               \\<forall>p\\<in>set (a # ps). sgn (poly p x) = sgn_neg_inf p;\n            lb < b\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (a # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>p\\<in>set [].\n              \\<forall>x. poly p x = 0 \\<longrightarrow> ?lb < x;\n   \\<forall>x\\<le>?lb.\n      \\<forall>p\\<in>set []. sgn (poly p x) = sgn_neg_inf p;\n   ?lb < b\\<rbrakk>\n  \\<Longrightarrow> thesis\n  0 \\<notin> set []\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>lb.\n                   \\<lbrakk>\\<forall>p\\<in>set [].\n                               \\<forall>x.\n                                  poly p x = 0 \\<longrightarrow> lb < x;\n                    \\<forall>x\\<le>lb.\n                       \\<forall>p\\<in>set [].\n                          sgn (poly p x) = sgn_neg_inf p;\n                    lb < b\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        0 \\<notin> set []\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>lb.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n                                \\<forall>x\\<le>lb.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_neg_inf p;\n                                lb < b\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>lb.\n           \\<lbrakk>\\<forall>p\\<in>set (a # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n            \\<forall>x\\<le>lb.\n               \\<forall>p\\<in>set (a # ps). sgn (poly p x) = sgn_neg_inf p;\n            lb < b\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (a # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using Nil(1)[of \"b - 1\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>p\\<in>set [].\n              \\<forall>x. poly p x = 0 \\<longrightarrow> b - 1 < x;\n   \\<forall>x\\<le>b - 1.\n      \\<forall>p\\<in>set []. sgn (poly p x) = sgn_neg_inf p;\n   b - 1 < b\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>lb.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n                                \\<forall>x\\<le>lb.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_neg_inf p;\n                                lb < b\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>lb.\n           \\<lbrakk>\\<forall>p\\<in>set (a # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n            \\<forall>x\\<le>lb.\n               \\<forall>p\\<in>set (a # ps). sgn (poly p x) = sgn_neg_inf p;\n            lb < b\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (a # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>lb.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n                                \\<forall>x\\<le>lb.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_neg_inf p;\n                                lb < b\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>lb.\n           \\<lbrakk>\\<forall>p\\<in>set (a # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n            \\<forall>x\\<le>lb.\n               \\<forall>p\\<in>set (a # ps). sgn (poly p x) = sgn_neg_inf p;\n            lb < b\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (a # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons p ps)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>lb.\n              \\<lbrakk>\\<forall>p\\<in>set ps.\n                          \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n               \\<forall>x\\<le>lb.\n                  \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n               lb < b\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   0 \\<notin> set ps\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>\\<forall>p\\<in>set (p # ps).\n              \\<forall>x. poly p x = 0 \\<longrightarrow> ?lb < x;\n   \\<forall>x\\<le>?lb.\n      \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_neg_inf p;\n   ?lb < b\\<rbrakk>\n  \\<Longrightarrow> thesis\n  0 \\<notin> set (p # ps)\n\ngoal (1 subgoal):\n 1. \\<And>a ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>lb.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n                                \\<forall>x\\<le>lb.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_neg_inf p;\n                                lb < b\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>lb.\n           \\<lbrakk>\\<forall>p\\<in>set (a # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n            \\<forall>x\\<le>lb.\n               \\<forall>p\\<in>set (a # ps). sgn (poly p x) = sgn_neg_inf p;\n            lb < b\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (a # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"p\\<noteq>0\" and \"0\\<notin>set ps\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>lb.\n              \\<lbrakk>\\<forall>p\\<in>set ps.\n                          \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n               \\<forall>x\\<le>lb.\n                  \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n               lb < b\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   0 \\<notin> set ps\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>\\<forall>p\\<in>set (p # ps).\n              \\<forall>x. poly p x = 0 \\<longrightarrow> ?lb < x;\n   \\<forall>x\\<le>?lb.\n      \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_neg_inf p;\n   ?lb < b\\<rbrakk>\n  \\<Longrightarrow> thesis\n  0 \\<notin> set (p # ps)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& 0 \\<notin> set ps", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  0 \\<notin> set ps\n\ngoal (1 subgoal):\n 1. \\<And>a ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>lb.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n                                \\<forall>x\\<le>lb.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_neg_inf p;\n                                lb < b\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>lb.\n           \\<lbrakk>\\<forall>p\\<in>set (a # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n            \\<forall>x\\<le>lb.\n               \\<forall>p\\<in>set (a # ps). sgn (poly p x) = sgn_neg_inf p;\n            lb < b\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (a # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  0 \\<notin> set ps", "obtain lb1 where lb1:\"\\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x > lb1\" and\n      lb1_sgn:\"\\<forall>x\\<le>lb1. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\" and \"lb1<b\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  0 \\<notin> set ps\n\ngoal (1 subgoal):\n 1. (\\<And>lb1.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb1 < x;\n         \\<forall>x\\<le>lb1.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb1 < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.hyps"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  0 \\<notin> set ps\n  \\<lbrakk>\\<And>lb.\n              \\<lbrakk>\\<forall>p\\<in>set ps.\n                          \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n               \\<forall>x\\<le>lb.\n                  \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n               lb < b\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   0 \\<notin> set ps\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>lb1.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb1 < x;\n         \\<forall>x\\<le>lb1.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb1 < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> lb1 < x\n  \\<forall>x\\<le>lb1. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\n  lb1 < b\n\ngoal (1 subgoal):\n 1. \\<And>a ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>lb.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n                                \\<forall>x\\<le>lb.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_neg_inf p;\n                                lb < b\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>lb.\n           \\<lbrakk>\\<forall>p\\<in>set (a # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n            \\<forall>x\\<le>lb.\n               \\<forall>p\\<in>set (a # ps). sgn (poly p x) = sgn_neg_inf p;\n            lb < b\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (a # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain lb2 where lb2:\"\\<forall>x. poly p x = 0 \\<longrightarrow> x > lb2\" \n      and lb2_sgn: \"\\<forall>x\\<le>lb2. sgn (poly p x) = sgn_neg_inf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb2.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> lb2 < x;\n         \\<forall>x\\<le>lb2. sgn (poly p x) = sgn_neg_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using root_lb[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  (\\<And>lb.\n      \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n       \\<forall>x\\<le>lb. sgn (poly p x) = sgn_neg_inf p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>lb2.\n        \\<lbrakk>\\<forall>x. poly p x = 0 \\<longrightarrow> lb2 < x;\n         \\<forall>x\\<le>lb2. sgn (poly p x) = sgn_neg_inf p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. poly p x = 0 \\<longrightarrow> lb2 < x\n  \\<forall>x\\<le>lb2. sgn (poly p x) = sgn_neg_inf p\n\ngoal (1 subgoal):\n 1. \\<And>a ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>lb.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n                                \\<forall>x\\<le>lb.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_neg_inf p;\n                                lb < b\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>lb.\n           \\<lbrakk>\\<forall>p\\<in>set (a # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n            \\<forall>x\\<le>lb.\n               \\<forall>p\\<in>set (a # ps). sgn (poly p x) = sgn_neg_inf p;\n            lb < b\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (a # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "define lb where \"lb\\<equiv>min lb1 lb2\""], ["proof (state)\nthis:\n  lb \\<equiv> min lb1 lb2\n\ngoal (1 subgoal):\n 1. \\<And>a ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>lb.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n                                \\<forall>x\\<le>lb.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_neg_inf p;\n                                lb < b\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>lb.\n           \\<lbrakk>\\<forall>p\\<in>set (a # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n            \\<forall>x\\<le>lb.\n               \\<forall>p\\<in>set (a # ps). sgn (poly p x) = sgn_neg_inf p;\n            lb < b\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (a # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<forall>p\\<in>set (p # ps). \\<forall>x. poly p x = 0 \\<longrightarrow> x > lb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (p # ps).\n       \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x", "using lb1 lb2 lb_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> lb1 < x\n  \\<forall>x. poly p x = 0 \\<longrightarrow> lb2 < x\n  lb \\<equiv> min lb1 lb2\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (p # ps).\n       \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x", "by force"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (p # ps).\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n\ngoal (1 subgoal):\n 1. \\<And>a ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>lb.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n                                \\<forall>x\\<le>lb.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_neg_inf p;\n                                lb < b\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>lb.\n           \\<lbrakk>\\<forall>p\\<in>set (a # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n            \\<forall>x\\<le>lb.\n               \\<forall>p\\<in>set (a # ps). sgn (poly p x) = sgn_neg_inf p;\n            lb < b\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (a # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (p # ps).\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n\ngoal (1 subgoal):\n 1. \\<And>a ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>lb.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n                                \\<forall>x\\<le>lb.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_neg_inf p;\n                                lb < b\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>lb.\n           \\<lbrakk>\\<forall>p\\<in>set (a # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n            \\<forall>x\\<le>lb.\n               \\<forall>p\\<in>set (a # ps). sgn (poly p x) = sgn_neg_inf p;\n            lb < b\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (a # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<forall>x\\<le>lb. \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_neg_inf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>lb.\n       \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_neg_inf p", "using lb1_sgn lb2_sgn lb_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>lb1. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\n  \\<forall>x\\<le>lb2. sgn (poly p x) = sgn_neg_inf p\n  lb \\<equiv> min lb1 lb2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>lb.\n       \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_neg_inf p", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<le>lb.\n     \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_neg_inf p\n\ngoal (1 subgoal):\n 1. \\<And>a ps thesis.\n       \\<lbrakk>\\<And>thesis.\n                   \\<lbrakk>\\<And>lb.\n                               \\<lbrakk>\\<forall>p\\<in>set ps.\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n                                \\<forall>x\\<le>lb.\n                                   \\<forall>p\\<in>set ps.\nsgn (poly p x) = sgn_neg_inf p;\n                                lb < b\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    0 \\<notin> set ps\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>lb.\n           \\<lbrakk>\\<forall>p\\<in>set (a # ps).\n                       \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n            \\<forall>x\\<le>lb.\n               \\<forall>p\\<in>set (a # ps). sgn (poly p x) = sgn_neg_inf p;\n            lb < b\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> set (a # ps)\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set (p # ps).\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n  \\<forall>x\\<le>lb.\n     \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_neg_inf p", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (p # ps).\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n  \\<forall>x\\<le>lb.\n     \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_neg_inf p\n\ngoal (1 subgoal):\n 1. thesis", "using Cons(2)[of lb] \\<open>lb1<b\\<close> lb_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (p # ps).\n     \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n  \\<forall>x\\<le>lb.\n     \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_neg_inf p\n  \\<lbrakk>\\<forall>p\\<in>set (p # ps).\n              \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n   \\<forall>x\\<le>lb.\n      \\<forall>p\\<in>set (p # ps). sgn (poly p x) = sgn_neg_inf p;\n   lb < b\\<rbrakk>\n  \\<Longrightarrow> thesis\n  lb1 < b\n  lb \\<equiv> min lb1 lb2\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem sturm_tarski_interval: \n  assumes \"a<b\" \"poly p a\\<noteq>0\" \"poly p b\\<noteq>0\"\n  shows \"taq {x. poly p x=0 \\<and> a<x \\<and> x<b} q = changes_itv_smods a b p (pderiv p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    changes_itv_smods a b p (pderiv p * q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    changes_itv_smods a b p (pderiv p * q)", "have \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using \\<open>poly p a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    changes_itv_smods a b p (pderiv p * q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    changes_itv_smods a b p (pderiv p * q)", "using cindex_poly_taq cindex_poly_changes_itv_mods[OF assms]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  taq {x. poly ?p x = 0 \\<and> ?a < x \\<and> x < ?b} ?q =\n  cindex_poly ?a ?b (pderiv ?p * ?q) ?p\n  cindex_poly a b ?q p = changes_itv_smods a b p ?q\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n    changes_itv_smods a b p (pderiv p * q)", "by auto"], ["proof (state)\nthis:\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < b} q =\n  changes_itv_smods a b p (pderiv p * q)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem sturm_tarski_above: \n  assumes \"poly p a\\<noteq>0\" \n  shows \"taq {x. poly p x=0 \\<and> a<x} q = changes_gt_smods a p (pderiv p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x} q =\n    changes_gt_smods a p (pderiv p * q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x} q =\n    changes_gt_smods a p (pderiv p * q)", "define ps where \"ps\\<equiv>smods p (pderiv p * q)\""], ["proof (state)\nthis:\n  ps \\<equiv> smods p (pderiv p * q)\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x} q =\n    changes_gt_smods a p (pderiv p * q)", "have \"p\\<noteq>0\" and \"p\\<in>set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& p \\<in> set ps", "using \\<open>poly p a\\<noteq>0\\<close> ps_def"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n  ps \\<equiv> smods p (pderiv p * q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& p \\<in> set ps", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x} q =\n    changes_gt_smods a p (pderiv p * q)", "obtain ub where ub:\"\\<forall>p\\<in>set ps. \\<forall>x. poly p x=0 \\<longrightarrow> x<ub\"\n      and ub_sgn:\"\\<forall>x\\<ge>ub. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\"\n      and \"ub>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         a < ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using root_list_ub[OF no_0_in_smods,of p \"pderiv p * q\",folded ps_def]"], ["proof (prove)\nusing this:\n  (\\<And>ub.\n      \\<lbrakk>\\<forall>p\\<in>set ps.\n                  \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n       \\<forall>x\\<ge>ub.\n          \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n       ?a < ub\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         a < ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n  \\<forall>x\\<ge>ub. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\n  a < ub\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x} q =\n    changes_gt_smods a p (pderiv p * q)", "have \"taq {x. poly p x=0 \\<and> a<x} q = taq {x. poly p x=0 \\<and> a<x \\<and> x<ub} q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x} q =\n    taq {x. poly p x = 0 \\<and> a < x \\<and> x < ub} q", "unfolding taq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x. sign (poly q x)) =\n    (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < ub. sign (poly q x))", "by (rule sum.cong,insert ub \\<open>p\\<in>set ps\\<close>,auto)"], ["proof (state)\nthis:\n  taq {x. poly p x = 0 \\<and> a < x} q =\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < ub} q\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x} q =\n    changes_gt_smods a p (pderiv p * q)", "moreover"], ["proof (state)\nthis:\n  taq {x. poly p x = 0 \\<and> a < x} q =\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < ub} q\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x} q =\n    changes_gt_smods a p (pderiv p * q)", "have \"changes_gt_smods a p (pderiv p * q) = changes_itv_smods a ub p (pderiv p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_gt_smods a p (pderiv p * q) =\n    changes_itv_smods a ub p (pderiv p * q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_gt_smods a p (pderiv p * q) =\n    changes_itv_smods a ub p (pderiv p * q)", "have \"map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps", "using ub_sgn[THEN spec,of ub,simplified]"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. sgn (poly p ub) = sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps", "by (metis (mono_tags, lifting) comp_def list.map_cong0)"], ["proof (state)\nthis:\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_gt_smods a p (pderiv p * q) =\n    changes_itv_smods a ub p (pderiv p * q)", "hence \"changes_poly_at ps ub=changes_poly_pos_inf ps\""], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_poly_at ps ub = changes_poly_pos_inf ps", "unfolding changes_poly_pos_inf_def changes_poly_at_def"], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p ub) ps) = changes (map sgn_pos_inf ps)", "by (subst changes_map_sgn_eq,metis map_map)"], ["proof (state)\nthis:\n  changes_poly_at ps ub = changes_poly_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_gt_smods a p (pderiv p * q) =\n    changes_itv_smods a ub p (pderiv p * q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at ps ub = changes_poly_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_gt_smods a p (pderiv p * q) =\n    changes_itv_smods a ub p (pderiv p * q)", "unfolding changes_gt_smods_def changes_itv_smods_def ps_def"], ["proof (prove)\nusing this:\n  changes_poly_at (smods p (pderiv p * q)) ub =\n  changes_poly_pos_inf (smods p (pderiv p * q))\n\ngoal (1 subgoal):\n 1. (let ps = smods p (pderiv p * q)\n     in changes_poly_at ps a - changes_poly_pos_inf ps) =\n    (let ps = smods p (pderiv p * q)\n     in changes_poly_at ps a - changes_poly_at ps ub)", "by metis"], ["proof (state)\nthis:\n  changes_gt_smods a p (pderiv p * q) =\n  changes_itv_smods a ub p (pderiv p * q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_gt_smods a p (pderiv p * q) =\n  changes_itv_smods a ub p (pderiv p * q)\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x} q =\n    changes_gt_smods a p (pderiv p * q)", "moreover"], ["proof (state)\nthis:\n  changes_gt_smods a p (pderiv p * q) =\n  changes_itv_smods a ub p (pderiv p * q)\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x} q =\n    changes_gt_smods a p (pderiv p * q)", "have \"poly p ub\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p ub \\<noteq> 0", "using ub \\<open>p\\<in>set ps\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. poly p ub \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p ub \\<noteq> 0\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x} q =\n    changes_gt_smods a p (pderiv p * q)", "ultimately"], ["proof (chain)\npicking this:\n  taq {x. poly p x = 0 \\<and> a < x} q =\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < ub} q\n  changes_gt_smods a p (pderiv p * q) =\n  changes_itv_smods a ub p (pderiv p * q)\n  poly p ub \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  taq {x. poly p x = 0 \\<and> a < x} q =\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < ub} q\n  changes_gt_smods a p (pderiv p * q) =\n  changes_itv_smods a ub p (pderiv p * q)\n  poly p ub \\<noteq> 0\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x} q =\n    changes_gt_smods a p (pderiv p * q)", "using sturm_tarski_interval[OF \\<open>ub>a\\<close> assms]"], ["proof (prove)\nusing this:\n  taq {x. poly p x = 0 \\<and> a < x} q =\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < ub} q\n  changes_gt_smods a p (pderiv p * q) =\n  changes_itv_smods a ub p (pderiv p * q)\n  poly p ub \\<noteq> 0\n  poly p ub \\<noteq> 0 \\<Longrightarrow>\n  taq {x. poly p x = 0 \\<and> a < x \\<and> x < ub} ?q =\n  changes_itv_smods a ub p (pderiv p * ?q)\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> a < x} q =\n    changes_gt_smods a p (pderiv p * q)", "by auto"], ["proof (state)\nthis:\n  taq {x. poly p x = 0 \\<and> a < x} q = changes_gt_smods a p (pderiv p * q)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem sturm_tarski_below: \n  assumes \"poly p b\\<noteq>0\" \n  shows \"taq {x. poly p x=0 \\<and> x<b} q = changes_le_smods b p (pderiv p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> x < b} q =\n    changes_le_smods b p (pderiv p * q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> x < b} q =\n    changes_le_smods b p (pderiv p * q)", "define ps where \"ps\\<equiv>smods p (pderiv p * q)\""], ["proof (state)\nthis:\n  ps \\<equiv> smods p (pderiv p * q)\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> x < b} q =\n    changes_le_smods b p (pderiv p * q)", "have \"p\\<noteq>0\" and \"p\\<in>set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& p \\<in> set ps", "using \\<open>poly p b\\<noteq>0\\<close> ps_def"], ["proof (prove)\nusing this:\n  poly p b \\<noteq> 0\n  ps \\<equiv> smods p (pderiv p * q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& p \\<in> set ps", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> x < b} q =\n    changes_le_smods b p (pderiv p * q)", "obtain lb where lb:\"\\<forall>p\\<in>set ps. \\<forall>x. poly p x=0 \\<longrightarrow> x>lb\"\n      and lb_sgn:\"\\<forall>x\\<le>lb. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\"\n      and \"lb<b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using root_list_lb[OF no_0_in_smods,of p \"pderiv p * q\",folded ps_def]"], ["proof (prove)\nusing this:\n  (\\<And>lb.\n      \\<lbrakk>\\<forall>p\\<in>set ps.\n                  \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n       \\<forall>x\\<le>lb.\n          \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n       lb < ?b\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n  \\<forall>x\\<le>lb. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\n  lb < b\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> x < b} q =\n    changes_le_smods b p (pderiv p * q)", "have \"taq {x. poly p x=0 \\<and> x<b} q = taq {x. poly p x=0 \\<and> lb<x \\<and> x<b} q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> x < b} q =\n    taq {x. poly p x = 0 \\<and> lb < x \\<and> x < b} q", "unfolding taq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> x < b. sign (poly q x)) =\n    (\\<Sum>x | poly p x = 0 \\<and> lb < x \\<and> x < b. sign (poly q x))", "by (rule sum.cong,insert lb \\<open>p\\<in>set ps\\<close>,auto)"], ["proof (state)\nthis:\n  taq {x. poly p x = 0 \\<and> x < b} q =\n  taq {x. poly p x = 0 \\<and> lb < x \\<and> x < b} q\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> x < b} q =\n    changes_le_smods b p (pderiv p * q)", "moreover"], ["proof (state)\nthis:\n  taq {x. poly p x = 0 \\<and> x < b} q =\n  taq {x. poly p x = 0 \\<and> lb < x \\<and> x < b} q\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> x < b} q =\n    changes_le_smods b p (pderiv p * q)", "have \"changes_le_smods b p (pderiv p * q) = changes_itv_smods lb b p (pderiv p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_le_smods b p (pderiv p * q) =\n    changes_itv_smods lb b p (pderiv p * q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_le_smods b p (pderiv p * q) =\n    changes_itv_smods lb b p (pderiv p * q)", "have \"map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps", "using lb_sgn[THEN spec,of lb,simplified]"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. sgn (poly p lb) = sgn_neg_inf p\n\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps", "by (metis (mono_tags, lifting) comp_def list.map_cong0)"], ["proof (state)\nthis:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes_le_smods b p (pderiv p * q) =\n    changes_itv_smods lb b p (pderiv p * q)", "hence \"changes_poly_at ps lb=changes_poly_neg_inf ps\""], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes_poly_at ps lb = changes_poly_neg_inf ps", "unfolding changes_poly_neg_inf_def changes_poly_at_def"], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p lb) ps) = changes (map sgn_neg_inf ps)", "by (subst changes_map_sgn_eq,metis map_map)"], ["proof (state)\nthis:\n  changes_poly_at ps lb = changes_poly_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes_le_smods b p (pderiv p * q) =\n    changes_itv_smods lb b p (pderiv p * q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at ps lb = changes_poly_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes_le_smods b p (pderiv p * q) =\n    changes_itv_smods lb b p (pderiv p * q)", "unfolding changes_le_smods_def changes_itv_smods_def ps_def"], ["proof (prove)\nusing this:\n  changes_poly_at (smods p (pderiv p * q)) lb =\n  changes_poly_neg_inf (smods p (pderiv p * q))\n\ngoal (1 subgoal):\n 1. (let ps = smods p (pderiv p * q)\n     in changes_poly_neg_inf ps - changes_poly_at ps b) =\n    (let ps = smods p (pderiv p * q)\n     in changes_poly_at ps lb - changes_poly_at ps b)", "by metis"], ["proof (state)\nthis:\n  changes_le_smods b p (pderiv p * q) =\n  changes_itv_smods lb b p (pderiv p * q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_le_smods b p (pderiv p * q) =\n  changes_itv_smods lb b p (pderiv p * q)\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> x < b} q =\n    changes_le_smods b p (pderiv p * q)", "moreover"], ["proof (state)\nthis:\n  changes_le_smods b p (pderiv p * q) =\n  changes_itv_smods lb b p (pderiv p * q)\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> x < b} q =\n    changes_le_smods b p (pderiv p * q)", "have \"poly p lb\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p lb \\<noteq> 0", "using lb \\<open>p\\<in>set ps\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. poly p lb \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p lb \\<noteq> 0\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> x < b} q =\n    changes_le_smods b p (pderiv p * q)", "ultimately"], ["proof (chain)\npicking this:\n  taq {x. poly p x = 0 \\<and> x < b} q =\n  taq {x. poly p x = 0 \\<and> lb < x \\<and> x < b} q\n  changes_le_smods b p (pderiv p * q) =\n  changes_itv_smods lb b p (pderiv p * q)\n  poly p lb \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  taq {x. poly p x = 0 \\<and> x < b} q =\n  taq {x. poly p x = 0 \\<and> lb < x \\<and> x < b} q\n  changes_le_smods b p (pderiv p * q) =\n  changes_itv_smods lb b p (pderiv p * q)\n  poly p lb \\<noteq> 0\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> x < b} q =\n    changes_le_smods b p (pderiv p * q)", "using sturm_tarski_interval[OF \\<open>lb<b\\<close> _ assms]"], ["proof (prove)\nusing this:\n  taq {x. poly p x = 0 \\<and> x < b} q =\n  taq {x. poly p x = 0 \\<and> lb < x \\<and> x < b} q\n  changes_le_smods b p (pderiv p * q) =\n  changes_itv_smods lb b p (pderiv p * q)\n  poly p lb \\<noteq> 0\n  poly p lb \\<noteq> 0 \\<Longrightarrow>\n  taq {x. poly p x = 0 \\<and> lb < x \\<and> x < b} ?q =\n  changes_itv_smods lb b p (pderiv p * ?q)\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0 \\<and> x < b} q =\n    changes_le_smods b p (pderiv p * q)", "by auto"], ["proof (state)\nthis:\n  taq {x. poly p x = 0 \\<and> x < b} q = changes_le_smods b p (pderiv p * q)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem sturm_tarski_R: \n  shows \"taq {x. poly p x=0} q = changes_R_smods p (pderiv p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "unfolding taq_def"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0. sign (poly q x)) =\n    changes_R_smods p (pderiv p * q)", "using infinite_UNIV_char_0"], ["proof (prove)\nusing this:\n  p = 0\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0. sign (poly q x)) =\n    changes_R_smods p (pderiv p * q)", "by (auto intro!:sum.infinite)"], ["proof (state)\nthis:\n  taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "define ps where \"ps\\<equiv>smods p (pderiv p * q)\""], ["proof (state)\nthis:\n  ps \\<equiv> smods p (pderiv p * q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "have \"p\\<in>set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set ps", "using ps_def \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  ps \\<equiv> smods p (pderiv p * q)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<in> set ps", "by auto"], ["proof (state)\nthis:\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "obtain lb where lb:\"\\<forall>p\\<in>set ps. \\<forall>x. poly p x=0 \\<longrightarrow> x>lb\"\n      and lb_sgn:\"\\<forall>x\\<le>lb. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\"\n      and \"lb<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using root_list_lb[OF no_0_in_smods,of p \"pderiv p * q\",folded ps_def]"], ["proof (prove)\nusing this:\n  (\\<And>lb.\n      \\<lbrakk>\\<forall>p\\<in>set ps.\n                  \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n       \\<forall>x\\<le>lb.\n          \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n       lb < ?b\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n  \\<forall>x\\<le>lb. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\n  lb < 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "obtain ub where ub:\"\\<forall>p\\<in>set ps. \\<forall>x. poly p x=0 \\<longrightarrow> x<ub\"\n      and ub_sgn:\"\\<forall>x\\<ge>ub. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\"\n      and \"ub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         0 < ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using root_list_ub[OF no_0_in_smods,of p \"pderiv p * q\",folded ps_def]"], ["proof (prove)\nusing this:\n  (\\<And>ub.\n      \\<lbrakk>\\<forall>p\\<in>set ps.\n                  \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n       \\<forall>x\\<ge>ub.\n          \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n       ?a < ub\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         0 < ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n  \\<forall>x\\<ge>ub. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\n  0 < ub\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "have \"taq {x. poly p x=0} q = taq {x. poly p x=0 \\<and> lb<x \\<and> x<ub} q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0} q =\n    taq {x. poly p x = 0 \\<and> lb < x \\<and> x < ub} q", "unfolding taq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0. sign (poly q x)) =\n    (\\<Sum>x | poly p x = 0 \\<and> lb < x \\<and> x < ub. sign (poly q x))", "by (rule sum.cong,insert lb ub \\<open>p\\<in>set ps\\<close>,auto)"], ["proof (state)\nthis:\n  taq {x. poly p x = 0} q =\n  taq {x. poly p x = 0 \\<and> lb < x \\<and> x < ub} q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "moreover"], ["proof (state)\nthis:\n  taq {x. poly p x = 0} q =\n  taq {x. poly p x = 0 \\<and> lb < x \\<and> x < ub} q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "have \"changes_R_smods p (pderiv p * q) = changes_itv_smods lb ub p (pderiv p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    changes_itv_smods lb ub p (pderiv p * q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    changes_itv_smods lb ub p (pderiv p * q)", "have \"map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\"\n        and \"map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps &&&\n    map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps", "using lb_sgn[THEN spec,of lb,simplified] ub_sgn[THEN spec,of ub,simplified]"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. sgn (poly p lb) = sgn_neg_inf p\n  \\<forall>p\\<in>set ps. sgn (poly p ub) = sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps &&&\n    map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps", "by (metis (mono_tags, lifting) comp_def list.map_cong0)+"], ["proof (state)\nthis:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    changes_itv_smods lb ub p (pderiv p * q)", "hence \"changes_poly_at ps lb=changes_poly_neg_inf ps\n          \\<and> changes_poly_at ps ub=changes_poly_pos_inf ps\""], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_poly_at ps lb = changes_poly_neg_inf ps \\<and>\n    changes_poly_at ps ub = changes_poly_pos_inf ps", "unfolding changes_poly_neg_inf_def changes_poly_at_def changes_poly_pos_inf_def"], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p lb) ps) =\n    changes (map sgn_neg_inf ps) \\<and>\n    changes (map (\\<lambda>p. poly p ub) ps) = changes (map sgn_pos_inf ps)", "by (subst (1 3)  changes_map_sgn_eq,metis map_map)"], ["proof (state)\nthis:\n  changes_poly_at ps lb = changes_poly_neg_inf ps \\<and>\n  changes_poly_at ps ub = changes_poly_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    changes_itv_smods lb ub p (pderiv p * q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at ps lb = changes_poly_neg_inf ps \\<and>\n  changes_poly_at ps ub = changes_poly_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_R_smods p (pderiv p * q) =\n    changes_itv_smods lb ub p (pderiv p * q)", "unfolding changes_R_smods_def changes_itv_smods_def ps_def"], ["proof (prove)\nusing this:\n  changes_poly_at (smods p (pderiv p * q)) lb =\n  changes_poly_neg_inf (smods p (pderiv p * q)) \\<and>\n  changes_poly_at (smods p (pderiv p * q)) ub =\n  changes_poly_pos_inf (smods p (pderiv p * q))\n\ngoal (1 subgoal):\n 1. (let ps = smods p (pderiv p * q)\n     in changes_poly_neg_inf ps - changes_poly_pos_inf ps) =\n    (let ps = smods p (pderiv p * q)\n     in changes_poly_at ps lb - changes_poly_at ps ub)", "by metis"], ["proof (state)\nthis:\n  changes_R_smods p (pderiv p * q) =\n  changes_itv_smods lb ub p (pderiv p * q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_R_smods p (pderiv p * q) =\n  changes_itv_smods lb ub p (pderiv p * q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "moreover"], ["proof (state)\nthis:\n  changes_R_smods p (pderiv p * q) =\n  changes_itv_smods lb ub p (pderiv p * q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "have \"poly p lb\\<noteq>0\" and \"poly p ub\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p lb \\<noteq> 0 &&& poly p ub \\<noteq> 0", "using lb ub \\<open>p\\<in>set ps\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. poly p lb \\<noteq> 0 &&& poly p ub \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p lb \\<noteq> 0\n  poly p ub \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "moreover"], ["proof (state)\nthis:\n  poly p lb \\<noteq> 0\n  poly p ub \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "have \"lb<ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lb < ub", "using \\<open>lb<0\\<close> \\<open>0<ub\\<close>"], ["proof (prove)\nusing this:\n  lb < 0\n  0 < ub\n\ngoal (1 subgoal):\n 1. lb < ub", "by auto"], ["proof (state)\nthis:\n  lb < ub\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "ultimately"], ["proof (chain)\npicking this:\n  taq {x. poly p x = 0} q =\n  taq {x. poly p x = 0 \\<and> lb < x \\<and> x < ub} q\n  changes_R_smods p (pderiv p * q) =\n  changes_itv_smods lb ub p (pderiv p * q)\n  poly p lb \\<noteq> 0\n  poly p ub \\<noteq> 0\n  lb < ub", "show ?thesis"], ["proof (prove)\nusing this:\n  taq {x. poly p x = 0} q =\n  taq {x. poly p x = 0 \\<and> lb < x \\<and> x < ub} q\n  changes_R_smods p (pderiv p * q) =\n  changes_itv_smods lb ub p (pderiv p * q)\n  poly p lb \\<noteq> 0\n  poly p ub \\<noteq> 0\n  lb < ub\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "using sturm_tarski_interval"], ["proof (prove)\nusing this:\n  taq {x. poly p x = 0} q =\n  taq {x. poly p x = 0 \\<and> lb < x \\<and> x < ub} q\n  changes_R_smods p (pderiv p * q) =\n  changes_itv_smods lb ub p (pderiv p * q)\n  poly p lb \\<noteq> 0\n  poly p ub \\<noteq> 0\n  lb < ub\n  \\<lbrakk>?a < ?b; poly ?p ?a \\<noteq> 0; poly ?p ?b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> taq {x. poly ?p x = 0 \\<and> ?a < x \\<and> x < ?b} ?q =\n                    changes_itv_smods ?a ?b ?p (pderiv ?p * ?q)\n\ngoal (1 subgoal):\n 1. taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)", "by auto"], ["proof (state)\nthis:\n  taq {x. poly p x = 0} q = changes_R_smods p (pderiv p * q)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem sturm_interval:\n  assumes \"a < b\" \"poly p a \\<noteq> 0\" \"poly p b \\<noteq> 0\"\n  shows \"card {x. poly p x = 0 \\<and> a < x \\<and> x < b} = changes_itv_smods a b p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card {x. poly p x = 0 \\<and> a < x \\<and> x < b}) =\n    changes_itv_smods a b p (pderiv p)", "using sturm_tarski_interval[OF assms, unfolded taq_def,of 1]"], ["proof (prove)\nusing this:\n  (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. sign (poly 1 x)) =\n  changes_itv_smods a b p (pderiv p * 1)\n\ngoal (1 subgoal):\n 1. int (card {x. poly p x = 0 \\<and> a < x \\<and> x < b}) =\n    changes_itv_smods a b p (pderiv p)", "by force"], ["", "theorem sturm_above:\n  assumes \"poly p a \\<noteq> 0\" \n  shows \"card {x. poly p x = 0 \\<and> a < x} = changes_gt_smods a p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card {x. poly p x = 0 \\<and> a < x}) =\n    changes_gt_smods a p (pderiv p)", "using sturm_tarski_above[OF assms, unfolded taq_def,of 1]"], ["proof (prove)\nusing this:\n  (\\<Sum>x | poly p x = 0 \\<and> a < x. sign (poly 1 x)) =\n  changes_gt_smods a p (pderiv p * 1)\n\ngoal (1 subgoal):\n 1. int (card {x. poly p x = 0 \\<and> a < x}) =\n    changes_gt_smods a p (pderiv p)", "by force"], ["", "theorem sturm_below:\n  assumes \"poly p b \\<noteq> 0\"\n  shows \"card {x. poly p x = 0 \\<and> x < b} = changes_le_smods b p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card {x. poly p x = 0 \\<and> x < b}) =\n    changes_le_smods b p (pderiv p)", "using sturm_tarski_below[OF assms, unfolded taq_def,of 1]"], ["proof (prove)\nusing this:\n  (\\<Sum>x | poly p x = 0 \\<and> x < b. sign (poly 1 x)) =\n  changes_le_smods b p (pderiv p * 1)\n\ngoal (1 subgoal):\n 1. int (card {x. poly p x = 0 \\<and> x < b}) =\n    changes_le_smods b p (pderiv p)", "by force"], ["", "theorem sturm_R:\n  shows \"card {x. poly p x=0} =  changes_R_smods p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card {x. poly p x = 0}) = changes_R_smods p (pderiv p)", "using sturm_tarski_R[of _ 1,unfolded taq_def]"], ["proof (prove)\nusing this:\n  (\\<Sum>x | poly ?p x = 0. sign (poly 1 x)) =\n  changes_R_smods ?p (pderiv ?p * 1)\n\ngoal (1 subgoal):\n 1. int (card {x. poly p x = 0}) = changes_R_smods p (pderiv p)", "by force"], ["", "end"]]}