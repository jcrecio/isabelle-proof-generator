{"file_name": "/home/qj213/afp-2021-10-22/thys/pGCL/Expectations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/pGCL", "problem_names": ["lemma bounded_byI[intro]:\n  \"\\<lbrakk> \\<And>x. P x \\<le> b \\<rbrakk> \\<Longrightarrow> bounded_by b P\"", "lemma bounded_byI2[intro]:\n  \"P \\<le> (\\<lambda>s. b) \\<Longrightarrow> bounded_by b P\"", "lemma bounded_byD[dest]:\n  \"bounded_by b P \\<Longrightarrow> P x \\<le> b\"", "lemma bounded_byD2[dest]:\n  \"bounded_by b P \\<Longrightarrow> P \\<le> (\\<lambda>s. b)\"", "lemma bounded_bdd_above[intro]:\n  assumes bP: \"bounded P\"\n  shows \"bdd_above (range P)\"", "lemma bound_of_least[intro]:\n  assumes bP: \"bounded_by b P\"\n  shows \"bound_of P \\<le> b\"", "lemma bounded_by_bound_of[intro!]:\n  fixes P::\"'a \\<Rightarrow> real\"\n  assumes bP: \"bounded P\"\n  shows \"bounded_by (bound_of P) P\"", "lemma bound_of_greater[intro]:\n  \"bounded P \\<Longrightarrow> P x \\<le> bound_of P\"", "lemma bounded_by_mono:\n  \"\\<lbrakk> bounded_by a P; a \\<le> b \\<rbrakk> \\<Longrightarrow> bounded_by b P\"", "lemma bounded_by_imp_bounded[intro]:\n  \"bounded_by b P \\<Longrightarrow> bounded P\"", "lemma bounded_by_bound_of_alt:\n  \"\\<lbrakk> bounded P; bound_of P = a \\<rbrakk> \\<Longrightarrow> bounded_by a P\"", "lemma bounded_const[simp]:\n  \"bounded (\\<lambda>x. c)\"", "lemma bounded_by_const[intro]:\n  \"c \\<le> b \\<Longrightarrow> bounded_by b (\\<lambda>x. c)\"", "lemma bounded_by_mono_alt[intro]:\n  \"\\<lbrakk> bounded_by b Q; P \\<le> Q \\<rbrakk> \\<Longrightarrow> bounded_by b P\"", "lemma bound_of_const[simp, intro]:\n  \"bound_of (\\<lambda>x. c) = (c::real)\"", "lemma bound_of_leI:\n  assumes \"\\<And>x. P x \\<le> (c::real)\"\n  shows \"bound_of P \\<le> c\"", "lemma bound_of_mono[intro]:\n  \"\\<lbrakk> P \\<le> Q; bounded P; bounded Q \\<rbrakk> \\<Longrightarrow> bound_of P \\<le> bound_of Q\"", "lemma bounded_by_o[intro,simp]:\n  \"\\<And>b. bounded_by b P \\<Longrightarrow> bounded_by b (P o f)\"", "lemma le_bound_of[intro]:\n  \"\\<And>x. bounded f \\<Longrightarrow> f x \\<le> bound_of f\"", "lemma nnegI[intro]:\n  \"\\<lbrakk> \\<And>x. 0 \\<le> P x \\<rbrakk> \\<Longrightarrow> nneg P\"", "lemma nnegI2[intro]:\n  \"(\\<lambda>s. 0) \\<le> P \\<Longrightarrow> nneg P\"", "lemma nnegD[dest]:\n  \"nneg P \\<Longrightarrow> 0 \\<le> P x\"", "lemma nnegD2[dest]:\n  \"nneg P \\<Longrightarrow> (\\<lambda>s. 0) \\<le> P\"", "lemma nneg_bdd_below[intro]:\n  \"nneg P \\<Longrightarrow> bdd_below (range P)\"", "lemma nneg_const[iff]:\n  \"nneg (\\<lambda>x. c) \\<longleftrightarrow> 0 \\<le> c\"", "lemma nneg_o[intro,simp]:\n  \"nneg P \\<Longrightarrow> nneg (P o f)\"", "lemma nneg_bound_nneg[intro]:\n  \"\\<lbrakk> bounded P; nneg P \\<rbrakk> \\<Longrightarrow> 0 \\<le> bound_of P\"", "lemma nneg_bounded_by_nneg[dest]:\n  \"\\<lbrakk> bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> 0 \\<le> (b::real)\"", "lemma bounded_by_nneg[dest]:\n  fixes P::\"'s \\<Rightarrow> real\"\n  shows \"\\<lbrakk> bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> 0 \\<le> b\"", "lemma soundI:\n  \"\\<lbrakk> bounded P; nneg P \\<rbrakk> \\<Longrightarrow> sound P\"", "lemma soundI2[intro]:\n  \"\\<lbrakk> bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> sound P\"", "lemma sound_bounded[dest]:\n  \"sound P \\<Longrightarrow> bounded P\"", "lemma sound_nneg[dest]:\n  \"sound P \\<Longrightarrow> nneg P\"", "lemma bound_of_sound[intro]:\n  assumes sP: \"sound P\"\n  shows \"0 \\<le> bound_of P\"", "lemma sound_sum[simp,intro]:\n  assumes sP: \"sound P\" and sQ: \"sound Q\"\n  shows \"sound (\\<lambda>s. P s + Q s)\"", "lemma mult_sound:\n  assumes sP: \"sound P\" and sQ: \"sound Q\"\n  shows \"sound (\\<lambda>s. P s * Q s)\"", "lemma div_sound:\n  assumes sP: \"sound P\" and cpos: \"0 < c\"\n  shows \"sound (\\<lambda>s. P s / c)\"", "lemma tminus_sound:\n  assumes sP: \"sound P\" and nnc: \"0 \\<le> c\"\n  shows \"sound (\\<lambda>s. P s \\<ominus> c)\"", "lemma const_sound:\n  \"0 \\<le> c \\<Longrightarrow> sound (\\<lambda>s. c)\"", "lemma sound_o[intro,simp]:\n  \"sound P \\<Longrightarrow> sound (P o f)\"", "lemma sc_bounded_by[intro,simp]:\n  \"\\<lbrakk> sound P; 0 \\<le> c \\<rbrakk> \\<Longrightarrow> bounded_by (c * bound_of P) (\\<lambda>x. c * P x)\"", "lemma sc_bounded[intro,simp]:\n  assumes sP:  \"sound P\" and pos: \"0 \\<le> c\"\n  shows \"bounded (\\<lambda>x. c * P x)\"", "lemma sc_bound[simp]:\n  assumes sP: \"sound P\"\n      and cnn: \"0 \\<le> c\"\n  shows \"c * bound_of P = bound_of (\\<lambda>x. c * P x)\"", "lemma sc_sound:\n  \"\\<lbrakk> sound P; 0 \\<le> c \\<rbrakk> \\<Longrightarrow> sound (\\<lambda>s. c * P s)\"", "lemma bounded_by_mult:\n  assumes sP: \"sound P\" and bP: \"bounded_by a P\"\n      and sQ: \"sound Q\" and bQ: \"bounded_by b Q\"\n  shows \"bounded_by (a * b) (\\<lambda>s. P s * Q s)\"", "lemma bounded_by_add:\n  fixes P::\"'s \\<Rightarrow> real\" and Q\n  assumes bP: \"bounded_by a P\"\n      and bQ: \"bounded_by b Q\"\n  shows \"bounded_by (a + b) (\\<lambda>s. P s + Q s)\"", "lemma sound_unit[intro!,simp]:\n  \"sound (\\<lambda>s. 1)\"", "lemma unit_mult[intro]:\n  assumes sP: \"sound P\" and bP: \"bounded_by 1 P\"\n      and sQ: \"sound Q\" and bQ: \"bounded_by 1 Q\"\n  shows \"bounded_by 1 (\\<lambda>s. P s * Q s)\"", "lemma sum_sound:\n  assumes sP: \"\\<forall>x\\<in>S. sound (P x)\"\n  shows \"sound (\\<lambda>s. \\<Sum>x\\<in>S. P x s)\"", "lemma unitaryI[intro]:\n  \"\\<lbrakk> sound P; bounded_by 1 P \\<rbrakk> \\<Longrightarrow> unitary P\"", "lemma unitaryI2:\n  \"\\<lbrakk> nneg P; bounded_by 1 P \\<rbrakk> \\<Longrightarrow> unitary P\"", "lemma unitary_sound[dest]:\n  \"unitary P \\<Longrightarrow> sound P\"", "lemma unitary_bound[dest]:\n  \"unitary P \\<Longrightarrow> bounded_by 1 P\"", "lemma embed_bool_nneg[simp,intro]:\n  \"nneg \\<guillemotleft>P\\<guillemotright>\"", "lemma embed_bool_bounded_by_1[simp,intro]:\n  \"bounded_by 1 \\<guillemotleft>P\\<guillemotright>\"", "lemma embed_bool_bounded[simp,intro]:\n  \"bounded \\<guillemotleft>P\\<guillemotright>\"", "lemma embed_bool_idem:\n  \"\\<guillemotleft>P\\<guillemotright> s * \\<guillemotleft>P\\<guillemotright> s = \\<guillemotleft>P\\<guillemotright> s\"", "lemma eval_embed_true[simp]:\n  \"P s \\<Longrightarrow> \\<guillemotleft>P\\<guillemotright> s = 1\"", "lemma eval_embed_false[simp]:\n  \"\\<not>P s \\<Longrightarrow> \\<guillemotleft>P\\<guillemotright> s = 0\"", "lemma embed_ge_0[simp,intro]:\n  \"0 \\<le> \\<guillemotleft>G\\<guillemotright> s\"", "lemma embed_le_1[simp,intro]:\n  \"\\<guillemotleft>G\\<guillemotright> s \\<le> 1\"", "lemma embed_le_1_alt[simp,intro]:\n  \"0 \\<le> 1 - \\<guillemotleft>G\\<guillemotright> s\"", "lemma expect_1_I:\n  \"P x \\<Longrightarrow> 1 \\<le> \\<guillemotleft>P\\<guillemotright> x\"", "lemma standard_sound[intro,simp]:\n  \"sound \\<guillemotleft>P\\<guillemotright>\"", "lemma embed_o[simp]:\n  \"\\<guillemotleft>P\\<guillemotright> o f = \\<guillemotleft>P o f\\<guillemotright>\"", "lemma negateI:\n  \"\\<not> P s \\<Longrightarrow> \\<N> P s\"", "lemma embed_split:\n  \"f s = \\<guillemotleft>P\\<guillemotright> s * f s + \\<guillemotleft>\\<N> P\\<guillemotright> s * f s\"", "lemma negate_embed:\n  \"\\<guillemotleft>\\<N> P\\<guillemotright> s = 1 - \\<guillemotleft>P\\<guillemotright> s\"", "lemma eval_nembed_true[simp]:\n  \"P s \\<Longrightarrow> \\<guillemotleft>\\<N> P\\<guillemotright> s = 0\"", "lemma eval_nembed_false[simp]:\n  \"\\<not>P s \\<Longrightarrow> \\<guillemotleft>\\<N> P\\<guillemotright> s = 1\"", "lemma negate_Not[simp]:\n  \"\\<N> Not = (\\<lambda>x. x)\"", "lemma negate_negate[simp]:\n  \"\\<N> (\\<N> P) = P\"", "lemma embed_bool_cancel:\n  \"\\<guillemotleft>G\\<guillemotright> s * \\<guillemotleft>\\<N> G\\<guillemotright> s = 0\"", "lemma entailsI[intro]:\n  \"\\<lbrakk>\\<And>s. P s \\<le> Q s\\<rbrakk> \\<Longrightarrow> P \\<tturnstile> Q\"", "lemma entailsD[dest]:\n  \"P \\<tturnstile> Q \\<Longrightarrow> P s \\<le> Q s\"", "lemma eq_entails[intro]:\n  \"P = Q \\<Longrightarrow> P \\<tturnstile> Q\"", "lemma entails_trans[trans]:\n  \"\\<lbrakk> P \\<tturnstile> Q; Q \\<tturnstile> R \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> R\"", "lemma implies_entails:\n  \"\\<lbrakk> \\<And>s. P s \\<Longrightarrow> Q s \\<rbrakk> \\<Longrightarrow> \\<guillemotleft>P\\<guillemotright> \\<tturnstile> \\<guillemotleft>Q\\<guillemotright>\"", "lemma entails_implies:\n  \"\\<And>s. \\<lbrakk> \\<guillemotleft>P\\<guillemotright> \\<tturnstile> \\<guillemotleft>Q\\<guillemotright>; P s \\<rbrakk> \\<Longrightarrow> Q s\"", "lemma pconj_lzero[intro,simp]:\n  \"b \\<le> 1 \\<Longrightarrow> 0 .& b = 0\"", "lemma pconj_rzero[intro,simp]:\n  \"b \\<le> 1 \\<Longrightarrow> b .& 0 = 0\"", "lemma pconj_lone[intro,simp]:\n  \"0 \\<le> b \\<Longrightarrow> 1 .& b = b\"", "lemma pconj_rone[intro,simp]:\n  \"0 \\<le> b \\<Longrightarrow> b .& 1 = b\"", "lemma pconj_bconj:\n  \"\\<guillemotleft>a\\<guillemotright> s .& \\<guillemotleft>b\\<guillemotright> s = \\<guillemotleft>\\<lambda>s. a s \\<and> b s\\<guillemotright> s\"", "lemma pconj_comm[ac_simps]:\n  \"a .& b = b .& a\"", "lemma pconj_assoc:\n  \"\\<lbrakk> 0 \\<le> a; a \\<le> 1; 0 \\<le> b; b \\<le> 1; 0 \\<le> c; c \\<le> 1 \\<rbrakk> \\<Longrightarrow>\n   a .& (b .& c) = (a .& b) .& c\"", "lemma pconj_mono:\n  \"\\<lbrakk> a \\<le> b; c \\<le> d \\<rbrakk> \\<Longrightarrow> a .& c \\<le> b .& d\"", "lemma pconj_nneg[intro,simp]:\n  \"0 \\<le> a .& b\"", "lemma min_pconj:\n  \"(min a b) .& (min c d) \\<le> min (a .& c) (b .& d)\"", "lemma pconj_less_one[simp]:\n  \"a + b < 1 \\<Longrightarrow> a .& b = 0\"", "lemma pconj_ge_one[simp]:\n  \"1 \\<le> a + b \\<Longrightarrow> a .& b = a + b - 1\"", "lemma pconj_idem[simp]:\n  \"\\<guillemotleft>P\\<guillemotright> s .& \\<guillemotleft>P\\<guillemotright> s = \\<guillemotleft>P\\<guillemotright> s\"", "lemma exp_conj_mono_left:\n  \"P \\<tturnstile> Q \\<Longrightarrow> P && R \\<tturnstile> Q && R\"", "lemma exp_conj_mono_right:\n  \"Q \\<tturnstile> R \\<Longrightarrow> P && Q \\<tturnstile> P && R\"", "lemma exp_conj_comm[ac_simps]:\n  \"a && b = b && a\"", "lemma exp_conj_bounded_by[intro,simp]:\n  assumes bP: \"bounded_by 1 P\"\n      and bQ: \"bounded_by 1 Q\"\n  shows \"bounded_by 1 (P && Q)\"", "lemma exp_conj_o_distrib[simp]:\n  \"(P && Q) o f = (P o f) && (Q o f)\"", "lemma exp_conj_assoc:\n  assumes \"unitary P\" and \"unitary Q\" and \"unitary R\"\n  shows \"P && (Q && R) = (P && Q) && R\"", "lemma exp_conj_top_left[simp]:\n  \"sound P \\<Longrightarrow> \\<guillemotleft>\\<lambda>_. True\\<guillemotright> && P = P\"", "lemma exp_conj_top_right[simp]:\n  \"sound P \\<Longrightarrow> P && \\<guillemotleft>\\<lambda>_. True\\<guillemotright> = P\"", "lemma exp_conj_idem[simp]:\n  \"\\<guillemotleft>P\\<guillemotright> && \\<guillemotleft>P\\<guillemotright> = \\<guillemotleft>P\\<guillemotright>\"", "lemma exp_conj_nneg[intro,simp]:\n  \"(\\<lambda>s. 0) \\<le> P && Q\"", "lemma exp_conj_sound[intro,simp]:\n  assumes s_P: \"sound P\"\n      and s_Q: \"sound Q\"\n  shows \"sound (P && Q)\"", "lemma exp_conj_rzero[simp]:\n  \"bounded_by 1 P \\<Longrightarrow> P && (\\<lambda>s. 0) = (\\<lambda>s. 0)\"", "lemma exp_conj_1_right[simp]:\n  assumes nn: \"nneg A\"\n  shows \"A && (\\<lambda>_. 1) = A\"", "lemma exp_conj_std_split:\n  \"\\<guillemotleft>\\<lambda>s. P s \\<and> Q s\\<guillemotright> = \\<guillemotleft>P\\<guillemotright> && \\<guillemotleft>Q\\<guillemotright>\"", "lemma entails_frame:\n  assumes ePR: \"P \\<tturnstile> R\"\n      and eQS: \"Q \\<tturnstile> S\"\n  shows \"P && Q \\<tturnstile> R && S\"", "lemma pentails_cases:\n  assumes PQe: \"\\<And>x. P x \\<tturnstile> Q x\"\n      and exhaust: \"\\<And>s. \\<exists>x. P (x s) s = 1\"\n      and framed: \"\\<And>x. P x && R \\<tturnstile> Q x && S\"\n      and sR: \"sound R\" and sS: \"sound S\"\n      and bQ: \"\\<And>x. bounded_by 1 (Q x)\"\n  shows \"R \\<tturnstile> S\"", "lemma unitary_bot[iff]:\n  \"unitary (\\<lambda>s. 0::real)\"", "lemma unitary_top[iff]:\n  \"unitary (\\<lambda>s. 1::real)\"", "lemma unitary_embed[iff]:\n  \"unitary \\<guillemotleft>P\\<guillemotright>\"", "lemma unitary_const[iff]:\n  \"\\<lbrakk> 0 \\<le> c; c \\<le> 1 \\<rbrakk> \\<Longrightarrow> unitary (\\<lambda>s. c)\"", "lemma unitary_mult:\n  assumes uA: \"unitary A\" and uB: \"unitary B\"\n  shows \"unitary (\\<lambda>s. A s * B s)\"", "lemma exp_conj_unitary:\n  \"\\<lbrakk> unitary P; unitary Q \\<rbrakk> \\<Longrightarrow> unitary (P && Q)\"", "lemma unitary_comp[simp]:\n  \"unitary P \\<Longrightarrow> unitary (P o f)\"", "lemmas unitary_intros =\n  unitary_bot unitary_top unitary_embed unitary_mult exp_conj_unitary\n  unitary_comp unitary_const", "lemmas sound_intros =\n  mult_sound div_sound const_sound sound_o sound_sum\n  tminus_sound sc_sound exp_conj_sound sum_sound"], "translations": [["", "lemma bounded_byI[intro]:\n  \"\\<lbrakk> \\<And>x. P x \\<le> b \\<rbrakk> \\<Longrightarrow> bounded_by b P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. P x \\<le> b) \\<Longrightarrow> bounded_by b P", "by (simp add:bounded_by_def)"], ["", "lemma bounded_byI2[intro]:\n  \"P \\<le> (\\<lambda>s. b) \\<Longrightarrow> bounded_by b P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<le> (\\<lambda>s. b) \\<Longrightarrow> bounded_by b P", "by (blast dest:le_funD)"], ["", "lemma bounded_byD[dest]:\n  \"bounded_by b P \\<Longrightarrow> P x \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by b P \\<Longrightarrow> P x \\<le> b", "by (simp add:bounded_by_def)"], ["", "lemma bounded_byD2[dest]:\n  \"bounded_by b P \\<Longrightarrow> P \\<le> (\\<lambda>s. b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by b P \\<Longrightarrow> P \\<le> (\\<lambda>s. b)", "by (blast intro:le_funI)"], ["", "text \\<open>A function is bounded if there exists at least one upper bound on it.\\<close>"], ["", "definition bounded :: \"('a \\<Rightarrow> real) \\<Rightarrow> bool\"\nwhere     \"bounded P \\<equiv> (\\<exists>b. bounded_by b P)\""], ["", "text \\<open>In the reals, if there exists any upper bound, then there must exist a least upper bound.\\<close>"], ["", "definition bound_of :: \"('a \\<Rightarrow> real) \\<Rightarrow> real\"\nwhere     \"bound_of P \\<equiv> Sup (P ` UNIV)\""], ["", "lemma bounded_bdd_above[intro]:\n  assumes bP: \"bounded P\"\n  shows \"bdd_above (range P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above (range P)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> range P \\<Longrightarrow> x \\<le> ?M", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> range P \\<Longrightarrow> x \\<le> ?M", "assume \"x \\<in> range P\""], ["proof (state)\nthis:\n  x \\<in> range P\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> range P \\<Longrightarrow> x \\<le> ?M", "with bP"], ["proof (chain)\npicking this:\n  Expectations.bounded P\n  x \\<in> range P", "show \"x \\<le> Inf {b. bounded_by b P}\""], ["proof (prove)\nusing this:\n  Expectations.bounded P\n  x \\<in> range P\n\ngoal (1 subgoal):\n 1. x \\<le> Inf {b. bounded_by b P}", "unfolding bounded_def"], ["proof (prove)\nusing this:\n  \\<exists>b. bounded_by b P\n  x \\<in> range P\n\ngoal (1 subgoal):\n 1. x \\<le> Inf {b. bounded_by b P}", "by(auto intro:cInf_greatest)"], ["proof (state)\nthis:\n  x \\<le> Inf {b. bounded_by b P}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The least upper bound has the usual properties:\\<close>"], ["", "lemma bound_of_least[intro]:\n  assumes bP: \"bounded_by b P\"\n  shows \"bound_of P \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bound_of P \\<le> b", "unfolding bound_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (range P) \\<le> b", "using bP"], ["proof (prove)\nusing this:\n  bounded_by b P\n\ngoal (1 subgoal):\n 1. Sup (range P) \\<le> b", "by(intro cSup_least, auto)"], ["", "lemma bounded_by_bound_of[intro!]:\n  fixes P::\"'a \\<Rightarrow> real\"\n  assumes bP: \"bounded P\"\n  shows \"bounded_by (bound_of P) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by (bound_of P) P", "unfolding bound_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by (Sup (range P)) P", "using bP"], ["proof (prove)\nusing this:\n  Expectations.bounded P\n\ngoal (1 subgoal):\n 1. bounded_by (Sup (range P)) P", "by(intro bounded_byI cSup_upper bounded_bdd_above, auto)"], ["", "lemma bound_of_greater[intro]:\n  \"bounded P \\<Longrightarrow> P x \\<le> bound_of P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Expectations.bounded P \\<Longrightarrow> P x \\<le> bound_of P", "by (blast intro:bounded_byD)"], ["", "lemma bounded_by_mono:\n  \"\\<lbrakk> bounded_by a P; a \\<le> b \\<rbrakk> \\<Longrightarrow> bounded_by b P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded_by a P; a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> bounded_by b P", "unfolding bounded_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x. P x \\<le> a; a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x. P x \\<le> b", "by(blast intro:order_trans)"], ["", "lemma bounded_by_imp_bounded[intro]:\n  \"bounded_by b P \\<Longrightarrow> bounded P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by b P \\<Longrightarrow> Expectations.bounded P", "unfolding bounded_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by b P \\<Longrightarrow> \\<exists>b. bounded_by b P", "by(blast)"], ["", "text \\<open>This is occasionally easier to apply:\\<close>"], ["", "lemma bounded_by_bound_of_alt:\n  \"\\<lbrakk> bounded P; bound_of P = a \\<rbrakk> \\<Longrightarrow> bounded_by a P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Expectations.bounded P; bound_of P = a\\<rbrakk>\n    \\<Longrightarrow> bounded_by a P", "by (blast)"], ["", "lemma bounded_const[simp]:\n  \"bounded (\\<lambda>x. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Expectations.bounded (\\<lambda>x. c)", "by (blast)"], ["", "lemma bounded_by_const[intro]:\n  \"c \\<le> b \\<Longrightarrow> bounded_by b (\\<lambda>x. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> b \\<Longrightarrow> bounded_by b (\\<lambda>x. c)", "by (blast)"], ["", "lemma bounded_by_mono_alt[intro]:\n  \"\\<lbrakk> bounded_by b Q; P \\<le> Q \\<rbrakk> \\<Longrightarrow> bounded_by b P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded_by b Q; P \\<le> Q\\<rbrakk>\n    \\<Longrightarrow> bounded_by b P", "by (blast intro:order_trans dest:le_funD)"], ["", "lemma bound_of_const[simp, intro]:\n  \"bound_of (\\<lambda>x. c) = (c::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bound_of (\\<lambda>x. c) = c", "unfolding bound_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP x. c) = c", "by(intro antisym cSup_least cSup_upper bounded_bdd_above bounded_const, auto)"], ["", "lemma bound_of_leI:\n  assumes \"\\<And>x. P x \\<le> (c::real)\"\n  shows \"bound_of P \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bound_of P \\<le> c", "unfolding bound_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (range P) \\<le> c", "using assms"], ["proof (prove)\nusing this:\n  P ?x \\<le> c\n\ngoal (1 subgoal):\n 1. Sup (range P) \\<le> c", "by(intro cSup_least, auto)"], ["", "lemma bound_of_mono[intro]:\n  \"\\<lbrakk> P \\<le> Q; bounded P; bounded Q \\<rbrakk> \\<Longrightarrow> bound_of P \\<le> bound_of Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<le> Q; Expectations.bounded P;\n     Expectations.bounded Q\\<rbrakk>\n    \\<Longrightarrow> bound_of P \\<le> bound_of Q", "by (blast intro:order_trans dest:le_funD)"], ["", "lemma bounded_by_o[intro,simp]:\n  \"\\<And>b. bounded_by b P \\<Longrightarrow> bounded_by b (P o f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b. bounded_by b P \\<Longrightarrow> bounded_by b (P \\<circ> f)", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       bounded_by b P \\<Longrightarrow> bounded_by b (\\<lambda>x. P (f x))", "by(blast)"], ["", "lemma le_bound_of[intro]:\n  \"\\<And>x. bounded f \\<Longrightarrow> f x \\<le> bound_of f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. Expectations.bounded f \\<Longrightarrow> f x \\<le> bound_of f", "by(blast)"], ["", "subsection \\<open>Non-Negative Functions.\\<close>"], ["", "text \\<open>The definitions for non-negative functions are analogous to those for bounded functions.\\<close>"], ["", "definition\n  nneg :: \"('a \\<Rightarrow> 'b::{zero,order}) \\<Rightarrow> bool\"\nwhere\n  \"nneg P \\<longleftrightarrow> (\\<forall>x. 0 \\<le> P x)\""], ["", "lemma nnegI[intro]:\n  \"\\<lbrakk> \\<And>x. 0 \\<le> P x \\<rbrakk> \\<Longrightarrow> nneg P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. (0::'b) \\<le> P x) \\<Longrightarrow> nneg P", "by (simp add:nneg_def)"], ["", "lemma nnegI2[intro]:\n  \"(\\<lambda>s. 0) \\<le> P \\<Longrightarrow> nneg P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. 0::'b) \\<le> P \\<Longrightarrow> nneg P", "by (blast dest:le_funD)"], ["", "lemma nnegD[dest]:\n  \"nneg P \\<Longrightarrow> 0 \\<le> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nneg P \\<Longrightarrow> (0::'b) \\<le> P x", "by (simp add:nneg_def)"], ["", "lemma nnegD2[dest]:\n  \"nneg P \\<Longrightarrow> (\\<lambda>s. 0) \\<le> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nneg P \\<Longrightarrow> (\\<lambda>s. 0::'b) \\<le> P", "by (blast intro:le_funI)"], ["", "lemma nneg_bdd_below[intro]:\n  \"nneg P \\<Longrightarrow> bdd_below (range P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nneg P \\<Longrightarrow> bdd_below (range P)", "by(auto)"], ["", "lemma nneg_const[iff]:\n  \"nneg (\\<lambda>x. c) \\<longleftrightarrow> 0 \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nneg (\\<lambda>x. c) = ((0::'b) \\<le> c)", "by (simp add:nneg_def)"], ["", "lemma nneg_o[intro,simp]:\n  \"nneg P \\<Longrightarrow> nneg (P o f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nneg P \\<Longrightarrow> nneg (P \\<circ> f)", "by (force)"], ["", "lemma nneg_bound_nneg[intro]:\n  \"\\<lbrakk> bounded P; nneg P \\<rbrakk> \\<Longrightarrow> 0 \\<le> bound_of P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Expectations.bounded P; nneg P\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> bound_of P", "by (blast intro:order_trans)"], ["", "lemma nneg_bounded_by_nneg[dest]:\n  \"\\<lbrakk> bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> 0 \\<le> (b::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded_by b P; nneg P\\<rbrakk> \\<Longrightarrow> 0 \\<le> b", "by (blast intro:order_trans)"], ["", "lemma bounded_by_nneg[dest]:\n  fixes P::\"'s \\<Rightarrow> real\"\n  shows \"\\<lbrakk> bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> 0 \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded_by b P; nneg P\\<rbrakk> \\<Longrightarrow> 0 \\<le> b", "by (blast intro:order_trans)"], ["", "subsection \\<open>Sound Expectations\\<close>"], ["", "definition sound :: \"('s \\<Rightarrow> real) \\<Rightarrow> bool\"\nwhere \"sound P \\<equiv> bounded P \\<and> nneg P\""], ["", "text \\<open>Combining @{term nneg} and @{term bounded}, we have @{term sound} expectations. We set up\nthe classical reasoner and the simplifier, such that showing soundess, or deriving a simple\nconsequence (e.g. @{term \"sound P \\<Longrightarrow> 0 \\<le> P s\"}) will usually follow by blast, force or simp.\\<close>"], ["", "lemma soundI:\n  \"\\<lbrakk> bounded P; nneg P \\<rbrakk> \\<Longrightarrow> sound P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Expectations.bounded P; nneg P\\<rbrakk>\n    \\<Longrightarrow> sound P", "by (simp add:sound_def)"], ["", "lemma soundI2[intro]:\n  \"\\<lbrakk> bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> sound P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded_by b P; nneg P\\<rbrakk> \\<Longrightarrow> sound P", "by(blast intro:soundI)"], ["", "lemma sound_bounded[dest]:\n  \"sound P \\<Longrightarrow> bounded P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound P \\<Longrightarrow> Expectations.bounded P", "by (simp add:sound_def)"], ["", "lemma sound_nneg[dest]:\n  \"sound P \\<Longrightarrow> nneg P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound P \\<Longrightarrow> nneg P", "by (simp add:sound_def)"], ["", "lemma bound_of_sound[intro]:\n  assumes sP: \"sound P\"\n  shows \"0 \\<le> bound_of P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> bound_of P", "using assms"], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. 0 \\<le> bound_of P", "by(auto)"], ["", "text \\<open>This proof demonstrates the use of the classical reasoner (specifically blast), to both\nintroduce and eliminate soundness terms.\\<close>"], ["", "lemma sound_sum[simp,intro]:\n  assumes sP: \"sound P\" and sQ: \"sound Q\"\n  shows \"sound (\\<lambda>s. P s + Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (\\<lambda>s. P s + Q s)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. bounded_by ?b (\\<lambda>s. P s + Q s)\n 2. nneg (\\<lambda>s. P s + Q s)", "from sP"], ["proof (chain)\npicking this:\n  sound P", "have \"\\<And>s. P s \\<le> bound_of P\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>s. P s \\<le> bound_of P", "by(blast)"], ["proof (state)\nthis:\n  P ?s \\<le> bound_of P\n\ngoal (2 subgoals):\n 1. bounded_by ?b (\\<lambda>s. P s + Q s)\n 2. nneg (\\<lambda>s. P s + Q s)", "moreover"], ["proof (state)\nthis:\n  P ?s \\<le> bound_of P\n\ngoal (2 subgoals):\n 1. bounded_by ?b (\\<lambda>s. P s + Q s)\n 2. nneg (\\<lambda>s. P s + Q s)", "from sQ"], ["proof (chain)\npicking this:\n  sound Q", "have \"\\<And>s. Q s \\<le> bound_of Q\""], ["proof (prove)\nusing this:\n  sound Q\n\ngoal (1 subgoal):\n 1. \\<And>s. Q s \\<le> bound_of Q", "by(blast)"], ["proof (state)\nthis:\n  Q ?s \\<le> bound_of Q\n\ngoal (2 subgoals):\n 1. bounded_by ?b (\\<lambda>s. P s + Q s)\n 2. nneg (\\<lambda>s. P s + Q s)", "ultimately"], ["proof (chain)\npicking this:\n  P ?s \\<le> bound_of P\n  Q ?s \\<le> bound_of Q", "have \"\\<And>s. P s + Q s \\<le> bound_of P + bound_of Q\""], ["proof (prove)\nusing this:\n  P ?s \\<le> bound_of P\n  Q ?s \\<le> bound_of Q\n\ngoal (1 subgoal):\n 1. \\<And>s. P s + Q s \\<le> bound_of P + bound_of Q", "by(rule add_mono)"], ["proof (state)\nthis:\n  P ?s + Q ?s \\<le> bound_of P + bound_of Q\n\ngoal (2 subgoals):\n 1. bounded_by ?b (\\<lambda>s. P s + Q s)\n 2. nneg (\\<lambda>s. P s + Q s)", "thus \"bounded_by (bound_of P + bound_of Q) (\\<lambda>s. P s + Q s)\""], ["proof (prove)\nusing this:\n  P ?s + Q ?s \\<le> bound_of P + bound_of Q\n\ngoal (1 subgoal):\n 1. bounded_by (bound_of P + bound_of Q) (\\<lambda>s. P s + Q s)", "by(blast)"], ["proof (state)\nthis:\n  bounded_by (bound_of P + bound_of Q) (\\<lambda>s. P s + Q s)\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. P s + Q s)", "from sP"], ["proof (chain)\npicking this:\n  sound P", "have \"\\<And>s. 0 \\<le> P s\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>s. 0 \\<le> P s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> P ?s\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. P s + Q s)", "moreover"], ["proof (state)\nthis:\n  0 \\<le> P ?s\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. P s + Q s)", "from sQ"], ["proof (chain)\npicking this:\n  sound Q", "have \"\\<And>s. 0 \\<le> Q s\""], ["proof (prove)\nusing this:\n  sound Q\n\ngoal (1 subgoal):\n 1. \\<And>s. 0 \\<le> Q s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> Q ?s\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. P s + Q s)", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> P ?s\n  0 \\<le> Q ?s", "have \"\\<And>s. 0 \\<le> P s + Q s\""], ["proof (prove)\nusing this:\n  0 \\<le> P ?s\n  0 \\<le> Q ?s\n\ngoal (1 subgoal):\n 1. \\<And>s. 0 \\<le> P s + Q s", "by(simp add:add_mono)"], ["proof (state)\nthis:\n  0 \\<le> P ?s + Q ?s\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. P s + Q s)", "thus \"nneg (\\<lambda>s. P s + Q s)\""], ["proof (prove)\nusing this:\n  0 \\<le> P ?s + Q ?s\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. P s + Q s)", "by(blast)"], ["proof (state)\nthis:\n  nneg (\\<lambda>s. P s + Q s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_sound:\n  assumes sP: \"sound P\" and sQ: \"sound Q\"\n  shows \"sound (\\<lambda>s. P s * Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (\\<lambda>s. P s * Q s)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. bounded_by ?b (\\<lambda>s. P s * Q s)\n 2. nneg (\\<lambda>s. P s * Q s)", "from sP"], ["proof (chain)\npicking this:\n  sound P", "have \"\\<And>s. P s \\<le> bound_of P\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>s. P s \\<le> bound_of P", "by(blast)"], ["proof (state)\nthis:\n  P ?s \\<le> bound_of P\n\ngoal (2 subgoals):\n 1. bounded_by ?b (\\<lambda>s. P s * Q s)\n 2. nneg (\\<lambda>s. P s * Q s)", "moreover"], ["proof (state)\nthis:\n  P ?s \\<le> bound_of P\n\ngoal (2 subgoals):\n 1. bounded_by ?b (\\<lambda>s. P s * Q s)\n 2. nneg (\\<lambda>s. P s * Q s)", "from sQ"], ["proof (chain)\npicking this:\n  sound Q", "have \"\\<And>s. Q s \\<le> bound_of Q\""], ["proof (prove)\nusing this:\n  sound Q\n\ngoal (1 subgoal):\n 1. \\<And>s. Q s \\<le> bound_of Q", "by(blast)"], ["proof (state)\nthis:\n  Q ?s \\<le> bound_of Q\n\ngoal (2 subgoals):\n 1. bounded_by ?b (\\<lambda>s. P s * Q s)\n 2. nneg (\\<lambda>s. P s * Q s)", "ultimately"], ["proof (chain)\npicking this:\n  P ?s \\<le> bound_of P\n  Q ?s \\<le> bound_of Q", "have \"\\<And>s. P s * Q s \\<le> bound_of P * bound_of Q\""], ["proof (prove)\nusing this:\n  P ?s \\<le> bound_of P\n  Q ?s \\<le> bound_of Q\n\ngoal (1 subgoal):\n 1. \\<And>s. P s * Q s \\<le> bound_of P * bound_of Q", "using sP and sQ"], ["proof (prove)\nusing this:\n  P ?s \\<le> bound_of P\n  Q ?s \\<le> bound_of Q\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. \\<And>s. P s * Q s \\<le> bound_of P * bound_of Q", "by(blast intro:mult_mono)"], ["proof (state)\nthis:\n  P ?s * Q ?s \\<le> bound_of P * bound_of Q\n\ngoal (2 subgoals):\n 1. bounded_by ?b (\\<lambda>s. P s * Q s)\n 2. nneg (\\<lambda>s. P s * Q s)", "thus \"bounded_by (bound_of P * bound_of Q) (\\<lambda>s. P s * Q s)\""], ["proof (prove)\nusing this:\n  P ?s * Q ?s \\<le> bound_of P * bound_of Q\n\ngoal (1 subgoal):\n 1. bounded_by (bound_of P * bound_of Q) (\\<lambda>s. P s * Q s)", "by(blast)"], ["proof (state)\nthis:\n  bounded_by (bound_of P * bound_of Q) (\\<lambda>s. P s * Q s)\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. P s * Q s)", "from sP and sQ"], ["proof (chain)\npicking this:\n  sound P\n  sound Q", "show \"nneg (\\<lambda>s. P s * Q s)\""], ["proof (prove)\nusing this:\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. P s * Q s)", "by(blast intro:mult_nonneg_nonneg)"], ["proof (state)\nthis:\n  nneg (\\<lambda>s. P s * Q s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma div_sound:\n  assumes sP: \"sound P\" and cpos: \"0 < c\"\n  shows \"sound (\\<lambda>s. P s / c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (\\<lambda>s. P s / c)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. bounded_by ?b (\\<lambda>s. P s / c)\n 2. nneg (\\<lambda>s. P s / c)", "from sP and cpos"], ["proof (chain)\npicking this:\n  sound P\n  0 < c", "have \"\\<And>s. P s / c \\<le> bound_of P / c\""], ["proof (prove)\nusing this:\n  sound P\n  0 < c\n\ngoal (1 subgoal):\n 1. \\<And>s. P s / c \\<le> bound_of P / c", "by(blast intro:divide_right_mono less_imp_le)"], ["proof (state)\nthis:\n  P ?s / c \\<le> bound_of P / c\n\ngoal (2 subgoals):\n 1. bounded_by ?b (\\<lambda>s. P s / c)\n 2. nneg (\\<lambda>s. P s / c)", "thus \"bounded_by (bound_of P / c) (\\<lambda>s. P s / c)\""], ["proof (prove)\nusing this:\n  P ?s / c \\<le> bound_of P / c\n\ngoal (1 subgoal):\n 1. bounded_by (bound_of P / c) (\\<lambda>s. P s / c)", "by(blast)"], ["proof (state)\nthis:\n  bounded_by (bound_of P / c) (\\<lambda>s. P s / c)\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. P s / c)", "from assms"], ["proof (chain)\npicking this:\n  sound P\n  0 < c", "show \"nneg (\\<lambda>s. P s / c)\""], ["proof (prove)\nusing this:\n  sound P\n  0 < c\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. P s / c)", "by(blast intro:divide_nonneg_pos)"], ["proof (state)\nthis:\n  nneg (\\<lambda>s. P s / c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tminus_sound:\n  assumes sP: \"sound P\" and nnc: \"0 \\<le> c\"\n  shows \"sound (\\<lambda>s. P s \\<ominus> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (\\<lambda>s. P s \\<ominus> c)", "proof(rule soundI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Expectations.bounded (\\<lambda>s. P s \\<ominus> c)\n 2. nneg (\\<lambda>s. P s \\<ominus> c)", "from sP"], ["proof (chain)\npicking this:\n  sound P", "have \"\\<And>s. P s \\<le> bound_of P\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>s. P s \\<le> bound_of P", "by(blast)"], ["proof (state)\nthis:\n  P ?s \\<le> bound_of P\n\ngoal (2 subgoals):\n 1. Expectations.bounded (\\<lambda>s. P s \\<ominus> c)\n 2. nneg (\\<lambda>s. P s \\<ominus> c)", "with nnc"], ["proof (chain)\npicking this:\n  0 \\<le> c\n  P ?s \\<le> bound_of P", "have \"\\<And>s. P s \\<ominus> c \\<le> bound_of P \\<ominus> c\""], ["proof (prove)\nusing this:\n  0 \\<le> c\n  P ?s \\<le> bound_of P\n\ngoal (1 subgoal):\n 1. \\<And>s. P s \\<ominus> c \\<le> bound_of P \\<ominus> c", "by(blast intro:tminus_left_mono)"], ["proof (state)\nthis:\n  P ?s \\<ominus> c \\<le> bound_of P \\<ominus> c\n\ngoal (2 subgoals):\n 1. Expectations.bounded (\\<lambda>s. P s \\<ominus> c)\n 2. nneg (\\<lambda>s. P s \\<ominus> c)", "thus \"bounded (\\<lambda>s. P s \\<ominus> c)\""], ["proof (prove)\nusing this:\n  P ?s \\<ominus> c \\<le> bound_of P \\<ominus> c\n\ngoal (1 subgoal):\n 1. Expectations.bounded (\\<lambda>s. P s \\<ominus> c)", "by(blast)"], ["proof (state)\nthis:\n  Expectations.bounded (\\<lambda>s. P s \\<ominus> c)\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. P s \\<ominus> c)", "show \"nneg (\\<lambda>s. P s \\<ominus> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. P s \\<ominus> c)", "by(blast)"], ["proof (state)\nthis:\n  nneg (\\<lambda>s. P s \\<ominus> c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma const_sound:\n  \"0 \\<le> c \\<Longrightarrow> sound (\\<lambda>s. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> c \\<Longrightarrow> sound (\\<lambda>s. c)", "by (blast)"], ["", "lemma sound_o[intro,simp]:\n  \"sound P \\<Longrightarrow> sound (P o f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound P \\<Longrightarrow> sound (P \\<circ> f)", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound P \\<Longrightarrow> sound (\\<lambda>x. P (f x))", "by(blast)"], ["", "lemma sc_bounded_by[intro,simp]:\n  \"\\<lbrakk> sound P; 0 \\<le> c \\<rbrakk> \\<Longrightarrow> bounded_by (c * bound_of P) (\\<lambda>x. c * P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sound P; 0 \\<le> c\\<rbrakk>\n    \\<Longrightarrow> bounded_by (c * bound_of P) (\\<lambda>x. c * P x)", "by(blast intro!:mult_left_mono)"], ["", "lemma sc_bounded[intro,simp]:\n  assumes sP:  \"sound P\" and pos: \"0 \\<le> c\"\n  shows \"bounded (\\<lambda>x. c * P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Expectations.bounded (\\<lambda>x. c * P x)", "using assms"], ["proof (prove)\nusing this:\n  sound P\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. Expectations.bounded (\\<lambda>x. c * P x)", "by(blast)"], ["", "lemma sc_bound[simp]:\n  assumes sP: \"sound P\"\n      and cnn: \"0 \\<le> c\"\n  shows \"c * bound_of P = bound_of (\\<lambda>x. c * P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * bound_of P = bound_of (\\<lambda>x. c * P x)", "proof(cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow> c * bound_of P = bound_of (\\<lambda>x. c * P x)\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    c * bound_of P = bound_of (\\<lambda>x. c * P x)", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow> c * bound_of P = bound_of (\\<lambda>x. c * P x)\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    c * bound_of P = bound_of (\\<lambda>x. c * P x)", "then"], ["proof (chain)\npicking this:\n  c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. c * bound_of P = bound_of (\\<lambda>x. c * P x)", "by(simp)"], ["proof (state)\nthis:\n  c * bound_of P = bound_of (\\<lambda>x. c * P x)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    c * bound_of P = bound_of (\\<lambda>x. c * P x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    c * bound_of P = bound_of (\\<lambda>x. c * P x)", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    c * bound_of P = bound_of (\\<lambda>x. c * P x)", "with cnn"], ["proof (chain)\npicking this:\n  0 \\<le> c\n  c \\<noteq> 0", "have cpos: \"0 < c\""], ["proof (prove)\nusing this:\n  0 \\<le> c\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < c", "by(auto)"], ["proof (state)\nthis:\n  0 < c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    c * bound_of P = bound_of (\\<lambda>x. c * P x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. c * bound_of P = bound_of (\\<lambda>x. c * P x)", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. c * bound_of P \\<le> bound_of (\\<lambda>x. c * P x)\n 2. bound_of (\\<lambda>x. c * P x) \\<le> c * bound_of P", "from sP and cnn"], ["proof (chain)\npicking this:\n  sound P\n  0 \\<le> c", "have \"bounded (\\<lambda>x. c * P x)\""], ["proof (prove)\nusing this:\n  sound P\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. Expectations.bounded (\\<lambda>x. c * P x)", "by(simp)"], ["proof (state)\nthis:\n  Expectations.bounded (\\<lambda>x. c * P x)\n\ngoal (2 subgoals):\n 1. c * bound_of P \\<le> bound_of (\\<lambda>x. c * P x)\n 2. bound_of (\\<lambda>x. c * P x) \\<le> c * bound_of P", "hence \"\\<And>x. c * P x \\<le> bound_of (\\<lambda>x. c * P x)\""], ["proof (prove)\nusing this:\n  Expectations.bounded (\\<lambda>x. c * P x)\n\ngoal (1 subgoal):\n 1. \\<And>x. c * P x \\<le> bound_of (\\<lambda>x. c * P x)", "by(rule le_bound_of)"], ["proof (state)\nthis:\n  c * P ?x \\<le> bound_of (\\<lambda>x. c * P x)\n\ngoal (2 subgoals):\n 1. c * bound_of P \\<le> bound_of (\\<lambda>x. c * P x)\n 2. bound_of (\\<lambda>x. c * P x) \\<le> c * bound_of P", "with cpos"], ["proof (chain)\npicking this:\n  0 < c\n  c * P ?x \\<le> bound_of (\\<lambda>x. c * P x)", "have \"\\<And>x. P x \\<le> inverse c * bound_of (\\<lambda>x. c * P x)\""], ["proof (prove)\nusing this:\n  0 < c\n  c * P ?x \\<le> bound_of (\\<lambda>x. c * P x)\n\ngoal (1 subgoal):\n 1. \\<And>x. P x \\<le> inverse c * bound_of (\\<lambda>x. c * P x)", "by(force intro:mult_div_mono_right)"], ["proof (state)\nthis:\n  P ?x \\<le> inverse c * bound_of (\\<lambda>x. c * P x)\n\ngoal (2 subgoals):\n 1. c * bound_of P \\<le> bound_of (\\<lambda>x. c * P x)\n 2. bound_of (\\<lambda>x. c * P x) \\<le> c * bound_of P", "hence \"bound_of P \\<le> inverse c * bound_of (\\<lambda>x. c * P x)\""], ["proof (prove)\nusing this:\n  P ?x \\<le> inverse c * bound_of (\\<lambda>x. c * P x)\n\ngoal (1 subgoal):\n 1. bound_of P \\<le> inverse c * bound_of (\\<lambda>x. c * P x)", "by(blast)"], ["proof (state)\nthis:\n  bound_of P \\<le> inverse c * bound_of (\\<lambda>x. c * P x)\n\ngoal (2 subgoals):\n 1. c * bound_of P \\<le> bound_of (\\<lambda>x. c * P x)\n 2. bound_of (\\<lambda>x. c * P x) \\<le> c * bound_of P", "with cpos"], ["proof (chain)\npicking this:\n  0 < c\n  bound_of P \\<le> inverse c * bound_of (\\<lambda>x. c * P x)", "show \"c * bound_of P \\<le> bound_of (\\<lambda>x. c * P x)\""], ["proof (prove)\nusing this:\n  0 < c\n  bound_of P \\<le> inverse c * bound_of (\\<lambda>x. c * P x)\n\ngoal (1 subgoal):\n 1. c * bound_of P \\<le> bound_of (\\<lambda>x. c * P x)", "by(force intro:mult_div_mono_left)"], ["proof (state)\nthis:\n  c * bound_of P \\<le> bound_of (\\<lambda>x. c * P x)\n\ngoal (1 subgoal):\n 1. bound_of (\\<lambda>x. c * P x) \\<le> c * bound_of P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bound_of (\\<lambda>x. c * P x) \\<le> c * bound_of P", "from sP and cpos"], ["proof (chain)\npicking this:\n  sound P\n  0 < c", "have \"\\<And>x. c * P x \\<le> c * bound_of P\""], ["proof (prove)\nusing this:\n  sound P\n  0 < c\n\ngoal (1 subgoal):\n 1. \\<And>x. c * P x \\<le> c * bound_of P", "by(blast intro:mult_left_mono less_imp_le)"], ["proof (state)\nthis:\n  c * P ?x \\<le> c * bound_of P\n\ngoal (1 subgoal):\n 1. bound_of (\\<lambda>x. c * P x) \\<le> c * bound_of P", "thus \"bound_of (\\<lambda>x. c * P x) \\<le> c * bound_of P\""], ["proof (prove)\nusing this:\n  c * P ?x \\<le> c * bound_of P\n\ngoal (1 subgoal):\n 1. bound_of (\\<lambda>x. c * P x) \\<le> c * bound_of P", "by(blast)"], ["proof (state)\nthis:\n  bound_of (\\<lambda>x. c * P x) \\<le> c * bound_of P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c * bound_of P = bound_of (\\<lambda>x. c * P x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sc_sound:\n  \"\\<lbrakk> sound P; 0 \\<le> c \\<rbrakk> \\<Longrightarrow> sound (\\<lambda>s. c * P s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sound P; 0 \\<le> c\\<rbrakk>\n    \\<Longrightarrow> sound (\\<lambda>s. c * P s)", "by (blast intro:mult_nonneg_nonneg)"], ["", "lemma bounded_by_mult:\n  assumes sP: \"sound P\" and bP: \"bounded_by a P\"\n      and sQ: \"sound Q\" and bQ: \"bounded_by b Q\"\n  shows \"bounded_by (a * b) (\\<lambda>s. P s * Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by (a * b) (\\<lambda>s. P s * Q s)", "using assms"], ["proof (prove)\nusing this:\n  sound P\n  bounded_by a P\n  sound Q\n  bounded_by b Q\n\ngoal (1 subgoal):\n 1. bounded_by (a * b) (\\<lambda>s. P s * Q s)", "by(intro bounded_byI, auto intro:mult_mono)"], ["", "lemma bounded_by_add:\n  fixes P::\"'s \\<Rightarrow> real\" and Q\n  assumes bP: \"bounded_by a P\"\n      and bQ: \"bounded_by b Q\"\n  shows \"bounded_by (a + b) (\\<lambda>s. P s + Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by (a + b) (\\<lambda>s. P s + Q s)", "using assms"], ["proof (prove)\nusing this:\n  bounded_by a P\n  bounded_by b Q\n\ngoal (1 subgoal):\n 1. bounded_by (a + b) (\\<lambda>s. P s + Q s)", "by(intro bounded_byI, auto intro:add_mono)"], ["", "lemma sound_unit[intro!,simp]:\n  \"sound (\\<lambda>s. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (\\<lambda>s. 1)", "by(auto)"], ["", "lemma unit_mult[intro]:\n  assumes sP: \"sound P\" and bP: \"bounded_by 1 P\"\n      and sQ: \"sound Q\" and bQ: \"bounded_by 1 Q\"\n  shows \"bounded_by 1 (\\<lambda>s. P s * Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by 1 (\\<lambda>s. P s * Q s)", "proof(rule bounded_byI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. P x * Q x \\<le> 1", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. P x * Q x \\<le> 1", "have \"P s * Q s \\<le> 1 * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s * Q s \\<le> 1 * 1", "using assms"], ["proof (prove)\nusing this:\n  sound P\n  bounded_by 1 P\n  sound Q\n  bounded_by 1 Q\n\ngoal (1 subgoal):\n 1. P s * Q s \\<le> 1 * 1", "by(blast dest:bounded_by_mult)"], ["proof (state)\nthis:\n  P s * Q s \\<le> 1 * 1\n\ngoal (1 subgoal):\n 1. \\<And>x. P x * Q x \\<le> 1", "thus \"P s * Q s \\<le> 1\""], ["proof (prove)\nusing this:\n  P s * Q s \\<le> 1 * 1\n\ngoal (1 subgoal):\n 1. P s * Q s \\<le> 1", "by(simp)"], ["proof (state)\nthis:\n  P s * Q s \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_sound:\n  assumes sP: \"\\<forall>x\\<in>S. sound (P x)\"\n  shows \"sound (\\<lambda>s. \\<Sum>x\\<in>S. P x s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (\\<lambda>s. \\<Sum>x\\<in>S. P x s)", "proof(rule soundI2)"], ["proof (state)\ngoal (2 subgoals):\n 1. bounded_by ?b (\\<lambda>s. \\<Sum>x\\<in>S. P x s)\n 2. nneg (\\<lambda>s. \\<Sum>x\\<in>S. P x s)", "from sP"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S. sound (P x)", "show \"bounded_by (\\<Sum>x\\<in>S. bound_of (P x)) (\\<lambda>s. \\<Sum>x\\<in>S. P x s)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. sound (P x)\n\ngoal (1 subgoal):\n 1. bounded_by (\\<Sum>x\\<in>S. bound_of (P x))\n     (\\<lambda>s. \\<Sum>x\\<in>S. P x s)", "by(auto intro!:sum_mono)"], ["proof (state)\nthis:\n  bounded_by (\\<Sum>x\\<in>S. bound_of (P x))\n   (\\<lambda>s. \\<Sum>x\\<in>S. P x s)\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. \\<Sum>x\\<in>S. P x s)", "from sP"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S. sound (P x)", "show \"nneg (\\<lambda>s. \\<Sum>x\\<in>S. P x s)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. sound (P x)\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. \\<Sum>x\\<in>S. P x s)", "by(auto intro!:sum_nonneg)"], ["proof (state)\nthis:\n  nneg (\\<lambda>s. \\<Sum>x\\<in>S. P x s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Unitary expectations\\<close>"], ["", "text \\<open>A unitary expectation is a sound expectation that is additionally bounded by one.  This\nis the domain on which the \\emph{liberal} (partial correctness) semantics operates.\\<close>"], ["", "definition unitary :: \"'s expect \\<Rightarrow> bool\"\nwhere \"unitary P \\<longleftrightarrow> sound P \\<and> bounded_by 1 P\""], ["", "lemma unitaryI[intro]:\n  \"\\<lbrakk> sound P; bounded_by 1 P \\<rbrakk> \\<Longrightarrow> unitary P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sound P; bounded_by 1 P\\<rbrakk> \\<Longrightarrow> unitary P", "by(simp add:unitary_def)"], ["", "lemma unitaryI2:\n  \"\\<lbrakk> nneg P; bounded_by 1 P \\<rbrakk> \\<Longrightarrow> unitary P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nneg P; bounded_by 1 P\\<rbrakk> \\<Longrightarrow> unitary P", "by(auto)"], ["", "lemma unitary_sound[dest]:\n  \"unitary P \\<Longrightarrow> sound P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary P \\<Longrightarrow> sound P", "by(simp add:unitary_def)"], ["", "lemma unitary_bound[dest]:\n  \"unitary P \\<Longrightarrow> bounded_by 1 P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary P \\<Longrightarrow> bounded_by 1 P", "by(simp add:unitary_def)"], ["", "subsection \\<open>Standard Expectations\\<close>"], ["", "text_raw \\<open>\\label{s:standard}\\<close>"], ["", "definition\n  embed_bool :: \"('s \\<Rightarrow> bool) \\<Rightarrow> 's \\<Rightarrow> real\" (\"\\<guillemotleft> _ \\<guillemotright>\" 1000)\nwhere\n  \"\\<guillemotleft>P\\<guillemotright> \\<equiv> (\\<lambda>s. if P s then 1 else 0)\""], ["", "text \\<open>Standard expectations are the embeddings of boolean predicates, mapping @{term False} to 0\nand @{term True} to 1. We write @{term \"\\<guillemotleft>P\\<guillemotright>\"} rather than @{term \"[P]\"} (the syntax employed by\n\\citet{McIver_M_04}) for boolean embedding to avoid clashing with the HOL syntax for lists.\\<close>"], ["", "lemma embed_bool_nneg[simp,intro]:\n  \"nneg \\<guillemotleft>P\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nneg \\<guillemotleft> P \\<guillemotright>", "unfolding embed_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. if P s then 1 else 0)", "by(force)"], ["", "lemma embed_bool_bounded_by_1[simp,intro]:\n  \"bounded_by 1 \\<guillemotleft>P\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by 1 \\<guillemotleft> P \\<guillemotright>", "unfolding embed_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by 1 (\\<lambda>s. if P s then 1 else 0)", "by(force)"], ["", "lemma embed_bool_bounded[simp,intro]:\n  \"bounded \\<guillemotleft>P\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Expectations.bounded \\<guillemotleft> P \\<guillemotright>", "by (blast)"], ["", "text \\<open>Standard expectations have a number of convenient properties, which mostly follow from\nboolean algebra.\\<close>"], ["", "lemma embed_bool_idem:\n  \"\\<guillemotleft>P\\<guillemotright> s * \\<guillemotleft>P\\<guillemotright> s = \\<guillemotleft>P\\<guillemotright> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> s *\n    \\<guillemotleft> P \\<guillemotright> s =\n    \\<guillemotleft> P \\<guillemotright> s", "by (simp add:embed_bool_def)"], ["", "lemma eval_embed_true[simp]:\n  \"P s \\<Longrightarrow> \\<guillemotleft>P\\<guillemotright> s = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> s = 1", "by (simp add:embed_bool_def)"], ["", "lemma eval_embed_false[simp]:\n  \"\\<not>P s \\<Longrightarrow> \\<guillemotleft>P\\<guillemotright> s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P s \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> s = 0", "by (simp add:embed_bool_def)"], ["", "lemma embed_ge_0[simp,intro]:\n  \"0 \\<le> \\<guillemotleft>G\\<guillemotright> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<guillemotleft> G \\<guillemotright> s", "by (simp add:embed_bool_def)"], ["", "lemma embed_le_1[simp,intro]:\n  \"\\<guillemotleft>G\\<guillemotright> s \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> s \\<le> 1", "by(simp add:embed_bool_def)"], ["", "lemma embed_le_1_alt[simp,intro]:\n  \"0 \\<le> 1 - \\<guillemotleft>G\\<guillemotright> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 1 - \\<guillemotleft> G \\<guillemotright> s", "by(subst add_le_cancel_right[where c=\"\\<guillemotleft>G\\<guillemotright> s\", symmetric], simp)"], ["", "lemma expect_1_I:\n  \"P x \\<Longrightarrow> 1 \\<le> \\<guillemotleft>P\\<guillemotright> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x \\<Longrightarrow> 1 \\<le> \\<guillemotleft> P \\<guillemotright> x", "by(simp)"], ["", "lemma standard_sound[intro,simp]:\n  \"sound \\<guillemotleft>P\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound \\<guillemotleft> P \\<guillemotright>", "by(blast)"], ["", "lemma embed_o[simp]:\n  \"\\<guillemotleft>P\\<guillemotright> o f = \\<guillemotleft>P o f\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> \\<circ> f =\n    \\<guillemotleft> P \\<circ> f \\<guillemotright>", "unfolding embed_bool_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if P (f x) then 1 else 0) =\n    (\\<lambda>s. if P (f s) then 1 else 0)", "by(simp)"], ["", "text \\<open>Negating a predicate has the expected effect in its\nembedding as an expectation:\\<close>"], ["", "definition negate :: \"('s \\<Rightarrow> bool) \\<Rightarrow> 's \\<Rightarrow> bool\" (\"\\<N>\")\nwhere     \"negate P = (\\<lambda>s. \\<not> P s)\""], ["", "lemma negateI:\n  \"\\<not> P s \\<Longrightarrow> \\<N> P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P s \\<Longrightarrow> \\<N> P s", "by (simp add:negate_def)"], ["", "lemma embed_split:\n  \"f s = \\<guillemotleft>P\\<guillemotright> s * f s + \\<guillemotleft>\\<N> P\\<guillemotright> s * f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f s =\n    \\<guillemotleft> P \\<guillemotright> s * f s +\n    \\<guillemotleft> \\<N> P \\<guillemotright> s * f s", "by (simp add:negate_def embed_bool_def)"], ["", "lemma negate_embed:\n  \"\\<guillemotleft>\\<N> P\\<guillemotright> s = 1 - \\<guillemotleft>P\\<guillemotright> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> \\<N> P \\<guillemotright> s =\n    1 - \\<guillemotleft> P \\<guillemotright> s", "by (simp add:embed_bool_def negate_def)"], ["", "lemma eval_nembed_true[simp]:\n  \"P s \\<Longrightarrow> \\<guillemotleft>\\<N> P\\<guillemotright> s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s \\<Longrightarrow> \\<guillemotleft> \\<N> P \\<guillemotright> s = 0", "by (simp add:embed_bool_def negate_def)"], ["", "lemma eval_nembed_false[simp]:\n  \"\\<not>P s \\<Longrightarrow> \\<guillemotleft>\\<N> P\\<guillemotright> s = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> \\<N> P \\<guillemotright> s = 1", "by (simp add:embed_bool_def negate_def)"], ["", "lemma negate_Not[simp]:\n  \"\\<N> Not = (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<N> Not = (\\<lambda>x. x)", "by(simp add:negate_def)"], ["", "lemma negate_negate[simp]:\n  \"\\<N> (\\<N> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<N> (\\<N> P) = P", "by(simp add:negate_def)"], ["", "lemma embed_bool_cancel:\n  \"\\<guillemotleft>G\\<guillemotright> s * \\<guillemotleft>\\<N> G\\<guillemotright> s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> s *\n    \\<guillemotleft> \\<N> G \\<guillemotright> s =\n    0", "by(cases \"G s\", simp_all)"], ["", "subsection \\<open>Entailment\\<close>"], ["", "text_raw \\<open>\\label{s:entailment}\\<close>"], ["", "text \\<open>Entailment on expectations is a generalisation of that on predicates, and is defined by\npointwise comparison:\\<close>"], ["", "abbreviation entails :: \"('s \\<Rightarrow> real) \\<Rightarrow> ('s \\<Rightarrow> real) \\<Rightarrow> bool\" (\"_ \\<tturnstile> _\" 50)\nwhere \"P \\<tturnstile> Q \\<equiv> P \\<le> Q\""], ["", "lemma entailsI[intro]:\n  \"\\<lbrakk>\\<And>s. P s \\<le> Q s\\<rbrakk> \\<Longrightarrow> P \\<tturnstile> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. P s \\<le> Q s) \\<Longrightarrow> P \\<tturnstile> Q", "by(simp add:le_funI)"], ["", "lemma entailsD[dest]:\n  \"P \\<tturnstile> Q \\<Longrightarrow> P s \\<le> Q s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tturnstile> Q \\<Longrightarrow> P s \\<le> Q s", "by(simp add:le_funD)"], ["", "lemma eq_entails[intro]:\n  \"P = Q \\<Longrightarrow> P \\<tturnstile> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = Q \\<Longrightarrow> P \\<tturnstile> Q", "by(blast)"], ["", "lemma entails_trans[trans]:\n  \"\\<lbrakk> P \\<tturnstile> Q; Q \\<tturnstile> R \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> Q; Q \\<tturnstile> R\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> R", "by(blast intro:order_trans)"], ["", "text \\<open>For standard expectations, both notions of entailment coincide. This result justifies the\nabove claim that our definition generalises predicate entailment:\\<close>"], ["", "lemma implies_entails:\n  \"\\<lbrakk> \\<And>s. P s \\<Longrightarrow> Q s \\<rbrakk> \\<Longrightarrow> \\<guillemotleft>P\\<guillemotright> \\<tturnstile> \\<guillemotleft>Q\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. P s \\<Longrightarrow> Q s) \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> \\<tturnstile> \\<guillemotleft> Q \\<guillemotright>", "by(rule entailsI, case_tac \"P s\", simp_all)"], ["", "lemma entails_implies:\n  \"\\<And>s. \\<lbrakk> \\<guillemotleft>P\\<guillemotright> \\<tturnstile> \\<guillemotleft>Q\\<guillemotright>; P s \\<rbrakk> \\<Longrightarrow> Q s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<guillemotleft> P \\<guillemotright> \\<tturnstile> \\<guillemotleft> Q \\<guillemotright>;\n        P s\\<rbrakk>\n       \\<Longrightarrow> Q s", "by(rule ccontr, drule_tac s=s in entailsD, simp)"], ["", "subsection \\<open>Expectation Conjunction\\<close>"], ["", "definition\n  pconj :: \"real \\<Rightarrow> real \\<Rightarrow>  real\" (infixl \".&\" 71)\nwhere\n  \"p .& q \\<equiv> p + q \\<ominus> 1\""], ["", "definition\n  exp_conj :: \"('s \\<Rightarrow> real) \\<Rightarrow> ('s \\<Rightarrow> real) \\<Rightarrow> ('s \\<Rightarrow> real)\" (infixl \"&&\" 71)\nwhere \"a && b \\<equiv> \\<lambda>s. (a s .& b s)\""], ["", "text \\<open>Expectation conjunction likewise generalises (boolean) predicate conjunction. We show that\nthe expected properties are preserved, and instantiate both the classical reasoner, and the\nsimplifier (in the case of associativity and commutativity).\\<close>"], ["", "lemma pconj_lzero[intro,simp]:\n  \"b \\<le> 1 \\<Longrightarrow> 0 .& b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> 1 \\<Longrightarrow> 0 .& b = 0", "by(simp add:pconj_def tminus_def)"], ["", "lemma pconj_rzero[intro,simp]:\n  \"b \\<le> 1 \\<Longrightarrow> b .& 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> 1 \\<Longrightarrow> b .& 0 = 0", "by(simp add:pconj_def tminus_def)"], ["", "lemma pconj_lone[intro,simp]:\n  \"0 \\<le> b \\<Longrightarrow> 1 .& b = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b \\<Longrightarrow> 1 .& b = b", "by(simp add:pconj_def tminus_def)"], ["", "lemma pconj_rone[intro,simp]:\n  \"0 \\<le> b \\<Longrightarrow> b .& 1 = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> b \\<Longrightarrow> b .& 1 = b", "by(simp add:pconj_def tminus_def)"], ["", "lemma pconj_bconj:\n  \"\\<guillemotleft>a\\<guillemotright> s .& \\<guillemotleft>b\\<guillemotright> s = \\<guillemotleft>\\<lambda>s. a s \\<and> b s\\<guillemotright> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> a \\<guillemotright> s .&\n    \\<guillemotleft> b \\<guillemotright> s =\n    \\<guillemotleft> \\<lambda>s. a s \\<and> b s \\<guillemotright> s", "unfolding embed_bool_def pconj_def tminus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. max ((if a s then 1 else 0) + (if b s then 1 else 0) - 1) 0 =\n    (if a s \\<and> b s then 1 else 0)", "by(force)"], ["", "lemma pconj_comm[ac_simps]:\n  \"a .& b = b .& a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a .& b = b .& a", "by(simp add:pconj_def ac_simps)"], ["", "lemma pconj_assoc:\n  \"\\<lbrakk> 0 \\<le> a; a \\<le> 1; 0 \\<le> b; b \\<le> 1; 0 \\<le> c; c \\<le> 1 \\<rbrakk> \\<Longrightarrow>\n   a .& (b .& c) = (a .& b) .& c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; a \\<le> 1; 0 \\<le> b; b \\<le> 1; 0 \\<le> c;\n     c \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> a .& (b .& c) = a .& b .& c", "unfolding pconj_def tminus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; a \\<le> 1; 0 \\<le> b; b \\<le> 1; 0 \\<le> c;\n     c \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> max (a + max (b + c - 1) 0 - 1) 0 =\n                      max (max (a + b - 1) 0 + c - 1) 0", "by(simp)"], ["", "lemma pconj_mono:\n  \"\\<lbrakk> a \\<le> b; c \\<le> d \\<rbrakk> \\<Longrightarrow> a .& c \\<le> b .& d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; c \\<le> d\\<rbrakk>\n    \\<Longrightarrow> a .& c \\<le> b .& d", "unfolding pconj_def tminus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; c \\<le> d\\<rbrakk>\n    \\<Longrightarrow> max (a + c - 1) 0 \\<le> max (b + d - 1) 0", "by(simp)"], ["", "lemma pconj_nneg[intro,simp]:\n  \"0 \\<le> a .& b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> a .& b", "unfolding pconj_def tminus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> max (a + b - 1) 0", "by(auto)"], ["", "lemma min_pconj:\n  \"(min a b) .& (min c d) \\<le> min (a .& c) (b .& d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min a b .& min c d \\<le> min (a .& c) (b .& d)", "by(cases \"a \\<le> b\",\n     (cases \"c \\<le> d\",\n      simp_all add:min.absorb1 min.absorb2 pconj_mono)[],\n     (cases \"c \\<le> d\",\n      simp_all add:min.absorb1 min.absorb2 pconj_mono))"], ["", "lemma pconj_less_one[simp]:\n  \"a + b < 1 \\<Longrightarrow> a .& b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b < 1 \\<Longrightarrow> a .& b = 0", "unfolding pconj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b < 1 \\<Longrightarrow> a + b \\<ominus> 1 = 0", "by(simp)"], ["", "lemma pconj_ge_one[simp]:\n  \"1 \\<le> a + b \\<Longrightarrow> a .& b = a + b - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> a + b \\<Longrightarrow> a .& b = a + b - 1", "unfolding pconj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> a + b \\<Longrightarrow> a + b \\<ominus> 1 = a + b - 1", "by(simp)"], ["", "lemma pconj_idem[simp]:\n  \"\\<guillemotleft>P\\<guillemotright> s .& \\<guillemotleft>P\\<guillemotright> s = \\<guillemotleft>P\\<guillemotright> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> s .&\n    \\<guillemotleft> P \\<guillemotright> s =\n    \\<guillemotleft> P \\<guillemotright> s", "unfolding pconj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> s +\n    \\<guillemotleft> P \\<guillemotright> s \\<ominus>\n    1 =\n    \\<guillemotleft> P \\<guillemotright> s", "by(cases \"P s\", simp_all)"], ["", "subsection \\<open>Rules Involving Conjunction.\\<close>"], ["", "lemma exp_conj_mono_left:\n  \"P \\<tturnstile> Q \\<Longrightarrow> P && R \\<tturnstile> Q && R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tturnstile> Q \\<Longrightarrow> P && R \\<tturnstile> Q && R", "unfolding exp_conj_def pconj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tturnstile> Q \\<Longrightarrow>\n    \\<lambda>s.\n       P s + R s \\<ominus> 1 \\<tturnstile> \\<lambda>s. Q s + R s \\<ominus> 1", "by(auto intro:tminus_left_mono add_right_mono)"], ["", "lemma exp_conj_mono_right:\n  \"Q \\<tturnstile> R \\<Longrightarrow> P && Q \\<tturnstile> P && R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<tturnstile> R \\<Longrightarrow> P && Q \\<tturnstile> P && R", "unfolding exp_conj_def pconj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<tturnstile> R \\<Longrightarrow>\n    \\<lambda>s.\n       P s + Q s \\<ominus> 1 \\<tturnstile> \\<lambda>s. P s + R s \\<ominus> 1", "by(auto intro:tminus_left_mono add_left_mono)"], ["", "lemma exp_conj_comm[ac_simps]:\n  \"a && b = b && a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a && b = b && a", "by(simp add:exp_conj_def ac_simps)"], ["", "lemma exp_conj_bounded_by[intro,simp]:\n  assumes bP: \"bounded_by 1 P\"\n      and bQ: \"bounded_by 1 Q\"\n  shows \"bounded_by 1 (P && Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by 1 (P && Q)", "proof(rule bounded_byI, unfold exp_conj_def pconj_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. P x + Q x \\<ominus> 1 \\<le> 1", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. P x + Q x \\<ominus> 1 \\<le> 1", "from bP"], ["proof (chain)\npicking this:\n  bounded_by 1 P", "have \"P x \\<le> 1\""], ["proof (prove)\nusing this:\n  bounded_by 1 P\n\ngoal (1 subgoal):\n 1. P x \\<le> 1", "by(blast)"], ["proof (state)\nthis:\n  P x \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x. P x + Q x \\<ominus> 1 \\<le> 1", "moreover"], ["proof (state)\nthis:\n  P x \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x. P x + Q x \\<ominus> 1 \\<le> 1", "from bQ"], ["proof (chain)\npicking this:\n  bounded_by 1 Q", "have \"Q x \\<le> 1\""], ["proof (prove)\nusing this:\n  bounded_by 1 Q\n\ngoal (1 subgoal):\n 1. Q x \\<le> 1", "by(blast)"], ["proof (state)\nthis:\n  Q x \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x. P x + Q x \\<ominus> 1 \\<le> 1", "ultimately"], ["proof (chain)\npicking this:\n  P x \\<le> 1\n  Q x \\<le> 1", "have \"P x + Q x \\<le> 2\""], ["proof (prove)\nusing this:\n  P x \\<le> 1\n  Q x \\<le> 1\n\ngoal (1 subgoal):\n 1. P x + Q x \\<le> 2", "by(auto)"], ["proof (state)\nthis:\n  P x + Q x \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<And>x. P x + Q x \\<ominus> 1 \\<le> 1", "thus \"P x + Q x \\<ominus> 1 \\<le> 1\""], ["proof (prove)\nusing this:\n  P x + Q x \\<le> 2\n\ngoal (1 subgoal):\n 1. P x + Q x \\<ominus> 1 \\<le> 1", "unfolding tminus_def"], ["proof (prove)\nusing this:\n  P x + Q x \\<le> 2\n\ngoal (1 subgoal):\n 1. max (P x + Q x - 1) 0 \\<le> 1", "by(simp)"], ["proof (state)\nthis:\n  P x + Q x \\<ominus> 1 \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exp_conj_o_distrib[simp]:\n  \"(P && Q) o f = (P o f) && (Q o f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P && Q \\<circ> f = (P \\<circ> f) && (Q \\<circ> f)", "unfolding exp_conj_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. P (f x) .& Q (f x)) = (\\<lambda>s. P (f s) .& Q (f s))", "by(simp)"], ["", "lemma exp_conj_assoc:\n  assumes \"unitary P\" and \"unitary Q\" and \"unitary R\"\n  shows \"P && (Q && R) = (P && Q) && R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P && (Q && R) = P && Q && R", "unfolding exp_conj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. P s .& (Q s .& R s)) = (\\<lambda>s. P s .& Q s .& R s)", "proof(rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. P s .& (Q s .& R s) = P s .& Q s .& R s", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. P s .& (Q s .& R s) = P s .& Q s .& R s", "from assms"], ["proof (chain)\npicking this:\n  unitary P\n  unitary Q\n  unitary R", "have \"0 \\<le> P s\""], ["proof (prove)\nusing this:\n  unitary P\n  unitary Q\n  unitary R\n\ngoal (1 subgoal):\n 1. 0 \\<le> P s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> P s\n\ngoal (1 subgoal):\n 1. \\<And>s. P s .& (Q s .& R s) = P s .& Q s .& R s", "moreover"], ["proof (state)\nthis:\n  0 \\<le> P s\n\ngoal (1 subgoal):\n 1. \\<And>s. P s .& (Q s .& R s) = P s .& Q s .& R s", "from assms"], ["proof (chain)\npicking this:\n  unitary P\n  unitary Q\n  unitary R", "have \"0 \\<le> Q s\""], ["proof (prove)\nusing this:\n  unitary P\n  unitary Q\n  unitary R\n\ngoal (1 subgoal):\n 1. 0 \\<le> Q s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> Q s\n\ngoal (1 subgoal):\n 1. \\<And>s. P s .& (Q s .& R s) = P s .& Q s .& R s", "moreover"], ["proof (state)\nthis:\n  0 \\<le> Q s\n\ngoal (1 subgoal):\n 1. \\<And>s. P s .& (Q s .& R s) = P s .& Q s .& R s", "from assms"], ["proof (chain)\npicking this:\n  unitary P\n  unitary Q\n  unitary R", "have \"0 \\<le> R s\""], ["proof (prove)\nusing this:\n  unitary P\n  unitary Q\n  unitary R\n\ngoal (1 subgoal):\n 1. 0 \\<le> R s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> R s\n\ngoal (1 subgoal):\n 1. \\<And>s. P s .& (Q s .& R s) = P s .& Q s .& R s", "moreover"], ["proof (state)\nthis:\n  0 \\<le> R s\n\ngoal (1 subgoal):\n 1. \\<And>s. P s .& (Q s .& R s) = P s .& Q s .& R s", "from assms"], ["proof (chain)\npicking this:\n  unitary P\n  unitary Q\n  unitary R", "have \"P s \\<le> 1\""], ["proof (prove)\nusing this:\n  unitary P\n  unitary Q\n  unitary R\n\ngoal (1 subgoal):\n 1. P s \\<le> 1", "by(blast)"], ["proof (state)\nthis:\n  P s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>s. P s .& (Q s .& R s) = P s .& Q s .& R s", "moreover"], ["proof (state)\nthis:\n  P s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>s. P s .& (Q s .& R s) = P s .& Q s .& R s", "from assms"], ["proof (chain)\npicking this:\n  unitary P\n  unitary Q\n  unitary R", "have \"Q s \\<le> 1\""], ["proof (prove)\nusing this:\n  unitary P\n  unitary Q\n  unitary R\n\ngoal (1 subgoal):\n 1. Q s \\<le> 1", "by(blast)"], ["proof (state)\nthis:\n  Q s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>s. P s .& (Q s .& R s) = P s .& Q s .& R s", "moreover"], ["proof (state)\nthis:\n  Q s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>s. P s .& (Q s .& R s) = P s .& Q s .& R s", "from assms"], ["proof (chain)\npicking this:\n  unitary P\n  unitary Q\n  unitary R", "have \"R s \\<le> 1\""], ["proof (prove)\nusing this:\n  unitary P\n  unitary Q\n  unitary R\n\ngoal (1 subgoal):\n 1. R s \\<le> 1", "by(blast)"], ["proof (state)\nthis:\n  R s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>s. P s .& (Q s .& R s) = P s .& Q s .& R s", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> P s\n  0 \\<le> Q s\n  0 \\<le> R s\n  P s \\<le> 1\n  Q s \\<le> 1\n  R s \\<le> 1", "show \"P s .& (Q s .& R s) = (P s .& Q s) .& R s\""], ["proof (prove)\nusing this:\n  0 \\<le> P s\n  0 \\<le> Q s\n  0 \\<le> R s\n  P s \\<le> 1\n  Q s \\<le> 1\n  R s \\<le> 1\n\ngoal (1 subgoal):\n 1. P s .& (Q s .& R s) = P s .& Q s .& R s", "by(simp add:pconj_assoc)"], ["proof (state)\nthis:\n  P s .& (Q s .& R s) = P s .& Q s .& R s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exp_conj_top_left[simp]:\n  \"sound P \\<Longrightarrow> \\<guillemotleft>\\<lambda>_. True\\<guillemotright> && P = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound P \\<Longrightarrow>\n    \\<guillemotleft> \\<lambda>_. True \\<guillemotright> && P = P", "unfolding exp_conj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound P \\<Longrightarrow>\n    (\\<lambda>s.\n        \\<guillemotleft> \\<lambda>_. True \\<guillemotright> s .& P s) =\n    P", "by(force)"], ["", "lemma exp_conj_top_right[simp]:\n  \"sound P \\<Longrightarrow> P && \\<guillemotleft>\\<lambda>_. True\\<guillemotright> = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound P \\<Longrightarrow>\n    P && \\<guillemotleft> \\<lambda>_. True \\<guillemotright> = P", "unfolding exp_conj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound P \\<Longrightarrow>\n    (\\<lambda>s.\n        P s .& \\<guillemotleft> \\<lambda>_. True \\<guillemotright> s) =\n    P", "by(force)"], ["", "lemma exp_conj_idem[simp]:\n  \"\\<guillemotleft>P\\<guillemotright> && \\<guillemotleft>P\\<guillemotright> = \\<guillemotleft>P\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> &&\n    \\<guillemotleft> P \\<guillemotright> =\n    \\<guillemotleft> P \\<guillemotright>", "unfolding exp_conj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        \\<guillemotleft> P \\<guillemotright> s .&\n        \\<guillemotleft> P \\<guillemotright> s) =\n    \\<guillemotleft> P \\<guillemotright>", "by(rule ext, cases \"P s\", simp_all)"], ["", "lemma exp_conj_nneg[intro,simp]:\n  \"(\\<lambda>s. 0) \\<le> P && Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s. 0 \\<tturnstile> P && Q", "unfolding exp_conj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s. 0 \\<tturnstile> \\<lambda>s. P s .& Q s", "by(blast intro:le_funI)"], ["", "lemma exp_conj_sound[intro,simp]:\n  assumes s_P: \"sound P\"\n      and s_Q: \"sound Q\"\n  shows \"sound (P && Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (P && Q)", "unfolding exp_conj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (\\<lambda>s. P s .& Q s)", "proof(rule soundI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Expectations.bounded (\\<lambda>s. P s .& Q s)\n 2. nneg (\\<lambda>s. P s .& Q s)", "from s_P and s_Q"], ["proof (chain)\npicking this:\n  sound P\n  sound Q", "have \"\\<And>s. 0 \\<le> P s + Q s\""], ["proof (prove)\nusing this:\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. \\<And>s. 0 \\<le> P s + Q s", "by(blast intro:add_nonneg_nonneg)"], ["proof (state)\nthis:\n  0 \\<le> P ?s + Q ?s\n\ngoal (2 subgoals):\n 1. Expectations.bounded (\\<lambda>s. P s .& Q s)\n 2. nneg (\\<lambda>s. P s .& Q s)", "hence \"\\<And>s. P s .& Q s \\<le> P s + Q s\""], ["proof (prove)\nusing this:\n  0 \\<le> P ?s + Q ?s\n\ngoal (1 subgoal):\n 1. \\<And>s. P s .& Q s \\<le> P s + Q s", "unfolding pconj_def"], ["proof (prove)\nusing this:\n  0 \\<le> P ?s + Q ?s\n\ngoal (1 subgoal):\n 1. \\<And>s. P s + Q s \\<ominus> 1 \\<le> P s + Q s", "by(force intro:tminus_less)"], ["proof (state)\nthis:\n  P ?s .& Q ?s \\<le> P ?s + Q ?s\n\ngoal (2 subgoals):\n 1. Expectations.bounded (\\<lambda>s. P s .& Q s)\n 2. nneg (\\<lambda>s. P s .& Q s)", "also"], ["proof (state)\nthis:\n  P ?s .& Q ?s \\<le> P ?s + Q ?s\n\ngoal (2 subgoals):\n 1. Expectations.bounded (\\<lambda>s. P s .& Q s)\n 2. nneg (\\<lambda>s. P s .& Q s)", "from assms"], ["proof (chain)\npicking this:\n  sound P\n  sound Q", "have \"\\<And>s. ... s \\<le> bound_of P + bound_of Q\""], ["proof (prove)\nusing this:\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. \\<And>s. P s + Q s \\<le> bound_of P + bound_of Q", "by(blast intro:add_mono)"], ["proof (state)\nthis:\n  P ?s + Q ?s \\<le> bound_of P + bound_of Q\n\ngoal (2 subgoals):\n 1. Expectations.bounded (\\<lambda>s. P s .& Q s)\n 2. nneg (\\<lambda>s. P s .& Q s)", "finally"], ["proof (chain)\npicking this:\n  P ?s1 .& Q ?s1 \\<le> bound_of P + bound_of Q", "have \"bounded_by (bound_of P + bound_of Q) (\\<lambda>s. P s .& Q s)\""], ["proof (prove)\nusing this:\n  P ?s1 .& Q ?s1 \\<le> bound_of P + bound_of Q\n\ngoal (1 subgoal):\n 1. bounded_by (bound_of P + bound_of Q) (\\<lambda>s. P s .& Q s)", "by(blast)"], ["proof (state)\nthis:\n  bounded_by (bound_of P + bound_of Q) (\\<lambda>s. P s .& Q s)\n\ngoal (2 subgoals):\n 1. Expectations.bounded (\\<lambda>s. P s .& Q s)\n 2. nneg (\\<lambda>s. P s .& Q s)", "thus \"bounded (\\<lambda>s. P s .& Q s)\""], ["proof (prove)\nusing this:\n  bounded_by (bound_of P + bound_of Q) (\\<lambda>s. P s .& Q s)\n\ngoal (1 subgoal):\n 1. Expectations.bounded (\\<lambda>s. P s .& Q s)", "by(blast)"], ["proof (state)\nthis:\n  Expectations.bounded (\\<lambda>s. P s .& Q s)\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. P s .& Q s)", "show \"nneg (\\<lambda>s. P s .& Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. P s .& Q s)", "unfolding pconj_def tminus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. max (P s + Q s - 1) 0)", "by(force)"], ["proof (state)\nthis:\n  nneg (\\<lambda>s. P s .& Q s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exp_conj_rzero[simp]:\n  \"bounded_by 1 P \\<Longrightarrow> P && (\\<lambda>s. 0) = (\\<lambda>s. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by 1 P \\<Longrightarrow> P && (\\<lambda>s. 0) = (\\<lambda>s. 0)", "unfolding exp_conj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by 1 P \\<Longrightarrow>\n    (\\<lambda>s. P s .& 0) = (\\<lambda>s. 0)", "by(force)"], ["", "lemma exp_conj_1_right[simp]:\n  assumes nn: \"nneg A\"\n  shows \"A && (\\<lambda>_. 1) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A && (\\<lambda>_. 1) = A", "unfolding exp_conj_def pconj_def tminus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. max (A s + 1 - 1) 0) = A", "proof(rule ext, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. max (A s) 0 = A s", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. max (A s) 0 = A s", "from nn"], ["proof (chain)\npicking this:\n  nneg A", "have \"0 \\<le> A s\""], ["proof (prove)\nusing this:\n  nneg A\n\ngoal (1 subgoal):\n 1. 0 \\<le> A s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> A s\n\ngoal (1 subgoal):\n 1. \\<And>s. max (A s) 0 = A s", "thus \"max (A s) 0 = A s\""], ["proof (prove)\nusing this:\n  0 \\<le> A s\n\ngoal (1 subgoal):\n 1. max (A s) 0 = A s", "by(force)"], ["proof (state)\nthis:\n  max (A s) 0 = A s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exp_conj_std_split:\n  \"\\<guillemotleft>\\<lambda>s. P s \\<and> Q s\\<guillemotright> = \\<guillemotleft>P\\<guillemotright> && \\<guillemotleft>Q\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> \\<lambda>s. P s \\<and> Q s \\<guillemotright> =\n    \\<guillemotleft> P \\<guillemotright> &&\n    \\<guillemotleft> Q \\<guillemotright>", "unfolding exp_conj_def embed_bool_def pconj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. if P s \\<and> Q s then 1 else 0) =\n    (\\<lambda>s.\n        (if P s then 1 else 0) + (if Q s then 1 else 0) \\<ominus> 1)", "by(auto)"], ["", "subsection \\<open>Rules Involving Entailment and Conjunction Together\\<close>"], ["", "text \\<open>Meta-conjunction distributes over expectaton entailment,\nbecoming expectation conjunction:\\<close>"], ["", "lemma entails_frame:\n  assumes ePR: \"P \\<tturnstile> R\"\n      and eQS: \"Q \\<tturnstile> S\"\n  shows \"P && Q \\<tturnstile> R && S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P && Q \\<tturnstile> R && S", "proof(rule le_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (P && Q) x \\<le> (R && S) x", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (P && Q) x \\<le> (R && S) x", "from ePR"], ["proof (chain)\npicking this:\n  P \\<tturnstile> R", "have \"P s \\<le> R s\""], ["proof (prove)\nusing this:\n  P \\<tturnstile> R\n\ngoal (1 subgoal):\n 1. P s \\<le> R s", "by(blast)"], ["proof (state)\nthis:\n  P s \\<le> R s\n\ngoal (1 subgoal):\n 1. \\<And>x. (P && Q) x \\<le> (R && S) x", "moreover"], ["proof (state)\nthis:\n  P s \\<le> R s\n\ngoal (1 subgoal):\n 1. \\<And>x. (P && Q) x \\<le> (R && S) x", "from eQS"], ["proof (chain)\npicking this:\n  Q \\<tturnstile> S", "have \"Q s \\<le> S s\""], ["proof (prove)\nusing this:\n  Q \\<tturnstile> S\n\ngoal (1 subgoal):\n 1. Q s \\<le> S s", "by(blast)"], ["proof (state)\nthis:\n  Q s \\<le> S s\n\ngoal (1 subgoal):\n 1. \\<And>x. (P && Q) x \\<le> (R && S) x", "ultimately"], ["proof (chain)\npicking this:\n  P s \\<le> R s\n  Q s \\<le> S s", "have \"P s + Q s \\<le> R s + S s\""], ["proof (prove)\nusing this:\n  P s \\<le> R s\n  Q s \\<le> S s\n\ngoal (1 subgoal):\n 1. P s + Q s \\<le> R s + S s", "by(rule add_mono)"], ["proof (state)\nthis:\n  P s + Q s \\<le> R s + S s\n\ngoal (1 subgoal):\n 1. \\<And>x. (P && Q) x \\<le> (R && S) x", "hence \"P s + Q s \\<ominus> 1 \\<le> R s + S s \\<ominus> 1\""], ["proof (prove)\nusing this:\n  P s + Q s \\<le> R s + S s\n\ngoal (1 subgoal):\n 1. P s + Q s \\<ominus> 1 \\<le> R s + S s \\<ominus> 1", "by(rule tminus_left_mono)"], ["proof (state)\nthis:\n  P s + Q s \\<ominus> 1 \\<le> R s + S s \\<ominus> 1\n\ngoal (1 subgoal):\n 1. \\<And>x. (P && Q) x \\<le> (R && S) x", "thus \"(P && Q) s \\<le> (R && S) s\""], ["proof (prove)\nusing this:\n  P s + Q s \\<ominus> 1 \\<le> R s + S s \\<ominus> 1\n\ngoal (1 subgoal):\n 1. (P && Q) s \\<le> (R && S) s", "unfolding exp_conj_def pconj_def"], ["proof (prove)\nusing this:\n  P s + Q s \\<ominus> 1 \\<le> R s + S s \\<ominus> 1\n\ngoal (1 subgoal):\n 1. P s + Q s \\<ominus> 1 \\<le> R s + S s \\<ominus> 1", "."], ["proof (state)\nthis:\n  (P && Q) s \\<le> (R && S) s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This rule allows something very much akin to a case distinction\non the pre-expectation.\\<close>"], ["", "lemma pentails_cases:\n  assumes PQe: \"\\<And>x. P x \\<tturnstile> Q x\"\n      and exhaust: \"\\<And>s. \\<exists>x. P (x s) s = 1\"\n      and framed: \"\\<And>x. P x && R \\<tturnstile> Q x && S\"\n      and sR: \"sound R\" and sS: \"sound S\"\n      and bQ: \"\\<And>x. bounded_by 1 (Q x)\"\n  shows \"R \\<tturnstile> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<tturnstile> S", "proof(rule le_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "from exhaust"], ["proof (chain)\npicking this:\n  \\<exists>x. P (x ?s) ?s = 1", "obtain x where P_xs: \"P x s = 1\""], ["proof (prove)\nusing this:\n  \\<exists>x. P (x ?s) ?s = 1\n\ngoal (1 subgoal):\n 1. (\\<And>x. P x s = 1 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by(blast)"], ["proof (state)\nthis:\n  P x s = 1\n\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "moreover"], ["proof (state)\nthis:\n  P x s = 1\n\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "{"], ["proof (state)\nthis:\n  P x s = 1\n\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "hence \"1 = P x s\""], ["proof (prove)\nusing this:\n  P x s = 1\n\ngoal (1 subgoal):\n 1. 1 = P x s", "by(simp)"], ["proof (state)\nthis:\n  1 = P x s\n\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "also"], ["proof (state)\nthis:\n  1 = P x s\n\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "from PQe"], ["proof (chain)\npicking this:\n  P ?x \\<tturnstile> Q ?x", "have \"P x s \\<le> Q x s\""], ["proof (prove)\nusing this:\n  P ?x \\<tturnstile> Q ?x\n\ngoal (1 subgoal):\n 1. P x s \\<le> Q x s", "by(blast dest:le_funD)"], ["proof (state)\nthis:\n  P x s \\<le> Q x s\n\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> Q x s", "have \"Q x s = 1\""], ["proof (prove)\nusing this:\n  1 \\<le> Q x s\n\ngoal (1 subgoal):\n 1. Q x s = 1", "using bQ"], ["proof (prove)\nusing this:\n  1 \\<le> Q x s\n  bounded_by 1 (Q ?x)\n\ngoal (1 subgoal):\n 1. Q x s = 1", "by(blast intro:antisym)"], ["proof (state)\nthis:\n  Q x s = 1\n\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "}"], ["proof (state)\nthis:\n  Q x s = 1\n\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "moreover"], ["proof (state)\nthis:\n  Q x s = 1\n\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "note le_funD[OF framed[where x=x], where x=s]"], ["proof (state)\nthis:\n  (P x && R) s \\<le> (Q x && S) s\n\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "moreover"], ["proof (state)\nthis:\n  (P x && R) s \\<le> (Q x && S) s\n\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "from sR"], ["proof (chain)\npicking this:\n  sound R", "have \"0 \\<le> R s\""], ["proof (prove)\nusing this:\n  sound R\n\ngoal (1 subgoal):\n 1. 0 \\<le> R s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> R s\n\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "moreover"], ["proof (state)\nthis:\n  0 \\<le> R s\n\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "from sS"], ["proof (chain)\npicking this:\n  sound S", "have \"0 \\<le> S s\""], ["proof (prove)\nusing this:\n  sound S\n\ngoal (1 subgoal):\n 1. 0 \\<le> S s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> S s\n\ngoal (1 subgoal):\n 1. \\<And>x. R x \\<le> S x", "ultimately"], ["proof (chain)\npicking this:\n  P x s = 1\n  Q x s = 1\n  (P x && R) s \\<le> (Q x && S) s\n  0 \\<le> R s\n  0 \\<le> S s", "show \"R s \\<le> S s\""], ["proof (prove)\nusing this:\n  P x s = 1\n  Q x s = 1\n  (P x && R) s \\<le> (Q x && S) s\n  0 \\<le> R s\n  0 \\<le> S s\n\ngoal (1 subgoal):\n 1. R s \\<le> S s", "by(simp add:exp_conj_def)"], ["proof (state)\nthis:\n  R s \\<le> S s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unitary_bot[iff]:\n  \"unitary (\\<lambda>s. 0::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (\\<lambda>s. 0)", "by(auto)"], ["", "lemma unitary_top[iff]:\n  \"unitary (\\<lambda>s. 1::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (\\<lambda>s. 1)", "by(auto)"], ["", "lemma unitary_embed[iff]:\n  \"unitary \\<guillemotleft>P\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary \\<guillemotleft> P \\<guillemotright>", "by(auto)"], ["", "lemma unitary_const[iff]:\n  \"\\<lbrakk> 0 \\<le> c; c \\<le> 1 \\<rbrakk> \\<Longrightarrow> unitary (\\<lambda>s. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> c; c \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> unitary (\\<lambda>s. c)", "by(auto)"], ["", "lemma unitary_mult:\n  assumes uA: \"unitary A\" and uB: \"unitary B\"\n  shows \"unitary (\\<lambda>s. A s * B s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (\\<lambda>s. A s * B s)", "proof(intro unitaryI2 nnegI bounded_byI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<le> A x * B x\n 2. \\<And>x. A x * B x \\<le> 1", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<le> A x * B x\n 2. \\<And>x. A x * B x \\<le> 1", "from assms"], ["proof (chain)\npicking this:\n  unitary A\n  unitary B", "have nnA: \"0 \\<le> A s\" and nnB: \"0 \\<le> B s\""], ["proof (prove)\nusing this:\n  unitary A\n  unitary B\n\ngoal (1 subgoal):\n 1. 0 \\<le> A s &&& 0 \\<le> B s", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> A s\n  0 \\<le> B s\n\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<le> A x * B x\n 2. \\<And>x. A x * B x \\<le> 1", "thus \"0 \\<le> A s * B s\""], ["proof (prove)\nusing this:\n  0 \\<le> A s\n  0 \\<le> B s\n\ngoal (1 subgoal):\n 1. 0 \\<le> A s * B s", "by(rule mult_nonneg_nonneg)"], ["proof (state)\nthis:\n  0 \\<le> A s * B s\n\ngoal (1 subgoal):\n 1. \\<And>x. A x * B x \\<le> 1", "from assms"], ["proof (chain)\npicking this:\n  unitary A\n  unitary B", "have \"A s \\<le> 1\" and \"B s \\<le> 1\""], ["proof (prove)\nusing this:\n  unitary A\n  unitary B\n\ngoal (1 subgoal):\n 1. A s \\<le> 1 &&& B s \\<le> 1", "by(auto)"], ["proof (state)\nthis:\n  A s \\<le> 1\n  B s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x. A x * B x \\<le> 1", "with nnB"], ["proof (chain)\npicking this:\n  0 \\<le> B s\n  A s \\<le> 1\n  B s \\<le> 1", "have \"A s * B s \\<le> 1 * 1\""], ["proof (prove)\nusing this:\n  0 \\<le> B s\n  A s \\<le> 1\n  B s \\<le> 1\n\ngoal (1 subgoal):\n 1. A s * B s \\<le> 1 * 1", "by(intro mult_mono, auto)"], ["proof (state)\nthis:\n  A s * B s \\<le> 1 * 1\n\ngoal (1 subgoal):\n 1. \\<And>x. A x * B x \\<le> 1", "also"], ["proof (state)\nthis:\n  A s * B s \\<le> 1 * 1\n\ngoal (1 subgoal):\n 1. \\<And>x. A x * B x \\<le> 1", "have \"... = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 1 = 1", "by(simp)"], ["proof (state)\nthis:\n  1 * 1 = 1\n\ngoal (1 subgoal):\n 1. \\<And>x. A x * B x \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  A s * B s \\<le> 1", "show \"A s * B s \\<le> 1\""], ["proof (prove)\nusing this:\n  A s * B s \\<le> 1\n\ngoal (1 subgoal):\n 1. A s * B s \\<le> 1", "."], ["proof (state)\nthis:\n  A s * B s \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exp_conj_unitary:\n  \"\\<lbrakk> unitary P; unitary Q \\<rbrakk> \\<Longrightarrow> unitary (P && Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unitary P; unitary Q\\<rbrakk>\n    \\<Longrightarrow> unitary (P && Q)", "by(intro unitaryI2 nnegI2, auto)"], ["", "lemma unitary_comp[simp]:\n  \"unitary P \\<Longrightarrow> unitary (P o f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary P \\<Longrightarrow> unitary (P \\<circ> f)", "by(intro unitaryI2 nnegI bounded_byI, auto simp:o_def)"], ["", "lemmas unitary_intros =\n  unitary_bot unitary_top unitary_embed unitary_mult exp_conj_unitary\n  unitary_comp unitary_const"], ["", "lemmas sound_intros =\n  mult_sound div_sound const_sound sound_o sound_sum\n  tminus_sound sc_sound exp_conj_sound sum_sound"], ["", "end"]]}