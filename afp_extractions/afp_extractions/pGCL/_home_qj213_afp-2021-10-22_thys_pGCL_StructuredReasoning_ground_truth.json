{"file_name": "/home/qj213/afp-2021-10-22/thys/pGCL/StructuredReasoning.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/pGCL", "problem_names": ["lemma wp_Abort:\n  \"(\\<lambda>s. 0) \\<tturnstile> wp Abort Q\"", "lemma wlp_Abort:\n  \"(\\<lambda>s. 1) \\<tturnstile> wlp Abort Q\"", "lemma wp_Skip:\n  \"P \\<tturnstile> wp Skip P\"", "lemma wlp_Skip:\n  \"P \\<tturnstile> wlp Skip P\"", "lemma wp_Apply:\n  \"Q o f \\<tturnstile> wp (Apply f) Q\"", "lemma wlp_Apply:\n  \"Q o f \\<tturnstile> wlp (Apply f) Q\"", "lemma wp_Seq:\n  assumes ent_a: \"P \\<tturnstile> wp a Q\"\n      and ent_b: \"Q \\<tturnstile> wp b R\"\n      and wa:   \"well_def a\"\n      and wb:   \"well_def b\"\n      and s_Q:   \"sound Q\"\n      and s_R:   \"sound R\"\n  shows \"P \\<tturnstile> wp (a ;; b) R\"", "lemma wlp_Seq:\n  assumes ent_a: \"P \\<tturnstile> wlp a Q\"\n      and ent_b: \"Q \\<tturnstile> wlp b R\"\n      and wa:   \"well_def a\"\n      and wb:   \"well_def b\"\n      and u_Q:   \"unitary Q\"\n      and u_R:   \"unitary R\"\n  shows \"P \\<tturnstile> wlp (a ;; b) R\"", "lemma wp_PC:\n  \"(\\<lambda>s. P s * wp a Q s + (1 - P s) * wp b Q s) \\<tturnstile> wp (a \\<^bsub>P\\<^esub>\\<oplus> b) Q\"", "lemma wlp_PC:\n  \"(\\<lambda>s. P s * wlp a Q s + (1 - P s) * wlp b Q s) \\<tturnstile> wlp (a \\<^bsub>P\\<^esub>\\<oplus> b) Q\"", "lemma PC_fixed:\n  assumes wpa: \"P \\<tturnstile> a ab R\"\n      and wpb: \"Q \\<tturnstile> b ab R\"\n      and np: \"0 \\<le> p\" and bp: \"p \\<le> 1\"\n  shows \"(\\<lambda>s. p * P s + (1 - p) * Q s) \\<tturnstile> (a \\<^bsub>(\\<lambda>s. p)\\<^esub>\\<oplus> b) ab R\"", "lemma wp_PC_fixed:\n  \"\\<lbrakk> P \\<tturnstile> wp a R; Q \\<tturnstile> wp b R; 0 \\<le> p; p \\<le> 1 \\<rbrakk> \\<Longrightarrow>\n  (\\<lambda>s. p * P s + (1 - p) * Q s) \\<tturnstile> wp (a \\<^bsub>(\\<lambda>s. p)\\<^esub>\\<oplus> b) R\"", "lemma wlp_PC_fixed:\n  \"\\<lbrakk> P \\<tturnstile> wlp a R; Q \\<tturnstile> wlp b R; 0 \\<le> p; p \\<le> 1 \\<rbrakk> \\<Longrightarrow>\n  (\\<lambda>s. p * P s + (1 - p) * Q s) \\<tturnstile> wlp (a \\<^bsub>(\\<lambda>s. p)\\<^esub>\\<oplus> b) R\"", "lemma wp_DC:\n  \"(\\<lambda>s. min (wp a Q s) (wp b Q s)) \\<tturnstile> wp (a \\<Sqinter> b) Q\"", "lemma wlp_DC:\n  \"(\\<lambda>s. min (wlp a Q s) (wlp b Q s)) \\<tturnstile> wlp (a \\<Sqinter> b) Q\"", "lemma DC_split:\n  fixes a::\"'s prog\" and b\n  assumes wpa: \"P \\<tturnstile> a ab R\"\n      and wpb: \"Q \\<tturnstile> b ab R\"\n  shows \"(\\<lambda>s. min (P s) (Q s)) \\<tturnstile> (a \\<Sqinter> b) ab R\"", "lemma wp_DC_split:\n  \"\\<lbrakk> P \\<tturnstile> wp prog R; Q \\<tturnstile> wp prog' R \\<rbrakk> \\<Longrightarrow>\n  (\\<lambda>s. min (P s) (Q s)) \\<tturnstile> wp (prog \\<Sqinter> prog') R\"", "lemma wlp_DC_split:\n  \"\\<lbrakk> P \\<tturnstile> wlp prog R; Q \\<tturnstile> wlp prog' R \\<rbrakk> \\<Longrightarrow>\n  (\\<lambda>s. min (P s) (Q s)) \\<tturnstile> wlp (prog \\<Sqinter> prog') R\"", "lemma wp_DC_split_same:\n  \"\\<lbrakk> P \\<tturnstile> wp prog Q; P \\<tturnstile> wp prog' Q \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> wp (prog \\<Sqinter> prog') Q\"", "lemma wlp_DC_split_same:\n  \"\\<lbrakk> P \\<tturnstile> wlp prog Q; P \\<tturnstile> wlp prog' Q \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> wlp (prog \\<Sqinter> prog') Q\"", "lemma SetPC_split:\n  fixes f::\"'x \\<Rightarrow> 'y prog\"\n    and p::\"'y \\<Rightarrow> 'x \\<Rightarrow> real\"\n  assumes rec: \"\\<And>x s. x \\<in> supp (p s) \\<Longrightarrow> P x \\<tturnstile> f x ab Q\"\n      and nnp: \"\\<And>s. nneg (p s)\"\n  shows \"(\\<lambda>s. \\<Sum>x \\<in> supp (p s). p s x * P x s) \\<tturnstile> SetPC f p ab Q\"", "lemma wp_SetPC_split:\n  \"\\<lbrakk> \\<And>x s. x \\<in> supp (p s) \\<Longrightarrow> P x \\<tturnstile> wp (f x) Q; \\<And>s. nneg (p s) \\<rbrakk> \\<Longrightarrow>\n   (\\<lambda>s. \\<Sum>x \\<in> supp (p s). p s x * P x s) \\<tturnstile> wp (SetPC f p) Q\"", "lemma wlp_SetPC_split:\n  \"\\<lbrakk> \\<And>x s. x \\<in> supp (p s) \\<Longrightarrow> P x \\<tturnstile> wlp (f x) Q; \\<And>s. nneg (p s) \\<rbrakk> \\<Longrightarrow>\n   (\\<lambda>s. \\<Sum>x \\<in> supp (p s). p s x * P x s) \\<tturnstile> wlp (SetPC f p) Q\"", "lemma wp_SetDC_split:\n  \"\\<lbrakk> \\<And>s x. x \\<in> S s \\<Longrightarrow> P \\<tturnstile> wp (f x) Q; \\<And>s. S s \\<noteq> {} \\<rbrakk> \\<Longrightarrow>\n   P \\<tturnstile> wp (SetDC f S) Q\"", "lemma wlp_SetDC_split:\n  \"\\<lbrakk> \\<And>s x. x \\<in> S s \\<Longrightarrow> P \\<tturnstile> wlp (f x) Q; \\<And>s. S s \\<noteq> {} \\<rbrakk> \\<Longrightarrow>\n   P \\<tturnstile> wlp (SetDC f S) Q\"", "lemma wp_SetDC:\n  assumes wp: \"\\<And>s x. x \\<in> S s \\<Longrightarrow> P x \\<tturnstile> wp (f x) Q\"\n      and ne: \"\\<And>s. S s \\<noteq> {}\"\n      and sP: \"\\<And>x. sound (P x)\"\n  shows \"(\\<lambda>s. Inf ((\\<lambda>x. P x s) ` S s)) \\<tturnstile> wp (SetDC f S) Q\"", "lemma wlp_SetDC:\n  assumes wp: \"\\<And>s x. x \\<in> S s \\<Longrightarrow> P x \\<tturnstile> wlp (f x) Q\"\n      and ne: \"\\<And>s. S s \\<noteq> {}\"\n      and sP: \"\\<And>x. sound (P x)\"\n  shows \"(\\<lambda>s. Inf ((\\<lambda>x. P x s) ` S s)) \\<tturnstile> wlp (SetDC f S) Q\"", "lemma wp_Embed:\n  \"P \\<tturnstile> t Q \\<Longrightarrow> P \\<tturnstile> wp (Embed t) Q\"", "lemma wlp_Embed:\n  \"P \\<tturnstile> t Q \\<Longrightarrow> P \\<tturnstile> wlp (Embed t) Q\"", "lemma wp_Bind:\n  \"\\<lbrakk> \\<And>s. P s \\<le> wp (a (f s)) Q s \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> wp (Bind f a) Q\"", "lemma wlp_Bind:\n  \"\\<lbrakk> \\<And>s. P s \\<le> wlp (a (f s)) Q s \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> wlp (Bind f a) Q\"", "lemma wp_repeat:\n  \"\\<lbrakk> P \\<tturnstile> wp a Q; Q \\<tturnstile> wp (repeat n a) R;\n     well_def a; sound Q; sound R \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> wp (repeat (Suc n) a) R\"", "lemma wlp_repeat:\n  \"\\<lbrakk> P \\<tturnstile> wlp a Q; Q \\<tturnstile> wlp (repeat n a) R;\n     well_def a; unitary Q; unitary R \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> wlp (repeat (Suc n) a) R\"", "lemmas wp_strengthen_post=\n  entails_strengthen_post[where t=\"wp a\" for a]", "lemma wlp_strengthen_post:\n  \"P \\<tturnstile> wlp a Q \\<Longrightarrow> nearly_healthy (wlp a) \\<Longrightarrow> unitary R \\<Longrightarrow> Q \\<tturnstile> R \\<Longrightarrow> unitary Q \\<Longrightarrow>\n   P \\<tturnstile> wlp a R\"", "lemmas wp_weaken_pre=\n  entails_weaken_pre[where t=\"wp a\" for a]", "lemmas wlp_weaken_pre=\n  entails_weaken_pre[where t=\"wlp a\" for a]", "lemmas wp_scale=\n  entails_scale[where t=\"wp a\" for a, OF _ well_def_wp_healthy]", "lemma wp_refines:\n  \"\\<lbrakk> a \\<sqsubseteq> b; P \\<tturnstile> wp a Q; sound Q \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> wp b Q\"", "lemmas wp_drefines = drefinesD", "lemma wp_validI:\n  \"P \\<tturnstile> wp prog Q \\<Longrightarrow> \\<lbrace>P\\<rbrace> prog \\<lbrace>Q\\<rbrace>p\"", "lemma wp_validD:\n  \"\\<lbrace>P\\<rbrace> prog \\<lbrace>Q\\<rbrace>p \\<Longrightarrow> P \\<tturnstile> wp prog Q\"", "lemma valid_Seq:\n  \"\\<lbrakk> \\<lbrace>P\\<rbrace> a \\<lbrace>Q\\<rbrace>p; \\<lbrace>Q\\<rbrace> b \\<lbrace>R\\<rbrace>p; well_def a; well_def b; sound Q; sound R \\<rbrakk> \\<Longrightarrow>\n  \\<lbrace>P\\<rbrace> a ;; b \\<lbrace>R\\<rbrace>p\""], "translations": [["", "lemma wp_Abort:\n  \"(\\<lambda>s. 0) \\<tturnstile> wp Abort Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s. 0 \\<tturnstile> wp Abort Q", "unfolding wp_eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s. 0 \\<tturnstile> \\<lambda>s. 0", "by(simp)"], ["", "lemma wlp_Abort:\n  \"(\\<lambda>s. 1) \\<tturnstile> wlp Abort Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s. 1 \\<tturnstile> wlp Abort Q", "unfolding wp_eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s. 1 \\<tturnstile> \\<lambda>s. 1", "by(simp)"], ["", "lemma wp_Skip:\n  \"P \\<tturnstile> wp Skip P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tturnstile> wp Skip P", "unfolding wp_eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tturnstile> P", "by(blast)"], ["", "lemma wlp_Skip:\n  \"P \\<tturnstile> wlp Skip P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tturnstile> wlp Skip P", "unfolding wp_eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tturnstile> P", "by(blast)"], ["", "lemma wp_Apply:\n  \"Q o f \\<tturnstile> wp (Apply f) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<circ> f \\<tturnstile> wp (Apply f) Q", "unfolding wp_eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<circ> f \\<tturnstile> Q \\<circ> f", "by(simp)"], ["", "lemma wlp_Apply:\n  \"Q o f \\<tturnstile> wlp (Apply f) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<circ> f \\<tturnstile> wlp (Apply f) Q", "unfolding wp_eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<circ> f \\<tturnstile> Q \\<circ> f", "by(simp)"], ["", "lemma wp_Seq:\n  assumes ent_a: \"P \\<tturnstile> wp a Q\"\n      and ent_b: \"Q \\<tturnstile> wp b R\"\n      and wa:   \"well_def a\"\n      and wb:   \"well_def b\"\n      and s_Q:   \"sound Q\"\n      and s_R:   \"sound R\"\n  shows \"P \\<tturnstile> wp (a ;; b) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tturnstile> wp (a ;; b) R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<tturnstile> wp (a ;; b) R", "note ha = well_def_wp_healthy[OF wa]"], ["proof (state)\nthis:\n  healthy (wp a)\n\ngoal (1 subgoal):\n 1. P \\<tturnstile> wp (a ;; b) R", "note hb = well_def_wp_healthy[OF wb]"], ["proof (state)\nthis:\n  healthy (wp b)\n\ngoal (1 subgoal):\n 1. P \\<tturnstile> wp (a ;; b) R", "note ent_a"], ["proof (state)\nthis:\n  P \\<tturnstile> wp a Q\n\ngoal (1 subgoal):\n 1. P \\<tturnstile> wp (a ;; b) R", "also"], ["proof (state)\nthis:\n  P \\<tturnstile> wp a Q\n\ngoal (1 subgoal):\n 1. P \\<tturnstile> wp (a ;; b) R", "from ent_b ha hb s_Q s_R"], ["proof (chain)\npicking this:\n  Q \\<tturnstile> wp b R\n  healthy (wp a)\n  healthy (wp b)\n  sound Q\n  sound R", "have \"wp a Q \\<tturnstile> wp a (wp b R)\""], ["proof (prove)\nusing this:\n  Q \\<tturnstile> wp b R\n  healthy (wp a)\n  healthy (wp b)\n  sound Q\n  sound R\n\ngoal (1 subgoal):\n 1. wp a Q \\<tturnstile> wp a (wp b R)", "by(blast intro:healthy_monoD2)"], ["proof (state)\nthis:\n  wp a Q \\<tturnstile> wp a (wp b R)\n\ngoal (1 subgoal):\n 1. P \\<tturnstile> wp (a ;; b) R", "finally"], ["proof (chain)\npicking this:\n  P \\<tturnstile> wp a (wp b R)", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<tturnstile> wp a (wp b R)\n\ngoal (1 subgoal):\n 1. P \\<tturnstile> wp (a ;; b) R", "by(simp add:wp_eval)"], ["proof (state)\nthis:\n  P \\<tturnstile> wp (a ;; b) R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wlp_Seq:\n  assumes ent_a: \"P \\<tturnstile> wlp a Q\"\n      and ent_b: \"Q \\<tturnstile> wlp b R\"\n      and wa:   \"well_def a\"\n      and wb:   \"well_def b\"\n      and u_Q:   \"unitary Q\"\n      and u_R:   \"unitary R\"\n  shows \"P \\<tturnstile> wlp (a ;; b) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tturnstile> wlp (a ;; b) R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<tturnstile> wlp (a ;; b) R", "note ha = well_def_wlp_nearly_healthy[OF wa]"], ["proof (state)\nthis:\n  nearly_healthy (wlp a)\n\ngoal (1 subgoal):\n 1. P \\<tturnstile> wlp (a ;; b) R", "note hb = well_def_wlp_nearly_healthy[OF wb]"], ["proof (state)\nthis:\n  nearly_healthy (wlp b)\n\ngoal (1 subgoal):\n 1. P \\<tturnstile> wlp (a ;; b) R", "note ent_a"], ["proof (state)\nthis:\n  P \\<tturnstile> wlp a Q\n\ngoal (1 subgoal):\n 1. P \\<tturnstile> wlp (a ;; b) R", "also"], ["proof (state)\nthis:\n  P \\<tturnstile> wlp a Q\n\ngoal (1 subgoal):\n 1. P \\<tturnstile> wlp (a ;; b) R", "from ent_b ha hb u_Q u_R"], ["proof (chain)\npicking this:\n  Q \\<tturnstile> wlp b R\n  nearly_healthy (wlp a)\n  nearly_healthy (wlp b)\n  unitary Q\n  unitary R", "have \"wlp a Q \\<tturnstile> wlp a (wlp b R)\""], ["proof (prove)\nusing this:\n  Q \\<tturnstile> wlp b R\n  nearly_healthy (wlp a)\n  nearly_healthy (wlp b)\n  unitary Q\n  unitary R\n\ngoal (1 subgoal):\n 1. wlp a Q \\<tturnstile> wlp a (wlp b R)", "by(blast intro:nearly_healthy_monoD[OF ha])"], ["proof (state)\nthis:\n  wlp a Q \\<tturnstile> wlp a (wlp b R)\n\ngoal (1 subgoal):\n 1. P \\<tturnstile> wlp (a ;; b) R", "finally"], ["proof (chain)\npicking this:\n  P \\<tturnstile> wlp a (wlp b R)", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<tturnstile> wlp a (wlp b R)\n\ngoal (1 subgoal):\n 1. P \\<tturnstile> wlp (a ;; b) R", "by(simp add:wp_eval)"], ["proof (state)\nthis:\n  P \\<tturnstile> wlp (a ;; b) R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wp_PC:\n  \"(\\<lambda>s. P s * wp a Q s + (1 - P s) * wp b Q s) \\<tturnstile> wp (a \\<^bsub>P\\<^esub>\\<oplus> b) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       P s * wp a Q s +\n       (1 - P s) *\n       wp b Q s \\<tturnstile> wp (a \\<^bsub>P\\<^esub>\\<oplus> b) Q", "by(simp add:wp_eval)"], ["", "lemma wlp_PC:\n  \"(\\<lambda>s. P s * wlp a Q s + (1 - P s) * wlp b Q s) \\<tturnstile> wlp (a \\<^bsub>P\\<^esub>\\<oplus> b) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       P s * wlp a Q s +\n       (1 - P s) *\n       wlp b Q s \\<tturnstile> wlp (a \\<^bsub>P\\<^esub>\\<oplus> b) Q", "by(simp add:wp_eval)"], ["", "text \\<open>A simpler rule for when the probability does not depend on the state.\\<close>"], ["", "lemma PC_fixed:\n  assumes wpa: \"P \\<tturnstile> a ab R\"\n      and wpb: \"Q \\<tturnstile> b ab R\"\n      and np: \"0 \\<le> p\" and bp: \"p \\<le> 1\"\n  shows \"(\\<lambda>s. p * P s + (1 - p) * Q s) \\<tturnstile> (a \\<^bsub>(\\<lambda>s. p)\\<^esub>\\<oplus> b) ab R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       p * P s +\n       (1 - p) *\n       Q s \\<tturnstile> (a \\<^bsub>(\\<lambda>s. p)\\<^esub>\\<oplus> b) ab R", "unfolding PC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       p * P s +\n       (1 - p) *\n       Q s \\<tturnstile> \\<lambda>s. p * a ab R s + (1 - p) * b ab R s", "proof(rule le_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. p * P x + (1 - p) * Q x \\<le> p * a ab R x + (1 - p) * b ab R x", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. p * P x + (1 - p) * Q x \\<le> p * a ab R x + (1 - p) * b ab R x", "from wpa and np"], ["proof (chain)\npicking this:\n  P \\<tturnstile> a ab R\n  0 \\<le> p", "have \"p * P s \\<le> p * a ab R s\""], ["proof (prove)\nusing this:\n  P \\<tturnstile> a ab R\n  0 \\<le> p\n\ngoal (1 subgoal):\n 1. p * P s \\<le> p * a ab R s", "by(auto intro:mult_left_mono)"], ["proof (state)\nthis:\n  p * P s \\<le> p * a ab R s\n\ngoal (1 subgoal):\n 1. \\<And>x. p * P x + (1 - p) * Q x \\<le> p * a ab R x + (1 - p) * b ab R x", "moreover"], ["proof (state)\nthis:\n  p * P s \\<le> p * a ab R s\n\ngoal (1 subgoal):\n 1. \\<And>x. p * P x + (1 - p) * Q x \\<le> p * a ab R x + (1 - p) * b ab R x", "{"], ["proof (state)\nthis:\n  p * P s \\<le> p * a ab R s\n\ngoal (1 subgoal):\n 1. \\<And>x. p * P x + (1 - p) * Q x \\<le> p * a ab R x + (1 - p) * b ab R x", "from bp"], ["proof (chain)\npicking this:\n  p \\<le> 1", "have \"0 \\<le> 1 - p\""], ["proof (prove)\nusing this:\n  p \\<le> 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> 1 - p", "by(simp)"], ["proof (state)\nthis:\n  0 \\<le> 1 - p\n\ngoal (1 subgoal):\n 1. \\<And>x. p * P x + (1 - p) * Q x \\<le> p * a ab R x + (1 - p) * b ab R x", "with wpb"], ["proof (chain)\npicking this:\n  Q \\<tturnstile> b ab R\n  0 \\<le> 1 - p", "have \"(1 - p) * Q s \\<le> (1 - p) * b ab R s\""], ["proof (prove)\nusing this:\n  Q \\<tturnstile> b ab R\n  0 \\<le> 1 - p\n\ngoal (1 subgoal):\n 1. (1 - p) * Q s \\<le> (1 - p) * b ab R s", "by(auto intro:mult_left_mono)"], ["proof (state)\nthis:\n  (1 - p) * Q s \\<le> (1 - p) * b ab R s\n\ngoal (1 subgoal):\n 1. \\<And>x. p * P x + (1 - p) * Q x \\<le> p * a ab R x + (1 - p) * b ab R x", "}"], ["proof (state)\nthis:\n  (1 - p) * Q s \\<le> (1 - p) * b ab R s\n\ngoal (1 subgoal):\n 1. \\<And>x. p * P x + (1 - p) * Q x \\<le> p * a ab R x + (1 - p) * b ab R x", "ultimately"], ["proof (chain)\npicking this:\n  p * P s \\<le> p * a ab R s\n  (1 - p) * Q s \\<le> (1 - p) * b ab R s", "show \"p * P s + (1 - p) * Q s \\<le>\n                   p * a ab R s + (1 - p) * b ab R s\""], ["proof (prove)\nusing this:\n  p * P s \\<le> p * a ab R s\n  (1 - p) * Q s \\<le> (1 - p) * b ab R s\n\ngoal (1 subgoal):\n 1. p * P s + (1 - p) * Q s \\<le> p * a ab R s + (1 - p) * b ab R s", "by(rule add_mono)"], ["proof (state)\nthis:\n  p * P s + (1 - p) * Q s \\<le> p * a ab R s + (1 - p) * b ab R s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wp_PC_fixed:\n  \"\\<lbrakk> P \\<tturnstile> wp a R; Q \\<tturnstile> wp b R; 0 \\<le> p; p \\<le> 1 \\<rbrakk> \\<Longrightarrow>\n  (\\<lambda>s. p * P s + (1 - p) * Q s) \\<tturnstile> wp (a \\<^bsub>(\\<lambda>s. p)\\<^esub>\\<oplus> b) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> wp a R; Q \\<tturnstile> wp b R; 0 \\<le> p;\n     p \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<lambda>s.\n                         p * P s +\n                         (1 - p) *\n                         Q s \\<tturnstile> wp\n      (a \\<^bsub>(\\<lambda>s. p)\\<^esub>\\<oplus> b) R", "by(simp add:wp_def PC_fixed)"], ["", "lemma wlp_PC_fixed:\n  \"\\<lbrakk> P \\<tturnstile> wlp a R; Q \\<tturnstile> wlp b R; 0 \\<le> p; p \\<le> 1 \\<rbrakk> \\<Longrightarrow>\n  (\\<lambda>s. p * P s + (1 - p) * Q s) \\<tturnstile> wlp (a \\<^bsub>(\\<lambda>s. p)\\<^esub>\\<oplus> b) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> wlp a R; Q \\<tturnstile> wlp b R; 0 \\<le> p;\n     p \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> \\<lambda>s.\n                         p * P s +\n                         (1 - p) *\n                         Q s \\<tturnstile> wlp\n      (a \\<^bsub>(\\<lambda>s. p)\\<^esub>\\<oplus> b) R", "by(simp add:wlp_def PC_fixed)"], ["", "lemma wp_DC:\n  \"(\\<lambda>s. min (wp a Q s) (wp b Q s)) \\<tturnstile> wp (a \\<Sqinter> b) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       min (wp a Q s) (wp b Q s) \\<tturnstile> wp (a \\<Sqinter> b) Q", "unfolding wp_eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       min (wp a Q s)\n        (wp b Q s) \\<tturnstile> \\<lambda>s. min (wp a Q s) (wp b Q s)", "by(simp)"], ["", "lemma wlp_DC:\n  \"(\\<lambda>s. min (wlp a Q s) (wlp b Q s)) \\<tturnstile> wlp (a \\<Sqinter> b) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       min (wlp a Q s) (wlp b Q s) \\<tturnstile> wlp (a \\<Sqinter> b) Q", "unfolding wp_eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       min (wlp a Q s)\n        (wlp b Q s) \\<tturnstile> \\<lambda>s. min (wlp a Q s) (wlp b Q s)", "by(simp)"], ["", "text \\<open>Combining annotations for both branches:\\<close>"], ["", "lemma DC_split:\n  fixes a::\"'s prog\" and b\n  assumes wpa: \"P \\<tturnstile> a ab R\"\n      and wpb: \"Q \\<tturnstile> b ab R\"\n  shows \"(\\<lambda>s. min (P s) (Q s)) \\<tturnstile> (a \\<Sqinter> b) ab R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s. min (P s) (Q s) \\<tturnstile> (a \\<Sqinter> b) ab R", "unfolding DC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       min (P s) (Q s) \\<tturnstile> \\<lambda>s. min (a ab R s) (b ab R s)", "proof(rule le_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. min (P x) (Q x) \\<le> min (a ab R x) (b ab R x)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. min (P x) (Q x) \\<le> min (a ab R x) (b ab R x)", "from wpa wpb"], ["proof (chain)\npicking this:\n  P \\<tturnstile> a ab R\n  Q \\<tturnstile> b ab R", "have \"P s \\<le> a ab R s\" and \"Q s \\<le> b ab R s\""], ["proof (prove)\nusing this:\n  P \\<tturnstile> a ab R\n  Q \\<tturnstile> b ab R\n\ngoal (1 subgoal):\n 1. P s \\<le> a ab R s &&& Q s \\<le> b ab R s", "by(auto)"], ["proof (state)\nthis:\n  P s \\<le> a ab R s\n  Q s \\<le> b ab R s\n\ngoal (1 subgoal):\n 1. \\<And>x. min (P x) (Q x) \\<le> min (a ab R x) (b ab R x)", "thus \"min (P s) (Q s) \\<le> min (a ab R s) (b ab R s)\""], ["proof (prove)\nusing this:\n  P s \\<le> a ab R s\n  Q s \\<le> b ab R s\n\ngoal (1 subgoal):\n 1. min (P s) (Q s) \\<le> min (a ab R s) (b ab R s)", "by(auto)"], ["proof (state)\nthis:\n  min (P s) (Q s) \\<le> min (a ab R s) (b ab R s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wp_DC_split:\n  \"\\<lbrakk> P \\<tturnstile> wp prog R; Q \\<tturnstile> wp prog' R \\<rbrakk> \\<Longrightarrow>\n  (\\<lambda>s. min (P s) (Q s)) \\<tturnstile> wp (prog \\<Sqinter> prog') R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> wp prog R; Q \\<tturnstile> wp prog' R\\<rbrakk>\n    \\<Longrightarrow> \\<lambda>s.\n                         min (P s)\n                          (Q s) \\<tturnstile> wp (prog \\<Sqinter> prog') R", "by(simp add:wp_def DC_split)"], ["", "lemma wlp_DC_split:\n  \"\\<lbrakk> P \\<tturnstile> wlp prog R; Q \\<tturnstile> wlp prog' R \\<rbrakk> \\<Longrightarrow>\n  (\\<lambda>s. min (P s) (Q s)) \\<tturnstile> wlp (prog \\<Sqinter> prog') R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> wlp prog R;\n     Q \\<tturnstile> wlp prog' R\\<rbrakk>\n    \\<Longrightarrow> \\<lambda>s.\n                         min (P s)\n                          (Q s) \\<tturnstile> wlp (prog \\<Sqinter> prog') R", "by(simp add:wlp_def DC_split)"], ["", "lemma wp_DC_split_same:\n  \"\\<lbrakk> P \\<tturnstile> wp prog Q; P \\<tturnstile> wp prog' Q \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> wp (prog \\<Sqinter> prog') Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> wp prog Q; P \\<tturnstile> wp prog' Q\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> wp (prog \\<Sqinter> prog') Q", "unfolding wp_eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> wp prog Q; P \\<tturnstile> wp prog' Q\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> \\<lambda>s.\n   min (wp prog Q s) (wp prog' Q s)", "by(blast intro:min.boundedI)"], ["", "lemma wlp_DC_split_same:\n  \"\\<lbrakk> P \\<tturnstile> wlp prog Q; P \\<tturnstile> wlp prog' Q \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> wlp (prog \\<Sqinter> prog') Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> wlp prog Q;\n     P \\<tturnstile> wlp prog' Q\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> wlp (prog \\<Sqinter> prog') Q", "unfolding wp_eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> wlp prog Q;\n     P \\<tturnstile> wlp prog' Q\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> \\<lambda>s.\n   min (wlp prog Q s) (wlp prog' Q s)", "by(blast intro:min.boundedI)"], ["", "lemma SetPC_split:\n  fixes f::\"'x \\<Rightarrow> 'y prog\"\n    and p::\"'y \\<Rightarrow> 'x \\<Rightarrow> real\"\n  assumes rec: \"\\<And>x s. x \\<in> supp (p s) \\<Longrightarrow> P x \\<tturnstile> f x ab Q\"\n      and nnp: \"\\<And>s. nneg (p s)\"\n  shows \"(\\<lambda>s. \\<Sum>x \\<in> supp (p s). p s x * P x s) \\<tturnstile> SetPC f p ab Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       \\<Sum>x\\<in>supp (p s). p s x * P x s \\<tturnstile> SetPC f p ab Q", "unfolding SetPC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       \\<Sum>x\\<in>supp (p s).\n         p s x *\n         P x s \\<tturnstile> \\<lambda>s.\n                                \\<Sum>a\\<in>supp (p s). p s a * f a ab Q s", "proof(rule le_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Sum>xa\\<in>supp (p x). p x xa * P xa x)\n       \\<le> (\\<Sum>a\\<in>supp (p x). p x a * f a ab Q x)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Sum>xa\\<in>supp (p x). p x xa * P xa x)\n       \\<le> (\\<Sum>a\\<in>supp (p x). p x a * f a ab Q x)", "from rec"], ["proof (chain)\npicking this:\n  ?x \\<in> supp (p ?s) \\<Longrightarrow> P ?x \\<tturnstile> f ?x ab Q", "have \"\\<And>x. x \\<in> supp (p s) \\<Longrightarrow> P x s \\<le> f x ab Q s\""], ["proof (prove)\nusing this:\n  ?x \\<in> supp (p ?s) \\<Longrightarrow> P ?x \\<tturnstile> f ?x ab Q\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> supp (p s) \\<Longrightarrow> P x s \\<le> f x ab Q s", "by(blast)"], ["proof (state)\nthis:\n  ?x \\<in> supp (p s) \\<Longrightarrow> P ?x s \\<le> f ?x ab Q s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Sum>xa\\<in>supp (p x). p x xa * P xa x)\n       \\<le> (\\<Sum>a\\<in>supp (p x). p x a * f a ab Q x)", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> supp (p s) \\<Longrightarrow> P ?x s \\<le> f ?x ab Q s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Sum>xa\\<in>supp (p x). p x xa * P xa x)\n       \\<le> (\\<Sum>a\\<in>supp (p x). p x a * f a ab Q x)", "from nnp"], ["proof (chain)\npicking this:\n  nneg (p ?s)", "have \"\\<And>x. 0 \\<le> p s x\""], ["proof (prove)\nusing this:\n  nneg (p ?s)\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 \\<le> p s x", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> p s ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Sum>xa\\<in>supp (p x). p x xa * P xa x)\n       \\<le> (\\<Sum>a\\<in>supp (p x). p x a * f a ab Q x)", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> supp (p s) \\<Longrightarrow> P ?x s \\<le> f ?x ab Q s\n  0 \\<le> p s ?x", "have \"\\<And>x. x \\<in> supp (p s) \\<Longrightarrow> p s x * P x s \\<le> p s x * f x ab Q s\""], ["proof (prove)\nusing this:\n  ?x \\<in> supp (p s) \\<Longrightarrow> P ?x s \\<le> f ?x ab Q s\n  0 \\<le> p s ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> supp (p s) \\<Longrightarrow>\n       p s x * P x s \\<le> p s x * f x ab Q s", "by(blast intro:mult_left_mono)"], ["proof (state)\nthis:\n  ?x \\<in> supp (p s) \\<Longrightarrow>\n  p s ?x * P ?x s \\<le> p s ?x * f ?x ab Q s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Sum>xa\\<in>supp (p x). p x xa * P xa x)\n       \\<le> (\\<Sum>a\\<in>supp (p x). p x a * f a ab Q x)", "thus \"(\\<Sum>x \\<in> supp (p s). p s x * P x s) \\<le> (\\<Sum>x \\<in> supp (p s). p s x * f x ab Q s)\""], ["proof (prove)\nusing this:\n  ?x \\<in> supp (p s) \\<Longrightarrow>\n  p s ?x * P ?x s \\<le> p s ?x * f ?x ab Q s\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>supp (p s). p s x * P x s)\n    \\<le> (\\<Sum>x\\<in>supp (p s). p s x * f x ab Q s)", "by(rule sum_mono)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>supp (p s). p s x * P x s)\n  \\<le> (\\<Sum>x\\<in>supp (p s). p s x * f x ab Q s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wp_SetPC_split:\n  \"\\<lbrakk> \\<And>x s. x \\<in> supp (p s) \\<Longrightarrow> P x \\<tturnstile> wp (f x) Q; \\<And>s. nneg (p s) \\<rbrakk> \\<Longrightarrow>\n   (\\<lambda>s. \\<Sum>x \\<in> supp (p s). p s x * P x s) \\<tturnstile> wp (SetPC f p) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x s.\n                x \\<in> supp (p s) \\<Longrightarrow>\n                P x \\<tturnstile> wp (f x) Q;\n     \\<And>s. nneg (p s)\\<rbrakk>\n    \\<Longrightarrow> \\<lambda>s.\n                         \\<Sum>x\\<in>supp (p s).\n                           p s x * P x s \\<tturnstile> wp (SetPC f p) Q", "by(simp add:wp_def SetPC_split)"], ["", "lemma wlp_SetPC_split:\n  \"\\<lbrakk> \\<And>x s. x \\<in> supp (p s) \\<Longrightarrow> P x \\<tturnstile> wlp (f x) Q; \\<And>s. nneg (p s) \\<rbrakk> \\<Longrightarrow>\n   (\\<lambda>s. \\<Sum>x \\<in> supp (p s). p s x * P x s) \\<tturnstile> wlp (SetPC f p) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x s.\n                x \\<in> supp (p s) \\<Longrightarrow>\n                P x \\<tturnstile> wlp (f x) Q;\n     \\<And>s. nneg (p s)\\<rbrakk>\n    \\<Longrightarrow> \\<lambda>s.\n                         \\<Sum>x\\<in>supp (p s).\n                           p s x * P x s \\<tturnstile> wlp (SetPC f p) Q", "by(simp add:wlp_def SetPC_split)"], ["", "lemma wp_SetDC_split:\n  \"\\<lbrakk> \\<And>s x. x \\<in> S s \\<Longrightarrow> P \\<tturnstile> wp (f x) Q; \\<And>s. S s \\<noteq> {} \\<rbrakk> \\<Longrightarrow>\n   P \\<tturnstile> wp (SetDC f S) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s x.\n                x \\<in> S s \\<Longrightarrow> P \\<tturnstile> wp (f x) Q;\n     \\<And>s. S s \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> wp (SetDC f S) Q", "by(rule le_funI, unfold wp_eval, blast intro!:cInf_greatest)"], ["", "lemma wlp_SetDC_split:\n  \"\\<lbrakk> \\<And>s x. x \\<in> S s \\<Longrightarrow> P \\<tturnstile> wlp (f x) Q; \\<And>s. S s \\<noteq> {} \\<rbrakk> \\<Longrightarrow>\n   P \\<tturnstile> wlp (SetDC f S) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s x.\n                x \\<in> S s \\<Longrightarrow> P \\<tturnstile> wlp (f x) Q;\n     \\<And>s. S s \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> wlp (SetDC f S) Q", "by(rule le_funI, unfold wp_eval, blast intro!:cInf_greatest)"], ["", "lemma wp_SetDC:\n  assumes wp: \"\\<And>s x. x \\<in> S s \\<Longrightarrow> P x \\<tturnstile> wp (f x) Q\"\n      and ne: \"\\<And>s. S s \\<noteq> {}\"\n      and sP: \"\\<And>x. sound (P x)\"\n  shows \"(\\<lambda>s. Inf ((\\<lambda>x. P x s) ` S s)) \\<tturnstile> wp (SetDC f S) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s. INF x\\<in>S s. P x s \\<tturnstile> wp (SetDC f S) Q", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> S ?s \\<Longrightarrow> P ?x \\<tturnstile> wp (f ?x) Q\n  S ?s \\<noteq> {}\n  sound (P ?x)\n\ngoal (1 subgoal):\n 1. \\<lambda>s. INF x\\<in>S s. P x s \\<tturnstile> wp (SetDC f S) Q", "by(intro le_funI, simp add:wp_eval, blast intro!:cInf_mono)"], ["", "lemma wlp_SetDC:\n  assumes wp: \"\\<And>s x. x \\<in> S s \\<Longrightarrow> P x \\<tturnstile> wlp (f x) Q\"\n      and ne: \"\\<And>s. S s \\<noteq> {}\"\n      and sP: \"\\<And>x. sound (P x)\"\n  shows \"(\\<lambda>s. Inf ((\\<lambda>x. P x s) ` S s)) \\<tturnstile> wlp (SetDC f S) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s. INF x\\<in>S s. P x s \\<tturnstile> wlp (SetDC f S) Q", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> S ?s \\<Longrightarrow> P ?x \\<tturnstile> wlp (f ?x) Q\n  S ?s \\<noteq> {}\n  sound (P ?x)\n\ngoal (1 subgoal):\n 1. \\<lambda>s. INF x\\<in>S s. P x s \\<tturnstile> wlp (SetDC f S) Q", "by(intro le_funI, simp add:wp_eval, blast intro!:cInf_mono)"], ["", "lemma wp_Embed:\n  \"P \\<tturnstile> t Q \\<Longrightarrow> P \\<tturnstile> wp (Embed t) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tturnstile> t Q \\<Longrightarrow> P \\<tturnstile> wp (Embed t) Q", "by(simp add:wp_def Embed_def)"], ["", "lemma wlp_Embed:\n  \"P \\<tturnstile> t Q \\<Longrightarrow> P \\<tturnstile> wlp (Embed t) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tturnstile> t Q \\<Longrightarrow> P \\<tturnstile> wlp (Embed t) Q", "by(simp add:wlp_def Embed_def)"], ["", "lemma wp_Bind:\n  \"\\<lbrakk> \\<And>s. P s \\<le> wp (a (f s)) Q s \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> wp (Bind f a) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. P s \\<le> wp (a (f s)) Q s) \\<Longrightarrow>\n    P \\<tturnstile> wp (Bind f a) Q", "by(auto simp:wp_def Bind_def)"], ["", "lemma wlp_Bind:\n  \"\\<lbrakk> \\<And>s. P s \\<le> wlp (a (f s)) Q s \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> wlp (Bind f a) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. P s \\<le> wlp (a (f s)) Q s) \\<Longrightarrow>\n    P \\<tturnstile> wlp (Bind f a) Q", "by(auto simp:wlp_def Bind_def)"], ["", "lemma wp_repeat:\n  \"\\<lbrakk> P \\<tturnstile> wp a Q; Q \\<tturnstile> wp (repeat n a) R;\n     well_def a; sound Q; sound R \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> wp (repeat (Suc n) a) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> wp a Q; Q \\<tturnstile> wp (repeat n a) R;\n     well_def a; sound Q; sound R\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> wp (repeat (Suc n) a) R", "by(auto intro!:wp_Seq wd_intros)"], ["", "lemma wlp_repeat:\n  \"\\<lbrakk> P \\<tturnstile> wlp a Q; Q \\<tturnstile> wlp (repeat n a) R;\n     well_def a; unitary Q; unitary R \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> wlp (repeat (Suc n) a) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> wlp a Q; Q \\<tturnstile> wlp (repeat n a) R;\n     well_def a; unitary Q; unitary R\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> wlp (repeat (Suc n) a) R", "by(auto intro!:wlp_Seq wd_intros)"], ["", "text \\<open>Note that the loop rules presented in section \\autoref{s:loop_rules} are of the same form,\nand would belong here, had they not already been stated.\\<close>"], ["", "text \\<open>The following rules are specialisations of those for general\n  transformers, and are easier for the unifier to match.\\<close>"], ["", "lemmas wp_strengthen_post=\n  entails_strengthen_post[where t=\"wp a\" for a]"], ["", "lemma wlp_strengthen_post:\n  \"P \\<tturnstile> wlp a Q \\<Longrightarrow> nearly_healthy (wlp a) \\<Longrightarrow> unitary R \\<Longrightarrow> Q \\<tturnstile> R \\<Longrightarrow> unitary Q \\<Longrightarrow>\n   P \\<tturnstile> wlp a R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> wlp a Q; nearly_healthy (wlp a); unitary R;\n     Q \\<tturnstile> R; unitary Q\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> wlp a R", "by(blast intro:entails_trans)"], ["", "lemmas wp_weaken_pre=\n  entails_weaken_pre[where t=\"wp a\" for a]"], ["", "lemmas wlp_weaken_pre=\n  entails_weaken_pre[where t=\"wlp a\" for a]"], ["", "lemmas wp_scale=\n  entails_scale[where t=\"wp a\" for a, OF _ well_def_wp_healthy]"], ["", "subsection \\<open>Algebraic Decomposition\\<close>"], ["", "text \\<open>Refinement is a powerful tool for decomposition, belied by the simplicity of the rule.\nThis is an \\emph{axiomatic} formulation of refinement (all annotations of the @{term a}\nare annotations of @{term b}), rather than an operational version (all traces of @{term b} are\ntraces of @{term a}.\\<close>"], ["", "lemma wp_refines:\n  \"\\<lbrakk> a \\<sqsubseteq> b; P \\<tturnstile> wp a Q; sound Q \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> wp b Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<sqsubseteq> b; P \\<tturnstile> wp a Q; sound Q\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> wp b Q", "by(auto intro:entails_trans)"], ["", "lemmas wp_drefines = drefinesD"], ["", "subsection \\<open>Hoare triples\\<close>"], ["", "text \\<open>The Hoare triple, or validity predicate, is logically equivalent to the weakest-precondition\nentailment form. The benefit is that it allows us to define transitivity rules for computational\n(also/finally) reasoning.\\<close>"], ["", "definition\n  wp_valid :: \"('a \\<Rightarrow> real) \\<Rightarrow> 'a prog \\<Rightarrow> ('a \\<Rightarrow> real) \\<Rightarrow> bool\" (\"\\<lbrace>_\\<rbrace> _ \\<lbrace>_\\<rbrace>p\")\nwhere\n  \"wp_valid P prog Q \\<equiv> P \\<tturnstile> wp prog Q\""], ["", "lemma wp_validI:\n  \"P \\<tturnstile> wp prog Q \\<Longrightarrow> \\<lbrace>P\\<rbrace> prog \\<lbrace>Q\\<rbrace>p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tturnstile> wp prog Q \\<Longrightarrow>\n    \\<lbrace>P\\<rbrace> prog \\<lbrace>Q\\<rbrace>p", "unfolding wp_valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tturnstile> wp prog Q \\<Longrightarrow> P \\<tturnstile> wp prog Q", "by(assumption)"], ["", "lemma wp_validD:\n  \"\\<lbrace>P\\<rbrace> prog \\<lbrace>Q\\<rbrace>p \\<Longrightarrow> P \\<tturnstile> wp prog Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>P\\<rbrace> prog \\<lbrace>Q\\<rbrace>p \\<Longrightarrow>\n    P \\<tturnstile> wp prog Q", "unfolding wp_valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tturnstile> wp prog Q \\<Longrightarrow> P \\<tturnstile> wp prog Q", "by(assumption)"], ["", "lemma valid_Seq:\n  \"\\<lbrakk> \\<lbrace>P\\<rbrace> a \\<lbrace>Q\\<rbrace>p; \\<lbrace>Q\\<rbrace> b \\<lbrace>R\\<rbrace>p; well_def a; well_def b; sound Q; sound R \\<rbrakk> \\<Longrightarrow>\n  \\<lbrace>P\\<rbrace> a ;; b \\<lbrace>R\\<rbrace>p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrace>P\\<rbrace> a \\<lbrace>Q\\<rbrace>p;\n     \\<lbrace>Q\\<rbrace> b \\<lbrace>R\\<rbrace>p; well_def a; well_def b;\n     sound Q; sound R\\<rbrakk>\n    \\<Longrightarrow> \\<lbrace>P\\<rbrace> a ;; b \\<lbrace>R\\<rbrace>p", "unfolding wp_valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> wp a Q; Q \\<tturnstile> wp b R; well_def a;\n     well_def b; sound Q; sound R\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> wp (a ;; b) R", "by(rule wp_Seq)"], ["", "text \\<open>We make it available to the computational reasoner:\\<close>"], ["", "declare valid_Seq[trans]"], ["", "end"]]}