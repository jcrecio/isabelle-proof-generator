{"file_name": "/home/qj213/afp-2021-10-22/thys/pGCL/Transformers.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/pGCL", "problem_names": ["lemma le_transI[intro]:\n  \"\\<lbrakk> \\<And>P. sound P \\<Longrightarrow> t P \\<le> u P \\<rbrakk> \\<Longrightarrow> le_trans t u\"", "lemma le_utransI[intro]:\n  \"\\<lbrakk> \\<And>P. unitary P \\<Longrightarrow> t P \\<le> u P \\<rbrakk> \\<Longrightarrow> le_utrans t u\"", "lemma  le_transD[dest]:\n  \"\\<lbrakk> le_trans t u; sound P \\<rbrakk> \\<Longrightarrow> t P \\<le> u P\"", "lemma le_utransD[dest]:\n  \"\\<lbrakk> le_utrans t u; unitary P \\<rbrakk> \\<Longrightarrow> t P \\<le> u P\"", "lemma le_trans_trans[trans]:\n  \"\\<lbrakk> le_trans x y; le_trans y z \\<rbrakk> \\<Longrightarrow> le_trans x z\"", "lemma le_utrans_trans[trans]:\n  \"\\<lbrakk> le_utrans x y; le_utrans y z \\<rbrakk> \\<Longrightarrow> le_utrans x z\"", "lemma le_trans_refl[iff]:\n  \"le_trans x x\"", "lemma le_utrans_refl[iff]:\n  \"le_utrans x x\"", "lemma le_trans_le_utrans[dest]:\n  \"le_trans t u \\<Longrightarrow> le_utrans t u\"", "lemma equiv_transI[intro]:\n  \"\\<lbrakk> \\<And>P. sound P \\<Longrightarrow> t P = u P \\<rbrakk> \\<Longrightarrow> equiv_trans t u\"", "lemma equiv_utransI[intro]:\n  \"\\<lbrakk> \\<And>P. sound P \\<Longrightarrow> t P = u P \\<rbrakk> \\<Longrightarrow> equiv_utrans t u\"", "lemma equiv_transD[dest]:\n  \"\\<lbrakk> equiv_trans t u; sound P \\<rbrakk> \\<Longrightarrow> t P = u P\"", "lemma equiv_utransD[dest]:\n  \"\\<lbrakk> equiv_utrans t u; unitary P \\<rbrakk> \\<Longrightarrow> t P = u P\"", "lemma equiv_trans_refl[iff]:\n  \"equiv_trans t t\"", "lemma equiv_utrans_refl[iff]:\n  \"equiv_utrans t t\"", "lemma le_trans_antisym:\n  \"\\<lbrakk> le_trans x y; le_trans y x \\<rbrakk> \\<Longrightarrow> equiv_trans x y\"", "lemma le_utrans_antisym:\n  \"\\<lbrakk> le_utrans x y; le_utrans y x \\<rbrakk> \\<Longrightarrow> equiv_utrans x y\"", "lemma equiv_trans_comm[ac_simps]:\n  \"equiv_trans t u \\<longleftrightarrow> equiv_trans u t\"", "lemma equiv_utrans_comm[ac_simps]:\n  \"equiv_utrans t u \\<longleftrightarrow> equiv_utrans u t\"", "lemma equiv_imp_le[intro]:\n  \"equiv_trans t u \\<Longrightarrow> le_trans t u\"", "lemma equivu_imp_le[intro]:\n  \"equiv_utrans t u \\<Longrightarrow> le_utrans t u\"", "lemma equiv_imp_le_alt:\n  \"equiv_trans t u \\<Longrightarrow> le_trans u t\"", "lemma equiv_uimp_le_alt:\n  \"equiv_utrans t u \\<Longrightarrow> le_utrans u t\"", "lemma le_trans_equiv_rsp[simp]:\n  \"equiv_trans t u \\<Longrightarrow> le_trans t v \\<longleftrightarrow> le_trans u v\"", "lemma le_utrans_equiv_rsp[simp]:\n  \"equiv_utrans t u \\<Longrightarrow> le_utrans t v \\<longleftrightarrow> le_utrans u v\"", "lemma equiv_trans_le_trans[trans]:\n  \"\\<lbrakk> equiv_trans t u; le_trans u v \\<rbrakk> \\<Longrightarrow> le_trans t v\"", "lemma equiv_utrans_le_utrans[trans]:\n  \"\\<lbrakk> equiv_utrans t u; le_utrans u v \\<rbrakk> \\<Longrightarrow> le_utrans t v\"", "lemma le_trans_equiv_rsp_right[simp]:\n  \"equiv_trans t u \\<Longrightarrow> le_trans v t \\<longleftrightarrow> le_trans v u\"", "lemma le_utrans_equiv_rsp_right[simp]:\n  \"equiv_utrans t u \\<Longrightarrow> le_utrans v t \\<longleftrightarrow> le_utrans v u\"", "lemma le_trans_equiv_trans[trans]:\n  \"\\<lbrakk> le_trans t u; equiv_trans u v \\<rbrakk> \\<Longrightarrow> le_trans t v\"", "lemma le_utrans_equiv_utrans[trans]:\n  \"\\<lbrakk> le_utrans t u; equiv_utrans u v \\<rbrakk> \\<Longrightarrow> le_utrans t v\"", "lemma equiv_trans_trans[trans]:\n  assumes xy: \"equiv_trans x y\"\n      and yz: \"equiv_trans y z\"\n  shows \"equiv_trans x z\"", "lemma equiv_utrans_trans[trans]:\n  assumes xy: \"equiv_utrans x y\"\n      and yz: \"equiv_utrans y z\"\n  shows \"equiv_utrans x z\"", "lemma equiv_trans_equiv_utrans[dest]:\n  \"equiv_trans t u \\<Longrightarrow> equiv_utrans t u\"", "lemma feasibleI[intro]:\n  \"\\<lbrakk> \\<And>b P. \\<lbrakk> bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> bounded_by b (t P);\n     \\<And>b P. \\<lbrakk> bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> nneg (t P) \\<rbrakk> \\<Longrightarrow> feasible t\"", "lemma feasible_boundedD[dest]:\n  \"\\<lbrakk> feasible t; bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> bounded_by b (t P)\"", "lemma feasible_nnegD[dest]:\n  \"\\<lbrakk> feasible t; bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> nneg (t P)\"", "lemma feasible_sound[dest]:\n  \"\\<lbrakk> feasible t; sound P \\<rbrakk> \\<Longrightarrow> sound (t P)\"", "lemma feasible_pr_0[simp]:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes ft: \"feasible t\"\n  shows \"t (\\<lambda>x. 0) = (\\<lambda>x. 0)\"", "lemma feasible_id:\n  \"feasible (\\<lambda>x. x)\"", "lemma feasible_bounded_by[dest]:\n  \"\\<lbrakk> feasible t; sound P; bounded_by b P \\<rbrakk> \\<Longrightarrow> bounded_by b (t P)\"", "lemma feasible_fixes_top:\n  \"feasible t \\<Longrightarrow> t (\\<lambda>s. 1) \\<le> (\\<lambda>s. (1::real))\"", "lemma feasible_fixes_bot:\n  assumes ft: \"feasible t\"\n  shows \"t (\\<lambda>s. 0) = (\\<lambda>s. 0)\"", "lemma feasible_unitaryD[dest]:\n  assumes ft: \"feasible t\" and uP: \"unitary P\"\n  shows \"unitary (t P)\"", "lemma mono_transI[intro]:\n  \"\\<lbrakk> \\<And>P Q. \\<lbrakk> sound P; sound Q; P \\<le> Q \\<rbrakk> \\<Longrightarrow>  t P \\<le> t Q \\<rbrakk> \\<Longrightarrow> mono_trans t\"", "lemma mono_transD[dest]:\n  \"\\<lbrakk> mono_trans t; sound P; sound Q; P \\<le> Q \\<rbrakk> \\<Longrightarrow> t P \\<le> t Q\"", "lemma scalingI[intro]:\n  \"\\<lbrakk> \\<And>P c x. \\<lbrakk> sound P; 0 \\<le> c \\<rbrakk> \\<Longrightarrow> c * t P x = t (\\<lambda>x. c * P x) x \\<rbrakk> \\<Longrightarrow> scaling t\"", "lemma scalingD[dest]:\n  \"\\<lbrakk> scaling t; sound P; 0 \\<le> c \\<rbrakk>  \\<Longrightarrow> c * t P x = t (\\<lambda>x. c * P x) x\"", "lemma right_scalingD:\n  assumes st: \"scaling t\"\n      and sP: \"sound P\"\n      and nnc: \"0 \\<le> c\"\n  shows \"t P s * c = t (\\<lambda>s. P s * c) s\"", "lemma healthyI[intro]:\n  \"\\<lbrakk> feasible t; mono_trans t; scaling t \\<rbrakk> \\<Longrightarrow> healthy t\"", "lemmas healthy_parts = healthyI[OF feasibleI mono_transI scalingI]", "lemma healthy_monoD[dest]:\n  \"healthy t \\<Longrightarrow> mono_trans t\"", "lemmas healthy_monoD2 = mono_transD[OF healthy_monoD]", "lemma healthy_feasibleD[dest]:\n  \"healthy t \\<Longrightarrow> feasible t\"", "lemma healthy_scalingD[dest]:\n  \"healthy t \\<Longrightarrow> scaling t\"", "lemma healthy_bounded_byD[intro]:\n  \"\\<lbrakk> healthy t; bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> bounded_by b (t P)\"", "lemma healthy_bounded_byD2:\n  \"\\<lbrakk> healthy t; bounded_by b P; sound P \\<rbrakk> \\<Longrightarrow> bounded_by b (t P)\"", "lemma healthy_boundedD[dest,simp]:\n  \"\\<lbrakk> healthy t; sound P \\<rbrakk> \\<Longrightarrow> bounded (t P)\"", "lemma healthy_nnegD[dest,simp]:\n  \"\\<lbrakk> healthy t; sound P \\<rbrakk> \\<Longrightarrow> nneg (t P)\"", "lemma healthy_nnegD2[dest,simp]:\n  \"\\<lbrakk> healthy t; bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> nneg (t P)\"", "lemma healthy_sound[intro]:\n  \"\\<lbrakk> healthy t; sound P \\<rbrakk> \\<Longrightarrow> sound (t P)\"", "lemma healthy_unitary[intro]:\n  \"\\<lbrakk> healthy t; unitary P \\<rbrakk> \\<Longrightarrow> unitary (t P)\"", "lemma healthy_id[simp,intro!]:\n  \"healthy id\"", "lemmas healthy_fixes_bot = feasible_fixes_bot[OF healthy_feasibleD]", "lemma le_trans_bot[intro,simp]:\n  \"healthy t \\<Longrightarrow> le_trans (\\<lambda>P s. 0) t\"", "lemma le_trans_top[intro,simp]:\n  \"healthy t \\<Longrightarrow> le_trans t (\\<lambda>P s. bound_of P)\"", "lemma healthy_pr_bot[simp]:\n  \"healthy t \\<Longrightarrow> t (\\<lambda>s. 0) = (\\<lambda>s. 0)\"", "lemma healthy_equivI:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\" and u\n  assumes equiv:   \"equiv_trans t u\"\n      and healthy: \"healthy t\"\n  shows \"healthy u\"", "lemma healthy_equiv:\n  \"equiv_trans t u \\<Longrightarrow> healthy t \\<longleftrightarrow> healthy u\"", "lemma healthy_scale:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes ht: \"healthy t\" and nc: \"0 \\<le> c\" and bc: \"c \\<le> 1\"\n  shows \"healthy (\\<lambda>P s. c * t P s)\"", "lemma healthy_top[iff]:\n  \"healthy (\\<lambda>P s. bound_of P)\"", "lemma healthy_bot[iff]:\n  \"healthy (\\<lambda>P s. 0)\"", "lemma nearly_healthyI[intro]:\n  \"\\<lbrakk> \\<And>P. unitary P \\<Longrightarrow> unitary (t P);\n     \\<And>P Q. \\<lbrakk> unitary P; unitary Q; P \\<tturnstile> Q \\<rbrakk> \\<Longrightarrow> t P \\<tturnstile> t Q \\<rbrakk> \\<Longrightarrow> nearly_healthy t\"", "lemma nearly_healthy_monoD[dest]:\n  \"\\<lbrakk> nearly_healthy t; P \\<tturnstile> Q; unitary P; unitary Q \\<rbrakk> \\<Longrightarrow> t P \\<tturnstile> t Q\"", "lemma nearly_healthy_unitaryD[dest]:\n  \"\\<lbrakk> nearly_healthy t; unitary P \\<rbrakk> \\<Longrightarrow> unitary (t P)\"", "lemma healthy_nearly_healthy[dest]:\n  assumes ht: \"healthy t\"\n  shows \"nearly_healthy t\"", "lemmas nearly_healthy_id[iff] =\n  healthy_nearly_healthy[OF healthy_id, unfolded id_def]", "lemma sublinearI[intro]:\n  \"\\<lbrakk> \\<And>a b c P Q s. \\<lbrakk> sound P; sound Q; 0 \\<le> a; 0 \\<le> b; 0 \\<le> c \\<rbrakk> \\<Longrightarrow>\n     a * t P s + b * t Q s \\<ominus> c \\<le>\n     t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s \\<rbrakk> \\<Longrightarrow> sublinear t\"", "lemma sublinearD[dest]:\n  \"\\<lbrakk> sublinear t; sound P; sound Q; 0 \\<le> a; 0 \\<le> b; 0 \\<le> c \\<rbrakk> \\<Longrightarrow>\n   a * t P s + b * t Q s \\<ominus> c \\<le>\n   t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s\"", "lemma sub_addI[intro]:\n  \"\\<lbrakk> \\<And>P Q s. \\<lbrakk> sound P; sound Q \\<rbrakk> \\<Longrightarrow>\n             t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s \\<rbrakk> \\<Longrightarrow> sub_add t\"", "lemma sub_addI2:\n  \"\\<lbrakk>\\<And>P Q. \\<lbrakk> sound P; sound Q \\<rbrakk> \\<Longrightarrow>\n          \\<lambda>s. t P s + t Q s \\<tturnstile> t (\\<lambda>s. P s + Q s)\\<rbrakk> \\<Longrightarrow>\n   sub_add t\"", "lemma sub_addD[dest]:\n  \"\\<lbrakk> sub_add t; sound P; sound Q \\<rbrakk> \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s\"", "lemma equiv_sub_add:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes eq: \"equiv_trans t u\"\n      and sa: \"sub_add t\"\n  shows \"sub_add u\"", "lemma sublinear_subadd:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes slt: \"sublinear t\"\n      and ft:  \"feasible t\"\n  shows \"sub_add t\"", "lemma standard_negate:\n  assumes ht: \"healthy t\"\n      and sat: \"sub_add t\"\n  shows \"t \\<guillemotleft>P\\<guillemotright> s + t \\<guillemotleft>\\<N> P\\<guillemotright> s \\<le> 1\"", "lemma sub_add_sum:\n  fixes t::\"'s trans\" and S::\"'a set\"\n  assumes sat: \"sub_add t\"\n      and ht: \"healthy t\"\n      and sP: \"\\<And>x. sound (P x)\"\n  shows \"(\\<lambda>x. \\<Sum>y\\<in>S. t (P y) x) \\<le> t (\\<lambda>x. \\<Sum>y\\<in>S. P y x)\"", "lemma sub_add_guard_split:\n  fixes t::\"'s::finite trans\" and P::\"'s expect\" and s::'s\n  assumes sat: \"sub_add t\"\n      and ht: \"healthy t\"\n      and sP: \"sound P\"\n  shows \"(\\<Sum>y\\<in>{s. G s}.  P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n         (\\<Sum>y\\<in>{s. \\<not>G s}. P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) \\<le> t P s\"", "lemma sub_distribI[intro]:\n  \"\\<lbrakk> \\<And>P s. sound P \\<Longrightarrow> t P s \\<ominus> 1 \\<le> t (\\<lambda>s'. P s' \\<ominus> 1) s \\<rbrakk> \\<Longrightarrow> sub_distrib t\"", "lemma sub_distribI2:\n  \"\\<lbrakk> \\<And>P. sound P \\<Longrightarrow> \\<lambda>s. t P s \\<ominus> 1 \\<tturnstile> t (\\<lambda>s. P s \\<ominus> 1) \\<rbrakk> \\<Longrightarrow> sub_distrib t\"", "lemma sub_distribD[dest]:\n  \"\\<lbrakk> sub_distrib t; sound P \\<rbrakk> \\<Longrightarrow> t P s \\<ominus> 1 \\<le> t (\\<lambda>s'. P s' \\<ominus> 1) s\"", "lemma equiv_sub_distrib:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes eq: \"equiv_trans t u\"\n      and sd: \"sub_distrib t\"\n  shows \"sub_distrib u\"", "lemma sublinear_sub_distrib:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes slt: \"sublinear t\"\n  shows \"sub_distrib t\"", "lemma sd_sa_sublinear:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes sdt: \"sub_distrib t\" and sat: \"sub_add t\" and ht: \"healthy t\"\n  shows \"sublinear t\"", "lemma sub_conjI[intro]:\n  \"\\<lbrakk> \\<And>P Q. \\<lbrakk> sound P; sound Q \\<rbrakk> \\<Longrightarrow>\n           t P && t Q \\<tturnstile> t (P && Q) \\<rbrakk> \\<Longrightarrow> sub_conj t\"", "lemma sub_conjD[dest]:\n  \"\\<lbrakk> sub_conj t; sound P; sound Q \\<rbrakk> \\<Longrightarrow> t P && t Q \\<tturnstile> t (P && Q)\"", "lemma sub_conj_wp_twice:\n  fixes f::\"'s \\<Rightarrow> (('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real)\"\n  assumes all: \"\\<forall>s. sub_conj (f s)\"\n  shows \"sub_conj (\\<lambda>P s. f s P s)\"", "lemma sublinear_sub_conj:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes slt: \"sublinear t\"\n  shows \"sub_conj t\"", "lemma equiv_sublinear:\n  \"\\<lbrakk> equiv_trans t u; sublinear t; healthy t \\<rbrakk> \\<Longrightarrow> sublinear u\"", "lemma additiveD:\n  \"\\<lbrakk> additive t; sound P; sound Q \\<rbrakk> \\<Longrightarrow> t (\\<lambda>s. P s + Q s) = (\\<lambda>s. t P s + t Q s)\"", "lemma additiveI[intro]:\n  \"\\<lbrakk> \\<And>P Q s. \\<lbrakk> sound P; sound Q \\<rbrakk> \\<Longrightarrow> t (\\<lambda>s. P s + Q s) s = t P s + t Q s \\<rbrakk> \\<Longrightarrow>\n   additive t\"", "lemma additive_sub_add:\n  \"additive t \\<Longrightarrow> sub_add t\"", "lemma additive_sum:\n  fixes S::\"'s set\"\n  assumes additive: \"additive t\"\n      and healthy:  \"healthy t\"\n      and finite:   \"finite S\"\n      and sPz:      \"\\<And>z. sound (P z)\"\n  shows \"t (\\<lambda>x. \\<Sum>y\\<in>S. P y x) = (\\<lambda>x. \\<Sum>y\\<in>S. t (P y) x)\"", "lemma additive_delta_split:\n  fixes t::\"('s::finite \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes additive: \"additive t\"\n      and ht: \"healthy t\"\n      and sP: \"sound P\"\n  shows \"t P x = (\\<Sum>y\\<in>UNIV. P y * t \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x)\"", "lemma additive_guard_split:\n  fixes t::\"('s::finite \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes additive: \"additive t\"\n      and ht: \"healthy t\"\n      and sP: \"sound P\"\n  shows \"t P x = (\\<Sum>y\\<in>{s.   G s}. P y * t \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) +\n                 (\\<Sum>y\\<in>{s. \\<not> G s}. P y * t \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x)\"", "lemma maximalI[intro]:\n  \"\\<lbrakk> \\<And>c. 0 \\<le> c \\<Longrightarrow> t (\\<lambda>_. c) = (\\<lambda>_. c) \\<rbrakk> \\<Longrightarrow> maximal t\"", "lemma maximalD[dest]:\n  \"\\<lbrakk> maximal t; 0 \\<le> c \\<rbrakk>  \\<Longrightarrow> t (\\<lambda>_. c) = (\\<lambda>_. c)\"", "lemma determI[intro]:\n  \"\\<lbrakk> additive t; maximal t \\<rbrakk> \\<Longrightarrow> determ t\"", "lemma determ_additiveD[intro]:\n  \"determ t \\<Longrightarrow> additive t\"", "lemma determ_maximalD[intro]:\n  \"determ t \\<Longrightarrow> maximal t\"", "lemma determ_negate:\n  assumes determ:  \"determ t\"\n  shows \"t \\<guillemotleft>P\\<guillemotright> s + t \\<guillemotleft>\\<N> P\\<guillemotright> s = 1\"", "lemma entails_combine:\n  assumes wp1: \"P \\<tturnstile> t R\"\n      and wp2: \"Q \\<tturnstile> t S\"\n      and sc:  \"sub_conj t\"\n      and sR:  \"sound R\"\n      and sS:  \"sound S\"\n  shows \"P && Q \\<tturnstile> t (R && S)\"", "lemma entails_strengthen_post:\n  \"\\<lbrakk> P \\<tturnstile> t Q; healthy t; sound R; Q \\<tturnstile> R; sound Q \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> t R\"", "lemma entails_weaken_pre:\n  \"\\<lbrakk> Q \\<tturnstile> t R; P \\<tturnstile> Q \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> t R\"", "lemma entails_scale:\n  assumes wp: \"P \\<tturnstile> t Q\" and h: \"healthy t\"\n      and sQ: \"sound Q\" and pos: \"0 \\<le> c\"\n  shows \"(\\<lambda>s. c * P s) \\<tturnstile> t (\\<lambda>s. c * Q s)\"", "lemma use_premise:\n  assumes h: \"healthy t\" and wP: \"\\<And>s. P s \\<Longrightarrow> 1 \\<le> t \\<guillemotleft>Q\\<guillemotright> s\"\n  shows \"\\<guillemotleft>P\\<guillemotright> \\<tturnstile> t \\<guillemotleft>Q\\<guillemotright>\"", "lemma fold_premise:\n  assumes ht: \"healthy t\"\n  and wp: \"\\<guillemotleft>P\\<guillemotright> \\<tturnstile> t \\<guillemotleft>Q\\<guillemotright>\"\n  shows \"\\<forall>s. P s \\<longrightarrow> 1 \\<le> t \\<guillemotleft>Q\\<guillemotright> s\"", "lemma conj_post:\n  \"\\<lbrakk> P \\<tturnstile> t \\<guillemotleft>\\<lambda>s. Q s \\<and> R s\\<guillemotright>; healthy t \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> t \\<guillemotleft>Q\\<guillemotright>\"", "lemma entails_pconj_assumption:\n  assumes f: \"feasible t\" and wP: \"\\<And>s. P s \\<Longrightarrow> Q s \\<le> t R s\"\n      and uQ: \"unitary Q\" and uR: \"unitary R\"\n  shows \"\\<guillemotleft>P\\<guillemotright> && Q \\<tturnstile> t R\""], "translations": [["", "lemma le_transI[intro]:\n  \"\\<lbrakk> \\<And>P. sound P \\<Longrightarrow> t P \\<le> u P \\<rbrakk> \\<Longrightarrow> le_trans t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        sound P \\<Longrightarrow> t P \\<tturnstile> u P) \\<Longrightarrow>\n    le_trans t u", "by(simp add:le_trans_def)"], ["", "lemma le_utransI[intro]:\n  \"\\<lbrakk> \\<And>P. unitary P \\<Longrightarrow> t P \\<le> u P \\<rbrakk> \\<Longrightarrow> le_utrans t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        unitary P \\<Longrightarrow> t P \\<tturnstile> u P) \\<Longrightarrow>\n    le_utrans t u", "by(simp add:le_utrans_def)"], ["", "lemma  le_transD[dest]:\n  \"\\<lbrakk> le_trans t u; sound P \\<rbrakk> \\<Longrightarrow> t P \\<le> u P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le_trans t u; sound P\\<rbrakk>\n    \\<Longrightarrow> t P \\<tturnstile> u P", "by(simp add:le_trans_def)"], ["", "lemma le_utransD[dest]:\n  \"\\<lbrakk> le_utrans t u; unitary P \\<rbrakk> \\<Longrightarrow> t P \\<le> u P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le_utrans t u; unitary P\\<rbrakk>\n    \\<Longrightarrow> t P \\<tturnstile> u P", "by(simp add:le_utrans_def)"], ["", "lemma le_trans_trans[trans]:\n  \"\\<lbrakk> le_trans x y; le_trans y z \\<rbrakk> \\<Longrightarrow> le_trans x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le_trans x y; le_trans y z\\<rbrakk>\n    \\<Longrightarrow> le_trans x z", "unfolding le_trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>P. sound P \\<longrightarrow> x P \\<tturnstile> y P;\n     \\<forall>P. sound P \\<longrightarrow> y P \\<tturnstile> z P\\<rbrakk>\n    \\<Longrightarrow> \\<forall>P.\n                         sound P \\<longrightarrow> x P \\<tturnstile> z P", "by(blast dest:order_trans)"], ["", "lemma le_utrans_trans[trans]:\n  \"\\<lbrakk> le_utrans x y; le_utrans y z \\<rbrakk> \\<Longrightarrow> le_utrans x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le_utrans x y; le_utrans y z\\<rbrakk>\n    \\<Longrightarrow> le_utrans x z", "unfolding le_utrans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>P. unitary P \\<longrightarrow> x P \\<tturnstile> y P;\n     \\<forall>P. unitary P \\<longrightarrow> y P \\<tturnstile> z P\\<rbrakk>\n    \\<Longrightarrow> \\<forall>P.\n                         unitary P \\<longrightarrow> x P \\<tturnstile> z P", "by(blast dest:order_trans)"], ["", "lemma le_trans_refl[iff]:\n  \"le_trans x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_trans x x", "by(simp add:le_trans_def)"], ["", "lemma le_utrans_refl[iff]:\n  \"le_utrans x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_utrans x x", "by(simp add:le_utrans_def)"], ["", "lemma le_trans_le_utrans[dest]:\n  \"le_trans t u \\<Longrightarrow> le_utrans t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_trans t u \\<Longrightarrow> le_utrans t u", "unfolding le_trans_def le_utrans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P.\n       sound P \\<longrightarrow> t P \\<tturnstile> u P \\<Longrightarrow>\n    \\<forall>P. unitary P \\<longrightarrow> t P \\<tturnstile> u P", "by(auto)"], ["", "definition\n  l_trans :: \"'s trans \\<Rightarrow> 's trans \\<Rightarrow> bool\"\nwhere\n  \"l_trans t u \\<longleftrightarrow> le_trans t u \\<and> \\<not> le_trans u t\""], ["", "text \\<open>Transformer equivalence is induced by comparison:\\<close>"], ["", "definition\n  equiv_trans :: \"'s trans \\<Rightarrow> 's trans \\<Rightarrow> bool\"\nwhere\n  \"equiv_trans t u \\<longleftrightarrow> le_trans t u \\<and> le_trans u t\""], ["", "definition\n  equiv_utrans :: \"'s trans \\<Rightarrow> 's trans \\<Rightarrow> bool\"\nwhere\n  \"equiv_utrans t u \\<longleftrightarrow> le_utrans t u \\<and> le_utrans u t\""], ["", "lemma equiv_transI[intro]:\n  \"\\<lbrakk> \\<And>P. sound P \\<Longrightarrow> t P = u P \\<rbrakk> \\<Longrightarrow> equiv_trans t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P. sound P \\<Longrightarrow> t P = u P) \\<Longrightarrow>\n    equiv_trans t u", "unfolding equiv_trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P. sound P \\<Longrightarrow> t P = u P) \\<Longrightarrow>\n    le_trans t u \\<and> le_trans u t", "by(force)"], ["", "lemma equiv_utransI[intro]:\n  \"\\<lbrakk> \\<And>P. sound P \\<Longrightarrow> t P = u P \\<rbrakk> \\<Longrightarrow> equiv_utrans t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P. sound P \\<Longrightarrow> t P = u P) \\<Longrightarrow>\n    equiv_utrans t u", "unfolding equiv_utrans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P. sound P \\<Longrightarrow> t P = u P) \\<Longrightarrow>\n    le_utrans t u \\<and> le_utrans u t", "by(force)"], ["", "lemma equiv_transD[dest]:\n  \"\\<lbrakk> equiv_trans t u; sound P \\<rbrakk> \\<Longrightarrow> t P = u P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv_trans t u; sound P\\<rbrakk> \\<Longrightarrow> t P = u P", "unfolding equiv_trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le_trans t u \\<and> le_trans u t; sound P\\<rbrakk>\n    \\<Longrightarrow> t P = u P", "by(blast intro:antisym)"], ["", "lemma equiv_utransD[dest]:\n  \"\\<lbrakk> equiv_utrans t u; unitary P \\<rbrakk> \\<Longrightarrow> t P = u P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv_utrans t u; unitary P\\<rbrakk>\n    \\<Longrightarrow> t P = u P", "unfolding equiv_utrans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le_utrans t u \\<and> le_utrans u t; unitary P\\<rbrakk>\n    \\<Longrightarrow> t P = u P", "by(blast intro:antisym)"], ["", "lemma equiv_trans_refl[iff]:\n  \"equiv_trans t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_trans t t", "by(blast)"], ["", "lemma equiv_utrans_refl[iff]:\n  \"equiv_utrans t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_utrans t t", "by(blast)"], ["", "lemma le_trans_antisym:\n  \"\\<lbrakk> le_trans x y; le_trans y x \\<rbrakk> \\<Longrightarrow> equiv_trans x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le_trans x y; le_trans y x\\<rbrakk>\n    \\<Longrightarrow> equiv_trans x y", "unfolding equiv_trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le_trans x y; le_trans y x\\<rbrakk>\n    \\<Longrightarrow> le_trans x y \\<and> le_trans y x", "by(simp)"], ["", "lemma le_utrans_antisym:\n  \"\\<lbrakk> le_utrans x y; le_utrans y x \\<rbrakk> \\<Longrightarrow> equiv_utrans x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le_utrans x y; le_utrans y x\\<rbrakk>\n    \\<Longrightarrow> equiv_utrans x y", "unfolding equiv_utrans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le_utrans x y; le_utrans y x\\<rbrakk>\n    \\<Longrightarrow> le_utrans x y \\<and> le_utrans y x", "by(simp)"], ["", "lemma equiv_trans_comm[ac_simps]:\n  \"equiv_trans t u \\<longleftrightarrow> equiv_trans u t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_trans t u = equiv_trans u t", "unfolding equiv_trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (le_trans t u \\<and> le_trans u t) = (le_trans u t \\<and> le_trans t u)", "by(blast)"], ["", "lemma equiv_utrans_comm[ac_simps]:\n  \"equiv_utrans t u \\<longleftrightarrow> equiv_utrans u t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_utrans t u = equiv_utrans u t", "unfolding equiv_utrans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (le_utrans t u \\<and> le_utrans u t) =\n    (le_utrans u t \\<and> le_utrans t u)", "by(blast)"], ["", "lemma equiv_imp_le[intro]:\n  \"equiv_trans t u \\<Longrightarrow> le_trans t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_trans t u \\<Longrightarrow> le_trans t u", "unfolding equiv_trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. le_trans t u \\<and> le_trans u t \\<Longrightarrow> le_trans t u", "by(clarify)"], ["", "lemma equivu_imp_le[intro]:\n  \"equiv_utrans t u \\<Longrightarrow> le_utrans t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_utrans t u \\<Longrightarrow> le_utrans t u", "unfolding equiv_utrans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. le_utrans t u \\<and> le_utrans u t \\<Longrightarrow> le_utrans t u", "by(clarify)"], ["", "lemma equiv_imp_le_alt:\n  \"equiv_trans t u \\<Longrightarrow> le_trans u t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_trans t u \\<Longrightarrow> le_trans u t", "by(force simp:ac_simps)"], ["", "lemma equiv_uimp_le_alt:\n  \"equiv_utrans t u \\<Longrightarrow> le_utrans u t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_utrans t u \\<Longrightarrow> le_utrans u t", "by(force simp:ac_simps)"], ["", "lemma le_trans_equiv_rsp[simp]:\n  \"equiv_trans t u \\<Longrightarrow> le_trans t v \\<longleftrightarrow> le_trans u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_trans t u \\<Longrightarrow> le_trans t v = le_trans u v", "unfolding equiv_trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. le_trans t u \\<and> le_trans u t \\<Longrightarrow>\n    le_trans t v = le_trans u v", "by(blast intro:le_trans_trans)"], ["", "lemma le_utrans_equiv_rsp[simp]:\n  \"equiv_utrans t u \\<Longrightarrow> le_utrans t v \\<longleftrightarrow> le_utrans u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_utrans t u \\<Longrightarrow> le_utrans t v = le_utrans u v", "unfolding equiv_utrans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. le_utrans t u \\<and> le_utrans u t \\<Longrightarrow>\n    le_utrans t v = le_utrans u v", "by(blast intro:le_utrans_trans)"], ["", "lemma equiv_trans_le_trans[trans]:\n  \"\\<lbrakk> equiv_trans t u; le_trans u v \\<rbrakk> \\<Longrightarrow> le_trans t v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv_trans t u; le_trans u v\\<rbrakk>\n    \\<Longrightarrow> le_trans t v", "by(simp)"], ["", "lemma equiv_utrans_le_utrans[trans]:\n  \"\\<lbrakk> equiv_utrans t u; le_utrans u v \\<rbrakk> \\<Longrightarrow> le_utrans t v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv_utrans t u; le_utrans u v\\<rbrakk>\n    \\<Longrightarrow> le_utrans t v", "by(simp)"], ["", "lemma le_trans_equiv_rsp_right[simp]:\n  \"equiv_trans t u \\<Longrightarrow> le_trans v t \\<longleftrightarrow> le_trans v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_trans t u \\<Longrightarrow> le_trans v t = le_trans v u", "unfolding equiv_trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. le_trans t u \\<and> le_trans u t \\<Longrightarrow>\n    le_trans v t = le_trans v u", "by(blast intro:le_trans_trans)"], ["", "lemma le_utrans_equiv_rsp_right[simp]:\n  \"equiv_utrans t u \\<Longrightarrow> le_utrans v t \\<longleftrightarrow> le_utrans v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_utrans t u \\<Longrightarrow> le_utrans v t = le_utrans v u", "unfolding equiv_utrans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. le_utrans t u \\<and> le_utrans u t \\<Longrightarrow>\n    le_utrans v t = le_utrans v u", "by(blast intro:le_utrans_trans)"], ["", "lemma le_trans_equiv_trans[trans]:\n  \"\\<lbrakk> le_trans t u; equiv_trans u v \\<rbrakk> \\<Longrightarrow> le_trans t v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le_trans t u; equiv_trans u v\\<rbrakk>\n    \\<Longrightarrow> le_trans t v", "by(simp)"], ["", "lemma le_utrans_equiv_utrans[trans]:\n  \"\\<lbrakk> le_utrans t u; equiv_utrans u v \\<rbrakk> \\<Longrightarrow> le_utrans t v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le_utrans t u; equiv_utrans u v\\<rbrakk>\n    \\<Longrightarrow> le_utrans t v", "by(simp)"], ["", "lemma equiv_trans_trans[trans]:\n  assumes xy: \"equiv_trans x y\"\n      and yz: \"equiv_trans y z\"\n  shows \"equiv_trans x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_trans x z", "proof(rule le_trans_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. le_trans x z\n 2. le_trans z x", "from xy"], ["proof (chain)\npicking this:\n  equiv_trans x y", "have \"le_trans x y\""], ["proof (prove)\nusing this:\n  equiv_trans x y\n\ngoal (1 subgoal):\n 1. le_trans x y", "by(blast)"], ["proof (state)\nthis:\n  le_trans x y\n\ngoal (2 subgoals):\n 1. le_trans x z\n 2. le_trans z x", "also"], ["proof (state)\nthis:\n  le_trans x y\n\ngoal (2 subgoals):\n 1. le_trans x z\n 2. le_trans z x", "from yz"], ["proof (chain)\npicking this:\n  equiv_trans y z", "have \"le_trans y z\""], ["proof (prove)\nusing this:\n  equiv_trans y z\n\ngoal (1 subgoal):\n 1. le_trans y z", "by(blast)"], ["proof (state)\nthis:\n  le_trans y z\n\ngoal (2 subgoals):\n 1. le_trans x z\n 2. le_trans z x", "finally"], ["proof (chain)\npicking this:\n  le_trans x z", "show \"le_trans x z\""], ["proof (prove)\nusing this:\n  le_trans x z\n\ngoal (1 subgoal):\n 1. le_trans x z", "."], ["proof (state)\nthis:\n  le_trans x z\n\ngoal (1 subgoal):\n 1. le_trans z x", "from yz"], ["proof (chain)\npicking this:\n  equiv_trans y z", "have \"le_trans z y\""], ["proof (prove)\nusing this:\n  equiv_trans y z\n\ngoal (1 subgoal):\n 1. le_trans z y", "by(force simp:ac_simps)"], ["proof (state)\nthis:\n  le_trans z y\n\ngoal (1 subgoal):\n 1. le_trans z x", "also"], ["proof (state)\nthis:\n  le_trans z y\n\ngoal (1 subgoal):\n 1. le_trans z x", "from xy"], ["proof (chain)\npicking this:\n  equiv_trans x y", "have \"le_trans y x\""], ["proof (prove)\nusing this:\n  equiv_trans x y\n\ngoal (1 subgoal):\n 1. le_trans y x", "by(force simp:ac_simps)"], ["proof (state)\nthis:\n  le_trans y x\n\ngoal (1 subgoal):\n 1. le_trans z x", "finally"], ["proof (chain)\npicking this:\n  le_trans z x", "show \"le_trans z x\""], ["proof (prove)\nusing this:\n  le_trans z x\n\ngoal (1 subgoal):\n 1. le_trans z x", "."], ["proof (state)\nthis:\n  le_trans z x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma equiv_utrans_trans[trans]:\n  assumes xy: \"equiv_utrans x y\"\n      and yz: \"equiv_utrans y z\"\n  shows \"equiv_utrans x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_utrans x z", "proof(rule le_utrans_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. le_utrans x z\n 2. le_utrans z x", "from xy"], ["proof (chain)\npicking this:\n  equiv_utrans x y", "have \"le_utrans x y\""], ["proof (prove)\nusing this:\n  equiv_utrans x y\n\ngoal (1 subgoal):\n 1. le_utrans x y", "by(blast)"], ["proof (state)\nthis:\n  le_utrans x y\n\ngoal (2 subgoals):\n 1. le_utrans x z\n 2. le_utrans z x", "also"], ["proof (state)\nthis:\n  le_utrans x y\n\ngoal (2 subgoals):\n 1. le_utrans x z\n 2. le_utrans z x", "from yz"], ["proof (chain)\npicking this:\n  equiv_utrans y z", "have \"le_utrans y z\""], ["proof (prove)\nusing this:\n  equiv_utrans y z\n\ngoal (1 subgoal):\n 1. le_utrans y z", "by(blast)"], ["proof (state)\nthis:\n  le_utrans y z\n\ngoal (2 subgoals):\n 1. le_utrans x z\n 2. le_utrans z x", "finally"], ["proof (chain)\npicking this:\n  le_utrans x z", "show \"le_utrans x z\""], ["proof (prove)\nusing this:\n  le_utrans x z\n\ngoal (1 subgoal):\n 1. le_utrans x z", "."], ["proof (state)\nthis:\n  le_utrans x z\n\ngoal (1 subgoal):\n 1. le_utrans z x", "from yz"], ["proof (chain)\npicking this:\n  equiv_utrans y z", "have \"le_utrans z y\""], ["proof (prove)\nusing this:\n  equiv_utrans y z\n\ngoal (1 subgoal):\n 1. le_utrans z y", "by(force simp:ac_simps)"], ["proof (state)\nthis:\n  le_utrans z y\n\ngoal (1 subgoal):\n 1. le_utrans z x", "also"], ["proof (state)\nthis:\n  le_utrans z y\n\ngoal (1 subgoal):\n 1. le_utrans z x", "from xy"], ["proof (chain)\npicking this:\n  equiv_utrans x y", "have \"le_utrans y x\""], ["proof (prove)\nusing this:\n  equiv_utrans x y\n\ngoal (1 subgoal):\n 1. le_utrans y x", "by(force simp:ac_simps)"], ["proof (state)\nthis:\n  le_utrans y x\n\ngoal (1 subgoal):\n 1. le_utrans z x", "finally"], ["proof (chain)\npicking this:\n  le_utrans z x", "show \"le_utrans z x\""], ["proof (prove)\nusing this:\n  le_utrans z x\n\ngoal (1 subgoal):\n 1. le_utrans z x", "."], ["proof (state)\nthis:\n  le_utrans z x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma equiv_trans_equiv_utrans[dest]:\n  \"equiv_trans t u \\<Longrightarrow> equiv_utrans t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_trans t u \\<Longrightarrow> equiv_utrans t u", "by(auto)"], ["", "subsection \\<open>Healthy Transformers\\<close>"], ["", "subsubsection \\<open>Feasibility\\<close>"], ["", "definition feasible :: \"(('a \\<Rightarrow> real) \\<Rightarrow> ('a \\<Rightarrow> real)) \\<Rightarrow> bool\"\nwhere     \"feasible t \\<longleftrightarrow> (\\<forall>P b. bounded_by b P \\<and> nneg P \\<longrightarrow>\n                               bounded_by b (t P) \\<and> nneg (t P))\""], ["", "text \\<open>A @{term feasible} transformer preserves non-negativity, and bounds. A @{term feasible}\ntransformer always takes its argument `closer to 0' (or leaves it where it is). Note that any\nparticular value of the expectation may increase, but no element of the new expectation may exceed\nany bound on the old. This is thus a relatively weak condition.\\<close>"], ["", "lemma feasibleI[intro]:\n  \"\\<lbrakk> \\<And>b P. \\<lbrakk> bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> bounded_by b (t P);\n     \\<And>b P. \\<lbrakk> bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> nneg (t P) \\<rbrakk> \\<Longrightarrow> feasible t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>b P.\n                \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n                \\<Longrightarrow> bounded_by b (t P);\n     \\<And>b P.\n        \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n        \\<Longrightarrow> nneg (t P)\\<rbrakk>\n    \\<Longrightarrow> feasible t", "by(force simp:feasible_def)"], ["", "lemma feasible_boundedD[dest]:\n  \"\\<lbrakk> feasible t; bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> bounded_by b (t P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>feasible t; bounded_by b P; nneg P\\<rbrakk>\n    \\<Longrightarrow> bounded_by b (t P)", "by(simp add:feasible_def)"], ["", "lemma feasible_nnegD[dest]:\n  \"\\<lbrakk> feasible t; bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> nneg (t P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>feasible t; bounded_by b P; nneg P\\<rbrakk>\n    \\<Longrightarrow> nneg (t P)", "by(simp add:feasible_def)"], ["", "lemma feasible_sound[dest]:\n  \"\\<lbrakk> feasible t; sound P \\<rbrakk> \\<Longrightarrow> sound (t P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>feasible t; sound P\\<rbrakk> \\<Longrightarrow> sound (t P)", "by(rule soundI, unfold sound_def, (blast)+)"], ["", "lemma feasible_pr_0[simp]:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes ft: \"feasible t\"\n  shows \"t (\\<lambda>x. 0) = (\\<lambda>x. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t (\\<lambda>x. 0) = (\\<lambda>x. 0)", "proof(rule ext, rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. t (\\<lambda>x. 0) x \\<le> 0\n 2. \\<And>x. 0 \\<le> t (\\<lambda>x. 0) x", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. t (\\<lambda>x. 0) x \\<le> 0\n 2. \\<And>x. 0 \\<le> t (\\<lambda>x. 0) x", "have \"bounded_by 0 (\\<lambda>_::'s. 0::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by 0 (\\<lambda>_. 0)", "by(blast)"], ["proof (state)\nthis:\n  bounded_by 0 (\\<lambda>_. 0)\n\ngoal (2 subgoals):\n 1. \\<And>x. t (\\<lambda>x. 0) x \\<le> 0\n 2. \\<And>x. 0 \\<le> t (\\<lambda>x. 0) x", "with ft"], ["proof (chain)\npicking this:\n  feasible t\n  bounded_by 0 (\\<lambda>_. 0)", "have \"bounded_by 0 (t (\\<lambda>_. 0))\""], ["proof (prove)\nusing this:\n  feasible t\n  bounded_by 0 (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. bounded_by 0 (t (\\<lambda>_. 0))", "by(blast)"], ["proof (state)\nthis:\n  bounded_by 0 (t (\\<lambda>_. 0))\n\ngoal (2 subgoals):\n 1. \\<And>x. t (\\<lambda>x. 0) x \\<le> 0\n 2. \\<And>x. 0 \\<le> t (\\<lambda>x. 0) x", "thus \"t (\\<lambda>_. 0) s \\<le> 0\""], ["proof (prove)\nusing this:\n  bounded_by 0 (t (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. t (\\<lambda>_. 0) s \\<le> 0", "by(blast)"], ["proof (state)\nthis:\n  t (\\<lambda>_. 0) s \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 \\<le> t (\\<lambda>x. 0) x", "have \"nneg (\\<lambda>_::'s. 0::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nneg (\\<lambda>_. 0)", "by(blast)"], ["proof (state)\nthis:\n  nneg (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 \\<le> t (\\<lambda>x. 0) x", "with ft"], ["proof (chain)\npicking this:\n  feasible t\n  nneg (\\<lambda>_. 0)", "have \"nneg (t (\\<lambda>_. 0))\""], ["proof (prove)\nusing this:\n  feasible t\n  nneg (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. nneg (t (\\<lambda>_. 0))", "by(blast)"], ["proof (state)\nthis:\n  nneg (t (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 \\<le> t (\\<lambda>x. 0) x", "thus \"0 \\<le> t (\\<lambda>_. 0) s\""], ["proof (prove)\nusing this:\n  nneg (t (\\<lambda>_. 0))\n\ngoal (1 subgoal):\n 1. 0 \\<le> t (\\<lambda>_. 0) s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> t (\\<lambda>_. 0) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma feasible_id:\n  \"feasible (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. feasible (\\<lambda>x. x)", "unfolding feasible_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P b.\n       bounded_by b P \\<and> nneg P \\<longrightarrow>\n       bounded_by b P \\<and> nneg P", "by(blast)"], ["", "lemma feasible_bounded_by[dest]:\n  \"\\<lbrakk> feasible t; sound P; bounded_by b P \\<rbrakk> \\<Longrightarrow> bounded_by b (t P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>feasible t; sound P; bounded_by b P\\<rbrakk>\n    \\<Longrightarrow> bounded_by b (t P)", "by(auto)"], ["", "lemma feasible_fixes_top:\n  \"feasible t \\<Longrightarrow> t (\\<lambda>s. 1) \\<le> (\\<lambda>s. (1::real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. feasible t \\<Longrightarrow>\n    t (\\<lambda>s. 1) \\<tturnstile> \\<lambda>s. 1", "by(drule bounded_byD2[OF feasible_bounded_by], auto)"], ["", "lemma feasible_fixes_bot:\n  assumes ft: \"feasible t\"\n  shows \"t (\\<lambda>s. 0) = (\\<lambda>s. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t (\\<lambda>s. 0) = (\\<lambda>s. 0)", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. t (\\<lambda>s. 0) \\<tturnstile> \\<lambda>s. 0\n 2. \\<lambda>s. 0 \\<tturnstile> t (\\<lambda>s. 0)", "have sb: \"sound (\\<lambda>s. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (\\<lambda>s. 0)", "by(auto)"], ["proof (state)\nthis:\n  sound (\\<lambda>s. 0)\n\ngoal (2 subgoals):\n 1. t (\\<lambda>s. 0) \\<tturnstile> \\<lambda>s. 0\n 2. \\<lambda>s. 0 \\<tturnstile> t (\\<lambda>s. 0)", "with ft"], ["proof (chain)\npicking this:\n  feasible t\n  sound (\\<lambda>s. 0)", "show \"(\\<lambda>s. 0) \\<le> t (\\<lambda>s. 0)\""], ["proof (prove)\nusing this:\n  feasible t\n  sound (\\<lambda>s. 0)\n\ngoal (1 subgoal):\n 1. \\<lambda>s. 0 \\<tturnstile> t (\\<lambda>s. 0)", "by(auto)"], ["proof (state)\nthis:\n  \\<lambda>s. 0 \\<tturnstile> t (\\<lambda>s. 0)\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. 0) \\<tturnstile> \\<lambda>s. 0", "thm bound_of_const"], ["proof (state)\nthis:\n  \\<lambda>s. 0 \\<tturnstile> t (\\<lambda>s. 0)\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. 0) \\<tturnstile> \\<lambda>s. 0", "from sb"], ["proof (chain)\npicking this:\n  sound (\\<lambda>s. 0)", "have \"bounded_by (bound_of (\\<lambda>s. 0::real)) (\\<lambda>s. 0)\""], ["proof (prove)\nusing this:\n  sound (\\<lambda>s. 0)\n\ngoal (1 subgoal):\n 1. bounded_by (bound_of (\\<lambda>s. 0)) (\\<lambda>s. 0)", "by(auto)"], ["proof (state)\nthis:\n  bounded_by (bound_of (\\<lambda>s. 0)) (\\<lambda>s. 0)\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. 0) \\<tturnstile> \\<lambda>s. 0", "hence \"bounded_by 0 (\\<lambda>s. 0::real)\""], ["proof (prove)\nusing this:\n  bounded_by (bound_of (\\<lambda>s. 0)) (\\<lambda>s. 0)\n\ngoal (1 subgoal):\n 1. bounded_by 0 (\\<lambda>s. 0)", "by(simp add:bound_of_const)"], ["proof (state)\nthis:\n  bounded_by 0 (\\<lambda>s. 0)\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. 0) \\<tturnstile> \\<lambda>s. 0", "with ft"], ["proof (chain)\npicking this:\n  feasible t\n  bounded_by 0 (\\<lambda>s. 0)", "have \"bounded_by 0 (t (\\<lambda>s. 0))\""], ["proof (prove)\nusing this:\n  feasible t\n  bounded_by 0 (\\<lambda>s. 0)\n\ngoal (1 subgoal):\n 1. bounded_by 0 (t (\\<lambda>s. 0))", "by(auto)"], ["proof (state)\nthis:\n  bounded_by 0 (t (\\<lambda>s. 0))\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. 0) \\<tturnstile> \\<lambda>s. 0", "thus \"t (\\<lambda>s. 0) \\<le> (\\<lambda>s. 0)\""], ["proof (prove)\nusing this:\n  bounded_by 0 (t (\\<lambda>s. 0))\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. 0) \\<tturnstile> \\<lambda>s. 0", "by(auto)"], ["proof (state)\nthis:\n  t (\\<lambda>s. 0) \\<tturnstile> \\<lambda>s. 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma feasible_unitaryD[dest]:\n  assumes ft: \"feasible t\" and uP: \"unitary P\"\n  shows \"unitary (t P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (t P)", "proof(rule unitaryI)"], ["proof (state)\ngoal (2 subgoals):\n 1. sound (t P)\n 2. bounded_by 1 (t P)", "from uP"], ["proof (chain)\npicking this:\n  unitary P", "have \"sound P\""], ["proof (prove)\nusing this:\n  unitary P\n\ngoal (1 subgoal):\n 1. sound P", "by(auto)"], ["proof (state)\nthis:\n  sound P\n\ngoal (2 subgoals):\n 1. sound (t P)\n 2. bounded_by 1 (t P)", "with ft"], ["proof (chain)\npicking this:\n  feasible t\n  sound P", "show \"sound (t P)\""], ["proof (prove)\nusing this:\n  feasible t\n  sound P\n\ngoal (1 subgoal):\n 1. sound (t P)", "by(auto)"], ["proof (state)\nthis:\n  sound (t P)\n\ngoal (1 subgoal):\n 1. bounded_by 1 (t P)", "from assms"], ["proof (chain)\npicking this:\n  feasible t\n  unitary P", "show \"bounded_by 1 (t P)\""], ["proof (prove)\nusing this:\n  feasible t\n  unitary P\n\ngoal (1 subgoal):\n 1. bounded_by 1 (t P)", "by(auto)"], ["proof (state)\nthis:\n  bounded_by 1 (t P)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Monotonicity\\<close>"], ["", "definition\n  mono_trans :: \"(('s \\<Rightarrow> real) \\<Rightarrow> ('s \\<Rightarrow> real)) \\<Rightarrow> bool\"\nwhere\n  \"mono_trans t \\<equiv> \\<forall>P Q. (sound P \\<and> sound Q \\<and> P \\<le> Q) \\<longrightarrow> t P \\<le> t Q\""], ["", "text \\<open>Monotonicity allows us to compose transformers, and thus model sequential computation.\nRecall the definition of predicate entailment (\\autoref{s:entailment}) as less-than-or-equal. The\nstatement @{term \"Q \\<tturnstile> t R\"} means that @{term Q} is everywhere below @{term \"t R\"}. For standard\nexpectations (\\autoref{s:standard}), this simply means that @{term Q} \\emph{implies} @{term \"t R\"},\nthe \\emph{weakest precondition} of @{term R} under @{term t}.\n\nGiven another, monotonic, transformer @{term u}, we have that @{term \"u Q \\<tturnstile> u (t R)\"}, or that the\nweakest precondition of @{term Q} under @{term u} entails that of @{term R} under the composition\n@{term \"u o t\"}.  If we additionally know that @{term \"P \\<tturnstile> u Q\"}, then by transitivity we have\n@{term \"P \\<tturnstile> u (t R)\"}.  We thus derive a probabilistic form of the standard rule for sequential\ncomposition: @{term \"\\<lbrakk> mono_trans t; P \\<tturnstile> u Q; Q \\<tturnstile> t R \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> u (t R)\"}.\n\\<close>"], ["", "lemma mono_transI[intro]:\n  \"\\<lbrakk> \\<And>P Q. \\<lbrakk> sound P; sound Q; P \\<le> Q \\<rbrakk> \\<Longrightarrow>  t P \\<le> t Q \\<rbrakk> \\<Longrightarrow> mono_trans t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n        \\<Longrightarrow> t P \\<tturnstile> t Q) \\<Longrightarrow>\n    mono_trans t", "by(simp add:mono_trans_def)"], ["", "lemma mono_transD[dest]:\n  \"\\<lbrakk> mono_trans t; sound P; sound Q; P \\<le> Q \\<rbrakk> \\<Longrightarrow> t P \\<le> t Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono_trans t; sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n    \\<Longrightarrow> t P \\<tturnstile> t Q", "by(simp add:mono_trans_def)"], ["", "subsubsection \\<open>Scaling\\<close>"], ["", "text_raw \\<open>\\label{s:scaling}\\<close>"], ["", "text \\<open>A healthy transformer commutes with scaling by a non-negative constant.\\<close>"], ["", "definition\n  scaling :: \"(('s \\<Rightarrow> real) \\<Rightarrow> ('s \\<Rightarrow> real)) \\<Rightarrow> bool\"\nwhere\n  \"scaling t \\<equiv> \\<forall>P c x. sound P \\<and> 0 \\<le> c \\<longrightarrow> c * t P x = t (\\<lambda>x. c * P x) x\""], ["", "text \\<open>The @{term scaling} and feasibility properties together allow us to treat transformers as a\ncomplete lattice, when operating on bounded expectations. The action of a transformer on such a\nbounded expectation is completely determined by its action on \\emph{unitary} expectations (those\nbounded by 1): @{term \"t P s = bound_of P * t (\\<lambda>s. P s / bound_of P) s\"}. Feasibility in turn\nensures that the lattice of unitary expectations is closed under the action of a healthy\ntransformer. We take advantage of this fact in \\autoref{s:induction}, in order to define the fixed\npoints of healthy transformers.\\<close>"], ["", "lemma scalingI[intro]:\n  \"\\<lbrakk> \\<And>P c x. \\<lbrakk> sound P; 0 \\<le> c \\<rbrakk> \\<Longrightarrow> c * t P x = t (\\<lambda>x. c * P x) x \\<rbrakk> \\<Longrightarrow> scaling t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P c x.\n        \\<lbrakk>sound P; 0 \\<le> c\\<rbrakk>\n        \\<Longrightarrow> c * t P x =\n                          t (\\<lambda>x. c * P x) x) \\<Longrightarrow>\n    scaling t", "by(simp add:scaling_def)"], ["", "lemma scalingD[dest]:\n  \"\\<lbrakk> scaling t; sound P; 0 \\<le> c \\<rbrakk>  \\<Longrightarrow> c * t P x = t (\\<lambda>x. c * P x) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>scaling t; sound P; 0 \\<le> c\\<rbrakk>\n    \\<Longrightarrow> c * t P x = t (\\<lambda>x. c * P x) x", "by(simp add:scaling_def)"], ["", "lemma right_scalingD:\n  assumes st: \"scaling t\"\n      and sP: \"sound P\"\n      and nnc: \"0 \\<le> c\"\n  shows \"t P s * c = t (\\<lambda>s. P s * c) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t P s * c = t (\\<lambda>s. P s * c) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t P s * c = t (\\<lambda>s. P s * c) s", "have \"t P s * c = c * t P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t P s * c = c * t P s", "by(simp add:algebra_simps)"], ["proof (state)\nthis:\n  t P s * c = c * t P s\n\ngoal (1 subgoal):\n 1. t P s * c = t (\\<lambda>s. P s * c) s", "also"], ["proof (state)\nthis:\n  t P s * c = c * t P s\n\ngoal (1 subgoal):\n 1. t P s * c = t (\\<lambda>s. P s * c) s", "from assms"], ["proof (chain)\npicking this:\n  scaling t\n  sound P\n  0 \\<le> c", "have \"... = t (\\<lambda>s. c * P s) s\""], ["proof (prove)\nusing this:\n  scaling t\n  sound P\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. c * t P s = t (\\<lambda>s. c * P s) s", "by(rule scalingD)"], ["proof (state)\nthis:\n  c * t P s = t (\\<lambda>s. c * P s) s\n\ngoal (1 subgoal):\n 1. t P s * c = t (\\<lambda>s. P s * c) s", "also"], ["proof (state)\nthis:\n  c * t P s = t (\\<lambda>s. c * P s) s\n\ngoal (1 subgoal):\n 1. t P s * c = t (\\<lambda>s. P s * c) s", "have \"... = t (\\<lambda>s. P s * c) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t (\\<lambda>s. c * P s) s = t (\\<lambda>s. P s * c) s", "by(simp add:algebra_simps)"], ["proof (state)\nthis:\n  t (\\<lambda>s. c * P s) s = t (\\<lambda>s. P s * c) s\n\ngoal (1 subgoal):\n 1. t P s * c = t (\\<lambda>s. P s * c) s", "finally"], ["proof (chain)\npicking this:\n  t P s * c = t (\\<lambda>s. P s * c) s", "show ?thesis"], ["proof (prove)\nusing this:\n  t P s * c = t (\\<lambda>s. P s * c) s\n\ngoal (1 subgoal):\n 1. t P s * c = t (\\<lambda>s. P s * c) s", "."], ["proof (state)\nthis:\n  t P s * c = t (\\<lambda>s. P s * c) s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Healthiness\\<close>"], ["", "text \\<open>Healthy transformers are feasible and monotonic, and respect scaling\\<close>"], ["", "definition\n  healthy :: \"(('s \\<Rightarrow> real) \\<Rightarrow> ('s \\<Rightarrow> real)) \\<Rightarrow> bool\"\nwhere\n  \"healthy t \\<longleftrightarrow> feasible t \\<and> mono_trans t \\<and> scaling t\""], ["", "lemma healthyI[intro]:\n  \"\\<lbrakk> feasible t; mono_trans t; scaling t \\<rbrakk> \\<Longrightarrow> healthy t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>feasible t; mono_trans t; scaling t\\<rbrakk>\n    \\<Longrightarrow> healthy t", "by(simp add:healthy_def)"], ["", "lemmas healthy_parts = healthyI[OF feasibleI mono_transI scalingI]"], ["", "lemma healthy_monoD[dest]:\n  \"healthy t \\<Longrightarrow> mono_trans t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. healthy t \\<Longrightarrow> mono_trans t", "by(simp add:healthy_def)"], ["", "lemmas healthy_monoD2 = mono_transD[OF healthy_monoD]"], ["", "lemma healthy_feasibleD[dest]:\n  \"healthy t \\<Longrightarrow> feasible t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. healthy t \\<Longrightarrow> feasible t", "by(simp add:healthy_def)"], ["", "lemma healthy_scalingD[dest]:\n  \"healthy t \\<Longrightarrow> scaling t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. healthy t \\<Longrightarrow> scaling t", "by(simp add:healthy_def)"], ["", "lemma healthy_bounded_byD[intro]:\n  \"\\<lbrakk> healthy t; bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> bounded_by b (t P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>healthy t; bounded_by b P; nneg P\\<rbrakk>\n    \\<Longrightarrow> bounded_by b (t P)", "by(blast)"], ["", "lemma healthy_bounded_byD2:\n  \"\\<lbrakk> healthy t; bounded_by b P; sound P \\<rbrakk> \\<Longrightarrow> bounded_by b (t P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>healthy t; bounded_by b P; sound P\\<rbrakk>\n    \\<Longrightarrow> bounded_by b (t P)", "by(blast)"], ["", "lemma healthy_boundedD[dest,simp]:\n  \"\\<lbrakk> healthy t; sound P \\<rbrakk> \\<Longrightarrow> bounded (t P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>healthy t; sound P\\<rbrakk>\n    \\<Longrightarrow> Expectations.bounded (t P)", "by(blast)"], ["", "lemma healthy_nnegD[dest,simp]:\n  \"\\<lbrakk> healthy t; sound P \\<rbrakk> \\<Longrightarrow> nneg (t P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>healthy t; sound P\\<rbrakk> \\<Longrightarrow> nneg (t P)", "by(blast intro!:feasible_nnegD)"], ["", "lemma healthy_nnegD2[dest,simp]:\n  \"\\<lbrakk> healthy t; bounded_by b P; nneg P \\<rbrakk> \\<Longrightarrow> nneg (t P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>healthy t; bounded_by b P; nneg P\\<rbrakk>\n    \\<Longrightarrow> nneg (t P)", "by(blast)"], ["", "lemma healthy_sound[intro]:\n  \"\\<lbrakk> healthy t; sound P \\<rbrakk> \\<Longrightarrow> sound (t P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>healthy t; sound P\\<rbrakk> \\<Longrightarrow> sound (t P)", "by(rule soundI, blast, blast intro:feasible_nnegD)"], ["", "lemma healthy_unitary[intro]:\n  \"\\<lbrakk> healthy t; unitary P \\<rbrakk> \\<Longrightarrow> unitary (t P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>healthy t; unitary P\\<rbrakk> \\<Longrightarrow> unitary (t P)", "by(blast intro!:unitaryI dest:unitary_bound healthy_bounded_byD)"], ["", "lemma healthy_id[simp,intro!]:\n  \"healthy id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. healthy id", "by(simp add:healthyI feasibleI mono_transI scalingI)"], ["", "lemmas healthy_fixes_bot = feasible_fixes_bot[OF healthy_feasibleD]"], ["", "text \\<open>Some additional results on @{term le_trans}, specific to\n@{term healthy} transformers.\\<close>"], ["", "lemma le_trans_bot[intro,simp]:\n  \"healthy t \\<Longrightarrow> le_trans (\\<lambda>P s. 0) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. healthy t \\<Longrightarrow> le_trans (\\<lambda>P s. 0) t", "by(blast intro:le_funI)"], ["", "lemma le_trans_top[intro,simp]:\n  \"healthy t \\<Longrightarrow> le_trans t (\\<lambda>P s. bound_of P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. healthy t \\<Longrightarrow> le_trans t (\\<lambda>P s. bound_of P)", "by(blast intro!:le_transI[OF le_funI])"], ["", "lemma healthy_pr_bot[simp]:\n  \"healthy t \\<Longrightarrow> t (\\<lambda>s. 0) = (\\<lambda>s. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. healthy t \\<Longrightarrow> t (\\<lambda>s. 0) = (\\<lambda>s. 0)", "by(blast intro:feasible_pr_0)"], ["", "text \\<open>The first significant result is that healthiness is preserved by equivalence:\\<close>"], ["", "lemma healthy_equivI:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\" and u\n  assumes equiv:   \"equiv_trans t u\"\n      and healthy: \"healthy t\"\n  shows \"healthy u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. healthy u", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. feasible u\n 2. mono_trans u\n 3. scaling u", "have le_t_u: \"le_trans t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_trans t u", "by(blast intro:equiv)"], ["proof (state)\nthis:\n  le_trans t u\n\ngoal (3 subgoals):\n 1. feasible u\n 2. mono_trans u\n 3. scaling u", "have le_u_t: \"le_trans u t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_trans u t", "by(simp add:equiv_imp_le ac_simps equiv)"], ["proof (state)\nthis:\n  le_trans u t\n\ngoal (3 subgoals):\n 1. feasible u\n 2. mono_trans u\n 3. scaling u", "from equiv"], ["proof (chain)\npicking this:\n  equiv_trans t u", "have eq_u_t: \"equiv_trans u t\""], ["proof (prove)\nusing this:\n  equiv_trans t u\n\ngoal (1 subgoal):\n 1. equiv_trans u t", "by(simp add:ac_simps)"], ["proof (state)\nthis:\n  equiv_trans u t\n\ngoal (3 subgoals):\n 1. feasible u\n 2. mono_trans u\n 3. scaling u", "show \"feasible u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. feasible u", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (u P)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk> \\<Longrightarrow> nneg (u P)", "fix b and P::\"'s \\<Rightarrow> real\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (u P)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk> \\<Longrightarrow> nneg (u P)", "assume bP: \"bounded_by b P\" and nP: \"nneg P\""], ["proof (state)\nthis:\n  bounded_by b P\n  nneg P\n\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (u P)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk> \\<Longrightarrow> nneg (u P)", "hence sP: \"sound P\""], ["proof (prove)\nusing this:\n  bounded_by b P\n  nneg P\n\ngoal (1 subgoal):\n 1. sound P", "by(blast)"], ["proof (state)\nthis:\n  sound P\n\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (u P)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk> \\<Longrightarrow> nneg (u P)", "with healthy"], ["proof (chain)\npicking this:\n  healthy t\n  sound P", "have \"\\<And>s. 0 \\<le> t P s\""], ["proof (prove)\nusing this:\n  healthy t\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>s. 0 \\<le> t P s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> t P ?s\n\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (u P)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk> \\<Longrightarrow> nneg (u P)", "also"], ["proof (state)\nthis:\n  0 \\<le> t P ?s\n\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (u P)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk> \\<Longrightarrow> nneg (u P)", "from sP and le_t_u"], ["proof (chain)\npicking this:\n  sound P\n  le_trans t u", "have \"\\<And>s. ... s \\<le> u P s\""], ["proof (prove)\nusing this:\n  sound P\n  le_trans t u\n\ngoal (1 subgoal):\n 1. \\<And>s. t P s \\<le> u P s", "by(blast)"], ["proof (state)\nthis:\n  t P ?s \\<le> u P ?s\n\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (u P)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk> \\<Longrightarrow> nneg (u P)", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> u P ?s1", "show \"nneg (u P)\""], ["proof (prove)\nusing this:\n  0 \\<le> u P ?s1\n\ngoal (1 subgoal):\n 1. nneg (u P)", "by(blast)"], ["proof (state)\nthis:\n  nneg (u P)\n\ngoal (1 subgoal):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (u P)", "from sP and le_u_t"], ["proof (chain)\npicking this:\n  sound P\n  le_trans u t", "have \"\\<And>s. u P s \\<le> t P s\""], ["proof (prove)\nusing this:\n  sound P\n  le_trans u t\n\ngoal (1 subgoal):\n 1. \\<And>s. u P s \\<le> t P s", "by(blast)"], ["proof (state)\nthis:\n  u P ?s \\<le> t P ?s\n\ngoal (1 subgoal):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (u P)", "also"], ["proof (state)\nthis:\n  u P ?s \\<le> t P ?s\n\ngoal (1 subgoal):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (u P)", "from healthy and sP and bP"], ["proof (chain)\npicking this:\n  healthy t\n  sound P\n  bounded_by b P", "have \"\\<And>s. t P s \\<le> b\""], ["proof (prove)\nusing this:\n  healthy t\n  sound P\n  bounded_by b P\n\ngoal (1 subgoal):\n 1. \\<And>s. t P s \\<le> b", "by(blast)"], ["proof (state)\nthis:\n  t P ?s \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (u P)", "finally"], ["proof (chain)\npicking this:\n  u P ?s1 \\<le> b", "show \"bounded_by b (u P)\""], ["proof (prove)\nusing this:\n  u P ?s1 \\<le> b\n\ngoal (1 subgoal):\n 1. bounded_by b (u P)", "by(blast)"], ["proof (state)\nthis:\n  bounded_by b (u P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  feasible u\n\ngoal (2 subgoals):\n 1. mono_trans u\n 2. scaling u", "show \"mono_trans u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_trans u", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n       \\<Longrightarrow> u P \\<tturnstile> u Q", "fix P::\"'s \\<Rightarrow> real\" and Q::\"'s \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n       \\<Longrightarrow> u P \\<tturnstile> u Q", "assume sP: \"sound P\" and sQ: \"sound Q\"\n       and le: \"P \\<tturnstile> Q\""], ["proof (state)\nthis:\n  sound P\n  sound Q\n  P \\<tturnstile> Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n       \\<Longrightarrow> u P \\<tturnstile> u Q", "from sP and le_u_t"], ["proof (chain)\npicking this:\n  sound P\n  le_trans u t", "have \"u P \\<tturnstile> t P\""], ["proof (prove)\nusing this:\n  sound P\n  le_trans u t\n\ngoal (1 subgoal):\n 1. u P \\<tturnstile> t P", "by(blast)"], ["proof (state)\nthis:\n  u P \\<tturnstile> t P\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n       \\<Longrightarrow> u P \\<tturnstile> u Q", "also"], ["proof (state)\nthis:\n  u P \\<tturnstile> t P\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n       \\<Longrightarrow> u P \\<tturnstile> u Q", "from sP and sQ and le and healthy"], ["proof (chain)\npicking this:\n  sound P\n  sound Q\n  P \\<tturnstile> Q\n  healthy t", "have \"t P \\<tturnstile> t Q\""], ["proof (prove)\nusing this:\n  sound P\n  sound Q\n  P \\<tturnstile> Q\n  healthy t\n\ngoal (1 subgoal):\n 1. t P \\<tturnstile> t Q", "by(blast)"], ["proof (state)\nthis:\n  t P \\<tturnstile> t Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n       \\<Longrightarrow> u P \\<tturnstile> u Q", "also"], ["proof (state)\nthis:\n  t P \\<tturnstile> t Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n       \\<Longrightarrow> u P \\<tturnstile> u Q", "from sQ and le_t_u"], ["proof (chain)\npicking this:\n  sound Q\n  le_trans t u", "have \"t Q \\<tturnstile> u Q\""], ["proof (prove)\nusing this:\n  sound Q\n  le_trans t u\n\ngoal (1 subgoal):\n 1. t Q \\<tturnstile> u Q", "by(blast)"], ["proof (state)\nthis:\n  t Q \\<tturnstile> u Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n       \\<Longrightarrow> u P \\<tturnstile> u Q", "finally"], ["proof (chain)\npicking this:\n  u P \\<tturnstile> u Q", "show \"u P \\<tturnstile> u Q\""], ["proof (prove)\nusing this:\n  u P \\<tturnstile> u Q\n\ngoal (1 subgoal):\n 1. u P \\<tturnstile> u Q", "."], ["proof (state)\nthis:\n  u P \\<tturnstile> u Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mono_trans u\n\ngoal (1 subgoal):\n 1. scaling u", "show \"scaling u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scaling u", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P c x.\n       \\<lbrakk>sound P; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> c * u P x = u (\\<lambda>x. c * P x) x", "fix P::\"'s \\<Rightarrow> real\" and c::real and x::'s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P c x.\n       \\<lbrakk>sound P; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> c * u P x = u (\\<lambda>x. c * P x) x", "assume sound: \"sound P\"\n       and pos:   \"0 \\<le> c\""], ["proof (state)\nthis:\n  sound P\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>P c x.\n       \\<lbrakk>sound P; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> c * u P x = u (\\<lambda>x. c * P x) x", "hence \"bounded_by (c * bound_of P) (\\<lambda>x. c * P x)\""], ["proof (prove)\nusing this:\n  sound P\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. bounded_by (c * bound_of P) (\\<lambda>x. c * P x)", "by(blast intro!:mult_left_mono dest!:less_imp_le)"], ["proof (state)\nthis:\n  bounded_by (c * bound_of P) (\\<lambda>x. c * P x)\n\ngoal (1 subgoal):\n 1. \\<And>P c x.\n       \\<lbrakk>sound P; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> c * u P x = u (\\<lambda>x. c * P x) x", "hence sc_bounded: \"bounded (\\<lambda>x. c * P x)\""], ["proof (prove)\nusing this:\n  bounded_by (c * bound_of P) (\\<lambda>x. c * P x)\n\ngoal (1 subgoal):\n 1. Expectations.bounded (\\<lambda>x. c * P x)", "by(blast)"], ["proof (state)\nthis:\n  Expectations.bounded (\\<lambda>x. c * P x)\n\ngoal (1 subgoal):\n 1. \\<And>P c x.\n       \\<lbrakk>sound P; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> c * u P x = u (\\<lambda>x. c * P x) x", "moreover"], ["proof (state)\nthis:\n  Expectations.bounded (\\<lambda>x. c * P x)\n\ngoal (1 subgoal):\n 1. \\<And>P c x.\n       \\<lbrakk>sound P; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> c * u P x = u (\\<lambda>x. c * P x) x", "from sound and pos"], ["proof (chain)\npicking this:\n  sound P\n  0 \\<le> c", "have sc_nneg: \"nneg (\\<lambda>x. c * P x)\""], ["proof (prove)\nusing this:\n  sound P\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>x. c * P x)", "by(blast intro:mult_nonneg_nonneg less_imp_le)"], ["proof (state)\nthis:\n  nneg (\\<lambda>x. c * P x)\n\ngoal (1 subgoal):\n 1. \\<And>P c x.\n       \\<lbrakk>sound P; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> c * u P x = u (\\<lambda>x. c * P x) x", "ultimately"], ["proof (chain)\npicking this:\n  Expectations.bounded (\\<lambda>x. c * P x)\n  nneg (\\<lambda>x. c * P x)", "have sc_sound: \"sound (\\<lambda>x. c * P x)\""], ["proof (prove)\nusing this:\n  Expectations.bounded (\\<lambda>x. c * P x)\n  nneg (\\<lambda>x. c * P x)\n\ngoal (1 subgoal):\n 1. sound (\\<lambda>x. c * P x)", "by(blast)"], ["proof (state)\nthis:\n  sound (\\<lambda>x. c * P x)\n\ngoal (1 subgoal):\n 1. \\<And>P c x.\n       \\<lbrakk>sound P; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> c * u P x = u (\\<lambda>x. c * P x) x", "show \"c * u P x = u (\\<lambda>x. c * P x) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * u P x = u (\\<lambda>x. c * P x) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c * u P x = u (\\<lambda>x. c * P x) x", "from sound"], ["proof (chain)\npicking this:\n  sound P", "have \"c * u P x = c * t P x\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. c * u P x = c * t P x", "by(simp add:equiv_transD[OF eq_u_t])"], ["proof (state)\nthis:\n  c * u P x = c * t P x\n\ngoal (1 subgoal):\n 1. c * u P x = u (\\<lambda>x. c * P x) x", "also"], ["proof (state)\nthis:\n  c * u P x = c * t P x\n\ngoal (1 subgoal):\n 1. c * u P x = u (\\<lambda>x. c * P x) x", "have \"... = t (\\<lambda>x. c * P x) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * t P x = t (\\<lambda>x. c * P x) x", "using healthy and sound and pos"], ["proof (prove)\nusing this:\n  healthy t\n  sound P\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. c * t P x = t (\\<lambda>x. c * P x) x", "by(blast intro: scalingD)"], ["proof (state)\nthis:\n  c * t P x = t (\\<lambda>x. c * P x) x\n\ngoal (1 subgoal):\n 1. c * u P x = u (\\<lambda>x. c * P x) x", "also"], ["proof (state)\nthis:\n  c * t P x = t (\\<lambda>x. c * P x) x\n\ngoal (1 subgoal):\n 1. c * u P x = u (\\<lambda>x. c * P x) x", "from sc_sound and equiv"], ["proof (chain)\npicking this:\n  sound (\\<lambda>x. c * P x)\n  equiv_trans t u", "have \"... = u (\\<lambda>x. c * P x) x\""], ["proof (prove)\nusing this:\n  sound (\\<lambda>x. c * P x)\n  equiv_trans t u\n\ngoal (1 subgoal):\n 1. t (\\<lambda>x. c * P x) x = u (\\<lambda>x. c * P x) x", "by(blast intro:fun_cong)"], ["proof (state)\nthis:\n  t (\\<lambda>x. c * P x) x = u (\\<lambda>x. c * P x) x\n\ngoal (1 subgoal):\n 1. c * u P x = u (\\<lambda>x. c * P x) x", "finally"], ["proof (chain)\npicking this:\n  c * u P x = u (\\<lambda>x. c * P x) x", "show ?thesis"], ["proof (prove)\nusing this:\n  c * u P x = u (\\<lambda>x. c * P x) x\n\ngoal (1 subgoal):\n 1. c * u P x = u (\\<lambda>x. c * P x) x", "."], ["proof (state)\nthis:\n  c * u P x = u (\\<lambda>x. c * P x) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c * u P x = u (\\<lambda>x. c * P x) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  scaling u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma healthy_equiv:\n  \"equiv_trans t u \\<Longrightarrow> healthy t \\<longleftrightarrow> healthy u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_trans t u \\<Longrightarrow> healthy t = healthy u", "by(rule iffI, rule healthy_equivI, assumption+,\n     simp add:healthy_equivI ac_simps)"], ["", "lemma healthy_scale:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes ht: \"healthy t\" and nc: \"0 \\<le> c\" and bc: \"c \\<le> 1\"\n  shows \"healthy (\\<lambda>P s. c * t P s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. healthy (\\<lambda>P s. c * t P s)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. feasible (\\<lambda>P s. c * t P s)\n 2. mono_trans (\\<lambda>P s. c * t P s)\n 3. scaling (\\<lambda>P s. c * t P s)", "show \"feasible (\\<lambda>P s. c * t P s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. feasible (\\<lambda>P s. c * t P s)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (\\<lambda>s. c * t P s)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> nneg (\\<lambda>s. c * t P s)", "fix b and P::\"'s \\<Rightarrow> real\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (\\<lambda>s. c * t P s)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> nneg (\\<lambda>s. c * t P s)", "assume nnP: \"nneg P\" and bP: \"bounded_by b P\""], ["proof (state)\nthis:\n  nneg P\n  bounded_by b P\n\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (\\<lambda>s. c * t P s)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> nneg (\\<lambda>s. c * t P s)", "from ht nnP bP"], ["proof (chain)\npicking this:\n  healthy t\n  nneg P\n  bounded_by b P", "have \"\\<And>s. t P s \\<le> b\""], ["proof (prove)\nusing this:\n  healthy t\n  nneg P\n  bounded_by b P\n\ngoal (1 subgoal):\n 1. \\<And>s. t P s \\<le> b", "by(blast)"], ["proof (state)\nthis:\n  t P ?s \\<le> b\n\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (\\<lambda>s. c * t P s)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> nneg (\\<lambda>s. c * t P s)", "with nc"], ["proof (chain)\npicking this:\n  0 \\<le> c\n  t P ?s \\<le> b", "have \"\\<And>s. c * t P s \\<le> c * b\""], ["proof (prove)\nusing this:\n  0 \\<le> c\n  t P ?s \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>s. c * t P s \\<le> c * b", "by(blast intro:mult_left_mono)"], ["proof (state)\nthis:\n  c * t P ?s \\<le> c * b\n\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (\\<lambda>s. c * t P s)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> nneg (\\<lambda>s. c * t P s)", "also"], ["proof (state)\nthis:\n  c * t P ?s \\<le> c * b\n\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (\\<lambda>s. c * t P s)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> nneg (\\<lambda>s. c * t P s)", "{"], ["proof (state)\nthis:\n  c * t P ?s \\<le> c * b\n\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (\\<lambda>s. c * t P s)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> nneg (\\<lambda>s. c * t P s)", "from nnP and bP"], ["proof (chain)\npicking this:\n  nneg P\n  bounded_by b P", "have \"0 \\<le> b\""], ["proof (prove)\nusing this:\n  nneg P\n  bounded_by b P\n\ngoal (1 subgoal):\n 1. 0 \\<le> b", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> b\n\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (\\<lambda>s. c * t P s)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> nneg (\\<lambda>s. c * t P s)", "with bc"], ["proof (chain)\npicking this:\n  c \\<le> 1\n  0 \\<le> b", "have \"c * b \\<le> 1 * b\""], ["proof (prove)\nusing this:\n  c \\<le> 1\n  0 \\<le> b\n\ngoal (1 subgoal):\n 1. c * b \\<le> 1 * b", "by(blast intro:mult_right_mono)"], ["proof (state)\nthis:\n  c * b \\<le> 1 * b\n\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (\\<lambda>s. c * t P s)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> nneg (\\<lambda>s. c * t P s)", "hence \"c * b \\<le> b\""], ["proof (prove)\nusing this:\n  c * b \\<le> 1 * b\n\ngoal (1 subgoal):\n 1. c * b \\<le> b", "by(simp)"], ["proof (state)\nthis:\n  c * b \\<le> b\n\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (\\<lambda>s. c * t P s)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> nneg (\\<lambda>s. c * t P s)", "}"], ["proof (state)\nthis:\n  c * b \\<le> b\n\ngoal (2 subgoals):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> bounded_by b (\\<lambda>s. c * t P s)\n 2. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> nneg (\\<lambda>s. c * t P s)", "finally"], ["proof (chain)\npicking this:\n  c * t P ?s1 \\<le> b", "show \"bounded_by b (\\<lambda>s. c * t P s)\""], ["proof (prove)\nusing this:\n  c * t P ?s1 \\<le> b\n\ngoal (1 subgoal):\n 1. bounded_by b (\\<lambda>s. c * t P s)", "by(blast)"], ["proof (state)\nthis:\n  bounded_by b (\\<lambda>s. c * t P s)\n\ngoal (1 subgoal):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> nneg (\\<lambda>s. c * t P s)", "from ht nnP bP"], ["proof (chain)\npicking this:\n  healthy t\n  nneg P\n  bounded_by b P", "have \"\\<And>s. 0 \\<le> t P s\""], ["proof (prove)\nusing this:\n  healthy t\n  nneg P\n  bounded_by b P\n\ngoal (1 subgoal):\n 1. \\<And>s. 0 \\<le> t P s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> t P ?s\n\ngoal (1 subgoal):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> nneg (\\<lambda>s. c * t P s)", "with nc"], ["proof (chain)\npicking this:\n  0 \\<le> c\n  0 \\<le> t P ?s", "have \"\\<And>s. 0 \\<le> c * t P s\""], ["proof (prove)\nusing this:\n  0 \\<le> c\n  0 \\<le> t P ?s\n\ngoal (1 subgoal):\n 1. \\<And>s. 0 \\<le> c * t P s", "by(rule mult_nonneg_nonneg)"], ["proof (state)\nthis:\n  0 \\<le> c * t P ?s\n\ngoal (1 subgoal):\n 1. \\<And>b P.\n       \\<lbrakk>bounded_by b P; nneg P\\<rbrakk>\n       \\<Longrightarrow> nneg (\\<lambda>s. c * t P s)", "thus \"nneg (\\<lambda>s. c * t P s)\""], ["proof (prove)\nusing this:\n  0 \\<le> c * t P ?s\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. c * t P s)", "by(blast)"], ["proof (state)\nthis:\n  nneg (\\<lambda>s. c * t P s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  feasible (\\<lambda>P s. c * t P s)\n\ngoal (2 subgoals):\n 1. mono_trans (\\<lambda>P s. c * t P s)\n 2. scaling (\\<lambda>P s. c * t P s)", "show \"mono_trans (\\<lambda>P s. c * t P s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_trans (\\<lambda>P s. c * t P s)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            c * t P s \\<tturnstile> \\<lambda>s. c * t Q s", "fix P::\"'s \\<Rightarrow> real\" and Q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            c * t P s \\<tturnstile> \\<lambda>s. c * t Q s", "assume sP: \"sound P\" and sQ: \"sound Q\" and le: \"P \\<tturnstile> Q\""], ["proof (state)\nthis:\n  sound P\n  sound Q\n  P \\<tturnstile> Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            c * t P s \\<tturnstile> \\<lambda>s. c * t Q s", "with ht"], ["proof (chain)\npicking this:\n  healthy t\n  sound P\n  sound Q\n  P \\<tturnstile> Q", "have \"\\<And>s. t P s \\<le> t Q s\""], ["proof (prove)\nusing this:\n  healthy t\n  sound P\n  sound Q\n  P \\<tturnstile> Q\n\ngoal (1 subgoal):\n 1. \\<And>s. t P s \\<le> t Q s", "by(auto intro:le_funD)"], ["proof (state)\nthis:\n  t P ?s \\<le> t Q ?s\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            c * t P s \\<tturnstile> \\<lambda>s. c * t Q s", "with nc"], ["proof (chain)\npicking this:\n  0 \\<le> c\n  t P ?s \\<le> t Q ?s", "have \"\\<And>s. c * t P s \\<le> c * t Q s\""], ["proof (prove)\nusing this:\n  0 \\<le> c\n  t P ?s \\<le> t Q ?s\n\ngoal (1 subgoal):\n 1. \\<And>s. c * t P s \\<le> c * t Q s", "by(blast intro:mult_left_mono)"], ["proof (state)\nthis:\n  c * t P ?s \\<le> c * t Q ?s\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>sound P; sound Q; P \\<tturnstile> Q\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            c * t P s \\<tturnstile> \\<lambda>s. c * t Q s", "thus \"\\<lambda>s. c * t P s \\<tturnstile> \\<lambda>s. c * t Q s\""], ["proof (prove)\nusing this:\n  c * t P ?s \\<le> c * t Q ?s\n\ngoal (1 subgoal):\n 1. \\<lambda>s. c * t P s \\<tturnstile> \\<lambda>s. c * t Q s", "by(blast)"], ["proof (state)\nthis:\n  \\<lambda>s. c * t P s \\<tturnstile> \\<lambda>s. c * t Q s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mono_trans (\\<lambda>P s. c * t P s)\n\ngoal (1 subgoal):\n 1. scaling (\\<lambda>P s. c * t P s)", "from ht"], ["proof (chain)\npicking this:\n  healthy t", "show \"scaling (\\<lambda>P s. c * t P s)\""], ["proof (prove)\nusing this:\n  healthy t\n\ngoal (1 subgoal):\n 1. scaling (\\<lambda>P s. c * t P s)", "by(auto simp:scalingD healthy_scalingD ht)"], ["proof (state)\nthis:\n  scaling (\\<lambda>P s. c * t P s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma healthy_top[iff]:\n  \"healthy (\\<lambda>P s. bound_of P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. healthy (\\<lambda>P s. bound_of P)", "by(auto intro!:healthy_parts)"], ["", "lemma healthy_bot[iff]:\n  \"healthy (\\<lambda>P s. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. healthy (\\<lambda>P s. 0)", "by(auto intro!:healthy_parts)"], ["", "text \\<open>This weaker healthiness condition is for the liberal (wlp) semantics. We only insist that\nthe transformer preserves \\emph{unitarity} (bounded by 1), and drop scaling (it is unnecessary in\nestablishing the lattice structure here, unlike for the strict semantics).\\<close>"], ["", "definition\n  nearly_healthy :: \"(('s \\<Rightarrow> real) \\<Rightarrow> ('s \\<Rightarrow> real)) \\<Rightarrow> bool\"\nwhere\n  \"nearly_healthy t \\<longleftrightarrow> (\\<forall>P. unitary P \\<longrightarrow> unitary (t P)) \\<and>\n                        (\\<forall>P Q. unitary P \\<longrightarrow> unitary Q \\<longrightarrow> P \\<tturnstile> Q \\<longrightarrow> t P \\<tturnstile> t Q)\""], ["", "lemma nearly_healthyI[intro]:\n  \"\\<lbrakk> \\<And>P. unitary P \\<Longrightarrow> unitary (t P);\n     \\<And>P Q. \\<lbrakk> unitary P; unitary Q; P \\<tturnstile> Q \\<rbrakk> \\<Longrightarrow> t P \\<tturnstile> t Q \\<rbrakk> \\<Longrightarrow> nearly_healthy t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>P. unitary P \\<Longrightarrow> unitary (t P);\n     \\<And>P Q.\n        \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> Q\\<rbrakk>\n        \\<Longrightarrow> t P \\<tturnstile> t Q\\<rbrakk>\n    \\<Longrightarrow> nearly_healthy t", "by(simp add:nearly_healthy_def)"], ["", "lemma nearly_healthy_monoD[dest]:\n  \"\\<lbrakk> nearly_healthy t; P \\<tturnstile> Q; unitary P; unitary Q \\<rbrakk> \\<Longrightarrow> t P \\<tturnstile> t Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nearly_healthy t; P \\<tturnstile> Q; unitary P;\n     unitary Q\\<rbrakk>\n    \\<Longrightarrow> t P \\<tturnstile> t Q", "by(simp add:nearly_healthy_def)"], ["", "lemma nearly_healthy_unitaryD[dest]:\n  \"\\<lbrakk> nearly_healthy t; unitary P \\<rbrakk> \\<Longrightarrow> unitary (t P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nearly_healthy t; unitary P\\<rbrakk>\n    \\<Longrightarrow> unitary (t P)", "by(simp add:nearly_healthy_def)"], ["", "lemma healthy_nearly_healthy[dest]:\n  assumes ht: \"healthy t\"\n  shows \"nearly_healthy t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nearly_healthy t", "by(intro nearly_healthyI, auto intro:mono_transD[OF healthy_monoD, OF ht] ht)"], ["", "lemmas nearly_healthy_id[iff] =\n  healthy_nearly_healthy[OF healthy_id, unfolded id_def]"], ["", "subsection \\<open>Sublinearity\\<close>"], ["", "text \\<open>As already mentioned, the core healthiness property (aside from feasibility and continuity)\nfor transformers is \\emph{sublinearity}: The transformation of a quasi-linear combination of sound\nexpectations is greater than the same combination applied to the transformation of the expectations\nthemselves. The term @{term \"x \\<ominus> y\"} represents \\emph{truncated subtraction} i.e. @{term \"max (x-y)\n0\"} (see \\autoref{s:trunc_sub}).\\<close>"], ["", "definition sublinear ::\n  \"(('s \\<Rightarrow> real) \\<Rightarrow> ('s \\<Rightarrow> real)) \\<Rightarrow> bool\"\nwhere\n  \"sublinear t \\<longleftrightarrow> (\\<forall>a b c P Q s. (sound P \\<and> sound Q \\<and> 0 \\<le> a \\<and> 0 \\<le> b \\<and> 0 \\<le> c) \\<longrightarrow>\n                  a * t P s + b * t Q s \\<ominus> c\n                  \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s)\""], ["", "lemma sublinearI[intro]:\n  \"\\<lbrakk> \\<And>a b c P Q s. \\<lbrakk> sound P; sound Q; 0 \\<le> a; 0 \\<le> b; 0 \\<le> c \\<rbrakk> \\<Longrightarrow>\n     a * t P s + b * t Q s \\<ominus> c \\<le>\n     t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s \\<rbrakk> \\<Longrightarrow> sublinear t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b c P Q s.\n        \\<lbrakk>sound P; sound Q; 0 \\<le> a; 0 \\<le> b; 0 \\<le> c\\<rbrakk>\n        \\<Longrightarrow> a * t P s + b * t Q s \\<ominus> c\n                          \\<le> t (\\<lambda>s'.\na * P s' + b * Q s' \\<ominus> c)\n                                 s) \\<Longrightarrow>\n    sublinear t", "by(simp add:sublinear_def)"], ["", "lemma sublinearD[dest]:\n  \"\\<lbrakk> sublinear t; sound P; sound Q; 0 \\<le> a; 0 \\<le> b; 0 \\<le> c \\<rbrakk> \\<Longrightarrow>\n   a * t P s + b * t Q s \\<ominus> c \\<le>\n   t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sublinear t; sound P; sound Q; 0 \\<le> a; 0 \\<le> b;\n     0 \\<le> c\\<rbrakk>\n    \\<Longrightarrow> a * t P s + b * t Q s \\<ominus> c\n                      \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c)\n                             s", "by(simp add:sublinear_def)"], ["", "text \\<open>It is easier to see the relevance of sublinearity by breaking it into several component\nproperties, as in the following sections.\\<close>"], ["", "subsubsection \\<open>Sub-additivity\\<close>"], ["", "text_raw \\<open>\\label{s:subadd}\\<close>"], ["", "definition sub_add ::\n  \"(('s \\<Rightarrow> real) \\<Rightarrow> ('s \\<Rightarrow> real)) \\<Rightarrow> bool\"\nwhere\n  \"sub_add t \\<longleftrightarrow> (\\<forall>P Q s. (sound P \\<and> sound Q) \\<longrightarrow>\n                t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s)\""], ["", "text \\<open>\n\\begin{figure}\n\\begin{center}\n\\begin{displaymath}\n\\begin{xy}\n0;<1cm,0cm>:\n(-0.25,0); (10,0) **\\dir{-} *\\dir{>},\n(0,-0.25); (0,6) **\\dir{-} *\\dir{>},\n(0.1,5.5)=\"Ps\";  (9.9,1.5)=\"Pe\"  **\\dir{-} ?(0.1)+<0em,1em> *{P},\n(0.1,4.0)=\"tPs\"; (9.9,1.0)=\"tPe\" **\\dir{} ?(0.1)+<0em,1em> *{tP},\n(0.1,0.5)=\"uPs\"; (9.9,5.0)=\"uPe\" **\\dir{} ?(0.9)+<0em,1em> *{uP}\n?!{\"tPs\";\"tPe\"}=\"inter\";\n    \"tPs\" **\\dir{--}, \"uPe\" **\\dir{--},\n    \"tPe\" **\\dir{-}, \"uPs\" **\\dir{-} ?(0.5)+<0em,1.5em> *{Q=tP \\sqcap uP},\n(1,0)=\"x\"; \"x\"-<0em,1em>*{x};\n\"x\"; (1,6) **{}, ?!{\"uPs\";\"uPe\"}=\"uPx\" *{\\bullet} -<0em,1em>*{Q(x)},\n(9,0)=\"y\"; \"y\"-<0em,1em>*{y};\n\"y\"; (9,6) **{}, ?!{\"tPs\";\"tPe\"}=\"tPy\" *{\\bullet} -<0em,1em>*{Q(y)},\n\"uPx\"; \"tPy\" **\\dir{.},\n(5,0)=\"xy\"; (5,6) **{},\n    ?!{\"tPs\";\"tPe\"}=\"tPxy\" *{\\bullet} -<0em,1.5em>*{Q(\\frac{x+y}{2})},\n    ?!{\"uPx\";\"tPy\"}=\"tPuP\" *{\\bullet} -<0em,1em>*{\\frac{Q(x)+Q(y)}{2}},\n\\end{xy}\n\\end{displaymath}\n\\end{center}\n\\caption{\\label{f:subadd_plot}A graphical depiction of sub-additivity as convexity.}\n\\end{figure}\n\\<close>"], ["", "text \\<open>Sub-additivity, together with scaling (\\autoref{s:scaling}) gives the \\emph{linear} portion\nof sublinearity. Together, these two properties are equivalent to \\emph{convexity}, as\n\\autoref{f:subadd_plot} illustrates by analogy.\n\nHere $P$ is an affine function (expectation) @{typ \"real \\<Rightarrow> real\"}, restricted to some finite\ninterval. In practice the state space (the left-hand type) is typically discrete and\nmulti-dimensional, but on the reals we have a convenient geometrical intuition. The lines $tP$ and\n$uP$ represent the effect of two healthy transformers (again affine). Neither monotonicity nor\nscaling are represented, but both are feasible: Both lines are bounded above by the greatest value\nof $P$.\n\nThe curve $Q$ is the pointwise minimum of $tP$ and $tQ$, written $tP \\sqcap tQ$.  This is, not\ncoincidentally, the syntax for a binary nondeterministic choice in pGCL: The probability that some\nproperty is established by the choice between programs $a$ and $b$ cannot be guaranteed to be any\nhigher than either the probability under $a$, or that under $b$.\n\nThe original curve, $P$, is trivially convex---it is linear.  Also, both $t$ and $u$, and the\noperator $\\sqcap$ preserve convexity.  A probabilistic choice will also preserve it.  The\npreservation of convexity is a property of sub-additive transformers that respect scaling.  Note\nthe form of the definition of convexity:\n\\begin{displaymath}\n\\forall x,y. \\frac{Q(x) + Q(y)}{2} \\le Q(\\frac{x+y}{2})\n\\end{displaymath}\nWere we to replace $Q$ by some sub-additive transformer $v$, and $x$ and $y$ by expectations $R$\nand $S$, the equivalent expression:\n\\begin{displaymath}\n\\frac{vR + vS}{2} \\le v(\\frac{R+S}{2})\n\\end{displaymath}\nCan be rewritten, using scaling, to:\n\\begin{displaymath}\n\\frac{1}{2}(vR + vS) \\le \\frac{1}{2}v(R+S)\n\\end{displaymath}\nWhich holds everywhere exactly when $v$ is sub-additive i.e.:\n\\begin{displaymath}\nvR + vS \\le v(R+S)\n\\end{displaymath}\n\\<close>"], ["", "lemma sub_addI[intro]:\n  \"\\<lbrakk> \\<And>P Q s. \\<lbrakk> sound P; sound Q \\<rbrakk> \\<Longrightarrow>\n             t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s \\<rbrakk> \\<Longrightarrow> sub_add t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q s.\n        \\<lbrakk>sound P; sound Q\\<rbrakk>\n        \\<Longrightarrow> t P s + t Q s\n                          \\<le> t (\\<lambda>s'. P s' + Q s')\n                                 s) \\<Longrightarrow>\n    sub_add t", "by(simp add:sub_add_def)"], ["", "lemma sub_addI2:\n  \"\\<lbrakk>\\<And>P Q. \\<lbrakk> sound P; sound Q \\<rbrakk> \\<Longrightarrow>\n          \\<lambda>s. t P s + t Q s \\<tturnstile> t (\\<lambda>s. P s + Q s)\\<rbrakk> \\<Longrightarrow>\n   sub_add t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>sound P; sound Q\\<rbrakk>\n        \\<Longrightarrow> \\<lambda>s.\n                             t P s +\n                             t Q s \\<tturnstile> t\n            (\\<lambda>s. P s + Q s)) \\<Longrightarrow>\n    sub_add t", "by(auto)"], ["", "lemma sub_addD[dest]:\n  \"\\<lbrakk> sub_add t; sound P; sound Q \\<rbrakk> \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sub_add t; sound P; sound Q\\<rbrakk>\n    \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "by(simp add:sub_add_def)"], ["", "lemma equiv_sub_add:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes eq: \"equiv_trans t u\"\n      and sa: \"sub_add t\"\n  shows \"sub_add u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub_add u", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> u P s + u Q s \\<le> u (\\<lambda>s'. P s' + Q s') s", "fix P::\"'s \\<Rightarrow> real\" and Q::\"'s \\<Rightarrow> real\" and s::\"'s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> u P s + u Q s \\<le> u (\\<lambda>s'. P s' + Q s') s", "assume sP: \"sound P\" and sQ: \"sound Q\""], ["proof (state)\nthis:\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> u P s + u Q s \\<le> u (\\<lambda>s'. P s' + Q s') s", "with eq"], ["proof (chain)\npicking this:\n  equiv_trans t u\n  sound P\n  sound Q", "have \"u P s + u Q s = t P s + t Q s\""], ["proof (prove)\nusing this:\n  equiv_trans t u\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. u P s + u Q s = t P s + t Q s", "by(simp add:equiv_transD)"], ["proof (state)\nthis:\n  u P s + u Q s = t P s + t Q s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> u P s + u Q s \\<le> u (\\<lambda>s'. P s' + Q s') s", "also"], ["proof (state)\nthis:\n  u P s + u Q s = t P s + t Q s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> u P s + u Q s \\<le> u (\\<lambda>s'. P s' + Q s') s", "from sP sQ sa"], ["proof (chain)\npicking this:\n  sound P\n  sound Q\n  sub_add t", "have \"t P s + t Q s \\<le> t (\\<lambda>s. P s + Q s) s\""], ["proof (prove)\nusing this:\n  sound P\n  sound Q\n  sub_add t\n\ngoal (1 subgoal):\n 1. t P s + t Q s \\<le> t (\\<lambda>s. P s + Q s) s", "by(auto)"], ["proof (state)\nthis:\n  t P s + t Q s \\<le> t (\\<lambda>s. P s + Q s) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> u P s + u Q s \\<le> u (\\<lambda>s'. P s' + Q s') s", "also"], ["proof (state)\nthis:\n  t P s + t Q s \\<le> t (\\<lambda>s. P s + Q s) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> u P s + u Q s \\<le> u (\\<lambda>s'. P s' + Q s') s", "{"], ["proof (state)\nthis:\n  t P s + t Q s \\<le> t (\\<lambda>s. P s + Q s) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> u P s + u Q s \\<le> u (\\<lambda>s'. P s' + Q s') s", "from sP sQ"], ["proof (chain)\npicking this:\n  sound P\n  sound Q", "have \"sound (\\<lambda>s. P s + Q s)\""], ["proof (prove)\nusing this:\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. sound (\\<lambda>s. P s + Q s)", "by(auto)"], ["proof (state)\nthis:\n  sound (\\<lambda>s. P s + Q s)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> u P s + u Q s \\<le> u (\\<lambda>s'. P s' + Q s') s", "with eq"], ["proof (chain)\npicking this:\n  equiv_trans t u\n  sound (\\<lambda>s. P s + Q s)", "have \"t (\\<lambda>s. P s + Q s) s = u (\\<lambda>s. P s + Q s) s\""], ["proof (prove)\nusing this:\n  equiv_trans t u\n  sound (\\<lambda>s. P s + Q s)\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. P s + Q s) s = u (\\<lambda>s. P s + Q s) s", "by(simp add:equiv_transD)"], ["proof (state)\nthis:\n  t (\\<lambda>s. P s + Q s) s = u (\\<lambda>s. P s + Q s) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> u P s + u Q s \\<le> u (\\<lambda>s'. P s' + Q s') s", "}"], ["proof (state)\nthis:\n  t (\\<lambda>s. P s + Q s) s = u (\\<lambda>s. P s + Q s) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> u P s + u Q s \\<le> u (\\<lambda>s'. P s' + Q s') s", "finally"], ["proof (chain)\npicking this:\n  u P s + u Q s \\<le> u (\\<lambda>s. P s + Q s) s", "show \"u P s + u Q s \\<le> u (\\<lambda>s. P s + Q s) s\""], ["proof (prove)\nusing this:\n  u P s + u Q s \\<le> u (\\<lambda>s. P s + Q s) s\n\ngoal (1 subgoal):\n 1. u P s + u Q s \\<le> u (\\<lambda>s. P s + Q s) s", "."], ["proof (state)\nthis:\n  u P s + u Q s \\<le> u (\\<lambda>s. P s + Q s) s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Sublinearity and feasibility imply sub-additivity.\\<close>"], ["", "lemma sublinear_subadd:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes slt: \"sublinear t\"\n      and ft:  \"feasible t\"\n  shows \"sub_add t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub_add t", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "fix P::\"'s \\<Rightarrow> real\" and Q::\"'s \\<Rightarrow> real\" and s::'s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "assume sP: \"sound P\" and sQ: \"sound Q\""], ["proof (state)\nthis:\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "with ft"], ["proof (chain)\npicking this:\n  feasible t\n  sound P\n  sound Q", "have \"sound (t P)\" \"sound (t Q)\""], ["proof (prove)\nusing this:\n  feasible t\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. sound (t P) &&& sound (t Q)", "by(auto)"], ["proof (state)\nthis:\n  sound (t P)\n  sound (t Q)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "hence \"0 \\<le> t P s\" and \"0 \\<le> t Q s\""], ["proof (prove)\nusing this:\n  sound (t P)\n  sound (t Q)\n\ngoal (1 subgoal):\n 1. 0 \\<le> t P s &&& 0 \\<le> t Q s", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> t P s\n  0 \\<le> t Q s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "hence \"0 \\<le> t P s + t Q s\""], ["proof (prove)\nusing this:\n  0 \\<le> t P s\n  0 \\<le> t Q s\n\ngoal (1 subgoal):\n 1. 0 \\<le> t P s + t Q s", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> t P s + t Q s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "hence \"... = ...\\<ominus> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> t P s + t Q s\n\ngoal (1 subgoal):\n 1. t P s + t Q s = t P s + t Q s \\<ominus> 0", "by(simp)"], ["proof (state)\nthis:\n  t P s + t Q s = t P s + t Q s \\<ominus> 0\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "also"], ["proof (state)\nthis:\n  t P s + t Q s = t P s + t Q s \\<ominus> 0\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "from sP sQ"], ["proof (chain)\npicking this:\n  sound P\n  sound Q", "have \"... \\<le> t (\\<lambda>s. P s + Q s \\<ominus> 0) s\""], ["proof (prove)\nusing this:\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. t P s + t Q s \\<ominus> 0 \\<le> t (\\<lambda>s. P s + Q s \\<ominus> 0) s", "by(rule sublinearD[OF slt, where a=1 and b=1 and c=0, simplified])"], ["proof (state)\nthis:\n  t P s + t Q s \\<ominus> 0 \\<le> t (\\<lambda>s. P s + Q s \\<ominus> 0) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "also"], ["proof (state)\nthis:\n  t P s + t Q s \\<ominus> 0 \\<le> t (\\<lambda>s. P s + Q s \\<ominus> 0) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "{"], ["proof (state)\nthis:\n  t P s + t Q s \\<ominus> 0 \\<le> t (\\<lambda>s. P s + Q s \\<ominus> 0) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "from sP sQ"], ["proof (chain)\npicking this:\n  sound P\n  sound Q", "have \"\\<And>s. 0 \\<le> P s\" and \"\\<And>s. 0 \\<le> Q s\""], ["proof (prove)\nusing this:\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. (\\<And>s. 0 \\<le> P s) &&& (\\<And>s. 0 \\<le> Q s)", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> P ?s\n  0 \\<le> Q ?s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "hence \"\\<And>s. 0 \\<le> P s + Q s\""], ["proof (prove)\nusing this:\n  0 \\<le> P ?s\n  0 \\<le> Q ?s\n\ngoal (1 subgoal):\n 1. \\<And>s. 0 \\<le> P s + Q s", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> P ?s + Q ?s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "hence \"t (\\<lambda>s. P s + Q s \\<ominus> 0) s = t (\\<lambda>s. P s + Q s) s\""], ["proof (prove)\nusing this:\n  0 \\<le> P ?s + Q ?s\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. P s + Q s \\<ominus> 0) s = t (\\<lambda>s. P s + Q s) s", "by(simp)"], ["proof (state)\nthis:\n  t (\\<lambda>s. P s + Q s \\<ominus> 0) s = t (\\<lambda>s. P s + Q s) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "}"], ["proof (state)\nthis:\n  t (\\<lambda>s. P s + Q s \\<ominus> 0) s = t (\\<lambda>s. P s + Q s) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P s + t Q s \\<le> t (\\<lambda>s'. P s' + Q s') s", "finally"], ["proof (chain)\npicking this:\n  t P s + t Q s \\<le> t (\\<lambda>s. P s + Q s) s", "show \"t P s + t Q s \\<le> t (\\<lambda>s. P s + Q s) s\""], ["proof (prove)\nusing this:\n  t P s + t Q s \\<le> t (\\<lambda>s. P s + Q s) s\n\ngoal (1 subgoal):\n 1. t P s + t Q s \\<le> t (\\<lambda>s. P s + Q s) s", "."], ["proof (state)\nthis:\n  t P s + t Q s \\<le> t (\\<lambda>s. P s + Q s) s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A few properties following from sub-additivity:\\<close>"], ["", "lemma standard_negate:\n  assumes ht: \"healthy t\"\n      and sat: \"sub_add t\"\n  shows \"t \\<guillemotleft>P\\<guillemotright> s + t \\<guillemotleft>\\<N> P\\<guillemotright> s \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s\n    \\<le> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s\n    \\<le> 1", "from sat"], ["proof (chain)\npicking this:\n  sub_add t", "have \"t \\<guillemotleft>P\\<guillemotright> s + t \\<guillemotleft>\\<N> P\\<guillemotright> s \\<le> t (\\<lambda>s. \\<guillemotleft>P\\<guillemotright> s + \\<guillemotleft>\\<N> P\\<guillemotright> s) s\""], ["proof (prove)\nusing this:\n  sub_add t\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s\n    \\<le> t (\\<lambda>s.\n                \\<guillemotleft> P \\<guillemotright> s +\n                \\<guillemotleft> \\<N> P \\<guillemotright> s)\n           s", "by(auto)"], ["proof (state)\nthis:\n  t \\<guillemotleft> P \\<guillemotright> s +\n  t \\<guillemotleft> \\<N> P \\<guillemotright> s\n  \\<le> t (\\<lambda>s.\n              \\<guillemotleft> P \\<guillemotright> s +\n              \\<guillemotleft> \\<N> P \\<guillemotright> s)\n         s\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s\n    \\<le> 1", "also"], ["proof (state)\nthis:\n  t \\<guillemotleft> P \\<guillemotright> s +\n  t \\<guillemotleft> \\<N> P \\<guillemotright> s\n  \\<le> t (\\<lambda>s.\n              \\<guillemotleft> P \\<guillemotright> s +\n              \\<guillemotleft> \\<N> P \\<guillemotright> s)\n         s\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s\n    \\<le> 1", "have \"... = t (\\<lambda>s. 1) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t (\\<lambda>s.\n          \\<guillemotleft> P \\<guillemotright> s +\n          \\<guillemotleft> \\<N> P \\<guillemotright> s)\n     s =\n    t (\\<lambda>s. 1) s", "by(simp add:negate_embed)"], ["proof (state)\nthis:\n  t (\\<lambda>s.\n        \\<guillemotleft> P \\<guillemotright> s +\n        \\<guillemotleft> \\<N> P \\<guillemotright> s)\n   s =\n  t (\\<lambda>s. 1) s\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s\n    \\<le> 1", "also"], ["proof (state)\nthis:\n  t (\\<lambda>s.\n        \\<guillemotleft> P \\<guillemotright> s +\n        \\<guillemotleft> \\<N> P \\<guillemotright> s)\n   s =\n  t (\\<lambda>s. 1) s\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s\n    \\<le> 1", "{"], ["proof (state)\nthis:\n  t (\\<lambda>s.\n        \\<guillemotleft> P \\<guillemotright> s +\n        \\<guillemotleft> \\<N> P \\<guillemotright> s)\n   s =\n  t (\\<lambda>s. 1) s\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s\n    \\<le> 1", "from ht"], ["proof (chain)\npicking this:\n  healthy t", "have \"bounded_by 1 (t (\\<lambda>s. 1))\""], ["proof (prove)\nusing this:\n  healthy t\n\ngoal (1 subgoal):\n 1. bounded_by 1 (t (\\<lambda>s. 1))", "by(auto)"], ["proof (state)\nthis:\n  bounded_by 1 (t (\\<lambda>s. 1))\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s\n    \\<le> 1", "hence \"t (\\<lambda>s. 1) s \\<le> 1\""], ["proof (prove)\nusing this:\n  bounded_by 1 (t (\\<lambda>s. 1))\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. 1) s \\<le> 1", "by(auto)"], ["proof (state)\nthis:\n  t (\\<lambda>s. 1) s \\<le> 1\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s\n    \\<le> 1", "}"], ["proof (state)\nthis:\n  t (\\<lambda>s. 1) s \\<le> 1\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s\n    \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  t \\<guillemotleft> P \\<guillemotright> s +\n  t \\<guillemotleft> \\<N> P \\<guillemotright> s\n  \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<guillemotleft> P \\<guillemotright> s +\n  t \\<guillemotleft> \\<N> P \\<guillemotright> s\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s\n    \\<le> 1", "."], ["proof (state)\nthis:\n  t \\<guillemotleft> P \\<guillemotright> s +\n  t \\<guillemotleft> \\<N> P \\<guillemotright> s\n  \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sub_add_sum:\n  fixes t::\"'s trans\" and S::\"'a set\"\n  assumes sat: \"sub_add t\"\n      and ht: \"healthy t\"\n      and sP: \"\\<And>x. sound (P x)\"\n  shows \"(\\<lambda>x. \\<Sum>y\\<in>S. t (P y) x) \\<le> t (\\<lambda>x. \\<Sum>y\\<in>S. P y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>x.\n       \\<Sum>y\\<in>S.\n         t (P y) x \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>S. P y x)", "proof(cases \"infinite S\", simp_all add:ht)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    \\<lambda>x.\n       \\<Sum>y\\<in>S.\n         t (P y) x \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>S. P y x)", "assume fS: \"finite S\""], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    \\<lambda>x.\n       \\<Sum>y\\<in>S.\n         t (P y) x \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>S. P y x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>x.\n       \\<Sum>y\\<in>S.\n         t (P y) x \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>S. P y x)", "proof(rule finite_induct[OF fS le_funI le_funI], simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<le> t (\\<lambda>x. 0) x\n 2. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lambda>a.\n           \\<Sum>y\\<in>F.\n             t (P y)\n              a \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>F. P y x)\\<rbrakk>\n       \\<Longrightarrow> t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa)\n                         \\<le> t (\\<lambda>xa.\n                                     P x xa + (\\<Sum>y\\<in>F. P y xa))\n                                xa", "fix s::'s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<le> t (\\<lambda>x. 0) x\n 2. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lambda>a.\n           \\<Sum>y\\<in>F.\n             t (P y)\n              a \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>F. P y x)\\<rbrakk>\n       \\<Longrightarrow> t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa)\n                         \\<le> t (\\<lambda>xa.\n                                     P x xa + (\\<Sum>y\\<in>F. P y xa))\n                                xa", "from ht"], ["proof (chain)\npicking this:\n  healthy t", "have \"sound (t (\\<lambda>s. 0))\""], ["proof (prove)\nusing this:\n  healthy t\n\ngoal (1 subgoal):\n 1. sound (t (\\<lambda>s. 0))", "by(auto)"], ["proof (state)\nthis:\n  sound (t (\\<lambda>s. 0))\n\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<le> t (\\<lambda>x. 0) x\n 2. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lambda>a.\n           \\<Sum>y\\<in>F.\n             t (P y)\n              a \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>F. P y x)\\<rbrakk>\n       \\<Longrightarrow> t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa)\n                         \\<le> t (\\<lambda>xa.\n                                     P x xa + (\\<Sum>y\\<in>F. P y xa))\n                                xa", "thus \"0 \\<le> t (\\<lambda>s. 0) s\""], ["proof (prove)\nusing this:\n  sound (t (\\<lambda>s. 0))\n\ngoal (1 subgoal):\n 1. 0 \\<le> t (\\<lambda>s. 0) s", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> t (\\<lambda>s. 0) s\n\ngoal (1 subgoal):\n 1. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lambda>a.\n           \\<Sum>y\\<in>F.\n             t (P y)\n              a \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>F. P y x)\\<rbrakk>\n       \\<Longrightarrow> t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa)\n                         \\<le> t (\\<lambda>xa.\n                                     P x xa + (\\<Sum>y\\<in>F. P y xa))\n                                xa", "fix F::\"'a set\" and x::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lambda>a.\n           \\<Sum>y\\<in>F.\n             t (P y)\n              a \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>F. P y x)\\<rbrakk>\n       \\<Longrightarrow> t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa)\n                         \\<le> t (\\<lambda>xa.\n                                     P x xa + (\\<Sum>y\\<in>F. P y xa))\n                                xa", "assume IH: \"\\<lambda>a. \\<Sum>y\\<in>F. t (P y) a \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>F. P y x)\""], ["proof (state)\nthis:\n  \\<lambda>a.\n     \\<Sum>y\\<in>F.\n       t (P y) a \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>F. P y x)\n\ngoal (1 subgoal):\n 1. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lambda>a.\n           \\<Sum>y\\<in>F.\n             t (P y)\n              a \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>F. P y x)\\<rbrakk>\n       \\<Longrightarrow> t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa)\n                         \\<le> t (\\<lambda>xa.\n                                     P x xa + (\\<Sum>y\\<in>F. P y xa))\n                                xa", "hence \"t (P x) s + (\\<Sum>y\\<in>F. t (P y) s) \\<le>\n           t (P x) s + t (\\<lambda>x. \\<Sum>y\\<in>F. P y x) s\""], ["proof (prove)\nusing this:\n  \\<lambda>a.\n     \\<Sum>y\\<in>F.\n       t (P y) a \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>F. P y x)\n\ngoal (1 subgoal):\n 1. t (P x) s + (\\<Sum>y\\<in>F. t (P y) s)\n    \\<le> t (P x) s + t (\\<lambda>x. \\<Sum>y\\<in>F. P y x) s", "by(auto intro:add_left_mono)"], ["proof (state)\nthis:\n  t (P x) s + (\\<Sum>y\\<in>F. t (P y) s)\n  \\<le> t (P x) s + t (\\<lambda>x. \\<Sum>y\\<in>F. P y x) s\n\ngoal (1 subgoal):\n 1. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lambda>a.\n           \\<Sum>y\\<in>F.\n             t (P y)\n              a \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>F. P y x)\\<rbrakk>\n       \\<Longrightarrow> t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa)\n                         \\<le> t (\\<lambda>xa.\n                                     P x xa + (\\<Sum>y\\<in>F. P y xa))\n                                xa", "also"], ["proof (state)\nthis:\n  t (P x) s + (\\<Sum>y\\<in>F. t (P y) s)\n  \\<le> t (P x) s + t (\\<lambda>x. \\<Sum>y\\<in>F. P y x) s\n\ngoal (1 subgoal):\n 1. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lambda>a.\n           \\<Sum>y\\<in>F.\n             t (P y)\n              a \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>F. P y x)\\<rbrakk>\n       \\<Longrightarrow> t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa)\n                         \\<le> t (\\<lambda>xa.\n                                     P x xa + (\\<Sum>y\\<in>F. P y xa))\n                                xa", "from sat sP"], ["proof (chain)\npicking this:\n  sub_add t\n  sound (P ?x)", "have \"... \\<le> t (\\<lambda>xa. P x xa + (\\<Sum>y\\<in>F. P y xa)) s\""], ["proof (prove)\nusing this:\n  sub_add t\n  sound (P ?x)\n\ngoal (1 subgoal):\n 1. t (P x) s + t (\\<lambda>x. \\<Sum>y\\<in>F. P y x) s\n    \\<le> t (\\<lambda>xa. P x xa + (\\<Sum>y\\<in>F. P y xa)) s", "by(auto intro!:sub_addD[OF sat] sum_sound)"], ["proof (state)\nthis:\n  t (P x) s + t (\\<lambda>x. \\<Sum>y\\<in>F. P y x) s\n  \\<le> t (\\<lambda>xa. P x xa + (\\<Sum>y\\<in>F. P y xa)) s\n\ngoal (1 subgoal):\n 1. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lambda>a.\n           \\<Sum>y\\<in>F.\n             t (P y)\n              a \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>F. P y x)\\<rbrakk>\n       \\<Longrightarrow> t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa)\n                         \\<le> t (\\<lambda>xa.\n                                     P x xa + (\\<Sum>y\\<in>F. P y xa))\n                                xa", "finally"], ["proof (chain)\npicking this:\n  t (P x) s + (\\<Sum>y\\<in>F. t (P y) s)\n  \\<le> t (\\<lambda>xa. P x xa + (\\<Sum>y\\<in>F. P y xa)) s", "show \"t (P x) s + (\\<Sum>y\\<in>F. t (P y) s) \\<le>\n          t (\\<lambda>xa. P x xa + (\\<Sum>y\\<in>F. P y xa)) s\""], ["proof (prove)\nusing this:\n  t (P x) s + (\\<Sum>y\\<in>F. t (P y) s)\n  \\<le> t (\\<lambda>xa. P x xa + (\\<Sum>y\\<in>F. P y xa)) s\n\ngoal (1 subgoal):\n 1. t (P x) s + (\\<Sum>y\\<in>F. t (P y) s)\n    \\<le> t (\\<lambda>xa. P x xa + (\\<Sum>y\\<in>F. P y xa)) s", "."], ["proof (state)\nthis:\n  t (P x) s + (\\<Sum>y\\<in>F. t (P y) s)\n  \\<le> t (\\<lambda>xa. P x xa + (\\<Sum>y\\<in>F. P y xa)) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lambda>x.\n     \\<Sum>y\\<in>S.\n       t (P y) x \\<tturnstile> t (\\<lambda>x. \\<Sum>y\\<in>S. P y x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sub_add_guard_split:\n  fixes t::\"'s::finite trans\" and P::\"'s expect\" and s::'s\n  assumes sat: \"sub_add t\"\n      and ht: \"healthy t\"\n      and sP: \"sound P\"\n  shows \"(\\<Sum>y\\<in>{s. G s}.  P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n         (\\<Sum>y\\<in>{s. \\<not>G s}. P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) \\<le> t P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "have \"{s. G s} \\<inter> {s. \\<not>G s} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. G s} \\<inter> {s. \\<not> G s} = {}", "by(blast)"], ["proof (state)\nthis:\n  {s. G s} \\<inter> {s. \\<not> G s} = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "hence \"(\\<Sum>y\\<in>{s. G s}.  P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n         (\\<Sum>y\\<in>{s. \\<not>G s}. P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n         (\\<Sum>y\\<in>({s. G s} \\<union> {s. \\<not>G s}). P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\""], ["proof (prove)\nusing this:\n  {s. G s} \\<inter> {s. \\<not> G s} = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n    (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)", "by(auto intro: sum.union_disjoint[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{s. G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n  (\\<Sum>y\\<in>{s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n  (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{s. G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n  (\\<Sum>y\\<in>{s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n  (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "{"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{s. G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n  (\\<Sum>y\\<in>{s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n  (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "have \"{s. G s} \\<union> {s. \\<not>G s} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. G s} \\<union> {s. \\<not> G s} = UNIV", "by (blast)"], ["proof (state)\nthis:\n  {s. G s} \\<union> {s. \\<not> G s} = UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "hence \"(\\<Sum>y\\<in>({s. G s} \\<union> {s. \\<not>G s}). P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n           (\\<lambda>x. \\<Sum>y\\<in>UNIV. P y * t (\\<lambda>x. \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) x) s\""], ["proof (prove)\nusing this:\n  {s. G s} \\<union> {s. \\<not> G s} = UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)", "by(simp)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "}"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "{"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "from sP"], ["proof (chain)\npicking this:\n  sound P", "have \"\\<And>y. 0 \\<le> P y\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>y. 0 \\<le> P y", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> P ?y\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "with healthy_scalingD[OF ht]"], ["proof (chain)\npicking this:\n  scaling t\n  0 \\<le> P ?y", "have \"(\\<lambda>x. \\<Sum>y\\<in>UNIV. P y * t (\\<lambda>x. \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) x) s =\n          (\\<lambda>x. \\<Sum>y\\<in>UNIV. t (\\<lambda>x. P y * \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) x) s\""], ["proof (prove)\nusing this:\n  scaling t\n  0 \\<le> P ?y\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n    (\\<Sum>y\\<in>UNIV.\n       t (\\<lambda>x.\n             P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n        s)", "by(simp add:scalingD)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n  (\\<Sum>y\\<in>UNIV.\n     t (\\<lambda>x.\n           P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n      s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "}"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n  (\\<Sum>y\\<in>UNIV.\n     t (\\<lambda>x.\n           P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n      s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n  (\\<Sum>y\\<in>UNIV.\n     t (\\<lambda>x.\n           P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n      s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "{"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) =\n  (\\<Sum>y\\<in>UNIV.\n     t (\\<lambda>x.\n           P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n      s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "from sat ht sP"], ["proof (chain)\npicking this:\n  sub_add t\n  healthy t\n  sound P", "have \"(\\<lambda>x. \\<Sum>y\\<in>UNIV. t (\\<lambda>x. P y * \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) x) \\<le>\n          t (\\<lambda>x. \\<Sum>y\\<in>UNIV. P y * \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x)\""], ["proof (prove)\nusing this:\n  sub_add t\n  healthy t\n  sound P\n\ngoal (1 subgoal):\n 1. \\<lambda>x.\n       \\<Sum>y\\<in>UNIV.\n         t (\\<lambda>x.\n               P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n          x \\<tturnstile> t (\\<lambda>x.\n                                \\<Sum>y\\<in>UNIV.\n                                  P y *\n                                  \\<guillemotleft> \\<lambda>z.\n                z = y \\<guillemotright>\n                                   x)", "by(intro sub_add_sum sound_intros, auto)"], ["proof (state)\nthis:\n  \\<lambda>x.\n     \\<Sum>y\\<in>UNIV.\n       t (\\<lambda>x.\n             P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n        x \\<tturnstile> t (\\<lambda>x.\n                              \\<Sum>y\\<in>UNIV.\n                                P y *\n                                \\<guillemotleft> \\<lambda>z.\n              z = y \\<guillemotright>\n                                 x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "hence \"(\\<lambda>x. \\<Sum>y\\<in>UNIV. t (\\<lambda>x. P y * \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) x) s \\<le>\n          t (\\<lambda>x. \\<Sum>y\\<in>UNIV. P y * \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) s\""], ["proof (prove)\nusing this:\n  \\<lambda>x.\n     \\<Sum>y\\<in>UNIV.\n       t (\\<lambda>x.\n             P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n        x \\<tturnstile> t (\\<lambda>x.\n                              \\<Sum>y\\<in>UNIV.\n                                P y *\n                                \\<guillemotleft> \\<lambda>z.\n              z = y \\<guillemotright>\n                                 x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>UNIV.\n       t (\\<lambda>x.\n             P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n        s)\n    \\<le> t (\\<lambda>x.\n                \\<Sum>y\\<in>UNIV.\n                  P y *\n                  \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n           s", "by(auto)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     t (\\<lambda>x.\n           P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n      s)\n  \\<le> t (\\<lambda>x.\n              \\<Sum>y\\<in>UNIV.\n                P y *\n                \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n         s\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "}"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     t (\\<lambda>x.\n           P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n      s)\n  \\<le> t (\\<lambda>x.\n              \\<Sum>y\\<in>UNIV.\n                P y *\n                \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n         s\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     t (\\<lambda>x.\n           P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n      s)\n  \\<le> t (\\<lambda>x.\n              \\<Sum>y\\<in>UNIV.\n                P y *\n                \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n         s\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "{"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     t (\\<lambda>x.\n           P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n      s)\n  \\<le> t (\\<lambda>x.\n              \\<Sum>y\\<in>UNIV.\n                P y *\n                \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n         s\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "have rw1: \"(\\<lambda>x. \\<Sum>y\\<in>UNIV. P y * \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) =\n               (\\<lambda>x. \\<Sum>y\\<in>UNIV. if y = x then P y else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) =\n    (\\<lambda>x. \\<Sum>y\\<in>UNIV. if y = x then P y else 0)", "by (rule ext [OF sum.cong]) auto"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      \\<Sum>y\\<in>UNIV.\n        P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) =\n  (\\<lambda>x. \\<Sum>y\\<in>UNIV. if y = x then P y else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "also"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      \\<Sum>y\\<in>UNIV.\n        P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) =\n  (\\<lambda>x. \\<Sum>y\\<in>UNIV. if y = x then P y else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "from sP"], ["proof (chain)\npicking this:\n  sound P", "have \"... \\<tturnstile> P\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<lambda>x. \\<Sum>y\\<in>UNIV. if y = x then P y else 0 \\<tturnstile> P", "by(cases \"finite (UNIV::'s set)\", auto simp:sum.delta)"], ["proof (state)\nthis:\n  \\<lambda>x. \\<Sum>y\\<in>UNIV. if y = x then P y else 0 \\<tturnstile> P\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "finally"], ["proof (chain)\npicking this:\n  \\<lambda>x.\n     \\<Sum>y\\<in>UNIV.\n       P y *\n       \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright>\n        x \\<tturnstile> P", "have leP: \"\\<lambda>x. \\<Sum>y\\<in>UNIV. P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x \\<tturnstile> P\""], ["proof (prove)\nusing this:\n  \\<lambda>x.\n     \\<Sum>y\\<in>UNIV.\n       P y *\n       \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright>\n        x \\<tturnstile> P\n\ngoal (1 subgoal):\n 1. \\<lambda>x.\n       \\<Sum>y\\<in>UNIV.\n         P y *\n         \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright>\n          x \\<tturnstile> P", "."], ["proof (state)\nthis:\n  \\<lambda>x.\n     \\<Sum>y\\<in>UNIV.\n       P y *\n       \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright>\n        x \\<tturnstile> P\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "moreover"], ["proof (state)\nthis:\n  \\<lambda>x.\n     \\<Sum>y\\<in>UNIV.\n       P y *\n       \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright>\n        x \\<tturnstile> P\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "have \"sound (\\<lambda>x. \\<Sum>y\\<in>UNIV. P y * \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound\n     (\\<lambda>x.\n         \\<Sum>y\\<in>UNIV.\n           P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "proof(intro soundI2 bounded_byI nnegI sum_nonneg ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n       \\<le> ?b\n 2. \\<And>x xa.\n       xa \\<in> UNIV \\<Longrightarrow>\n       0 \\<le> P xa *\n               \\<guillemotleft> \\<lambda>z. z = xa \\<guillemotright> x", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n       \\<le> ?b\n 2. \\<And>x xa.\n       xa \\<in> UNIV \\<Longrightarrow>\n       0 \\<le> P xa *\n               \\<guillemotleft> \\<lambda>z. z = xa \\<guillemotright> x", "from leP"], ["proof (chain)\npicking this:\n  \\<lambda>x.\n     \\<Sum>y\\<in>UNIV.\n       P y *\n       \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright>\n        x \\<tturnstile> P", "have \"(\\<Sum>y\\<in>UNIV. P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) \\<le> P x\""], ["proof (prove)\nusing this:\n  \\<lambda>x.\n     \\<Sum>y\\<in>UNIV.\n       P y *\n       \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright>\n        x \\<tturnstile> P\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>UNIV.\n       P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n    \\<le> P x", "by(auto)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n  \\<le> P x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n       \\<le> ?b\n 2. \\<And>x xa.\n       xa \\<in> UNIV \\<Longrightarrow>\n       0 \\<le> P xa *\n               \\<guillemotleft> \\<lambda>z. z = xa \\<guillemotright> x", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n  \\<le> P x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n       \\<le> ?b\n 2. \\<And>x xa.\n       xa \\<in> UNIV \\<Longrightarrow>\n       0 \\<le> P xa *\n               \\<guillemotleft> \\<lambda>z. z = xa \\<guillemotright> x", "from sP"], ["proof (chain)\npicking this:\n  sound P", "have \"... \\<le> bound_of P\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. P x \\<le> bound_of P", "by(auto)"], ["proof (state)\nthis:\n  P x \\<le> bound_of P\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n       \\<le> ?b\n 2. \\<And>x xa.\n       xa \\<in> UNIV \\<Longrightarrow>\n       0 \\<le> P xa *\n               \\<guillemotleft> \\<lambda>z. z = xa \\<guillemotright> x", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>UNIV.\n     P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n  \\<le> bound_of P", "show \"(\\<Sum>y\\<in>UNIV. P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) \\<le> bound_of P\""], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>UNIV.\n     P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n  \\<le> bound_of P\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>UNIV.\n       P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n    \\<le> bound_of P", "."], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n  \\<le> bound_of P\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> UNIV \\<Longrightarrow>\n       0 \\<le> P xa *\n               \\<guillemotleft> \\<lambda>z. z = xa \\<guillemotright> x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> UNIV \\<Longrightarrow>\n       0 \\<le> P xa *\n               \\<guillemotleft> \\<lambda>z. z = xa \\<guillemotright> x", "from sP"], ["proof (chain)\npicking this:\n  sound P", "show \"0 \\<le> P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. 0 \\<le> P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x", "by(auto intro:mult_nonneg_nonneg)"], ["proof (state)\nthis:\n  0 \\<le> P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sound\n   (\\<lambda>x.\n       \\<Sum>y\\<in>UNIV.\n         P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "ultimately"], ["proof (chain)\npicking this:\n  \\<lambda>x.\n     \\<Sum>y\\<in>UNIV.\n       P y *\n       \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright>\n        x \\<tturnstile> P\n  sound\n   (\\<lambda>x.\n       \\<Sum>y\\<in>UNIV.\n         P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "have \"t (\\<lambda>x. \\<Sum>y\\<in>UNIV. P y * \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) s \\<le> t P s\""], ["proof (prove)\nusing this:\n  \\<lambda>x.\n     \\<Sum>y\\<in>UNIV.\n       P y *\n       \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright>\n        x \\<tturnstile> P\n  sound\n   (\\<lambda>x.\n       \\<Sum>y\\<in>UNIV.\n         P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n\ngoal (1 subgoal):\n 1. t (\\<lambda>x.\n          \\<Sum>y\\<in>UNIV.\n            P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n     s\n    \\<le> t P s", "using sP"], ["proof (prove)\nusing this:\n  \\<lambda>x.\n     \\<Sum>y\\<in>UNIV.\n       P y *\n       \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright>\n        x \\<tturnstile> P\n  sound\n   (\\<lambda>x.\n       \\<Sum>y\\<in>UNIV.\n         P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n  sound P\n\ngoal (1 subgoal):\n 1. t (\\<lambda>x.\n          \\<Sum>y\\<in>UNIV.\n            P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n     s\n    \\<le> t P s", "by(auto intro:le_funD[OF mono_transD, OF healthy_monoD, OF ht])"], ["proof (state)\nthis:\n  t (\\<lambda>x.\n        \\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n   s\n  \\<le> t P s\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "}"], ["proof (state)\nthis:\n  t (\\<lambda>x.\n        \\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n   s\n  \\<le> t P s\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>{s. G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n  (\\<Sum>y\\<in>{s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n  \\<le> t P s", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>{s. G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n  (\\<Sum>y\\<in>{s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n  \\<le> t P s\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n    \\<le> t P s", "."], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{s. G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s) +\n  (\\<Sum>y\\<in>{s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> s)\n  \\<le> t P s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Sub-distributivity\\<close>"], ["", "definition sub_distrib ::\n  \"(('s \\<Rightarrow> real) \\<Rightarrow> ('s \\<Rightarrow> real)) \\<Rightarrow> bool\"\nwhere\n  \"sub_distrib t \\<longleftrightarrow> (\\<forall>P s. sound P \\<longrightarrow> t P s \\<ominus> 1 \\<le> t (\\<lambda>s'. P s' \\<ominus> 1) s)\""], ["", "lemma sub_distribI[intro]:\n  \"\\<lbrakk> \\<And>P s. sound P \\<Longrightarrow> t P s \\<ominus> 1 \\<le> t (\\<lambda>s'. P s' \\<ominus> 1) s \\<rbrakk> \\<Longrightarrow> sub_distrib t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P s.\n        sound P \\<Longrightarrow>\n        t P s \\<ominus> 1\n        \\<le> t (\\<lambda>s'. P s' \\<ominus> 1) s) \\<Longrightarrow>\n    sub_distrib t", "by(simp add:sub_distrib_def)"], ["", "lemma sub_distribI2:\n  \"\\<lbrakk> \\<And>P. sound P \\<Longrightarrow> \\<lambda>s. t P s \\<ominus> 1 \\<tturnstile> t (\\<lambda>s. P s \\<ominus> 1) \\<rbrakk> \\<Longrightarrow> sub_distrib t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        sound P \\<Longrightarrow>\n        \\<lambda>s.\n           t P s \\<ominus>\n           1 \\<tturnstile> t (\\<lambda>s.\n                                 P s \\<ominus> 1)) \\<Longrightarrow>\n    sub_distrib t", "by(auto)"], ["", "lemma sub_distribD[dest]:\n  \"\\<lbrakk> sub_distrib t; sound P \\<rbrakk> \\<Longrightarrow> t P s \\<ominus> 1 \\<le> t (\\<lambda>s'. P s' \\<ominus> 1) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sub_distrib t; sound P\\<rbrakk>\n    \\<Longrightarrow> t P s \\<ominus> 1\n                      \\<le> t (\\<lambda>s'. P s' \\<ominus> 1) s", "by(simp add:sub_distrib_def)"], ["", "lemma equiv_sub_distrib:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes eq: \"equiv_trans t u\"\n      and sd: \"sub_distrib t\"\n  shows \"sub_distrib u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub_distrib u", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P s.\n       sound P \\<Longrightarrow>\n       u P s \\<ominus> 1 \\<le> u (\\<lambda>s'. P s' \\<ominus> 1) s", "fix P::\"'s \\<Rightarrow> real\" and s::\"'s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P s.\n       sound P \\<Longrightarrow>\n       u P s \\<ominus> 1 \\<le> u (\\<lambda>s'. P s' \\<ominus> 1) s", "assume sP: \"sound P\""], ["proof (state)\nthis:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>P s.\n       sound P \\<Longrightarrow>\n       u P s \\<ominus> 1 \\<le> u (\\<lambda>s'. P s' \\<ominus> 1) s", "with eq"], ["proof (chain)\npicking this:\n  equiv_trans t u\n  sound P", "have \"u P s \\<ominus> 1 = t P s \\<ominus> 1\""], ["proof (prove)\nusing this:\n  equiv_trans t u\n  sound P\n\ngoal (1 subgoal):\n 1. u P s \\<ominus> 1 = t P s \\<ominus> 1", "by(simp add:equiv_transD)"], ["proof (state)\nthis:\n  u P s \\<ominus> 1 = t P s \\<ominus> 1\n\ngoal (1 subgoal):\n 1. \\<And>P s.\n       sound P \\<Longrightarrow>\n       u P s \\<ominus> 1 \\<le> u (\\<lambda>s'. P s' \\<ominus> 1) s", "also"], ["proof (state)\nthis:\n  u P s \\<ominus> 1 = t P s \\<ominus> 1\n\ngoal (1 subgoal):\n 1. \\<And>P s.\n       sound P \\<Longrightarrow>\n       u P s \\<ominus> 1 \\<le> u (\\<lambda>s'. P s' \\<ominus> 1) s", "from sP sd"], ["proof (chain)\npicking this:\n  sound P\n  sub_distrib t", "have \"... \\<le> t (\\<lambda>s. P s \\<ominus> 1) s\""], ["proof (prove)\nusing this:\n  sound P\n  sub_distrib t\n\ngoal (1 subgoal):\n 1. t P s \\<ominus> 1 \\<le> t (\\<lambda>s. P s \\<ominus> 1) s", "by(auto)"], ["proof (state)\nthis:\n  t P s \\<ominus> 1 \\<le> t (\\<lambda>s. P s \\<ominus> 1) s\n\ngoal (1 subgoal):\n 1. \\<And>P s.\n       sound P \\<Longrightarrow>\n       u P s \\<ominus> 1 \\<le> u (\\<lambda>s'. P s' \\<ominus> 1) s", "also"], ["proof (state)\nthis:\n  t P s \\<ominus> 1 \\<le> t (\\<lambda>s. P s \\<ominus> 1) s\n\ngoal (1 subgoal):\n 1. \\<And>P s.\n       sound P \\<Longrightarrow>\n       u P s \\<ominus> 1 \\<le> u (\\<lambda>s'. P s' \\<ominus> 1) s", "from sP eq"], ["proof (chain)\npicking this:\n  sound P\n  equiv_trans t u", "have \"... = u (\\<lambda>s. P s \\<ominus> 1) s\""], ["proof (prove)\nusing this:\n  sound P\n  equiv_trans t u\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. P s \\<ominus> 1) s = u (\\<lambda>s. P s \\<ominus> 1) s", "by(simp add:equiv_transD tminus_sound)"], ["proof (state)\nthis:\n  t (\\<lambda>s. P s \\<ominus> 1) s = u (\\<lambda>s. P s \\<ominus> 1) s\n\ngoal (1 subgoal):\n 1. \\<And>P s.\n       sound P \\<Longrightarrow>\n       u P s \\<ominus> 1 \\<le> u (\\<lambda>s'. P s' \\<ominus> 1) s", "finally"], ["proof (chain)\npicking this:\n  u P s \\<ominus> 1 \\<le> u (\\<lambda>s. P s \\<ominus> 1) s", "show \"u P s \\<ominus> 1 \\<le> u (\\<lambda>s. P s \\<ominus> 1) s\""], ["proof (prove)\nusing this:\n  u P s \\<ominus> 1 \\<le> u (\\<lambda>s. P s \\<ominus> 1) s\n\ngoal (1 subgoal):\n 1. u P s \\<ominus> 1 \\<le> u (\\<lambda>s. P s \\<ominus> 1) s", "."], ["proof (state)\nthis:\n  u P s \\<ominus> 1 \\<le> u (\\<lambda>s. P s \\<ominus> 1) s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Sublinearity implies sub-distributivity:\\<close>"], ["", "lemma sublinear_sub_distrib:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes slt: \"sublinear t\"\n  shows \"sub_distrib t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub_distrib t", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P s.\n       sound P \\<Longrightarrow>\n       t P s \\<ominus> 1 \\<le> t (\\<lambda>s'. P s' \\<ominus> 1) s", "fix P::\"'s \\<Rightarrow> real\" and s::'s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P s.\n       sound P \\<Longrightarrow>\n       t P s \\<ominus> 1 \\<le> t (\\<lambda>s'. P s' \\<ominus> 1) s", "assume sP: \"sound P\""], ["proof (state)\nthis:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>P s.\n       sound P \\<Longrightarrow>\n       t P s \\<ominus> 1 \\<le> t (\\<lambda>s'. P s' \\<ominus> 1) s", "moreover"], ["proof (state)\nthis:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>P s.\n       sound P \\<Longrightarrow>\n       t P s \\<ominus> 1 \\<le> t (\\<lambda>s'. P s' \\<ominus> 1) s", "have \"sound (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (\\<lambda>_. 0)", "by(auto)"], ["proof (state)\nthis:\n  sound (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. \\<And>P s.\n       sound P \\<Longrightarrow>\n       t P s \\<ominus> 1 \\<le> t (\\<lambda>s'. P s' \\<ominus> 1) s", "ultimately"], ["proof (chain)\npicking this:\n  sound P\n  sound (\\<lambda>_. 0)", "show \"t P s \\<ominus> 1 \\<le> t (\\<lambda>s. P s \\<ominus> 1) s\""], ["proof (prove)\nusing this:\n  sound P\n  sound (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. t P s \\<ominus> 1 \\<le> t (\\<lambda>s. P s \\<ominus> 1) s", "by(rule sublinearD[OF slt, where a=1 and b=0 and c=1, simplified])"], ["proof (state)\nthis:\n  t P s \\<ominus> 1 \\<le> t (\\<lambda>s. P s \\<ominus> 1) s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Healthiness, sub-additivity and sub-distributivity imply\n  sublinearity.  This is how we usually show sublinearity.\\<close>"], ["", "lemma sd_sa_sublinear:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes sdt: \"sub_distrib t\" and sat: \"sub_add t\" and ht: \"healthy t\"\n  shows \"sublinear t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sublinear t", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c P Q s.\n       \\<lbrakk>sound P; sound Q; 0 \\<le> a; 0 \\<le> b; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * t P s + b * t Q s \\<ominus> c\n                         \\<le> t (\\<lambda>s'.\n                                     a * P s' + b * Q s' \\<ominus> c)\n                                s", "fix P::\"'s \\<Rightarrow> real\" and Q::\"'s \\<Rightarrow> real\" and s::'s\n  and a::real and b::real and c::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c P Q s.\n       \\<lbrakk>sound P; sound Q; 0 \\<le> a; 0 \\<le> b; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * t P s + b * t Q s \\<ominus> c\n                         \\<le> t (\\<lambda>s'.\n                                     a * P s' + b * Q s' \\<ominus> c)\n                                s", "assume sP: \"sound P\" and sQ: \"sound Q\"\n     and nna: \"0 \\<le> a\" and nnb: \"0 \\<le> b\" and nnc: \"0 \\<le> c\""], ["proof (state)\nthis:\n  sound P\n  sound Q\n  0 \\<le> a\n  0 \\<le> b\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>a b c P Q s.\n       \\<lbrakk>sound P; sound Q; 0 \\<le> a; 0 \\<le> b; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * t P s + b * t Q s \\<ominus> c\n                         \\<le> t (\\<lambda>s'.\n                                     a * P s' + b * Q s' \\<ominus> c)\n                                s", "from ht sP sQ nna nnb"], ["proof (chain)\npicking this:\n  healthy t\n  sound P\n  sound Q\n  0 \\<le> a\n  0 \\<le> b", "have saP: \"sound (\\<lambda>s. a * P s)\" and staP: \"sound (\\<lambda>s. a * t P s)\"\n   and sbQ: \"sound (\\<lambda>s. b * Q s)\" and stbQ: \"sound (\\<lambda>s. b * t Q s)\""], ["proof (prove)\nusing this:\n  healthy t\n  sound P\n  sound Q\n  0 \\<le> a\n  0 \\<le> b\n\ngoal (1 subgoal):\n 1. (sound (\\<lambda>s. a * P s) &&& sound (\\<lambda>s. a * t P s)) &&&\n    sound (\\<lambda>s. b * Q s) &&& sound (\\<lambda>s. b * t Q s)", "by(auto intro:sc_sound)"], ["proof (state)\nthis:\n  sound (\\<lambda>s. a * P s)\n  sound (\\<lambda>s. a * t P s)\n  sound (\\<lambda>s. b * Q s)\n  sound (\\<lambda>s. b * t Q s)\n\ngoal (1 subgoal):\n 1. \\<And>a b c P Q s.\n       \\<lbrakk>sound P; sound Q; 0 \\<le> a; 0 \\<le> b; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * t P s + b * t Q s \\<ominus> c\n                         \\<le> t (\\<lambda>s'.\n                                     a * P s' + b * Q s' \\<ominus> c)\n                                s", "hence sabPQ:  \"sound (\\<lambda>s. a * P s + b * Q s)\"\n    and stabPQ: \"sound (\\<lambda>s. a * t P s + b * t Q s)\""], ["proof (prove)\nusing this:\n  sound (\\<lambda>s. a * P s)\n  sound (\\<lambda>s. a * t P s)\n  sound (\\<lambda>s. b * Q s)\n  sound (\\<lambda>s. b * t Q s)\n\ngoal (1 subgoal):\n 1. sound (\\<lambda>s. a * P s + b * Q s) &&&\n    sound (\\<lambda>s. a * t P s + b * t Q s)", "by(auto intro:sound_sum)"], ["proof (state)\nthis:\n  sound (\\<lambda>s. a * P s + b * Q s)\n  sound (\\<lambda>s. a * t P s + b * t Q s)\n\ngoal (1 subgoal):\n 1. \\<And>a b c P Q s.\n       \\<lbrakk>sound P; sound Q; 0 \\<le> a; 0 \\<le> b; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * t P s + b * t Q s \\<ominus> c\n                         \\<le> t (\\<lambda>s'.\n                                     a * P s' + b * Q s' \\<ominus> c)\n                                s", "from ht sP sQ nna nnb"], ["proof (chain)\npicking this:\n  healthy t\n  sound P\n  sound Q\n  0 \\<le> a\n  0 \\<le> b", "have \"a * t P s + b * t Q s = t (\\<lambda>s. a * P s) s + t (\\<lambda>s. b * Q s) s\""], ["proof (prove)\nusing this:\n  healthy t\n  sound P\n  sound Q\n  0 \\<le> a\n  0 \\<le> b\n\ngoal (1 subgoal):\n 1. a * t P s + b * t Q s =\n    t (\\<lambda>s. a * P s) s + t (\\<lambda>s. b * Q s) s", "by(simp add:scalingD healthy_scalingD)"], ["proof (state)\nthis:\n  a * t P s + b * t Q s =\n  t (\\<lambda>s. a * P s) s + t (\\<lambda>s. b * Q s) s\n\ngoal (1 subgoal):\n 1. \\<And>a b c P Q s.\n       \\<lbrakk>sound P; sound Q; 0 \\<le> a; 0 \\<le> b; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * t P s + b * t Q s \\<ominus> c\n                         \\<le> t (\\<lambda>s'.\n                                     a * P s' + b * Q s' \\<ominus> c)\n                                s", "also"], ["proof (state)\nthis:\n  a * t P s + b * t Q s =\n  t (\\<lambda>s. a * P s) s + t (\\<lambda>s. b * Q s) s\n\ngoal (1 subgoal):\n 1. \\<And>a b c P Q s.\n       \\<lbrakk>sound P; sound Q; 0 \\<le> a; 0 \\<le> b; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * t P s + b * t Q s \\<ominus> c\n                         \\<le> t (\\<lambda>s'.\n                                     a * P s' + b * Q s' \\<ominus> c)\n                                s", "from saP sbQ sat"], ["proof (chain)\npicking this:\n  sound (\\<lambda>s. a * P s)\n  sound (\\<lambda>s. b * Q s)\n  sub_add t", "have \"t (\\<lambda>s. a * P s) s + t (\\<lambda>s. b * Q s) s \\<le>\n        t (\\<lambda>s. a * P s + b * Q s) s\""], ["proof (prove)\nusing this:\n  sound (\\<lambda>s. a * P s)\n  sound (\\<lambda>s. b * Q s)\n  sub_add t\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. a * P s) s + t (\\<lambda>s. b * Q s) s\n    \\<le> t (\\<lambda>s. a * P s + b * Q s) s", "by(blast)"], ["proof (state)\nthis:\n  t (\\<lambda>s. a * P s) s + t (\\<lambda>s. b * Q s) s\n  \\<le> t (\\<lambda>s. a * P s + b * Q s) s\n\ngoal (1 subgoal):\n 1. \\<And>a b c P Q s.\n       \\<lbrakk>sound P; sound Q; 0 \\<le> a; 0 \\<le> b; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * t P s + b * t Q s \\<ominus> c\n                         \\<le> t (\\<lambda>s'.\n                                     a * P s' + b * Q s' \\<ominus> c)\n                                s", "finally"], ["proof (chain)\npicking this:\n  a * t P s + b * t Q s \\<le> t (\\<lambda>s. a * P s + b * Q s) s", "have notm: \"a * t P s + b * t Q s \\<le> t (\\<lambda>s. a * P s + b * Q s) s\""], ["proof (prove)\nusing this:\n  a * t P s + b * t Q s \\<le> t (\\<lambda>s. a * P s + b * Q s) s\n\ngoal (1 subgoal):\n 1. a * t P s + b * t Q s \\<le> t (\\<lambda>s. a * P s + b * Q s) s", "."], ["proof (state)\nthis:\n  a * t P s + b * t Q s \\<le> t (\\<lambda>s. a * P s + b * Q s) s\n\ngoal (1 subgoal):\n 1. \\<And>a b c P Q s.\n       \\<lbrakk>sound P; sound Q; 0 \\<le> a; 0 \\<le> b; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * t P s + b * t Q s \\<ominus> c\n                         \\<le> t (\\<lambda>s'.\n                                     a * P s' + b * Q s' \\<ominus> c)\n                                s", "show \"a * t P s + b * t Q s \\<ominus> c \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "proof(cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "note z = this"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "from stabPQ"], ["proof (chain)\npicking this:\n  sound (\\<lambda>s. a * t P s + b * t Q s)", "have \"\\<And>s. 0 \\<le> a * t P s + b * t Q s\""], ["proof (prove)\nusing this:\n  sound (\\<lambda>s. a * t P s + b * t Q s)\n\ngoal (1 subgoal):\n 1. \\<And>s. 0 \\<le> a * t P s + b * t Q s", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> a * t P ?s + b * t Q ?s\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "moreover"], ["proof (state)\nthis:\n  0 \\<le> a * t P ?s + b * t Q ?s\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "from sabPQ"], ["proof (chain)\npicking this:\n  sound (\\<lambda>s. a * P s + b * Q s)", "have \"\\<And>s. 0 \\<le> a * P s + b * Q s\""], ["proof (prove)\nusing this:\n  sound (\\<lambda>s. a * P s + b * Q s)\n\ngoal (1 subgoal):\n 1. \\<And>s. 0 \\<le> a * P s + b * Q s", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> a * P ?s + b * Q ?s\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> a * t P ?s + b * t Q ?s\n  0 \\<le> a * P ?s + b * Q ?s", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> a * t P ?s + b * t Q ?s\n  0 \\<le> a * P ?s + b * Q ?s\n\ngoal (1 subgoal):\n 1. a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "by(simp add:z notm)"], ["proof (state)\nthis:\n  a * t P s + b * t Q s \\<ominus> c\n  \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "note nz = this"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "from nz and nnc"], ["proof (chain)\npicking this:\n  c \\<noteq> 0\n  0 \\<le> c", "have nni: \"0 \\<le> inverse c\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. 0 \\<le> inverse c", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> inverse c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "have \"\\<And>s. (inverse c * a) * P s + (inverse c * b) * Q s =\n              inverse c * (a * P s + b * Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       inverse c * a * P s + inverse c * b * Q s =\n       inverse c * (a * P s + b * Q s)", "by(simp add: divide_simps)"], ["proof (state)\nthis:\n  inverse c * a * P ?s + inverse c * b * Q ?s =\n  inverse c * (a * P ?s + b * Q ?s)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "with sabPQ and nni"], ["proof (chain)\npicking this:\n  sound (\\<lambda>s. a * P s + b * Q s)\n  0 \\<le> inverse c\n  inverse c * a * P ?s + inverse c * b * Q ?s =\n  inverse c * (a * P ?s + b * Q ?s)", "have si: \"sound (\\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s)\""], ["proof (prove)\nusing this:\n  sound (\\<lambda>s. a * P s + b * Q s)\n  0 \\<le> inverse c\n  inverse c * a * P ?s + inverse c * b * Q ?s =\n  inverse c * (a * P ?s + b * Q ?s)\n\ngoal (1 subgoal):\n 1. sound (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s)", "by(auto intro:sc_sound)"], ["proof (state)\nthis:\n  sound (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "hence sim: \"sound (\\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s \\<ominus> 1)\""], ["proof (prove)\nusing this:\n  sound (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s)\n\ngoal (1 subgoal):\n 1. sound\n     (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)", "by(auto intro!:tminus_sound)"], ["proof (state)\nthis:\n  sound (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "from nz"], ["proof (chain)\npicking this:\n  c \\<noteq> 0", "have \"a * t P s + b * t Q s \\<ominus> c =\n          (c * inverse c) * a * t P s +\n          (c * inverse c) * b * t Q s \\<ominus> c\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a * t P s + b * t Q s \\<ominus> c =\n    c * inverse c * a * t P s + c * inverse c * b * t Q s \\<ominus> c", "by(simp)"], ["proof (state)\nthis:\n  a * t P s + b * t Q s \\<ominus> c =\n  c * inverse c * a * t P s + c * inverse c * b * t Q s \\<ominus> c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "also"], ["proof (state)\nthis:\n  a * t P s + b * t Q s \\<ominus> c =\n  c * inverse c * a * t P s + c * inverse c * b * t Q s \\<ominus> c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "have \"... = c * (inverse c * a * t P s) +\n                c * (inverse c * b * t Q s) \\<ominus> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * inverse c * a * t P s + c * inverse c * b * t Q s \\<ominus> c =\n    c * (inverse c * a * t P s) + c * (inverse c * b * t Q s) \\<ominus> c", "by(simp add:field_simps)"], ["proof (state)\nthis:\n  c * inverse c * a * t P s + c * inverse c * b * t Q s \\<ominus> c =\n  c * (inverse c * a * t P s) + c * (inverse c * b * t Q s) \\<ominus> c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "also"], ["proof (state)\nthis:\n  c * inverse c * a * t P s + c * inverse c * b * t Q s \\<ominus> c =\n  c * (inverse c * a * t P s) + c * (inverse c * b * t Q s) \\<ominus> c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "from nnc"], ["proof (chain)\npicking this:\n  0 \\<le> c", "have \"... = c * (inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1)\""], ["proof (prove)\nusing this:\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. c * (inverse c * a * t P s) + c * (inverse c * b * t Q s) \\<ominus> c =\n    c * (inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1)", "by(simp add:distrib_left tminus_left_distrib)"], ["proof (state)\nthis:\n  c * (inverse c * a * t P s) + c * (inverse c * b * t Q s) \\<ominus> c =\n  c * (inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "also"], ["proof (state)\nthis:\n  c * (inverse c * a * t P s) + c * (inverse c * b * t Q s) \\<ominus> c =\n  c * (inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "{"], ["proof (state)\nthis:\n  c * (inverse c * a * t P s) + c * (inverse c * b * t Q s) \\<ominus> c =\n  c * (inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "have X: \"\\<And>s. (inverse c * a) * t P s + (inverse c * b) * t Q s =\n                   inverse c * (a * t P s + b * t Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       inverse c * a * t P s + inverse c * b * t Q s =\n       inverse c * (a * t P s + b * t Q s)", "by(simp add: divide_simps)"], ["proof (state)\nthis:\n  inverse c * a * t P ?s + inverse c * b * t Q ?s =\n  inverse c * (a * t P ?s + b * t Q ?s)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "also"], ["proof (state)\nthis:\n  inverse c * a * t P ?s + inverse c * b * t Q ?s =\n  inverse c * (a * t P ?s + b * t Q ?s)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "from nni and notm"], ["proof (chain)\npicking this:\n  0 \\<le> inverse c\n  a * t P s + b * t Q s \\<le> t (\\<lambda>s. a * P s + b * Q s) s", "have \"inverse c * (a * t P s + b * t Q s) \\<le>\n            inverse c * (t (\\<lambda>s. a * P s + b * Q s) s)\""], ["proof (prove)\nusing this:\n  0 \\<le> inverse c\n  a * t P s + b * t Q s \\<le> t (\\<lambda>s. a * P s + b * Q s) s\n\ngoal (1 subgoal):\n 1. inverse c * (a * t P s + b * t Q s)\n    \\<le> inverse c * t (\\<lambda>s. a * P s + b * Q s) s", "by(blast intro:mult_left_mono)"], ["proof (state)\nthis:\n  inverse c * (a * t P s + b * t Q s)\n  \\<le> inverse c * t (\\<lambda>s. a * P s + b * Q s) s\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "also"], ["proof (state)\nthis:\n  inverse c * (a * t P s + b * t Q s)\n  \\<le> inverse c * t (\\<lambda>s. a * P s + b * Q s) s\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "from nni ht sabPQ"], ["proof (chain)\npicking this:\n  0 \\<le> inverse c\n  healthy t\n  sound (\\<lambda>s. a * P s + b * Q s)", "have \"... = t (\\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s) s\""], ["proof (prove)\nusing this:\n  0 \\<le> inverse c\n  healthy t\n  sound (\\<lambda>s. a * P s + b * Q s)\n\ngoal (1 subgoal):\n 1. inverse c * t (\\<lambda>s. a * P s + b * Q s) s =\n    t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s) s", "by(simp add:scalingD[OF healthy_scalingD, OF ht] algebra_simps)"], ["proof (state)\nthis:\n  inverse c * t (\\<lambda>s. a * P s + b * Q s) s =\n  t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s) s\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "finally"], ["proof (chain)\npicking this:\n  inverse c * a * t P s + inverse c * b * t Q s\n  \\<le> t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s) s", "have \"(inverse c * a) * t P s + (inverse c * b) * t Q s \\<ominus> 1 \\<le>\n            t (\\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s) s \\<ominus> 1\""], ["proof (prove)\nusing this:\n  inverse c * a * t P s + inverse c * b * t Q s\n  \\<le> t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s) s\n\ngoal (1 subgoal):\n 1. inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1\n    \\<le> t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s)\n           s \\<ominus>\n          1", "by(rule tminus_left_mono)"], ["proof (state)\nthis:\n  inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1\n  \\<le> t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s)\n         s \\<ominus>\n        1\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "also"], ["proof (state)\nthis:\n  inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1\n  \\<le> t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s)\n         s \\<ominus>\n        1\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "{"], ["proof (state)\nthis:\n  inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1\n  \\<le> t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s)\n         s \\<ominus>\n        1\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "from sdt si"], ["proof (chain)\npicking this:\n  sub_distrib t\n  sound (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s)", "have \"t (\\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s) s \\<ominus> 1 \\<le>\n              t (\\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s \\<ominus> 1) s\""], ["proof (prove)\nusing this:\n  sub_distrib t\n  sound (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s)\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s) s \\<ominus> 1\n    \\<le> t (\\<lambda>s.\n                inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)\n           s", "by(blast)"], ["proof (state)\nthis:\n  t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s) s \\<ominus> 1\n  \\<le> t (\\<lambda>s.\n              inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)\n         s\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "}"], ["proof (state)\nthis:\n  t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s) s \\<ominus> 1\n  \\<le> t (\\<lambda>s.\n              inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)\n         s\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "finally"], ["proof (chain)\npicking this:\n  inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1\n  \\<le> t (\\<lambda>s.\n              inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)\n         s", "have \"c * (inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1) \\<le>\n            c * t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s \\<ominus> 1) s\""], ["proof (prove)\nusing this:\n  inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1\n  \\<le> t (\\<lambda>s.\n              inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)\n         s\n\ngoal (1 subgoal):\n 1. c * (inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1)\n    \\<le> c *\n          t (\\<lambda>s.\n                inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)\n           s", "using nnc"], ["proof (prove)\nusing this:\n  inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1\n  \\<le> t (\\<lambda>s.\n              inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)\n         s\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. c * (inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1)\n    \\<le> c *\n          t (\\<lambda>s.\n                inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)\n           s", "by(blast intro:mult_left_mono)"], ["proof (state)\nthis:\n  c * (inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1)\n  \\<le> c *\n        t (\\<lambda>s.\n              inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)\n         s\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "}"], ["proof (state)\nthis:\n  c * (inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1)\n  \\<le> c *\n        t (\\<lambda>s.\n              inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)\n         s\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "also"], ["proof (state)\nthis:\n  c * (inverse c * a * t P s + inverse c * b * t Q s \\<ominus> 1)\n  \\<le> c *\n        t (\\<lambda>s.\n              inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)\n         s\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "from nnc ht sim"], ["proof (chain)\npicking this:\n  0 \\<le> c\n  healthy t\n  sound (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)", "have \"c * t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s \\<ominus> 1) s\n          = t (\\<lambda>s. c * (inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)) s\""], ["proof (prove)\nusing this:\n  0 \\<le> c\n  healthy t\n  sound (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)\n\ngoal (1 subgoal):\n 1. c *\n    t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s \\<ominus> 1)\n     s =\n    t (\\<lambda>s.\n          c * (inverse c * a * P s + inverse c * b * Q s \\<ominus> 1))\n     s", "by(simp add:scalingD healthy_scalingD)"], ["proof (state)\nthis:\n  c *\n  t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s \\<ominus> 1) s =\n  t (\\<lambda>s.\n        c * (inverse c * a * P s + inverse c * b * Q s \\<ominus> 1))\n   s\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "also"], ["proof (state)\nthis:\n  c *\n  t (\\<lambda>s. inverse c * a * P s + inverse c * b * Q s \\<ominus> 1) s =\n  t (\\<lambda>s.\n        c * (inverse c * a * P s + inverse c * b * Q s \\<ominus> 1))\n   s\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "from nnc"], ["proof (chain)\npicking this:\n  0 \\<le> c", "have \"... = t (\\<lambda>s. c * (inverse c * a * P s) +\n                       c * (inverse c * b * Q s) \\<ominus> c) s\""], ["proof (prove)\nusing this:\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s.\n          c * (inverse c * a * P s + inverse c * b * Q s \\<ominus> 1))\n     s =\n    t (\\<lambda>s.\n          c * (inverse c * a * P s) + c * (inverse c * b * Q s) \\<ominus> c)\n     s", "by(simp add:distrib_left tminus_left_distrib)"], ["proof (state)\nthis:\n  t (\\<lambda>s.\n        c * (inverse c * a * P s + inverse c * b * Q s \\<ominus> 1))\n   s =\n  t (\\<lambda>s.\n        c * (inverse c * a * P s) + c * (inverse c * b * Q s) \\<ominus> c)\n   s\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "also"], ["proof (state)\nthis:\n  t (\\<lambda>s.\n        c * (inverse c * a * P s + inverse c * b * Q s \\<ominus> 1))\n   s =\n  t (\\<lambda>s.\n        c * (inverse c * a * P s) + c * (inverse c * b * Q s) \\<ominus> c)\n   s\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "have \"... = t (\\<lambda>s. (c * inverse c) * a * P s +\n                            (c * inverse c) * b * Q s \\<ominus> c) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t (\\<lambda>s.\n          c * (inverse c * a * P s) + c * (inverse c * b * Q s) \\<ominus> c)\n     s =\n    t (\\<lambda>s.\n          c * inverse c * a * P s + c * inverse c * b * Q s \\<ominus> c)\n     s", "by(simp add:field_simps)"], ["proof (state)\nthis:\n  t (\\<lambda>s.\n        c * (inverse c * a * P s) + c * (inverse c * b * Q s) \\<ominus> c)\n   s =\n  t (\\<lambda>s.\n        c * inverse c * a * P s + c * inverse c * b * Q s \\<ominus> c)\n   s\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "finally"], ["proof (chain)\npicking this:\n  a * t P s + b * t Q s \\<ominus> c\n  \\<le> t (\\<lambda>s.\n              c * inverse c * a * P s + c * inverse c * b * Q s \\<ominus> c)\n         s", "show \"a * t P s + b * t Q s \\<ominus> c \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s\""], ["proof (prove)\nusing this:\n  a * t P s + b * t Q s \\<ominus> c\n  \\<le> t (\\<lambda>s.\n              c * inverse c * a * P s + c * inverse c * b * Q s \\<ominus> c)\n         s\n\ngoal (1 subgoal):\n 1. a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "using nz"], ["proof (prove)\nusing this:\n  a * t P s + b * t Q s \\<ominus> c\n  \\<le> t (\\<lambda>s.\n              c * inverse c * a * P s + c * inverse c * b * Q s \\<ominus> c)\n         s\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a * t P s + b * t Q s \\<ominus> c\n    \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s", "by(simp)"], ["proof (state)\nthis:\n  a * t P s + b * t Q s \\<ominus> c\n  \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a * t P s + b * t Q s \\<ominus> c\n  \\<le> t (\\<lambda>s'. a * P s' + b * Q s' \\<ominus> c) s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Sub-conjunctivity\\<close>"], ["", "definition\n  sub_conj :: \"(('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real) \\<Rightarrow> bool\"\nwhere\n  \"sub_conj t \\<equiv> \\<forall>P Q. (sound P \\<and> sound Q) \\<longrightarrow>\n                       t P && t Q \\<tturnstile> t (P && Q)\""], ["", "lemma sub_conjI[intro]:\n  \"\\<lbrakk> \\<And>P Q. \\<lbrakk> sound P; sound Q \\<rbrakk> \\<Longrightarrow>\n           t P && t Q \\<tturnstile> t (P && Q) \\<rbrakk> \\<Longrightarrow> sub_conj t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>sound P; sound Q\\<rbrakk>\n        \\<Longrightarrow> t P &&\n                          t Q \\<tturnstile> t (P && Q)) \\<Longrightarrow>\n    sub_conj t", "unfolding sub_conj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>sound P; sound Q\\<rbrakk>\n        \\<Longrightarrow> t P &&\n                          t Q \\<tturnstile> t (P && Q)) \\<Longrightarrow>\n    \\<forall>P Q.\n       sound P \\<and> sound Q \\<longrightarrow>\n       t P && t Q \\<tturnstile> t (P && Q)", "by(simp)"], ["", "lemma sub_conjD[dest]:\n  \"\\<lbrakk> sub_conj t; sound P; sound Q \\<rbrakk> \\<Longrightarrow> t P && t Q \\<tturnstile> t (P && Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sub_conj t; sound P; sound Q\\<rbrakk>\n    \\<Longrightarrow> t P && t Q \\<tturnstile> t (P && Q)", "unfolding sub_conj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>P Q.\n                sound P \\<and> sound Q \\<longrightarrow>\n                t P && t Q \\<tturnstile> t (P && Q);\n     sound P; sound Q\\<rbrakk>\n    \\<Longrightarrow> t P && t Q \\<tturnstile> t (P && Q)", "by(simp)"], ["", "lemma sub_conj_wp_twice:\n  fixes f::\"'s \\<Rightarrow> (('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real)\"\n  assumes all: \"\\<forall>s. sub_conj (f s)\"\n  shows \"sub_conj (\\<lambda>P s. f s P s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub_conj (\\<lambda>P s. f s P s)", "proof(rule sub_conjI, rule le_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) x\n                         \\<le> f x (P && Q) x", "fix P::\"'s \\<Rightarrow> real\" and Q::\"'s \\<Rightarrow> real\" and s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) x\n                         \\<le> f x (P && Q) x", "assume sP: \"sound P\" and sQ: \"sound Q\""], ["proof (state)\nthis:\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) x\n                         \\<le> f x (P && Q) x", "have \"((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) s = (f s P && f s Q) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) s = (f s P && f s Q) s", "by(simp add:exp_conj_def)"], ["proof (state)\nthis:\n  ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) s = (f s P && f s Q) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) x\n                         \\<le> f x (P && Q) x", "also"], ["proof (state)\nthis:\n  ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) s = (f s P && f s Q) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) x\n                         \\<le> f x (P && Q) x", "{"], ["proof (state)\nthis:\n  ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) s = (f s P && f s Q) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) x\n                         \\<le> f x (P && Q) x", "from all"], ["proof (chain)\npicking this:\n  \\<forall>s. sub_conj (f s)", "have \"sub_conj (f s)\""], ["proof (prove)\nusing this:\n  \\<forall>s. sub_conj (f s)\n\ngoal (1 subgoal):\n 1. sub_conj (f s)", "by(blast)"], ["proof (state)\nthis:\n  sub_conj (f s)\n\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) x\n                         \\<le> f x (P && Q) x", "with sP and sQ"], ["proof (chain)\npicking this:\n  sound P\n  sound Q\n  sub_conj (f s)", "have \"(f s P && f s Q) s \\<le> f s (P && Q) s\""], ["proof (prove)\nusing this:\n  sound P\n  sound Q\n  sub_conj (f s)\n\ngoal (1 subgoal):\n 1. (f s P && f s Q) s \\<le> f s (P && Q) s", "by(blast)"], ["proof (state)\nthis:\n  (f s P && f s Q) s \\<le> f s (P && Q) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) x\n                         \\<le> f x (P && Q) x", "}"], ["proof (state)\nthis:\n  (f s P && f s Q) s \\<le> f s (P && Q) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) x\n                         \\<le> f x (P && Q) x", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) s \\<le> f s (P && Q) s", "show \"((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) s \\<le> f s (P && Q) s\""], ["proof (prove)\nusing this:\n  ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) s \\<le> f s (P && Q) s\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) s \\<le> f s (P && Q) s", "."], ["proof (state)\nthis:\n  ((\\<lambda>s. f s P s) && (\\<lambda>s. f s Q s)) s \\<le> f s (P && Q) s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Sublinearity implies sub-conjunctivity:\\<close>"], ["", "lemma sublinear_sub_conj:\n  fixes t::\"('s \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes slt: \"sublinear t\"\n  shows \"sub_conj t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub_conj t", "proof(rule sub_conjI, rule le_funI, unfold exp_conj_def pconj_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P x + t Q x \\<ominus> 1\n                         \\<le> t (\\<lambda>s. P s + Q s \\<ominus> 1) x", "fix P::\"'s \\<Rightarrow> real\" and Q::\"'s \\<Rightarrow> real\"and s::'s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P x + t Q x \\<ominus> 1\n                         \\<le> t (\\<lambda>s. P s + Q s \\<ominus> 1) x", "assume sP: \"sound P\" and sQ: \"sound Q\""], ["proof (state)\nthis:\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> t P x + t Q x \\<ominus> 1\n                         \\<le> t (\\<lambda>s. P s + Q s \\<ominus> 1) x", "thus \"t P s + t Q s \\<ominus> 1 \\<le> t (\\<lambda>s. P s + Q s \\<ominus> 1) s\""], ["proof (prove)\nusing this:\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. t P s + t Q s \\<ominus> 1 \\<le> t (\\<lambda>s. P s + Q s \\<ominus> 1) s", "by(rule sublinearD[OF slt, where a=1 and b=1 and c=1, simplified])"], ["proof (state)\nthis:\n  t P s + t Q s \\<ominus> 1 \\<le> t (\\<lambda>s. P s + Q s \\<ominus> 1) s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Sublinearity under equivalence\\<close>"], ["", "text \\<open>Sublinearity is preserved by equivalence.\\<close>"], ["", "lemma equiv_sublinear:\n  \"\\<lbrakk> equiv_trans t u; sublinear t; healthy t \\<rbrakk> \\<Longrightarrow> sublinear u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv_trans t u; sublinear t; healthy t\\<rbrakk>\n    \\<Longrightarrow> sublinear u", "by(iprover intro:sd_sa_sublinear healthy_equivI\n             dest:equiv_sub_distrib equiv_sub_add\n                  sublinear_sub_distrib sublinear_subadd\n                  healthy_feasibleD)"], ["", "subsection \\<open>Determinism\\<close>"], ["", "text \\<open>Transformers which are both additive, and maximal among those that\nsatisfy feasibility are \\emph{deterministic}, and will turn out to be maximal\nin the refinement order.\\<close>"], ["", "subsubsection \\<open>Additivity\\<close>"], ["", "text \\<open>Full additivity is not generally satisfied.  It holds for\n  (sub-)probabilistic transformers however.\\<close>"], ["", "definition\n  additive :: \"(('a \\<Rightarrow> real) \\<Rightarrow> 'a \\<Rightarrow> real) \\<Rightarrow> bool\"\nwhere\n  \"additive t \\<equiv> \\<forall>P Q. (sound P \\<and> sound Q) \\<longrightarrow>\n                      t (\\<lambda>s. P s + Q s) = (\\<lambda>s. t P s + t Q s)\""], ["", "lemma additiveD:\n  \"\\<lbrakk> additive t; sound P; sound Q \\<rbrakk> \\<Longrightarrow> t (\\<lambda>s. P s + Q s) = (\\<lambda>s. t P s + t Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Transformers.additive t; sound P; sound Q\\<rbrakk>\n    \\<Longrightarrow> t (\\<lambda>s. P s + Q s) =\n                      (\\<lambda>s. t P s + t Q s)", "by(simp add:additive_def)"], ["", "lemma additiveI[intro]:\n  \"\\<lbrakk> \\<And>P Q s. \\<lbrakk> sound P; sound Q \\<rbrakk> \\<Longrightarrow> t (\\<lambda>s. P s + Q s) s = t P s + t Q s \\<rbrakk> \\<Longrightarrow>\n   additive t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q s.\n        \\<lbrakk>sound P; sound Q\\<rbrakk>\n        \\<Longrightarrow> t (\\<lambda>s. P s + Q s) s =\n                          t P s + t Q s) \\<Longrightarrow>\n    Transformers.additive t", "unfolding additive_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q s.\n        \\<lbrakk>sound P; sound Q\\<rbrakk>\n        \\<Longrightarrow> t (\\<lambda>s. P s + Q s) s =\n                          t P s + t Q s) \\<Longrightarrow>\n    \\<forall>P Q.\n       sound P \\<and> sound Q \\<longrightarrow>\n       t (\\<lambda>s. P s + Q s) = (\\<lambda>s. t P s + t Q s)", "by(blast)"], ["", "text \\<open>Additivity is strictly stronger than sub-additivity.\\<close>"], ["", "lemma additive_sub_add:\n  \"additive t \\<Longrightarrow> sub_add t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transformers.additive t \\<Longrightarrow> sub_add t", "by(simp add:sub_addI additiveD)"], ["", "text \\<open>The additivity property extends to finite summation.\\<close>"], ["", "lemma additive_sum:\n  fixes S::\"'s set\"\n  assumes additive: \"additive t\"\n      and healthy:  \"healthy t\"\n      and finite:   \"finite S\"\n      and sPz:      \"\\<And>z. sound (P z)\"\n  shows \"t (\\<lambda>x. \\<Sum>y\\<in>S. P y x) = (\\<lambda>x. \\<Sum>y\\<in>S. t (P y) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t (\\<lambda>x. \\<Sum>y\\<in>S. P y x) =\n    (\\<lambda>x. \\<Sum>y\\<in>S. t (P y) x)", "proof(rule finite_induct, simp_all add:assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        t (\\<lambda>x. \\<Sum>y\\<in>F. P y x) =\n        (\\<lambda>x. \\<Sum>y\\<in>F. t (P y) x)\\<rbrakk>\n       \\<Longrightarrow> t (\\<lambda>xa. P x xa + (\\<Sum>y\\<in>F. P y xa)) =\n                         (\\<lambda>xa.\n                             t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa))", "fix z::'s and T::\"'s set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        t (\\<lambda>x. \\<Sum>y\\<in>F. P y x) =\n        (\\<lambda>x. \\<Sum>y\\<in>F. t (P y) x)\\<rbrakk>\n       \\<Longrightarrow> t (\\<lambda>xa. P x xa + (\\<Sum>y\\<in>F. P y xa)) =\n                         (\\<lambda>xa.\n                             t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa))", "assume finT: \"finite T\"\n     and IH: \"t (\\<lambda>x. \\<Sum>y\\<in>T. P y x) = (\\<lambda>x. \\<Sum>y\\<in>T. t (P y) x)\""], ["proof (state)\nthis:\n  finite T\n  t (\\<lambda>x. \\<Sum>y\\<in>T. P y x) =\n  (\\<lambda>x. \\<Sum>y\\<in>T. t (P y) x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        t (\\<lambda>x. \\<Sum>y\\<in>F. P y x) =\n        (\\<lambda>x. \\<Sum>y\\<in>F. t (P y) x)\\<rbrakk>\n       \\<Longrightarrow> t (\\<lambda>xa. P x xa + (\\<Sum>y\\<in>F. P y xa)) =\n                         (\\<lambda>xa.\n                             t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa))", "from additive sPz"], ["proof (chain)\npicking this:\n  Transformers.additive t\n  sound (P ?z)", "have \"t (\\<lambda>x. P z x + (\\<Sum>y\\<in>T. P y x)) =\n        (\\<lambda>x. t (P z) x +  t (\\<lambda>x. \\<Sum>y\\<in>T. P y x) x)\""], ["proof (prove)\nusing this:\n  Transformers.additive t\n  sound (P ?z)\n\ngoal (1 subgoal):\n 1. t (\\<lambda>x. P z x + (\\<Sum>y\\<in>T. P y x)) =\n    (\\<lambda>x. t (P z) x + t (\\<lambda>x. \\<Sum>y\\<in>T. P y x) x)", "by(auto intro!:sum_sound additiveD)"], ["proof (state)\nthis:\n  t (\\<lambda>x. P z x + (\\<Sum>y\\<in>T. P y x)) =\n  (\\<lambda>x. t (P z) x + t (\\<lambda>x. \\<Sum>y\\<in>T. P y x) x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        t (\\<lambda>x. \\<Sum>y\\<in>F. P y x) =\n        (\\<lambda>x. \\<Sum>y\\<in>F. t (P y) x)\\<rbrakk>\n       \\<Longrightarrow> t (\\<lambda>xa. P x xa + (\\<Sum>y\\<in>F. P y xa)) =\n                         (\\<lambda>xa.\n                             t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa))", "also"], ["proof (state)\nthis:\n  t (\\<lambda>x. P z x + (\\<Sum>y\\<in>T. P y x)) =\n  (\\<lambda>x. t (P z) x + t (\\<lambda>x. \\<Sum>y\\<in>T. P y x) x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        t (\\<lambda>x. \\<Sum>y\\<in>F. P y x) =\n        (\\<lambda>x. \\<Sum>y\\<in>F. t (P y) x)\\<rbrakk>\n       \\<Longrightarrow> t (\\<lambda>xa. P x xa + (\\<Sum>y\\<in>F. P y xa)) =\n                         (\\<lambda>xa.\n                             t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa))", "from IH"], ["proof (chain)\npicking this:\n  t (\\<lambda>x. \\<Sum>y\\<in>T. P y x) =\n  (\\<lambda>x. \\<Sum>y\\<in>T. t (P y) x)", "have \"... = (\\<lambda>x. t (P z) x + (\\<Sum>y\\<in>T. t (P y) x))\""], ["proof (prove)\nusing this:\n  t (\\<lambda>x. \\<Sum>y\\<in>T. P y x) =\n  (\\<lambda>x. \\<Sum>y\\<in>T. t (P y) x)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. t (P z) x + t (\\<lambda>x. \\<Sum>y\\<in>T. P y x) x) =\n    (\\<lambda>x. t (P z) x + (\\<Sum>y\\<in>T. t (P y) x))", "by(simp)"], ["proof (state)\nthis:\n  (\\<lambda>x. t (P z) x + t (\\<lambda>x. \\<Sum>y\\<in>T. P y x) x) =\n  (\\<lambda>x. t (P z) x + (\\<Sum>y\\<in>T. t (P y) x))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        t (\\<lambda>x. \\<Sum>y\\<in>F. P y x) =\n        (\\<lambda>x. \\<Sum>y\\<in>F. t (P y) x)\\<rbrakk>\n       \\<Longrightarrow> t (\\<lambda>xa. P x xa + (\\<Sum>y\\<in>F. P y xa)) =\n                         (\\<lambda>xa.\n                             t (P x) xa + (\\<Sum>y\\<in>F. t (P y) xa))", "finally"], ["proof (chain)\npicking this:\n  t (\\<lambda>x. P z x + (\\<Sum>y\\<in>T. P y x)) =\n  (\\<lambda>x. t (P z) x + (\\<Sum>y\\<in>T. t (P y) x))", "show \"t (\\<lambda>x. P z x + (\\<Sum>y\\<in>T. P y x)) =\n                (\\<lambda>x. t (P z) x + (\\<Sum>y\\<in>T. t (P y) x))\""], ["proof (prove)\nusing this:\n  t (\\<lambda>x. P z x + (\\<Sum>y\\<in>T. P y x)) =\n  (\\<lambda>x. t (P z) x + (\\<Sum>y\\<in>T. t (P y) x))\n\ngoal (1 subgoal):\n 1. t (\\<lambda>x. P z x + (\\<Sum>y\\<in>T. P y x)) =\n    (\\<lambda>x. t (P z) x + (\\<Sum>y\\<in>T. t (P y) x))", "."], ["proof (state)\nthis:\n  t (\\<lambda>x. P z x + (\\<Sum>y\\<in>T. P y x)) =\n  (\\<lambda>x. t (P z) x + (\\<Sum>y\\<in>T. t (P y) x))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>An additive transformer (over a finite state space) is linear: it is\n  simply the weighted sum of final expectation values, the weights being the\n  probability of reaching a given final state.  This is useful for reasoning\n  using the forward, or ``gambling game'' interpretation.\\<close>"], ["", "lemma additive_delta_split:\n  fixes t::\"('s::finite \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes additive: \"additive t\"\n      and ht: \"healthy t\"\n      and sP: \"sound P\"\n  shows \"t P x = (\\<Sum>y\\<in>UNIV. P y * t \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "have \"\\<And>x. (\\<Sum>y\\<in>UNIV. P y * \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) =\n            (\\<Sum>y\\<in>UNIV. if y = x then P y else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) =\n       (\\<Sum>y\\<in>UNIV. if y = x then P y else 0)", "by (rule sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> ?x) =\n  (\\<Sum>y\\<in>UNIV. if y = ?x then P y else 0)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> ?x) =\n  (\\<Sum>y\\<in>UNIV. if y = ?x then P y else 0)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "have \"\\<And>x. ... x = P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<Sum>y\\<in>UNIV. if y = x then P y else 0) = P x", "by(simp add:sum.delta)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV. if y = ?x then P y else 0) = P ?x\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>UNIV.\n     P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> ?x1) =\n  P ?x1", "have \"t P x = t (\\<lambda>x. \\<Sum>y\\<in>UNIV. P y * \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) x\""], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>UNIV.\n     P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> ?x1) =\n  P ?x1\n\ngoal (1 subgoal):\n 1. t P x =\n    t (\\<lambda>x.\n          \\<Sum>y\\<in>UNIV.\n            P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n     x", "by(simp)"], ["proof (state)\nthis:\n  t P x =\n  t (\\<lambda>x.\n        \\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n   x\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "also"], ["proof (state)\nthis:\n  t P x =\n  t (\\<lambda>x.\n        \\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n   x\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "{"], ["proof (state)\nthis:\n  t P x =\n  t (\\<lambda>x.\n        \\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n   x\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "from sP"], ["proof (chain)\npicking this:\n  sound P", "have \"\\<And>z. sound (\\<lambda>a. P z * \\<guillemotleft> \\<lambda>za. za = z \\<guillemotright> a)\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       sound\n        (\\<lambda>a.\n            P z * \\<guillemotleft> \\<lambda>za. za = z \\<guillemotright> a)", "by(auto intro!:mult_sound)"], ["proof (state)\nthis:\n  sound\n   (\\<lambda>a.\n       P ?z * \\<guillemotleft> \\<lambda>za. za = ?z \\<guillemotright> a)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "hence \"t (\\<lambda>x. \\<Sum>y\\<in>UNIV. P y * \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) x =\n           (\\<Sum>y\\<in>UNIV. t (\\<lambda>x. P y * \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) x)\""], ["proof (prove)\nusing this:\n  sound\n   (\\<lambda>a.\n       P ?z * \\<guillemotleft> \\<lambda>za. za = ?z \\<guillemotright> a)\n\ngoal (1 subgoal):\n 1. t (\\<lambda>x.\n          \\<Sum>y\\<in>UNIV.\n            P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n     x =\n    (\\<Sum>y\\<in>UNIV.\n       t (\\<lambda>x.\n             P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n        x)", "by(subst additive_sum, simp_all add:assms)"], ["proof (state)\nthis:\n  t (\\<lambda>x.\n        \\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n   x =\n  (\\<Sum>y\\<in>UNIV.\n     t (\\<lambda>x.\n           P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n      x)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "}"], ["proof (state)\nthis:\n  t (\\<lambda>x.\n        \\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n   x =\n  (\\<Sum>y\\<in>UNIV.\n     t (\\<lambda>x.\n           P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n      x)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "also"], ["proof (state)\nthis:\n  t (\\<lambda>x.\n        \\<Sum>y\\<in>UNIV.\n          P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n   x =\n  (\\<Sum>y\\<in>UNIV.\n     t (\\<lambda>x.\n           P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n      x)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "from sP"], ["proof (chain)\npicking this:\n  sound P", "have \"(\\<Sum>y\\<in>UNIV. t (\\<lambda>x. P y * \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) x) =\n        (\\<Sum>y\\<in>UNIV. P y * t \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x)\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>UNIV.\n       t (\\<lambda>x.\n             P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n        x) =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "by(subst scalingD[OF healthy_scalingD, OF ht], auto)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     t (\\<lambda>x.\n           P y * \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n      x) =\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "finally"], ["proof (chain)\npicking this:\n  t P x =\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "show \"t P x = (\\<Sum>y\\<in>UNIV. P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\""], ["proof (prove)\nusing this:\n  t P x =\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "."], ["proof (state)\nthis:\n  t P x =\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We can group the states in the linear form, to split on the value\n  of a predicate (guard).\\<close>"], ["", "lemma additive_guard_split:\n  fixes t::\"('s::finite \\<Rightarrow> real) \\<Rightarrow> 's \\<Rightarrow> real\"\n  assumes additive: \"additive t\"\n      and ht: \"healthy t\"\n      and sP: \"sound P\"\n  shows \"t P x = (\\<Sum>y\\<in>{s.   G s}. P y * t \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) +\n                 (\\<Sum>y\\<in>{s. \\<not> G s}. P y * t \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "from assms"], ["proof (chain)\npicking this:\n  Transformers.additive t\n  healthy t\n  sound P", "have \"t P x = (\\<Sum>y\\<in>UNIV. P y * t \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x)\""], ["proof (prove)\nusing this:\n  Transformers.additive t\n  healthy t\n  sound P\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "by(rule additive_delta_split)"], ["proof (state)\nthis:\n  t P x =\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "also"], ["proof (state)\nthis:\n  t P x =\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "{"], ["proof (state)\nthis:\n  t P x =\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "have \"UNIV = {s. G s} \\<union> {s. \\<not> G s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {s. G s} \\<union> {s. \\<not> G s}", "by(auto)"], ["proof (state)\nthis:\n  UNIV = {s. G s} \\<union> {s. \\<not> G s}\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "hence \"(\\<Sum>y\\<in>UNIV. P y * t \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) =\n           (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}. P y * t \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x)\""], ["proof (prove)\nusing this:\n  UNIV = {s. G s} \\<union> {s. \\<not> G s}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>UNIV.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) =\n    (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "by(simp)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) =\n  (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "}"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) =\n  (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>UNIV.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) =\n  (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "have \"(\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}. P y * t \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) =\n        (\\<Sum>y\\<in>{s.   G s}. P y * t \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x) +\n        (\\<Sum>y\\<in>{s. \\<not> G s}. P y * t \\<guillemotleft>\\<lambda>z. z = y\\<guillemotright> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) =\n    (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "by(auto intro:sum.union_disjoint)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>{s. G s} \\<union> {s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) =\n  (\\<Sum>y\\<in>{s. G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n  (\\<Sum>y\\<in>{s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "finally"], ["proof (chain)\npicking this:\n  t P x =\n  (\\<Sum>y\\<in>{s. G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n  (\\<Sum>y\\<in>{s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "show ?thesis"], ["proof (prove)\nusing this:\n  t P x =\n  (\\<Sum>y\\<in>{s. G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n  (\\<Sum>y\\<in>{s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n\ngoal (1 subgoal):\n 1. t P x =\n    (\\<Sum>y\\<in>{s. G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n    (\\<Sum>y\\<in>{s. \\<not> G s}.\n       P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)", "."], ["proof (state)\nthis:\n  t P x =\n  (\\<Sum>y\\<in>{s. G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x) +\n  (\\<Sum>y\\<in>{s. \\<not> G s}.\n     P y * t \\<guillemotleft> \\<lambda>z. z = y \\<guillemotright> x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Maximality\\<close>"], ["", "definition\n  maximal :: \"(('a \\<Rightarrow> real) \\<Rightarrow> 'a \\<Rightarrow> real) \\<Rightarrow> bool\"\nwhere\n  \"maximal t \\<equiv> \\<forall>c. 0 \\<le> c \\<longrightarrow> t (\\<lambda>_. c) = (\\<lambda>_. c)\""], ["", "lemma maximalI[intro]:\n  \"\\<lbrakk> \\<And>c. 0 \\<le> c \\<Longrightarrow> t (\\<lambda>_. c) = (\\<lambda>_. c) \\<rbrakk> \\<Longrightarrow> maximal t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        0 \\<le> c \\<Longrightarrow>\n        t (\\<lambda>_. c) = (\\<lambda>_. c)) \\<Longrightarrow>\n    maximal t", "by(simp add:maximal_def)"], ["", "lemma maximalD[dest]:\n  \"\\<lbrakk> maximal t; 0 \\<le> c \\<rbrakk>  \\<Longrightarrow> t (\\<lambda>_. c) = (\\<lambda>_. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maximal t; 0 \\<le> c\\<rbrakk>\n    \\<Longrightarrow> t (\\<lambda>_. c) = (\\<lambda>_. c)", "by(simp add:maximal_def)"], ["", "text \\<open>A transformer that is both additive and maximal is deterministic:\\<close>"], ["", "definition determ :: \"(('a \\<Rightarrow> real) \\<Rightarrow> 'a \\<Rightarrow> real) \\<Rightarrow> bool\"\nwhere\n  \"determ t \\<equiv> additive t \\<and> maximal t\""], ["", "lemma determI[intro]:\n  \"\\<lbrakk> additive t; maximal t \\<rbrakk> \\<Longrightarrow> determ t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Transformers.additive t; maximal t\\<rbrakk>\n    \\<Longrightarrow> determ t", "by(simp add:determ_def)"], ["", "lemma determ_additiveD[intro]:\n  \"determ t \\<Longrightarrow> additive t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. determ t \\<Longrightarrow> Transformers.additive t", "by(simp add:determ_def)"], ["", "lemma determ_maximalD[intro]:\n  \"determ t \\<Longrightarrow> maximal t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. determ t \\<Longrightarrow> maximal t", "by(simp add:determ_def)"], ["", "text \\<open>For a fully-deterministic transformer, a transformed standard\n  expectation, and its transformed negation are complementary.\\<close>"], ["", "lemma determ_negate:\n  assumes determ:  \"determ t\"\n  shows \"t \\<guillemotleft>P\\<guillemotright> s + t \\<guillemotleft>\\<N> P\\<guillemotright> s = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n    1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n    1", "have \"t \\<guillemotleft>P\\<guillemotright> s + t \\<guillemotleft>\\<N> P\\<guillemotright> s = t (\\<lambda>s. \\<guillemotleft>P\\<guillemotright> s + \\<guillemotleft>\\<N> P\\<guillemotright> s) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n    t (\\<lambda>s.\n          \\<guillemotleft> P \\<guillemotright> s +\n          \\<guillemotleft> \\<N> P \\<guillemotright> s)\n     s", "by(simp add:additiveD determ determ_additiveD)"], ["proof (state)\nthis:\n  t \\<guillemotleft> P \\<guillemotright> s +\n  t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n  t (\\<lambda>s.\n        \\<guillemotleft> P \\<guillemotright> s +\n        \\<guillemotleft> \\<N> P \\<guillemotright> s)\n   s\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n    1", "also"], ["proof (state)\nthis:\n  t \\<guillemotleft> P \\<guillemotright> s +\n  t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n  t (\\<lambda>s.\n        \\<guillemotleft> P \\<guillemotright> s +\n        \\<guillemotleft> \\<N> P \\<guillemotright> s)\n   s\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n    1", "{"], ["proof (state)\nthis:\n  t \\<guillemotleft> P \\<guillemotright> s +\n  t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n  t (\\<lambda>s.\n        \\<guillemotleft> P \\<guillemotright> s +\n        \\<guillemotleft> \\<N> P \\<guillemotright> s)\n   s\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n    1", "have \"\\<And>s. \\<guillemotleft>P\\<guillemotright> s + \\<guillemotleft>\\<N> P\\<guillemotright> s = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<guillemotleft> P \\<guillemotright> s +\n       \\<guillemotleft> \\<N> P \\<guillemotright> s =\n       1", "by(case_tac \"P s\", simp_all)"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> ?s +\n  \\<guillemotleft> \\<N> P \\<guillemotright> ?s =\n  1\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n    1", "hence \"t (\\<lambda>s. \\<guillemotleft>P\\<guillemotright> s + \\<guillemotleft>\\<N> P\\<guillemotright> s) = t (\\<lambda>s. 1)\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> P \\<guillemotright> ?s +\n  \\<guillemotleft> \\<N> P \\<guillemotright> ?s =\n  1\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s.\n          \\<guillemotleft> P \\<guillemotright> s +\n          \\<guillemotleft> \\<N> P \\<guillemotright> s) =\n    t (\\<lambda>s. 1)", "by(simp)"], ["proof (state)\nthis:\n  t (\\<lambda>s.\n        \\<guillemotleft> P \\<guillemotright> s +\n        \\<guillemotleft> \\<N> P \\<guillemotright> s) =\n  t (\\<lambda>s. 1)\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n    1", "}"], ["proof (state)\nthis:\n  t (\\<lambda>s.\n        \\<guillemotleft> P \\<guillemotright> s +\n        \\<guillemotleft> \\<N> P \\<guillemotright> s) =\n  t (\\<lambda>s. 1)\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n    1", "also"], ["proof (state)\nthis:\n  t (\\<lambda>s.\n        \\<guillemotleft> P \\<guillemotright> s +\n        \\<guillemotleft> \\<N> P \\<guillemotright> s) =\n  t (\\<lambda>s. 1)\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n    1", "have \"t (\\<lambda>s. 1) = (\\<lambda>s. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t (\\<lambda>s. 1) = (\\<lambda>s. 1)", "by(simp add:maximalD determ determ_maximalD)"], ["proof (state)\nthis:\n  t (\\<lambda>s. 1) = (\\<lambda>s. 1)\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n    1", "finally"], ["proof (chain)\npicking this:\n  t \\<guillemotleft> P \\<guillemotright> s +\n  t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n  1", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<guillemotleft> P \\<guillemotright> s +\n  t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n  1\n\ngoal (1 subgoal):\n 1. t \\<guillemotleft> P \\<guillemotright> s +\n    t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n    1", "."], ["proof (state)\nthis:\n  t \\<guillemotleft> P \\<guillemotright> s +\n  t \\<guillemotleft> \\<N> P \\<guillemotright> s =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Modular Reasoning\\<close>"], ["", "text \\<open>The emphasis of a mechanised logic is on automation, and letting\n  the computer tackle the large, uninteresting problems.  However, as\n  terms generally grow exponentially in the size of a program, it is\n  still essential to break up a proof and reason in a modular fashion.\n\n  The following rules allow proof decomposition, and later will be\n  incorporated into a verification condition generator.\\<close>"], ["", "lemma entails_combine:\n  assumes wp1: \"P \\<tturnstile> t R\"\n      and wp2: \"Q \\<tturnstile> t S\"\n      and sc:  \"sub_conj t\"\n      and sR:  \"sound R\"\n      and sS:  \"sound S\"\n  shows \"P && Q \\<tturnstile> t (R && S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P && Q \\<tturnstile> t (R && S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P && Q \\<tturnstile> t (R && S)", "from wp1 and wp2"], ["proof (chain)\npicking this:\n  P \\<tturnstile> t R\n  Q \\<tturnstile> t S", "have \"P && Q \\<tturnstile> t R && t S\""], ["proof (prove)\nusing this:\n  P \\<tturnstile> t R\n  Q \\<tturnstile> t S\n\ngoal (1 subgoal):\n 1. P && Q \\<tturnstile> t R && t S", "by(blast intro:entails_frame)"], ["proof (state)\nthis:\n  P && Q \\<tturnstile> t R && t S\n\ngoal (1 subgoal):\n 1. P && Q \\<tturnstile> t (R && S)", "also"], ["proof (state)\nthis:\n  P && Q \\<tturnstile> t R && t S\n\ngoal (1 subgoal):\n 1. P && Q \\<tturnstile> t (R && S)", "from sc and sR and sS"], ["proof (chain)\npicking this:\n  sub_conj t\n  sound R\n  sound S", "have \"... \\<le> t (R && S)\""], ["proof (prove)\nusing this:\n  sub_conj t\n  sound R\n  sound S\n\ngoal (1 subgoal):\n 1. t R && t S \\<tturnstile> t (R && S)", "by(rule sub_conjD)"], ["proof (state)\nthis:\n  t R && t S \\<tturnstile> t (R && S)\n\ngoal (1 subgoal):\n 1. P && Q \\<tturnstile> t (R && S)", "finally"], ["proof (chain)\npicking this:\n  P && Q \\<tturnstile> t (R && S)", "show ?thesis"], ["proof (prove)\nusing this:\n  P && Q \\<tturnstile> t (R && S)\n\ngoal (1 subgoal):\n 1. P && Q \\<tturnstile> t (R && S)", "."], ["proof (state)\nthis:\n  P && Q \\<tturnstile> t (R && S)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>These allow mismatched results to be composed\\<close>"], ["", "lemma entails_strengthen_post:\n  \"\\<lbrakk> P \\<tturnstile> t Q; healthy t; sound R; Q \\<tturnstile> R; sound Q \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> t R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> t Q; healthy t; sound R; Q \\<tturnstile> R;\n     sound Q\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> t R", "by(blast intro:entails_trans)"], ["", "lemma entails_weaken_pre:\n  \"\\<lbrakk> Q \\<tturnstile> t R; P \\<tturnstile> Q \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> t R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q \\<tturnstile> t R; P \\<tturnstile> Q\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> t R", "by(blast intro:entails_trans)"], ["", "text \\<open>This rule is unique to pGCL.  Use it to scale the post-expectation\n        of a rule to 'fit under' the precondition you need to satisfy.\\<close>"], ["", "lemma entails_scale:\n  assumes wp: \"P \\<tturnstile> t Q\" and h: \"healthy t\"\n      and sQ: \"sound Q\" and pos: \"0 \\<le> c\"\n  shows \"(\\<lambda>s. c * P s) \\<tturnstile> t (\\<lambda>s. c * Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s. c * P s \\<tturnstile> t (\\<lambda>s. c * Q s)", "proof(rule le_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. c * P x \\<le> t (\\<lambda>s. c * Q s) x", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. c * P x \\<le> t (\\<lambda>s. c * Q s) x", "from pos and wp"], ["proof (chain)\npicking this:\n  0 \\<le> c\n  P \\<tturnstile> t Q", "have \"c * P s \\<le> c * t Q s\""], ["proof (prove)\nusing this:\n  0 \\<le> c\n  P \\<tturnstile> t Q\n\ngoal (1 subgoal):\n 1. c * P s \\<le> c * t Q s", "by(auto intro:mult_left_mono)"], ["proof (state)\nthis:\n  c * P s \\<le> c * t Q s\n\ngoal (1 subgoal):\n 1. \\<And>x. c * P x \\<le> t (\\<lambda>s. c * Q s) x", "with sQ pos h"], ["proof (chain)\npicking this:\n  sound Q\n  0 \\<le> c\n  healthy t\n  c * P s \\<le> c * t Q s", "show \"c * P s \\<le> t (\\<lambda>s. c * Q s) s\""], ["proof (prove)\nusing this:\n  sound Q\n  0 \\<le> c\n  healthy t\n  c * P s \\<le> c * t Q s\n\ngoal (1 subgoal):\n 1. c * P s \\<le> t (\\<lambda>s. c * Q s) s", "by(simp add:scalingD healthy_scalingD)"], ["proof (state)\nthis:\n  c * P s \\<le> t (\\<lambda>s. c * Q s) s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Transforming Standard Expectations\\<close>"], ["", "text \\<open>Reasoning with \\emph{standard} expectations, those obtained\n  by embedding a predicate, is often easier, as the analogues of\n  many familiar boolean rules hold in modified form.\\<close>"], ["", "text \\<open>One may use a standard pre-expectation as an assumption:\\<close>"], ["", "lemma use_premise:\n  assumes h: \"healthy t\" and wP: \"\\<And>s. P s \\<Longrightarrow> 1 \\<le> t \\<guillemotleft>Q\\<guillemotright> s\"\n  shows \"\\<guillemotleft>P\\<guillemotright> \\<tturnstile> t \\<guillemotleft>Q\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> \\<tturnstile> t\n                  \\<guillemotleft> Q \\<guillemotright>", "proof(rule entailsI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<guillemotleft> P \\<guillemotright> s\n       \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<guillemotleft> P \\<guillemotright> s\n       \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "show \"\\<guillemotleft>P\\<guillemotright> s \\<le> t \\<guillemotleft>Q\\<guillemotright> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> s\n    \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "proof(cases \"P s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s\n    \\<le> t \\<guillemotleft> Q \\<guillemotright> s\n 2. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s\n    \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "case True"], ["proof (state)\nthis:\n  P s\n\ngoal (2 subgoals):\n 1. P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s\n    \\<le> t \\<guillemotleft> Q \\<guillemotright> s\n 2. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s\n    \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "with wP"], ["proof (chain)\npicking this:\n  P ?s \\<Longrightarrow> 1 \\<le> t \\<guillemotleft> Q \\<guillemotright> ?s\n  P s", "show ?thesis"], ["proof (prove)\nusing this:\n  P ?s \\<Longrightarrow> 1 \\<le> t \\<guillemotleft> Q \\<guillemotright> ?s\n  P s\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> s\n    \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "by(auto)"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> s\n  \\<le> t \\<guillemotleft> Q \\<guillemotright> s\n\ngoal (1 subgoal):\n 1. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s\n    \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s\n    \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "case False"], ["proof (state)\nthis:\n  \\<not> P s\n\ngoal (1 subgoal):\n 1. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s\n    \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "with h"], ["proof (chain)\npicking this:\n  healthy t\n  \\<not> P s", "show ?thesis"], ["proof (prove)\nusing this:\n  healthy t\n  \\<not> P s\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> s\n    \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "by(auto)"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> s\n  \\<le> t \\<guillemotleft> Q \\<guillemotright> s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> s\n  \\<le> t \\<guillemotleft> Q \\<guillemotright> s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The other direction works too.\\<close>"], ["", "lemma fold_premise:\n  assumes ht: \"healthy t\"\n  and wp: \"\\<guillemotleft>P\\<guillemotright> \\<tturnstile> t \\<guillemotleft>Q\\<guillemotright>\"\n  shows \"\\<forall>s. P s \\<longrightarrow> 1 \\<le> t \\<guillemotleft>Q\\<guillemotright> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       P s \\<longrightarrow>\n       1 \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       P s \\<Longrightarrow>\n       1 \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       P s \\<Longrightarrow>\n       1 \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "assume \"P s\""], ["proof (state)\nthis:\n  P s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       P s \\<Longrightarrow>\n       1 \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "hence \"1 = \\<guillemotleft>P\\<guillemotright> s\""], ["proof (prove)\nusing this:\n  P s\n\ngoal (1 subgoal):\n 1. 1 = \\<guillemotleft> P \\<guillemotright> s", "by(simp)"], ["proof (state)\nthis:\n  1 = \\<guillemotleft> P \\<guillemotright> s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       P s \\<Longrightarrow>\n       1 \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "also"], ["proof (state)\nthis:\n  1 = \\<guillemotleft> P \\<guillemotright> s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       P s \\<Longrightarrow>\n       1 \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "from wp"], ["proof (chain)\npicking this:\n  \\<guillemotleft> P \\<guillemotright> \\<tturnstile> t\n                \\<guillemotleft> Q \\<guillemotright>", "have \"... \\<le> t \\<guillemotleft>Q\\<guillemotright> s\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> P \\<guillemotright> \\<tturnstile> t\n                \\<guillemotleft> Q \\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> s\n    \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "by(auto)"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> s\n  \\<le> t \\<guillemotleft> Q \\<guillemotright> s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       P s \\<Longrightarrow>\n       1 \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "show \"1 \\<le> t \\<guillemotleft>Q\\<guillemotright> s\""], ["proof (prove)\nusing this:\n  1 \\<le> t \\<guillemotleft> Q \\<guillemotright> s\n\ngoal (1 subgoal):\n 1. 1 \\<le> t \\<guillemotleft> Q \\<guillemotright> s", "."], ["proof (state)\nthis:\n  1 \\<le> t \\<guillemotleft> Q \\<guillemotright> s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Predicate conjunction behaves as expected:\\<close>"], ["", "lemma conj_post:\n  \"\\<lbrakk> P \\<tturnstile> t \\<guillemotleft>\\<lambda>s. Q s \\<and> R s\\<guillemotright>; healthy t \\<rbrakk> \\<Longrightarrow> P \\<tturnstile> t \\<guillemotleft>Q\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<tturnstile> t \\<guillemotleft> \\<lambda>s.\n             Q s \\<and> R s \\<guillemotright>;\n     healthy t\\<rbrakk>\n    \\<Longrightarrow> P \\<tturnstile> t \\<guillemotleft> Q \\<guillemotright>", "by(blast intro:entails_strengthen_post implies_entails)"], ["", "text \\<open>Similar to @{thm use_premise}, but more general.\\<close>"], ["", "lemma entails_pconj_assumption:\n  assumes f: \"feasible t\" and wP: \"\\<And>s. P s \\<Longrightarrow> Q s \\<le> t R s\"\n      and uQ: \"unitary Q\" and uR: \"unitary R\"\n  shows \"\\<guillemotleft>P\\<guillemotright> && Q \\<tturnstile> t R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> && Q \\<tturnstile> t R", "unfolding exp_conj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       \\<guillemotleft> P \\<guillemotright> s .& Q s \\<tturnstile> t R", "proof(rule entailsI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "show \"\\<guillemotleft>P\\<guillemotright> s .& Q s \\<le> t R s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "proof(cases \"P s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s\n 2. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "case True"], ["proof (state)\nthis:\n  P s\n\ngoal (2 subgoals):\n 1. P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s\n 2. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "moreover"], ["proof (state)\nthis:\n  P s\n\ngoal (2 subgoals):\n 1. P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s\n 2. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "from uQ"], ["proof (chain)\npicking this:\n  unitary Q", "have \"0 \\<le> Q s\""], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. 0 \\<le> Q s", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> Q s\n\ngoal (2 subgoals):\n 1. P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s\n 2. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "ultimately"], ["proof (chain)\npicking this:\n  P s\n  0 \\<le> Q s", "show ?thesis"], ["proof (prove)\nusing this:\n  P s\n  0 \\<le> Q s\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "by(simp add:pconj_lone wP)"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s\n\ngoal (1 subgoal):\n 1. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "case False"], ["proof (state)\nthis:\n  \\<not> P s\n\ngoal (1 subgoal):\n 1. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "moreover"], ["proof (state)\nthis:\n  \\<not> P s\n\ngoal (1 subgoal):\n 1. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "from uQ"], ["proof (chain)\npicking this:\n  unitary Q", "have \"Q s \\<le> 1\""], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. Q s \\<le> 1", "by(auto)"], ["proof (state)\nthis:\n  Q s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> P s \\<Longrightarrow>\n    \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> P s\n  Q s \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> P s\n  Q s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "using assms"], ["proof (prove)\nusing this:\n  \\<not> P s\n  Q s \\<le> 1\n  feasible t\n  P ?s \\<Longrightarrow> Q ?s \\<le> t R ?s\n  unitary Q\n  unitary R\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> s .& Q s \\<le> t R s\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}