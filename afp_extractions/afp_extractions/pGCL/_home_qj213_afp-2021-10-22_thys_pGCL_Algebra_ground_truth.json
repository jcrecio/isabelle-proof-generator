{"file_name": "/home/qj213/afp-2021-10-22/thys/pGCL/Algebra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/pGCL", "problem_names": ["lemma refinesI[intro]:\n  \"\\<lbrakk> \\<And>P. sound P \\<Longrightarrow> wp prog P \\<tturnstile> wp prog' P \\<rbrakk> \\<Longrightarrow> prog \\<sqsubseteq> prog'\"", "lemma refinesD[dest]:\n  \"\\<lbrakk> prog \\<sqsubseteq> prog'; sound P \\<rbrakk> \\<Longrightarrow> wp prog P \\<tturnstile> wp prog' P\"", "lemma pequivI[intro]:\n  \"\\<lbrakk> \\<And>P. sound P \\<Longrightarrow> wp prog P = wp prog' P \\<rbrakk> \\<Longrightarrow> prog \\<simeq> prog'\"", "lemma pequivD[dest,simp]:\n  \"\\<lbrakk> prog \\<simeq> prog'; sound P \\<rbrakk> \\<Longrightarrow> wp prog P = wp prog' P\"", "lemma pequiv_equiv_trans:\n  \"a \\<simeq> b \\<longleftrightarrow> equiv_trans (wp a) (wp b)\"", "lemma DC_comm[ac_simps]:\n  \"a \\<Sqinter> b = b \\<Sqinter> a\"", "lemma DC_assoc[ac_simps]:\n  \"a \\<Sqinter> (b \\<Sqinter> c) = (a \\<Sqinter> b) \\<Sqinter> c\"", "lemma DC_idem:\n  \"a \\<Sqinter> a = a\"", "lemma AC_comm[ac_simps]:\n  \"a \\<Squnion> b = b \\<Squnion> a\"", "lemma AC_assoc[ac_simps]:\n  \"a \\<Squnion> (b \\<Squnion> c) = (a \\<Squnion> b) \\<Squnion> c\"", "lemma AC_idem:\n  \"a \\<Squnion> a = a\"", "lemma PC_quasi_comm:\n  \"a \\<^bsub>p\\<^esub>\\<oplus> b = b \\<^bsub>(\\<lambda>s. 1 - p s)\\<^esub>\\<oplus> a\"", "lemma PC_idem:\n  \"a \\<^bsub>p\\<^esub>\\<oplus> a = a\"", "lemma Seq_assoc[ac_simps]:\n  \"A ;; (B ;; C) = A ;; B ;; C\"", "lemma Abort_refines[intro]:\n  \"well_def a \\<Longrightarrow> Abort \\<sqsubseteq> a\"", "lemma left_refines_DC:\n  \"(a \\<Sqinter> b) \\<sqsubseteq> a\"", "lemma right_refines_DC:\n  \"(a \\<Sqinter> b) \\<sqsubseteq> b\"", "lemma DC_refines:\n  fixes a::\"'s prog\" and b and c\n  assumes rab: \"a \\<sqsubseteq> b\" and rac: \"a \\<sqsubseteq> c\"\n  shows \"a \\<sqsubseteq> (b \\<Sqinter> c)\"", "lemma DC_mono:\n  fixes a::\"'s prog\"\n  assumes rab: \"a \\<sqsubseteq> b\" and rcd: \"c \\<sqsubseteq> d\"\n  shows \"(a \\<Sqinter> c) \\<sqsubseteq> (b \\<Sqinter> d)\"", "lemma left_refines_AC:\n  \"a \\<sqsubseteq> (a \\<Squnion> b)\"", "lemma right_refines_AC:\n  \"b \\<sqsubseteq> (a \\<Squnion> b)\"", "lemma AC_refines:\n  fixes a::\"'s prog\" and b and c\n  assumes rac: \"a \\<sqsubseteq> c\" and rbc: \"b \\<sqsubseteq> c\"\n  shows \"(a \\<Squnion> b) \\<sqsubseteq> c\"", "lemma AC_mono:\n  fixes a::\"'s prog\"\n  assumes rab: \"a \\<sqsubseteq> b\" and rcd: \"c \\<sqsubseteq> d\"\n  shows \"(a \\<Squnion> c) \\<sqsubseteq> (b \\<Squnion> d)\"", "lemma DC_refines_PC:\n  assumes unit: \"unitary p\"\n  shows \"(a \\<Sqinter> b) \\<sqsubseteq> (a \\<^bsub>p\\<^esub>\\<oplus> b)\"", "lemma PC_refines_AC:\n  assumes unit: \"unitary p\"\n  shows \"(a \\<^bsub>p\\<^esub>\\<oplus> b) \\<sqsubseteq> (a \\<Squnion> b)\"", "lemma DC_refines_AC:\n  \"(a \\<Sqinter> b) \\<sqsubseteq> (a \\<Squnion> b)\"", "lemma pr_trans[trans]:\n  fixes A::\"'a prog\"\n  assumes prAB: \"A \\<sqsubseteq> B\"\n      and prBC: \"B \\<sqsubseteq> C\"\n  shows \"A \\<sqsubseteq> C\"", "lemma pequiv_refl[intro!,simp]:\n  \"a \\<simeq> a\"", "lemma pequiv_comm[ac_simps]:\n  \"a \\<simeq> b \\<longleftrightarrow> b \\<simeq> a\"", "lemma pequiv_pr[dest]:\n  \"a \\<simeq> b \\<Longrightarrow> a \\<sqsubseteq> b\"", "lemma pequiv_trans[intro,trans]:\n  \"\\<lbrakk> a \\<simeq> b; b \\<simeq> c \\<rbrakk> \\<Longrightarrow> a \\<simeq> c\"", "lemma pequiv_pr_trans[intro,trans]:\n  \"\\<lbrakk> a \\<simeq> b; b \\<sqsubseteq> c \\<rbrakk> \\<Longrightarrow> a \\<sqsubseteq> c\"", "lemma pr_pequiv_trans[intro,trans]:\n  \"\\<lbrakk> a \\<sqsubseteq> b; b \\<simeq> c \\<rbrakk> \\<Longrightarrow> a \\<sqsubseteq> c\"", "lemma pequiv_antisym:\n  \"\\<lbrakk> a \\<sqsubseteq> b; b \\<sqsubseteq> a \\<rbrakk> \\<Longrightarrow> a \\<simeq> b\"", "lemma pequiv_DC:\n  \"\\<lbrakk> a \\<simeq> c; b \\<simeq> d \\<rbrakk> \\<Longrightarrow> (a \\<Sqinter> b) \\<simeq> (c \\<Sqinter> d)\"", "lemma pequiv_AC:\n  \"\\<lbrakk> a \\<simeq> c; b \\<simeq> d \\<rbrakk> \\<Longrightarrow> (a \\<Squnion> b) \\<simeq> (c \\<Squnion> d)\"", "lemma refines_determ:\n  fixes a::\"'s prog\"\n  assumes da: \"determ (wp a)\"\n      and wa: \"well_def a\"\n      and wb: \"well_def b\"\n      and dr: \"a \\<sqsubseteq> b\"\n  shows \"a \\<simeq> b\"", "lemma eq_det: \"\\<And>a b::'s prog. \\<lbrakk> a \\<simeq> b; determ (wp a) \\<rbrakk> \\<Longrightarrow> determ (wp b)\"", "lemma determ_maximal:\n  \"\\<lbrakk> pdeterm a; a \\<le> x \\<rbrakk> \\<Longrightarrow> a = x\"", "lemma drefinesD[dest]:\n  \"\\<lbrakk> drefines \\<phi> G A B; unitary P; unitary Q; P \\<tturnstile> wp A Q \\<rbrakk> \\<Longrightarrow>\n   \\<guillemotleft>G\\<guillemotright> && (P o \\<phi>) \\<tturnstile> wp B (Q o \\<phi>)\"", "lemma drefinesD2:\n  assumes dr:  \"drefines \\<phi> G A B\"\n      and uP:  \"unitary P\"\n      and uQ:  \"unitary Q\"\n      and wpA: \"P \\<tturnstile> wp A Q\"\n      and G:   \"G s\"\n  shows \"(P o \\<phi>) s \\<le> wp B (Q o \\<phi>) s\"", "lemma drefinesD3:\n  assumes dr: \"drefines \\<phi> G a b\"\n      and G:  \"G s\"\n      and uQ: \"unitary Q\"\n      and wa: \"well_def a\"\n  shows \"wp a Q (\\<phi> s) \\<le> wp b (Q o \\<phi>) s\"", "lemma drefinesI[intro]:\n  \"\\<lbrakk> \\<And>P Q. \\<lbrakk> unitary P; unitary Q; P \\<tturnstile> wp A Q \\<rbrakk> \\<Longrightarrow>\n           \\<guillemotleft>G\\<guillemotright> && (P o \\<phi>) \\<tturnstile> wp B (Q o \\<phi>) \\<rbrakk> \\<Longrightarrow>\n   drefines \\<phi> G A B\"", "lemma drefinesI2:\n  fixes   A::\"'a prog\"\n    and   B::\"'b prog\"\n    and   \\<phi>::\"'b \\<Rightarrow> 'a\"\n    and   G::\"'b \\<Rightarrow> bool\"\n  assumes wB: \"well_def B\"\n      and withAs:\n        \"\\<And>P Q s. \\<lbrakk> unitary P; unitary Q;\n                 G s; P \\<tturnstile> wp A Q \\<rbrakk> \\<Longrightarrow> (P o \\<phi>) s \\<le> wp B (Q o \\<phi>) s\"\n  shows \"drefines \\<phi> G A B\"", "lemma dr_strengthen_guard:\n  fixes a::\"'s prog\" and b::\"'t prog\"\n  assumes fg: \"\\<And>s. F s \\<Longrightarrow> G s\"\n      and drab: \"drefines \\<phi> G a b\"\n  shows \"drefines \\<phi> F a b\"", "lemma pcorresI:\n  \"\\<lbrakk> \\<And>Q. unitary Q \\<Longrightarrow> \\<guillemotleft>G\\<guillemotright> && (wp A Q o \\<phi>) = \\<guillemotleft>G\\<guillemotright> && wp B (Q o \\<phi>) \\<rbrakk> \\<Longrightarrow>\n   pcorres \\<phi> G A B\"", "lemma pcorresI2[intro]:\n  fixes A::\"'a prog\" and B::\"'b prog\"\n  assumes withG: \"\\<And>Q s. \\<lbrakk> unitary Q; G s \\<rbrakk> \\<Longrightarrow> wp A Q (\\<phi> s)= wp B (Q o \\<phi>) s\"\n      and wA: \"well_def A\"\n      and wB: \"well_def B\"\n  shows \"pcorres \\<phi> G A B\"", "lemma pcorresD:\n  \"\\<lbrakk> pcorres \\<phi> G A B; unitary Q \\<rbrakk> \\<Longrightarrow> \\<guillemotleft>G\\<guillemotright> && (wp A Q o \\<phi>) = \\<guillemotleft>G\\<guillemotright> && wp B (Q o \\<phi>)\"", "lemma pcorresD2:\n  assumes pc: \"pcorres \\<phi> G A B\"\n      and uQ: \"unitary Q\"\n      and wA: \"well_def A\" and wB: \"well_def B\"\n      and G: \"G s\"\n  shows \"wp A Q (\\<phi> s) = wp B (Q o \\<phi>) s\"", "lemma refines_drefines:\n  fixes a::\"'s prog\"\n  assumes rab: \"a \\<sqsubseteq> b\" and wb: \"well_def b\"\n  shows \"drefines (\\<lambda>s. s) G a b\"", "lemma dr_trans[trans]:\n  fixes A::\"'a prog\" and B::\"'b prog\" and C::\"'c prog\"\n  assumes drAB: \"drefines \\<phi> G A B\"\n      and drBC: \"drefines \\<phi>' G' B C\"\n      and Gimp: \"\\<And>s. G' s \\<Longrightarrow> G (\\<phi>' s)\"\n  shows \"drefines (\\<phi> o \\<phi>') G' A C\"", "lemma pr_dr_trans[trans]:\n  assumes prAB: \"A \\<sqsubseteq> B\"\n      and drBC: \"drefines \\<phi> G B C\"\n  shows \"drefines \\<phi> G A C\"", "lemma dr_pr_trans[trans]:\n  assumes drAB: \"drefines \\<phi> G A B\"\n  assumes prBC: \"B \\<sqsubseteq> C\"\n  shows \"drefines \\<phi> G A C\"", "lemma dr_refl:\n  assumes wa: \"well_def a\"\n      and comm: \"\\<And>Q. unitary Q \\<Longrightarrow> wp a Q o \\<phi> \\<tturnstile> wp a (Q o \\<phi>)\"\n  shows \"drefines \\<phi> G a a\"", "lemma pcorres_drefine:\n  assumes corres: \"pcorres \\<phi> G A C\"\n      and wC: \"well_def C\"\n  shows \"drefines \\<phi> G A C\"", "lemma drefines_determ:\n  fixes a::\"'a prog\" and b::\"'b prog\"\n  assumes da: \"determ (wp a)\"\n      and wa: \"well_def a\"\n      and wb: \"well_def b\"\n      and dr: \"drefines \\<phi> G a b\"\n  shows \"pcorres \\<phi> G a b\"", "lemma pcorres_Skip:\n  \"pcorres \\<phi> G Skip Skip\"", "lemma pcorres_Seq:\n  fixes A::\"'b prog\" and B::\"'c prog\"\n    and C::\"'b prog\" and D::\"'c prog\"\n    and \\<phi>::\"'c \\<Rightarrow> 'b\"\n  assumes pcAB: \"pcorres \\<phi> G A B\"\n      and pcCD: \"pcorres \\<phi> H C D\"\n      and wA: \"well_def A\" and wB: \"well_def B\"\n      and wC: \"well_def C\" and wD: \"well_def D\"\n      and p3p2: \"\\<And>Q. unitary Q \\<Longrightarrow> \\<guillemotleft>I\\<guillemotright> && wp B Q = wp B (\\<guillemotleft>H\\<guillemotright> && Q)\"\n      and p1p3: \"\\<And>s. G s \\<Longrightarrow> I s\"\n  shows \"pcorres \\<phi> G (A;;C) (B;;D)\"", "lemma dr_Skip:\n  fixes \\<phi>::\"'c \\<Rightarrow> 'b\"\n  shows \"drefines \\<phi> G Skip Skip\"", "lemma dr_Abort:\n  fixes \\<phi>::\"'c \\<Rightarrow> 'b\"\n  shows \"drefines \\<phi> G Abort Abort\"", "lemma dr_Apply:\n  fixes \\<phi>::\"'c \\<Rightarrow> 'b\"\n  assumes commutes: \"f o \\<phi> = \\<phi> o g\"\n  shows \"drefines \\<phi> G (Apply f) (Apply g)\"", "lemma dr_Seq:\n  assumes drAB: \"drefines \\<phi> P A B\"\n      and drBC: \"drefines \\<phi> Q C D\"\n      and wpB:  \"\\<guillemotleft>P\\<guillemotright> \\<tturnstile> wp B \\<guillemotleft>Q\\<guillemotright>\"\n      and wB:   \"well_def B\"\n      and wC:   \"well_def C\"\n      and wD:   \"well_def D\"\n  shows \"drefines \\<phi> P (A;;C) (B;;D)\"", "lemma dr_repeat:\n  fixes \\<phi> :: \"'a \\<Rightarrow> 'b\"\n  assumes dr_ab: \"drefines \\<phi> G a b\"\n      and Gpr:  \"\\<guillemotleft>G\\<guillemotright> \\<tturnstile> wp b \\<guillemotleft>G\\<guillemotright>\"\n      and wa:    \"well_def a\"\n      and wb:    \"well_def b\"\n  shows \"drefines \\<phi> G (repeat n a) (repeat n b)\" (is \"?X n\")"], "translations": [["", "lemma refinesI[intro]:\n  \"\\<lbrakk> \\<And>P. sound P \\<Longrightarrow> wp prog P \\<tturnstile> wp prog' P \\<rbrakk> \\<Longrightarrow> prog \\<sqsubseteq> prog'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        sound P \\<Longrightarrow>\n        wp prog P \\<tturnstile> wp prog' P) \\<Longrightarrow>\n    prog \\<sqsubseteq> prog'", "unfolding refines_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        sound P \\<Longrightarrow>\n        wp prog P \\<tturnstile> wp prog' P) \\<Longrightarrow>\n    \\<forall>P. sound P \\<longrightarrow> wp prog P \\<tturnstile> wp prog' P", "by(simp)"], ["", "lemma refinesD[dest]:\n  \"\\<lbrakk> prog \\<sqsubseteq> prog'; sound P \\<rbrakk> \\<Longrightarrow> wp prog P \\<tturnstile> wp prog' P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<sqsubseteq> prog'; sound P\\<rbrakk>\n    \\<Longrightarrow> wp prog P \\<tturnstile> wp prog' P", "unfolding refines_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>P.\n                sound P \\<longrightarrow>\n                wp prog P \\<tturnstile> wp prog' P;\n     sound P\\<rbrakk>\n    \\<Longrightarrow> wp prog P \\<tturnstile> wp prog' P", "by(simp)"], ["", "text \\<open>The equivalence relation below will turn out to be that induced by refinement. It is also\nthe application of @{term equiv_trans} to the weakest precondition.\\<close>"], ["", "definition\n  pequiv :: \"'s prog \\<Rightarrow> 's prog \\<Rightarrow> bool\" (infix \"\\<simeq>\" 70)\nwhere\n  \"prog \\<simeq> prog' \\<equiv> \\<forall>P. sound P \\<longrightarrow> wp prog P = wp prog' P\""], ["", "lemma pequivI[intro]:\n  \"\\<lbrakk> \\<And>P. sound P \\<Longrightarrow> wp prog P = wp prog' P \\<rbrakk> \\<Longrightarrow> prog \\<simeq> prog'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        sound P \\<Longrightarrow> wp prog P = wp prog' P) \\<Longrightarrow>\n    prog \\<simeq> prog'", "unfolding pequiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        sound P \\<Longrightarrow> wp prog P = wp prog' P) \\<Longrightarrow>\n    \\<forall>P. sound P \\<longrightarrow> wp prog P = wp prog' P", "by(simp)"], ["", "lemma pequivD[dest,simp]:\n  \"\\<lbrakk> prog \\<simeq> prog'; sound P \\<rbrakk> \\<Longrightarrow> wp prog P = wp prog' P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog \\<simeq> prog'; sound P\\<rbrakk>\n    \\<Longrightarrow> wp prog P = wp prog' P", "unfolding pequiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>P. sound P \\<longrightarrow> wp prog P = wp prog' P;\n     sound P\\<rbrakk>\n    \\<Longrightarrow> wp prog P = wp prog' P", "by(simp)"], ["", "lemma pequiv_equiv_trans:\n  \"a \\<simeq> b \\<longleftrightarrow> equiv_trans (wp a) (wp b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<simeq> b = equiv_trans (wp a) (wp b)", "by(auto)"], ["", "subsection \\<open>Simple Identities\\<close>"], ["", "text \\<open>The following identities involve only the primitive operations as defined in\n\\autoref{s:syntax}, and refinement as defined above.\\<close>"], ["", "subsubsection \\<open>Laws following from the basic arithmetic of the operators seperately\\<close>"], ["", "lemma DC_comm[ac_simps]:\n  \"a \\<Sqinter> b = b \\<Sqinter> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<Sqinter> b = b \\<Sqinter> a", "unfolding DC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ab Q s. min (a ab Q s) (b ab Q s)) =\n    (\\<lambda>ab Q s. min (b ab Q s) (a ab Q s))", "by(simp add:ac_simps)"], ["", "lemma DC_assoc[ac_simps]:\n  \"a \\<Sqinter> (b \\<Sqinter> c) = (a \\<Sqinter> b) \\<Sqinter> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<Sqinter> b \\<Sqinter> c = (a \\<Sqinter> b) \\<Sqinter> c", "unfolding DC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ab Q s. min (a ab Q s) (min (b ab Q s) (c ab Q s))) =\n    (\\<lambda>ab Q s. min (min (a ab Q s) (b ab Q s)) (c ab Q s))", "by(simp add:ac_simps)"], ["", "lemma DC_idem:\n  \"a \\<Sqinter> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<Sqinter> a = a", "unfolding DC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ab Q s. min (a ab Q s) (a ab Q s)) = a", "by(simp)"], ["", "lemma AC_comm[ac_simps]:\n  \"a \\<Squnion> b = b \\<Squnion> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<Squnion> b = b \\<Squnion> a", "unfolding AC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ab Q s. max (a ab Q s) (b ab Q s)) =\n    (\\<lambda>ab Q s. max (b ab Q s) (a ab Q s))", "by(simp add:ac_simps)"], ["", "lemma AC_assoc[ac_simps]:\n  \"a \\<Squnion> (b \\<Squnion> c) = (a \\<Squnion> b) \\<Squnion> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<Squnion> b \\<Squnion> c = (a \\<Squnion> b) \\<Squnion> c", "unfolding AC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ab Q s. max (a ab Q s) (max (b ab Q s) (c ab Q s))) =\n    (\\<lambda>ab Q s. max (max (a ab Q s) (b ab Q s)) (c ab Q s))", "by(simp add:ac_simps)"], ["", "lemma AC_idem:\n  \"a \\<Squnion> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<Squnion> a = a", "unfolding AC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ab Q s. max (a ab Q s) (a ab Q s)) = a", "by(simp)"], ["", "lemma PC_quasi_comm:\n  \"a \\<^bsub>p\\<^esub>\\<oplus> b = b \\<^bsub>(\\<lambda>s. 1 - p s)\\<^esub>\\<oplus> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<^bsub>p\\<^esub>\\<oplus> b =\n    b \\<^bsub>(\\<lambda>s. 1 - p s)\\<^esub>\\<oplus> a", "unfolding PC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ab Q s. p s * a ab Q s + (1 - p s) * b ab Q s) =\n    (\\<lambda>ab Q s. (1 - p s) * b ab Q s + (1 - (1 - p s)) * a ab Q s)", "by(simp add:algebra_simps)"], ["", "lemma PC_idem:\n  \"a \\<^bsub>p\\<^esub>\\<oplus> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<^bsub>p\\<^esub>\\<oplus> a = a", "unfolding PC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ab Q s. p s * a ab Q s + (1 - p s) * a ab Q s) = a", "by(simp add:algebra_simps)"], ["", "lemma Seq_assoc[ac_simps]:\n  \"A ;; (B ;; C) = A ;; B ;; C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ;; (B ;; C) = A ;; B ;; C", "by(simp add:Seq_def o_def)"], ["", "lemma Abort_refines[intro]:\n  \"well_def a \\<Longrightarrow> Abort \\<sqsubseteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def a \\<Longrightarrow> Abort \\<sqsubseteq> a", "by(rule refinesI, unfold wp_eval, auto dest!:well_def_wp_healthy)"], ["", "subsubsection \\<open>Laws relating demonic choice and refinement\\<close>"], ["", "lemma left_refines_DC:\n  \"(a \\<Sqinter> b) \\<sqsubseteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<Sqinter> b) \\<sqsubseteq> a", "by(auto intro!:refinesI simp:wp_eval)"], ["", "lemma right_refines_DC:\n  \"(a \\<Sqinter> b) \\<sqsubseteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<Sqinter> b) \\<sqsubseteq> b", "by(auto intro!:refinesI simp:wp_eval)"], ["", "lemma DC_refines:\n  fixes a::\"'s prog\" and b and c\n  assumes rab: \"a \\<sqsubseteq> b\" and rac: \"a \\<sqsubseteq> c\"\n  shows \"a \\<sqsubseteq> (b \\<Sqinter> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqsubseteq> (b \\<Sqinter> c)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow> wp a P \\<tturnstile> wp (b \\<Sqinter> c) P", "fix P::\"'s \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow> wp a P \\<tturnstile> wp (b \\<Sqinter> c) P", "assume sP: \"sound P\""], ["proof (state)\nthis:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow> wp a P \\<tturnstile> wp (b \\<Sqinter> c) P", "with assms"], ["proof (chain)\npicking this:\n  a \\<sqsubseteq> b\n  a \\<sqsubseteq> c\n  sound P", "have \"wp a P \\<tturnstile> wp b P\" and \"wp a P \\<tturnstile> wp c P\""], ["proof (prove)\nusing this:\n  a \\<sqsubseteq> b\n  a \\<sqsubseteq> c\n  sound P\n\ngoal (1 subgoal):\n 1. wp a P \\<tturnstile> wp b P &&& wp a P \\<tturnstile> wp c P", "by(auto dest:refinesD)"], ["proof (state)\nthis:\n  wp a P \\<tturnstile> wp b P\n  wp a P \\<tturnstile> wp c P\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow> wp a P \\<tturnstile> wp (b \\<Sqinter> c) P", "thus \"wp a P \\<tturnstile> wp (b \\<Sqinter> c) P\""], ["proof (prove)\nusing this:\n  wp a P \\<tturnstile> wp b P\n  wp a P \\<tturnstile> wp c P\n\ngoal (1 subgoal):\n 1. wp a P \\<tturnstile> wp (b \\<Sqinter> c) P", "by(auto simp:wp_eval intro:min.boundedI)"], ["proof (state)\nthis:\n  wp a P \\<tturnstile> wp (b \\<Sqinter> c) P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DC_mono:\n  fixes a::\"'s prog\"\n  assumes rab: \"a \\<sqsubseteq> b\" and rcd: \"c \\<sqsubseteq> d\"\n  shows \"(a \\<Sqinter> c) \\<sqsubseteq> (b \\<Sqinter> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<Sqinter> c) \\<sqsubseteq> (b \\<Sqinter> d)", "proof(rule refinesI, unfold wp_eval, rule le_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       min (wp a P x) (wp c P x) \\<le> min (wp b P x) (wp d P x)", "fix P::\"'s \\<Rightarrow> real\" and s::'s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       min (wp a P x) (wp c P x) \\<le> min (wp b P x) (wp d P x)", "assume sP: \"sound P\""], ["proof (state)\nthis:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       min (wp a P x) (wp c P x) \\<le> min (wp b P x) (wp d P x)", "with assms"], ["proof (chain)\npicking this:\n  a \\<sqsubseteq> b\n  c \\<sqsubseteq> d\n  sound P", "have \"wp a P s \\<le> wp b P s\" and \"wp c P s \\<le> wp d P s\""], ["proof (prove)\nusing this:\n  a \\<sqsubseteq> b\n  c \\<sqsubseteq> d\n  sound P\n\ngoal (1 subgoal):\n 1. wp a P s \\<le> wp b P s &&& wp c P s \\<le> wp d P s", "by(auto)"], ["proof (state)\nthis:\n  wp a P s \\<le> wp b P s\n  wp c P s \\<le> wp d P s\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       min (wp a P x) (wp c P x) \\<le> min (wp b P x) (wp d P x)", "thus \"min (wp a P s) (wp c P s) \\<le> min (wp b P s) (wp d P s)\""], ["proof (prove)\nusing this:\n  wp a P s \\<le> wp b P s\n  wp c P s \\<le> wp d P s\n\ngoal (1 subgoal):\n 1. min (wp a P s) (wp c P s) \\<le> min (wp b P s) (wp d P s)", "by(auto)"], ["proof (state)\nthis:\n  min (wp a P s) (wp c P s) \\<le> min (wp b P s) (wp d P s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Laws relating angelic choice and refinement\\<close>"], ["", "lemma left_refines_AC:\n  \"a \\<sqsubseteq> (a \\<Squnion> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqsubseteq> (a \\<Squnion> b)", "by(auto intro!:refinesI simp:wp_eval)"], ["", "lemma right_refines_AC:\n  \"b \\<sqsubseteq> (a \\<Squnion> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sqsubseteq> (a \\<Squnion> b)", "by(auto intro!:refinesI simp:wp_eval)"], ["", "lemma AC_refines:\n  fixes a::\"'s prog\" and b and c\n  assumes rac: \"a \\<sqsubseteq> c\" and rbc: \"b \\<sqsubseteq> c\"\n  shows \"(a \\<Squnion> b) \\<sqsubseteq> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<Squnion> b) \\<sqsubseteq> c", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow> wp (a \\<Squnion> b) P \\<tturnstile> wp c P", "fix P::\"'s \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow> wp (a \\<Squnion> b) P \\<tturnstile> wp c P", "assume sP: \"sound P\""], ["proof (state)\nthis:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow> wp (a \\<Squnion> b) P \\<tturnstile> wp c P", "with assms"], ["proof (chain)\npicking this:\n  a \\<sqsubseteq> c\n  b \\<sqsubseteq> c\n  sound P", "have \"\\<And>s. wp a P s \\<le> wp c P s\"\n              and \"\\<And>s. wp b P s \\<le> wp c P s\""], ["proof (prove)\nusing this:\n  a \\<sqsubseteq> c\n  b \\<sqsubseteq> c\n  sound P\n\ngoal (1 subgoal):\n 1. (\\<And>s. wp a P s \\<le> wp c P s) &&&\n    (\\<And>s. wp b P s \\<le> wp c P s)", "by(auto dest:refinesD)"], ["proof (state)\nthis:\n  wp a P ?s \\<le> wp c P ?s\n  wp b P ?s \\<le> wp c P ?s\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow> wp (a \\<Squnion> b) P \\<tturnstile> wp c P", "thus \"wp (a \\<Squnion> b) P \\<tturnstile> wp c P\""], ["proof (prove)\nusing this:\n  wp a P ?s \\<le> wp c P ?s\n  wp b P ?s \\<le> wp c P ?s\n\ngoal (1 subgoal):\n 1. wp (a \\<Squnion> b) P \\<tturnstile> wp c P", "unfolding wp_eval"], ["proof (prove)\nusing this:\n  wp a P ?s \\<le> wp c P ?s\n  wp b P ?s \\<le> wp c P ?s\n\ngoal (1 subgoal):\n 1. \\<lambda>s. max (wp a P s) (wp b P s) \\<tturnstile> wp c P", "by(auto)"], ["proof (state)\nthis:\n  wp (a \\<Squnion> b) P \\<tturnstile> wp c P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AC_mono:\n  fixes a::\"'s prog\"\n  assumes rab: \"a \\<sqsubseteq> b\" and rcd: \"c \\<sqsubseteq> d\"\n  shows \"(a \\<Squnion> c) \\<sqsubseteq> (b \\<Squnion> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<Squnion> c) \\<sqsubseteq> (b \\<Squnion> d)", "proof(rule refinesI, unfold wp_eval, rule le_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       max (wp a P x) (wp c P x) \\<le> max (wp b P x) (wp d P x)", "fix P::\"'s \\<Rightarrow> real\" and s::'s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       max (wp a P x) (wp c P x) \\<le> max (wp b P x) (wp d P x)", "assume sP: \"sound P\""], ["proof (state)\nthis:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       max (wp a P x) (wp c P x) \\<le> max (wp b P x) (wp d P x)", "with assms"], ["proof (chain)\npicking this:\n  a \\<sqsubseteq> b\n  c \\<sqsubseteq> d\n  sound P", "have \"wp a P s \\<le> wp b P s\" and \"wp c P s \\<le> wp d P s\""], ["proof (prove)\nusing this:\n  a \\<sqsubseteq> b\n  c \\<sqsubseteq> d\n  sound P\n\ngoal (1 subgoal):\n 1. wp a P s \\<le> wp b P s &&& wp c P s \\<le> wp d P s", "by(auto)"], ["proof (state)\nthis:\n  wp a P s \\<le> wp b P s\n  wp c P s \\<le> wp d P s\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       max (wp a P x) (wp c P x) \\<le> max (wp b P x) (wp d P x)", "thus \"max (wp a P s) (wp c P s) \\<le> max (wp b P s) (wp d P s)\""], ["proof (prove)\nusing this:\n  wp a P s \\<le> wp b P s\n  wp c P s \\<le> wp d P s\n\ngoal (1 subgoal):\n 1. max (wp a P s) (wp c P s) \\<le> max (wp b P s) (wp d P s)", "by(auto)"], ["proof (state)\nthis:\n  max (wp a P s) (wp c P s) \\<le> max (wp b P s) (wp d P s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Laws depending on the arithmetic of @{term \"a \\<^bsub>p\\<^esub>\\<oplus> b\"} and @{term \"a \\<Sqinter> b\"}\ntogether\\<close>"], ["", "lemma DC_refines_PC:\n  assumes unit: \"unitary p\"\n  shows \"(a \\<Sqinter> b) \\<sqsubseteq> (a \\<^bsub>p\\<^esub>\\<oplus> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<Sqinter> b) \\<sqsubseteq> (a \\<^bsub>p\\<^esub>\\<oplus> b)", "proof(rule refinesI, unfold wp_eval, rule le_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       min (wp a P x) (wp b P x) \\<le> p x * wp a P x + (1 - p x) * wp b P x", "fix s and P::\"'a \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       min (wp a P x) (wp b P x) \\<le> p x * wp a P x + (1 - p x) * wp b P x", "assume sound: \"sound P\""], ["proof (state)\nthis:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       min (wp a P x) (wp b P x) \\<le> p x * wp a P x + (1 - p x) * wp b P x", "from unit"], ["proof (chain)\npicking this:\n  unitary p", "have nn_p: \"0 \\<le> p s\""], ["proof (prove)\nusing this:\n  unitary p\n\ngoal (1 subgoal):\n 1. 0 \\<le> p s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> p s\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       min (wp a P x) (wp b P x) \\<le> p x * wp a P x + (1 - p x) * wp b P x", "from unit"], ["proof (chain)\npicking this:\n  unitary p", "have \"p s \\<le> 1\""], ["proof (prove)\nusing this:\n  unitary p\n\ngoal (1 subgoal):\n 1. p s \\<le> 1", "by(blast)"], ["proof (state)\nthis:\n  p s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       min (wp a P x) (wp b P x) \\<le> p x * wp a P x + (1 - p x) * wp b P x", "hence nn_np: \"0 \\<le> 1 - p s\""], ["proof (prove)\nusing this:\n  p s \\<le> 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> 1 - p s", "by(simp)"], ["proof (state)\nthis:\n  0 \\<le> 1 - p s\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       min (wp a P x) (wp b P x) \\<le> p x * wp a P x + (1 - p x) * wp b P x", "show \"min (wp a P s) (wp b P s) \\<le> p s * wp a P s + (1 - p s) * wp b P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (wp a P s) (wp b P s) \\<le> p s * wp a P s + (1 - p s) * wp b P s", "proof(cases \"wp a P s \\<le> wp b P s\",\n      simp_all add:min.absorb1 min.absorb2)"], ["proof (state)\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "case True"], ["proof (state)\nthis:\n  wp a P s \\<le> wp b P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "note le = this"], ["proof (state)\nthis:\n  wp a P s \\<le> wp b P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "have \"wp a P s = (p s + (1 - p s)) * wp a P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp a P s = (p s + (1 - p s)) * wp a P s", "by(simp)"], ["proof (state)\nthis:\n  wp a P s = (p s + (1 - p s)) * wp a P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "also"], ["proof (state)\nthis:\n  wp a P s = (p s + (1 - p s)) * wp a P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "have \"... = p s * wp a P s + (1 - p s) * wp a P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p s + (1 - p s)) * wp a P s = p s * wp a P s + (1 - p s) * wp a P s", "by(simp only: distrib_right)"], ["proof (state)\nthis:\n  (p s + (1 - p s)) * wp a P s = p s * wp a P s + (1 - p s) * wp a P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "also"], ["proof (state)\nthis:\n  (p s + (1 - p s)) * wp a P s = p s * wp a P s + (1 - p s) * wp a P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "{"], ["proof (state)\nthis:\n  (p s + (1 - p s)) * wp a P s = p s * wp a P s + (1 - p s) * wp a P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "from le and nn_np"], ["proof (chain)\npicking this:\n  wp a P s \\<le> wp b P s\n  0 \\<le> 1 - p s", "have \"(1 - p s) * wp a P s \\<le> (1 - p s) * wp b P s\""], ["proof (prove)\nusing this:\n  wp a P s \\<le> wp b P s\n  0 \\<le> 1 - p s\n\ngoal (1 subgoal):\n 1. (1 - p s) * wp a P s \\<le> (1 - p s) * wp b P s", "by(rule mult_left_mono)"], ["proof (state)\nthis:\n  (1 - p s) * wp a P s \\<le> (1 - p s) * wp b P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "hence \"p s * wp a P s + (1 - p s) * wp a P s \\<le>\n        p s * wp a P s + (1 - p s) * wp b P s\""], ["proof (prove)\nusing this:\n  (1 - p s) * wp a P s \\<le> (1 - p s) * wp b P s\n\ngoal (1 subgoal):\n 1. p s * wp a P s + (1 - p s) * wp a P s\n    \\<le> p s * wp a P s + (1 - p s) * wp b P s", "by(rule add_left_mono)"], ["proof (state)\nthis:\n  p s * wp a P s + (1 - p s) * wp a P s\n  \\<le> p s * wp a P s + (1 - p s) * wp b P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "}"], ["proof (state)\nthis:\n  p s * wp a P s + (1 - p s) * wp a P s\n  \\<le> p s * wp a P s + (1 - p s) * wp b P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "finally"], ["proof (chain)\npicking this:\n  wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "show \"wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\""], ["proof (prove)\nusing this:\n  wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n\ngoal (1 subgoal):\n 1. wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "."], ["proof (state)\nthis:\n  wp a P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "case False"], ["proof (state)\nthis:\n  \\<not> wp a P s \\<le> wp b P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "then"], ["proof (chain)\npicking this:\n  \\<not> wp a P s \\<le> wp b P s", "have le: \"wp b P s \\<le> wp a P s\""], ["proof (prove)\nusing this:\n  \\<not> wp a P s \\<le> wp b P s\n\ngoal (1 subgoal):\n 1. wp b P s \\<le> wp a P s", "by(simp)"], ["proof (state)\nthis:\n  wp b P s \\<le> wp a P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "have \"wp b P s = (p s + (1 - p s)) * wp b P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp b P s = (p s + (1 - p s)) * wp b P s", "by(simp)"], ["proof (state)\nthis:\n  wp b P s = (p s + (1 - p s)) * wp b P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "also"], ["proof (state)\nthis:\n  wp b P s = (p s + (1 - p s)) * wp b P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "have \"... = p s * wp b P s + (1 - p s) * wp b P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p s + (1 - p s)) * wp b P s = p s * wp b P s + (1 - p s) * wp b P s", "by(simp only:distrib_right)"], ["proof (state)\nthis:\n  (p s + (1 - p s)) * wp b P s = p s * wp b P s + (1 - p s) * wp b P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "also"], ["proof (state)\nthis:\n  (p s + (1 - p s)) * wp b P s = p s * wp b P s + (1 - p s) * wp b P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "{"], ["proof (state)\nthis:\n  (p s + (1 - p s)) * wp b P s = p s * wp b P s + (1 - p s) * wp b P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "from le and nn_p"], ["proof (chain)\npicking this:\n  wp b P s \\<le> wp a P s\n  0 \\<le> p s", "have \"p s * wp b P s \\<le> p s * wp a P s\""], ["proof (prove)\nusing this:\n  wp b P s \\<le> wp a P s\n  0 \\<le> p s\n\ngoal (1 subgoal):\n 1. p s * wp b P s \\<le> p s * wp a P s", "by(rule mult_left_mono)"], ["proof (state)\nthis:\n  p s * wp b P s \\<le> p s * wp a P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "hence \"p s * wp b P s + (1 - p s) * wp b P s \\<le>\n        p s * wp a P s + (1 - p s) * wp b P s\""], ["proof (prove)\nusing this:\n  p s * wp b P s \\<le> p s * wp a P s\n\ngoal (1 subgoal):\n 1. p s * wp b P s + (1 - p s) * wp b P s\n    \\<le> p s * wp a P s + (1 - p s) * wp b P s", "by(rule add_right_mono)"], ["proof (state)\nthis:\n  p s * wp b P s + (1 - p s) * wp b P s\n  \\<le> p s * wp a P s + (1 - p s) * wp b P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "}"], ["proof (state)\nthis:\n  p s * wp b P s + (1 - p s) * wp b P s\n  \\<le> p s * wp a P s + (1 - p s) * wp b P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "finally"], ["proof (chain)\npicking this:\n  wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "show \"wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\""], ["proof (prove)\nusing this:\n  wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n\ngoal (1 subgoal):\n 1. wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s", "."], ["proof (state)\nthis:\n  wp b P s \\<le> p s * wp a P s + (1 - p s) * wp b P s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  min (wp a P s) (wp b P s) \\<le> p s * wp a P s + (1 - p s) * wp b P s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Laws depending on the arithmetic of @{term \"a \\<^bsub>p\\<^esub>\\<oplus> b\"} and @{term \"a \\<Squnion> b\"}\ntogether\\<close>"], ["", "lemma PC_refines_AC:\n  assumes unit: \"unitary p\"\n  shows \"(a \\<^bsub>p\\<^esub>\\<oplus> b) \\<sqsubseteq> (a \\<Squnion> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<^bsub>p\\<^esub>\\<oplus> b) \\<sqsubseteq> (a \\<Squnion> b)", "proof(rule refinesI, unfold wp_eval, rule le_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       p x * wp a P x + (1 - p x) * wp b P x \\<le> max (wp a P x) (wp b P x)", "fix s and P::\"'a \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       p x * wp a P x + (1 - p x) * wp b P x \\<le> max (wp a P x) (wp b P x)", "assume sound: \"sound P\""], ["proof (state)\nthis:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       p x * wp a P x + (1 - p x) * wp b P x \\<le> max (wp a P x) (wp b P x)", "from unit"], ["proof (chain)\npicking this:\n  unitary p", "have \"p s \\<le> 1\""], ["proof (prove)\nusing this:\n  unitary p\n\ngoal (1 subgoal):\n 1. p s \\<le> 1", "by(blast)"], ["proof (state)\nthis:\n  p s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       p x * wp a P x + (1 - p x) * wp b P x \\<le> max (wp a P x) (wp b P x)", "hence nn_np: \"0 \\<le> 1 - p s\""], ["proof (prove)\nusing this:\n  p s \\<le> 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> 1 - p s", "by(simp)"], ["proof (state)\nthis:\n  0 \\<le> 1 - p s\n\ngoal (1 subgoal):\n 1. \\<And>P x.\n       sound P \\<Longrightarrow>\n       p x * wp a P x + (1 - p x) * wp b P x \\<le> max (wp a P x) (wp b P x)", "show \"p s * wp a P s + (1 - p s) * wp b P s \\<le>\n        max (wp a P s) (wp b P s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "proof(cases \"wp a P s \\<le> wp b P s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "case True"], ["proof (state)\nthis:\n  wp a P s \\<le> wp b P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "note leab = this"], ["proof (state)\nthis:\n  wp a P s \\<le> wp b P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "with unit nn_np"], ["proof (chain)\npicking this:\n  unitary p\n  0 \\<le> 1 - p s\n  wp a P s \\<le> wp b P s", "have \"p s * wp a P s + (1 - p s) * wp b P s \\<le>\n          p s * wp b P s + (1 - p s) * wp b P s\""], ["proof (prove)\nusing this:\n  unitary p\n  0 \\<le> 1 - p s\n  wp a P s \\<le> wp b P s\n\ngoal (1 subgoal):\n 1. p s * wp a P s + (1 - p s) * wp b P s\n    \\<le> p s * wp b P s + (1 - p s) * wp b P s", "by(auto intro:add_mono mult_left_mono)"], ["proof (state)\nthis:\n  p s * wp a P s + (1 - p s) * wp b P s\n  \\<le> p s * wp b P s + (1 - p s) * wp b P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "also"], ["proof (state)\nthis:\n  p s * wp a P s + (1 - p s) * wp b P s\n  \\<le> p s * wp b P s + (1 - p s) * wp b P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "have \"... = wp b P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p s * wp b P s + (1 - p s) * wp b P s = wp b P s", "by(auto simp:field_simps)"], ["proof (state)\nthis:\n  p s * wp b P s + (1 - p s) * wp b P s = wp b P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "also"], ["proof (state)\nthis:\n  p s * wp b P s + (1 - p s) * wp b P s = wp b P s\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "from leab"], ["proof (chain)\npicking this:\n  wp a P s \\<le> wp b P s", "have \"... = max (wp a P s) (wp b P s)\""], ["proof (prove)\nusing this:\n  wp a P s \\<le> wp b P s\n\ngoal (1 subgoal):\n 1. wp b P s = max (wp a P s) (wp b P s)", "by(auto)"], ["proof (state)\nthis:\n  wp b P s = max (wp a P s) (wp b P s)\n\ngoal (2 subgoals):\n 1. wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)\n 2. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "finally"], ["proof (chain)\npicking this:\n  p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "show ?thesis"], ["proof (prove)\nusing this:\n  p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)\n\ngoal (1 subgoal):\n 1. p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "."], ["proof (state)\nthis:\n  p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "case False"], ["proof (state)\nthis:\n  \\<not> wp a P s \\<le> wp b P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "note leba = this"], ["proof (state)\nthis:\n  \\<not> wp a P s \\<le> wp b P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "with unit nn_np"], ["proof (chain)\npicking this:\n  unitary p\n  0 \\<le> 1 - p s\n  \\<not> wp a P s \\<le> wp b P s", "have \"p s * wp a P s + (1 - p s) * wp b P s \\<le>\n          p s * wp a P s + (1 - p s) * wp a P s\""], ["proof (prove)\nusing this:\n  unitary p\n  0 \\<le> 1 - p s\n  \\<not> wp a P s \\<le> wp b P s\n\ngoal (1 subgoal):\n 1. p s * wp a P s + (1 - p s) * wp b P s\n    \\<le> p s * wp a P s + (1 - p s) * wp a P s", "by(auto intro:add_mono mult_left_mono)"], ["proof (state)\nthis:\n  p s * wp a P s + (1 - p s) * wp b P s\n  \\<le> p s * wp a P s + (1 - p s) * wp a P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "also"], ["proof (state)\nthis:\n  p s * wp a P s + (1 - p s) * wp b P s\n  \\<le> p s * wp a P s + (1 - p s) * wp a P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "have \"... = wp a P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p s * wp a P s + (1 - p s) * wp a P s = wp a P s", "by(auto simp:field_simps)"], ["proof (state)\nthis:\n  p s * wp a P s + (1 - p s) * wp a P s = wp a P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "also"], ["proof (state)\nthis:\n  p s * wp a P s + (1 - p s) * wp a P s = wp a P s\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "from leba"], ["proof (chain)\npicking this:\n  \\<not> wp a P s \\<le> wp b P s", "have \"... = max (wp a P s) (wp b P s)\""], ["proof (prove)\nusing this:\n  \\<not> wp a P s \\<le> wp b P s\n\ngoal (1 subgoal):\n 1. wp a P s = max (wp a P s) (wp b P s)", "by(auto)"], ["proof (state)\nthis:\n  wp a P s = max (wp a P s) (wp b P s)\n\ngoal (1 subgoal):\n 1. \\<not> wp a P s \\<le> wp b P s \\<Longrightarrow>\n    p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "finally"], ["proof (chain)\npicking this:\n  p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "show ?thesis"], ["proof (prove)\nusing this:\n  p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)\n\ngoal (1 subgoal):\n 1. p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)", "."], ["proof (state)\nthis:\n  p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p s * wp a P s + (1 - p s) * wp b P s \\<le> max (wp a P s) (wp b P s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Laws depending on the arithmetic of @{term \"a \\<Squnion> b\"} and @{term \"a \\<Sqinter> b\"} together\n\\<close>"], ["", "lemma DC_refines_AC:\n  \"(a \\<Sqinter> b) \\<sqsubseteq> (a \\<Squnion> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<Sqinter> b) \\<sqsubseteq> (a \\<Squnion> b)", "by(auto intro!:refinesI simp:wp_eval)"], ["", "subsubsection \\<open>Laws Involving Refinement and Equivalence\\<close>"], ["", "lemma pr_trans[trans]:\n  fixes A::\"'a prog\"\n  assumes prAB: \"A \\<sqsubseteq> B\"\n      and prBC: \"B \\<sqsubseteq> C\"\n  shows \"A \\<sqsubseteq> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<sqsubseteq> C", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P. sound P \\<Longrightarrow> wp A P \\<tturnstile> wp C P", "fix P::\"'a \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P. sound P \\<Longrightarrow> wp A P \\<tturnstile> wp C P", "assume sP: \"sound P\""], ["proof (state)\nthis:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>P. sound P \\<Longrightarrow> wp A P \\<tturnstile> wp C P", "with prAB"], ["proof (chain)\npicking this:\n  A \\<sqsubseteq> B\n  sound P", "have \"wp A P \\<tturnstile> wp B P\""], ["proof (prove)\nusing this:\n  A \\<sqsubseteq> B\n  sound P\n\ngoal (1 subgoal):\n 1. wp A P \\<tturnstile> wp B P", "by(blast)"], ["proof (state)\nthis:\n  wp A P \\<tturnstile> wp B P\n\ngoal (1 subgoal):\n 1. \\<And>P. sound P \\<Longrightarrow> wp A P \\<tturnstile> wp C P", "also"], ["proof (state)\nthis:\n  wp A P \\<tturnstile> wp B P\n\ngoal (1 subgoal):\n 1. \\<And>P. sound P \\<Longrightarrow> wp A P \\<tturnstile> wp C P", "from sP and prBC"], ["proof (chain)\npicking this:\n  sound P\n  B \\<sqsubseteq> C", "have \"... \\<tturnstile> wp C P\""], ["proof (prove)\nusing this:\n  sound P\n  B \\<sqsubseteq> C\n\ngoal (1 subgoal):\n 1. wp B P \\<tturnstile> wp C P", "by(blast)"], ["proof (state)\nthis:\n  wp B P \\<tturnstile> wp C P\n\ngoal (1 subgoal):\n 1. \\<And>P. sound P \\<Longrightarrow> wp A P \\<tturnstile> wp C P", "finally"], ["proof (chain)\npicking this:\n  wp A P \\<tturnstile> wp C P", "show \"wp A P \\<tturnstile> ...\""], ["proof (prove)\nusing this:\n  wp A P \\<tturnstile> wp C P\n\ngoal (1 subgoal):\n 1. wp A P \\<tturnstile> wp C P", "."], ["proof (state)\nthis:\n  wp A P \\<tturnstile> wp C P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pequiv_refl[intro!,simp]:\n  \"a \\<simeq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<simeq> a", "by(auto)"], ["", "lemma pequiv_comm[ac_simps]:\n  \"a \\<simeq> b \\<longleftrightarrow> b \\<simeq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<simeq> b = b \\<simeq> a", "unfolding pequiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>P. sound P \\<longrightarrow> wp a P = wp b P) =\n    (\\<forall>P. sound P \\<longrightarrow> wp b P = wp a P)", "by(rule iffI, safe, simp_all)"], ["", "lemma pequiv_pr[dest]:\n  \"a \\<simeq> b \\<Longrightarrow> a \\<sqsubseteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<simeq> b \\<Longrightarrow> a \\<sqsubseteq> b", "by(auto)"], ["", "lemma pequiv_trans[intro,trans]:\n  \"\\<lbrakk> a \\<simeq> b; b \\<simeq> c \\<rbrakk> \\<Longrightarrow> a \\<simeq> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<simeq> b; b \\<simeq> c\\<rbrakk>\n    \\<Longrightarrow> a \\<simeq> c", "unfolding pequiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>P. sound P \\<longrightarrow> wp a P = wp b P;\n     \\<forall>P. sound P \\<longrightarrow> wp b P = wp c P\\<rbrakk>\n    \\<Longrightarrow> \\<forall>P. sound P \\<longrightarrow> wp a P = wp c P", "by(auto intro!:order_trans)"], ["", "lemma pequiv_pr_trans[intro,trans]:\n  \"\\<lbrakk> a \\<simeq> b; b \\<sqsubseteq> c \\<rbrakk> \\<Longrightarrow> a \\<sqsubseteq> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<simeq> b; b \\<sqsubseteq> c\\<rbrakk>\n    \\<Longrightarrow> a \\<sqsubseteq> c", "unfolding pequiv_def refines_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>P. sound P \\<longrightarrow> wp a P = wp b P;\n     \\<forall>P.\n        sound P \\<longrightarrow> wp b P \\<tturnstile> wp c P\\<rbrakk>\n    \\<Longrightarrow> \\<forall>P.\n                         sound P \\<longrightarrow>\n                         wp a P \\<tturnstile> wp c P", "by(simp)"], ["", "lemma pr_pequiv_trans[intro,trans]:\n  \"\\<lbrakk> a \\<sqsubseteq> b; b \\<simeq> c \\<rbrakk> \\<Longrightarrow> a \\<sqsubseteq> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<sqsubseteq> b; b \\<simeq> c\\<rbrakk>\n    \\<Longrightarrow> a \\<sqsubseteq> c", "unfolding pequiv_def refines_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>P.\n                sound P \\<longrightarrow> wp a P \\<tturnstile> wp b P;\n     \\<forall>P. sound P \\<longrightarrow> wp b P = wp c P\\<rbrakk>\n    \\<Longrightarrow> \\<forall>P.\n                         sound P \\<longrightarrow>\n                         wp a P \\<tturnstile> wp c P", "by(simp)"], ["", "text \\<open>Refinement induces equivalence by antisymmetry:\\<close>"], ["", "lemma pequiv_antisym:\n  \"\\<lbrakk> a \\<sqsubseteq> b; b \\<sqsubseteq> a \\<rbrakk> \\<Longrightarrow> a \\<simeq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<sqsubseteq> b; b \\<sqsubseteq> a\\<rbrakk>\n    \\<Longrightarrow> a \\<simeq> b", "by(auto intro:antisym)"], ["", "lemma pequiv_DC:\n  \"\\<lbrakk> a \\<simeq> c; b \\<simeq> d \\<rbrakk> \\<Longrightarrow> (a \\<Sqinter> b) \\<simeq> (c \\<Sqinter> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<simeq> c; b \\<simeq> d\\<rbrakk>\n    \\<Longrightarrow> (a \\<Sqinter> b) \\<simeq> (c \\<Sqinter> d)", "by(auto intro!:DC_mono pequiv_antisym simp:ac_simps)"], ["", "lemma pequiv_AC:\n  \"\\<lbrakk> a \\<simeq> c; b \\<simeq> d \\<rbrakk> \\<Longrightarrow> (a \\<Squnion> b) \\<simeq> (c \\<Squnion> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<simeq> c; b \\<simeq> d\\<rbrakk>\n    \\<Longrightarrow> (a \\<Squnion> b) \\<simeq> (c \\<Squnion> d)", "by(auto intro!:AC_mono pequiv_antisym simp:ac_simps)"], ["", "subsection \\<open>Deterministic Programs are Maximal\\<close>"], ["", "text \\<open>Any sub-additive refinement of a deterministic program is in fact an equivalence.\nDeterministic programs are thus maximal (under the refinement order) among sub-additive programs.\n\\<close>"], ["", "lemma refines_determ:\n  fixes a::\"'s prog\"\n  assumes da: \"determ (wp a)\"\n      and wa: \"well_def a\"\n      and wb: \"well_def b\"\n      and dr: \"a \\<sqsubseteq> b\"\n  shows \"a \\<simeq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<simeq> b", "txt \\<open>Proof by contradiction.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<simeq> b", "proof(rule pequivI, rule contrapos_pp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "from wb"], ["proof (chain)\npicking this:\n  well_def b", "have \"feasible (wp b)\""], ["proof (prove)\nusing this:\n  well_def b\n\ngoal (1 subgoal):\n 1. feasible (wp b)", "by(auto)"], ["proof (state)\nthis:\n  feasible (wp b)\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "with wb"], ["proof (chain)\npicking this:\n  well_def b\n  feasible (wp b)", "have sab: \"sub_add (wp b)\""], ["proof (prove)\nusing this:\n  well_def b\n  feasible (wp b)\n\ngoal (1 subgoal):\n 1. sub_add (wp b)", "by(auto dest: sublinear_subadd[OF well_def_wp_sublinear])"], ["proof (state)\nthis:\n  sub_add (wp b)\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "fix P::\"'s \\<Rightarrow> real\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "assume sP: \"sound P\""], ["proof (state)\nthis:\n  sound P\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "txt \\<open>Assume that @{term a} and @{term b} are not equivalent:\\<close>"], ["proof (state)\nthis:\n  sound P\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "assume ne: \"wp a P \\<noteq> wp b P\""], ["proof (state)\nthis:\n  wp a P \\<noteq> wp b P\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "txt \\<open>Find a point at which they differ.  As @{term \"a \\<sqsubseteq> b\"},\n    @{term \"wp b P s\"} must by strictly greater than @{term \"wp a P s\"}\n    here:\\<close>"], ["proof (state)\nthis:\n  wp a P \\<noteq> wp b P\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "hence \"\\<exists>s. wp a P s < wp b P s\""], ["proof (prove)\nusing this:\n  wp a P \\<noteq> wp b P\n\ngoal (1 subgoal):\n 1. \\<exists>s. wp a P s < wp b P s", "proof(rule contrapos_np)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>s. wp a P s < wp b P s \\<Longrightarrow> wp a P = wp b P", "assume \"\\<not>(\\<exists>s. wp a P s < wp b P s)\""], ["proof (state)\nthis:\n  \\<nexists>s. wp a P s < wp b P s\n\ngoal (1 subgoal):\n 1. \\<nexists>s. wp a P s < wp b P s \\<Longrightarrow> wp a P = wp b P", "hence \"\\<forall>s. wp b P s \\<le> wp a P s\""], ["proof (prove)\nusing this:\n  \\<nexists>s. wp a P s < wp b P s\n\ngoal (1 subgoal):\n 1. \\<forall>s. wp b P s \\<le> wp a P s", "by(auto simp:not_less)"], ["proof (state)\nthis:\n  \\<forall>s. wp b P s \\<le> wp a P s\n\ngoal (1 subgoal):\n 1. \\<nexists>s. wp a P s < wp b P s \\<Longrightarrow> wp a P = wp b P", "hence \"wp b P \\<tturnstile> wp a P\""], ["proof (prove)\nusing this:\n  \\<forall>s. wp b P s \\<le> wp a P s\n\ngoal (1 subgoal):\n 1. wp b P \\<tturnstile> wp a P", "by(auto)"], ["proof (state)\nthis:\n  wp b P \\<tturnstile> wp a P\n\ngoal (1 subgoal):\n 1. \\<nexists>s. wp a P s < wp b P s \\<Longrightarrow> wp a P = wp b P", "moreover"], ["proof (state)\nthis:\n  wp b P \\<tturnstile> wp a P\n\ngoal (1 subgoal):\n 1. \\<nexists>s. wp a P s < wp b P s \\<Longrightarrow> wp a P = wp b P", "from sP dr"], ["proof (chain)\npicking this:\n  sound P\n  a \\<sqsubseteq> b", "have \"wp a P \\<tturnstile> wp b P\""], ["proof (prove)\nusing this:\n  sound P\n  a \\<sqsubseteq> b\n\ngoal (1 subgoal):\n 1. wp a P \\<tturnstile> wp b P", "by(auto)"], ["proof (state)\nthis:\n  wp a P \\<tturnstile> wp b P\n\ngoal (1 subgoal):\n 1. \\<nexists>s. wp a P s < wp b P s \\<Longrightarrow> wp a P = wp b P", "ultimately"], ["proof (chain)\npicking this:\n  wp b P \\<tturnstile> wp a P\n  wp a P \\<tturnstile> wp b P", "show \"wp a P = wp b P\""], ["proof (prove)\nusing this:\n  wp b P \\<tturnstile> wp a P\n  wp a P \\<tturnstile> wp b P\n\ngoal (1 subgoal):\n 1. wp a P = wp b P", "by(auto)"], ["proof (state)\nthis:\n  wp a P = wp b P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s. wp a P s < wp b P s\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "then"], ["proof (chain)\npicking this:\n  \\<exists>s. wp a P s < wp b P s", "obtain s where less: \"wp a P s < wp b P s\""], ["proof (prove)\nusing this:\n  \\<exists>s. wp a P s < wp b P s\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        wp a P s < wp b P s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast)"], ["proof (state)\nthis:\n  wp a P s < wp b P s\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "txt \\<open>Take a carefully constructed expectation:\\<close>"], ["proof (state)\nthis:\n  wp a P s < wp b P s\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "let ?Pc = \"\\<lambda>s. bound_of P - P s\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "have sPc: \"sound ?Pc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (\\<lambda>s. bound_of P - P s)", "proof(rule soundI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Expectations.bounded (\\<lambda>s. bound_of P - P s)\n 2. nneg (\\<lambda>s. bound_of P - P s)", "from sP"], ["proof (chain)\npicking this:\n  sound P", "have \"\\<And>s. 0 \\<le> P s\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>s. 0 \\<le> P s", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> P ?s\n\ngoal (2 subgoals):\n 1. Expectations.bounded (\\<lambda>s. bound_of P - P s)\n 2. nneg (\\<lambda>s. bound_of P - P s)", "hence \"\\<And>s. ?Pc s \\<le> bound_of P\""], ["proof (prove)\nusing this:\n  0 \\<le> P ?s\n\ngoal (1 subgoal):\n 1. \\<And>s. bound_of P - P s \\<le> bound_of P", "by(auto)"], ["proof (state)\nthis:\n  bound_of P - P ?s \\<le> bound_of P\n\ngoal (2 subgoals):\n 1. Expectations.bounded (\\<lambda>s. bound_of P - P s)\n 2. nneg (\\<lambda>s. bound_of P - P s)", "thus \"bounded ?Pc\""], ["proof (prove)\nusing this:\n  bound_of P - P ?s \\<le> bound_of P\n\ngoal (1 subgoal):\n 1. Expectations.bounded (\\<lambda>s. bound_of P - P s)", "by(blast)"], ["proof (state)\nthis:\n  Expectations.bounded (\\<lambda>s. bound_of P - P s)\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. bound_of P - P s)", "from sP"], ["proof (chain)\npicking this:\n  sound P", "have \"\\<And>s. P s \\<le> bound_of P\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>s. P s \\<le> bound_of P", "by(auto)"], ["proof (state)\nthis:\n  P ?s \\<le> bound_of P\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. bound_of P - P s)", "hence \"\\<And>s. 0 \\<le> ?Pc s\""], ["proof (prove)\nusing this:\n  P ?s \\<le> bound_of P\n\ngoal (1 subgoal):\n 1. \\<And>s. 0 \\<le> bound_of P - P s", "by auto"], ["proof (state)\nthis:\n  0 \\<le> bound_of P - P ?s\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. bound_of P - P s)", "thus \"nneg ?Pc\""], ["proof (prove)\nusing this:\n  0 \\<le> bound_of P - P ?s\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. bound_of P - P s)", "by(auto)"], ["proof (state)\nthis:\n  nneg (\\<lambda>s. bound_of P - P s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sound (\\<lambda>s. bound_of P - P s)\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "txt \\<open>We then show that @{term \"wp b\"} violates feasibility, and\n    thus healthiness.\\<close>"], ["proof (state)\nthis:\n  sound (\\<lambda>s. bound_of P - P s)\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "from sP"], ["proof (chain)\npicking this:\n  sound P", "have \"0 \\<le> bound_of P\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. 0 \\<le> bound_of P", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> bound_of P\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "with da"], ["proof (chain)\npicking this:\n  determ (wp a)\n  0 \\<le> bound_of P", "have \"bound_of P = wp a (\\<lambda>s. bound_of P) s\""], ["proof (prove)\nusing this:\n  determ (wp a)\n  0 \\<le> bound_of P\n\ngoal (1 subgoal):\n 1. bound_of P = wp a (\\<lambda>s. bound_of P) s", "by(simp add:maximalD determ_maximalD)"], ["proof (state)\nthis:\n  bound_of P = wp a (\\<lambda>s. bound_of P) s\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "also"], ["proof (state)\nthis:\n  bound_of P = wp a (\\<lambda>s. bound_of P) s\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "have \"... = wp a (\\<lambda>s. ?Pc s + P s) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp a (\\<lambda>s. bound_of P) s =\n    wp a (\\<lambda>s. bound_of P - P s + P s) s", "by(simp)"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. bound_of P) s =\n  wp a (\\<lambda>s. bound_of P - P s + P s) s\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "also"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. bound_of P) s =\n  wp a (\\<lambda>s. bound_of P - P s + P s) s\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "from da sP sPc"], ["proof (chain)\npicking this:\n  determ (wp a)\n  sound P\n  sound (\\<lambda>s. bound_of P - P s)", "have \"... = wp a ?Pc s + wp a P s\""], ["proof (prove)\nusing this:\n  determ (wp a)\n  sound P\n  sound (\\<lambda>s. bound_of P - P s)\n\ngoal (1 subgoal):\n 1. wp a (\\<lambda>s. bound_of P - P s + P s) s =\n    wp a (\\<lambda>s. bound_of P - P s) s + wp a P s", "by(subst additiveD[OF determ_additiveD], simp_all add:sP sPc)"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. bound_of P - P s + P s) s =\n  wp a (\\<lambda>s. bound_of P - P s) s + wp a P s\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "also"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. bound_of P - P s + P s) s =\n  wp a (\\<lambda>s. bound_of P - P s) s + wp a P s\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "from sPc dr"], ["proof (chain)\npicking this:\n  sound (\\<lambda>s. bound_of P - P s)\n  a \\<sqsubseteq> b", "have \"... \\<le> wp b ?Pc s + wp a P s\""], ["proof (prove)\nusing this:\n  sound (\\<lambda>s. bound_of P - P s)\n  a \\<sqsubseteq> b\n\ngoal (1 subgoal):\n 1. wp a (\\<lambda>s. bound_of P - P s) s + wp a P s\n    \\<le> wp b (\\<lambda>s. bound_of P - P s) s + wp a P s", "by(auto)"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. bound_of P - P s) s + wp a P s\n  \\<le> wp b (\\<lambda>s. bound_of P - P s) s + wp a P s\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "also"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. bound_of P - P s) s + wp a P s\n  \\<le> wp b (\\<lambda>s. bound_of P - P s) s + wp a P s\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "from less"], ["proof (chain)\npicking this:\n  wp a P s < wp b P s", "have \"... < wp b ?Pc s + wp b P s\""], ["proof (prove)\nusing this:\n  wp a P s < wp b P s\n\ngoal (1 subgoal):\n 1. wp b (\\<lambda>s. bound_of P - P s) s + wp a P s\n    < wp b (\\<lambda>s. bound_of P - P s) s + wp b P s", "by(auto)"], ["proof (state)\nthis:\n  wp b (\\<lambda>s. bound_of P - P s) s + wp a P s\n  < wp b (\\<lambda>s. bound_of P - P s) s + wp b P s\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "also"], ["proof (state)\nthis:\n  wp b (\\<lambda>s. bound_of P - P s) s + wp a P s\n  < wp b (\\<lambda>s. bound_of P - P s) s + wp b P s\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "from sab sP sPc"], ["proof (chain)\npicking this:\n  sub_add (wp b)\n  sound P\n  sound (\\<lambda>s. bound_of P - P s)", "have \"... \\<le> wp b (\\<lambda>s. ?Pc s + P s) s\""], ["proof (prove)\nusing this:\n  sub_add (wp b)\n  sound P\n  sound (\\<lambda>s. bound_of P - P s)\n\ngoal (1 subgoal):\n 1. wp b (\\<lambda>s. bound_of P - P s) s + wp b P s\n    \\<le> wp b (\\<lambda>s. bound_of P - P s + P s) s", "by(blast)"], ["proof (state)\nthis:\n  wp b (\\<lambda>s. bound_of P - P s) s + wp b P s\n  \\<le> wp b (\\<lambda>s. bound_of P - P s + P s) s\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "finally"], ["proof (chain)\npicking this:\n  bound_of P < wp b (\\<lambda>s. bound_of P - P s + P s) s", "have \"\\<not>wp b (\\<lambda>s. bound_of P) s \\<le> bound_of P\""], ["proof (prove)\nusing this:\n  bound_of P < wp b (\\<lambda>s. bound_of P - P s + P s) s\n\ngoal (1 subgoal):\n 1. \\<not> wp b (\\<lambda>s. bound_of P) s \\<le> bound_of P", "by(simp)"], ["proof (state)\nthis:\n  \\<not> wp b (\\<lambda>s. bound_of P) s \\<le> bound_of P\n\ngoal (2 subgoals):\n 1. \\<And>P. sound P \\<Longrightarrow> ?Q2 P\n 2. \\<And>P.\n       \\<lbrakk>sound P; wp a P \\<noteq> wp b P\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 P", "thus \"\\<not>bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))\""], ["proof (prove)\nusing this:\n  \\<not> wp b (\\<lambda>s. bound_of P) s \\<le> bound_of P\n\ngoal (1 subgoal):\n 1. \\<not> bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))", "by(auto)"], ["proof (state)\nthis:\n  \\<not> bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow>\n       bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow>\n       bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))", "txt \\<open>However,\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow>\n       bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))", "fix P::\"'s \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow>\n       bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))", "assume sP: \"sound P\""], ["proof (state)\nthis:\n  sound P\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow>\n       bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))", "hence \"nneg (\\<lambda>s. bound_of P)\""], ["proof (prove)\nusing this:\n  sound P\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. bound_of P)", "by(auto)"], ["proof (state)\nthis:\n  nneg (\\<lambda>s. bound_of P)\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow>\n       bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))", "moreover"], ["proof (state)\nthis:\n  nneg (\\<lambda>s. bound_of P)\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow>\n       bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))", "have \"bounded_by (bound_of P) (\\<lambda>s. bound_of P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by (bound_of P) (\\<lambda>s. bound_of P)", "by(auto)"], ["proof (state)\nthis:\n  bounded_by (bound_of P) (\\<lambda>s. bound_of P)\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       sound P \\<Longrightarrow>\n       bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))", "ultimately"], ["proof (chain)\npicking this:\n  nneg (\\<lambda>s. bound_of P)\n  bounded_by (bound_of P) (\\<lambda>s. bound_of P)", "show \"bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))\""], ["proof (prove)\nusing this:\n  nneg (\\<lambda>s. bound_of P)\n  bounded_by (bound_of P) (\\<lambda>s. bound_of P)\n\ngoal (1 subgoal):\n 1. bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))", "using wb"], ["proof (prove)\nusing this:\n  nneg (\\<lambda>s. bound_of P)\n  bounded_by (bound_of P) (\\<lambda>s. bound_of P)\n  well_def b\n\ngoal (1 subgoal):\n 1. bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))", "by(auto dest!:well_def_wp_healthy)"], ["proof (state)\nthis:\n  bounded_by (bound_of P) (wp b (\\<lambda>s. bound_of P))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The Algebraic Structure of Refinement\\<close>"], ["", "text \\<open>Well-defined programs form a half-bounded semilattice under refinement, where @{term Abort}\nis bottom, and @{term \"a \\<Sqinter> b\"} is @{term inf}. There is no unique top element, but all\nfully-deterministic programs are maximal.\n\nThe type that we construct here is not especially useful, but serves as a convenient way to express\nthis result.\\<close>"], ["", "quotient_type 's program =\n  \"'s prog\" / partial : \"\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part_equivp\n     (\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b)", "proof(rule part_equivpI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>x. x \\<simeq> x \\<and> well_def x \\<and> well_def x\n 2. symp (\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b)\n 3. transp (\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b)", "have \"Skip \\<simeq> Skip\" and \"well_def Skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Skip \\<simeq> Skip &&& well_def Skip", "by(auto intro:wd_intros)"], ["proof (state)\nthis:\n  Skip \\<simeq> Skip\n  well_def Skip\n\ngoal (3 subgoals):\n 1. \\<exists>x. x \\<simeq> x \\<and> well_def x \\<and> well_def x\n 2. symp (\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b)\n 3. transp (\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b)", "thus \"\\<exists>x. x \\<simeq> x \\<and> well_def x \\<and> well_def x\""], ["proof (prove)\nusing this:\n  Skip \\<simeq> Skip\n  well_def Skip\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<simeq> x \\<and> well_def x \\<and> well_def x", "by(blast)"], ["proof (state)\nthis:\n  \\<exists>x. x \\<simeq> x \\<and> well_def x \\<and> well_def x\n\ngoal (2 subgoals):\n 1. symp (\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b)\n 2. transp (\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b)", "show \"symp (\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symp (\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b)", "proof(rule sympI, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<simeq> b; well_def a; well_def b\\<rbrakk>\n       \\<Longrightarrow> b \\<simeq> a", "fix a::\"'a prog\" and b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<simeq> b; well_def a; well_def b\\<rbrakk>\n       \\<Longrightarrow> b \\<simeq> a", "assume \"a \\<simeq> b\""], ["proof (state)\nthis:\n  a \\<simeq> b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<simeq> b; well_def a; well_def b\\<rbrakk>\n       \\<Longrightarrow> b \\<simeq> a", "hence \"equiv_trans (wp a) (wp b)\""], ["proof (prove)\nusing this:\n  a \\<simeq> b\n\ngoal (1 subgoal):\n 1. equiv_trans (wp a) (wp b)", "by(simp add:pequiv_equiv_trans)"], ["proof (state)\nthis:\n  equiv_trans (wp a) (wp b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<simeq> b; well_def a; well_def b\\<rbrakk>\n       \\<Longrightarrow> b \\<simeq> a", "thus \"b \\<simeq> a\""], ["proof (prove)\nusing this:\n  equiv_trans (wp a) (wp b)\n\ngoal (1 subgoal):\n 1. b \\<simeq> a", "by(simp add:ac_simps pequiv_equiv_trans)"], ["proof (state)\nthis:\n  b \\<simeq> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  symp (\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b)\n\ngoal (1 subgoal):\n 1. transp (\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b)", "show \"transp (\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp (\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b)", "by(rule transpI, safe, rule pequiv_trans)"], ["proof (state)\nthis:\n  transp (\\<lambda>a b. a \\<simeq> b \\<and> well_def a \\<and> well_def b)\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation program :: (type) semilattice_inf begin"], ["", "lift_definition\n  less_eq_program :: \"'a program \\<Rightarrow> 'a program \\<Rightarrow> bool\" is refines"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2 \\<and>\n                well_def fun1 \\<and> well_def fun2;\n        fun3 \\<simeq> fun4 \\<and>\n        well_def fun3 \\<and> well_def fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3 = fun2 \\<sqsubseteq> fun4", "proof(safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "fix a::\"'a prog\" and b c d"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "assume \"a \\<simeq> b\""], ["proof (state)\nthis:\n  a \\<simeq> b\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "hence \"b \\<simeq> a\""], ["proof (prove)\nusing this:\n  a \\<simeq> b\n\ngoal (1 subgoal):\n 1. b \\<simeq> a", "by(simp add:ac_simps)"], ["proof (state)\nthis:\n  b \\<simeq> a\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "also"], ["proof (state)\nthis:\n  b \\<simeq> a\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "assume \"a \\<sqsubseteq> c\""], ["proof (state)\nthis:\n  a \\<sqsubseteq> c\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "also"], ["proof (state)\nthis:\n  a \\<sqsubseteq> c\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "assume \"c \\<simeq> d\""], ["proof (state)\nthis:\n  c \\<simeq> d\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "finally"], ["proof (chain)\npicking this:\n  b \\<sqsubseteq> d", "show \"b \\<sqsubseteq> d\""], ["proof (prove)\nusing this:\n  b \\<sqsubseteq> d\n\ngoal (1 subgoal):\n 1. b \\<sqsubseteq> d", "."], ["proof (state)\nthis:\n  b \\<sqsubseteq> d\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "fix a::\"'a prog\" and b c d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "assume \"a \\<simeq> b\""], ["proof (state)\nthis:\n  a \\<simeq> b\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "also"], ["proof (state)\nthis:\n  a \\<simeq> b\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "assume \"b \\<sqsubseteq> d\""], ["proof (state)\nthis:\n  b \\<sqsubseteq> d\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "also"], ["proof (state)\nthis:\n  b \\<sqsubseteq> d\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "assume \"c \\<simeq> d\""], ["proof (state)\nthis:\n  c \\<simeq> d\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "hence \"d \\<simeq> c\""], ["proof (prove)\nusing this:\n  c \\<simeq> d\n\ngoal (1 subgoal):\n 1. d \\<simeq> c", "by(simp add:ac_simps)"], ["proof (state)\nthis:\n  d \\<simeq> c\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3", "finally"], ["proof (chain)\npicking this:\n  a \\<sqsubseteq> c", "show \"a \\<sqsubseteq> c\""], ["proof (prove)\nusing this:\n  a \\<sqsubseteq> c\n\ngoal (1 subgoal):\n 1. a \\<sqsubseteq> c", "."], ["proof (state)\nthis:\n  a \\<sqsubseteq> c\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX - what's up here? *)"], ["", "lift_definition\n  less_program :: \"'a program \\<Rightarrow> 'a program \\<Rightarrow> bool\"\n  is \"\\<lambda>a b. a \\<sqsubseteq> b \\<and> \\<not> b \\<sqsubseteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2 \\<and>\n                well_def fun1 \\<and> well_def fun2;\n        fun3 \\<simeq> fun4 \\<and>\n        well_def fun3 \\<and> well_def fun4\\<rbrakk>\n       \\<Longrightarrow> (fun1 \\<sqsubseteq> fun3 \\<and>\n                          \\<not> fun3 \\<sqsubseteq> fun1) =\n                         (fun2 \\<sqsubseteq> fun4 \\<and>\n                          \\<not> fun4 \\<sqsubseteq> fun2)", "proof(safe)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 4. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "fix a::\"'a prog\" and b c d"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 4. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"a \\<simeq> b\""], ["proof (state)\nthis:\n  a \\<simeq> b\n\ngoal (4 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 4. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"b \\<simeq> a\""], ["proof (prove)\nusing this:\n  a \\<simeq> b\n\ngoal (1 subgoal):\n 1. b \\<simeq> a", "by(simp add:ac_simps)"], ["proof (state)\nthis:\n  b \\<simeq> a\n\ngoal (4 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 4. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  b \\<simeq> a\n\ngoal (4 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 4. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"a \\<sqsubseteq> c\""], ["proof (state)\nthis:\n  a \\<sqsubseteq> c\n\ngoal (4 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 4. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  a \\<sqsubseteq> c\n\ngoal (4 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 4. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"c \\<simeq> d\""], ["proof (state)\nthis:\n  c \\<simeq> d\n\ngoal (4 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> fun2 \\<sqsubseteq> fun4\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 4. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  b \\<sqsubseteq> d", "show \"b \\<sqsubseteq> d\""], ["proof (prove)\nusing this:\n  b \\<sqsubseteq> d\n\ngoal (1 subgoal):\n 1. b \\<sqsubseteq> d", "."], ["proof (state)\nthis:\n  b \\<sqsubseteq> d\n\ngoal (3 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "fix a::\"'a prog\" and b c d"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"a \\<simeq> b\""], ["proof (state)\nthis:\n  a \\<simeq> b\n\ngoal (3 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  a \\<simeq> b\n\ngoal (3 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"b \\<sqsubseteq> d\""], ["proof (state)\nthis:\n  b \\<sqsubseteq> d\n\ngoal (3 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  b \\<sqsubseteq> d\n\ngoal (3 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"c \\<simeq> d\""], ["proof (state)\nthis:\n  c \\<simeq> d\n\ngoal (3 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"d \\<simeq> c\""], ["proof (prove)\nusing this:\n  c \\<simeq> d\n\ngoal (1 subgoal):\n 1. d \\<simeq> c", "by(simp add:ac_simps)"], ["proof (state)\nthis:\n  d \\<simeq> c\n\ngoal (3 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> fun1 \\<sqsubseteq> fun3\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  a \\<sqsubseteq> c", "show \"a \\<sqsubseteq> c\""], ["proof (prove)\nusing this:\n  a \\<sqsubseteq> c\n\ngoal (1 subgoal):\n 1. a \\<sqsubseteq> c", "."], ["proof (state)\nthis:\n  a \\<sqsubseteq> c\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "fix a b and c::\"'a prog\" and d"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"c \\<simeq> d\""], ["proof (state)\nthis:\n  c \\<simeq> d\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  c \\<simeq> d\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"d \\<sqsubseteq> b\""], ["proof (state)\nthis:\n  d \\<sqsubseteq> b\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  d \\<sqsubseteq> b\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"a \\<simeq> b\""], ["proof (state)\nthis:\n  a \\<simeq> b\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"b \\<simeq> a\""], ["proof (prove)\nusing this:\n  a \\<simeq> b\n\ngoal (1 subgoal):\n 1. b \\<simeq> a", "by(simp add:ac_simps)"], ["proof (state)\nthis:\n  b \\<simeq> a\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  c \\<sqsubseteq> a", "have \"c \\<sqsubseteq> a\""], ["proof (prove)\nusing this:\n  c \\<sqsubseteq> a\n\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> a", "."], ["proof (state)\nthis:\n  c \\<sqsubseteq> a\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  c \\<sqsubseteq> a\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"\\<not> c \\<sqsubseteq> a\""], ["proof (state)\nthis:\n  \\<not> c \\<sqsubseteq> a\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun1 \\<sqsubseteq> fun3; \\<not> fun3 \\<sqsubseteq> fun1;\n        fun4 \\<sqsubseteq> fun2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  c \\<sqsubseteq> a\n  \\<not> c \\<sqsubseteq> a", "show False"], ["proof (prove)\nusing this:\n  c \\<sqsubseteq> a\n  \\<not> c \\<sqsubseteq> a\n\ngoal (1 subgoal):\n 1. False", "by(auto)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "fix a b and c::\"'a prog\" and d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"c \\<simeq> d\""], ["proof (state)\nthis:\n  c \\<simeq> d\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"d \\<simeq> c\""], ["proof (prove)\nusing this:\n  c \\<simeq> d\n\ngoal (1 subgoal):\n 1. d \\<simeq> c", "by(simp add:ac_simps)"], ["proof (state)\nthis:\n  d \\<simeq> c\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  d \\<simeq> c\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"c \\<sqsubseteq> a\""], ["proof (state)\nthis:\n  c \\<sqsubseteq> a\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  c \\<sqsubseteq> a\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"a \\<simeq> b\""], ["proof (state)\nthis:\n  a \\<simeq> b\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  d \\<sqsubseteq> b", "have \"d \\<sqsubseteq> b\""], ["proof (prove)\nusing this:\n  d \\<sqsubseteq> b\n\ngoal (1 subgoal):\n 1. d \\<sqsubseteq> b", "."], ["proof (state)\nthis:\n  d \\<sqsubseteq> b\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  d \\<sqsubseteq> b\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"\\<not> d \\<sqsubseteq> b\""], ["proof (state)\nthis:\n  \\<not> d \\<sqsubseteq> b\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4;\n        fun2 \\<sqsubseteq> fun4; \\<not> fun4 \\<sqsubseteq> fun2;\n        fun3 \\<sqsubseteq> fun1\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  d \\<sqsubseteq> b\n  \\<not> d \\<sqsubseteq> b", "show False"], ["proof (prove)\nusing this:\n  d \\<sqsubseteq> b\n  \\<not> d \\<sqsubseteq> b\n\ngoal (1 subgoal):\n 1. False", "by(auto)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition\n  inf_program :: \"'a program \\<Rightarrow> 'a program \\<Rightarrow> 'a program\" is DC"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2 \\<and>\n                well_def fun1 \\<and> well_def fun2;\n        fun3 \\<simeq> fun4 \\<and>\n        well_def fun3 \\<and> well_def fun4\\<rbrakk>\n       \\<Longrightarrow> (fun1 \\<Sqinter> fun3) \\<simeq>\n                         (fun2 \\<Sqinter> fun4) \\<and>\n                         well_def (fun1 \\<Sqinter> fun3) \\<and>\n                         well_def (fun2 \\<Sqinter> fun4)", "proof(safe)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> (fun1 \\<Sqinter> fun3) \\<simeq>\n                         (fun2 \\<Sqinter> fun4)\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun1 \\<Sqinter> fun3)\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun2 \\<Sqinter> fun4)", "fix a b c d::\"'s prog\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> (fun1 \\<Sqinter> fun3) \\<simeq>\n                         (fun2 \\<Sqinter> fun4)\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun1 \\<Sqinter> fun3)\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun2 \\<Sqinter> fun4)", "assume \"a \\<simeq> b\" and \"c \\<simeq> d\""], ["proof (state)\nthis:\n  a \\<simeq> b\n  c \\<simeq> d\n\ngoal (3 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> (fun1 \\<Sqinter> fun3) \\<simeq>\n                         (fun2 \\<Sqinter> fun4)\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun1 \\<Sqinter> fun3)\n 3. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun2 \\<Sqinter> fun4)", "thus \"(a \\<Sqinter> c) \\<simeq> (b \\<Sqinter> d)\""], ["proof (prove)\nusing this:\n  a \\<simeq> b\n  c \\<simeq> d\n\ngoal (1 subgoal):\n 1. (a \\<Sqinter> c) \\<simeq> (b \\<Sqinter> d)", "by(rule pequiv_DC)"], ["proof (state)\nthis:\n  (a \\<Sqinter> c) \\<simeq> (b \\<Sqinter> d)\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun1 \\<Sqinter> fun3)\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun2 \\<Sqinter> fun4)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun1 \\<Sqinter> fun3)\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun2 \\<Sqinter> fun4)", "fix a c::\"'s prog\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun1 \\<Sqinter> fun3)\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun2 \\<Sqinter> fun4)", "assume \"well_def a\" \"well_def c\""], ["proof (state)\nthis:\n  well_def a\n  well_def c\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun1 \\<Sqinter> fun3)\n 2. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun2 \\<Sqinter> fun4)", "thus \"well_def (a \\<Sqinter> c)\""], ["proof (prove)\nusing this:\n  well_def a\n  well_def c\n\ngoal (1 subgoal):\n 1. well_def (a \\<Sqinter> c)", "by(rule wd_intros)"], ["proof (state)\nthis:\n  well_def (a \\<Sqinter> c)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun2 \\<Sqinter> fun4)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun2 \\<Sqinter> fun4)", "fix a c::\"'s prog\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun2 \\<Sqinter> fun4)", "assume \"well_def a\" \"well_def c\""], ["proof (state)\nthis:\n  well_def a\n  well_def c\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2 fun3 fun4.\n       \\<lbrakk>fun1 \\<simeq> fun2; fun3 \\<simeq> fun4; well_def fun1;\n        well_def fun2; well_def fun3; well_def fun4\\<rbrakk>\n       \\<Longrightarrow> well_def (fun2 \\<Sqinter> fun4)", "thus \"well_def (a \\<Sqinter> c)\""], ["proof (prove)\nusing this:\n  well_def a\n  well_def c\n\ngoal (1 subgoal):\n 1. well_def (a \\<Sqinter> c)", "by(rule wd_intros)"], ["proof (state)\nthis:\n  well_def (a \\<Sqinter> c)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a program, semilattice_inf_class)", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. inf x y \\<le> x\n 6. \\<And>x y. inf x y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "fix x y::\"'a program\""], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. inf x y \\<le> x\n 6. \\<And>x y. inf x y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "show \"(x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by(transfer, simp)"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n\ngoal (6 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. inf x y \\<le> x\n 5. \\<And>x y. inf x y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "show \"x \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "by(transfer, auto)"], ["proof (state)\nthis:\n  x \\<le> x\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. inf x y \\<le> x\n 4. \\<And>x y. inf x y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "show \"inf x y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf x y \\<le> x", "by(transfer, rule left_refines_DC)"], ["proof (state)\nthis:\n  inf x y \\<le> x\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. inf x y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "show \"inf x y \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf x y \\<le> y", "by(transfer, rule right_refines_DC)"], ["proof (state)\nthis:\n  inf x y \\<le> y\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "assume \"x \\<le> y\" and \"y \\<le> x\""], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> x\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "thus \"x = y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. x = y", "by(transfer, iprover intro:pequiv_antisym)"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "fix x y z::\"'a program\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "assume \"x \\<le> y\" and \"y \\<le> z\""], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> z\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "thus \"x \\<le> z\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> z", "by(transfer, iprover intro:pr_trans)"], ["proof (state)\nthis:\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "fix x y z::\"'a program\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "assume \"x \\<le> y\" and \"x \\<le> z\""], ["proof (state)\nthis:\n  x \\<le> y\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z", "thus \"x \\<le> inf y z\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> inf y z", "by(transfer, iprover intro:DC_refines)"], ["proof (state)\nthis:\n  x \\<le> inf y z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation program :: (type) bot begin"], ["", "lift_definition\n  bot_program :: \"'a program\" is Abort"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abort \\<simeq> Abort \\<and> well_def Abort \\<and> well_def Abort", "by(auto intro:wd_intros)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a program, bot_class)", ".."], ["", "end"], ["", "lemma eq_det: \"\\<And>a b::'s prog. \\<lbrakk> a \\<simeq> b; determ (wp a) \\<rbrakk> \\<Longrightarrow> determ (wp b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<simeq> b; determ (wp a)\\<rbrakk>\n       \\<Longrightarrow> determ (wp b)", "proof(intro determI additiveI maximalI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b P Q s.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>s. P s + Q s) s =\n                         wp b P s + wp b Q s\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "fix a b::\"'s prog\" and P::\"'s \\<Rightarrow> real\"\n    and Q::\"'s \\<Rightarrow> real\" and s::\"'s\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b P Q s.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>s. P s + Q s) s =\n                         wp b P s + wp b Q s\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "assume da: \"determ (wp a)\""], ["proof (state)\nthis:\n  determ (wp a)\n\ngoal (2 subgoals):\n 1. \\<And>a b P Q s.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>s. P s + Q s) s =\n                         wp b P s + wp b Q s\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "assume sP: \"sound P\" and sQ: \"sound Q\"\n    and eq: \"a \\<simeq> b\""], ["proof (state)\nthis:\n  sound P\n  sound Q\n  a \\<simeq> b\n\ngoal (2 subgoals):\n 1. \\<And>a b P Q s.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>s. P s + Q s) s =\n                         wp b P s + wp b Q s\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "hence \"wp b (\\<lambda>s. P s + Q s) s =\n         wp a (\\<lambda>s. P s + Q s) s\""], ["proof (prove)\nusing this:\n  sound P\n  sound Q\n  a \\<simeq> b\n\ngoal (1 subgoal):\n 1. wp b (\\<lambda>s. P s + Q s) s = wp a (\\<lambda>s. P s + Q s) s", "by(simp add:sound_intros)"], ["proof (state)\nthis:\n  wp b (\\<lambda>s. P s + Q s) s = wp a (\\<lambda>s. P s + Q s) s\n\ngoal (2 subgoals):\n 1. \\<And>a b P Q s.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>s. P s + Q s) s =\n                         wp b P s + wp b Q s\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "also"], ["proof (state)\nthis:\n  wp b (\\<lambda>s. P s + Q s) s = wp a (\\<lambda>s. P s + Q s) s\n\ngoal (2 subgoals):\n 1. \\<And>a b P Q s.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>s. P s + Q s) s =\n                         wp b P s + wp b Q s\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "from da sP sQ"], ["proof (chain)\npicking this:\n  determ (wp a)\n  sound P\n  sound Q", "have \"... = wp a P s + wp a Q s\""], ["proof (prove)\nusing this:\n  determ (wp a)\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. wp a (\\<lambda>s. P s + Q s) s = wp a P s + wp a Q s", "by(simp add:additiveD determ_additiveD)"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. P s + Q s) s = wp a P s + wp a Q s\n\ngoal (2 subgoals):\n 1. \\<And>a b P Q s.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>s. P s + Q s) s =\n                         wp b P s + wp b Q s\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "also"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. P s + Q s) s = wp a P s + wp a Q s\n\ngoal (2 subgoals):\n 1. \\<And>a b P Q s.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>s. P s + Q s) s =\n                         wp b P s + wp b Q s\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "from eq sP sQ"], ["proof (chain)\npicking this:\n  a \\<simeq> b\n  sound P\n  sound Q", "have \"... = wp b P s + wp b Q s\""], ["proof (prove)\nusing this:\n  a \\<simeq> b\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. wp a P s + wp a Q s = wp b P s + wp b Q s", "by(simp add:pequivD)"], ["proof (state)\nthis:\n  wp a P s + wp a Q s = wp b P s + wp b Q s\n\ngoal (2 subgoals):\n 1. \\<And>a b P Q s.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>s. P s + Q s) s =\n                         wp b P s + wp b Q s\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "finally"], ["proof (chain)\npicking this:\n  wp b (\\<lambda>s. P s + Q s) s = wp b P s + wp b Q s", "show \"wp b (\\<lambda>s. P s + Q s) s = wp b P s + wp b Q s\""], ["proof (prove)\nusing this:\n  wp b (\\<lambda>s. P s + Q s) s = wp b P s + wp b Q s\n\ngoal (1 subgoal):\n 1. wp b (\\<lambda>s. P s + Q s) s = wp b P s + wp b Q s", "."], ["proof (state)\nthis:\n  wp b (\\<lambda>s. P s + Q s) s = wp b P s + wp b Q s\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "fix a b::\"'s prog\" and c::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "assume da: \"determ (wp a)\""], ["proof (state)\nthis:\n  determ (wp a)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "assume \"a \\<simeq> b\""], ["proof (state)\nthis:\n  a \\<simeq> b\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "hence \"b \\<simeq> a\""], ["proof (prove)\nusing this:\n  a \\<simeq> b\n\ngoal (1 subgoal):\n 1. b \\<simeq> a", "by(simp add:ac_simps)"], ["proof (state)\nthis:\n  b \\<simeq> a\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "moreover"], ["proof (state)\nthis:\n  b \\<simeq> a\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "assume nn: \"0 \\<le> c\""], ["proof (state)\nthis:\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "ultimately"], ["proof (chain)\npicking this:\n  b \\<simeq> a\n  0 \\<le> c", "have \"wp b (\\<lambda>_. c) = wp a (\\<lambda>_. c)\""], ["proof (prove)\nusing this:\n  b \\<simeq> a\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. wp b (\\<lambda>_. c) = wp a (\\<lambda>_. c)", "by(simp add:pequivD const_sound)"], ["proof (state)\nthis:\n  wp b (\\<lambda>_. c) = wp a (\\<lambda>_. c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "also"], ["proof (state)\nthis:\n  wp b (\\<lambda>_. c) = wp a (\\<lambda>_. c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "from da nn"], ["proof (chain)\npicking this:\n  determ (wp a)\n  0 \\<le> c", "have \"... = (\\<lambda>_. c)\""], ["proof (prove)\nusing this:\n  determ (wp a)\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. wp a (\\<lambda>_. c) = (\\<lambda>_. c)", "by(simp add:determ_maximalD maximalD)"], ["proof (state)\nthis:\n  wp a (\\<lambda>_. c) = (\\<lambda>_. c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<simeq> b; determ (wp a); 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "finally"], ["proof (chain)\npicking this:\n  wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "show \"wp b (\\<lambda>_. c) = (\\<lambda>_. c)\""], ["proof (prove)\nusing this:\n  wp b (\\<lambda>_. c) = (\\<lambda>_. c)\n\ngoal (1 subgoal):\n 1. wp b (\\<lambda>_. c) = (\\<lambda>_. c)", "."], ["proof (state)\nthis:\n  wp b (\\<lambda>_. c) = (\\<lambda>_. c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition\n  pdeterm :: \"'s program \\<Rightarrow> bool\"\n  is \"\\<lambda>a. determ (wp a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       fun1 \\<simeq> fun2 \\<and>\n       well_def fun1 \\<and> well_def fun2 \\<Longrightarrow>\n       determ (wp fun1) = determ (wp fun2)", "proof(safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>fun1 \\<simeq> fun2; well_def fun1; well_def fun2;\n        determ (wp fun1)\\<rbrakk>\n       \\<Longrightarrow> determ (wp fun2)\n 2. \\<And>fun1 fun2.\n       \\<lbrakk>fun1 \\<simeq> fun2; well_def fun1; well_def fun2;\n        determ (wp fun2)\\<rbrakk>\n       \\<Longrightarrow> determ (wp fun1)", "fix a b::\"'s prog\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>fun1 \\<simeq> fun2; well_def fun1; well_def fun2;\n        determ (wp fun1)\\<rbrakk>\n       \\<Longrightarrow> determ (wp fun2)\n 2. \\<And>fun1 fun2.\n       \\<lbrakk>fun1 \\<simeq> fun2; well_def fun1; well_def fun2;\n        determ (wp fun2)\\<rbrakk>\n       \\<Longrightarrow> determ (wp fun1)", "assume \"a \\<simeq> b\" and \"determ (wp a)\""], ["proof (state)\nthis:\n  a \\<simeq> b\n  determ (wp a)\n\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>fun1 \\<simeq> fun2; well_def fun1; well_def fun2;\n        determ (wp fun1)\\<rbrakk>\n       \\<Longrightarrow> determ (wp fun2)\n 2. \\<And>fun1 fun2.\n       \\<lbrakk>fun1 \\<simeq> fun2; well_def fun1; well_def fun2;\n        determ (wp fun2)\\<rbrakk>\n       \\<Longrightarrow> determ (wp fun1)", "thus \"determ (wp b)\""], ["proof (prove)\nusing this:\n  a \\<simeq> b\n  determ (wp a)\n\ngoal (1 subgoal):\n 1. determ (wp b)", "by(rule eq_det)"], ["proof (state)\nthis:\n  determ (wp b)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>fun1 \\<simeq> fun2; well_def fun1; well_def fun2;\n        determ (wp fun2)\\<rbrakk>\n       \\<Longrightarrow> determ (wp fun1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>fun1 \\<simeq> fun2; well_def fun1; well_def fun2;\n        determ (wp fun2)\\<rbrakk>\n       \\<Longrightarrow> determ (wp fun1)", "fix a b::\"'s prog\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>fun1 \\<simeq> fun2; well_def fun1; well_def fun2;\n        determ (wp fun2)\\<rbrakk>\n       \\<Longrightarrow> determ (wp fun1)", "assume \"a \\<simeq> b\""], ["proof (state)\nthis:\n  a \\<simeq> b\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>fun1 \\<simeq> fun2; well_def fun1; well_def fun2;\n        determ (wp fun2)\\<rbrakk>\n       \\<Longrightarrow> determ (wp fun1)", "hence \"b \\<simeq> a\""], ["proof (prove)\nusing this:\n  a \\<simeq> b\n\ngoal (1 subgoal):\n 1. b \\<simeq> a", "by(simp add:ac_simps)"], ["proof (state)\nthis:\n  b \\<simeq> a\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>fun1 \\<simeq> fun2; well_def fun1; well_def fun2;\n        determ (wp fun2)\\<rbrakk>\n       \\<Longrightarrow> determ (wp fun1)", "moreover"], ["proof (state)\nthis:\n  b \\<simeq> a\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>fun1 \\<simeq> fun2; well_def fun1; well_def fun2;\n        determ (wp fun2)\\<rbrakk>\n       \\<Longrightarrow> determ (wp fun1)", "assume \"determ (wp b)\""], ["proof (state)\nthis:\n  determ (wp b)\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>fun1 \\<simeq> fun2; well_def fun1; well_def fun2;\n        determ (wp fun2)\\<rbrakk>\n       \\<Longrightarrow> determ (wp fun1)", "ultimately"], ["proof (chain)\npicking this:\n  b \\<simeq> a\n  determ (wp b)", "show \"determ (wp a)\""], ["proof (prove)\nusing this:\n  b \\<simeq> a\n  determ (wp b)\n\ngoal (1 subgoal):\n 1. determ (wp a)", "by(rule eq_det)"], ["proof (state)\nthis:\n  determ (wp a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma determ_maximal:\n  \"\\<lbrakk> pdeterm a; a \\<le> x \\<rbrakk> \\<Longrightarrow> a = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pdeterm a; a \\<le> x\\<rbrakk> \\<Longrightarrow> a = x", "by(transfer, auto intro:refines_determ)"], ["", "subsection \\<open>Data Refinement\\<close>"], ["", "text \\<open>A projective data refinement construction for pGCL. By projective, we mean that the abstract\nstate is always a function (@{term \\<phi>}) of the concrete state. Refinement may be predicated (@{term\nG}) on the state.\\<close>"], ["", "definition\n  drefines :: \"('b \\<Rightarrow> 'a) \\<Rightarrow> ('b \\<Rightarrow> bool) \\<Rightarrow> 'a prog \\<Rightarrow> 'b prog \\<Rightarrow> bool\"\nwhere\n  \"drefines \\<phi> G A B \\<equiv> \\<forall>P Q. (unitary P \\<and> unitary Q \\<and> (P \\<tturnstile> wp A Q)) \\<longrightarrow>\n                            (\\<guillemotleft>G\\<guillemotright> && (P o \\<phi>) \\<tturnstile> wp B (Q o \\<phi>))\""], ["", "lemma drefinesD[dest]:\n  \"\\<lbrakk> drefines \\<phi> G A B; unitary P; unitary Q; P \\<tturnstile> wp A Q \\<rbrakk> \\<Longrightarrow>\n   \\<guillemotleft>G\\<guillemotright> && (P o \\<phi>) \\<tturnstile> wp B (Q o \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>drefines \\<phi> G A B; unitary P; unitary Q;\n     P \\<tturnstile> wp A Q\\<rbrakk>\n    \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                      (P \\<circ>\n                       \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "unfolding drefines_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>P Q.\n                unitary P \\<and>\n                unitary Q \\<and> P \\<tturnstile> wp A Q \\<longrightarrow>\n                \\<guillemotleft> G \\<guillemotright> &&\n                (P \\<circ> \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>);\n     unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n    \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                      (P \\<circ>\n                       \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "by(blast)"], ["", "text \\<open>We can alternatively use G as an assumption:\\<close>"], ["", "lemma drefinesD2:\n  assumes dr:  \"drefines \\<phi> G A B\"\n      and uP:  \"unitary P\"\n      and uQ:  \"unitary Q\"\n      and wpA: \"P \\<tturnstile> wp A Q\"\n      and G:   \"G s\"\n  shows \"(P o \\<phi>) s \\<le> wp B (Q o \\<phi>) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s \\<le> wp B (Q \\<circ> \\<phi>) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s \\<le> wp B (Q \\<circ> \\<phi>) s", "from uP"], ["proof (chain)\npicking this:\n  unitary P", "have \"0 \\<le> (P o \\<phi>) s\""], ["proof (prove)\nusing this:\n  unitary P\n\ngoal (1 subgoal):\n 1. 0 \\<le> (P \\<circ> \\<phi>) s", "unfolding o_def"], ["proof (prove)\nusing this:\n  unitary P\n\ngoal (1 subgoal):\n 1. 0 \\<le> P (\\<phi> s)", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> (P \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s \\<le> wp B (Q \\<circ> \\<phi>) s", "with G"], ["proof (chain)\npicking this:\n  G s\n  0 \\<le> (P \\<circ> \\<phi>) s", "have \"(P o \\<phi>) s = (\\<guillemotleft>G\\<guillemotright> && (P o \\<phi>)) s\""], ["proof (prove)\nusing this:\n  G s\n  0 \\<le> (P \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s =\n    (\\<guillemotleft> G \\<guillemotright> && (P \\<circ> \\<phi>)) s", "by(simp add:exp_conj_def)"], ["proof (state)\nthis:\n  (P \\<circ> \\<phi>) s =\n  (\\<guillemotleft> G \\<guillemotright> && (P \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s \\<le> wp B (Q \\<circ> \\<phi>) s", "also"], ["proof (state)\nthis:\n  (P \\<circ> \\<phi>) s =\n  (\\<guillemotleft> G \\<guillemotright> && (P \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s \\<le> wp B (Q \\<circ> \\<phi>) s", "from assms"], ["proof (chain)\npicking this:\n  drefines \\<phi> G A B\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp A Q\n  G s", "have \"... \\<le> wp B (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  drefines \\<phi> G A B\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp A Q\n  G s\n\ngoal (1 subgoal):\n 1. (\\<guillemotleft> G \\<guillemotright> && (P \\<circ> \\<phi>)) s\n    \\<le> wp B (Q \\<circ> \\<phi>) s", "by(blast)"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && (P \\<circ> \\<phi>)) s\n  \\<le> wp B (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s \\<le> wp B (Q \\<circ> \\<phi>) s", "finally"], ["proof (chain)\npicking this:\n  (P \\<circ> \\<phi>) s \\<le> wp B (Q \\<circ> \\<phi>) s", "show \"(P o \\<phi>) s \\<le> ...\""], ["proof (prove)\nusing this:\n  (P \\<circ> \\<phi>) s \\<le> wp B (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s \\<le> wp B (Q \\<circ> \\<phi>) s", "."], ["proof (state)\nthis:\n  (P \\<circ> \\<phi>) s \\<le> wp B (Q \\<circ> \\<phi>) s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This additional form is sometimes useful:\\<close>"], ["", "lemma drefinesD3:\n  assumes dr: \"drefines \\<phi> G a b\"\n      and G:  \"G s\"\n      and uQ: \"unitary Q\"\n      and wa: \"well_def a\"\n  shows \"wp a Q (\\<phi> s) \\<le> wp b (Q o \\<phi>) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) \\<le> wp b (Q \\<circ> \\<phi>) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) \\<le> wp b (Q \\<circ> \\<phi>) s", "let \"?L s'\" = \"wp a Q s'\""], ["proof (state)\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) \\<le> wp b (Q \\<circ> \\<phi>) s", "from uQ wa"], ["proof (chain)\npicking this:\n  unitary Q\n  well_def a", "have sL: \"sound ?L\""], ["proof (prove)\nusing this:\n  unitary Q\n  well_def a\n\ngoal (1 subgoal):\n 1. sound (wp a Q)", "by(blast)"], ["proof (state)\nthis:\n  sound (wp a Q)\n\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) \\<le> wp b (Q \\<circ> \\<phi>) s", "from uQ wa"], ["proof (chain)\npicking this:\n  unitary Q\n  well_def a", "have bL: \"bounded_by 1 ?L\""], ["proof (prove)\nusing this:\n  unitary Q\n  well_def a\n\ngoal (1 subgoal):\n 1. bounded_by 1 (wp a Q)", "by(blast)"], ["proof (state)\nthis:\n  bounded_by 1 (wp a Q)\n\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) \\<le> wp b (Q \\<circ> \\<phi>) s", "have \"?L \\<tturnstile> ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp a Q \\<tturnstile> wp a Q", "by(simp)"], ["proof (state)\nthis:\n  wp a Q \\<tturnstile> wp a Q\n\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) \\<le> wp b (Q \\<circ> \\<phi>) s", "with sL and bL and assms"], ["proof (chain)\npicking this:\n  sound (wp a Q)\n  bounded_by 1 (wp a Q)\n  drefines \\<phi> G a b\n  G s\n  unitary Q\n  well_def a\n  wp a Q \\<tturnstile> wp a Q", "show ?thesis"], ["proof (prove)\nusing this:\n  sound (wp a Q)\n  bounded_by 1 (wp a Q)\n  drefines \\<phi> G a b\n  G s\n  unitary Q\n  well_def a\n  wp a Q \\<tturnstile> wp a Q\n\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) \\<le> wp b (Q \\<circ> \\<phi>) s", "by(blast intro:drefinesD2[OF dr, where P=\"?L\", simplified])"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) \\<le> wp b (Q \\<circ> \\<phi>) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma drefinesI[intro]:\n  \"\\<lbrakk> \\<And>P Q. \\<lbrakk> unitary P; unitary Q; P \\<tturnstile> wp A Q \\<rbrakk> \\<Longrightarrow>\n           \\<guillemotleft>G\\<guillemotright> && (P o \\<phi>) \\<tturnstile> wp B (Q o \\<phi>) \\<rbrakk> \\<Longrightarrow>\n   drefines \\<phi> G A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n        \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                          (P \\<circ>\n                           \\<phi>) \\<tturnstile> wp B\n            (Q \\<circ> \\<phi>)) \\<Longrightarrow>\n    drefines \\<phi> G A B", "unfolding drefines_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n        \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                          (P \\<circ>\n                           \\<phi>) \\<tturnstile> wp B\n            (Q \\<circ> \\<phi>)) \\<Longrightarrow>\n    \\<forall>P Q.\n       unitary P \\<and>\n       unitary Q \\<and> P \\<tturnstile> wp A Q \\<longrightarrow>\n       \\<guillemotleft> G \\<guillemotright> &&\n       (P \\<circ> \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "by(blast)"], ["", "text \\<open>Use G as an assumption, when showing refinement:\\<close>"], ["", "lemma drefinesI2:\n  fixes   A::\"'a prog\"\n    and   B::\"'b prog\"\n    and   \\<phi>::\"'b \\<Rightarrow> 'a\"\n    and   G::\"'b \\<Rightarrow> bool\"\n  assumes wB: \"well_def B\"\n      and withAs:\n        \"\\<And>P Q s. \\<lbrakk> unitary P; unitary Q;\n                 G s; P \\<tturnstile> wp A Q \\<rbrakk> \\<Longrightarrow> (P o \\<phi>) s \\<le> wp B (Q o \\<phi>) s\"\n  shows \"drefines \\<phi> G A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drefines \\<phi> G A B", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "fix P and Q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "assume uP:  \"unitary P\"\n     and uQ:  \"unitary Q\"\n     and wpA: \"P \\<tturnstile> wp A Q\""], ["proof (state)\nthis:\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp A Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "hence \"\\<And>s. G s \\<Longrightarrow> (P o \\<phi>) s \\<le> wp B (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp A Q\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       G s \\<Longrightarrow>\n       (P \\<circ> \\<phi>) s \\<le> wp B (Q \\<circ> \\<phi>) s", "using withAs"], ["proof (prove)\nusing this:\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp A Q\n  \\<lbrakk>unitary ?P; unitary ?Q; G ?s; ?P \\<tturnstile> wp A ?Q\\<rbrakk>\n  \\<Longrightarrow> (?P \\<circ> \\<phi>) ?s \\<le> wp B (?Q \\<circ> \\<phi>) ?s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       G s \\<Longrightarrow>\n       (P \\<circ> \\<phi>) s \\<le> wp B (Q \\<circ> \\<phi>) s", "by(blast)"], ["proof (state)\nthis:\n  G ?s \\<Longrightarrow>\n  (P \\<circ> \\<phi>) ?s \\<le> wp B (Q \\<circ> \\<phi>) ?s\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "moreover"], ["proof (state)\nthis:\n  G ?s \\<Longrightarrow>\n  (P \\<circ> \\<phi>) ?s \\<le> wp B (Q \\<circ> \\<phi>) ?s\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "from uQ"], ["proof (chain)\npicking this:\n  unitary Q", "have \"unitary (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. unitary (Q \\<circ> \\<phi>)", "unfolding o_def"], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. unitary (\\<lambda>x. Q (\\<phi> x))", "by(blast)"], ["proof (state)\nthis:\n  unitary (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "moreover"], ["proof (state)\nthis:\n  unitary (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "from uP"], ["proof (chain)\npicking this:\n  unitary P", "have \"unitary (P o \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary P\n\ngoal (1 subgoal):\n 1. unitary (P \\<circ> \\<phi>)", "unfolding o_def"], ["proof (prove)\nusing this:\n  unitary P\n\ngoal (1 subgoal):\n 1. unitary (\\<lambda>x. P (\\<phi> x))", "by(blast)"], ["proof (state)\nthis:\n  unitary (P \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "ultimately"], ["proof (chain)\npicking this:\n  G ?s \\<Longrightarrow>\n  (P \\<circ> \\<phi>) ?s \\<le> wp B (Q \\<circ> \\<phi>) ?s\n  unitary (Q \\<circ> \\<phi>)\n  unitary (P \\<circ> \\<phi>)", "show \"\\<guillemotleft>G\\<guillemotright> && (P o \\<phi>) \\<tturnstile> wp B (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  G ?s \\<Longrightarrow>\n  (P \\<circ> \\<phi>) ?s \\<le> wp B (Q \\<circ> \\<phi>) ?s\n  unitary (Q \\<circ> \\<phi>)\n  unitary (P \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> &&\n    (P \\<circ> \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "using wB"], ["proof (prove)\nusing this:\n  G ?s \\<Longrightarrow>\n  (P \\<circ> \\<phi>) ?s \\<le> wp B (Q \\<circ> \\<phi>) ?s\n  unitary (Q \\<circ> \\<phi>)\n  unitary (P \\<circ> \\<phi>)\n  well_def B\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> &&\n    (P \\<circ> \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "by(blast intro:entails_pconj_assumption)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dr_strengthen_guard:\n  fixes a::\"'s prog\" and b::\"'t prog\"\n  assumes fg: \"\\<And>s. F s \\<Longrightarrow> G s\"\n      and drab: \"drefines \\<phi> G a b\"\n  shows \"drefines \\<phi> F a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drefines \\<phi> F a b", "proof(intro drefinesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> F \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)", "fix P Q::\"'s expect\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> F \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)", "assume uP: \"unitary P\" and uQ: \"unitary Q\"\n     and wp: \"P \\<tturnstile> wp a Q\""], ["proof (state)\nthis:\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp a Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> F \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)", "from fg"], ["proof (chain)\npicking this:\n  F ?s \\<Longrightarrow> G ?s", "have \"\\<And>s. \\<guillemotleft>F\\<guillemotright> s \\<le> \\<guillemotleft>G\\<guillemotright> s\""], ["proof (prove)\nusing this:\n  F ?s \\<Longrightarrow> G ?s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<guillemotleft> F \\<guillemotright> s\n       \\<le> \\<guillemotleft> G \\<guillemotright> s", "by(simp add:embed_bool_def)"], ["proof (state)\nthis:\n  \\<guillemotleft> F \\<guillemotright> ?s\n  \\<le> \\<guillemotleft> G \\<guillemotright> ?s\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> F \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)", "hence \"(\\<guillemotleft>F\\<guillemotright> && (P o \\<phi>)) \\<tturnstile> (\\<guillemotleft>G\\<guillemotright> && (P o \\<phi>))\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> F \\<guillemotright> ?s\n  \\<le> \\<guillemotleft> G \\<guillemotright> ?s\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> F \\<guillemotright> &&\n    (P \\<circ>\n     \\<phi>) \\<tturnstile> \\<guillemotleft> G \\<guillemotright> &&\n                           (P \\<circ> \\<phi>)", "by(auto intro:pconj_mono le_funI simp:exp_conj_def)"], ["proof (state)\nthis:\n  \\<guillemotleft> F \\<guillemotright> &&\n  (P \\<circ>\n   \\<phi>) \\<tturnstile> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> F \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)", "also"], ["proof (state)\nthis:\n  \\<guillemotleft> F \\<guillemotright> &&\n  (P \\<circ>\n   \\<phi>) \\<tturnstile> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> F \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)", "from drab uP uQ wp"], ["proof (chain)\npicking this:\n  drefines \\<phi> G a b\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp a Q", "have \"... \\<tturnstile> wp b (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  drefines \\<phi> G a b\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp a Q\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> &&\n    (P \\<circ> \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)", "by(auto)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> F \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)", "finally"], ["proof (chain)\npicking this:\n  \\<guillemotleft> F \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)", "show \"\\<guillemotleft>F\\<guillemotright> && (P o \\<phi>) \\<tturnstile> wp b (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> F \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> F \\<guillemotright> &&\n    (P \\<circ> \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)", "."], ["proof (state)\nthis:\n  \\<guillemotleft> F \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Probabilistic correspondence, @{term pcorres}, is equality on distribution transformers,\nmodulo a guard. It is the analogue, for data refinement, of program equivalence for program\nrefinement.\\<close>"], ["", "definition\n  pcorres :: \"('b \\<Rightarrow> 'a) \\<Rightarrow> ('b \\<Rightarrow> bool) \\<Rightarrow> 'a prog \\<Rightarrow> 'b prog \\<Rightarrow> bool\"\nwhere\n  \"pcorres \\<phi> G A B \\<longleftrightarrow>\n   (\\<forall>Q. unitary Q \\<longrightarrow>  \\<guillemotleft>G\\<guillemotright> && (wp A Q o \\<phi>) = \\<guillemotleft>G\\<guillemotright> && wp B (Q o \\<phi>))\""], ["", "lemma pcorresI:\n  \"\\<lbrakk> \\<And>Q. unitary Q \\<Longrightarrow> \\<guillemotleft>G\\<guillemotright> && (wp A Q o \\<phi>) = \\<guillemotleft>G\\<guillemotright> && wp B (Q o \\<phi>) \\<rbrakk> \\<Longrightarrow>\n   pcorres \\<phi> G A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        unitary Q \\<Longrightarrow>\n        \\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>) =\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp B (Q \\<circ> \\<phi>)) \\<Longrightarrow>\n    pcorres \\<phi> G A B", "by(simp add:pcorres_def)"], ["", "text \\<open>Often easier to use, as it allows one to assume the precondition.\\<close>"], ["", "lemma pcorresI2[intro]:\n  fixes A::\"'a prog\" and B::\"'b prog\"\n  assumes withG: \"\\<And>Q s. \\<lbrakk> unitary Q; G s \\<rbrakk> \\<Longrightarrow> wp A Q (\\<phi> s)= wp B (Q o \\<phi>) s\"\n      and wA: \"well_def A\"\n      and wB: \"well_def B\"\n  shows \"pcorres \\<phi> G A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pcorres \\<phi> G A B", "proof(rule pcorresI, rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       unitary Q \\<Longrightarrow>\n       (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) x =\n       (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) x", "fix Q::\"'a \\<Rightarrow> real\" and s::'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       unitary Q \\<Longrightarrow>\n       (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) x =\n       (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) x", "assume uQ: \"unitary Q\""], ["proof (state)\nthis:\n  unitary Q\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       unitary Q \\<Longrightarrow>\n       (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) x =\n       (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) x", "hence uQ\\<phi>: \"unitary (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. unitary (Q \\<circ> \\<phi>)", "by(auto)"], ["proof (state)\nthis:\n  unitary (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       unitary Q \\<Longrightarrow>\n       (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) x =\n       (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) x", "show \"(\\<guillemotleft>G\\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s = (\\<guillemotleft>G\\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "proof(cases \"G s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s\n 2. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "case True"], ["proof (state)\nthis:\n  G s\n\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s\n 2. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "note this"], ["proof (state)\nthis:\n  G s\n\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s\n 2. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "moreover"], ["proof (state)\nthis:\n  G s\n\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s\n 2. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "from well_def_wp_healthy[OF wA] uQ"], ["proof (chain)\npicking this:\n  healthy (wp A)\n  unitary Q", "have \"0 \\<le> wp A Q (\\<phi> s)\""], ["proof (prove)\nusing this:\n  healthy (wp A)\n  unitary Q\n\ngoal (1 subgoal):\n 1. 0 \\<le> wp A Q (\\<phi> s)", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> wp A Q (\\<phi> s)\n\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s\n 2. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "moreover"], ["proof (state)\nthis:\n  0 \\<le> wp A Q (\\<phi> s)\n\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s\n 2. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "from well_def_wp_healthy[OF wB] uQ\\<phi>"], ["proof (chain)\npicking this:\n  healthy (wp B)\n  unitary (Q \\<circ> \\<phi>)", "have \"0 \\<le> wp B (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  healthy (wp B)\n  unitary (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. 0 \\<le> wp B (Q \\<circ> \\<phi>) s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> wp B (Q \\<circ> \\<phi>) s\n\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s\n 2. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "ultimately"], ["proof (chain)\npicking this:\n  G s\n  0 \\<le> wp A Q (\\<phi> s)\n  0 \\<le> wp B (Q \\<circ> \\<phi>) s", "show ?thesis"], ["proof (prove)\nusing this:\n  G s\n  0 \\<le> wp A Q (\\<phi> s)\n  0 \\<le> wp B (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "using uQ"], ["proof (prove)\nusing this:\n  G s\n  0 \\<le> wp A Q (\\<phi> s)\n  0 \\<le> wp B (Q \\<circ> \\<phi>) s\n  unitary Q\n\ngoal (1 subgoal):\n 1. (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "by(simp add:exp_conj_def withG)"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n  (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "case False"], ["proof (state)\nthis:\n  \\<not> G s\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "note this"], ["proof (state)\nthis:\n  \\<not> G s\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "moreover"], ["proof (state)\nthis:\n  \\<not> G s\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "from well_def_wp_healthy[OF wA] uQ"], ["proof (chain)\npicking this:\n  healthy (wp A)\n  unitary Q", "have \"wp A Q (\\<phi> s) \\<le> 1\""], ["proof (prove)\nusing this:\n  healthy (wp A)\n  unitary Q\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) \\<le> 1", "by(blast)"], ["proof (state)\nthis:\n  wp A Q (\\<phi> s) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "moreover"], ["proof (state)\nthis:\n  wp A Q (\\<phi> s) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "from well_def_wp_healthy[OF wB] uQ\\<phi>"], ["proof (chain)\npicking this:\n  healthy (wp B)\n  unitary (Q \\<circ> \\<phi>)", "have \"wp B (Q o \\<phi>) s \\<le> 1\""], ["proof (prove)\nusing this:\n  healthy (wp B)\n  unitary (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. wp B (Q \\<circ> \\<phi>) s \\<le> 1", "by(blast dest!:healthy_bounded_byD intro:sound_nneg)"], ["proof (state)\nthis:\n  wp B (Q \\<circ> \\<phi>) s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> G s\n  wp A Q (\\<phi> s) \\<le> 1\n  wp B (Q \\<circ> \\<phi>) s \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> G s\n  wp A Q (\\<phi> s) \\<le> 1\n  wp B (Q \\<circ> \\<phi>) s \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s", "by(simp add:exp_conj_def)"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n  (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>)) s =\n  (\\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pcorresD:\n  \"\\<lbrakk> pcorres \\<phi> G A B; unitary Q \\<rbrakk> \\<Longrightarrow> \\<guillemotleft>G\\<guillemotright> && (wp A Q o \\<phi>) = \\<guillemotleft>G\\<guillemotright> && wp B (Q o \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pcorres \\<phi> G A B; unitary Q\\<rbrakk>\n    \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                      (wp A Q \\<circ> \\<phi>) =\n                      \\<guillemotleft> G \\<guillemotright> &&\n                      wp B (Q \\<circ> \\<phi>)", "unfolding pcorres_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>Q.\n                unitary Q \\<longrightarrow>\n                \\<guillemotleft> G \\<guillemotright> &&\n                (wp A Q \\<circ> \\<phi>) =\n                \\<guillemotleft> G \\<guillemotright> &&\n                wp B (Q \\<circ> \\<phi>);\n     unitary Q\\<rbrakk>\n    \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                      (wp A Q \\<circ> \\<phi>) =\n                      \\<guillemotleft> G \\<guillemotright> &&\n                      wp B (Q \\<circ> \\<phi>)", "by(simp)"], ["", "text \\<open>Again, easier to use if the precondition is known to hold.\\<close>"], ["", "lemma pcorresD2:\n  assumes pc: \"pcorres \\<phi> G A B\"\n      and uQ: \"unitary Q\"\n      and wA: \"well_def A\" and wB: \"well_def B\"\n      and G: \"G s\"\n  shows \"wp A Q (\\<phi> s) = wp B (Q o \\<phi>) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "from uQ well_def_wp_healthy[OF wA]"], ["proof (chain)\npicking this:\n  unitary Q\n  healthy (wp A)", "have \"0 \\<le> wp A Q (\\<phi> s)\""], ["proof (prove)\nusing this:\n  unitary Q\n  healthy (wp A)\n\ngoal (1 subgoal):\n 1. 0 \\<le> wp A Q (\\<phi> s)", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> wp A Q (\\<phi> s)\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "with G"], ["proof (chain)\npicking this:\n  G s\n  0 \\<le> wp A Q (\\<phi> s)", "have \"wp A Q (\\<phi> s) = \\<guillemotleft>G\\<guillemotright> s .& wp A Q (\\<phi> s)\""], ["proof (prove)\nusing this:\n  G s\n  0 \\<le> wp A Q (\\<phi> s)\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) =\n    \\<guillemotleft> G \\<guillemotright> s .& wp A Q (\\<phi> s)", "by(simp)"], ["proof (state)\nthis:\n  wp A Q (\\<phi> s) =\n  \\<guillemotleft> G \\<guillemotright> s .& wp A Q (\\<phi> s)\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "also"], ["proof (state)\nthis:\n  wp A Q (\\<phi> s) =\n  \\<guillemotleft> G \\<guillemotright> s .& wp A Q (\\<phi> s)\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "{"], ["proof (state)\nthis:\n  wp A Q (\\<phi> s) =\n  \\<guillemotleft> G \\<guillemotright> s .& wp A Q (\\<phi> s)\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "from pc uQ"], ["proof (chain)\npicking this:\n  pcorres \\<phi> G A B\n  unitary Q", "have \"\\<guillemotleft>G\\<guillemotright> && (wp A Q o \\<phi>) = \\<guillemotleft>G\\<guillemotright> && wp B (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  pcorres \\<phi> G A B\n  unitary Q\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>) =\n    \\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)", "by(rule pcorresD)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>) =\n  \\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "hence \"\\<guillemotleft>G\\<guillemotright> s .& wp A Q (\\<phi> s) = \\<guillemotleft>G\\<guillemotright> s .& wp B (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>) =\n  \\<guillemotleft> G \\<guillemotright> && wp B (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> s .& wp A Q (\\<phi> s) =\n    \\<guillemotleft> G \\<guillemotright> s .& wp B (Q \\<circ> \\<phi>) s", "unfolding exp_conj_def o_def"], ["proof (prove)\nusing this:\n  (\\<lambda>s.\n      \\<guillemotleft> G \\<guillemotright> s .& wp A Q (\\<phi> s)) =\n  (\\<lambda>s.\n      \\<guillemotleft> G \\<guillemotright> s .&\n      wp B (\\<lambda>x. Q (\\<phi> x)) s)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> s .& wp A Q (\\<phi> s) =\n    \\<guillemotleft> G \\<guillemotright> s .&\n    wp B (\\<lambda>x. Q (\\<phi> x)) s", "by(rule fun_cong)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> s .& wp A Q (\\<phi> s) =\n  \\<guillemotleft> G \\<guillemotright> s .& wp B (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "}"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> s .& wp A Q (\\<phi> s) =\n  \\<guillemotleft> G \\<guillemotright> s .& wp B (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "also"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> s .& wp A Q (\\<phi> s) =\n  \\<guillemotleft> G \\<guillemotright> s .& wp B (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "{"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> s .& wp A Q (\\<phi> s) =\n  \\<guillemotleft> G \\<guillemotright> s .& wp B (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "from uQ"], ["proof (chain)\npicking this:\n  unitary Q", "have \"sound Q\""], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. sound Q", "by(auto)"], ["proof (state)\nthis:\n  sound Q\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "hence \"sound (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  sound Q\n\ngoal (1 subgoal):\n 1. sound (Q \\<circ> \\<phi>)", "by(auto intro:sound_intros)"], ["proof (state)\nthis:\n  sound (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "with well_def_wp_healthy[OF wB]"], ["proof (chain)\npicking this:\n  healthy (wp B)\n  sound (Q \\<circ> \\<phi>)", "have \"0 \\<le> wp B (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  healthy (wp B)\n  sound (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. 0 \\<le> wp B (Q \\<circ> \\<phi>) s", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> wp B (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "with G"], ["proof (chain)\npicking this:\n  G s\n  0 \\<le> wp B (Q \\<circ> \\<phi>) s", "have \"\\<guillemotleft>G\\<guillemotright> s .& wp B (Q o \\<phi>) s = wp B (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  G s\n  0 \\<le> wp B (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> s .& wp B (Q \\<circ> \\<phi>) s =\n    wp B (Q \\<circ> \\<phi>) s", "by(simp)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> s .& wp B (Q \\<circ> \\<phi>) s =\n  wp B (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "}"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> s .& wp B (Q \\<circ> \\<phi>) s =\n  wp B (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "finally"], ["proof (chain)\npicking this:\n  wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "show ?thesis"], ["proof (prove)\nusing this:\n  wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s", "."], ["proof (state)\nthis:\n  wp A Q (\\<phi> s) = wp B (Q \\<circ> \\<phi>) s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The Algebra of Data Refinement\\<close>"], ["", "text \\<open>Program refinement implies a trivial data refinement:\\<close>"], ["", "lemma refines_drefines:\n  fixes a::\"'s prog\"\n  assumes rab: \"a \\<sqsubseteq> b\" and wb: \"well_def b\"\n  shows \"drefines (\\<lambda>s. s) G a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drefines (\\<lambda>s. s) G a b", "proof(intro drefinesI2 wb, simp add:o_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> P s \\<le> wp b Q s", "fix P::\"'s \\<Rightarrow> real\" and Q::\"'s \\<Rightarrow> real\" and s::'s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> P s \\<le> wp b Q s", "assume sQ: \"unitary Q\""], ["proof (state)\nthis:\n  unitary Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> P s \\<le> wp b Q s", "assume \"P \\<tturnstile> wp a Q\""], ["proof (state)\nthis:\n  P \\<tturnstile> wp a Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> P s \\<le> wp b Q s", "hence \"P s \\<le> wp a Q s\""], ["proof (prove)\nusing this:\n  P \\<tturnstile> wp a Q\n\ngoal (1 subgoal):\n 1. P s \\<le> wp a Q s", "by(auto)"], ["proof (state)\nthis:\n  P s \\<le> wp a Q s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> P s \\<le> wp b Q s", "also"], ["proof (state)\nthis:\n  P s \\<le> wp a Q s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> P s \\<le> wp b Q s", "from rab sQ"], ["proof (chain)\npicking this:\n  a \\<sqsubseteq> b\n  unitary Q", "have \"... \\<le> wp b Q s\""], ["proof (prove)\nusing this:\n  a \\<sqsubseteq> b\n  unitary Q\n\ngoal (1 subgoal):\n 1. wp a Q s \\<le> wp b Q s", "by(auto)"], ["proof (state)\nthis:\n  wp a Q s \\<le> wp b Q s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> P s \\<le> wp b Q s", "finally"], ["proof (chain)\npicking this:\n  P s \\<le> wp b Q s", "show \"P s \\<le> wp b Q s\""], ["proof (prove)\nusing this:\n  P s \\<le> wp b Q s\n\ngoal (1 subgoal):\n 1. P s \\<le> wp b Q s", "."], ["proof (state)\nthis:\n  P s \\<le> wp b Q s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Data refinement is transitive:\\<close>"], ["", "lemma dr_trans[trans]:\n  fixes A::\"'a prog\" and B::\"'b prog\" and C::\"'c prog\"\n  assumes drAB: \"drefines \\<phi> G A B\"\n      and drBC: \"drefines \\<phi>' G' B C\"\n      and Gimp: \"\\<And>s. G' s \\<Longrightarrow> G (\\<phi>' s)\"\n  shows \"drefines (\\<phi> o \\<phi>') G' A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drefines (\\<phi> \\<circ> \\<phi>') G' A C", "proof(rule drefinesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G' \\<guillemotright> &&\n                         (P \\<circ>\n                          (\\<phi> \\<circ>\n                           \\<phi>')) \\<tturnstile> wp C\n              (Q \\<circ> (\\<phi> \\<circ> \\<phi>'))", "fix P::\"'a \\<Rightarrow> real\" and Q::\"'a \\<Rightarrow> real\" and s::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G' \\<guillemotright> &&\n                         (P \\<circ>\n                          (\\<phi> \\<circ>\n                           \\<phi>')) \\<tturnstile> wp C\n              (Q \\<circ> (\\<phi> \\<circ> \\<phi>'))", "assume uP: \"unitary P\" and uQ: \"unitary Q\"\n     and wpA: \"P \\<tturnstile> wp A Q\""], ["proof (state)\nthis:\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp A Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G' \\<guillemotright> &&\n                         (P \\<circ>\n                          (\\<phi> \\<circ>\n                           \\<phi>')) \\<tturnstile> wp C\n              (Q \\<circ> (\\<phi> \\<circ> \\<phi>'))", "have \"\\<guillemotleft>G'\\<guillemotright> && \\<guillemotleft>G o \\<phi>'\\<guillemotright> = \\<guillemotleft>G'\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> G' \\<guillemotright> &&\n    \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> =\n    \\<guillemotleft> G' \\<guillemotright>", "proof(rule ext, unfold exp_conj_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft> G' \\<guillemotright> x .&\n       \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n       \\<guillemotleft> G' \\<guillemotright> x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft> G' \\<guillemotright> x .&\n       \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n       \\<guillemotleft> G' \\<guillemotright> x", "show \"\\<guillemotleft>G'\\<guillemotright> x .& \\<guillemotleft>G o \\<phi>'\\<guillemotright> x = \\<guillemotleft>G'\\<guillemotright> x\" (is ?X)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> G' \\<guillemotright> x .&\n    \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n    \\<guillemotleft> G' \\<guillemotright> x", "proof(cases \"G' x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. G' x \\<Longrightarrow>\n    \\<guillemotleft> G' \\<guillemotright> x .&\n    \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n    \\<guillemotleft> G' \\<guillemotright> x\n 2. \\<not> G' x \\<Longrightarrow>\n    \\<guillemotleft> G' \\<guillemotright> x .&\n    \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n    \\<guillemotleft> G' \\<guillemotright> x", "case False"], ["proof (state)\nthis:\n  \\<not> G' x\n\ngoal (2 subgoals):\n 1. G' x \\<Longrightarrow>\n    \\<guillemotleft> G' \\<guillemotright> x .&\n    \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n    \\<guillemotleft> G' \\<guillemotright> x\n 2. \\<not> G' x \\<Longrightarrow>\n    \\<guillemotleft> G' \\<guillemotright> x .&\n    \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n    \\<guillemotleft> G' \\<guillemotright> x", "then"], ["proof (chain)\npicking this:\n  \\<not> G' x", "show ?X"], ["proof (prove)\nusing this:\n  \\<not> G' x\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G' \\<guillemotright> x .&\n    \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n    \\<guillemotleft> G' \\<guillemotright> x", "by(simp)"], ["proof (state)\nthis:\n  \\<guillemotleft> G' \\<guillemotright> x .&\n  \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n  \\<guillemotleft> G' \\<guillemotright> x\n\ngoal (1 subgoal):\n 1. G' x \\<Longrightarrow>\n    \\<guillemotleft> G' \\<guillemotright> x .&\n    \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n    \\<guillemotleft> G' \\<guillemotright> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. G' x \\<Longrightarrow>\n    \\<guillemotleft> G' \\<guillemotright> x .&\n    \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n    \\<guillemotleft> G' \\<guillemotright> x", "case True"], ["proof (state)\nthis:\n  G' x\n\ngoal (1 subgoal):\n 1. G' x \\<Longrightarrow>\n    \\<guillemotleft> G' \\<guillemotright> x .&\n    \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n    \\<guillemotleft> G' \\<guillemotright> x", "moreover"], ["proof (state)\nthis:\n  G' x\n\ngoal (1 subgoal):\n 1. G' x \\<Longrightarrow>\n    \\<guillemotleft> G' \\<guillemotright> x .&\n    \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n    \\<guillemotleft> G' \\<guillemotright> x", "with Gimp"], ["proof (chain)\npicking this:\n  G' ?s \\<Longrightarrow> G (\\<phi>' ?s)\n  G' x", "have \"(G o \\<phi>') x\""], ["proof (prove)\nusing this:\n  G' ?s \\<Longrightarrow> G (\\<phi>' ?s)\n  G' x\n\ngoal (1 subgoal):\n 1. (G \\<circ> \\<phi>') x", "by(simp add:o_def)"], ["proof (state)\nthis:\n  (G \\<circ> \\<phi>') x\n\ngoal (1 subgoal):\n 1. G' x \\<Longrightarrow>\n    \\<guillemotleft> G' \\<guillemotright> x .&\n    \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n    \\<guillemotleft> G' \\<guillemotright> x", "ultimately"], ["proof (chain)\npicking this:\n  G' x\n  (G \\<circ> \\<phi>') x", "show ?X"], ["proof (prove)\nusing this:\n  G' x\n  (G \\<circ> \\<phi>') x\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G' \\<guillemotright> x .&\n    \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n    \\<guillemotleft> G' \\<guillemotright> x", "by(simp)"], ["proof (state)\nthis:\n  \\<guillemotleft> G' \\<guillemotright> x .&\n  \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n  \\<guillemotleft> G' \\<guillemotright> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft> G' \\<guillemotright> x .&\n  \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> x =\n  \\<guillemotleft> G' \\<guillemotright> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft> G' \\<guillemotright> &&\n  \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> =\n  \\<guillemotleft> G' \\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G' \\<guillemotright> &&\n                         (P \\<circ>\n                          (\\<phi> \\<circ>\n                           \\<phi>')) \\<tturnstile> wp C\n              (Q \\<circ> (\\<phi> \\<circ> \\<phi>'))", "with uP"], ["proof (chain)\npicking this:\n  unitary P\n  \\<guillemotleft> G' \\<guillemotright> &&\n  \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> =\n  \\<guillemotleft> G' \\<guillemotright>", "have \"\\<guillemotleft>G'\\<guillemotright> && (P o (\\<phi> o \\<phi>')) = \\<guillemotleft>G'\\<guillemotright> && ((\\<guillemotleft>G\\<guillemotright> && (P o \\<phi>)) o \\<phi>')\""], ["proof (prove)\nusing this:\n  unitary P\n  \\<guillemotleft> G' \\<guillemotright> &&\n  \\<guillemotleft> G \\<circ> \\<phi>' \\<guillemotright> =\n  \\<guillemotleft> G' \\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G' \\<guillemotright> &&\n    (P \\<circ> (\\<phi> \\<circ> \\<phi>')) =\n    \\<guillemotleft> G' \\<guillemotright> &&\n    (\\<guillemotleft> G \\<guillemotright> && (P \\<circ> \\<phi>) \\<circ>\n     \\<phi>')", "by(simp add:exp_conj_assoc o_assoc)"], ["proof (state)\nthis:\n  \\<guillemotleft> G' \\<guillemotright> &&\n  (P \\<circ> (\\<phi> \\<circ> \\<phi>')) =\n  \\<guillemotleft> G' \\<guillemotright> &&\n  (\\<guillemotleft> G \\<guillemotright> && (P \\<circ> \\<phi>) \\<circ>\n   \\<phi>')\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G' \\<guillemotright> &&\n                         (P \\<circ>\n                          (\\<phi> \\<circ>\n                           \\<phi>')) \\<tturnstile> wp C\n              (Q \\<circ> (\\<phi> \\<circ> \\<phi>'))", "also"], ["proof (state)\nthis:\n  \\<guillemotleft> G' \\<guillemotright> &&\n  (P \\<circ> (\\<phi> \\<circ> \\<phi>')) =\n  \\<guillemotleft> G' \\<guillemotright> &&\n  (\\<guillemotleft> G \\<guillemotright> && (P \\<circ> \\<phi>) \\<circ>\n   \\<phi>')\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G' \\<guillemotright> &&\n                         (P \\<circ>\n                          (\\<phi> \\<circ>\n                           \\<phi>')) \\<tturnstile> wp C\n              (Q \\<circ> (\\<phi> \\<circ> \\<phi>'))", "{"], ["proof (state)\nthis:\n  \\<guillemotleft> G' \\<guillemotright> &&\n  (P \\<circ> (\\<phi> \\<circ> \\<phi>')) =\n  \\<guillemotleft> G' \\<guillemotright> &&\n  (\\<guillemotleft> G \\<guillemotright> && (P \\<circ> \\<phi>) \\<circ>\n   \\<phi>')\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G' \\<guillemotright> &&\n                         (P \\<circ>\n                          (\\<phi> \\<circ>\n                           \\<phi>')) \\<tturnstile> wp C\n              (Q \\<circ> (\\<phi> \\<circ> \\<phi>'))", "from uP uQ wpA and drAB"], ["proof (chain)\npicking this:\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp A Q\n  drefines \\<phi> G A B", "have \"\\<guillemotleft>G\\<guillemotright> && (P o \\<phi>) \\<tturnstile> wp B (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp A Q\n  drefines \\<phi> G A B\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> &&\n    (P \\<circ> \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "by(blast intro:drefinesD)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G' \\<guillemotright> &&\n                         (P \\<circ>\n                          (\\<phi> \\<circ>\n                           \\<phi>')) \\<tturnstile> wp C\n              (Q \\<circ> (\\<phi> \\<circ> \\<phi>'))", "with drBC and uP uQ"], ["proof (chain)\npicking this:\n  drefines \\<phi>' G' B C\n  unitary P\n  unitary Q\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "have \"\\<guillemotleft>G'\\<guillemotright> && ((\\<guillemotleft>G\\<guillemotright> && (P o \\<phi>)) o \\<phi>') \\<tturnstile> wp C ((Q o \\<phi>) o \\<phi>')\""], ["proof (prove)\nusing this:\n  drefines \\<phi>' G' B C\n  unitary P\n  unitary Q\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G' \\<guillemotright> &&\n    (\\<guillemotleft> G \\<guillemotright> && (P \\<circ> \\<phi>) \\<circ>\n     \\<phi>') \\<tturnstile> wp C (Q \\<circ> \\<phi> \\<circ> \\<phi>')", "by(blast intro:unitary_intros drefinesD)"], ["proof (state)\nthis:\n  \\<guillemotleft> G' \\<guillemotright> &&\n  (\\<guillemotleft> G \\<guillemotright> && (P \\<circ> \\<phi>) \\<circ>\n   \\<phi>') \\<tturnstile> wp C (Q \\<circ> \\<phi> \\<circ> \\<phi>')\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G' \\<guillemotright> &&\n                         (P \\<circ>\n                          (\\<phi> \\<circ>\n                           \\<phi>')) \\<tturnstile> wp C\n              (Q \\<circ> (\\<phi> \\<circ> \\<phi>'))", "}"], ["proof (state)\nthis:\n  \\<guillemotleft> G' \\<guillemotright> &&\n  (\\<guillemotleft> G \\<guillemotright> && (P \\<circ> \\<phi>) \\<circ>\n   \\<phi>') \\<tturnstile> wp C (Q \\<circ> \\<phi> \\<circ> \\<phi>')\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G' \\<guillemotright> &&\n                         (P \\<circ>\n                          (\\<phi> \\<circ>\n                           \\<phi>')) \\<tturnstile> wp C\n              (Q \\<circ> (\\<phi> \\<circ> \\<phi>'))", "finally"], ["proof (chain)\npicking this:\n  \\<guillemotleft> G' \\<guillemotright> &&\n  (P \\<circ>\n   (\\<phi> \\<circ>\n    \\<phi>')) \\<tturnstile> wp C (Q \\<circ> \\<phi> \\<circ> \\<phi>')", "show \"\\<guillemotleft>G'\\<guillemotright> && (P o (\\<phi> o \\<phi>')) \\<tturnstile> wp C (Q o (\\<phi> o \\<phi>'))\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> G' \\<guillemotright> &&\n  (P \\<circ>\n   (\\<phi> \\<circ>\n    \\<phi>')) \\<tturnstile> wp C (Q \\<circ> \\<phi> \\<circ> \\<phi>')\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G' \\<guillemotright> &&\n    (P \\<circ>\n     (\\<phi> \\<circ>\n      \\<phi>')) \\<tturnstile> wp C (Q \\<circ> (\\<phi> \\<circ> \\<phi>'))", "by(simp add:o_assoc)"], ["proof (state)\nthis:\n  \\<guillemotleft> G' \\<guillemotright> &&\n  (P \\<circ>\n   (\\<phi> \\<circ>\n    \\<phi>')) \\<tturnstile> wp C (Q \\<circ> (\\<phi> \\<circ> \\<phi>'))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Data refinement composes with program refinement:\\<close>"], ["", "lemma pr_dr_trans[trans]:\n  assumes prAB: \"A \\<sqsubseteq> B\"\n      and drBC: \"drefines \\<phi> G B C\"\n  shows \"drefines \\<phi> G A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drefines \\<phi> G A C", "proof(rule drefinesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "fix P and Q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "assume uP:  \"unitary P\"\n     and uQ:  \"unitary Q\"\n     and wpA: \"P \\<tturnstile> wp A Q\""], ["proof (state)\nthis:\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp A Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "note wpA"], ["proof (state)\nthis:\n  P \\<tturnstile> wp A Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "also"], ["proof (state)\nthis:\n  P \\<tturnstile> wp A Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "from uQ and prAB"], ["proof (chain)\npicking this:\n  unitary Q\n  A \\<sqsubseteq> B", "have \"wp A Q \\<tturnstile> wp B Q\""], ["proof (prove)\nusing this:\n  unitary Q\n  A \\<sqsubseteq> B\n\ngoal (1 subgoal):\n 1. wp A Q \\<tturnstile> wp B Q", "by(blast)"], ["proof (state)\nthis:\n  wp A Q \\<tturnstile> wp B Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "finally"], ["proof (chain)\npicking this:\n  P \\<tturnstile> wp B Q", "have \"P \\<tturnstile> wp B Q\""], ["proof (prove)\nusing this:\n  P \\<tturnstile> wp B Q\n\ngoal (1 subgoal):\n 1. P \\<tturnstile> wp B Q", "."], ["proof (state)\nthis:\n  P \\<tturnstile> wp B Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "with uP uQ drBC"], ["proof (chain)\npicking this:\n  unitary P\n  unitary Q\n  drefines \\<phi> G B C\n  P \\<tturnstile> wp B Q", "show \"\\<guillemotleft>G\\<guillemotright> && (P o \\<phi>) \\<tturnstile> wp C (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary P\n  unitary Q\n  drefines \\<phi> G B C\n  P \\<tturnstile> wp B Q\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> &&\n    (P \\<circ> \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "by(blast intro:drefinesD)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dr_pr_trans[trans]:\n  assumes drAB: \"drefines \\<phi> G A B\"\n  assumes prBC: \"B \\<sqsubseteq> C\"\n  shows \"drefines \\<phi> G A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drefines \\<phi> G A C", "proof(rule drefinesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "fix P and Q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "assume uP:  \"unitary P\"\n     and uQ:  \"unitary Q\"\n     and wpA: \"P \\<tturnstile> wp A Q\""], ["proof (state)\nthis:\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp A Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "with drAB"], ["proof (chain)\npicking this:\n  drefines \\<phi> G A B\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp A Q", "have \"\\<guillemotleft>G\\<guillemotright> && (P o \\<phi>) \\<tturnstile> wp B (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  drefines \\<phi> G A B\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp A Q\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> &&\n    (P \\<circ> \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)", "by(blast intro:drefinesD)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "also"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp B (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "from uQ prBC"], ["proof (chain)\npicking this:\n  unitary Q\n  B \\<sqsubseteq> C", "have \"... \\<tturnstile> wp C (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary Q\n  B \\<sqsubseteq> C\n\ngoal (1 subgoal):\n 1. wp B (Q \\<circ> \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "by(blast)"], ["proof (state)\nthis:\n  wp B (Q \\<circ> \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "finally"], ["proof (chain)\npicking this:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "show \"\\<guillemotleft>G\\<guillemotright> && (P o \\<phi>) \\<tturnstile> ...\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> &&\n    (P \\<circ> \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "."], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>If the projection @{term \\<phi>} commutes with the transformer, then data refinement is\nreflexive:\\<close>"], ["", "lemma dr_refl:\n  assumes wa: \"well_def a\"\n      and comm: \"\\<And>Q. unitary Q \\<Longrightarrow> wp a Q o \\<phi> \\<tturnstile> wp a (Q o \\<phi>)\"\n  shows \"drefines \\<phi> G a a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drefines \\<phi> G a a", "proof(intro drefinesI2 wa)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp a (Q \\<circ> \\<phi>) s", "fix P and Q and s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp a (Q \\<circ> \\<phi>) s", "assume wp: \"P \\<tturnstile> wp a Q\""], ["proof (state)\nthis:\n  P \\<tturnstile> wp a Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp a (Q \\<circ> \\<phi>) s", "assume uQ: \"unitary Q\""], ["proof (state)\nthis:\n  unitary Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp a (Q \\<circ> \\<phi>) s", "have \"(P o \\<phi>) s = P (\\<phi> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s = P (\\<phi> s)", "by(simp)"], ["proof (state)\nthis:\n  (P \\<circ> \\<phi>) s = P (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp a (Q \\<circ> \\<phi>) s", "also"], ["proof (state)\nthis:\n  (P \\<circ> \\<phi>) s = P (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp a (Q \\<circ> \\<phi>) s", "from wp"], ["proof (chain)\npicking this:\n  P \\<tturnstile> wp a Q", "have \"... \\<le> wp a Q (\\<phi> s)\""], ["proof (prove)\nusing this:\n  P \\<tturnstile> wp a Q\n\ngoal (1 subgoal):\n 1. P (\\<phi> s) \\<le> wp a Q (\\<phi> s)", "by(blast)"], ["proof (state)\nthis:\n  P (\\<phi> s) \\<le> wp a Q (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp a (Q \\<circ> \\<phi>) s", "also"], ["proof (state)\nthis:\n  P (\\<phi> s) \\<le> wp a Q (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp a (Q \\<circ> \\<phi>) s", "{"], ["proof (state)\nthis:\n  P (\\<phi> s) \\<le> wp a Q (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp a (Q \\<circ> \\<phi>) s", "from comm uQ"], ["proof (chain)\npicking this:\n  unitary ?Q \\<Longrightarrow>\n  wp a ?Q \\<circ> \\<phi> \\<tturnstile> wp a (?Q \\<circ> \\<phi>)\n  unitary Q", "have \"wp a Q o \\<phi> \\<tturnstile> wp a (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary ?Q \\<Longrightarrow>\n  wp a ?Q \\<circ> \\<phi> \\<tturnstile> wp a (?Q \\<circ> \\<phi>)\n  unitary Q\n\ngoal (1 subgoal):\n 1. wp a Q \\<circ> \\<phi> \\<tturnstile> wp a (Q \\<circ> \\<phi>)", "by(blast)"], ["proof (state)\nthis:\n  wp a Q \\<circ> \\<phi> \\<tturnstile> wp a (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp a (Q \\<circ> \\<phi>) s", "hence \"(wp a Q o \\<phi>) s \\<le> wp a (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  wp a Q \\<circ> \\<phi> \\<tturnstile> wp a (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. (wp a Q \\<circ> \\<phi>) s \\<le> wp a (Q \\<circ> \\<phi>) s", "by(blast)"], ["proof (state)\nthis:\n  (wp a Q \\<circ> \\<phi>) s \\<le> wp a (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp a (Q \\<circ> \\<phi>) s", "hence \"wp a Q (\\<phi> s) \\<le> ...\""], ["proof (prove)\nusing this:\n  (wp a Q \\<circ> \\<phi>) s \\<le> wp a (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) \\<le> wp a (Q \\<circ> \\<phi>) s", "by(simp)"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) \\<le> wp a (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp a (Q \\<circ> \\<phi>) s", "}"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) \\<le> wp a (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s; P \\<tturnstile> wp a Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp a (Q \\<circ> \\<phi>) s", "finally"], ["proof (chain)\npicking this:\n  (P \\<circ> \\<phi>) s \\<le> wp a (Q \\<circ> \\<phi>) s", "show  \"(P o \\<phi>) s \\<le> wp a (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  (P \\<circ> \\<phi>) s \\<le> wp a (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s \\<le> wp a (Q \\<circ> \\<phi>) s", "."], ["proof (state)\nthis:\n  (P \\<circ> \\<phi>) s \\<le> wp a (Q \\<circ> \\<phi>) s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Correspondence implies data refinement\\<close>"], ["", "lemma pcorres_drefine:\n  assumes corres: \"pcorres \\<phi> G A C\"\n      and wC: \"well_def C\"\n  shows \"drefines \\<phi> G A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drefines \\<phi> G A C", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "fix P and Q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "assume uP: \"unitary P\" and uQ: \"unitary Q\"\n     and wpA: \"P \\<tturnstile> wp A Q\""], ["proof (state)\nthis:\n  unitary P\n  unitary Q\n  P \\<tturnstile> wp A Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "from wpA"], ["proof (chain)\npicking this:\n  P \\<tturnstile> wp A Q", "have \"P o \\<phi> \\<tturnstile> wp A Q o \\<phi>\""], ["proof (prove)\nusing this:\n  P \\<tturnstile> wp A Q\n\ngoal (1 subgoal):\n 1. P \\<circ> \\<phi> \\<tturnstile> wp A Q \\<circ> \\<phi>", "by(simp add:o_def le_fun_def)"], ["proof (state)\nthis:\n  P \\<circ> \\<phi> \\<tturnstile> wp A Q \\<circ> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "hence \"\\<guillemotleft>G\\<guillemotright> && (P o \\<phi>) \\<tturnstile> \\<guillemotleft>G\\<guillemotright> && (wp A Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  P \\<circ> \\<phi> \\<tturnstile> wp A Q \\<circ> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> &&\n    (P \\<circ>\n     \\<phi>) \\<tturnstile> \\<guillemotleft> G \\<guillemotright> &&\n                           (wp A Q \\<circ> \\<phi>)", "by(rule exp_conj_mono_right)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ>\n   \\<phi>) \\<tturnstile> \\<guillemotleft> G \\<guillemotright> &&\n                         (wp A Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "also"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ>\n   \\<phi>) \\<tturnstile> \\<guillemotleft> G \\<guillemotright> &&\n                         (wp A Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "from corres uQ"], ["proof (chain)\npicking this:\n  pcorres \\<phi> G A C\n  unitary Q", "have \"... = \\<guillemotleft>G\\<guillemotright> && (wp C (Q o \\<phi>))\""], ["proof (prove)\nusing this:\n  pcorres \\<phi> G A C\n  unitary Q\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>) =\n    \\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)", "by(rule pcorresD)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>) =\n  \\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "also"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> && (wp A Q \\<circ> \\<phi>) =\n  \\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "have \"... \\<tturnstile> wp C (Q o \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> &&\n    wp C (Q \\<circ> \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "proof(rule le_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) x\n       \\<le> wp C (Q \\<circ> \\<phi>) x", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) x\n       \\<le> wp C (Q \\<circ> \\<phi>) x", "from uQ"], ["proof (chain)\npicking this:\n  unitary Q", "have \"unitary (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. unitary (Q \\<circ> \\<phi>)", "by(rule unitary_intros)"], ["proof (state)\nthis:\n  unitary (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) x\n       \\<le> wp C (Q \\<circ> \\<phi>) x", "with well_def_wp_healthy[OF wC]"], ["proof (chain)\npicking this:\n  healthy (wp C)\n  unitary (Q \\<circ> \\<phi>)", "have nn_wpC: \"0 \\<le> wp C (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  healthy (wp C)\n  unitary (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. 0 \\<le> wp C (Q \\<circ> \\<phi>) s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> wp C (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) x\n       \\<le> wp C (Q \\<circ> \\<phi>) x", "show \"(\\<guillemotleft>G\\<guillemotright> && wp C (Q o \\<phi>)) s \\<le> wp C (Q o \\<phi>) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "proof(cases \"G s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s\n 2. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "case True"], ["proof (state)\nthis:\n  G s\n\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s\n 2. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "with nn_wpC"], ["proof (chain)\npicking this:\n  0 \\<le> wp C (Q \\<circ> \\<phi>) s\n  G s", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> wp C (Q \\<circ> \\<phi>) s\n  G s\n\ngoal (1 subgoal):\n 1. (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "by(simp add:exp_conj_def)"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n  \\<le> wp C (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "case False"], ["proof (state)\nthis:\n  \\<not> G s\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "note this"], ["proof (state)\nthis:\n  \\<not> G s\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "moreover"], ["proof (state)\nthis:\n  \\<not> G s\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "{"], ["proof (state)\nthis:\n  \\<not> G s\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "from uQ"], ["proof (chain)\npicking this:\n  unitary Q", "have \"unitary (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. unitary (Q \\<circ> \\<phi>)", "by(simp)"], ["proof (state)\nthis:\n  unitary (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "with well_def_wp_healthy[OF wC]"], ["proof (chain)\npicking this:\n  healthy (wp C)\n  unitary (Q \\<circ> \\<phi>)", "have \"wp C (Q o \\<phi>) s \\<le> 1\""], ["proof (prove)\nusing this:\n  healthy (wp C)\n  unitary (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. wp C (Q \\<circ> \\<phi>) s \\<le> 1", "by(auto)"], ["proof (state)\nthis:\n  wp C (Q \\<circ> \\<phi>) s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "}"], ["proof (state)\nthis:\n  wp C (Q \\<circ> \\<phi>) s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "moreover"], ["proof (state)\nthis:\n  wp C (Q \\<circ> \\<phi>) s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "note nn_wpC"], ["proof (state)\nthis:\n  0 \\<le> wp C (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> G s\n  wp C (Q \\<circ> \\<phi>) s \\<le> 1\n  0 \\<le> wp C (Q \\<circ> \\<phi>) s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> G s\n  wp C (Q \\<circ> \\<phi>) s \\<le> 1\n  0 \\<le> wp C (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n    \\<le> wp C (Q \\<circ> \\<phi>) s", "by(simp add:exp_conj_def)"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n  \\<le> wp C (Q \\<circ> \\<phi>) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && wp C (Q \\<circ> \\<phi>)) s\n  \\<le> wp C (Q \\<circ> \\<phi>) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  wp C (Q \\<circ> \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<lbrakk>unitary P; unitary Q; P \\<tturnstile> wp A Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> &&\n                         (P \\<circ>\n                          \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "finally"], ["proof (chain)\npicking this:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "show \"\\<guillemotleft>G\\<guillemotright> && (P o \\<phi>) \\<tturnstile> wp C (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> &&\n    (P \\<circ> \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)", "."], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (P \\<circ> \\<phi>) \\<tturnstile> wp C (Q \\<circ> \\<phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Any \\emph{data} refinement of a deterministic program is correspondence. This is the\nanalogous result to that relating program refinement and equivalence.\\<close>"], ["", "lemma drefines_determ:\n  fixes a::\"'a prog\" and b::\"'b prog\"\n  assumes da: \"determ (wp a)\"\n      and wa: \"well_def a\"\n      and wb: \"well_def b\"\n      and dr: \"drefines \\<phi> G a b\"\n  shows \"pcorres \\<phi> G a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pcorres \\<phi> G a b", "txt \\<open>The proof follows exactly the same form\n    as that for program refinement: Assuming that correspondence\n    \\emph{doesn't} hold, we show that @{term \"wp b\"} is not feasible,\n    and thus not healthy, contradicting the assumption.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. pcorres \\<phi> G a b", "proof(rule pcorresI, rule contrapos_pp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q. unitary Q \\<Longrightarrow> ?Q2 Q\n 2. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> ?Q2 Q", "from wb"], ["proof (chain)\npicking this:\n  well_def b", "show \"feasible (wp b)\""], ["proof (prove)\nusing this:\n  well_def b\n\ngoal (1 subgoal):\n 1. feasible (wp b)", "by(auto)"], ["proof (state)\nthis:\n  feasible (wp b)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "note ha = well_def_wp_healthy[OF wa]"], ["proof (state)\nthis:\n  healthy (wp a)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "note hb = well_def_wp_healthy[OF wb]"], ["proof (state)\nthis:\n  healthy (wp b)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "from wb"], ["proof (chain)\npicking this:\n  well_def b", "have \"sublinear (wp b)\""], ["proof (prove)\nusing this:\n  well_def b\n\ngoal (1 subgoal):\n 1. sublinear (wp b)", "by(auto)"], ["proof (state)\nthis:\n  sublinear (wp b)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "moreover"], ["proof (state)\nthis:\n  sublinear (wp b)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "from hb"], ["proof (chain)\npicking this:\n  healthy (wp b)", "have \"feasible (wp b)\""], ["proof (prove)\nusing this:\n  healthy (wp b)\n\ngoal (1 subgoal):\n 1. feasible (wp b)", "by(auto)"], ["proof (state)\nthis:\n  feasible (wp b)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "ultimately"], ["proof (chain)\npicking this:\n  sublinear (wp b)\n  feasible (wp b)", "have sab: \"sub_add (wp b)\""], ["proof (prove)\nusing this:\n  sublinear (wp b)\n  feasible (wp b)\n\ngoal (1 subgoal):\n 1. sub_add (wp b)", "by(rule sublinear_subadd)"], ["proof (state)\nthis:\n  sub_add (wp b)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "fix Q::\"'a \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "assume uQ: \"unitary Q\""], ["proof (state)\nthis:\n  unitary Q\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "hence uQ\\<phi>: \"unitary (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. unitary (Q \\<circ> \\<phi>)", "by(auto)"], ["proof (state)\nthis:\n  unitary (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "assume ne: \"\\<guillemotleft>G\\<guillemotright> && (wp a Q o \\<phi>) \\<noteq> \\<guillemotleft>G\\<guillemotright> && wp b (Q o \\<phi>)\""], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>) \\<noteq>\n  \\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "hence ne': \"wp a Q o \\<phi> \\<noteq> wp b (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>) \\<noteq>\n  \\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. wp a Q \\<circ> \\<phi> \\<noteq> wp b (Q \\<circ> \\<phi>)", "by(auto)"], ["proof (state)\nthis:\n  wp a Q \\<circ> \\<phi> \\<noteq> wp b (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "txt \\<open>From refinement, @{term \"\\<guillemotleft>G\\<guillemotright> && (wp a Q o \\<phi>)\"}\n    lies below @{term \"\\<guillemotleft>G\\<guillemotright> && wp b (Q o \\<phi>)\"}.\\<close>"], ["proof (state)\nthis:\n  wp a Q \\<circ> \\<phi> \\<noteq> wp b (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "from ha uQ"], ["proof (chain)\npicking this:\n  healthy (wp a)\n  unitary Q", "have gle: \"\\<guillemotleft>G\\<guillemotright> && (wp a Q o \\<phi>) \\<tturnstile> wp b (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  healthy (wp a)\n  unitary Q\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> &&\n    (wp a Q \\<circ> \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)", "by(blast intro!:drefinesD[OF dr])"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (wp a Q \\<circ> \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "have le: \"\\<guillemotleft>G\\<guillemotright> && (wp a Q o \\<phi>) \\<tturnstile> \\<guillemotleft>G\\<guillemotright> && wp b (Q o \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> &&\n    (wp a Q \\<circ>\n     \\<phi>) \\<tturnstile> \\<guillemotleft> G \\<guillemotright> &&\n                           wp b (Q \\<circ> \\<phi>)", "unfolding exp_conj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       \\<guillemotleft> G \\<guillemotright> s .&\n       (wp a Q \\<circ> \\<phi>)\n        s \\<tturnstile> \\<lambda>s.\n                           \\<guillemotleft> G \\<guillemotright> s .&\n                           wp b (Q \\<circ> \\<phi>) s", "proof(rule le_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft> G \\<guillemotright> x .& (wp a Q \\<circ> \\<phi>) x\n       \\<le> \\<guillemotleft> G \\<guillemotright> x .&\n             wp b (Q \\<circ> \\<phi>) x", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft> G \\<guillemotright> x .& (wp a Q \\<circ> \\<phi>) x\n       \\<le> \\<guillemotleft> G \\<guillemotright> x .&\n             wp b (Q \\<circ> \\<phi>) x", "from gle"], ["proof (chain)\npicking this:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (wp a Q \\<circ> \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)", "have \"\\<guillemotleft>G\\<guillemotright> s .& (wp a Q o \\<phi>) s \\<le> wp b (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (wp a Q \\<circ> \\<phi>) \\<tturnstile> wp b (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> s .& (wp a Q \\<circ> \\<phi>) s\n    \\<le> wp b (Q \\<circ> \\<phi>) s", "unfolding exp_conj_def"], ["proof (prove)\nusing this:\n  \\<lambda>s.\n     \\<guillemotleft> G \\<guillemotright> s .&\n     (wp a Q \\<circ> \\<phi>) s \\<tturnstile> wp b (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> s .& (wp a Q \\<circ> \\<phi>) s\n    \\<le> wp b (Q \\<circ> \\<phi>) s", "by(auto)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> s .& (wp a Q \\<circ> \\<phi>) s\n  \\<le> wp b (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft> G \\<guillemotright> x .& (wp a Q \\<circ> \\<phi>) x\n       \\<le> \\<guillemotleft> G \\<guillemotright> x .&\n             wp b (Q \\<circ> \\<phi>) x", "hence \"\\<guillemotleft>G\\<guillemotright> s .& (\\<guillemotleft>G\\<guillemotright> s .& (wp a Q o \\<phi>) s) \\<le> \\<guillemotleft>G\\<guillemotright> s .& wp b (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> G \\<guillemotright> s .& (wp a Q \\<circ> \\<phi>) s\n  \\<le> wp b (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> s .&\n    (\\<guillemotleft> G \\<guillemotright> s .& (wp a Q \\<circ> \\<phi>) s)\n    \\<le> \\<guillemotleft> G \\<guillemotright> s .&\n          wp b (Q \\<circ> \\<phi>) s", "by(auto intro:pconj_mono)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> s .&\n  (\\<guillemotleft> G \\<guillemotright> s .& (wp a Q \\<circ> \\<phi>) s)\n  \\<le> \\<guillemotleft> G \\<guillemotright> s .& wp b (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft> G \\<guillemotright> x .& (wp a Q \\<circ> \\<phi>) x\n       \\<le> \\<guillemotleft> G \\<guillemotright> x .&\n             wp b (Q \\<circ> \\<phi>) x", "moreover"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> s .&\n  (\\<guillemotleft> G \\<guillemotright> s .& (wp a Q \\<circ> \\<phi>) s)\n  \\<le> \\<guillemotleft> G \\<guillemotright> s .& wp b (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft> G \\<guillemotright> x .& (wp a Q \\<circ> \\<phi>) x\n       \\<le> \\<guillemotleft> G \\<guillemotright> x .&\n             wp b (Q \\<circ> \\<phi>) x", "from uQ ha"], ["proof (chain)\npicking this:\n  unitary Q\n  healthy (wp a)", "have \"wp a Q (\\<phi> s) \\<le> 1\""], ["proof (prove)\nusing this:\n  unitary Q\n  healthy (wp a)\n\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) \\<le> 1", "by(auto dest:healthy_bounded_byD)"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft> G \\<guillemotright> x .& (wp a Q \\<circ> \\<phi>) x\n       \\<le> \\<guillemotleft> G \\<guillemotright> x .&\n             wp b (Q \\<circ> \\<phi>) x", "moreover"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft> G \\<guillemotright> x .& (wp a Q \\<circ> \\<phi>) x\n       \\<le> \\<guillemotleft> G \\<guillemotright> x .&\n             wp b (Q \\<circ> \\<phi>) x", "from uQ ha"], ["proof (chain)\npicking this:\n  unitary Q\n  healthy (wp a)", "have \"0 \\<le> wp a Q (\\<phi> s)\""], ["proof (prove)\nusing this:\n  unitary Q\n  healthy (wp a)\n\ngoal (1 subgoal):\n 1. 0 \\<le> wp a Q (\\<phi> s)", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> wp a Q (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft> G \\<guillemotright> x .& (wp a Q \\<circ> \\<phi>) x\n       \\<le> \\<guillemotleft> G \\<guillemotright> x .&\n             wp b (Q \\<circ> \\<phi>) x", "ultimately"], ["proof (chain)\npicking this:\n  \\<guillemotleft> G \\<guillemotright> s .&\n  (\\<guillemotleft> G \\<guillemotright> s .& (wp a Q \\<circ> \\<phi>) s)\n  \\<le> \\<guillemotleft> G \\<guillemotright> s .& wp b (Q \\<circ> \\<phi>) s\n  wp a Q (\\<phi> s) \\<le> 1\n  0 \\<le> wp a Q (\\<phi> s)", "show \"\\<guillemotleft> G \\<guillemotright> s .& (wp a Q \\<circ> \\<phi>) s \\<le> \\<guillemotleft> G \\<guillemotright> s .& wp b (Q \\<circ> \\<phi>) s\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> G \\<guillemotright> s .&\n  (\\<guillemotleft> G \\<guillemotright> s .& (wp a Q \\<circ> \\<phi>) s)\n  \\<le> \\<guillemotleft> G \\<guillemotright> s .& wp b (Q \\<circ> \\<phi>) s\n  wp a Q (\\<phi> s) \\<le> 1\n  0 \\<le> wp a Q (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> s .& (wp a Q \\<circ> \\<phi>) s\n    \\<le> \\<guillemotleft> G \\<guillemotright> s .&\n          wp b (Q \\<circ> \\<phi>) s", "by(simp add:pconj_assoc)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> s .& (wp a Q \\<circ> \\<phi>) s\n  \\<le> \\<guillemotleft> G \\<guillemotright> s .& wp b (Q \\<circ> \\<phi>) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (wp a Q \\<circ>\n   \\<phi>) \\<tturnstile> \\<guillemotleft> G \\<guillemotright> &&\n                         wp b (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "txt \\<open>If the programs do not correspond, the terms must differ somewhere, and given the previous\n  result, the second must be somewhere strictly larger than the first:\\<close>"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (wp a Q \\<circ>\n   \\<phi>) \\<tturnstile> \\<guillemotleft> G \\<guillemotright> &&\n                         wp b (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "have nle: \"\\<exists>s. (\\<guillemotleft>G\\<guillemotright> && (wp a Q o \\<phi>)) s < (\\<guillemotleft>G\\<guillemotright> && wp b (Q o \\<phi>)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s.\n       (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n       < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "proof(rule contrapos_np[OF ne], rule ext, rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<nexists>s.\n          (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>))\n           s\n          < (\\<guillemotleft> G \\<guillemotright> &&\n             wp b (Q \\<circ> \\<phi>))\n             s \\<Longrightarrow>\n       (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) x\n       \\<le> (\\<guillemotleft> G \\<guillemotright> &&\n              wp b (Q \\<circ> \\<phi>))\n              x\n 2. \\<And>x.\n       \\<nexists>s.\n          (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>))\n           s\n          < (\\<guillemotleft> G \\<guillemotright> &&\n             wp b (Q \\<circ> \\<phi>))\n             s \\<Longrightarrow>\n       (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) x\n       \\<le> (\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              x", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<nexists>s.\n          (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>))\n           s\n          < (\\<guillemotleft> G \\<guillemotright> &&\n             wp b (Q \\<circ> \\<phi>))\n             s \\<Longrightarrow>\n       (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) x\n       \\<le> (\\<guillemotleft> G \\<guillemotright> &&\n              wp b (Q \\<circ> \\<phi>))\n              x\n 2. \\<And>x.\n       \\<nexists>s.\n          (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>))\n           s\n          < (\\<guillemotleft> G \\<guillemotright> &&\n             wp b (Q \\<circ> \\<phi>))\n             s \\<Longrightarrow>\n       (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) x\n       \\<le> (\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              x", "from le"], ["proof (chain)\npicking this:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (wp a Q \\<circ>\n   \\<phi>) \\<tturnstile> \\<guillemotleft> G \\<guillemotright> &&\n                         wp b (Q \\<circ> \\<phi>)", "show \"(\\<guillemotleft>G\\<guillemotright> && (wp a Q o \\<phi>)) s \\<le> (\\<guillemotleft>G\\<guillemotright> && wp b (Q o \\<phi>)) s\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (wp a Q \\<circ>\n   \\<phi>) \\<tturnstile> \\<guillemotleft> G \\<guillemotright> &&\n                         wp b (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n    \\<le> (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>))\n           s", "by(blast)"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n  \\<le> (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<nexists>s.\n          (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>))\n           s\n          < (\\<guillemotleft> G \\<guillemotright> &&\n             wp b (Q \\<circ> \\<phi>))\n             s \\<Longrightarrow>\n       (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) x\n       \\<le> (\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<nexists>s.\n          (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>))\n           s\n          < (\\<guillemotleft> G \\<guillemotright> &&\n             wp b (Q \\<circ> \\<phi>))\n             s \\<Longrightarrow>\n       (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) x\n       \\<le> (\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              x", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<nexists>s.\n          (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>))\n           s\n          < (\\<guillemotleft> G \\<guillemotright> &&\n             wp b (Q \\<circ> \\<phi>))\n             s \\<Longrightarrow>\n       (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) x\n       \\<le> (\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              x", "assume \"\\<not> (\\<exists>s. (\\<guillemotleft>G\\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s < (\\<guillemotleft>G\\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s)\""], ["proof (state)\nthis:\n  \\<nexists>s.\n     (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n     < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<nexists>s.\n          (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>))\n           s\n          < (\\<guillemotleft> G \\<guillemotright> &&\n             wp b (Q \\<circ> \\<phi>))\n             s \\<Longrightarrow>\n       (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) x\n       \\<le> (\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              x", "thus \" (\\<guillemotleft>G\\<guillemotright> && (wp b (Q \\<circ> \\<phi>))) s \\<le> (\\<guillemotleft>G\\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\""], ["proof (prove)\nusing this:\n  \\<nexists>s.\n     (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n     < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n    \\<le> (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>))\n           s", "by(simp add:not_less)"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n  \\<le> (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s.\n     (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n     < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>s.\n     (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n     < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "obtain s where less_s:\n    \"(\\<guillemotleft>G\\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s < (\\<guillemotleft>G\\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\""], ["proof (prove)\nusing this:\n  \\<exists>s.\n     (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n     < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n        < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>))\n           s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(blast)"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n  < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "txt \\<open>The transformers themselves must differ at this point:\\<close>"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n  < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "hence larger: \"wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s\""], ["proof (prove)\nusing this:\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n  < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "proof(cases \"G s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s\n 2. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "case True"], ["proof (state)\nthis:\n  G s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s\n 2. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "moreover"], ["proof (state)\nthis:\n  G s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s\n 2. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "from ha uQ"], ["proof (chain)\npicking this:\n  healthy (wp a)\n  unitary Q", "have \"0 \\<le> wp a Q (\\<phi> s)\""], ["proof (prove)\nusing this:\n  healthy (wp a)\n  unitary Q\n\ngoal (1 subgoal):\n 1. 0 \\<le> wp a Q (\\<phi> s)", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> wp a Q (\\<phi> s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s\n 2. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "moreover"], ["proof (state)\nthis:\n  0 \\<le> wp a Q (\\<phi> s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s\n 2. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "from hb uQ\\<phi>"], ["proof (chain)\npicking this:\n  healthy (wp b)\n  unitary (Q \\<circ> \\<phi>)", "have \"0 \\<le> wp b (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  healthy (wp b)\n  unitary (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. 0 \\<le> wp b (Q \\<circ> \\<phi>) s", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> wp b (Q \\<circ> \\<phi>) s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s\n 2. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "moreover"], ["proof (state)\nthis:\n  0 \\<le> wp b (Q \\<circ> \\<phi>) s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s\n 2. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "note less_s"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n  < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s\n 2. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "ultimately"], ["proof (chain)\npicking this:\n  G s\n  0 \\<le> wp a Q (\\<phi> s)\n  0 \\<le> wp b (Q \\<circ> \\<phi>) s\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n  < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "show ?thesis"], ["proof (prove)\nusing this:\n  G s\n  0 \\<le> wp a Q (\\<phi> s)\n  0 \\<le> wp b (Q \\<circ> \\<phi>) s\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n  < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "by(simp add:exp_conj_def)"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "case False"], ["proof (state)\nthis:\n  \\<not> G s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "moreover"], ["proof (state)\nthis:\n  \\<not> G s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "from ha uQ"], ["proof (chain)\npicking this:\n  healthy (wp a)\n  unitary Q", "have \"wp a Q (\\<phi> s) \\<le> 1\""], ["proof (prove)\nusing this:\n  healthy (wp a)\n  unitary Q\n\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) \\<le> 1", "by(blast)"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "moreover"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "{"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "from uQ"], ["proof (chain)\npicking this:\n  unitary Q", "have \"bounded_by 1 (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. bounded_by 1 (Q \\<circ> \\<phi>)", "by(blast)"], ["proof (state)\nthis:\n  bounded_by 1 (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "moreover"], ["proof (state)\nthis:\n  bounded_by 1 (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "from unitary_sound[OF uQ]"], ["proof (chain)\npicking this:\n  sound Q", "have \"sound (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  sound Q\n\ngoal (1 subgoal):\n 1. sound (Q \\<circ> \\<phi>)", "by(auto)"], ["proof (state)\nthis:\n  sound (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "ultimately"], ["proof (chain)\npicking this:\n  bounded_by 1 (Q \\<circ> \\<phi>)\n  sound (Q \\<circ> \\<phi>)", "have \"wp b (Q o \\<phi>) s \\<le> 1\""], ["proof (prove)\nusing this:\n  bounded_by 1 (Q \\<circ> \\<phi>)\n  sound (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. wp b (Q \\<circ> \\<phi>) s \\<le> 1", "using hb"], ["proof (prove)\nusing this:\n  bounded_by 1 (Q \\<circ> \\<phi>)\n  sound (Q \\<circ> \\<phi>)\n  healthy (wp b)\n\ngoal (1 subgoal):\n 1. wp b (Q \\<circ> \\<phi>) s \\<le> 1", "by(auto)"], ["proof (state)\nthis:\n  wp b (Q \\<circ> \\<phi>) s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "}"], ["proof (state)\nthis:\n  wp b (Q \\<circ> \\<phi>) s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "moreover"], ["proof (state)\nthis:\n  wp b (Q \\<circ> \\<phi>) s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "note less_s"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n  < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<guillemotleft> G \\<guillemotright> &&\n              (wp a Q \\<circ> \\<phi>))\n              s\n             < (\\<guillemotleft> G \\<guillemotright> &&\n                wp b (Q \\<circ> \\<phi>))\n                s;\n     \\<not> G s\\<rbrakk>\n    \\<Longrightarrow> wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> G s\n  wp a Q (\\<phi> s) \\<le> 1\n  wp b (Q \\<circ> \\<phi>) s \\<le> 1\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n  < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> G s\n  wp a Q (\\<phi> s) \\<le> 1\n  wp b (Q \\<circ> \\<phi>) s \\<le> 1\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n  < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s", "by(simp add:exp_conj_def)"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "from less_s"], ["proof (chain)\npicking this:\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n  < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "have \"(\\<guillemotleft>G\\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s \\<noteq> (\\<guillemotleft>G\\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\""], ["proof (prove)\nusing this:\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s\n  < (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>))\n     s \\<noteq>\n    (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "by(force)"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>))\n   s \\<noteq>\n  (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "txt \\<open>@{term G} must also hold, as otherwise both would be zero.\\<close>"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>))\n   s \\<noteq>\n  (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "hence G_s: \"G s\""], ["proof (prove)\nusing this:\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>))\n   s \\<noteq>\n  (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal (1 subgoal):\n 1. G s", "proof(rule contrapos_np)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "assume nG: \"\\<not> G s\""], ["proof (state)\nthis:\n  \\<not> G s\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "moreover"], ["proof (state)\nthis:\n  \\<not> G s\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "from ha uQ"], ["proof (chain)\npicking this:\n  healthy (wp a)\n  unitary Q", "have \"wp a Q (\\<phi> s) \\<le> 1\""], ["proof (prove)\nusing this:\n  healthy (wp a)\n  unitary Q\n\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) \\<le> 1", "by(blast)"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "moreover"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "{"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "from uQ"], ["proof (chain)\npicking this:\n  unitary Q", "have \"bounded_by 1 (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. bounded_by 1 (Q \\<circ> \\<phi>)", "by(blast)"], ["proof (state)\nthis:\n  bounded_by 1 (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "moreover"], ["proof (state)\nthis:\n  bounded_by 1 (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "from unitary_sound[OF uQ]"], ["proof (chain)\npicking this:\n  sound Q", "have \"sound (Q o \\<phi>)\""], ["proof (prove)\nusing this:\n  sound Q\n\ngoal (1 subgoal):\n 1. sound (Q \\<circ> \\<phi>)", "by(auto)"], ["proof (state)\nthis:\n  sound (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "ultimately"], ["proof (chain)\npicking this:\n  bounded_by 1 (Q \\<circ> \\<phi>)\n  sound (Q \\<circ> \\<phi>)", "have \"wp b (Q o \\<phi>) s \\<le> 1\""], ["proof (prove)\nusing this:\n  bounded_by 1 (Q \\<circ> \\<phi>)\n  sound (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. wp b (Q \\<circ> \\<phi>) s \\<le> 1", "using hb"], ["proof (prove)\nusing this:\n  bounded_by 1 (Q \\<circ> \\<phi>)\n  sound (Q \\<circ> \\<phi>)\n  healthy (wp b)\n\ngoal (1 subgoal):\n 1. wp b (Q \\<circ> \\<phi>) s \\<le> 1", "by(auto)"], ["proof (state)\nthis:\n  wp b (Q \\<circ> \\<phi>) s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "}"], ["proof (state)\nthis:\n  wp b (Q \\<circ> \\<phi>) s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> G s \\<Longrightarrow>\n    (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> G s\n  wp a Q (\\<phi> s) \\<le> 1\n  wp b (Q \\<circ> \\<phi>) s \\<le> 1", "show \"(\\<guillemotleft>G\\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s = (\\<guillemotleft>G\\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\""], ["proof (prove)\nusing this:\n  \\<not> G s\n  wp a Q (\\<phi> s) \\<le> 1\n  wp b (Q \\<circ> \\<phi>) s \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s =\n    (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s", "by(simp add:exp_conj_def)"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && (wp a Q \\<circ> \\<phi>)) s =\n  (\\<guillemotleft> G \\<guillemotright> && wp b (Q \\<circ> \\<phi>)) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "txt \\<open>Take a carefully constructed expectation:\\<close>"], ["proof (state)\nthis:\n  G s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "let ?Qc = \"\\<lambda>s. bound_of Q - Q s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "have bQc: \"bounded_by 1 ?Qc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by 1 (\\<lambda>s. bound_of Q - Q s)", "proof(rule bounded_byI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. bound_of Q - Q x \\<le> 1", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. bound_of Q - Q x \\<le> 1", "from uQ"], ["proof (chain)\npicking this:\n  unitary Q", "have \"bound_of Q \\<le> 1\" and \"0 \\<le> Q s\""], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. bound_of Q \\<le> 1 &&& 0 \\<le> Q s", "by(auto)"], ["proof (state)\nthis:\n  bound_of Q \\<le> 1\n  0 \\<le> Q s\n\ngoal (1 subgoal):\n 1. \\<And>x. bound_of Q - Q x \\<le> 1", "thus \"bound_of Q - Q s \\<le> 1\""], ["proof (prove)\nusing this:\n  bound_of Q \\<le> 1\n  0 \\<le> Q s\n\ngoal (1 subgoal):\n 1. bound_of Q - Q s \\<le> 1", "by(auto)"], ["proof (state)\nthis:\n  bound_of Q - Q s \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bounded_by 1 (\\<lambda>s. bound_of Q - Q s)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "have sQc: \"sound ?Qc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound (\\<lambda>s. bound_of Q - Q s)", "proof(rule soundI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Expectations.bounded (\\<lambda>s. bound_of Q - Q s)\n 2. nneg (\\<lambda>s. bound_of Q - Q s)", "from bQc"], ["proof (chain)\npicking this:\n  bounded_by 1 (\\<lambda>s. bound_of Q - Q s)", "show \"bounded ?Qc\""], ["proof (prove)\nusing this:\n  bounded_by 1 (\\<lambda>s. bound_of Q - Q s)\n\ngoal (1 subgoal):\n 1. Expectations.bounded (\\<lambda>s. bound_of Q - Q s)", "by(auto)"], ["proof (state)\nthis:\n  Expectations.bounded (\\<lambda>s. bound_of Q - Q s)\n\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. bound_of Q - Q s)", "show \"nneg ?Qc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nneg (\\<lambda>s. bound_of Q - Q s)", "proof(rule nnegI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. 0 \\<le> bound_of Q - Q x", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. 0 \\<le> bound_of Q - Q x", "from uQ"], ["proof (chain)\npicking this:\n  unitary Q", "have \"Q s \\<le> bound_of Q\""], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. Q s \\<le> bound_of Q", "by(auto)"], ["proof (state)\nthis:\n  Q s \\<le> bound_of Q\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 \\<le> bound_of Q - Q x", "thus \"0 \\<le> bound_of Q - Q s\""], ["proof (prove)\nusing this:\n  Q s \\<le> bound_of Q\n\ngoal (1 subgoal):\n 1. 0 \\<le> bound_of Q - Q s", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> bound_of Q - Q s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nneg (\\<lambda>s. bound_of Q - Q s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sound (\\<lambda>s. bound_of Q - Q s)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "txt \\<open>By the maximality of @{term \"wp a\"}, @{term \"wp b\"} must violate feasibility, by mapping\n  @{term s} to something strictly greater than @{term \"bound_of Q\"}.\\<close>"], ["proof (state)\nthis:\n  sound (\\<lambda>s. bound_of Q - Q s)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "from uQ"], ["proof (chain)\npicking this:\n  unitary Q", "have \"0 \\<le> bound_of Q\""], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. 0 \\<le> bound_of Q", "by(auto)"], ["proof (state)\nthis:\n  0 \\<le> bound_of Q\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "with da"], ["proof (chain)\npicking this:\n  determ (wp a)\n  0 \\<le> bound_of Q", "have \"bound_of Q = wp a (\\<lambda>s. bound_of Q) (\\<phi> s)\""], ["proof (prove)\nusing this:\n  determ (wp a)\n  0 \\<le> bound_of Q\n\ngoal (1 subgoal):\n 1. bound_of Q = wp a (\\<lambda>s. bound_of Q) (\\<phi> s)", "by(simp add:maximalD determ_maximalD)"], ["proof (state)\nthis:\n  bound_of Q = wp a (\\<lambda>s. bound_of Q) (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "also"], ["proof (state)\nthis:\n  bound_of Q = wp a (\\<lambda>s. bound_of Q) (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "have \"wp a (\\<lambda>s. bound_of Q) (\\<phi> s) = wp a (\\<lambda>s. Q s + ?Qc s) (\\<phi> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp a (\\<lambda>s. bound_of Q) (\\<phi> s) =\n    wp a (\\<lambda>s. Q s + (bound_of Q - Q s)) (\\<phi> s)", "by(simp)"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. bound_of Q) (\\<phi> s) =\n  wp a (\\<lambda>s. Q s + (bound_of Q - Q s)) (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "also"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. bound_of Q) (\\<phi> s) =\n  wp a (\\<lambda>s. Q s + (bound_of Q - Q s)) (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "{"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. bound_of Q) (\\<phi> s) =\n  wp a (\\<lambda>s. Q s + (bound_of Q - Q s)) (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "from da"], ["proof (chain)\npicking this:\n  determ (wp a)", "have \"additive (wp a)\""], ["proof (prove)\nusing this:\n  determ (wp a)\n\ngoal (1 subgoal):\n 1. Transformers.additive (wp a)", "by(blast)"], ["proof (state)\nthis:\n  Transformers.additive (wp a)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "with uQ sQc"], ["proof (chain)\npicking this:\n  unitary Q\n  sound (\\<lambda>s. bound_of Q - Q s)\n  Transformers.additive (wp a)", "have \"wp a (\\<lambda>s. Q s + ?Qc s) (\\<phi> s) =\n          wp a Q (\\<phi> s) + wp a ?Qc (\\<phi> s)\""], ["proof (prove)\nusing this:\n  unitary Q\n  sound (\\<lambda>s. bound_of Q - Q s)\n  Transformers.additive (wp a)\n\ngoal (1 subgoal):\n 1. wp a (\\<lambda>s. Q s + (bound_of Q - Q s)) (\\<phi> s) =\n    wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)", "by(subst additiveD, blast+)"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. Q s + (bound_of Q - Q s)) (\\<phi> s) =\n  wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "}"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. Q s + (bound_of Q - Q s)) (\\<phi> s) =\n  wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "also"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. Q s + (bound_of Q - Q s)) (\\<phi> s) =\n  wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "{"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. Q s + (bound_of Q - Q s)) (\\<phi> s) =\n  wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "from ha and sQc and bQc"], ["proof (chain)\npicking this:\n  healthy (wp a)\n  sound (\\<lambda>s. bound_of Q - Q s)\n  bounded_by 1 (\\<lambda>s. bound_of Q - Q s)", "have \"\\<guillemotleft>G\\<guillemotright> && (wp a ?Qc o \\<phi>) \\<tturnstile> wp b (?Qc o \\<phi>)\""], ["proof (prove)\nusing this:\n  healthy (wp a)\n  sound (\\<lambda>s. bound_of Q - Q s)\n  bounded_by 1 (\\<lambda>s. bound_of Q - Q s)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> &&\n    (wp a (\\<lambda>s. bound_of Q - Q s) \\<circ>\n     \\<phi>) \\<tturnstile> wp b\n                            ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>)", "by(blast intro!:drefinesD[OF dr])"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (wp a (\\<lambda>s. bound_of Q - Q s) \\<circ>\n   \\<phi>) \\<tturnstile> wp b\n                          ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "hence \"(\\<guillemotleft>G\\<guillemotright> && (wp a ?Qc o \\<phi>)) s \\<le> wp b (?Qc o \\<phi>) s\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> G \\<guillemotright> &&\n  (wp a (\\<lambda>s. bound_of Q - Q s) \\<circ>\n   \\<phi>) \\<tturnstile> wp b\n                          ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<guillemotleft> G \\<guillemotright> &&\n     (wp a (\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>))\n     s\n    \\<le> wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s", "by(blast)"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> &&\n   (wp a (\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>))\n   s\n  \\<le> wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "moreover"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> &&\n   (wp a (\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>))\n   s\n  \\<le> wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "from sQc and ha"], ["proof (chain)\npicking this:\n  sound (\\<lambda>s. bound_of Q - Q s)\n  healthy (wp a)", "have \"0 \\<le> wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\""], ["proof (prove)\nusing this:\n  sound (\\<lambda>s. bound_of Q - Q s)\n  healthy (wp a)\n\ngoal (1 subgoal):\n 1. 0 \\<le> wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)", "by(blast)"], ["proof (state)\nthis:\n  0 \\<le> wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<guillemotleft> G \\<guillemotright> &&\n   (wp a (\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>))\n   s\n  \\<le> wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n  0 \\<le> wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)", "have \"wp a ?Qc (\\<phi> s) \\<le> wp b (?Qc o \\<phi>) s\""], ["proof (prove)\nusing this:\n  (\\<guillemotleft> G \\<guillemotright> &&\n   (wp a (\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>))\n   s\n  \\<le> wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n  0 \\<le> wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n\ngoal (1 subgoal):\n 1. wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n    \\<le> wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s", "using G_s"], ["proof (prove)\nusing this:\n  (\\<guillemotleft> G \\<guillemotright> &&\n   (wp a (\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>))\n   s\n  \\<le> wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n  0 \\<le> wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n  G s\n\ngoal (1 subgoal):\n 1. wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n    \\<le> wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s", "by(simp add:exp_conj_def)"], ["proof (state)\nthis:\n  wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n  \\<le> wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "hence \"wp a Q (\\<phi> s) + wp a ?Qc (\\<phi> s) \\<le> wp a Q (\\<phi> s) + wp b (?Qc o \\<phi>) s\""], ["proof (prove)\nusing this:\n  wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n  \\<le> wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n    \\<le> wp a Q (\\<phi> s) +\n          wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s", "by(rule add_left_mono)"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n  \\<le> wp a Q (\\<phi> s) +\n        wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "also"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n  \\<le> wp a Q (\\<phi> s) +\n        wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "with larger"], ["proof (chain)\npicking this:\n  wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s\n  wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n  \\<le> wp a Q (\\<phi> s) +\n        wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s", "have \"wp a Q (\\<phi> s) + wp b (?Qc o \\<phi>) s <\n          wp b (Q o \\<phi>) s + wp b (?Qc o \\<phi>) s\""], ["proof (prove)\nusing this:\n  wp a Q (\\<phi> s) < wp b (Q \\<circ> \\<phi>) s\n  wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n  \\<le> wp a Q (\\<phi> s) +\n        wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) +\n    wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n    < wp b (Q \\<circ> \\<phi>) s +\n      wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s", "by(auto)"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) + wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n  < wp b (Q \\<circ> \\<phi>) s +\n    wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "finally"], ["proof (chain)\npicking this:\n  wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n  < wp b (Q \\<circ> \\<phi>) s +\n    wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s", "have \"wp a Q (\\<phi> s) + wp a ?Qc (\\<phi> s) <\n          wp b (Q o \\<phi>) s + wp b (?Qc o \\<phi>) s\""], ["proof (prove)\nusing this:\n  wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n  < wp b (Q \\<circ> \\<phi>) s +\n    wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n    < wp b (Q \\<circ> \\<phi>) s +\n      wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s", "."], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n  < wp b (Q \\<circ> \\<phi>) s +\n    wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "}"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n  < wp b (Q \\<circ> \\<phi>) s +\n    wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "also"], ["proof (state)\nthis:\n  wp a Q (\\<phi> s) + wp a (\\<lambda>s. bound_of Q - Q s) (\\<phi> s)\n  < wp b (Q \\<circ> \\<phi>) s +\n    wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "from sab and unitary_sound[OF uQ] and sQc"], ["proof (chain)\npicking this:\n  sub_add (wp b)\n  sound Q\n  sound (\\<lambda>s. bound_of Q - Q s)", "have \"wp b (Q o \\<phi>) s + wp b (?Qc o \\<phi>) s \\<le>\n        wp b (\\<lambda>s. (Q o \\<phi>) s + (?Qc o \\<phi>) s) s\""], ["proof (prove)\nusing this:\n  sub_add (wp b)\n  sound Q\n  sound (\\<lambda>s. bound_of Q - Q s)\n\ngoal (1 subgoal):\n 1. wp b (Q \\<circ> \\<phi>) s +\n    wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n    \\<le> wp b\n           (\\<lambda>s.\n               (Q \\<circ> \\<phi>) s +\n               ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s)\n           s", "by(blast)"], ["proof (state)\nthis:\n  wp b (Q \\<circ> \\<phi>) s +\n  wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n  \\<le> wp b\n         (\\<lambda>s.\n             (Q \\<circ> \\<phi>) s +\n             ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s)\n         s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "also"], ["proof (state)\nthis:\n  wp b (Q \\<circ> \\<phi>) s +\n  wp b ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s\n  \\<le> wp b\n         (\\<lambda>s.\n             (Q \\<circ> \\<phi>) s +\n             ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s)\n         s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "have \"... = wp b (\\<lambda>s. bound_of Q) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp b\n     (\\<lambda>s.\n         (Q \\<circ> \\<phi>) s +\n         ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s)\n     s =\n    wp b (\\<lambda>s. bound_of Q) s", "by(simp)"], ["proof (state)\nthis:\n  wp b\n   (\\<lambda>s.\n       (Q \\<circ> \\<phi>) s +\n       ((\\<lambda>s. bound_of Q - Q s) \\<circ> \\<phi>) s)\n   s =\n  wp b (\\<lambda>s. bound_of Q) s\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>unitary Q;\n        \\<guillemotleft> G \\<guillemotright> &&\n        (wp a Q \\<circ> \\<phi>) \\<noteq>\n        \\<guillemotleft> G \\<guillemotright> &&\n        wp b (Q \\<circ> \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> \\<not> feasible (wp b)", "finally"], ["proof (chain)\npicking this:\n  bound_of Q < wp b (\\<lambda>s. bound_of Q) s", "show \"\\<not> feasible (wp b)\""], ["proof (prove)\nusing this:\n  bound_of Q < wp b (\\<lambda>s. bound_of Q) s\n\ngoal (1 subgoal):\n 1. \\<not> feasible (wp b)", "proof(rule contrapos_pn)"], ["proof (state)\ngoal (1 subgoal):\n 1. feasible (wp b) \\<Longrightarrow>\n    \\<not> bound_of Q < wp b (\\<lambda>s. bound_of Q) s", "assume fb: \"feasible (wp b)\""], ["proof (state)\nthis:\n  feasible (wp b)\n\ngoal (1 subgoal):\n 1. feasible (wp b) \\<Longrightarrow>\n    \\<not> bound_of Q < wp b (\\<lambda>s. bound_of Q) s", "have \"bounded_by (bound_of Q) (\\<lambda>s. bound_of Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_by (bound_of Q) (\\<lambda>s. bound_of Q)", "by(blast)"], ["proof (state)\nthis:\n  bounded_by (bound_of Q) (\\<lambda>s. bound_of Q)\n\ngoal (1 subgoal):\n 1. feasible (wp b) \\<Longrightarrow>\n    \\<not> bound_of Q < wp b (\\<lambda>s. bound_of Q) s", "hence \"bounded_by (bound_of Q) (wp b (\\<lambda>s. bound_of Q))\""], ["proof (prove)\nusing this:\n  bounded_by (bound_of Q) (\\<lambda>s. bound_of Q)\n\ngoal (1 subgoal):\n 1. bounded_by (bound_of Q) (wp b (\\<lambda>s. bound_of Q))", "using uQ"], ["proof (prove)\nusing this:\n  bounded_by (bound_of Q) (\\<lambda>s. bound_of Q)\n  unitary Q\n\ngoal (1 subgoal):\n 1. bounded_by (bound_of Q) (wp b (\\<lambda>s. bound_of Q))", "by(blast intro:feasible_boundedD[OF fb])"], ["proof (state)\nthis:\n  bounded_by (bound_of Q) (wp b (\\<lambda>s. bound_of Q))\n\ngoal (1 subgoal):\n 1. feasible (wp b) \\<Longrightarrow>\n    \\<not> bound_of Q < wp b (\\<lambda>s. bound_of Q) s", "hence \"wp b (\\<lambda>s. bound_of Q) s \\<le> bound_of Q\""], ["proof (prove)\nusing this:\n  bounded_by (bound_of Q) (wp b (\\<lambda>s. bound_of Q))\n\ngoal (1 subgoal):\n 1. wp b (\\<lambda>s. bound_of Q) s \\<le> bound_of Q", "by(blast)"], ["proof (state)\nthis:\n  wp b (\\<lambda>s. bound_of Q) s \\<le> bound_of Q\n\ngoal (1 subgoal):\n 1. feasible (wp b) \\<Longrightarrow>\n    \\<not> bound_of Q < wp b (\\<lambda>s. bound_of Q) s", "thus \"\\<not> bound_of Q < wp b (\\<lambda>s. bound_of Q) s\""], ["proof (prove)\nusing this:\n  wp b (\\<lambda>s. bound_of Q) s \\<le> bound_of Q\n\ngoal (1 subgoal):\n 1. \\<not> bound_of Q < wp b (\\<lambda>s. bound_of Q) s", "by(simp)"], ["proof (state)\nthis:\n  \\<not> bound_of Q < wp b (\\<lambda>s. bound_of Q) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> feasible (wp b)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Structural Rules for Correspondence\\<close>"], ["", "lemma pcorres_Skip:\n  \"pcorres \\<phi> G Skip Skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pcorres \\<phi> G Skip Skip", "by(simp add:pcorres_def wp_eval)"], ["", "text \\<open>Correspondence composes over sequential composition.\\<close>"], ["", "lemma pcorres_Seq:\n  fixes A::\"'b prog\" and B::\"'c prog\"\n    and C::\"'b prog\" and D::\"'c prog\"\n    and \\<phi>::\"'c \\<Rightarrow> 'b\"\n  assumes pcAB: \"pcorres \\<phi> G A B\"\n      and pcCD: \"pcorres \\<phi> H C D\"\n      and wA: \"well_def A\" and wB: \"well_def B\"\n      and wC: \"well_def C\" and wD: \"well_def D\"\n      and p3p2: \"\\<And>Q. unitary Q \\<Longrightarrow> \\<guillemotleft>I\\<guillemotright> && wp B Q = wp B (\\<guillemotleft>H\\<guillemotright> && Q)\"\n      and p1p3: \"\\<And>s. G s \\<Longrightarrow> I s\"\n  shows \"pcorres \\<phi> G (A;;C) (B;;D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pcorres \\<phi> G (A ;; C) (B ;; D)", "proof(rule pcorresI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q.\n       unitary Q \\<Longrightarrow>\n       \\<guillemotleft> G \\<guillemotright> &&\n       (wp (A ;; C) Q \\<circ> \\<phi>) =\n       \\<guillemotleft> G \\<guillemotright> &&\n       wp (B ;; D) (Q \\<circ> \\<phi>)", "fix Q::\"'b \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q.\n       unitary Q \\<Longrightarrow>\n       \\<guillemotleft> G \\<guillemotright> &&\n       (wp (A ;; C) Q \\<circ> \\<phi>) =\n       \\<guillemotleft> G \\<guillemotright> &&\n       wp (B ;; D) (Q \\<circ> \\<phi>)", "assume uQ: \"unitary Q\""], ["proof (state)\nthis:\n  unitary Q\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       unitary Q \\<Longrightarrow>\n       \\<guillemotleft> G \\<guillemotright> &&\n       (wp (A ;; C) Q \\<circ> \\<phi>) =\n       \\<guillemotleft> G \\<guillemotright> &&\n       wp (B ;; D) (Q \\<circ> \\<phi>)", "with well_def_wp_healthy[OF wC]"], ["proof (chain)\npicking this:\n  healthy (wp C)\n  unitary Q", "have uCQ: \"unitary (wp C Q)\""], ["proof (prove)\nusing this:\n  healthy (wp C)\n  unitary Q\n\ngoal (1 subgoal):\n 1. unitary (wp C Q)", "by(auto)"], ["proof (state)\nthis:\n  unitary (wp C Q)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       unitary Q \\<Longrightarrow>\n       \\<guillemotleft> G \\<guillemotright> &&\n       (wp (A ;; C) Q \\<circ> \\<phi>) =\n       \\<guillemotleft> G \\<guillemotright> &&\n       wp (B ;; D) (Q \\<circ> \\<phi>)", "from uQ well_def_wp_healthy[OF wD]"], ["proof (chain)\npicking this:\n  unitary Q\n  healthy (wp D)", "have uDQ: \"unitary (wp D (Q o \\<phi>))\""], ["proof (prove)\nusing this:\n  unitary Q\n  healthy (wp D)\n\ngoal (1 subgoal):\n 1. unitary (wp D (Q \\<circ> \\<phi>))", "by(auto dest:unitary_comp)"], ["proof (state)\nthis:\n  unitary (wp D (Q \\<circ> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       unitary Q \\<Longrightarrow>\n       \\<guillemotleft> G \\<guillemotright> &&\n       (wp (A ;; C) Q \\<circ> \\<phi>) =\n       \\<guillemotleft> G \\<guillemotright> &&\n       wp (B ;; D) (Q \\<circ> \\<phi>)", "have p3p1: \"\\<And>R S. \\<lbrakk> unitary R; unitary S; \\<guillemotleft>I\\<guillemotright> && R = \\<guillemotleft>I\\<guillemotright> && S \\<rbrakk> \\<Longrightarrow>\n                    \\<guillemotleft>G\\<guillemotright> && R = \\<guillemotleft>G\\<guillemotright> && S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>R S.\n       \\<lbrakk>unitary R; unitary S;\n        \\<guillemotleft> I \\<guillemotright> && R =\n        \\<guillemotleft> I \\<guillemotright> && S\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> && R =\n                         \\<guillemotleft> G \\<guillemotright> && S", "proof(rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R S x.\n       \\<lbrakk>unitary R; unitary S;\n        \\<guillemotleft> I \\<guillemotright> && R =\n        \\<guillemotleft> I \\<guillemotright> && S\\<rbrakk>\n       \\<Longrightarrow> (\\<guillemotleft> G \\<guillemotright> && R) x =\n                         (\\<guillemotleft> G \\<guillemotright> && S) x", "fix R::\"'c \\<Rightarrow> real\" and S::\"'c \\<Rightarrow> real\" and s::'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R S x.\n       \\<lbrakk>unitary R; unitary S;\n        \\<guillemotleft> I \\<guillemotright> && R =\n        \\<guillemotleft> I \\<guillemotright> && S\\<rbrakk>\n       \\<Longrightarrow> (\\<guillemotleft> G \\<guillemotright> && R) x =\n                         (\\<guillemotleft> G \\<guillemotright> && S) x", "assume a3: \"\\<guillemotleft>I\\<guillemotright> && R = \\<guillemotleft>I\\<guillemotright> && S\"\n       and uR: \"unitary R\" and uS: \"unitary S\""], ["proof (state)\nthis:\n  \\<guillemotleft> I \\<guillemotright> && R =\n  \\<guillemotleft> I \\<guillemotright> && S\n  unitary R\n  unitary S\n\ngoal (1 subgoal):\n 1. \\<And>R S x.\n       \\<lbrakk>unitary R; unitary S;\n        \\<guillemotleft> I \\<guillemotright> && R =\n        \\<guillemotleft> I \\<guillemotright> && S\\<rbrakk>\n       \\<Longrightarrow> (\\<guillemotleft> G \\<guillemotright> && R) x =\n                         (\\<guillemotleft> G \\<guillemotright> && S) x", "show \"(\\<guillemotleft>G\\<guillemotright> && R) s = (\\<guillemotleft>G\\<guillemotright> && S) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<guillemotleft> G \\<guillemotright> && R) s =\n    (\\<guillemotleft> G \\<guillemotright> && S) s", "proof(simp add:exp_conj_def, cases \"G s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s\n 2. \\<not> G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "case False"], ["proof (state)\nthis:\n  \\<not> G s\n\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s\n 2. \\<not> G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "note this"], ["proof (state)\nthis:\n  \\<not> G s\n\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s\n 2. \\<not> G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "moreover"], ["proof (state)\nthis:\n  \\<not> G s\n\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s\n 2. \\<not> G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "from uR"], ["proof (chain)\npicking this:\n  unitary R", "have \"R s \\<le> 1\""], ["proof (prove)\nusing this:\n  unitary R\n\ngoal (1 subgoal):\n 1. R s \\<le> 1", "by(blast)"], ["proof (state)\nthis:\n  R s \\<le> 1\n\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s\n 2. \\<not> G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "moreover"], ["proof (state)\nthis:\n  R s \\<le> 1\n\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s\n 2. \\<not> G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "from uS"], ["proof (chain)\npicking this:\n  unitary S", "have \"S s \\<le> 1\""], ["proof (prove)\nusing this:\n  unitary S\n\ngoal (1 subgoal):\n 1. S s \\<le> 1", "by(blast)"], ["proof (state)\nthis:\n  S s \\<le> 1\n\ngoal (2 subgoals):\n 1. G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s\n 2. \\<not> G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> G s\n  R s \\<le> 1\n  S s \\<le> 1", "show \"\\<guillemotleft>G\\<guillemotright> s .& R s = \\<guillemotleft>G\\<guillemotright> s .& S s\""], ["proof (prove)\nusing this:\n  \\<not> G s\n  R s \\<le> 1\n  S s \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "by(simp)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> s .& R s =\n  \\<guillemotleft> G \\<guillemotright> s .& S s\n\ngoal (1 subgoal):\n 1. G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "case True"], ["proof (state)\nthis:\n  G s\n\ngoal (1 subgoal):\n 1. G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "note p1 = this"], ["proof (state)\nthis:\n  G s\n\ngoal (1 subgoal):\n 1. G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "with p1p3"], ["proof (chain)\npicking this:\n  G ?s \\<Longrightarrow> I ?s\n  G s", "have \"I s\""], ["proof (prove)\nusing this:\n  G ?s \\<Longrightarrow> I ?s\n  G s\n\ngoal (1 subgoal):\n 1. I s", "by(blast)"], ["proof (state)\nthis:\n  I s\n\ngoal (1 subgoal):\n 1. G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "with fun_cong[OF a3, where x=s]"], ["proof (chain)\npicking this:\n  (\\<guillemotleft> I \\<guillemotright> && R) s =\n  (\\<guillemotleft> I \\<guillemotright> && S) s\n  I s", "have \"1 .& R s = 1 .& S s\""], ["proof (prove)\nusing this:\n  (\\<guillemotleft> I \\<guillemotright> && R) s =\n  (\\<guillemotleft> I \\<guillemotright> && S) s\n  I s\n\ngoal (1 subgoal):\n 1. 1 .& R s = 1 .& S s", "by(simp add:exp_conj_def)"], ["proof (state)\nthis:\n  1 .& R s = 1 .& S s\n\ngoal (1 subgoal):\n 1. G s \\<Longrightarrow>\n    \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "with p1"], ["proof (chain)\npicking this:\n  G s\n  1 .& R s = 1 .& S s", "show \"\\<guillemotleft>G\\<guillemotright> s .& R s = \\<guillemotleft>G\\<guillemotright> s .& S s\""], ["proof (prove)\nusing this:\n  G s\n  1 .& R s = 1 .& S s\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> s .& R s =\n    \\<guillemotleft> G \\<guillemotright> s .& S s", "by(simp)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> s .& R s =\n  \\<guillemotleft> G \\<guillemotright> s .& S s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<guillemotleft> G \\<guillemotright> && R) s =\n  (\\<guillemotleft> G \\<guillemotright> && S) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>unitary ?R; unitary ?S;\n   \\<guillemotleft> I \\<guillemotright> && ?R =\n   \\<guillemotleft> I \\<guillemotright> && ?S\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft> G \\<guillemotright> && ?R =\n                    \\<guillemotleft> G \\<guillemotright> && ?S\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       unitary Q \\<Longrightarrow>\n       \\<guillemotleft> G \\<guillemotright> &&\n       (wp (A ;; C) Q \\<circ> \\<phi>) =\n       \\<guillemotleft> G \\<guillemotright> &&\n       wp (B ;; D) (Q \\<circ> \\<phi>)", "show \"\\<guillemotleft>G\\<guillemotright> && (wp (A;;C) Q o \\<phi>) = \\<guillemotleft>G\\<guillemotright> && wp (B;;D) (Q o \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> && (wp (A ;; C) Q \\<circ> \\<phi>) =\n    \\<guillemotleft> G \\<guillemotright> && wp (B ;; D) (Q \\<circ> \\<phi>)", "proof(simp add:wp_eval)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> && (wp A (wp C Q) \\<circ> \\<phi>) =\n    \\<guillemotleft> G \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))", "from uCQ pcAB"], ["proof (chain)\npicking this:\n  unitary (wp C Q)\n  pcorres \\<phi> G A B", "have \"\\<guillemotleft>G\\<guillemotright> && (wp A (wp C Q) \\<circ> \\<phi>) =\n                        \\<guillemotleft>G\\<guillemotright> && wp B ((wp C Q) \\<circ> \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary (wp C Q)\n  pcorres \\<phi> G A B\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> && (wp A (wp C Q) \\<circ> \\<phi>) =\n    \\<guillemotleft> G \\<guillemotright> && wp B (wp C Q \\<circ> \\<phi>)", "by(auto dest:pcorresD)"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> && (wp A (wp C Q) \\<circ> \\<phi>) =\n  \\<guillemotleft> G \\<guillemotright> && wp B (wp C Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> && (wp A (wp C Q) \\<circ> \\<phi>) =\n    \\<guillemotleft> G \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))", "also"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> && (wp A (wp C Q) \\<circ> \\<phi>) =\n  \\<guillemotleft> G \\<guillemotright> && wp B (wp C Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> && (wp A (wp C Q) \\<circ> \\<phi>) =\n    \\<guillemotleft> G \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))", "have \"\\<guillemotleft>G\\<guillemotright> && wp B ((wp C Q) \\<circ> \\<phi>) =\n               \\<guillemotleft>G\\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> && wp B (wp C Q \\<circ> \\<phi>) =\n    \\<guillemotleft> G \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))", "proof(rule p3p1)"], ["proof (state)\ngoal (3 subgoals):\n 1. unitary (wp B (wp C Q \\<circ> \\<phi>))\n 2. unitary (wp B (wp D (Q \\<circ> \\<phi>)))\n 3. \\<guillemotleft> I \\<guillemotright> && wp B (wp C Q \\<circ> \\<phi>) =\n    \\<guillemotleft> I \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))", "from uCQ well_def_wp_healthy[OF wB]"], ["proof (chain)\npicking this:\n  unitary (wp C Q)\n  healthy (wp B)", "show \"unitary (wp B (wp C Q \\<circ> \\<phi>))\""], ["proof (prove)\nusing this:\n  unitary (wp C Q)\n  healthy (wp B)\n\ngoal (1 subgoal):\n 1. unitary (wp B (wp C Q \\<circ> \\<phi>))", "by(auto intro:unitary_comp)"], ["proof (state)\nthis:\n  unitary (wp B (wp C Q \\<circ> \\<phi>))\n\ngoal (2 subgoals):\n 1. unitary (wp B (wp D (Q \\<circ> \\<phi>)))\n 2. \\<guillemotleft> I \\<guillemotright> && wp B (wp C Q \\<circ> \\<phi>) =\n    \\<guillemotleft> I \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))", "from uDQ well_def_wp_healthy[OF wB]"], ["proof (chain)\npicking this:\n  unitary (wp D (Q \\<circ> \\<phi>))\n  healthy (wp B)", "show \"unitary (wp B (wp D (Q \\<circ> \\<phi>)))\""], ["proof (prove)\nusing this:\n  unitary (wp D (Q \\<circ> \\<phi>))\n  healthy (wp B)\n\ngoal (1 subgoal):\n 1. unitary (wp B (wp D (Q \\<circ> \\<phi>)))", "by(auto)"], ["proof (state)\nthis:\n  unitary (wp B (wp D (Q \\<circ> \\<phi>)))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> I \\<guillemotright> && wp B (wp C Q \\<circ> \\<phi>) =\n    \\<guillemotleft> I \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))", "from uQ"], ["proof (chain)\npicking this:\n  unitary Q", "have \"\\<guillemotleft> H \\<guillemotright> && (wp C Q \\<circ> \\<phi>) = \\<guillemotleft> H \\<guillemotright> && wp D (Q \\<circ> \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary Q\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> H \\<guillemotright> && (wp C Q \\<circ> \\<phi>) =\n    \\<guillemotleft> H \\<guillemotright> && wp D (Q \\<circ> \\<phi>)", "by(blast intro:pcorresD[OF pcCD])"], ["proof (state)\nthis:\n  \\<guillemotleft> H \\<guillemotright> && (wp C Q \\<circ> \\<phi>) =\n  \\<guillemotleft> H \\<guillemotright> && wp D (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> I \\<guillemotright> && wp B (wp C Q \\<circ> \\<phi>) =\n    \\<guillemotleft> I \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))", "thus \"\\<guillemotleft> I \\<guillemotright> && wp B (wp C Q \\<circ> \\<phi>) = \\<guillemotleft> I \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> H \\<guillemotright> && (wp C Q \\<circ> \\<phi>) =\n  \\<guillemotleft> H \\<guillemotright> && wp D (Q \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> I \\<guillemotright> && wp B (wp C Q \\<circ> \\<phi>) =\n    \\<guillemotleft> I \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))", "by(simp add:p3p2 uCQ uDQ)"], ["proof (state)\nthis:\n  \\<guillemotleft> I \\<guillemotright> && wp B (wp C Q \\<circ> \\<phi>) =\n  \\<guillemotleft> I \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> && wp B (wp C Q \\<circ> \\<phi>) =\n  \\<guillemotleft> G \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> && (wp A (wp C Q) \\<circ> \\<phi>) =\n    \\<guillemotleft> G \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))", "finally"], ["proof (chain)\npicking this:\n  \\<guillemotleft> G \\<guillemotright> && (wp A (wp C Q) \\<circ> \\<phi>) =\n  \\<guillemotleft> G \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))", "show \"\\<guillemotleft>G\\<guillemotright> && (wp A (wp C Q) \\<circ> \\<phi>) = \\<guillemotleft>G\\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> G \\<guillemotright> && (wp A (wp C Q) \\<circ> \\<phi>) =\n  \\<guillemotleft> G \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> G \\<guillemotright> && (wp A (wp C Q) \\<circ> \\<phi>) =\n    \\<guillemotleft> G \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))", "."], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> && (wp A (wp C Q) \\<circ> \\<phi>) =\n  \\<guillemotleft> G \\<guillemotright> && wp B (wp D (Q \\<circ> \\<phi>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft> G \\<guillemotright> && (wp (A ;; C) Q \\<circ> \\<phi>) =\n  \\<guillemotleft> G \\<guillemotright> && wp (B ;; D) (Q \\<circ> \\<phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Structural Rules for Data Refinement\\<close>"], ["", "lemma dr_Skip:\n  fixes \\<phi>::\"'c \\<Rightarrow> 'b\"\n  shows \"drefines \\<phi> G Skip Skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drefines \\<phi> G Skip Skip", "proof(intro drefinesI2 wd_intros)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp Skip Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp Skip (Q \\<circ> \\<phi>) s", "fix P::\"'b \\<Rightarrow> real\" and Q::\"'b \\<Rightarrow> real\" and s::'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp Skip Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp Skip (Q \\<circ> \\<phi>) s", "assume \"P \\<tturnstile> wp Skip Q\""], ["proof (state)\nthis:\n  P \\<tturnstile> wp Skip Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp Skip Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp Skip (Q \\<circ> \\<phi>) s", "hence \"(P o \\<phi>) s \\<le> wp Skip Q (\\<phi> s)\""], ["proof (prove)\nusing this:\n  P \\<tturnstile> wp Skip Q\n\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s \\<le> wp Skip Q (\\<phi> s)", "by(simp, blast)"], ["proof (state)\nthis:\n  (P \\<circ> \\<phi>) s \\<le> wp Skip Q (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp Skip Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp Skip (Q \\<circ> \\<phi>) s", "thus \"(P o \\<phi>) s \\<le> wp Skip (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  (P \\<circ> \\<phi>) s \\<le> wp Skip Q (\\<phi> s)\n\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s \\<le> wp Skip (Q \\<circ> \\<phi>) s", "by(simp add:wp_eval)"], ["proof (state)\nthis:\n  (P \\<circ> \\<phi>) s \\<le> wp Skip (Q \\<circ> \\<phi>) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dr_Abort:\n  fixes \\<phi>::\"'c \\<Rightarrow> 'b\"\n  shows \"drefines \\<phi> G Abort Abort\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drefines \\<phi> G Abort Abort", "proof(intro drefinesI2 wd_intros)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp Abort Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp Abort (Q \\<circ> \\<phi>) s", "fix P::\"'b \\<Rightarrow> real\" and Q::\"'b \\<Rightarrow> real\" and s::'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp Abort Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp Abort (Q \\<circ> \\<phi>) s", "assume \"P \\<tturnstile> wp Abort Q\""], ["proof (state)\nthis:\n  P \\<tturnstile> wp Abort Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp Abort Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp Abort (Q \\<circ> \\<phi>) s", "hence \"(P o \\<phi>) s \\<le> wp Abort Q (\\<phi> s)\""], ["proof (prove)\nusing this:\n  P \\<tturnstile> wp Abort Q\n\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s \\<le> wp Abort Q (\\<phi> s)", "by(auto)"], ["proof (state)\nthis:\n  (P \\<circ> \\<phi>) s \\<le> wp Abort Q (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp Abort Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp Abort (Q \\<circ> \\<phi>) s", "thus \"(P o \\<phi>) s \\<le> wp Abort (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  (P \\<circ> \\<phi>) s \\<le> wp Abort Q (\\<phi> s)\n\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s \\<le> wp Abort (Q \\<circ> \\<phi>) s", "by(simp add:wp_eval)"], ["proof (state)\nthis:\n  (P \\<circ> \\<phi>) s \\<le> wp Abort (Q \\<circ> \\<phi>) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dr_Apply:\n  fixes \\<phi>::\"'c \\<Rightarrow> 'b\"\n  assumes commutes: \"f o \\<phi> = \\<phi> o g\"\n  shows \"drefines \\<phi> G (Apply f) (Apply g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drefines \\<phi> G (Apply f) (Apply g)", "proof(intro drefinesI2 wd_intros)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp (Apply f) Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s", "fix P::\"'b \\<Rightarrow> real\" and Q::\"'b \\<Rightarrow> real\" and s::'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp (Apply f) Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s", "assume wp: \"P \\<tturnstile> wp (Apply f) Q\""], ["proof (state)\nthis:\n  P \\<tturnstile> wp (Apply f) Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp (Apply f) Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s", "hence \"P \\<tturnstile> (Q o f)\""], ["proof (prove)\nusing this:\n  P \\<tturnstile> wp (Apply f) Q\n\ngoal (1 subgoal):\n 1. P \\<tturnstile> Q \\<circ> f", "by(simp add:wp_eval)"], ["proof (state)\nthis:\n  P \\<tturnstile> Q \\<circ> f\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp (Apply f) Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s", "hence \"P (\\<phi> s) \\<le> (Q o f) (\\<phi> s)\""], ["proof (prove)\nusing this:\n  P \\<tturnstile> Q \\<circ> f\n\ngoal (1 subgoal):\n 1. P (\\<phi> s) \\<le> (Q \\<circ> f) (\\<phi> s)", "by(blast)"], ["proof (state)\nthis:\n  P (\\<phi> s) \\<le> (Q \\<circ> f) (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp (Apply f) Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s", "also"], ["proof (state)\nthis:\n  P (\\<phi> s) \\<le> (Q \\<circ> f) (\\<phi> s)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp (Apply f) Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s", "have \"... = Q ((f o \\<phi>) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q \\<circ> f) (\\<phi> s) = Q ((f \\<circ> \\<phi>) s)", "by(simp)"], ["proof (state)\nthis:\n  (Q \\<circ> f) (\\<phi> s) = Q ((f \\<circ> \\<phi>) s)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp (Apply f) Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s", "also"], ["proof (state)\nthis:\n  (Q \\<circ> f) (\\<phi> s) = Q ((f \\<circ> \\<phi>) s)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp (Apply f) Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s", "with commutes"], ["proof (chain)\npicking this:\n  f \\<circ> \\<phi> = \\<phi> \\<circ> g\n  (Q \\<circ> f) (\\<phi> s) = Q ((f \\<circ> \\<phi>) s)", "have \"... = ((Q o \\<phi>) o g) s\""], ["proof (prove)\nusing this:\n  f \\<circ> \\<phi> = \\<phi> \\<circ> g\n  (Q \\<circ> f) (\\<phi> s) = Q ((f \\<circ> \\<phi>) s)\n\ngoal (1 subgoal):\n 1. Q ((f \\<circ> \\<phi>) s) = (Q \\<circ> \\<phi> \\<circ> g) s", "by(simp)"], ["proof (state)\nthis:\n  Q ((f \\<circ> \\<phi>) s) = (Q \\<circ> \\<phi> \\<circ> g) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp (Apply f) Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s", "also"], ["proof (state)\nthis:\n  Q ((f \\<circ> \\<phi>) s) = (Q \\<circ> \\<phi> \\<circ> g) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp (Apply f) Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s", "have \"... = wp (Apply g) (Q o \\<phi>) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q \\<circ> \\<phi> \\<circ> g) s = wp (Apply g) (Q \\<circ> \\<phi>) s", "by(simp add:wp_eval)"], ["proof (state)\nthis:\n  (Q \\<circ> \\<phi> \\<circ> g) s = wp (Apply g) (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>unitary P; unitary Q; G s;\n        P \\<tturnstile> wp (Apply f) Q\\<rbrakk>\n       \\<Longrightarrow> (P \\<circ> \\<phi>) s\n                         \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s", "finally"], ["proof (chain)\npicking this:\n  P (\\<phi> s) \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s", "show \"(P o \\<phi>) s \\<le> wp (Apply g) (Q o \\<phi>) s\""], ["proof (prove)\nusing this:\n  P (\\<phi> s) \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s\n\ngoal (1 subgoal):\n 1. (P \\<circ> \\<phi>) s \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s", "by(simp)"], ["proof (state)\nthis:\n  (P \\<circ> \\<phi>) s \\<le> wp (Apply g) (Q \\<circ> \\<phi>) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dr_Seq:\n  assumes drAB: \"drefines \\<phi> P A B\"\n      and drBC: \"drefines \\<phi> Q C D\"\n      and wpB:  \"\\<guillemotleft>P\\<guillemotright> \\<tturnstile> wp B \\<guillemotleft>Q\\<guillemotright>\"\n      and wB:   \"well_def B\"\n      and wC:   \"well_def C\"\n      and wD:   \"well_def D\"\n  shows \"drefines \\<phi> P (A;;C) (B;;D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drefines \\<phi> P (A ;; C) (B ;; D)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pa Q.\n       \\<lbrakk>unitary Pa; unitary Q;\n        Pa \\<tturnstile> wp (A ;; C) Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> &&\n                         (Pa \\<circ>\n                          \\<phi>) \\<tturnstile> wp (B ;; D)\n           (Q \\<circ> \\<phi>)", "fix R and S"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pa Q.\n       \\<lbrakk>unitary Pa; unitary Q;\n        Pa \\<tturnstile> wp (A ;; C) Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> &&\n                         (Pa \\<circ>\n                          \\<phi>) \\<tturnstile> wp (B ;; D)\n           (Q \\<circ> \\<phi>)", "assume uR: \"unitary R\" and uS: \"unitary S\"\n     and wpAC: \"R \\<tturnstile> wp (A;;C) S\""], ["proof (state)\nthis:\n  unitary R\n  unitary S\n  R \\<tturnstile> wp (A ;; C) S\n\ngoal (1 subgoal):\n 1. \\<And>Pa Q.\n       \\<lbrakk>unitary Pa; unitary Q;\n        Pa \\<tturnstile> wp (A ;; C) Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> &&\n                         (Pa \\<circ>\n                          \\<phi>) \\<tturnstile> wp (B ;; D)\n           (Q \\<circ> \\<phi>)", "from uR"], ["proof (chain)\npicking this:\n  unitary R", "have \"\\<guillemotleft>P\\<guillemotright> && (R o \\<phi>) = \\<guillemotleft>P\\<guillemotright> && (\\<guillemotleft>P\\<guillemotright> && (R o \\<phi>))\""], ["proof (prove)\nusing this:\n  unitary R\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> && (R \\<circ> \\<phi>) =\n    \\<guillemotleft> P \\<guillemotright> &&\n    (\\<guillemotleft> P \\<guillemotright> && (R \\<circ> \\<phi>))", "by(simp add:exp_conj_assoc)"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> && (R \\<circ> \\<phi>) =\n  \\<guillemotleft> P \\<guillemotright> &&\n  (\\<guillemotleft> P \\<guillemotright> && (R \\<circ> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<And>Pa Q.\n       \\<lbrakk>unitary Pa; unitary Q;\n        Pa \\<tturnstile> wp (A ;; C) Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> &&\n                         (Pa \\<circ>\n                          \\<phi>) \\<tturnstile> wp (B ;; D)\n           (Q \\<circ> \\<phi>)", "also"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> && (R \\<circ> \\<phi>) =\n  \\<guillemotleft> P \\<guillemotright> &&\n  (\\<guillemotleft> P \\<guillemotright> && (R \\<circ> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<And>Pa Q.\n       \\<lbrakk>unitary Pa; unitary Q;\n        Pa \\<tturnstile> wp (A ;; C) Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> &&\n                         (Pa \\<circ>\n                          \\<phi>) \\<tturnstile> wp (B ;; D)\n           (Q \\<circ> \\<phi>)", "{"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> && (R \\<circ> \\<phi>) =\n  \\<guillemotleft> P \\<guillemotright> &&\n  (\\<guillemotleft> P \\<guillemotright> && (R \\<circ> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<And>Pa Q.\n       \\<lbrakk>unitary Pa; unitary Q;\n        Pa \\<tturnstile> wp (A ;; C) Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> &&\n                         (Pa \\<circ>\n                          \\<phi>) \\<tturnstile> wp (B ;; D)\n           (Q \\<circ> \\<phi>)", "from well_def_wp_healthy[OF wC] uR uS\n     and wpAC[unfolded eval_wp_Seq o_def]"], ["proof (chain)\npicking this:\n  healthy (wp C)\n  unitary R\n  unitary S\n  R \\<tturnstile> wp A (wp C S)", "have \"\\<guillemotleft>P\\<guillemotright> && (R o \\<phi>) \\<tturnstile> wp B (wp C S o \\<phi>)\""], ["proof (prove)\nusing this:\n  healthy (wp C)\n  unitary R\n  unitary S\n  R \\<tturnstile> wp A (wp C S)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> &&\n    (R \\<circ> \\<phi>) \\<tturnstile> wp B (wp C S \\<circ> \\<phi>)", "by(auto intro:drefinesD[OF drAB])"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> &&\n  (R \\<circ> \\<phi>) \\<tturnstile> wp B (wp C S \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>Pa Q.\n       \\<lbrakk>unitary Pa; unitary Q;\n        Pa \\<tturnstile> wp (A ;; C) Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> &&\n                         (Pa \\<circ>\n                          \\<phi>) \\<tturnstile> wp (B ;; D)\n           (Q \\<circ> \\<phi>)", "with wpB well_def_wp_healthy[OF wC] uS\n         sublinear_sub_conj[OF well_def_wp_sublinear, OF wB]"], ["proof (chain)\npicking this:\n  \\<guillemotleft> P \\<guillemotright> \\<tturnstile> wp B\n                \\<guillemotleft> Q \\<guillemotright>\n  healthy (wp C)\n  unitary S\n  sub_conj (wp B)\n  \\<guillemotleft> P \\<guillemotright> &&\n  (R \\<circ> \\<phi>) \\<tturnstile> wp B (wp C S \\<circ> \\<phi>)", "have \"\\<guillemotleft>P\\<guillemotright> && (\\<guillemotleft>P\\<guillemotright> && (R o \\<phi>)) \\<tturnstile> wp B (\\<guillemotleft>Q\\<guillemotright> && (wp C S o \\<phi>))\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> P \\<guillemotright> \\<tturnstile> wp B\n                \\<guillemotleft> Q \\<guillemotright>\n  healthy (wp C)\n  unitary S\n  sub_conj (wp B)\n  \\<guillemotleft> P \\<guillemotright> &&\n  (R \\<circ> \\<phi>) \\<tturnstile> wp B (wp C S \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> &&\n    (\\<guillemotleft> P \\<guillemotright> &&\n     (R \\<circ>\n      \\<phi>)) \\<tturnstile> wp B\n                              (\\<guillemotleft> Q \\<guillemotright> &&\n                               (wp C S \\<circ> \\<phi>))", "by(auto intro!:entails_combine dest!:unitary_sound)"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> &&\n  (\\<guillemotleft> P \\<guillemotright> &&\n   (R \\<circ>\n    \\<phi>)) \\<tturnstile> wp B\n                            (\\<guillemotleft> Q \\<guillemotright> &&\n                             (wp C S \\<circ> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<And>Pa Q.\n       \\<lbrakk>unitary Pa; unitary Q;\n        Pa \\<tturnstile> wp (A ;; C) Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> &&\n                         (Pa \\<circ>\n                          \\<phi>) \\<tturnstile> wp (B ;; D)\n           (Q \\<circ> \\<phi>)", "}"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> &&\n  (\\<guillemotleft> P \\<guillemotright> &&\n   (R \\<circ>\n    \\<phi>)) \\<tturnstile> wp B\n                            (\\<guillemotleft> Q \\<guillemotright> &&\n                             (wp C S \\<circ> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<And>Pa Q.\n       \\<lbrakk>unitary Pa; unitary Q;\n        Pa \\<tturnstile> wp (A ;; C) Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> &&\n                         (Pa \\<circ>\n                          \\<phi>) \\<tturnstile> wp (B ;; D)\n           (Q \\<circ> \\<phi>)", "also"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> &&\n  (\\<guillemotleft> P \\<guillemotright> &&\n   (R \\<circ>\n    \\<phi>)) \\<tturnstile> wp B\n                            (\\<guillemotleft> Q \\<guillemotright> &&\n                             (wp C S \\<circ> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<And>Pa Q.\n       \\<lbrakk>unitary Pa; unitary Q;\n        Pa \\<tturnstile> wp (A ;; C) Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> &&\n                         (Pa \\<circ>\n                          \\<phi>) \\<tturnstile> wp (B ;; D)\n           (Q \\<circ> \\<phi>)", "{"], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> &&\n  (\\<guillemotleft> P \\<guillemotright> &&\n   (R \\<circ>\n    \\<phi>)) \\<tturnstile> wp B\n                            (\\<guillemotleft> Q \\<guillemotright> &&\n                             (wp C S \\<circ> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<And>Pa Q.\n       \\<lbrakk>unitary Pa; unitary Q;\n        Pa \\<tturnstile> wp (A ;; C) Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> &&\n                         (Pa \\<circ>\n                          \\<phi>) \\<tturnstile> wp (B ;; D)\n           (Q \\<circ> \\<phi>)", "from uS well_def_wp_healthy[OF wC]"], ["proof (chain)\npicking this:\n  unitary S\n  healthy (wp C)", "have \"\\<guillemotleft>Q\\<guillemotright> && (wp C S o \\<phi>) \\<tturnstile> wp D (S o \\<phi>)\""], ["proof (prove)\nusing this:\n  unitary S\n  healthy (wp C)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> Q \\<guillemotright> &&\n    (wp C S \\<circ> \\<phi>) \\<tturnstile> wp D (S \\<circ> \\<phi>)", "by(auto intro!:drefinesD[OF drBC])"], ["proof (state)\nthis:\n  \\<guillemotleft> Q \\<guillemotright> &&\n  (wp C S \\<circ> \\<phi>) \\<tturnstile> wp D (S \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>Pa Q.\n       \\<lbrakk>unitary Pa; unitary Q;\n        Pa \\<tturnstile> wp (A ;; C) Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> &&\n                         (Pa \\<circ>\n                          \\<phi>) \\<tturnstile> wp (B ;; D)\n           (Q \\<circ> \\<phi>)", "with well_def_wp_healthy[OF wB] well_def_wp_healthy[OF wC]\n         well_def_wp_healthy[OF wD] and unitary_sound[OF uS]"], ["proof (chain)\npicking this:\n  healthy (wp B)\n  healthy (wp C)\n  healthy (wp D)\n  sound S\n  \\<guillemotleft> Q \\<guillemotright> &&\n  (wp C S \\<circ> \\<phi>) \\<tturnstile> wp D (S \\<circ> \\<phi>)", "have \"wp B (\\<guillemotleft>Q\\<guillemotright> && (wp C S o \\<phi>)) \\<tturnstile> wp B (wp D (S o \\<phi>))\""], ["proof (prove)\nusing this:\n  healthy (wp B)\n  healthy (wp C)\n  healthy (wp D)\n  sound S\n  \\<guillemotleft> Q \\<guillemotright> &&\n  (wp C S \\<circ> \\<phi>) \\<tturnstile> wp D (S \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. wp B\n     (\\<guillemotleft> Q \\<guillemotright> &&\n      (wp C S \\<circ> \\<phi>)) \\<tturnstile> wp B (wp D (S \\<circ> \\<phi>))", "by(blast intro!:mono_transD)"], ["proof (state)\nthis:\n  wp B\n   (\\<guillemotleft> Q \\<guillemotright> &&\n    (wp C S \\<circ> \\<phi>)) \\<tturnstile> wp B (wp D (S \\<circ> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<And>Pa Q.\n       \\<lbrakk>unitary Pa; unitary Q;\n        Pa \\<tturnstile> wp (A ;; C) Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> &&\n                         (Pa \\<circ>\n                          \\<phi>) \\<tturnstile> wp (B ;; D)\n           (Q \\<circ> \\<phi>)", "}"], ["proof (state)\nthis:\n  wp B\n   (\\<guillemotleft> Q \\<guillemotright> &&\n    (wp C S \\<circ> \\<phi>)) \\<tturnstile> wp B (wp D (S \\<circ> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<And>Pa Q.\n       \\<lbrakk>unitary Pa; unitary Q;\n        Pa \\<tturnstile> wp (A ;; C) Q\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft> P \\<guillemotright> &&\n                         (Pa \\<circ>\n                          \\<phi>) \\<tturnstile> wp (B ;; D)\n           (Q \\<circ> \\<phi>)", "finally"], ["proof (chain)\npicking this:\n  \\<guillemotleft> P \\<guillemotright> &&\n  (R \\<circ> \\<phi>) \\<tturnstile> wp B (wp D (S \\<circ> \\<phi>))", "show \"\\<guillemotleft>P\\<guillemotright> && (R o \\<phi>) \\<tturnstile> wp (B;;D) (S o \\<phi>)\""], ["proof (prove)\nusing this:\n  \\<guillemotleft> P \\<guillemotright> &&\n  (R \\<circ> \\<phi>) \\<tturnstile> wp B (wp D (S \\<circ> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> &&\n    (R \\<circ> \\<phi>) \\<tturnstile> wp (B ;; D) (S \\<circ> \\<phi>)", "unfolding wp_eval o_def"], ["proof (prove)\nusing this:\n  \\<guillemotleft> P \\<guillemotright> &&\n  (\\<lambda>x.\n      R (\\<phi> x)) \\<tturnstile> wp B (wp D (\\<lambda>x. S (\\<phi> x)))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> P \\<guillemotright> &&\n    (\\<lambda>x.\n        R (\\<phi> x)) \\<tturnstile> wp B (wp D (\\<lambda>x. S (\\<phi> x)))", "."], ["proof (state)\nthis:\n  \\<guillemotleft> P \\<guillemotright> &&\n  (R \\<circ> \\<phi>) \\<tturnstile> wp (B ;; D) (S \\<circ> \\<phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dr_repeat:\n  fixes \\<phi> :: \"'a \\<Rightarrow> 'b\"\n  assumes dr_ab: \"drefines \\<phi> G a b\"\n      and Gpr:  \"\\<guillemotleft>G\\<guillemotright> \\<tturnstile> wp b \\<guillemotleft>G\\<guillemotright>\"\n      and wa:    \"well_def a\"\n      and wb:    \"well_def b\"\n  shows \"drefines \\<phi> G (repeat n a) (repeat n b)\" (is \"?X n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. drefines \\<phi> G (repeat n a) (repeat n b)", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. drefines \\<phi> G (repeat 0 a) (repeat 0 b)\n 2. \\<And>n.\n       drefines \\<phi> G (repeat n a) (repeat n b) \\<Longrightarrow>\n       drefines \\<phi> G (repeat (Suc n) a) (repeat (Suc n) b)", "show \"?X 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drefines \\<phi> G (repeat 0 a) (repeat 0 b)", "by(simp add:dr_Skip)"], ["proof (state)\nthis:\n  drefines \\<phi> G (repeat 0 a) (repeat 0 b)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       drefines \\<phi> G (repeat n a) (repeat n b) \\<Longrightarrow>\n       drefines \\<phi> G (repeat (Suc n) a) (repeat (Suc n) b)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       drefines \\<phi> G (repeat n a) (repeat n b) \\<Longrightarrow>\n       drefines \\<phi> G (repeat (Suc n) a) (repeat (Suc n) b)", "assume IH: \"?X n\""], ["proof (state)\nthis:\n  drefines \\<phi> G (repeat n a) (repeat n b)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       drefines \\<phi> G (repeat n a) (repeat n b) \\<Longrightarrow>\n       drefines \\<phi> G (repeat (Suc n) a) (repeat (Suc n) b)", "thus \"?X (Suc n)\""], ["proof (prove)\nusing this:\n  drefines \\<phi> G (repeat n a) (repeat n b)\n\ngoal (1 subgoal):\n 1. drefines \\<phi> G (repeat (Suc n) a) (repeat (Suc n) b)", "by(auto intro!:dr_Seq Gpr assms wd_intros)"], ["proof (state)\nthis:\n  drefines \\<phi> G (repeat (Suc n) a) (repeat (Suc n) b)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}