{"file_name": "/home/qj213/afp-2021-10-22/thys/pGCL/Tutorial/LoopExamples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/pGCL", "problem_names": ["lemma wp_inv_count:\n  \"wp_inv (\\<lambda>x. 0 < x) (Apply (\\<lambda>s. s - 1)) \\<guillemotleft>inv_count\\<guillemotright>\"", "lemma term_countdown:\n  \"\\<guillemotleft>inv_count\\<guillemotright> \\<tturnstile> wp countdown (\\<lambda>s. 1)\"", "lemma wait_for_heads_term:\n  \"\\<lambda>s. 1 \\<tturnstile> wp wait_for_heads (\\<lambda>s. 1)\""], "translations": [["", "lemma wp_inv_count:\n  \"wp_inv (\\<lambda>x. 0 < x) (Apply (\\<lambda>s. s - 1)) \\<guillemotleft>inv_count\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp_inv ((<) 0) (Apply (\\<lambda>s. s - 1))\n     \\<guillemotleft> inv_count \\<guillemotright>", "unfolding wp_inv_def inv_count_def wp_eval o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       \\<guillemotleft> (<) 0 \\<guillemotright> s *\n       \\<guillemotleft> (\\<le>) 0 \\<guillemotright> s\n       \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (s - 1)", "proof(clarify, cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       ?P1 s \\<Longrightarrow>\n       \\<guillemotleft> (<) 0 \\<guillemotright> s *\n       \\<guillemotleft> (\\<le>) 0 \\<guillemotright> s\n       \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (s - 1)\n 2. \\<And>s.\n       \\<not> ?P1 s \\<Longrightarrow>\n       \\<guillemotleft> (<) 0 \\<guillemotright> s *\n       \\<guillemotleft> (\\<le>) 0 \\<guillemotright> s\n       \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (s - 1)", "fix x::int"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       ?P1 s \\<Longrightarrow>\n       \\<guillemotleft> (<) 0 \\<guillemotright> s *\n       \\<guillemotleft> (\\<le>) 0 \\<guillemotright> s\n       \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (s - 1)\n 2. \\<And>s.\n       \\<not> ?P1 s \\<Longrightarrow>\n       \\<guillemotleft> (<) 0 \\<guillemotright> s *\n       \\<guillemotleft> (\\<le>) 0 \\<guillemotright> s\n       \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (s - 1)", "assume \"0 \\<le> x\""], ["proof (state)\nthis:\n  0 \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       ?P1 s \\<Longrightarrow>\n       \\<guillemotleft> (<) 0 \\<guillemotright> s *\n       \\<guillemotleft> (\\<le>) 0 \\<guillemotright> s\n       \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (s - 1)\n 2. \\<And>s.\n       \\<not> ?P1 s \\<Longrightarrow>\n       \\<guillemotleft> (<) 0 \\<guillemotright> s *\n       \\<guillemotleft> (\\<le>) 0 \\<guillemotright> s\n       \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (s - 1)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> x", "show \"\\<guillemotleft>\\<lambda>x. 0 < x\\<guillemotright> x * \\<guillemotleft>\\<lambda>x. 0 \\<le> x\\<guillemotright> x \\<le> \\<guillemotleft>\\<lambda>x. 0 \\<le> x\\<guillemotright> (x - 1)\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> (<) 0 \\<guillemotright> x *\n    \\<guillemotleft> (\\<le>) 0 \\<guillemotright> x\n    \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (x - 1)", "by(simp add:embed_bool_def)"], ["proof (state)\nthis:\n  \\<guillemotleft> (<) 0 \\<guillemotright> x *\n  \\<guillemotleft> (\\<le>) 0 \\<guillemotright> x\n  \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (x - 1)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<not> 0 \\<le> s \\<Longrightarrow>\n       \\<guillemotleft> (<) 0 \\<guillemotright> s *\n       \\<guillemotleft> (\\<le>) 0 \\<guillemotright> s\n       \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (s - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<not> 0 \\<le> s \\<Longrightarrow>\n       \\<guillemotleft> (<) 0 \\<guillemotright> s *\n       \\<guillemotleft> (\\<le>) 0 \\<guillemotright> s\n       \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (s - 1)", "fix x::int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<not> 0 \\<le> s \\<Longrightarrow>\n       \\<guillemotleft> (<) 0 \\<guillemotright> s *\n       \\<guillemotleft> (\\<le>) 0 \\<guillemotright> s\n       \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (s - 1)", "assume \"\\<not> 0 \\<le> x\""], ["proof (state)\nthis:\n  \\<not> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<not> 0 \\<le> s \\<Longrightarrow>\n       \\<guillemotleft> (<) 0 \\<guillemotright> s *\n       \\<guillemotleft> (\\<le>) 0 \\<guillemotright> s\n       \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (s - 1)", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> x", "show \"\\<guillemotleft>\\<lambda>x. 0 < x\\<guillemotright> x * \\<guillemotleft>\\<lambda>x. 0 \\<le> x\\<guillemotright> x \\<le> \\<guillemotleft>\\<lambda>x. 0 \\<le> x\\<guillemotright> (x - 1)\""], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<guillemotleft> (<) 0 \\<guillemotright> x *\n    \\<guillemotleft> (\\<le>) 0 \\<guillemotright> x\n    \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (x - 1)", "by(simp add:embed_bool_def)"], ["proof (state)\nthis:\n  \\<guillemotleft> (<) 0 \\<guillemotright> x *\n  \\<guillemotleft> (\\<le>) 0 \\<guillemotright> x\n  \\<le> \\<guillemotleft> (\\<le>) 0 \\<guillemotright> (x - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This example is contrived to give us an obvious variant, or measure function: the counter\nitself.\\<close>"], ["", "lemma term_countdown:\n  \"\\<guillemotleft>inv_count\\<guillemotright> \\<tturnstile> wp countdown (\\<lambda>s. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> inv_count \\<guillemotright> \\<tturnstile> wp countdown\n                          (\\<lambda>s. 1)", "unfolding countdown_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> inv_count \\<guillemotright> \\<tturnstile> wp\n                          (\\<mu>x.\n                              Apply (\\<lambda>s. s - 1) ;;\n                              x \\<^bsub>\\<guillemotleft> (<)\n                    0 \\<guillemotright>\\<^esub>\\<oplus> Skip)\n                          (\\<lambda>s. 1)", "proof(intro loop_term_nat_measure[where m=\"\\<lambda>x. nat (max x 0)\"] wp_inv_count)"], ["proof (state)\ngoal (3 subgoals):\n 1. well_def (Apply (\\<lambda>s. s - 1))\n 2. \\<And>s. nat (max s 0) = 0 \\<longrightarrow> \\<not> 0 < s\n 3. \\<And>n.\n       \\<guillemotleft> \\<lambda>s.\n                           nat (max s 0) = Suc n \\<guillemotright> &&\n       \\<guillemotleft> inv_count \\<guillemotright> \\<tturnstile> wp\n                             (Apply (\\<lambda>s. s - 1))\n                             \\<guillemotleft> \\<lambda>s.\n           nat (max s 0) = n \\<guillemotright>", "let ?p = \"Apply (\\<lambda>x. x - 1::int)\""], ["proof (state)\ngoal (3 subgoals):\n 1. well_def (Apply (\\<lambda>s. s - 1))\n 2. \\<And>s. nat (max s 0) = 0 \\<longrightarrow> \\<not> 0 < s\n 3. \\<And>n.\n       \\<guillemotleft> \\<lambda>s.\n                           nat (max s 0) = Suc n \\<guillemotright> &&\n       \\<guillemotleft> inv_count \\<guillemotright> \\<tturnstile> wp\n                             (Apply (\\<lambda>s. s - 1))\n                             \\<guillemotleft> \\<lambda>s.\n           nat (max s 0) = n \\<guillemotright>", "txt \\<open>As usual, well-definedness is trivial.\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. well_def (Apply (\\<lambda>s. s - 1))\n 2. \\<And>s. nat (max s 0) = 0 \\<longrightarrow> \\<not> 0 < s\n 3. \\<And>n.\n       \\<guillemotleft> \\<lambda>s.\n                           nat (max s 0) = Suc n \\<guillemotright> &&\n       \\<guillemotleft> inv_count \\<guillemotright> \\<tturnstile> wp\n                             (Apply (\\<lambda>s. s - 1))\n                             \\<guillemotleft> \\<lambda>s.\n           nat (max s 0) = n \\<guillemotright>", "show \"well_def ?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def (Apply (\\<lambda>x. x - 1))", "by(rule wd_intros)"], ["proof (state)\nthis:\n  well_def (Apply (\\<lambda>x. x - 1))\n\ngoal (2 subgoals):\n 1. \\<And>s. nat (max s 0) = 0 \\<longrightarrow> \\<not> 0 < s\n 2. \\<And>n.\n       \\<guillemotleft> \\<lambda>s.\n                           nat (max s 0) = Suc n \\<guillemotright> &&\n       \\<guillemotleft> inv_count \\<guillemotright> \\<tturnstile> wp\n                             (Apply (\\<lambda>s. s - 1))\n                             \\<guillemotleft> \\<lambda>s.\n           nat (max s 0) = n \\<guillemotright>", "txt \\<open>A measure of 0 imples termination.\\<close>"], ["proof (state)\nthis:\n  well_def (Apply (\\<lambda>x. x - 1))\n\ngoal (2 subgoals):\n 1. \\<And>s. nat (max s 0) = 0 \\<longrightarrow> \\<not> 0 < s\n 2. \\<And>n.\n       \\<guillemotleft> \\<lambda>s.\n                           nat (max s 0) = Suc n \\<guillemotright> &&\n       \\<guillemotleft> inv_count \\<guillemotright> \\<tturnstile> wp\n                             (Apply (\\<lambda>s. s - 1))\n                             \\<guillemotleft> \\<lambda>s.\n           nat (max s 0) = n \\<guillemotright>", "show \"\\<And>x. nat (max x 0) = 0 \\<longrightarrow> \\<not> 0 < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. nat (max x 0) = 0 \\<longrightarrow> \\<not> 0 < x", "by(auto)"], ["proof (state)\nthis:\n  nat (max ?x 0) = 0 \\<longrightarrow> \\<not> 0 < ?x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<guillemotleft> \\<lambda>s.\n                           nat (max s 0) = Suc n \\<guillemotright> &&\n       \\<guillemotleft> inv_count \\<guillemotright> \\<tturnstile> wp\n                             (Apply (\\<lambda>s. s - 1))\n                             \\<guillemotleft> \\<lambda>s.\n           nat (max s 0) = n \\<guillemotright>", "txt \\<open>This is the meat of the proof: that the measure must decrease,\n    whenever the invariant holds.  Note that the invariant is essential\n    here, as if @{term \"x \\<le> 0\"}, the measure will \\emph{not} decrease.\n\n    This is the kind of proof that the VCG is good at.  It leaves a purely\n    logical goal, which we can solve with auto.\\<close>"], ["proof (state)\nthis:\n  nat (max ?x 0) = 0 \\<longrightarrow> \\<not> 0 < ?x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<guillemotleft> \\<lambda>s.\n                           nat (max s 0) = Suc n \\<guillemotright> &&\n       \\<guillemotleft> inv_count \\<guillemotright> \\<tturnstile> wp\n                             (Apply (\\<lambda>s. s - 1))\n                             \\<guillemotleft> \\<lambda>s.\n           nat (max s 0) = n \\<guillemotright>", "show \"\\<And>n. \\<guillemotleft>\\<lambda>x. nat (max x 0) = Suc n\\<guillemotright> && \\<guillemotleft>inv_count\\<guillemotright> \\<tturnstile>\n         wp ?p \\<guillemotleft>\\<lambda>x. nat (max x 0) = n\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<guillemotleft> \\<lambda>x.\n                           nat (max x 0) = Suc n \\<guillemotright> &&\n       \\<guillemotleft> inv_count \\<guillemotright> \\<tturnstile> wp\n                             (Apply (\\<lambda>x. x - 1))\n                             \\<guillemotleft> \\<lambda>x.\n           nat (max x 0) = n \\<guillemotright>", "unfolding inv_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<guillemotleft> \\<lambda>x.\n                           nat (max x 0) = Suc n \\<guillemotright> &&\n       \\<guillemotleft> (\\<le>)\n                         0 \\<guillemotright> \\<tturnstile> wp\n                      (Apply (\\<lambda>x. x - 1))\n                      \\<guillemotleft> \\<lambda>x.\n    nat (max x 0) = n \\<guillemotright>", "by(pvcg,\n       auto simp:  o_def exp_conj_std_split[symmetric]\n            intro: implies_entails)"], ["proof (state)\nthis:\n  \\<guillemotleft> \\<lambda>x. nat (max x 0) = Suc ?n \\<guillemotright> &&\n  \\<guillemotleft> inv_count \\<guillemotright> \\<tturnstile> wp\n                        (Apply (\\<lambda>x. x - 1))\n                        \\<guillemotleft> \\<lambda>x.\n      nat (max x 0) = ?n \\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Probabilistic Termination\\<close>"], ["", "text \\<open>Loops need not terminate deterministically: it is sufficient to terminate with probability\n1. Here we show the intuitively obvious result that by flipping a coin repeatedly, you will\neventually see heads.\\<close>"], ["", "type_synonym coin = bool"], ["", "definition \"Heads = True\""], ["", "definition \"Tails = False\""], ["", "definition\n  flip :: \"coin prog\"\nwhere\n  \"flip = Apply (\\<lambda>_. Heads) \\<^bsub>(\\<lambda>s. 1/2)\\<^esub>\\<oplus> Apply (\\<lambda>_. Tails)\""], ["", "text \\<open>We can't define a measure here, as we did previously, as neither of the\n  two possible states guarantee termination.\\<close>"], ["", "definition\n  wait_for_heads :: \"coin prog\"\nwhere\n  \"wait_for_heads = do ((\\<noteq>) Heads) \\<longrightarrow> flip od\""], ["", "text \\<open>Nonetheless, we can show termination .\\<close>"], ["", "lemma wait_for_heads_term:\n  \"\\<lambda>s. 1 \\<tturnstile> wp wait_for_heads (\\<lambda>s. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s. 1 \\<tturnstile> wp wait_for_heads (\\<lambda>s. 1)", "unfolding wait_for_heads_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       1 \\<tturnstile> wp (\\<mu>x.\n                              LoopExamples.flip ;;\n                              x \\<^bsub>\\<guillemotleft> (\\<noteq>)\n                    Heads \\<guillemotright>\\<^esub>\\<oplus> Skip)\n                        (\\<lambda>s. 1)", "txt \\<open>We use one of the zero-one laws for termination, specifically that\n    if, from every state there is a nonzero probability of satisfying the\n    guard (and thus terminating) in a single step, then the loop terminates\n    from \\emph{any} state, with probability 1.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       1 \\<tturnstile> wp (\\<mu>x.\n                              LoopExamples.flip ;;\n                              x \\<^bsub>\\<guillemotleft> (\\<noteq>)\n                    Heads \\<guillemotright>\\<^esub>\\<oplus> Skip)\n                        (\\<lambda>s. 1)", "proof(rule termination_0_1)"], ["proof (state)\ngoal (4 subgoals):\n 1. well_def LoopExamples.flip\n 2. \\<lambda>s.\n       ?p \\<tturnstile> wp LoopExamples.flip\n                         \\<guillemotleft> \\<N>\n     ((\\<noteq>) Heads) \\<guillemotright>\n 3. 0 < ?p\n 4. maximal (wp LoopExamples.flip)", "show \"well_def flip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def LoopExamples.flip", "unfolding flip_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def\n     (Apply\n       (\\<lambda>_.\n           Heads) \\<^bsub>(\\<lambda>s.\n                              1 /\n                              2)\\<^esub>\\<oplus> Apply (\\<lambda>_. Tails))", "by(auto intro:wd_intros)"], ["proof (state)\nthis:\n  well_def LoopExamples.flip\n\ngoal (3 subgoals):\n 1. \\<lambda>s.\n       ?p \\<tturnstile> wp LoopExamples.flip\n                         \\<guillemotleft> \\<N>\n     ((\\<noteq>) Heads) \\<guillemotright>\n 2. 0 < ?p\n 3. maximal (wp LoopExamples.flip)", "txt \\<open>We must show that the loop body is deterministic, meaning that\n    it cannot diverge by itself.\\<close>"], ["proof (state)\nthis:\n  well_def LoopExamples.flip\n\ngoal (3 subgoals):\n 1. \\<lambda>s.\n       ?p \\<tturnstile> wp LoopExamples.flip\n                         \\<guillemotleft> \\<N>\n     ((\\<noteq>) Heads) \\<guillemotright>\n 2. 0 < ?p\n 3. maximal (wp LoopExamples.flip)", "show \"maximal (wp flip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal (wp LoopExamples.flip)", "unfolding flip_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal\n     (wp (Apply\n           (\\<lambda>_.\n               Heads) \\<^bsub>(\\<lambda>s.\n                                  1 /\n                                  2)\\<^esub>\\<oplus> Apply\n                (\\<lambda>_. Tails)))", "by(auto intro:max_intros)"], ["proof (state)\nthis:\n  maximal (wp LoopExamples.flip)\n\ngoal (2 subgoals):\n 1. \\<lambda>s.\n       ?p \\<tturnstile> wp LoopExamples.flip\n                         \\<guillemotleft> \\<N>\n     ((\\<noteq>) Heads) \\<guillemotright>\n 2. 0 < ?p", "txt \\<open>The verification condition for the loop body is one-step-termination,\n    here shown to hold with probability 1/2.  As usual, this result falls to\n    the VCG.\\<close>"], ["proof (state)\nthis:\n  maximal (wp LoopExamples.flip)\n\ngoal (2 subgoals):\n 1. \\<lambda>s.\n       ?p \\<tturnstile> wp LoopExamples.flip\n                         \\<guillemotleft> \\<N>\n     ((\\<noteq>) Heads) \\<guillemotright>\n 2. 0 < ?p", "show \"\\<lambda>s. 1/2 \\<tturnstile> wp flip \\<guillemotleft>\\<N> ((\\<noteq>) Heads)\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       1 /\n       2 \\<tturnstile> wp LoopExamples.flip\n                        \\<guillemotleft> \\<N>\n    ((\\<noteq>) Heads) \\<guillemotright>", "unfolding flip_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       1 /\n       2 \\<tturnstile> wp (Apply\n                            (\\<lambda>_.\n                                Heads) \\<^bsub>(\\<lambda>s.\n             1 / 2)\\<^esub>\\<oplus> Apply (\\<lambda>_. Tails))\n                        \\<guillemotleft> \\<N>\n    ((\\<noteq>) Heads) \\<guillemotright>", "by(pvcg, simp add:o_def Heads_def Tails_def)"], ["proof (state)\nthis:\n  \\<lambda>s.\n     1 /\n     2 \\<tturnstile> wp LoopExamples.flip\n                      \\<guillemotleft> \\<N>\n  ((\\<noteq>) Heads) \\<guillemotright>\n\ngoal (1 subgoal):\n 1. 0 < 1 / 2", "txt \\<open>Finally, the one-step escape probability is non-zero.\\<close>"], ["proof (state)\nthis:\n  \\<lambda>s.\n     1 /\n     2 \\<tturnstile> wp LoopExamples.flip\n                      \\<guillemotleft> \\<N>\n  ((\\<noteq>) Heads) \\<guillemotright>\n\ngoal (1 subgoal):\n 1. 0 < 1 / 2", "show \"(0::real) < 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 / 2", "by(simp)"], ["proof (state)\nthis:\n  0 < 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}