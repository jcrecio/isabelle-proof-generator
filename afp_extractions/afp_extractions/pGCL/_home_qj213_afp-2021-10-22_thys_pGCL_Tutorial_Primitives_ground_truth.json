{"file_name": "/home/qj213/afp-2021-10-22/thys/pGCL/Tutorial/Primitives.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/pGCL", "problem_names": ["lemma\n  \"Apply (\\<lambda>s. s \\<lparr> a := Heads \\<rparr>) = (a := (\\<lambda>s. Heads))\"", "lemma\n  \"\\<And>x. \\<guillemotleft>\\<lambda>s. b s = x\\<guillemotright> \\<tturnstile> wp (a := b) \\<guillemotleft>\\<lambda>s. a s = x\\<guillemotright>\"", "lemma\n  \"\\<guillemotleft>\\<lambda>s::real. s \\<noteq> 0\\<guillemotright> \\<tturnstile> wp (Apply ((*) 2) ;; Apply (\\<lambda>s. s / s)) \\<guillemotleft>\\<lambda>s. s = 1\\<guillemotright>\"", "lemma\n  \"(\\<lambda>s. 1/2) = wp (flip_a (1/2)) \\<guillemotleft>\\<lambda>s. a s = Heads\\<guillemotright>\"", "lemma\n  \"\\<lambda>s. 1/3 \\<tturnstile> wp (flip_a (2/3) \\<Sqinter> flip_a (1/3)) \\<guillemotleft>\\<lambda>s. a s = Heads\\<guillemotright>\"", "lemma\n  \"(\\<lambda>s. 1/4) = wp (flip_a (1/2) ;; flip_b (1/2))\n                  \\<guillemotleft>\\<lambda>s. a s = Heads \\<and> b s = Heads\\<guillemotright>\"", "lemma Puniform_in:\n  \"x \\<in> S \\<Longrightarrow> Puniform S x = 1 / card S\"", "lemma Puniform_out:\n  \"x \\<notin> S \\<Longrightarrow> Puniform S x = 0\"", "lemma supp_Puniform:\n  \"finite S \\<Longrightarrow> supp (Puniform S) = S\"", "lemma\n  \"(\\<lambda>s. 7/2) = wp (bind v at (\\<lambda>s. Puniform {1..6} v) in red := (\\<lambda>_. v)) red\"", "lemma\n  \"(\\<lambda>s. 7) = wp ((bind v at (\\<lambda>s. Puniform {1..6} v) in red := (\\<lambda>s. v)) ;;\n                 (bind v at (\\<lambda>s. Puniform {1..6} v) in blue := (\\<lambda>s. v)))\n                (\\<lambda>s. red s + blue s)\""], "translations": [["", "lemma\n  \"Apply (\\<lambda>s. s \\<lparr> a := Heads \\<rparr>) = (a := (\\<lambda>s. Heads))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Apply (a_update (\\<lambda>_. Heads)) =\n    Apply (a_update (\\<lambda>_. Heads))", "by(simp)"], ["", "text \\<open>We can treat the record's fields as the names of \\emph{variables}. Note that the right-hand\nside of an assignment is always a function of the current state. Thus we may use a record accessor\ndirectly, for example @{term \"a := b\"}, which updates @{term a} with the current value of @{term b}.\nIf we wish to formally establish that the previous statement is correct i.e. that in the final\nstate, @{term a} really will have whatever value @{term b} had in the initial state, we must first\nintroduce the assertion language.\\<close>"], ["", "subsection \\<open>Assertion and Annotation\\<close>"], ["", "text \\<open>Assertions in pGCL are real-valued functions of the state, which are often interpreted as a\nprobability distribution over possible outcomes. These functions are termed \\emph{expectations}, for\nreasons which shortly be clear. Initially, however, we need only consider \\emph{standard}\nexpectations: those derived from a binary predicate. A predicate @{term_type \"P::'s \\<Rightarrow> bool\"} is\nembedded as @{term_type \"\\<guillemotleft>P::'s \\<Rightarrow> bool\\<guillemotright>\"}, such that @{term \"P s \\<longrightarrow> \\<guillemotleft>P\\<guillemotright> s = 1 \\<and> \\<not> P s \\<longrightarrow> \\<guillemotleft>P\\<guillemotright> s = 0\"}.\n\n  An annotation consists of an assertion on the initial state and one on the final state, which for\n  standard expectations may be interpreted as `if @{term P} holds in the initial state, then @{term\n  Q} will hold in the final state'. These are in weakest-precondition form: we assert that the\n  precondition implies the \\emph{weakest precondition}: the weakest assertion on the initial state,\n  which implies that the postcondition must hold on the final state. So far, this is identical to\n  the standard approach. Remember, however, that we are working with \\emph{real-valued} assertions.\n  For standard expectations, the logic is nevertheless identical, if the implication @{term \"\\<forall>s. P s\n  \\<longrightarrow> Q s\"} is substituted with the equivalent expectation entailment @{term \"\\<guillemotleft>P\\<guillemotright> \\<tturnstile> \\<guillemotleft>Q\\<guillemotright>\"}, @{thm\n  entails_implies}. Thus a valid specification of @{term \"a := b\"} is:\\<close>"], ["", "lemma\n  \"\\<And>x. \\<guillemotleft>\\<lambda>s. b s = x\\<guillemotright> \\<tturnstile> wp (a := b) \\<guillemotleft>\\<lambda>s. a s = x\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft> \\<lambda>s.\n                           b s =\n                           x \\<guillemotright> \\<tturnstile> wp\n                        (Apply (\\<lambda>s. s\\<lparr>a := b s\\<rparr>))\n                        \\<guillemotleft> \\<lambda>s.\n      a s = x \\<guillemotright>", "by(pvcg, simp add:o_def)"], ["", "text \\<open>Any ordinary computation and its associated annotation can be expressed in this form.\\<close>"], ["", "subsection \\<open>Probability\\<close>"], ["", "text \\<open>Next, we introduce the syntax @{term \"x ;; y\"} for the sequential composition of @{term x}\nand @{term y}, and also demonstrate that one can operate directly on a real-valued (and thus\ninfinite) state space:\\<close>"], ["", "lemma\n  \"\\<guillemotleft>\\<lambda>s::real. s \\<noteq> 0\\<guillemotright> \\<tturnstile> wp (Apply ((*) 2) ;; Apply (\\<lambda>s. s / s)) \\<guillemotleft>\\<lambda>s. s = 1\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> \\<lambda>s.\n                        s \\<noteq>\n                        0 \\<guillemotright> \\<tturnstile> wp\n                     (Apply ((*) 2) ;; Apply (\\<lambda>s. s / s))\n                     \\<guillemotleft> \\<lambda>s. s = 1 \\<guillemotright>", "by(pvcg, simp add:o_def)"], ["", "text \\<open>So far, we haven't done anything that required probabilities, or expectations other than 0\nand 1. As an example of both, we show that a single coin toss is fair. We introduce the syntax\n@{term \"x \\<^bsub>p\\<^esub>\\<oplus> y\"} for a probabilistic choice between @{term x} and @{term y}. This program behaves\nas @{term x} with probability @{term p}, and as @{term y} with probability @{term \"1-p\"}. The\nprobability may depend on the state, and is therefore of type @{typ \"'s \\<Rightarrow> real\"}. The following\nannotation states that the probability of heads is exactly 1/2:\\<close>"], ["", "definition\n  flip_a :: \"real \\<Rightarrow> coins prog\"\nwhere\n  \"flip_a p = a := (\\<lambda>_. Heads) \\<^bsub>(\\<lambda>s. p)\\<^esub>\\<oplus> a := (\\<lambda>_. Tails)\""], ["", "lemma\n  \"(\\<lambda>s. 1/2) = wp (flip_a (1/2)) \\<guillemotleft>\\<lambda>s. a s = Heads\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. 1 / 2) =\n    wp (flip_a (1 / 2))\n     \\<guillemotleft> \\<lambda>s. a s = Heads \\<guillemotright>", "unfolding flip_a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. 1 / 2) =\n    wp (Apply\n         (a_update\n           (\\<lambda>_.\n               Heads)) \\<^bsub>(\\<lambda>s.\n                                   1 /\n                                   2)\\<^esub>\\<oplus> Apply\n                 (a_update (\\<lambda>_. Tails)))\n     \\<guillemotleft> \\<lambda>s. a s = Heads \\<guillemotright>", "txt \\<open>Sufficiently small problems can be handled by the simplifier, by symbolic evaluation.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. 1 / 2) =\n    wp (Apply\n         (a_update\n           (\\<lambda>_.\n               Heads)) \\<^bsub>(\\<lambda>s.\n                                   1 /\n                                   2)\\<^esub>\\<oplus> Apply\n                 (a_update (\\<lambda>_. Tails)))\n     \\<guillemotleft> \\<lambda>s. a s = Heads \\<guillemotright>", "by(simp add:wp_eval o_def)"], ["", "subsection \\<open>Nondeterminism\\<close>"], ["", "text \\<open>We can also under-specify a program, using the \\emph{nondeterministic choice} operator,\n@{term \"x \\<Sqinter> y\"}. This is interpreted demonically, giving the pointwise \\emph{minimum} of the\npre-expectations for @{term x} and @{term y}: the chance of seeing heads, if your opponent is\nallowed choose between a pair of coins, one biased 2/3 heads and one 2/3 tails, and then flips it,\nis \\emph{at least} 1/3, but we can make no stronger statement:\\<close>"], ["", "lemma\n  \"\\<lambda>s. 1/3 \\<tturnstile> wp (flip_a (2/3) \\<Sqinter> flip_a (1/3)) \\<guillemotleft>\\<lambda>s. a s = Heads\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       1 /\n       3 \\<tturnstile> wp (flip_a (2 / 3) \\<Sqinter> flip_a (1 / 3))\n                        \\<guillemotleft> \\<lambda>s.\n      a s = Heads \\<guillemotright>", "unfolding flip_a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       1 /\n       3 \\<tturnstile> wp ((Apply\n                             (a_update\n                               (\\<lambda>_.\n                                   Heads)) \\<^bsub>(\\<lambda>s.\n                 2 /\n                 3)\\<^esub>\\<oplus> Apply\n                                     (a_update\n (\\<lambda>_.\n     Tails))) \\<Sqinter> Apply\n                          (a_update\n                            (\\<lambda>_.\n                                Heads)) \\<^bsub>(\\<lambda>s.\n              1 / 3)\\<^esub>\\<oplus> Apply (a_update (\\<lambda>_. Tails)))\n                        \\<guillemotleft> \\<lambda>s.\n      a s = Heads \\<guillemotright>", "by(pvcg, simp add:o_def le_funI)"], ["", "subsection \\<open>Properties of Expectations\\<close>"], ["", "text \\<open>The probabilities of independent events combine as usual, by multiplying: The chance\nof getting heads on two separate coins is @{term \"1/4\"}.\\<close>"], ["", "definition\n  flip_b :: \"real \\<Rightarrow> coins prog\"\nwhere\n  \"flip_b p = b := (\\<lambda>_. Heads) \\<^bsub>(\\<lambda>s. p)\\<^esub>\\<oplus> b := (\\<lambda>_. Tails)\""], ["", "lemma\n  \"(\\<lambda>s. 1/4) = wp (flip_a (1/2) ;; flip_b (1/2))\n                  \\<guillemotleft>\\<lambda>s. a s = Heads \\<and> b s = Heads\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. 1 / 4) =\n    wp (flip_a (1 / 2) ;; flip_b (1 / 2))\n     \\<guillemotleft> \\<lambda>s.\n                         a s = Heads \\<and> b s = Heads \\<guillemotright>", "unfolding flip_a_def flip_b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. 1 / 4) =\n    wp ((Apply\n          (a_update\n            (\\<lambda>_.\n                Heads)) \\<^bsub>(\\<lambda>s.\n                                    1 /\n                                    2)\\<^esub>\\<oplus> Apply\n                  (a_update (\\<lambda>_. Tails))) ;;\n        (Apply\n          (b_update\n            (\\<lambda>_.\n                Heads)) \\<^bsub>(\\<lambda>s.\n                                    1 /\n                                    2)\\<^esub>\\<oplus> Apply\n                  (b_update (\\<lambda>_. Tails))))\n     \\<guillemotleft> \\<lambda>s.\n                         a s = Heads \\<and> b s = Heads \\<guillemotright>", "by(simp add:wp_eval o_def)"], ["", "text \\<open>If, rather than two coins, we use two dice, we can make some slightly more involved\ncalculations.  We see that the weakest pre-expectation of the value on the face of the die after\nrolling is its \\emph{expected value} in the initial state, which justifies the use of the term\nexpectation.\n\\<close>"], ["", "record dice =\n  red  :: nat\n  blue :: nat"], ["", "definition Puniform :: \"'a set \\<Rightarrow> ('a \\<Rightarrow> real)\"\nwhere \"Puniform S = (\\<lambda>x. if x \\<in> S then 1 / card S else 0)\""], ["", "lemma Puniform_in:\n  \"x \\<in> S \\<Longrightarrow> Puniform S x = 1 / card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow> Puniform S x = 1 / real (card S)", "by(simp add:Puniform_def)"], ["", "lemma Puniform_out:\n  \"x \\<notin> S \\<Longrightarrow> Puniform S x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> S \\<Longrightarrow> Puniform S x = 0", "by(simp add:Puniform_def)"], ["", "lemma supp_Puniform:\n  \"finite S \\<Longrightarrow> supp (Puniform S) = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow> supp (Puniform S) = S", "by(auto simp:Puniform_def supp_def)"], ["", "text \\<open>The expected value of a roll of a six-sided die is @{term \"7/2\"}:\\<close>"], ["", "lemma\n  \"(\\<lambda>s. 7/2) = wp (bind v at (\\<lambda>s. Puniform {1..6} v) in red := (\\<lambda>_. v)) red\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. 7 / 2) =\n    wp (SetPC (\\<lambda>v. Apply (red_update (\\<lambda>_. v)))\n         (flip (\\<lambda>v s. Puniform {1..6} v)))\n     (\\<lambda>x. real (red x))", "by(simp add:wp_eval supp_Puniform sum.atLeast_Suc_atMost Puniform_in)"], ["", "text \\<open>The expectations of independent variables add:\\<close>"], ["", "lemma\n  \"(\\<lambda>s. 7) = wp ((bind v at (\\<lambda>s. Puniform {1..6} v) in red := (\\<lambda>s. v)) ;;\n                 (bind v at (\\<lambda>s. Puniform {1..6} v) in blue := (\\<lambda>s. v)))\n                (\\<lambda>s. red s + blue s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. 7) =\n    wp (SetPC (\\<lambda>v. Apply (red_update (\\<lambda>_. v)))\n         (flip (\\<lambda>v s. Puniform {1..6} v)) ;;\n        SetPC (\\<lambda>v. Apply (blue_update (\\<lambda>_. v)))\n         (flip (\\<lambda>v s. Puniform {1..6} v)))\n     (\\<lambda>x. real (red x + blue x))", "by(simp add:wp_eval supp_Puniform sum.atLeast_Suc_atMost Puniform_in)"], ["", "end"]]}