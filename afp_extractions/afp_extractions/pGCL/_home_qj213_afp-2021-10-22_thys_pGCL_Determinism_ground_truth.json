{"file_name": "/home/qj213/afp-2021-10-22/thys/pGCL/Determinism.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/pGCL", "problem_names": ["lemma additive_wp_Abort:\n  \"additive (wp (Abort))\"", "lemma additive_wp_Skip:\n  \"additive (wp (Skip))\"", "lemma additive_wp_Apply:\n  \"additive (wp (Apply f))\"", "lemma additive_wp_Seq:\n  fixes a::\"'s prog\"\n  assumes adda: \"additive (wp a)\"\n      and addb: \"additive (wp b)\"\n      and wb:   \"well_def b\"\n  shows \"additive (wp (a ;; b))\"", "lemma additive_wp_PC:\n  \"\\<lbrakk> additive (wp a); additive (wp b) \\<rbrakk> \\<Longrightarrow> additive (wp (a \\<^bsub>P\\<^esub>\\<oplus> b))\"", "lemma additive_wp_SetPC:\n  \"\\<lbrakk> \\<And>x s. x \\<in> supp (p s) \\<Longrightarrow> additive (wp (a x)); \\<And>s. finite (supp (p s)) \\<rbrakk> \\<Longrightarrow>\n   additive (wp (SetPC a p))\"", "lemma additive_wp_Bind:\n  \"\\<lbrakk> \\<And>x. additive (wp (a (f x))) \\<rbrakk> \\<Longrightarrow> additive (wp (Bind f a))\"", "lemma additive_wp_Embed:\n  \"\\<lbrakk> additive t \\<rbrakk> \\<Longrightarrow> additive (wp (Embed t))\"", "lemma additive_wp_repeat:\n  \"additive (wp a) \\<Longrightarrow> well_def a \\<Longrightarrow> additive (wp (repeat n a))\"", "lemmas fa_intros =\n  additive_wp_Abort additive_wp_Skip\n  additive_wp_Apply additive_wp_Seq\n  additive_wp_PC    additive_wp_SetPC\n  additive_wp_Bind  additive_wp_Embed\n  additive_wp_repeat", "lemma max_wp_Skip:\n  \"maximal (wp Skip)\"", "lemma max_wp_Apply:\n  \"maximal (wp (Apply f))\"", "lemma max_wp_Seq:\n  \"\\<lbrakk> maximal (wp a); maximal (wp b) \\<rbrakk> \\<Longrightarrow> maximal (wp (a ;; b))\"", "lemma max_wp_PC:\n  \"\\<lbrakk> maximal (wp a); maximal (wp b) \\<rbrakk> \\<Longrightarrow> maximal (wp (a \\<^bsub>P\\<^esub>\\<oplus> b))\"", "lemma max_wp_DC:\n  \"\\<lbrakk> maximal (wp a); maximal (wp b) \\<rbrakk> \\<Longrightarrow> maximal (wp (a \\<Sqinter> b))\"", "lemma max_wp_SetPC:\n  \"\\<lbrakk> \\<And>s a. a \\<in> supp (P s) \\<Longrightarrow> maximal (wp (p a)); \\<And>s. (\\<Sum>a\\<in>supp (P s). P s a) = 1 \\<rbrakk> \\<Longrightarrow>\n  maximal (wp (SetPC p P))\"", "lemma max_wp_SetDC:\n  fixes p::\"'a \\<Rightarrow> 's prog\"\n  assumes mp: \"\\<And>s a. a \\<in> S s \\<Longrightarrow> maximal (wp (p a))\"\n      and ne: \"\\<And>s. S s \\<noteq> {}\"\n  shows \"maximal (wp (SetDC p S))\"", "lemma max_wp_Embed:\n  \"maximal t \\<Longrightarrow> maximal (wp (Embed t))\"", "lemma max_wp_repeat:\n  \"maximal (wp a) \\<Longrightarrow> maximal (wp (repeat n a))\"", "lemma max_wp_Bind:\n  assumes ma: \"\\<And>s. maximal (wp (a (f s)))\"\n  shows \"maximal (wp (Bind f a))\"", "lemmas max_intros =\n  max_wp_Skip  max_wp_Apply\n  max_wp_Seq   max_wp_PC\n  max_wp_DC    max_wp_SetPC\n  max_wp_SetDC max_wp_Embed\n  max_wp_Bind  max_wp_repeat", "lemma healthy_term_max:\n  assumes ht: \"healthy t\"\n      and trm: \"\\<lambda>s. 1 \\<tturnstile> t (\\<lambda>s. 1)\"\n  shows \"maximal t\"", "lemma det_wp_Skip:\n  \"determ (wp Skip)\"", "lemma det_wp_Apply:\n  \"determ (wp (Apply f))\"", "lemma det_wp_Seq:\n  \"determ (wp a) \\<Longrightarrow> determ (wp b) \\<Longrightarrow> well_def b \\<Longrightarrow> determ (wp (a ;; b))\"", "lemma det_wp_PC:\n  \"determ (wp a) \\<Longrightarrow> determ (wp b) \\<Longrightarrow> determ (wp (a \\<^bsub>P\\<^esub>\\<oplus> b))\"", "lemma det_wp_SetPC:\n  \"(\\<And>x s. x \\<in> supp (p s) \\<Longrightarrow> determ (wp (a x))) \\<Longrightarrow>\n   (\\<And>s. finite (supp (p s))) \\<Longrightarrow>\n   (\\<And>s. sum (p s) (supp (p s)) = 1) \\<Longrightarrow>\n   determ (wp (SetPC a p))\"", "lemma det_wp_Bind:\n  \"(\\<And>x. determ (wp (a (f x)))) \\<Longrightarrow> determ (wp (Bind f a))\"", "lemma det_wp_Embed:\n  \"determ t \\<Longrightarrow> determ (wp (Embed t))\"", "lemma det_wp_repeat:\n  \"determ (wp a) \\<Longrightarrow> well_def a \\<Longrightarrow> determ (wp (repeat n a))\"", "lemmas determ_intros =\n  det_wp_Skip det_wp_Apply\n  det_wp_Seq  det_wp_PC\n  det_wp_SetPC det_wp_Bind\n  det_wp_Embed det_wp_repeat"], "translations": [["", "lemma additive_wp_Abort:\n  \"additive (wp (Abort))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transformers.additive (wp Abort)", "by(auto simp:wp_eval)"], ["", "text \\<open>@{term \"wlp Abort\"} is not additive.\\<close>"], ["", "lemma additive_wp_Skip:\n  \"additive (wp (Skip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transformers.additive (wp Skip)", "by(auto simp:wp_eval)"], ["", "lemma additive_wp_Apply:\n  \"additive (wp (Apply f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transformers.additive (wp (Apply f))", "by(auto simp:wp_eval)"], ["", "lemma additive_wp_Seq:\n  fixes a::\"'s prog\"\n  assumes adda: \"additive (wp a)\"\n      and addb: \"additive (wp b)\"\n      and wb:   \"well_def b\"\n  shows \"additive (wp (a ;; b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transformers.additive (wp (a ;; b))", "proof(rule additiveI, unfold wp_eval o_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> wp a (wp b (\\<lambda>s. P s + Q s)) s =\n                         wp a (wp b P) s + wp a (wp b Q) s", "fix P::\"'s \\<Rightarrow> real\" and Q::\"'s \\<Rightarrow> real\" and s::'s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> wp a (wp b (\\<lambda>s. P s + Q s)) s =\n                         wp a (wp b P) s + wp a (wp b Q) s", "assume sP: \"sound P\" and sQ: \"sound Q\""], ["proof (state)\nthis:\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> wp a (wp b (\\<lambda>s. P s + Q s)) s =\n                         wp a (wp b P) s + wp a (wp b Q) s", "note hb = well_def_wp_healthy[OF wb]"], ["proof (state)\nthis:\n  healthy (wp b)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> wp a (wp b (\\<lambda>s. P s + Q s)) s =\n                         wp a (wp b P) s + wp a (wp b Q) s", "from addb sP sQ"], ["proof (chain)\npicking this:\n  Transformers.additive (wp b)\n  sound P\n  sound Q", "have \"wp b (\\<lambda>s. P s + Q s) = (\\<lambda>s. wp b P s + wp b Q s)\""], ["proof (prove)\nusing this:\n  Transformers.additive (wp b)\n  sound P\n  sound Q\n\ngoal (1 subgoal):\n 1. wp b (\\<lambda>s. P s + Q s) = (\\<lambda>s. wp b P s + wp b Q s)", "by(blast dest:additiveD)"], ["proof (state)\nthis:\n  wp b (\\<lambda>s. P s + Q s) = (\\<lambda>s. wp b P s + wp b Q s)\n\ngoal (1 subgoal):\n 1. \\<And>P Q s.\n       \\<lbrakk>sound P; sound Q\\<rbrakk>\n       \\<Longrightarrow> wp a (wp b (\\<lambda>s. P s + Q s)) s =\n                         wp a (wp b P) s + wp a (wp b Q) s", "with adda sP sQ hb"], ["proof (chain)\npicking this:\n  Transformers.additive (wp a)\n  sound P\n  sound Q\n  healthy (wp b)\n  wp b (\\<lambda>s. P s + Q s) = (\\<lambda>s. wp b P s + wp b Q s)", "show \"wp a (wp b (\\<lambda>s. P s + Q s)) s =\n        wp a (wp b P) s + (wp a (wp b Q)) s\""], ["proof (prove)\nusing this:\n  Transformers.additive (wp a)\n  sound P\n  sound Q\n  healthy (wp b)\n  wp b (\\<lambda>s. P s + Q s) = (\\<lambda>s. wp b P s + wp b Q s)\n\ngoal (1 subgoal):\n 1. wp a (wp b (\\<lambda>s. P s + Q s)) s =\n    wp a (wp b P) s + wp a (wp b Q) s", "by(auto intro:fun_cong[OF additiveD])"], ["proof (state)\nthis:\n  wp a (wp b (\\<lambda>s. P s + Q s)) s = wp a (wp b P) s + wp a (wp b Q) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma additive_wp_PC:\n  \"\\<lbrakk> additive (wp a); additive (wp b) \\<rbrakk> \\<Longrightarrow> additive (wp (a \\<^bsub>P\\<^esub>\\<oplus> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Transformers.additive (wp a);\n     Transformers.additive (wp b)\\<rbrakk>\n    \\<Longrightarrow> Transformers.additive\n                       (wp (a \\<^bsub>P\\<^esub>\\<oplus> b))", "by(rule additiveI, simp add:additiveD field_simps wp_eval)"], ["", "text \\<open>@{term DC} is not additive.\\<close>"], ["", "lemma additive_wp_SetPC:\n  \"\\<lbrakk> \\<And>x s. x \\<in> supp (p s) \\<Longrightarrow> additive (wp (a x)); \\<And>s. finite (supp (p s)) \\<rbrakk> \\<Longrightarrow>\n   additive (wp (SetPC a p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x s.\n                x \\<in> supp (p s) \\<Longrightarrow>\n                Transformers.additive (wp (a x));\n     \\<And>s. finite (supp (p s))\\<rbrakk>\n    \\<Longrightarrow> Transformers.additive (wp (SetPC a p))", "by(rule additiveI,\n     simp add:wp_eval additiveD distrib_left sum.distrib)"], ["", "lemma additive_wp_Bind:\n  \"\\<lbrakk> \\<And>x. additive (wp (a (f x))) \\<rbrakk> \\<Longrightarrow> additive (wp (Bind f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. Transformers.additive (wp (a (f x)))) \\<Longrightarrow>\n    Transformers.additive (wp (Bind f a))", "by(simp add:wp_eval additive_def)"], ["", "lemma additive_wp_Embed:\n  \"\\<lbrakk> additive t \\<rbrakk> \\<Longrightarrow> additive (wp (Embed t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transformers.additive t \\<Longrightarrow>\n    Transformers.additive (wp (Embed t))", "by(simp add:wp_eval)"], ["", "lemma additive_wp_repeat:\n  \"additive (wp a) \\<Longrightarrow> well_def a \\<Longrightarrow> additive (wp (repeat n a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Transformers.additive (wp a); well_def a\\<rbrakk>\n    \\<Longrightarrow> Transformers.additive (wp (repeat n a))", "by(induct n, auto simp:additive_wp_Skip intro:additive_wp_Seq wd_intros)"], ["", "lemmas fa_intros =\n  additive_wp_Abort additive_wp_Skip\n  additive_wp_Apply additive_wp_Seq\n  additive_wp_PC    additive_wp_SetPC\n  additive_wp_Bind  additive_wp_Embed\n  additive_wp_repeat"], ["", "subsection \\<open>Maximality\\<close>"], ["", "lemma max_wp_Skip:\n  \"maximal (wp Skip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal (wp Skip)", "by(simp add:maximal_def wp_eval)"], ["", "lemma max_wp_Apply:\n  \"maximal (wp (Apply f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal (wp (Apply f))", "by(auto simp:wp_eval o_def)"], ["", "lemma max_wp_Seq:\n  \"\\<lbrakk> maximal (wp a); maximal (wp b) \\<rbrakk> \\<Longrightarrow> maximal (wp (a ;; b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maximal (wp a); maximal (wp b)\\<rbrakk>\n    \\<Longrightarrow> maximal (wp (a ;; b))", "by(simp add:wp_eval maximal_def)"], ["", "lemma max_wp_PC:\n  \"\\<lbrakk> maximal (wp a); maximal (wp b) \\<rbrakk> \\<Longrightarrow> maximal (wp (a \\<^bsub>P\\<^esub>\\<oplus> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maximal (wp a); maximal (wp b)\\<rbrakk>\n    \\<Longrightarrow> maximal (wp (a \\<^bsub>P\\<^esub>\\<oplus> b))", "by(rule maximalI, simp add:maximalD field_simps wp_eval)"], ["", "lemma max_wp_DC:\n  \"\\<lbrakk> maximal (wp a); maximal (wp b) \\<rbrakk> \\<Longrightarrow> maximal (wp (a \\<Sqinter> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>maximal (wp a); maximal (wp b)\\<rbrakk>\n    \\<Longrightarrow> maximal (wp (a \\<Sqinter> b))", "by(rule maximalI, simp add:wp_eval maximalD)"], ["", "lemma max_wp_SetPC:\n  \"\\<lbrakk> \\<And>s a. a \\<in> supp (P s) \\<Longrightarrow> maximal (wp (p a)); \\<And>s. (\\<Sum>a\\<in>supp (P s). P s a) = 1 \\<rbrakk> \\<Longrightarrow>\n  maximal (wp (SetPC p P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s a.\n                a \\<in> supp (P s) \\<Longrightarrow> maximal (wp (p a));\n     \\<And>s. sum (P s) (supp (P s)) = 1\\<rbrakk>\n    \\<Longrightarrow> maximal (wp (SetPC p P))", "by(auto simp:maximalD wp_def SetPC_def sum_distrib_right[symmetric])"], ["", "lemma max_wp_SetDC:\n  fixes p::\"'a \\<Rightarrow> 's prog\"\n  assumes mp: \"\\<And>s a. a \\<in> S s \\<Longrightarrow> maximal (wp (p a))\"\n      and ne: \"\\<And>s. S s \\<noteq> {}\"\n  shows \"maximal (wp (SetDC p S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal (wp (SetDC p S))", "proof(rule maximalI, rule ext, unfold wp_eval)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c uu_.\n       0 \\<le> c \\<Longrightarrow>\n       (INF a\\<in>S uu_. wp (p a) (\\<lambda>_. c) uu_) = c", "fix c::real and s::'s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c uu_.\n       0 \\<le> c \\<Longrightarrow>\n       (INF a\\<in>S uu_. wp (p a) (\\<lambda>_. c) uu_) = c", "assume \"0 \\<le> c\""], ["proof (state)\nthis:\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>c uu_.\n       0 \\<le> c \\<Longrightarrow>\n       (INF a\\<in>S uu_. wp (p a) (\\<lambda>_. c) uu_) = c", "hence \"Inf ((\\<lambda>a. wp (p a) (\\<lambda>_. c) s) ` S s) = Inf ((\\<lambda>_. c) ` S s)\""], ["proof (prove)\nusing this:\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. (INF a\\<in>S s. wp (p a) (\\<lambda>_. c) s) = (INF _\\<in>S s. c)", "using mp"], ["proof (prove)\nusing this:\n  0 \\<le> c\n  ?a \\<in> S ?s \\<Longrightarrow> maximal (wp (p ?a))\n\ngoal (1 subgoal):\n 1. (INF a\\<in>S s. wp (p a) (\\<lambda>_. c) s) = (INF _\\<in>S s. c)", "by(simp add:maximalD cong:image_cong)"], ["proof (state)\nthis:\n  (INF a\\<in>S s. wp (p a) (\\<lambda>_. c) s) = (INF _\\<in>S s. c)\n\ngoal (1 subgoal):\n 1. \\<And>c uu_.\n       0 \\<le> c \\<Longrightarrow>\n       (INF a\\<in>S uu_. wp (p a) (\\<lambda>_. c) uu_) = c", "also"], ["proof (state)\nthis:\n  (INF a\\<in>S s. wp (p a) (\\<lambda>_. c) s) = (INF _\\<in>S s. c)\n\ngoal (1 subgoal):\n 1. \\<And>c uu_.\n       0 \\<le> c \\<Longrightarrow>\n       (INF a\\<in>S uu_. wp (p a) (\\<lambda>_. c) uu_) = c", "{"], ["proof (state)\nthis:\n  (INF a\\<in>S s. wp (p a) (\\<lambda>_. c) s) = (INF _\\<in>S s. c)\n\ngoal (1 subgoal):\n 1. \\<And>c uu_.\n       0 \\<le> c \\<Longrightarrow>\n       (INF a\\<in>S uu_. wp (p a) (\\<lambda>_. c) uu_) = c", "from ne"], ["proof (chain)\npicking this:\n  S ?s \\<noteq> {}", "obtain a where \"a \\<in> S s\""], ["proof (prove)\nusing this:\n  S ?s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> S s \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> S s\n\ngoal (1 subgoal):\n 1. \\<And>c uu_.\n       0 \\<le> c \\<Longrightarrow>\n       (INF a\\<in>S uu_. wp (p a) (\\<lambda>_. c) uu_) = c", "hence \"Inf ((\\<lambda>_. c) ` S s) = c\""], ["proof (prove)\nusing this:\n  a \\<in> S s\n\ngoal (1 subgoal):\n 1. (INF _\\<in>S s. c) = c", "by (auto simp add: image_constant_conv cong del: INF_cong_simp)"], ["proof (state)\nthis:\n  (INF _\\<in>S s. c) = c\n\ngoal (1 subgoal):\n 1. \\<And>c uu_.\n       0 \\<le> c \\<Longrightarrow>\n       (INF a\\<in>S uu_. wp (p a) (\\<lambda>_. c) uu_) = c", "}"], ["proof (state)\nthis:\n  (INF _\\<in>S s. c) = c\n\ngoal (1 subgoal):\n 1. \\<And>c uu_.\n       0 \\<le> c \\<Longrightarrow>\n       (INF a\\<in>S uu_. wp (p a) (\\<lambda>_. c) uu_) = c", "finally"], ["proof (chain)\npicking this:\n  (INF a\\<in>S s. wp (p a) (\\<lambda>_. c) s) = c", "show \"Inf ((\\<lambda>a. wp (p a) (\\<lambda>_. c) s) ` S s) = c\""], ["proof (prove)\nusing this:\n  (INF a\\<in>S s. wp (p a) (\\<lambda>_. c) s) = c\n\ngoal (1 subgoal):\n 1. (INF a\\<in>S s. wp (p a) (\\<lambda>_. c) s) = c", "."], ["proof (state)\nthis:\n  (INF a\\<in>S s. wp (p a) (\\<lambda>_. c) s) = c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_wp_Embed:\n  \"maximal t \\<Longrightarrow> maximal (wp (Embed t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal t \\<Longrightarrow> maximal (wp (Embed t))", "by(simp add:wp_eval)"], ["", "lemma max_wp_repeat:\n  \"maximal (wp a) \\<Longrightarrow> maximal (wp (repeat n a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal (wp a) \\<Longrightarrow> maximal (wp (repeat n a))", "by(induct n, simp_all add:max_wp_Skip max_wp_Seq)"], ["", "lemma max_wp_Bind:\n  assumes ma: \"\\<And>s. maximal (wp (a (f s)))\"\n  shows \"maximal (wp (Bind f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal (wp (Bind f a))", "proof(rule maximalI, rule ext, simp add:wp_eval)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c uu_.\n       0 \\<le> c \\<Longrightarrow> wp (a (f uu_)) (\\<lambda>_. c) uu_ = c", "fix c::real and s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c uu_.\n       0 \\<le> c \\<Longrightarrow> wp (a (f uu_)) (\\<lambda>_. c) uu_ = c", "assume \"0 \\<le> c\""], ["proof (state)\nthis:\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>c uu_.\n       0 \\<le> c \\<Longrightarrow> wp (a (f uu_)) (\\<lambda>_. c) uu_ = c", "with ma"], ["proof (chain)\npicking this:\n  maximal (wp (a (f ?s)))\n  0 \\<le> c", "have \"wp (a (f s)) (\\<lambda>_. c) = (\\<lambda>_. c)\""], ["proof (prove)\nusing this:\n  maximal (wp (a (f ?s)))\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. wp (a (f s)) (\\<lambda>_. c) = (\\<lambda>_. c)", "by(blast)"], ["proof (state)\nthis:\n  wp (a (f s)) (\\<lambda>_. c) = (\\<lambda>_. c)\n\ngoal (1 subgoal):\n 1. \\<And>c uu_.\n       0 \\<le> c \\<Longrightarrow> wp (a (f uu_)) (\\<lambda>_. c) uu_ = c", "thus \"wp (a (f s)) (\\<lambda>_. c) s = c\""], ["proof (prove)\nusing this:\n  wp (a (f s)) (\\<lambda>_. c) = (\\<lambda>_. c)\n\ngoal (1 subgoal):\n 1. wp (a (f s)) (\\<lambda>_. c) s = c", "by(auto)"], ["proof (state)\nthis:\n  wp (a (f s)) (\\<lambda>_. c) s = c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas max_intros =\n  max_wp_Skip  max_wp_Apply\n  max_wp_Seq   max_wp_PC\n  max_wp_DC    max_wp_SetPC\n  max_wp_SetDC max_wp_Embed\n  max_wp_Bind  max_wp_repeat"], ["", "text \\<open>A healthy transformer that terminates is maximal.\\<close>"], ["", "lemma healthy_term_max:\n  assumes ht: \"healthy t\"\n      and trm: \"\\<lambda>s. 1 \\<tturnstile> t (\\<lambda>s. 1)\"\n  shows \"maximal t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal t", "proof(intro maximalI ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c uu_. 0 \\<le> c \\<Longrightarrow> t (\\<lambda>_. c) uu_ = c", "fix c::real and s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c uu_. 0 \\<le> c \\<Longrightarrow> t (\\<lambda>_. c) uu_ = c", "assume nnc: \"0 \\<le> c\""], ["proof (state)\nthis:\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>c uu_. 0 \\<le> c \\<Longrightarrow> t (\\<lambda>_. c) uu_ = c", "have \"t (\\<lambda>s. c) s = t (\\<lambda>s. 1 * c) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t (\\<lambda>s. c) s = t (\\<lambda>s. 1 * c) s", "by(simp)"], ["proof (state)\nthis:\n  t (\\<lambda>s. c) s = t (\\<lambda>s. 1 * c) s\n\ngoal (1 subgoal):\n 1. \\<And>c uu_. 0 \\<le> c \\<Longrightarrow> t (\\<lambda>_. c) uu_ = c", "also"], ["proof (state)\nthis:\n  t (\\<lambda>s. c) s = t (\\<lambda>s. 1 * c) s\n\ngoal (1 subgoal):\n 1. \\<And>c uu_. 0 \\<le> c \\<Longrightarrow> t (\\<lambda>_. c) uu_ = c", "from nnc healthy_scalingD[OF ht]"], ["proof (chain)\npicking this:\n  0 \\<le> c\n  scaling t", "have \"... = c * t (\\<lambda>s. 1) s\""], ["proof (prove)\nusing this:\n  0 \\<le> c\n  scaling t\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. 1 * c) s = c * t (\\<lambda>s. 1) s", "by(simp add:scalingD)"], ["proof (state)\nthis:\n  t (\\<lambda>s. 1 * c) s = c * t (\\<lambda>s. 1) s\n\ngoal (1 subgoal):\n 1. \\<And>c uu_. 0 \\<le> c \\<Longrightarrow> t (\\<lambda>_. c) uu_ = c", "also"], ["proof (state)\nthis:\n  t (\\<lambda>s. 1 * c) s = c * t (\\<lambda>s. 1) s\n\ngoal (1 subgoal):\n 1. \\<And>c uu_. 0 \\<le> c \\<Longrightarrow> t (\\<lambda>_. c) uu_ = c", "{"], ["proof (state)\nthis:\n  t (\\<lambda>s. 1 * c) s = c * t (\\<lambda>s. 1) s\n\ngoal (1 subgoal):\n 1. \\<And>c uu_. 0 \\<le> c \\<Longrightarrow> t (\\<lambda>_. c) uu_ = c", "from ht"], ["proof (chain)\npicking this:\n  healthy t", "have \"t (\\<lambda>s. 1) \\<tturnstile> \\<lambda>s. 1\""], ["proof (prove)\nusing this:\n  healthy t\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. 1) \\<tturnstile> \\<lambda>s. 1", "by(auto)"], ["proof (state)\nthis:\n  t (\\<lambda>s. 1) \\<tturnstile> \\<lambda>s. 1\n\ngoal (1 subgoal):\n 1. \\<And>c uu_. 0 \\<le> c \\<Longrightarrow> t (\\<lambda>_. c) uu_ = c", "with trm"], ["proof (chain)\npicking this:\n  \\<lambda>s. 1 \\<tturnstile> t (\\<lambda>s. 1)\n  t (\\<lambda>s. 1) \\<tturnstile> \\<lambda>s. 1", "have \"t (\\<lambda>s. 1) = (\\<lambda>s. 1)\""], ["proof (prove)\nusing this:\n  \\<lambda>s. 1 \\<tturnstile> t (\\<lambda>s. 1)\n  t (\\<lambda>s. 1) \\<tturnstile> \\<lambda>s. 1\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. 1) = (\\<lambda>s. 1)", "by(auto)"], ["proof (state)\nthis:\n  t (\\<lambda>s. 1) = (\\<lambda>s. 1)\n\ngoal (1 subgoal):\n 1. \\<And>c uu_. 0 \\<le> c \\<Longrightarrow> t (\\<lambda>_. c) uu_ = c", "hence \"c * t (\\<lambda>s. 1) s = c\""], ["proof (prove)\nusing this:\n  t (\\<lambda>s. 1) = (\\<lambda>s. 1)\n\ngoal (1 subgoal):\n 1. c * t (\\<lambda>s. 1) s = c", "by(simp)"], ["proof (state)\nthis:\n  c * t (\\<lambda>s. 1) s = c\n\ngoal (1 subgoal):\n 1. \\<And>c uu_. 0 \\<le> c \\<Longrightarrow> t (\\<lambda>_. c) uu_ = c", "}"], ["proof (state)\nthis:\n  c * t (\\<lambda>s. 1) s = c\n\ngoal (1 subgoal):\n 1. \\<And>c uu_. 0 \\<le> c \\<Longrightarrow> t (\\<lambda>_. c) uu_ = c", "finally"], ["proof (chain)\npicking this:\n  t (\\<lambda>s. c) s = c", "show \"t (\\<lambda>s. c) s = c\""], ["proof (prove)\nusing this:\n  t (\\<lambda>s. c) s = c\n\ngoal (1 subgoal):\n 1. t (\\<lambda>s. c) s = c", "."], ["proof (state)\nthis:\n  t (\\<lambda>s. c) s = c\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Determinism\\<close>"], ["", "lemma det_wp_Skip:\n  \"determ (wp Skip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. determ (wp Skip)", "using max_intros fa_intros"], ["proof (prove)\nusing this:\n  maximal (wp Skip)\n  maximal (wp (Apply ?f))\n  \\<lbrakk>maximal (wp ?a); maximal (wp ?b)\\<rbrakk>\n  \\<Longrightarrow> maximal (wp (?a ;; ?b))\n  \\<lbrakk>maximal (wp ?a); maximal (wp ?b)\\<rbrakk>\n  \\<Longrightarrow> maximal (wp (?a \\<^bsub>?P\\<^esub>\\<oplus> ?b))\n  \\<lbrakk>maximal (wp ?a); maximal (wp ?b)\\<rbrakk>\n  \\<Longrightarrow> maximal (wp (?a \\<Sqinter> ?b))\n  \\<lbrakk>\\<And>s a.\n              a \\<in> supp (?P s) \\<Longrightarrow> maximal (wp (?p a));\n   \\<And>s. sum (?P s) (supp (?P s)) = 1\\<rbrakk>\n  \\<Longrightarrow> maximal (wp (SetPC ?p ?P))\n  \\<lbrakk>\\<And>s a. a \\<in> ?S s \\<Longrightarrow> maximal (wp (?p a));\n   \\<And>s. ?S s \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> maximal (wp (SetDC ?p ?S))\n  maximal ?t \\<Longrightarrow> maximal (wp (Embed ?t))\n  (\\<And>s. maximal (wp (?a (?f s)))) \\<Longrightarrow>\n  maximal (wp (Bind ?f ?a))\n  maximal (wp ?a) \\<Longrightarrow> maximal (wp (repeat ?n ?a))\n  Transformers.additive (wp Abort)\n  Transformers.additive (wp Skip)\n  Transformers.additive (wp (Apply ?f))\n  \\<lbrakk>Transformers.additive (wp ?a); Transformers.additive (wp ?b);\n   well_def ?b\\<rbrakk>\n  \\<Longrightarrow> Transformers.additive (wp (?a ;; ?b))\n  \\<lbrakk>Transformers.additive (wp ?a);\n   Transformers.additive (wp ?b)\\<rbrakk>\n  \\<Longrightarrow> Transformers.additive\n                     (wp (?a \\<^bsub>?P\\<^esub>\\<oplus> ?b))\n  \\<lbrakk>\\<And>x s.\n              x \\<in> supp (?p s) \\<Longrightarrow>\n              Transformers.additive (wp (?a x));\n   \\<And>s. finite (supp (?p s))\\<rbrakk>\n  \\<Longrightarrow> Transformers.additive (wp (SetPC ?a ?p))\n  (\\<And>x. Transformers.additive (wp (?a (?f x)))) \\<Longrightarrow>\n  Transformers.additive (wp (Bind ?f ?a))\n  Transformers.additive ?t \\<Longrightarrow>\n  Transformers.additive (wp (Embed ?t))\n  \\<lbrakk>Transformers.additive (wp ?a); well_def ?a\\<rbrakk>\n  \\<Longrightarrow> Transformers.additive (wp (repeat ?n ?a))\n\ngoal (1 subgoal):\n 1. determ (wp Skip)", "by(blast)"], ["", "lemma det_wp_Apply:\n  \"determ (wp (Apply f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. determ (wp (Apply f))", "by(intro determI fa_intros max_intros)"], ["", "lemma det_wp_Seq:\n  \"determ (wp a) \\<Longrightarrow> determ (wp b) \\<Longrightarrow> well_def b \\<Longrightarrow> determ (wp (a ;; b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>determ (wp a); determ (wp b); well_def b\\<rbrakk>\n    \\<Longrightarrow> determ (wp (a ;; b))", "by(intro determI fa_intros max_intros, auto)"], ["", "lemma det_wp_PC:\n  \"determ (wp a) \\<Longrightarrow> determ (wp b) \\<Longrightarrow> determ (wp (a \\<^bsub>P\\<^esub>\\<oplus> b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>determ (wp a); determ (wp b)\\<rbrakk>\n    \\<Longrightarrow> determ (wp (a \\<^bsub>P\\<^esub>\\<oplus> b))", "by(intro determI fa_intros max_intros, auto)"], ["", "lemma det_wp_SetPC:\n  \"(\\<And>x s. x \\<in> supp (p s) \\<Longrightarrow> determ (wp (a x))) \\<Longrightarrow>\n   (\\<And>s. finite (supp (p s))) \\<Longrightarrow>\n   (\\<And>s. sum (p s) (supp (p s)) = 1) \\<Longrightarrow>\n   determ (wp (SetPC a p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x s.\n                x \\<in> supp (p s) \\<Longrightarrow> determ (wp (a x));\n     \\<And>s. finite (supp (p s));\n     \\<And>s. sum (p s) (supp (p s)) = 1\\<rbrakk>\n    \\<Longrightarrow> determ (wp (SetPC a p))", "by(intro determI fa_intros max_intros, auto)"], ["", "lemma det_wp_Bind:\n  \"(\\<And>x. determ (wp (a (f x)))) \\<Longrightarrow> determ (wp (Bind f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. determ (wp (a (f x)))) \\<Longrightarrow>\n    determ (wp (Bind f a))", "by(intro determI fa_intros max_intros, auto)"], ["", "lemma det_wp_Embed:\n  \"determ t \\<Longrightarrow> determ (wp (Embed t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. determ t \\<Longrightarrow> determ (wp (Embed t))", "by(simp add:wp_eval)"], ["", "lemma det_wp_repeat:\n  \"determ (wp a) \\<Longrightarrow> well_def a \\<Longrightarrow> determ (wp (repeat n a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>determ (wp a); well_def a\\<rbrakk>\n    \\<Longrightarrow> determ (wp (repeat n a))", "by(intro determI fa_intros max_intros, auto)"], ["", "lemmas determ_intros =\n  det_wp_Skip det_wp_Apply\n  det_wp_Seq  det_wp_PC\n  det_wp_SetPC det_wp_Bind\n  det_wp_Embed det_wp_repeat"], ["", "end"]]}