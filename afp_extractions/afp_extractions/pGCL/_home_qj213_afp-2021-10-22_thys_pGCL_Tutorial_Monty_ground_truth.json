{"file_name": "/home/qj213/afp-2021-10-22/thys/pGCL/Tutorial/Monty.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/pGCL", "problem_names": ["lemma eval_win[simp]:\n  \"p = g \\<Longrightarrow> \\<guillemotleft>player_wins\\<guillemotright> (s\\<lparr> prize := p, guess := g, clue := c \\<rparr>) = 1\"", "lemma eval_loss[simp]:\n  \"p \\<noteq> g \\<Longrightarrow> \\<guillemotleft>player_wins\\<guillemotright> (s\\<lparr> prize := p, guess := g, clue := c \\<rparr>) = 0\"", "lemma wp_monty_noswitch:\n  \"(\\<lambda>s. 1/3) = wp (monty False) \\<guillemotleft>player_wins\\<guillemotright>\"", "lemma swap_upd:\n  \"s\\<lparr> prize := p, clue := c, guess := g \\<rparr> =\n   s\\<lparr> prize := p, guess := g, clue := c \\<rparr>\"", "lemma wp_monty_switch_bruteforce:\n  \"(\\<lambda>s. 2/3) = wp (monty True) \\<guillemotleft>player_wins\\<guillemotright>\"", "lemma wd_hide_prize:\n  \"well_def hide_prize\"", "lemma wd_make_guess:\n  \"well_def make_guess\"", "lemma wd_reveal:\n  \"well_def reveal\"", "lemma wd_switch_guess:\n  \"well_def switch_guess\"", "lemmas monty_healthy =\n  wd_switch_guess wd_reveal wd_make_guess wd_hide_prize", "lemma wp_hide_prize:\n  \"(\\<lambda>s. 1) \\<tturnstile> wp hide_prize \\<guillemotleft>inv_prize\\<guillemotright>\"", "lemma wp_make_guess:\n  \"(\\<lambda>s. 2/3 * \\<guillemotleft>\\<lambda>g. inv_prize g\\<guillemotright> s) \\<tturnstile>\n   wp make_guess \\<guillemotleft>\\<lambda>g. guess g \\<noteq> prize g \\<and> inv_prize g \\<and> inv_guess g\\<guillemotright>\"", "lemma last_one:\n  assumes \"a \\<noteq> b\" and \"a \\<in> {1::nat,2,3}\" and \"b \\<in> {1,2,3}\"\n  shows \"\\<exists>!c. {1,2,3} - {b,a} = {c}\"", "lemma wp_reveal:\n  \"\\<guillemotleft>\\<lambda>g. guess g \\<noteq> prize g \\<and> inv_prize g \\<and> inv_guess g\\<guillemotright> \\<tturnstile>\n   wp reveal \\<guillemotleft>\\<lambda>g. guess g \\<noteq> prize g \\<and>\n                  clue g \\<noteq> prize g \\<and>\n                  clue g \\<noteq> guess g \\<and>\n                  inv_prize g \\<and> inv_guess g \\<and> inv_clue g\\<guillemotright>\"\n  (is \"?X \\<tturnstile> wp reveal ?Y\")", "lemma distinct_game:\n  \"\\<lbrakk> guess g \\<noteq> prize g; clue g \\<noteq> prize g; clue g \\<noteq> guess g;\n     inv_prize g; inv_guess g; inv_clue g \\<rbrakk> \\<Longrightarrow> \n   {1, 2, 3} = {guess g, prize g, clue g}\"", "lemma wp_switch_guess:\n  \"\\<guillemotleft>\\<lambda>g. guess g \\<noteq> prize g \\<and> clue g \\<noteq> prize g \\<and> clue g \\<noteq> guess g \\<and>\n        inv_prize g \\<and> inv_guess g \\<and> inv_clue g\\<guillemotright> \\<tturnstile>\n   wp switch_guess \\<guillemotleft>player_wins\\<guillemotright>\"", "lemma wp_monty_switch_modular:\n  \"(\\<lambda>s. 2/3) \\<tturnstile> wp (monty True) \\<guillemotleft>player_wins\\<guillemotright>\"", "lemmas scaled_hide = wp_scale[OF wp_hide_prize, simplified]", "lemma wp_monty_switch_vcg:\n  \"(\\<lambda>s. 2/3) \\<tturnstile> wp (monty True) \\<guillemotleft>player_wins\\<guillemotright>\""], "translations": [["", "lemma eval_win[simp]:\n  \"p = g \\<Longrightarrow> \\<guillemotleft>player_wins\\<guillemotright> (s\\<lparr> prize := p, guess := g, clue := c \\<rparr>) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = g \\<Longrightarrow>\n    \\<guillemotleft> player_wins \\<guillemotright>\n     (s\\<lparr>prize := p, guess := g, clue := c\\<rparr>) =\n    1", "by(simp add:embed_bool_def player_wins_def)"], ["", "lemma eval_loss[simp]:\n  \"p \\<noteq> g \\<Longrightarrow> \\<guillemotleft>player_wins\\<guillemotright> (s\\<lparr> prize := p, guess := g, clue := c \\<rparr>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> g \\<Longrightarrow>\n    \\<guillemotleft> player_wins \\<guillemotright>\n     (s\\<lparr>prize := p, guess := g, clue := c\\<rparr>) =\n    0", "by(simp add:embed_bool_def player_wins_def)"], ["", "text \\<open>If they stick to their guns, the player wins with $p=1/3$.\\<close>"], ["", "lemma wp_monty_noswitch:\n  \"(\\<lambda>s. 1/3) = wp (monty False) \\<guillemotleft>player_wins\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. 1 / 3) =\n    wp (monty False) \\<guillemotleft> player_wins \\<guillemotright>", "unfolding monty_def hide_prize_def make_guess_def reveal_def\n            hide_behind_def guess_behind_def open_door_def\n            switch_guess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. 1 / 3) =\n    wp ((Apply\n          (prize_update\n            (\\<lambda>x.\n                1)) \\<Sqinter> Apply\n                                (prize_update\n                                  (\\<lambda>x.\n2)) \\<Sqinter> Apply (prize_update (\\<lambda>x. 3))) ;;\n        (Apply\n          (guess_update\n            (\\<lambda>x.\n                1)) \\<^bsub>(\\<lambda>s.\n                                1 /\n                                3)\\<^esub>\\<oplus> Apply\n              (guess_update\n                (\\<lambda>x.\n                    2)) \\<^bsub>(\\<lambda>s.\n                                    1 /\n                                    2)\\<^esub>\\<oplus> Apply\n                  (guess_update (\\<lambda>x. 3))) ;;\n        \\<Sqinter>d\\<in>\\<lambda>s. {1, 2, 3} - {prize s, guess s}.\n        Apply (clue_update (\\<lambda>x. d)) ;;\n        (if False\n         then \\<Sqinter>d\\<in>\\<lambda>s. {1, 2, 3} - {clue s, guess s}.\n              Apply (guess_update (\\<lambda>x. d))\n         else Skip))\n     \\<guillemotleft> player_wins \\<guillemotright>", "by(simp add:wp_eval insert_Diff_if o_def)"], ["", "lemma swap_upd:\n  \"s\\<lparr> prize := p, clue := c, guess := g \\<rparr> =\n   s\\<lparr> prize := p, guess := g, clue := c \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<lparr>prize := p, clue := c, guess := g\\<rparr> = s\n    \\<lparr>prize := p, guess := g, clue := c\\<rparr>", "by(simp)"], ["", "text \\<open>If they switch, they win with $p=2/3$.  Brute force here\n  takes longer, but is still feasible.  On larger programs,\n  this will rapidly become impossible, as the size of the terms\n  (generally) grows exponentially with the length of the program.\\<close>"], ["", "lemma wp_monty_switch_bruteforce:\n  \"(\\<lambda>s. 2/3) = wp (monty True) \\<guillemotleft>player_wins\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. 2 / 3) =\n    wp (monty True) \\<guillemotleft> player_wins \\<guillemotright>", "unfolding monty_def hide_prize_def make_guess_def reveal_def\n            hide_behind_def guess_behind_def open_door_def\n            switch_guess_def\n  \\<comment> \\<open>Note that this is getting slow\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. 2 / 3) =\n    wp ((Apply\n          (prize_update\n            (\\<lambda>x.\n                1)) \\<Sqinter> Apply\n                                (prize_update\n                                  (\\<lambda>x.\n2)) \\<Sqinter> Apply (prize_update (\\<lambda>x. 3))) ;;\n        (Apply\n          (guess_update\n            (\\<lambda>x.\n                1)) \\<^bsub>(\\<lambda>s.\n                                1 /\n                                3)\\<^esub>\\<oplus> Apply\n              (guess_update\n                (\\<lambda>x.\n                    2)) \\<^bsub>(\\<lambda>s.\n                                    1 /\n                                    2)\\<^esub>\\<oplus> Apply\n                  (guess_update (\\<lambda>x. 3))) ;;\n        \\<Sqinter>d\\<in>\\<lambda>s. {1, 2, 3} - {prize s, guess s}.\n        Apply (clue_update (\\<lambda>x. d)) ;;\n        (if True\n         then \\<Sqinter>d\\<in>\\<lambda>s. {1, 2, 3} - {clue s, guess s}.\n              Apply (guess_update (\\<lambda>x. d))\n         else Skip))\n     \\<guillemotleft> player_wins \\<guillemotright>", "by (simp add: wp_eval insert_Diff_if swap_upd o_def cong del: INF_cong_simp)"], ["", "subsection \\<open>A Modular Approach\\<close>"], ["", "text \\<open>We can solve the problem more efficiently, at the cost of\n  a little more user effort, by breaking up the problem and annotating\n  each step of the game separately.  While this is not strictly necessary\n  for this program, it will scale to larger examples, as the work in\n  annotation only increases linearly with the length of the program.\\<close>"], ["", "subsubsection \\<open>Healthiness\\<close>"], ["", "text \\<open>We first establish healthiness for each step. This follows\n  straightforwardly by applying the supplied rulesets.\\<close>"], ["", "lemma wd_hide_prize:\n  \"well_def hide_prize\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def hide_prize", "unfolding hide_prize_def hide_behind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def\n     (Apply\n       (prize_update\n         (\\<lambda>x.\n             1)) \\<Sqinter> Apply\n                             (prize_update\n                               (\\<lambda>x.\n                                   2)) \\<Sqinter> Apply\n             (prize_update (\\<lambda>x. 3)))", "by(simp add:wd_intros)"], ["", "lemma wd_make_guess:\n  \"well_def make_guess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def make_guess", "unfolding make_guess_def guess_behind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def\n     (Apply\n       (guess_update\n         (\\<lambda>x.\n             1)) \\<^bsub>(\\<lambda>s.\n                             1 /\n                             3)\\<^esub>\\<oplus> Apply\n           (guess_update\n             (\\<lambda>x.\n                 2)) \\<^bsub>(\\<lambda>s.\n                                 1 /\n                                 2)\\<^esub>\\<oplus> Apply\n               (guess_update (\\<lambda>x. 3)))", "by(simp add:wd_intros)"], ["", "lemma wd_reveal:\n  \"well_def reveal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def reveal", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. well_def reveal", "txt \\<open>Here, we do need a subsidiary lemma: that there is always\n    a `fresh' door available.  The rest of the healthiness proof follows\n    as usual.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. well_def reveal", "have \"\\<And>s. {1, 2, 3} - {prize s, guess s} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. {1, 2, 3} - {prize s, guess s} \\<noteq> {}", "by(auto simp:insert_Diff_if)"], ["proof (state)\nthis:\n  {1, 2, 3} - {prize ?s, guess ?s} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. well_def reveal", "thus ?thesis"], ["proof (prove)\nusing this:\n  {1, 2, 3} - {prize ?s, guess ?s} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. well_def reveal", "unfolding reveal_def open_door_def"], ["proof (prove)\nusing this:\n  {1, 2, 3} - {prize ?s, guess ?s} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. well_def\n     (\\<Sqinter>d\\<in>\\<lambda>s. {1, 2, 3} - {prize s, guess s}.\n      Apply (clue_update (\\<lambda>x. d)))", "by(intro wd_intros, auto)"], ["proof (state)\nthis:\n  well_def reveal\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wd_switch_guess:\n  \"well_def switch_guess\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_def switch_guess", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. well_def switch_guess", "have \"\\<And>s. {1, 2, 3} - {clue s, guess s} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. {1, 2, 3} - {clue s, guess s} \\<noteq> {}", "by(auto simp:insert_Diff_if)"], ["proof (state)\nthis:\n  {1, 2, 3} - {clue ?s, guess ?s} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. well_def switch_guess", "thus ?thesis"], ["proof (prove)\nusing this:\n  {1, 2, 3} - {clue ?s, guess ?s} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. well_def switch_guess", "unfolding switch_guess_def guess_behind_def"], ["proof (prove)\nusing this:\n  {1, 2, 3} - {clue ?s, guess ?s} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. well_def\n     (\\<Sqinter>d\\<in>\\<lambda>s. {1, 2, 3} - {clue s, guess s}.\n      Apply (guess_update (\\<lambda>x. d)))", "by(intro wd_intros, auto)"], ["proof (state)\nthis:\n  well_def switch_guess\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas monty_healthy =\n  wd_switch_guess wd_reveal wd_make_guess wd_hide_prize"], ["", "subsubsection \\<open>Annotations\\<close>"], ["", "text \\<open>We now annotate each step individually, and then combine them to\n  produce an annotation for the entire program.\\<close>"], ["", "text \\<open>@{term hide_prize} chooses a valid door.\\<close>"], ["", "lemma wp_hide_prize:\n  \"(\\<lambda>s. 1) \\<tturnstile> wp hide_prize \\<guillemotleft>inv_prize\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       1 \\<tturnstile> wp hide_prize\n                        \\<guillemotleft> inv_prize \\<guillemotright>", "unfolding hide_prize_def hide_behind_def wp_eval o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       1 \\<tturnstile> \\<lambda>s.\n                          min (\\<guillemotleft> inv_prize \\<guillemotright>\n                                (s\\<lparr>prize := 1\\<rparr>))\n                           (min (\\<guillemotleft> inv_prize \\<guillemotright>\n                                  (s\\<lparr>prize := 2\\<rparr>))\n                             (\\<guillemotleft> inv_prize \\<guillemotright>\n                               (s\\<lparr>prize := 3\\<rparr>)))", "by(simp add:embed_bool_def inv_prize_def)"], ["", "text \\<open>Given the prize invariant, @{term make_guess} chooses a valid\n  door, and guesses incorrectly with probability at least 2/3.\\<close>"], ["", "lemma wp_make_guess:\n  \"(\\<lambda>s. 2/3 * \\<guillemotleft>\\<lambda>g. inv_prize g\\<guillemotright> s) \\<tturnstile>\n   wp make_guess \\<guillemotleft>\\<lambda>g. guess g \\<noteq> prize g \\<and> inv_prize g \\<and> inv_guess g\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       2 / 3 *\n       \\<guillemotleft> inv_prize \\<guillemotright>\n        s \\<tturnstile> wp make_guess\n                         \\<guillemotleft> \\<lambda>g.\n       guess g \\<noteq> prize g \\<and>\n       inv_prize g \\<and> inv_guess g \\<guillemotright>", "unfolding make_guess_def guess_behind_def wp_eval o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       2 / 3 *\n       \\<guillemotleft> inv_prize \\<guillemotright>\n        s \\<tturnstile> \\<lambda>s.\n                           1 / 3 *\n                           \\<guillemotleft> \\<lambda>g.\n         guess g \\<noteq> prize g \\<and>\n         inv_prize g \\<and> inv_guess g \\<guillemotright>\n                            (s\\<lparr>guess := 1\\<rparr>) +\n                           (1 - 1 / 3) *\n                           (1 / 2 *\n                            \\<guillemotleft> \\<lambda>g.\n          guess g \\<noteq> prize g \\<and>\n          inv_prize g \\<and> inv_guess g \\<guillemotright>\n                             (s\\<lparr>guess := 2\\<rparr>) +\n                            (1 - 1 / 2) *\n                            \\<guillemotleft> \\<lambda>g.\n          guess g \\<noteq> prize g \\<and>\n          inv_prize g \\<and> inv_guess g \\<guillemotright>\n                             (s\\<lparr>guess := 3\\<rparr>))", "by(auto simp:embed_bool_def inv_prize_def inv_guess_def)"], ["", "lemma last_one:\n  assumes \"a \\<noteq> b\" and \"a \\<in> {1::nat,2,3}\" and \"b \\<in> {1,2,3}\"\n  shows \"\\<exists>!c. {1,2,3} - {b,a} = {c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!c. {1, 2, 3} - {b, a} = {c}", "apply(simp add:insert_Diff_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a = 3 \\<longrightarrow>\n     b \\<noteq> 2 \\<longrightarrow>\n     (b = 3 \\<longrightarrow> (\\<exists>!c. Suc 0 = c \\<and> c = 2)) \\<and>\n     (b \\<noteq> 3 \\<longrightarrow>\n      Suc 0 \\<noteq> b \\<longrightarrow>\n      (\\<exists>!c. Suc 0 = c \\<and> c = 2))) \\<and>\n    (a \\<noteq> 3 \\<longrightarrow>\n     (b = 2 \\<longrightarrow>\n      (a = 2 \\<longrightarrow> (\\<exists>!c. Suc 0 = c \\<and> c = 3)) \\<and>\n      (a \\<noteq> 2 \\<longrightarrow>\n       Suc 0 \\<noteq> a \\<longrightarrow>\n       (\\<exists>!c. Suc 0 = c \\<and> c = 3))) \\<and>\n     (b \\<noteq> 2 \\<longrightarrow>\n      (b = 3 \\<longrightarrow>\n       a \\<noteq> 2 \\<longrightarrow>\n       Suc 0 \\<noteq> a \\<longrightarrow>\n       (\\<exists>!c. Suc 0 = c \\<and> c = 2)) \\<and>\n      (b \\<noteq> 3 \\<longrightarrow>\n       (a = 2 \\<longrightarrow>\n        Suc 0 \\<noteq> b \\<longrightarrow>\n        (\\<exists>!c. Suc 0 = c \\<and> c = 3)) \\<and>\n       (a \\<noteq> 2 \\<longrightarrow>\n        (Suc 0 = b \\<longrightarrow>\n         (\\<exists>!c. c = 2 \\<and> c = 3)) \\<and>\n        (Suc 0 = a \\<longrightarrow>\n         (\\<exists>!c. c = 2 \\<and> c = 3)) \\<and>\n        (Suc 0 \\<noteq> b \\<and> Suc 0 \\<noteq> a \\<longrightarrow>\n         (\\<exists>!c. Suc 0 = c \\<and> c = 2 \\<and> c = 3))))))", "using assms"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  a \\<in> {1, 2, 3}\n  b \\<in> {1, 2, 3}\n\ngoal (1 subgoal):\n 1. (a = 3 \\<longrightarrow>\n     b \\<noteq> 2 \\<longrightarrow>\n     (b = 3 \\<longrightarrow> (\\<exists>!c. Suc 0 = c \\<and> c = 2)) \\<and>\n     (b \\<noteq> 3 \\<longrightarrow>\n      Suc 0 \\<noteq> b \\<longrightarrow>\n      (\\<exists>!c. Suc 0 = c \\<and> c = 2))) \\<and>\n    (a \\<noteq> 3 \\<longrightarrow>\n     (b = 2 \\<longrightarrow>\n      (a = 2 \\<longrightarrow> (\\<exists>!c. Suc 0 = c \\<and> c = 3)) \\<and>\n      (a \\<noteq> 2 \\<longrightarrow>\n       Suc 0 \\<noteq> a \\<longrightarrow>\n       (\\<exists>!c. Suc 0 = c \\<and> c = 3))) \\<and>\n     (b \\<noteq> 2 \\<longrightarrow>\n      (b = 3 \\<longrightarrow>\n       a \\<noteq> 2 \\<longrightarrow>\n       Suc 0 \\<noteq> a \\<longrightarrow>\n       (\\<exists>!c. Suc 0 = c \\<and> c = 2)) \\<and>\n      (b \\<noteq> 3 \\<longrightarrow>\n       (a = 2 \\<longrightarrow>\n        Suc 0 \\<noteq> b \\<longrightarrow>\n        (\\<exists>!c. Suc 0 = c \\<and> c = 3)) \\<and>\n       (a \\<noteq> 2 \\<longrightarrow>\n        (Suc 0 = b \\<longrightarrow>\n         (\\<exists>!c. c = 2 \\<and> c = 3)) \\<and>\n        (Suc 0 = a \\<longrightarrow>\n         (\\<exists>!c. c = 2 \\<and> c = 3)) \\<and>\n        (Suc 0 \\<noteq> b \\<and> Suc 0 \\<noteq> a \\<longrightarrow>\n         (\\<exists>!c. Suc 0 = c \\<and> c = 2 \\<and> c = 3))))))", "by(auto intro:assms)"], ["", "text \\<open>Given the composed invariants, and an incorrect guess, @{term reveal}\n  will give a clue that is neither the prize, nor the guess.\\<close>"], ["", "lemma wp_reveal:\n  \"\\<guillemotleft>\\<lambda>g. guess g \\<noteq> prize g \\<and> inv_prize g \\<and> inv_guess g\\<guillemotright> \\<tturnstile>\n   wp reveal \\<guillemotleft>\\<lambda>g. guess g \\<noteq> prize g \\<and>\n                  clue g \\<noteq> prize g \\<and>\n                  clue g \\<noteq> guess g \\<and>\n                  inv_prize g \\<and> inv_guess g \\<and> inv_clue g\\<guillemotright>\"\n  (is \"?X \\<tturnstile> wp reveal ?Y\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> \\<lambda>g.\n                        guess g \\<noteq> prize g \\<and>\n                        inv_prize g \\<and>\n                        inv_guess\n                         g \\<guillemotright> \\<tturnstile> wp reveal\n                      \\<guillemotleft> \\<lambda>g.\n    guess g \\<noteq> prize g \\<and>\n    clue g \\<noteq> prize g \\<and>\n    clue g \\<noteq> guess g \\<and>\n    inv_prize g \\<and> inv_guess g \\<and> inv_clue g \\<guillemotright>", "proof(rule use_premise, rule well_def_wp_healthy[OF wd_reveal], clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; inv_prize s; inv_guess s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp reveal\n                                  \\<guillemotleft> \\<lambda>a.\n                guess a \\<noteq> prize a \\<and>\n                clue a \\<noteq> prize a \\<and>\n                clue a \\<noteq> guess a \\<and>\n                inv_prize a \\<and>\n                inv_guess a \\<and> inv_clue a \\<guillemotright>\n                                  s", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; inv_prize s; inv_guess s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp reveal\n                                  \\<guillemotleft> \\<lambda>a.\n                guess a \\<noteq> prize a \\<and>\n                clue a \\<noteq> prize a \\<and>\n                clue a \\<noteq> guess a \\<and>\n                inv_prize a \\<and>\n                inv_guess a \\<and> inv_clue a \\<guillemotright>\n                                  s", "assume \"guess s \\<noteq> prize s\"\n     and \"inv_prize s\"\n     and \"inv_guess s\""], ["proof (state)\nthis:\n  guess s \\<noteq> prize s\n  inv_prize s\n  inv_guess s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; inv_prize s; inv_guess s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp reveal\n                                  \\<guillemotleft> \\<lambda>a.\n                guess a \\<noteq> prize a \\<and>\n                clue a \\<noteq> prize a \\<and>\n                clue a \\<noteq> guess a \\<and>\n                inv_prize a \\<and>\n                inv_guess a \\<and> inv_clue a \\<guillemotright>\n                                  s", "moreover"], ["proof (state)\nthis:\n  guess s \\<noteq> prize s\n  inv_prize s\n  inv_guess s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; inv_prize s; inv_guess s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp reveal\n                                  \\<guillemotleft> \\<lambda>a.\n                guess a \\<noteq> prize a \\<and>\n                clue a \\<noteq> prize a \\<and>\n                clue a \\<noteq> guess a \\<and>\n                inv_prize a \\<and>\n                inv_guess a \\<and> inv_clue a \\<guillemotright>\n                                  s", "then"], ["proof (chain)\npicking this:\n  guess s \\<noteq> prize s\n  inv_prize s\n  inv_guess s", "obtain c\n    where singleton: \"{Suc 0,2,3} -  {prize s, guess s} = {c}\"\n      and \"c \\<noteq> prize s\"\n      and \"c \\<noteq> guess s\"\n      and \"c \\<in> {Suc 0,2,3}\""], ["proof (prove)\nusing this:\n  guess s \\<noteq> prize s\n  inv_prize s\n  inv_guess s\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>{Suc 0, 2, 3} - {prize s, guess s} = {c};\n         c \\<noteq> prize s; c \\<noteq> guess s;\n         c \\<in> {Suc 0, 2, 3}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding inv_prize_def inv_guess_def"], ["proof (prove)\nusing this:\n  guess s \\<noteq> prize s\n  prize s \\<in> {1, 2, 3}\n  guess s \\<in> {1, 2, 3}\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>{Suc 0, 2, 3} - {prize s, guess s} = {c};\n         c \\<noteq> prize s; c \\<noteq> guess s;\n         c \\<in> {Suc 0, 2, 3}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(force dest:last_one elim!:ex1E)"], ["proof (state)\nthis:\n  {Suc 0, 2, 3} - {prize s, guess s} = {c}\n  c \\<noteq> prize s\n  c \\<noteq> guess s\n  c \\<in> {Suc 0, 2, 3}\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; inv_prize s; inv_guess s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp reveal\n                                  \\<guillemotleft> \\<lambda>a.\n                guess a \\<noteq> prize a \\<and>\n                clue a \\<noteq> prize a \\<and>\n                clue a \\<noteq> guess a \\<and>\n                inv_prize a \\<and>\n                inv_guess a \\<and> inv_clue a \\<guillemotright>\n                                  s", "ultimately"], ["proof (chain)\npicking this:\n  guess s \\<noteq> prize s\n  inv_prize s\n  inv_guess s\n  {Suc 0, 2, 3} - {prize s, guess s} = {c}\n  c \\<noteq> prize s\n  c \\<noteq> guess s\n  c \\<in> {Suc 0, 2, 3}", "show \"1 \\<le> wp reveal ?Y s\""], ["proof (prove)\nusing this:\n  guess s \\<noteq> prize s\n  inv_prize s\n  inv_guess s\n  {Suc 0, 2, 3} - {prize s, guess s} = {c}\n  c \\<noteq> prize s\n  c \\<noteq> guess s\n  c \\<in> {Suc 0, 2, 3}\n\ngoal (1 subgoal):\n 1. 1 \\<le> wp reveal\n             \\<guillemotleft> \\<lambda>g.\n                                 guess g \\<noteq> prize g \\<and>\n                                 clue g \\<noteq> prize g \\<and>\n                                 clue g \\<noteq> guess g \\<and>\n                                 inv_prize g \\<and>\n                                 inv_guess g \\<and>\n                                 inv_clue g \\<guillemotright>\n             s", "by(simp add:reveal_def open_door_def wp_eval singleton o_def\n                embed_bool_def inv_prize_def inv_guess_def inv_clue_def)"], ["proof (state)\nthis:\n  1 \\<le> wp reveal\n           \\<guillemotleft> \\<lambda>g.\n                               guess g \\<noteq> prize g \\<and>\n                               clue g \\<noteq> prize g \\<and>\n                               clue g \\<noteq> guess g \\<and>\n                               inv_prize g \\<and>\n                               inv_guess g \\<and>\n                               inv_clue g \\<guillemotright>\n           s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Showing that the three doors are all district is a largeish\n  first-order problem, for which sledgehammer gives us a reasonable\n  script.\\<close>"], ["", "lemma distinct_game:\n  \"\\<lbrakk> guess g \\<noteq> prize g; clue g \\<noteq> prize g; clue g \\<noteq> guess g;\n     inv_prize g; inv_guess g; inv_clue g \\<rbrakk> \\<Longrightarrow> \n   {1, 2, 3} = {guess g, prize g, clue g}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>guess g \\<noteq> prize g; clue g \\<noteq> prize g;\n     clue g \\<noteq> guess g; inv_prize g; inv_guess g; inv_clue g\\<rbrakk>\n    \\<Longrightarrow> {1, 2, 3} = {guess g, prize g, clue g}", "unfolding inv_prize_def inv_guess_def inv_clue_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>guess g \\<noteq> prize g; clue g \\<noteq> prize g;\n     clue g \\<noteq> guess g; prize g \\<in> {1, 2, 3};\n     guess g \\<in> {1, 2, 3}; clue g \\<in> {1, 2, 3}\\<rbrakk>\n    \\<Longrightarrow> {1, 2, 3} = {guess g, prize g, clue g}", "apply(rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>guess g \\<noteq> prize g; clue g \\<noteq> prize g;\n        clue g \\<noteq> guess g; prize g \\<in> {1, 2, 3};\n        guess g \\<in> {1, 2, 3}; clue g \\<in> {1, 2, 3}\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> {1, 2, 3}) =\n                         (x \\<in> {guess g, prize g, clue g})", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>guess g \\<noteq> prize g; clue g \\<noteq> prize g;\n        clue g \\<noteq> guess g; prize g \\<in> {1, 2, 3};\n        guess g \\<in> {1, 2, 3}; clue g \\<in> {1, 2, 3};\n        x \\<in> {1, 2, 3}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {guess g, prize g, clue g}\n 2. \\<And>x.\n       \\<lbrakk>guess g \\<noteq> prize g; clue g \\<noteq> prize g;\n        clue g \\<noteq> guess g; prize g \\<in> {1, 2, 3};\n        guess g \\<in> {1, 2, 3}; clue g \\<in> {1, 2, 3};\n        x \\<in> {guess g, prize g, clue g}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {1, 2, 3}", "apply(clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>guess g \\<noteq> prize g; clue g \\<noteq> prize g;\n        clue g \\<noteq> guess g; prize g \\<in> {1, 2, 3};\n        guess g \\<in> {1, 2, 3}; clue g \\<in> {1, 2, 3}; x \\<in> {1, 2, 3};\n        x \\<noteq> guess g; x \\<noteq> prize g; x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> x = clue g\n 2. \\<And>x.\n       \\<lbrakk>guess g \\<noteq> prize g; clue g \\<noteq> prize g;\n        clue g \\<noteq> guess g; prize g \\<in> {1, 2, 3};\n        guess g \\<in> {1, 2, 3}; clue g \\<in> {1, 2, 3};\n        x \\<in> {guess g, prize g, clue g}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {1, 2, 3}", "apply(metis (full_types) empty_iff insert_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>guess g \\<noteq> prize g; clue g \\<noteq> prize g;\n        clue g \\<noteq> guess g; prize g \\<in> {1, 2, 3};\n        guess g \\<in> {1, 2, 3}; clue g \\<in> {1, 2, 3};\n        x \\<in> {guess g, prize g, clue g}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {1, 2, 3}", "apply(metis insert_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Given the invariants, switching from the wrong guess gives\n  the right one.\\<close>"], ["", "lemma wp_switch_guess:\n  \"\\<guillemotleft>\\<lambda>g. guess g \\<noteq> prize g \\<and> clue g \\<noteq> prize g \\<and> clue g \\<noteq> guess g \\<and>\n        inv_prize g \\<and> inv_guess g \\<and> inv_clue g\\<guillemotright> \\<tturnstile>\n   wp switch_guess \\<guillemotleft>player_wins\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft> \\<lambda>g.\n                        guess g \\<noteq> prize g \\<and>\n                        clue g \\<noteq> prize g \\<and>\n                        clue g \\<noteq> guess g \\<and>\n                        inv_prize g \\<and>\n                        inv_guess g \\<and>\n                        inv_clue\n                         g \\<guillemotright> \\<tturnstile> wp switch_guess\n                      \\<guillemotleft> player_wins \\<guillemotright>", "proof(rule use_premise, safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. healthy (wp switch_guess)\n 2. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; clue s \\<noteq> prize s;\n        clue s \\<noteq> guess s; inv_prize s; inv_guess s;\n        inv_clue s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp switch_guess\n                                  \\<guillemotleft> player_wins \\<guillemotright>\n                                  s", "from wd_switch_guess"], ["proof (chain)\npicking this:\n  well_def switch_guess", "show \"healthy (wp switch_guess)\""], ["proof (prove)\nusing this:\n  well_def switch_guess\n\ngoal (1 subgoal):\n 1. healthy (wp switch_guess)", "by(auto)"], ["proof (state)\nthis:\n  healthy (wp switch_guess)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; clue s \\<noteq> prize s;\n        clue s \\<noteq> guess s; inv_prize s; inv_guess s;\n        inv_clue s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp switch_guess\n                                  \\<guillemotleft> player_wins \\<guillemotright>\n                                  s", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; clue s \\<noteq> prize s;\n        clue s \\<noteq> guess s; inv_prize s; inv_guess s;\n        inv_clue s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp switch_guess\n                                  \\<guillemotleft> player_wins \\<guillemotright>\n                                  s", "assume \"guess s \\<noteq> prize s\" and \"clue s \\<noteq> prize s\"\n     and \"clue s \\<noteq> guess s\" and \"inv_prize s\"\n     and \"inv_guess s\" and \"inv_clue s\""], ["proof (state)\nthis:\n  guess s \\<noteq> prize s\n  clue s \\<noteq> prize s\n  clue s \\<noteq> guess s\n  inv_prize s\n  inv_guess s\n  inv_clue s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; clue s \\<noteq> prize s;\n        clue s \\<noteq> guess s; inv_prize s; inv_guess s;\n        inv_clue s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp switch_guess\n                                  \\<guillemotleft> player_wins \\<guillemotright>\n                                  s", "note state = this"], ["proof (state)\nthis:\n  guess s \\<noteq> prize s\n  clue s \\<noteq> prize s\n  clue s \\<noteq> guess s\n  inv_prize s\n  inv_guess s\n  inv_clue s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; clue s \\<noteq> prize s;\n        clue s \\<noteq> guess s; inv_prize s; inv_guess s;\n        inv_clue s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp switch_guess\n                                  \\<guillemotleft> player_wins \\<guillemotright>\n                                  s", "hence \"1 \\<le> Inf ((\\<lambda>a. \\<guillemotleft> player_wins \\<guillemotright> (s\\<lparr>guess := a\\<rparr>)) `\n    ({guess s, prize s, clue s} - {clue s, guess s}))\""], ["proof (prove)\nusing this:\n  guess s \\<noteq> prize s\n  clue s \\<noteq> prize s\n  clue s \\<noteq> guess s\n  inv_prize s\n  inv_guess s\n  inv_clue s\n\ngoal (1 subgoal):\n 1. 1 \\<le> (INF a\\<in>{guess s, prize s, clue s} - {clue s, guess s}.\n                \\<guillemotleft> player_wins \\<guillemotright>\n                 (s\\<lparr>guess := a\\<rparr>))", "by(auto simp:insert_Diff_if player_wins_def)"], ["proof (state)\nthis:\n  1 \\<le> (INF a\\<in>{guess s, prize s, clue s} - {clue s, guess s}.\n              \\<guillemotleft> player_wins \\<guillemotright>\n               (s\\<lparr>guess := a\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; clue s \\<noteq> prize s;\n        clue s \\<noteq> guess s; inv_prize s; inv_guess s;\n        inv_clue s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp switch_guess\n                                  \\<guillemotleft> player_wins \\<guillemotright>\n                                  s", "also"], ["proof (state)\nthis:\n  1 \\<le> (INF a\\<in>{guess s, prize s, clue s} - {clue s, guess s}.\n              \\<guillemotleft> player_wins \\<guillemotright>\n               (s\\<lparr>guess := a\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; clue s \\<noteq> prize s;\n        clue s \\<noteq> guess s; inv_prize s; inv_guess s;\n        inv_clue s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp switch_guess\n                                  \\<guillemotleft> player_wins \\<guillemotright>\n                                  s", "from state"], ["proof (chain)\npicking this:\n  guess s \\<noteq> prize s\n  clue s \\<noteq> prize s\n  clue s \\<noteq> guess s\n  inv_prize s\n  inv_guess s\n  inv_clue s", "have \"... = Inf ((\\<lambda>a. \\<guillemotleft> player_wins \\<guillemotright> (s\\<lparr>guess := a\\<rparr>)) `\n                  ({1, 2, 3} - {clue s, guess s}))\""], ["proof (prove)\nusing this:\n  guess s \\<noteq> prize s\n  clue s \\<noteq> prize s\n  clue s \\<noteq> guess s\n  inv_prize s\n  inv_guess s\n  inv_clue s\n\ngoal (1 subgoal):\n 1. (INF a\\<in>{guess s, prize s, clue s} - {clue s, guess s}.\n        \\<guillemotleft> player_wins \\<guillemotright>\n         (s\\<lparr>guess := a\\<rparr>)) =\n    (INF a\\<in>{1, 2, 3} - {clue s, guess s}.\n        \\<guillemotleft> player_wins \\<guillemotright>\n         (s\\<lparr>guess := a\\<rparr>))", "by(simp add:distinct_game[symmetric])"], ["proof (state)\nthis:\n  (INF a\\<in>{guess s, prize s, clue s} - {clue s, guess s}.\n      \\<guillemotleft> player_wins \\<guillemotright>\n       (s\\<lparr>guess := a\\<rparr>)) =\n  (INF a\\<in>{1, 2, 3} - {clue s, guess s}.\n      \\<guillemotleft> player_wins \\<guillemotright>\n       (s\\<lparr>guess := a\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; clue s \\<noteq> prize s;\n        clue s \\<noteq> guess s; inv_prize s; inv_guess s;\n        inv_clue s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp switch_guess\n                                  \\<guillemotleft> player_wins \\<guillemotright>\n                                  s", "also"], ["proof (state)\nthis:\n  (INF a\\<in>{guess s, prize s, clue s} - {clue s, guess s}.\n      \\<guillemotleft> player_wins \\<guillemotright>\n       (s\\<lparr>guess := a\\<rparr>)) =\n  (INF a\\<in>{1, 2, 3} - {clue s, guess s}.\n      \\<guillemotleft> player_wins \\<guillemotright>\n       (s\\<lparr>guess := a\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; clue s \\<noteq> prize s;\n        clue s \\<noteq> guess s; inv_prize s; inv_guess s;\n        inv_clue s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp switch_guess\n                                  \\<guillemotleft> player_wins \\<guillemotright>\n                                  s", "have \"... = wp switch_guess \\<guillemotleft>player_wins\\<guillemotright> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF a\\<in>{1, 2, 3} - {clue s, guess s}.\n        \\<guillemotleft> player_wins \\<guillemotright>\n         (s\\<lparr>guess := a\\<rparr>)) =\n    wp switch_guess \\<guillemotleft> player_wins \\<guillemotright> s", "by(simp add:switch_guess_def guess_behind_def wp_eval o_def)"], ["proof (state)\nthis:\n  (INF a\\<in>{1, 2, 3} - {clue s, guess s}.\n      \\<guillemotleft> player_wins \\<guillemotright>\n       (s\\<lparr>guess := a\\<rparr>)) =\n  wp switch_guess \\<guillemotleft> player_wins \\<guillemotright> s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>guess s \\<noteq> prize s; clue s \\<noteq> prize s;\n        clue s \\<noteq> guess s; inv_prize s; inv_guess s;\n        inv_clue s\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> wp switch_guess\n                                  \\<guillemotleft> player_wins \\<guillemotright>\n                                  s", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> wp switch_guess \\<guillemotleft> player_wins \\<guillemotright> s", "show \"1 \\<le> wp switch_guess \\<guillemotleft> player_wins \\<guillemotright> s\""], ["proof (prove)\nusing this:\n  1 \\<le> wp switch_guess \\<guillemotleft> player_wins \\<guillemotright> s\n\ngoal (1 subgoal):\n 1. 1 \\<le> wp switch_guess \\<guillemotleft> player_wins \\<guillemotright> s", "."], ["proof (state)\nthis:\n  1 \\<le> wp switch_guess \\<guillemotleft> player_wins \\<guillemotright> s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Given componentwise specifications, we can glue them together\nwith calculational reasoning to get our result.\\<close>"], ["", "lemma wp_monty_switch_modular:\n  \"(\\<lambda>s. 2/3) \\<tturnstile> wp (monty True) \\<guillemotleft>player_wins\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       2 /\n       3 \\<tturnstile> wp (monty True)\n                        \\<guillemotleft> player_wins \\<guillemotright>", "proof(rule wp_validD)  \\<comment> \\<open>Work in probabilistic Hoare triples\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                2 /\n                3\\<rbrace> monty\n                            True \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p", "note wp_validI[OF wp_scale, OF wp_hide_prize, simplified]\n    \\<comment> \\<open>Here we apply scaling to match our pre-expectation\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>well_def hide_prize; 0 \\<le> ?c1\\<rbrakk>\n  \\<Longrightarrow> \\<lbrace>\\<lambda>s.\n                                ?c1\\<rbrace> hide_prize \\<lbrace>\\<lambda>s.\n                              ?c1 *\n                              \\<guillemotleft> inv_prize \\<guillemotright>\n                               s\\<rbrace>p\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                2 /\n                3\\<rbrace> monty\n                            True \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p", "also"], ["proof (state)\nthis:\n  \\<lbrakk>well_def hide_prize; 0 \\<le> ?c1\\<rbrakk>\n  \\<Longrightarrow> \\<lbrace>\\<lambda>s.\n                                ?c1\\<rbrace> hide_prize \\<lbrace>\\<lambda>s.\n                              ?c1 *\n                              \\<guillemotleft> inv_prize \\<guillemotright>\n                               s\\<rbrace>p\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                2 /\n                3\\<rbrace> monty\n                            True \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p", "note wp_validI[OF wp_make_guess]"], ["proof (state)\nthis:\n  \\<lbrace>\\<lambda>s.\n              2 / 3 *\n              \\<guillemotleft> inv_prize \\<guillemotright>\n               s\\<rbrace> make_guess \\<lbrace>\\<guillemotleft> \\<lambda>g.\n                            guess g \\<noteq> prize g \\<and>\n                            inv_prize g \\<and>\n                            inv_guess g \\<guillemotright>\\<rbrace>p\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                2 /\n                3\\<rbrace> monty\n                            True \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p", "also"], ["proof (state)\nthis:\n  \\<lbrace>\\<lambda>s.\n              2 / 3 *\n              \\<guillemotleft> inv_prize \\<guillemotright>\n               s\\<rbrace> make_guess \\<lbrace>\\<guillemotleft> \\<lambda>g.\n                            guess g \\<noteq> prize g \\<and>\n                            inv_prize g \\<and>\n                            inv_guess g \\<guillemotright>\\<rbrace>p\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                2 /\n                3\\<rbrace> monty\n                            True \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p", "note wp_validI[OF wp_reveal]"], ["proof (state)\nthis:\n  \\<lbrace>\\<guillemotleft> \\<lambda>g.\n                               guess g \\<noteq> prize g \\<and>\n                               inv_prize g \\<and>\n                               inv_guess\n                                g \\<guillemotright>\\<rbrace> reveal \\<lbrace>\\<guillemotleft> \\<lambda>g.\n                     guess g \\<noteq> prize g \\<and>\n                     clue g \\<noteq> prize g \\<and>\n                     clue g \\<noteq> guess g \\<and>\n                     inv_prize g \\<and>\n                     inv_guess g \\<and>\n                     inv_clue g \\<guillemotright>\\<rbrace>p\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                2 /\n                3\\<rbrace> monty\n                            True \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p", "also"], ["proof (state)\nthis:\n  \\<lbrace>\\<guillemotleft> \\<lambda>g.\n                               guess g \\<noteq> prize g \\<and>\n                               inv_prize g \\<and>\n                               inv_guess\n                                g \\<guillemotright>\\<rbrace> reveal \\<lbrace>\\<guillemotleft> \\<lambda>g.\n                     guess g \\<noteq> prize g \\<and>\n                     clue g \\<noteq> prize g \\<and>\n                     clue g \\<noteq> guess g \\<and>\n                     inv_prize g \\<and>\n                     inv_guess g \\<and>\n                     inv_clue g \\<guillemotright>\\<rbrace>p\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                2 /\n                3\\<rbrace> monty\n                            True \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p", "note wp_validI[OF wp_switch_guess]"], ["proof (state)\nthis:\n  \\<lbrace>\\<guillemotleft> \\<lambda>g.\n                               guess g \\<noteq> prize g \\<and>\n                               clue g \\<noteq> prize g \\<and>\n                               clue g \\<noteq> guess g \\<and>\n                               inv_prize g \\<and>\n                               inv_guess g \\<and>\n                               inv_clue\n                                g \\<guillemotright>\\<rbrace> switch_guess \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                2 /\n                3\\<rbrace> monty\n                            True \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>well_def hide_prize; 0 \\<le> 2 / 3; well_def hide_prize;\n   well_def make_guess;\n   sound\n    (\\<lambda>s. 2 / 3 * \\<guillemotleft> inv_prize \\<guillemotright> s);\n   sound\n    \\<guillemotleft> \\<lambda>g.\n                        guess g \\<noteq> prize g \\<and>\n                        inv_prize g \\<and> inv_guess g \\<guillemotright>;\n   well_def (hide_prize ;; make_guess); well_def reveal;\n   sound\n    \\<guillemotleft> \\<lambda>g.\n                        guess g \\<noteq> prize g \\<and>\n                        inv_prize g \\<and> inv_guess g \\<guillemotright>;\n   sound\n    \\<guillemotleft> \\<lambda>g.\n                        guess g \\<noteq> prize g \\<and>\n                        clue g \\<noteq> prize g \\<and>\n                        clue g \\<noteq> guess g \\<and>\n                        inv_prize g \\<and>\n                        inv_guess g \\<and> inv_clue g \\<guillemotright>;\n   well_def (hide_prize ;; make_guess ;; reveal); well_def switch_guess;\n   sound\n    \\<guillemotleft> \\<lambda>g.\n                        guess g \\<noteq> prize g \\<and>\n                        clue g \\<noteq> prize g \\<and>\n                        clue g \\<noteq> guess g \\<and>\n                        inv_prize g \\<and>\n                        inv_guess g \\<and> inv_clue g \\<guillemotright>;\n   sound \\<guillemotleft> player_wins \\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<lbrace>\\<lambda>s.\n                                2 /\n                                3\\<rbrace> hide_prize ;; make_guess ;;\n     reveal ;;\n     switch_guess \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p", "show \"\\<lbrace>\\<lambda>s. 2/3\\<rbrace> monty True \\<lbrace>\\<guillemotleft>player_wins\\<guillemotright>\\<rbrace>p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>well_def hide_prize; 0 \\<le> 2 / 3; well_def hide_prize;\n   well_def make_guess;\n   sound\n    (\\<lambda>s. 2 / 3 * \\<guillemotleft> inv_prize \\<guillemotright> s);\n   sound\n    \\<guillemotleft> \\<lambda>g.\n                        guess g \\<noteq> prize g \\<and>\n                        inv_prize g \\<and> inv_guess g \\<guillemotright>;\n   well_def (hide_prize ;; make_guess); well_def reveal;\n   sound\n    \\<guillemotleft> \\<lambda>g.\n                        guess g \\<noteq> prize g \\<and>\n                        inv_prize g \\<and> inv_guess g \\<guillemotright>;\n   sound\n    \\<guillemotleft> \\<lambda>g.\n                        guess g \\<noteq> prize g \\<and>\n                        clue g \\<noteq> prize g \\<and>\n                        clue g \\<noteq> guess g \\<and>\n                        inv_prize g \\<and>\n                        inv_guess g \\<and> inv_clue g \\<guillemotright>;\n   well_def (hide_prize ;; make_guess ;; reveal); well_def switch_guess;\n   sound\n    \\<guillemotleft> \\<lambda>g.\n                        guess g \\<noteq> prize g \\<and>\n                        clue g \\<noteq> prize g \\<and>\n                        clue g \\<noteq> guess g \\<and>\n                        inv_prize g \\<and>\n                        inv_guess g \\<and> inv_clue g \\<guillemotright>;\n   sound \\<guillemotleft> player_wins \\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<lbrace>\\<lambda>s.\n                                2 /\n                                3\\<rbrace> hide_prize ;; make_guess ;;\n     reveal ;;\n     switch_guess \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                2 /\n                3\\<rbrace> monty\n                            True \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p", "unfolding monty_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>well_def hide_prize; 0 \\<le> 2 / 3; well_def hide_prize;\n   well_def make_guess;\n   sound\n    (\\<lambda>s. 2 / 3 * \\<guillemotleft> inv_prize \\<guillemotright> s);\n   sound\n    \\<guillemotleft> \\<lambda>g.\n                        guess g \\<noteq> prize g \\<and>\n                        inv_prize g \\<and> inv_guess g \\<guillemotright>;\n   well_def (hide_prize ;; make_guess); well_def reveal;\n   sound\n    \\<guillemotleft> \\<lambda>g.\n                        guess g \\<noteq> prize g \\<and>\n                        inv_prize g \\<and> inv_guess g \\<guillemotright>;\n   sound\n    \\<guillemotleft> \\<lambda>g.\n                        guess g \\<noteq> prize g \\<and>\n                        clue g \\<noteq> prize g \\<and>\n                        clue g \\<noteq> guess g \\<and>\n                        inv_prize g \\<and>\n                        inv_guess g \\<and> inv_clue g \\<guillemotright>;\n   well_def (hide_prize ;; make_guess ;; reveal); well_def switch_guess;\n   sound\n    \\<guillemotleft> \\<lambda>g.\n                        guess g \\<noteq> prize g \\<and>\n                        clue g \\<noteq> prize g \\<and>\n                        clue g \\<noteq> guess g \\<and>\n                        inv_prize g \\<and>\n                        inv_guess g \\<and> inv_clue g \\<guillemotright>;\n   sound \\<guillemotleft> player_wins \\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<lbrace>\\<lambda>s.\n                                2 /\n                                3\\<rbrace> hide_prize ;; make_guess ;;\n     reveal ;;\n     switch_guess \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                2 /\n                3\\<rbrace> hide_prize ;; make_guess ;; reveal ;;\n                           (if True then switch_guess\n                            else Skip) \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p", "by(simp add:wd_intros sound_intros monty_healthy)"], ["proof (state)\nthis:\n  \\<lbrace>\\<lambda>s.\n              2 /\n              3\\<rbrace> monty\n                          True \\<lbrace>\\<guillemotleft> player_wins \\<guillemotright>\\<rbrace>p\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Using the VCG\\<close>"], ["", "lemmas scaled_hide = wp_scale[OF wp_hide_prize, simplified]"], ["", "declare scaled_hide[pwp] wp_make_guess[pwp] wp_reveal[pwp] wp_switch_guess[pwp]"], ["", "declare wd_hide_prize[wd] wd_make_guess[wd] wd_reveal[wd] wd_switch_guess[wd]"], ["", "text \\<open>Alternatively, the VCG will get this using the same annotations.\\<close>"], ["", "lemma wp_monty_switch_vcg:\n  \"(\\<lambda>s. 2/3) \\<tturnstile> wp (monty True) \\<guillemotleft>player_wins\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       2 /\n       3 \\<tturnstile> wp (monty True)\n                        \\<guillemotleft> player_wins \\<guillemotright>", "unfolding monty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       2 /\n       3 \\<tturnstile> wp (hide_prize ;; make_guess ;; reveal ;;\n                           (if True then switch_guess else Skip))\n                        \\<guillemotleft> player_wins \\<guillemotright>", "by(simp, pvcg)"], ["", "end"]]}