{"file_name": "/home/qj213/afp-2021-10-22/thys/Show/Show_Instances.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Show", "problem_names": ["lemma show_law_unit [show_law_intros]:\n  \"show_law showsp_unit x\"", "lemma show_law_char [show_law_intros]:\n  \"show_law showsp_char x\"", "lemma show_law_bool [show_law_intros]:\n  \"show_law showsp_bool x\"", "lemma showsp_prod_simps [simp, code]:\n  \"showsp_prod s1 s2 p (x, y) =\n    shows_string ''('' o s1 1 x o shows_string '', '' o s2 1 y o shows_string '')''\"", "lemma show_law_prod [show_law_intros]:\n  \"(\\<And>x. x \\<in> Basic_BNFs.fsts y \\<Longrightarrow> show_law s1 x) \\<Longrightarrow>\n   (\\<And>x. x \\<in> Basic_BNFs.snds y \\<Longrightarrow> show_law s2 x) \\<Longrightarrow>\n    show_law (showsp_prod s1 s2) y\"", "lemma show_law_nat [show_law_intros]:\n  \"show_law showsp_nat n\"", "lemma showsp_nat_append [show_law_simps]:\n  \"showsp_nat p n (x @ y) = showsp_nat p n x @ y\"", "lemma show_law_int [show_law_intros]:\n  \"show_law showsp_int i\"", "lemma showsp_int_append [show_law_simps]:\n  \"showsp_int p i (x @ y) = showsp_int p i x @ y\"", "lemma show_law_rat [show_law_intros]:\n  \"show_law showsp_rat r\"", "lemma showsp_rat_append [show_law_simps]:\n  \"showsp_rat p r (x @ y) = showsp_rat p r x @ y\""], "translations": [["", "lemma show_law_unit [show_law_intros]:\n  \"show_law showsp_unit x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. show_law showsp_unit x", "by (rule show_lawI) (simp add: showsp_unit_def show_law_simps)"], ["", "abbreviation showsp_char :: \"char showsp\"\nwhere\n  \"showsp_char \\<equiv> shows_prec\""], ["", "lemma show_law_char [show_law_intros]:\n  \"show_law showsp_char x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. show_law showsp_char x", "by (rule show_lawI) (simp add: show_law_simps)"], ["", "primrec showsp_bool :: \"bool showsp\"\nwhere\n  \"showsp_bool p True = shows_string ''True''\" |\n  \"showsp_bool p False = shows_string ''False''\""], ["", "lemma show_law_bool [show_law_intros]:\n  \"show_law showsp_bool x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. show_law showsp_bool x", "by (rule show_lawI, cases x) (simp_all add: show_law_simps)"], ["", "primrec pshowsp_prod :: \"(shows \\<times> shows) showsp\"\nwhere\n  \"pshowsp_prod p (x, y) = shows_string ''('' o x o shows_string '', '' o y o shows_string '')''\""], ["", "(*NOTE: in order to be compatible with automatically generated show funtions,\nshow-arguments of \"map\"-functions need to get precedence 1 (which may lead to\nredundant parentheses in the output, but seems unavoidable in the current setup,\ni.e., pshowsp via primrec followed by defining showsp via pshowsp composed with map).*)"], ["", "definition showsp_prod :: \"'a showsp \\<Rightarrow> 'b showsp \\<Rightarrow> ('a \\<times> 'b) showsp\"\nwhere\n  [code del]: \"showsp_prod s1 s2 p = pshowsp_prod p o map_prod (s1 1) (s2 1)\""], ["", "lemma showsp_prod_simps [simp, code]:\n  \"showsp_prod s1 s2 p (x, y) =\n    shows_string ''('' o s1 1 x o shows_string '', '' o s2 1 y o shows_string '')''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. showsp_prod s1 s2 p (x, y) =\n    shows_string ''('' \\<circ> s1 1 x \\<circ> shows_string '', '' \\<circ>\n    s2 1 y \\<circ>\n    shows_string '')''", "by (simp add: showsp_prod_def)"], ["", "lemma show_law_prod [show_law_intros]:\n  \"(\\<And>x. x \\<in> Basic_BNFs.fsts y \\<Longrightarrow> show_law s1 x) \\<Longrightarrow>\n   (\\<And>x. x \\<in> Basic_BNFs.snds y \\<Longrightarrow> show_law s2 x) \\<Longrightarrow>\n    show_law (showsp_prod s1 s2) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> Basic_BNFs.fsts y \\<Longrightarrow> show_law s1 x;\n     \\<And>x.\n        x \\<in> Basic_BNFs.snds y \\<Longrightarrow> show_law s2 x\\<rbrakk>\n    \\<Longrightarrow> show_law (showsp_prod s1 s2) y", "proof (induct y)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> Basic_BNFs.fsts (a, b) \\<Longrightarrow>\n                   show_law s1 x;\n        \\<And>x.\n           x \\<in> Basic_BNFs.snds (a, b) \\<Longrightarrow>\n           show_law s2 x\\<rbrakk>\n       \\<Longrightarrow> show_law (showsp_prod s1 s2) (a, b)", "case (Pair x y)"], ["proof (state)\nthis:\n  ?x \\<in> Basic_BNFs.fsts (x, y) \\<Longrightarrow> show_law s1 ?x\n  ?x \\<in> Basic_BNFs.snds (x, y) \\<Longrightarrow> show_law s2 ?x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> Basic_BNFs.fsts (a, b) \\<Longrightarrow>\n                   show_law s1 x;\n        \\<And>x.\n           x \\<in> Basic_BNFs.snds (a, b) \\<Longrightarrow>\n           show_law s2 x\\<rbrakk>\n       \\<Longrightarrow> show_law (showsp_prod s1 s2) (a, b)", "note * = Pair [unfolded prod_set_simps]"], ["proof (state)\nthis:\n  ?x \\<in> {x} \\<Longrightarrow> show_law s1 ?x\n  ?x \\<in> {y} \\<Longrightarrow> show_law s2 ?x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> Basic_BNFs.fsts (a, b) \\<Longrightarrow>\n                   show_law s1 x;\n        \\<And>x.\n           x \\<in> Basic_BNFs.snds (a, b) \\<Longrightarrow>\n           show_law s2 x\\<rbrakk>\n       \\<Longrightarrow> show_law (showsp_prod s1 s2) (a, b)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. show_law (showsp_prod s1 s2) (x, y)", "by (rule show_lawI)\n       (auto simp del: o_apply intro!: o_append intro: show_lawD * simp: show_law_simps)"], ["proof (state)\nthis:\n  show_law (showsp_prod s1 s2) (x, y)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun string_of_digit :: \"nat \\<Rightarrow> string\"\nwhere\n  \"string_of_digit n =\n    (if n = 0 then ''0''\n    else if n = 1 then ''1''\n    else if n = 2 then ''2''\n    else if n = 3 then ''3''\n    else if n = 4 then ''4''\n    else if n = 5 then ''5''\n    else if n = 6 then ''6''\n    else if n = 7 then ''7''\n    else if n = 8 then ''8''\n    else ''9'')\""], ["", "fun showsp_nat :: \"nat showsp\"\nwhere\n  \"showsp_nat p n =\n    (if n < 10 then shows_string (string_of_digit n)\n    else showsp_nat p (n div 10) o shows_string (string_of_digit (n mod 10)))\""], ["", "declare showsp_nat.simps [simp del]"], ["", "lemma show_law_nat [show_law_intros]:\n  \"show_law showsp_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. show_law showsp_nat n", "by (rule show_lawI, induct n rule: nat_less_induct) (simp add: show_law_simps showsp_nat.simps)"], ["", "lemma showsp_nat_append [show_law_simps]:\n  \"showsp_nat p n (x @ y) = showsp_nat p n x @ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. showsp_nat p n (x @ y) = showsp_nat p n x @ y", "by (intro show_lawD show_law_intros)"], ["", "definition showsp_int :: \"int showsp\"\nwhere\n  \"showsp_int p i =\n    (if i < 0 then shows_string ''-'' o showsp_nat p (nat (- i)) else showsp_nat p (nat i))\""], ["", "lemma show_law_int [show_law_intros]:\n  \"show_law showsp_int i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. show_law showsp_int i", "by (rule show_lawI, cases \"i < 0\") (simp_all add: showsp_int_def show_law_simps)"], ["", "lemma showsp_int_append [show_law_simps]:\n  \"showsp_int p i (x @ y) = showsp_int p i x @ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. showsp_int p i (x @ y) = showsp_int p i x @ y", "by (intro show_lawD show_law_intros)"], ["", "definition showsp_rat :: \"rat showsp\"\nwhere\n  \"showsp_rat p x =\n    (case quotient_of x of (d, n) \\<Rightarrow>\n      if n = 1 then showsp_int p d else showsp_int p d o shows_string ''/'' o showsp_int p n)\""], ["", "lemma show_law_rat [show_law_intros]:\n  \"show_law showsp_rat r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. show_law showsp_rat r", "by (rule show_lawI, cases \"quotient_of r\") (simp add: showsp_rat_def show_law_simps)"], ["", "lemma showsp_rat_append [show_law_simps]:\n  \"showsp_rat p r (x @ y) = showsp_rat p r x @ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. showsp_rat p r (x @ y) = showsp_rat p r x @ y", "by (intro show_lawD show_law_intros)"], ["", "text \\<open>\n  Automatic show functions are not used for @{type unit}, @{type prod}, and numbers:\n  for @{type unit} and @{type prod}, we do not want to display @{term \"''Unity''\"} and\n  @{term \"''Pair''\"}; for @{type nat}, we do not want to display\n  @{term \"''Suc (Suc (... (Suc 0) ...))''\"}; and neither @{type int}\n  nor @{type rat} are datatypes.\n\\<close>"], ["", "local_setup \\<open>\n  Show_Generator.register_foreign_partial_and_full_showsp @{type_name prod} 0\n       @{term \"pshowsp_prod\"}\n       @{term \"showsp_prod\"} (SOME @{thm showsp_prod_def})\n       @{term \"map_prod\"} (SOME @{thm prod.map_comp}) [true, true]\n       @{thm show_law_prod}\n  #> Show_Generator.register_foreign_showsp @{typ unit} @{term \"showsp_unit\"} @{thm show_law_unit}\n  #> Show_Generator.register_foreign_showsp @{typ bool} @{term \"showsp_bool\"} @{thm show_law_bool}\n  #> Show_Generator.register_foreign_showsp @{typ char} @{term \"showsp_char\"} @{thm show_law_char}\n  #> Show_Generator.register_foreign_showsp @{typ nat} @{term \"showsp_nat\"} @{thm show_law_nat}\n  #> Show_Generator.register_foreign_showsp @{typ int} @{term \"showsp_int\"} @{thm show_law_int}\n  #> Show_Generator.register_foreign_showsp @{typ rat} @{term \"showsp_rat\"} @{thm show_law_rat}\n\\<close>"], ["", "derive \"show\" option sum prod unit bool nat int rat"], ["", "export_code\n  \"shows_prec :: 'a::show option showsp\"\n  \"shows_prec :: ('a::show, 'b::show) sum showsp\"\n  \"shows_prec :: ('a::show \\<times> 'b::show) showsp\"\n  \"shows_prec :: unit showsp\"\n  \"shows_prec :: char showsp\"\n  \"shows_prec :: bool showsp\"\n  \"shows_prec :: nat showsp\"\n  \"shows_prec :: int showsp\"\n  \"shows_prec :: rat showsp\"\n  checking"], ["", "end"]]}