{"file_name": "/home/qj213/afp-2021-10-22/thys/Show/Show.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Show", "problem_names": ["lemma show_lawI:\n  \"(\\<And>p y z. s p x (y @ z) = s p x y @ z) \\<Longrightarrow> show_law s x\"", "lemma show_lawE:\n  \"show_law s x \\<Longrightarrow> (s p x (y @ z) = s p x y @ z \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma show_lawD:\n  \"show_law s x \\<Longrightarrow> s p x (y @ z) = s p x y @ z\"", "lemma shows_string_append [show_law_simps]:\n  \"shows_string x (r @ s) = shows_string x r @ s\"", "lemma shows_sep_append [show_law_simps]:\n  assumes \"\\<And>r s. \\<forall>x \\<in> set xs. showsx x (r @ s) = showsx x r @ s\"\n    and \"\\<And>r s. sep (r @ s) = sep r @ s\"\n  shows \"shows_sep showsx sep xs (r @ s) = shows_sep showsx sep xs r @ s\"", "lemma shows_sep_map:\n  \"shows_sep f sep (map g xs) = shows_sep (f o g) sep xs\"", "lemma shows_list_gen_append [show_law_simps]:\n  assumes \"\\<And>r s. \\<forall>x\\<in>set xs. showsx x (r @ s) = showsx x r @ s\"\n  shows \"shows_list_gen showsx e l sep r xs (s @ t) = shows_list_gen showsx e l sep r xs s @ t\"", "lemma shows_list_gen_map:\n  \"shows_list_gen f e l sep r (map g xs) = shows_list_gen (f o g) e l sep r xs\"", "lemma showsp_list_code [code]:\n  \"showsp_list s p xs = shows_list_gen (s 0) ''[]'' ''['' '', '' '']'' xs\"", "lemma show_law_list [show_law_intros]:\n  \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> show_law s x) \\<Longrightarrow> show_law (showsp_list s) xs\"", "lemma showsp_list_append [show_law_simps]:\n  \"(\\<And>p y z. \\<forall>x \\<in> set xs. s p x (y @ z) = s p x y @ z) \\<Longrightarrow>\n    showsp_list s p xs (y @ z) = showsp_list s p xs y @ z\"", "lemma\n  shows_nl_append [show_law_simps]: \"shows_nl (x @ y) = shows_nl x @ y\" and\n  shows_space_append [show_law_simps]: \"shows_space (x @ y) = shows_space x @ y\" and\n  shows_paren_append [show_law_simps]:\n    \"(\\<And>x y. s (x @ y) = s x @ y) \\<Longrightarrow> shows_paren s (x @ y) = shows_paren s x @ y\" and\n  shows_quote_append [show_law_simps]:\n    \"(\\<And>x y. s (x @ y) = s x @ y) \\<Longrightarrow> shows_quote s (x @ y) = shows_quote s x @ y\" and\n  shows_pl_append [show_law_simps]: \"shows_pl p (x @ y) = shows_pl p x @ y\" and\n  shows_pr_append [show_law_simps]: \"shows_pr p (x @ y) = shows_pr p x @ y\"", "lemma o_append:\n  \"(\\<And>x y. f (x @ y) = f x @ y) \\<Longrightarrow> g (x @ y) = g x @ y \\<Longrightarrow> (f o g) (x @ y) = (f o g) x @ y\"", "lemma shows_lines_append [show_law_simps]:\n  \"shows_lines xs (r @ s) = shows_lines xs r @ s\"", "lemma shows_many_append [show_law_simps]:\n  \"shows_many xs (r @ s) = shows_many xs r @ s\"", "lemma shows_words_append [show_law_simps]:\n  \"shows_words xs (r @ s) = shows_words xs r @ s\"", "lemma shows_foldr_append [show_law_simps]:\n  assumes \"\\<And>r s. \\<forall>x \\<in> set xs. showx x (r @ s) = showx x r @ s\"\n  shows \"foldr showx xs (r @ s) = foldr showx xs r @ s\"", "lemma shows_sep_cong [fundef_cong]:\n  assumes \"xs = ys\" and \"\\<And>x. x \\<in> set ys \\<Longrightarrow> f x = g x\"\n  shows \"shows_sep f sep xs = shows_sep g sep ys\"", "lemma shows_list_gen_cong [fundef_cong]:\n  assumes \"xs = ys\" and \"\\<And>x. x \\<in> set ys \\<Longrightarrow> f x = g x\"\n  shows \"shows_list_gen f e l sep r xs = shows_list_gen g e l sep r ys\"", "lemma showsp_list_cong [fundef_cong]:\n  \"xs = ys \\<Longrightarrow> p = q \\<Longrightarrow>\n    (\\<And>p x. x \\<in> set ys \\<Longrightarrow> f p x = g p x) \\<Longrightarrow> showsp_list f p xs = showsp_list g q ys\"", "lemma shows_list_literal_code [code]:\n  \"shows_list = foldr (\\<lambda>s. shows_string (String.explode s))\""], "translations": [["", "lemma show_lawI:\n  \"(\\<And>p y z. s p x (y @ z) = s p x y @ z) \\<Longrightarrow> show_law s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p y z. s p x (y @ z) = s p x y @ z) \\<Longrightarrow>\n    show_law s x", "by (simp add: show_law_def)"], ["", "lemma show_lawE:\n  \"show_law s x \\<Longrightarrow> (s p x (y @ z) = s p x y @ z \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>show_law s x;\n     s p x (y @ z) = s p x y @ z \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto simp: show_law_def)"], ["", "lemma show_lawD:\n  \"show_law s x \\<Longrightarrow> s p x (y @ z) = s p x y @ z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. show_law s x \\<Longrightarrow> s p x (y @ z) = s p x y @ z", "by (blast elim: show_lawE)"], ["", "class \"show\" =\n  fixes shows_prec :: \"'a showsp\"\n    and shows_list :: \"'a list \\<Rightarrow> shows\"\n  assumes shows_prec_append [show_law_simps]: \"shows_prec p x (r @ s) = shows_prec p x r @ s\" and\n    shows_list_append [show_law_simps]: \"shows_list xs (r @ s) = shows_list xs r @ s\"\nbegin"], ["", "abbreviation \"shows x \\<equiv> shows_prec 0 x\""], ["", "abbreviation \"show x \\<equiv> shows x ''''\""], ["", "end"], ["", "text \\<open>Convert a string to a show-function that simply prepends the string unchanged.\\<close>"], ["", "definition shows_string :: \"string \\<Rightarrow> shows\"\nwhere\n  \"shows_string = (@)\""], ["", "lemma shows_string_append [show_law_simps]:\n  \"shows_string x (r @ s) = shows_string x r @ s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_string x (r @ s) = shows_string x r @ s", "by (simp add: shows_string_def)"], ["", "fun shows_sep :: \"('a \\<Rightarrow> shows) \\<Rightarrow> shows \\<Rightarrow> 'a list \\<Rightarrow> shows\"\nwhere\n  \"shows_sep s sep [] = shows_string ''''\" |\n  \"shows_sep s sep [x] = s x\" |\n  \"shows_sep s sep (x#xs) = s x o sep o shows_sep s sep xs\""], ["", "lemma shows_sep_append [show_law_simps]:\n  assumes \"\\<And>r s. \\<forall>x \\<in> set xs. showsx x (r @ s) = showsx x r @ s\"\n    and \"\\<And>r s. sep (r @ s) = sep r @ s\"\n  shows \"shows_sep showsx sep xs (r @ s) = shows_sep showsx sep xs r @ s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_sep showsx sep xs (r @ s) = shows_sep showsx sep xs r @ s", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. showsx x (?r @ ?s) = showsx x ?r @ ?s\n  sep (?r @ ?s) = sep ?r @ ?s\n\ngoal (1 subgoal):\n 1. shows_sep showsx sep xs (r @ s) = shows_sep showsx sep xs r @ s", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>r s.\n                \\<forall>x\\<in>set []. showsx x (r @ s) = showsx x r @ s;\n     \\<And>r s. sep (r @ s) = sep r @ s\\<rbrakk>\n    \\<Longrightarrow> shows_sep showsx sep [] (r @ s) =\n                      shows_sep showsx sep [] r @ s\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>r s.\n                            \\<forall>x\\<in>set xs.\n                               showsx x (r @ s) = showsx x r @ s;\n                 \\<And>r s. sep (r @ s) = sep r @ s\\<rbrakk>\n                \\<Longrightarrow> shows_sep showsx sep xs (r @ s) =\n                                  shows_sep showsx sep xs r @ s;\n        \\<And>r s.\n           \\<forall>x\\<in>set (a # xs). showsx x (r @ s) = showsx x r @ s;\n        \\<And>r s. sep (r @ s) = sep r @ s\\<rbrakk>\n       \\<Longrightarrow> shows_sep showsx sep (a # xs) (r @ s) =\n                         shows_sep showsx sep (a # xs) r @ s", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>r s.\n              \\<forall>x\\<in>set xs. showsx x (r @ s) = showsx x r @ s;\n   \\<And>r s. sep (r @ s) = sep r @ s\\<rbrakk>\n  \\<Longrightarrow> shows_sep showsx sep xs (r @ s) =\n                    shows_sep showsx sep xs r @ s\n  \\<forall>x\\<in>set (x # xs). showsx x (?r @ ?s) = showsx x ?r @ ?s\n  sep (?r @ ?s) = sep ?r @ ?s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>r s.\n                \\<forall>x\\<in>set []. showsx x (r @ s) = showsx x r @ s;\n     \\<And>r s. sep (r @ s) = sep r @ s\\<rbrakk>\n    \\<Longrightarrow> shows_sep showsx sep [] (r @ s) =\n                      shows_sep showsx sep [] r @ s\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>r s.\n                            \\<forall>x\\<in>set xs.\n                               showsx x (r @ s) = showsx x r @ s;\n                 \\<And>r s. sep (r @ s) = sep r @ s\\<rbrakk>\n                \\<Longrightarrow> shows_sep showsx sep xs (r @ s) =\n                                  shows_sep showsx sep xs r @ s;\n        \\<And>r s.\n           \\<forall>x\\<in>set (a # xs). showsx x (r @ s) = showsx x r @ s;\n        \\<And>r s. sep (r @ s) = sep r @ s\\<rbrakk>\n       \\<Longrightarrow> shows_sep showsx sep (a # xs) (r @ s) =\n                         shows_sep showsx sep (a # xs) r @ s", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>r s.\n              \\<forall>x\\<in>set xs. showsx x (r @ s) = showsx x r @ s;\n   \\<And>r s. sep (r @ s) = sep r @ s\\<rbrakk>\n  \\<Longrightarrow> shows_sep showsx sep xs (r @ s) =\n                    shows_sep showsx sep xs r @ s\n  \\<forall>x\\<in>set (x # xs). showsx x (?r @ ?s) = showsx x ?r @ ?s\n  sep (?r @ ?s) = sep ?r @ ?s", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>r s.\n              \\<forall>x\\<in>set xs. showsx x (r @ s) = showsx x r @ s;\n   \\<And>r s. sep (r @ s) = sep r @ s\\<rbrakk>\n  \\<Longrightarrow> shows_sep showsx sep xs (r @ s) =\n                    shows_sep showsx sep xs r @ s\n  \\<forall>x\\<in>set (x # xs). showsx x (?r @ ?s) = showsx x ?r @ ?s\n  sep (?r @ ?s) = sep ?r @ ?s\n\ngoal (1 subgoal):\n 1. shows_sep showsx sep (x # xs) (r @ s) =\n    shows_sep showsx sep (x # xs) r @ s", "by (cases xs) (simp_all)"], ["proof (state)\nthis:\n  shows_sep showsx sep (x # xs) (r @ s) =\n  shows_sep showsx sep (x # xs) r @ s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r s.\n                \\<forall>x\\<in>set []. showsx x (r @ s) = showsx x r @ s;\n     \\<And>r s. sep (r @ s) = sep r @ s\\<rbrakk>\n    \\<Longrightarrow> shows_sep showsx sep [] (r @ s) =\n                      shows_sep showsx sep [] r @ s", "qed (simp add: show_law_simps)"], ["", "lemma shows_sep_map:\n  \"shows_sep f sep (map g xs) = shows_sep (f o g) sep xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_sep f sep (map g xs) = shows_sep (f \\<circ> g) sep xs", "by (induct xs) (simp, case_tac xs, simp_all)"], ["", "definition\n  shows_list_gen :: \"('a \\<Rightarrow> shows) \\<Rightarrow> string \\<Rightarrow> string \\<Rightarrow> string \\<Rightarrow> string \\<Rightarrow> 'a list \\<Rightarrow> shows\"\nwhere\n  \"shows_list_gen showsx e l s r xs =\n    (if xs = [] then shows_string e\n    else shows_string l o shows_sep showsx (shows_string s) xs o shows_string r)\""], ["", "lemma shows_list_gen_append [show_law_simps]:\n  assumes \"\\<And>r s. \\<forall>x\\<in>set xs. showsx x (r @ s) = showsx x r @ s\"\n  shows \"shows_list_gen showsx e l sep r xs (s @ t) = shows_list_gen showsx e l sep r xs s @ t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_list_gen showsx e l sep r xs (s @ t) =\n    shows_list_gen showsx e l sep r xs s @ t", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. showsx x (?r @ ?s) = showsx x ?r @ ?s\n\ngoal (1 subgoal):\n 1. shows_list_gen showsx e l sep r xs (s @ t) =\n    shows_list_gen showsx e l sep r xs s @ t", "by (cases xs) (simp_all add: shows_list_gen_def show_law_simps)"], ["", "lemma shows_list_gen_map:\n  \"shows_list_gen f e l sep r (map g xs) = shows_list_gen (f o g) e l sep r xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_list_gen f e l sep r (map g xs) =\n    shows_list_gen (f \\<circ> g) e l sep r xs", "by (simp_all add: shows_list_gen_def shows_sep_map)"], ["", "definition pshowsp_list :: \"nat \\<Rightarrow> shows list \\<Rightarrow> shows\"\nwhere\n  \"pshowsp_list p xs = shows_list_gen id ''[]'' ''['' '', '' '']'' xs\""], ["", "definition showsp_list :: \"'a showsp \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> shows\"\nwhere\n  [code del]: \"showsp_list s p = pshowsp_list p o map (s 0)\""], ["", "lemma showsp_list_code [code]:\n  \"showsp_list s p xs = shows_list_gen (s 0) ''[]'' ''['' '', '' '']'' xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. showsp_list s p xs = shows_list_gen (s 0) ''[]'' ''['' '', '' '']'' xs", "by (simp add: showsp_list_def pshowsp_list_def shows_list_gen_map)"], ["", "lemma show_law_list [show_law_intros]:\n  \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> show_law s x) \\<Longrightarrow> show_law (showsp_list s) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow> show_law s x) \\<Longrightarrow>\n    show_law (showsp_list s) xs", "by (simp add: show_law_def showsp_list_code show_law_simps)"], ["", "lemma showsp_list_append [show_law_simps]:\n  \"(\\<And>p y z. \\<forall>x \\<in> set xs. s p x (y @ z) = s p x y @ z) \\<Longrightarrow>\n    showsp_list s p xs (y @ z) = showsp_list s p xs y @ z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p y z.\n        \\<forall>x\\<in>set xs.\n           s p x (y @ z) = s p x y @ z) \\<Longrightarrow>\n    showsp_list s p xs (y @ z) = showsp_list s p xs y @ z", "by (simp add: show_law_simps showsp_list_def pshowsp_list_def)"], ["", "subsection \\<open>Show-Functions for Characters and Strings\\<close>"], ["", "instantiation char :: \"show\"\nbegin"], ["", "definition \"shows_prec p (c::char) = (#) c\""], ["", "definition \"shows_list (cs::string) = shows_string cs\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(char, show_class)", "by standard (simp_all add: shows_prec_char_def shows_list_char_def show_law_simps)"], ["", "end"], ["", "definition \"shows_nl = shows (CHR ''\\<newline>'')\""], ["", "definition \"shows_space = shows (CHR '' '')\""], ["", "definition \"shows_paren s = shows (CHR ''('') o s o shows (CHR '')'')\""], ["", "definition \"shows_quote s = shows (CHR 0x27) o s o shows (CHR 0x27)\""], ["", "abbreviation \"apply_if b s \\<equiv> (if b then s else id)\" \\<comment> \\<open>conditional function application\\<close>"], ["", "text \\<open>Parenthesize only if precedence is greater than @{term \"0::nat\"}.\\<close>"], ["", "definition \"shows_pl (p::nat) = apply_if (p > 0) (shows (CHR ''(''))\""], ["", "definition \"shows_pr (p::nat) = apply_if (p > 0) (shows (CHR '')''))\""], ["", "lemma\n  shows_nl_append [show_law_simps]: \"shows_nl (x @ y) = shows_nl x @ y\" and\n  shows_space_append [show_law_simps]: \"shows_space (x @ y) = shows_space x @ y\" and\n  shows_paren_append [show_law_simps]:\n    \"(\\<And>x y. s (x @ y) = s x @ y) \\<Longrightarrow> shows_paren s (x @ y) = shows_paren s x @ y\" and\n  shows_quote_append [show_law_simps]:\n    \"(\\<And>x y. s (x @ y) = s x @ y) \\<Longrightarrow> shows_quote s (x @ y) = shows_quote s x @ y\" and\n  shows_pl_append [show_law_simps]: \"shows_pl p (x @ y) = shows_pl p x @ y\" and\n  shows_pr_append [show_law_simps]: \"shows_pr p (x @ y) = shows_pr p x @ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (shows_nl (x @ y) = shows_nl x @ y &&&\n     shows_space (x @ y) = shows_space x @ y &&&\n     ((\\<And>x y. s (x @ y) = s x @ y) \\<Longrightarrow>\n      shows_paren s (x @ y) = shows_paren s x @ y)) &&&\n    ((\\<And>x y. s (x @ y) = s x @ y) \\<Longrightarrow>\n     shows_quote s (x @ y) = shows_quote s x @ y) &&&\n    shows_pl p (x @ y) = shows_pl p x @ y &&&\n    shows_pr p (x @ y) = shows_pr p x @ y", "by (simp_all add: shows_nl_def shows_space_def shows_paren_def shows_quote_def shows_pl_def shows_pr_def show_law_simps)"], ["", "lemma o_append:\n  \"(\\<And>x y. f (x @ y) = f x @ y) \\<Longrightarrow> g (x @ y) = g x @ y \\<Longrightarrow> (f o g) (x @ y) = (f o g) x @ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y. f (x @ y) = f x @ y; g (x @ y) = g x @ y\\<rbrakk>\n    \\<Longrightarrow> (f \\<circ> g) (x @ y) = (f \\<circ> g) x @ y", "by simp"], ["", "ML_file \\<open>show_generator.ML\\<close>"], ["", "local_setup \\<open>\n  Show_Generator.register_foreign_partial_and_full_showsp @{type_name \"list\"} 0\n    @{term \"pshowsp_list\"}\n    @{term \"showsp_list\"} (SOME @{thm showsp_list_def})\n    @{term \"map\"} (SOME @{thm list.map_comp}) [true] @{thm show_law_list}\n\\<close>"], ["", "instantiation list :: (\"show\") \"show\"\nbegin"], ["", "definition \"shows_prec (p :: nat) (xs :: 'a list) = shows_list xs\""], ["", "definition \"shows_list (xss :: 'a list list) = showsp_list shows_prec 0 xss\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a list, show_class)", "by standard (simp_all add: show_law_simps shows_prec_list_def shows_list_list_def)"], ["", "end"], ["", "definition shows_lines :: \"'a::show list \\<Rightarrow> shows\"\nwhere\n  \"shows_lines = shows_sep shows shows_nl\""], ["", "definition shows_many :: \"'a::show list \\<Rightarrow> shows\"\nwhere\n  \"shows_many = shows_sep shows id\""], ["", "definition shows_words :: \"'a::show list \\<Rightarrow> shows\"\nwhere\n  \"shows_words = shows_sep shows shows_space\""], ["", "lemma shows_lines_append [show_law_simps]:\n  \"shows_lines xs (r @ s) = shows_lines xs r @ s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_lines xs (r @ s) = shows_lines xs r @ s", "by (simp add: shows_lines_def show_law_simps)"], ["", "lemma shows_many_append [show_law_simps]:\n  \"shows_many xs (r @ s) = shows_many xs r @ s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_many xs (r @ s) = shows_many xs r @ s", "by (simp add: shows_many_def show_law_simps)"], ["", "lemma shows_words_append [show_law_simps]:\n  \"shows_words xs (r @ s) = shows_words xs r @ s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_words xs (r @ s) = shows_words xs r @ s", "by (simp add: shows_words_def show_law_simps)"], ["", "lemma shows_foldr_append [show_law_simps]:\n  assumes \"\\<And>r s. \\<forall>x \\<in> set xs. showx x (r @ s) = showx x r @ s\"\n  shows \"foldr showx xs (r @ s) = foldr showx xs r @ s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr showx xs (r @ s) = foldr showx xs r @ s", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. showx x (?r @ ?s) = showx x ?r @ ?s\n\ngoal (1 subgoal):\n 1. foldr showx xs (r @ s) = foldr showx xs r @ s", "by (induct xs) (simp_all)"], ["", "lemma shows_sep_cong [fundef_cong]:\n  assumes \"xs = ys\" and \"\\<And>x. x \\<in> set ys \\<Longrightarrow> f x = g x\"\n  shows \"shows_sep f sep xs = shows_sep g sep ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_sep f sep xs = shows_sep g sep ys", "using assms"], ["proof (prove)\nusing this:\n  xs = ys\n  ?x \\<in> set ys \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. shows_sep f sep xs = shows_sep g sep ys", "proof (induct ys arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs = [];\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> f x = g x\\<rbrakk>\n       \\<Longrightarrow> shows_sep f sep xs = shows_sep g sep []\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>xs = ys;\n                    \\<And>x.\n                       x \\<in> set ys \\<Longrightarrow> f x = g x\\<rbrakk>\n                   \\<Longrightarrow> shows_sep f sep xs =\n                                     shows_sep g sep ys;\n        xs = a # ys;\n        \\<And>x. x \\<in> set (a # ys) \\<Longrightarrow> f x = g x\\<rbrakk>\n       \\<Longrightarrow> shows_sep f sep xs = shows_sep g sep (a # ys)", "case (Cons y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>?xs = ys;\n   \\<And>x. x \\<in> set ys \\<Longrightarrow> f x = g x\\<rbrakk>\n  \\<Longrightarrow> shows_sep f sep ?xs = shows_sep g sep ys\n  xs = y # ys\n  ?x \\<in> set (y # ys) \\<Longrightarrow> f ?x = g ?x\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs = [];\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> f x = g x\\<rbrakk>\n       \\<Longrightarrow> shows_sep f sep xs = shows_sep g sep []\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>xs = ys;\n                    \\<And>x.\n                       x \\<in> set ys \\<Longrightarrow> f x = g x\\<rbrakk>\n                   \\<Longrightarrow> shows_sep f sep xs =\n                                     shows_sep g sep ys;\n        xs = a # ys;\n        \\<And>x. x \\<in> set (a # ys) \\<Longrightarrow> f x = g x\\<rbrakk>\n       \\<Longrightarrow> shows_sep f sep xs = shows_sep g sep (a # ys)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?xs = ys;\n   \\<And>x. x \\<in> set ys \\<Longrightarrow> f x = g x\\<rbrakk>\n  \\<Longrightarrow> shows_sep f sep ?xs = shows_sep g sep ys\n  xs = y # ys\n  ?x \\<in> set (y # ys) \\<Longrightarrow> f ?x = g ?x", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs = ys;\n   \\<And>x. x \\<in> set ys \\<Longrightarrow> f x = g x\\<rbrakk>\n  \\<Longrightarrow> shows_sep f sep ?xs = shows_sep g sep ys\n  xs = y # ys\n  ?x \\<in> set (y # ys) \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. shows_sep f sep xs = shows_sep g sep (y # ys)", "by (cases ys) simp_all"], ["proof (state)\nthis:\n  shows_sep f sep xs = shows_sep g sep (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>xs = [];\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> f x = g x\\<rbrakk>\n       \\<Longrightarrow> shows_sep f sep xs = shows_sep g sep []", "qed simp"], ["", "lemma shows_list_gen_cong [fundef_cong]:\n  assumes \"xs = ys\" and \"\\<And>x. x \\<in> set ys \\<Longrightarrow> f x = g x\"\n  shows \"shows_list_gen f e l sep r xs = shows_list_gen g e l sep r ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_list_gen f e l sep r xs = shows_list_gen g e l sep r ys", "using shows_sep_cong [of xs ys f g] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>xs = ys;\n   \\<And>x. x \\<in> set ys \\<Longrightarrow> f x = g x\\<rbrakk>\n  \\<Longrightarrow> shows_sep f ?sep xs = shows_sep g ?sep ys\n  xs = ys\n  ?x \\<in> set ys \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. shows_list_gen f e l sep r xs = shows_list_gen g e l sep r ys", "by (cases xs) (auto simp: shows_list_gen_def)"], ["", "lemma showsp_list_cong [fundef_cong]:\n  \"xs = ys \\<Longrightarrow> p = q \\<Longrightarrow>\n    (\\<And>p x. x \\<in> set ys \\<Longrightarrow> f p x = g p x) \\<Longrightarrow> showsp_list f p xs = showsp_list g q ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = ys; p = q;\n     \\<And>p x. x \\<in> set ys \\<Longrightarrow> f p x = g p x\\<rbrakk>\n    \\<Longrightarrow> showsp_list f p xs = showsp_list g q ys", "by (simp add: showsp_list_code cong: shows_list_gen_cong)"], ["", "abbreviation (input) shows_cons :: \"string \\<Rightarrow> shows \\<Rightarrow> shows\" (infixr \"+#+\" 10)\nwhere\n  \"s +#+ p \\<equiv> shows_string s \\<circ> p\""], ["", "abbreviation (input) shows_append :: \"shows \\<Rightarrow> shows \\<Rightarrow> shows\" (infixr \"+@+\" 10)\nwhere\n  \"s +@+ p \\<equiv> s \\<circ> p\""], ["", "instantiation String.literal :: \"show\"\nbegin"], ["", "definition shows_prec_literal :: \"nat \\<Rightarrow> String.literal \\<Rightarrow> string \\<Rightarrow> string\"\n  where \"shows_prec p s = shows_string (String.explode s)\""], ["", "definition shows_list_literal :: \"String.literal list \\<Rightarrow> string \\<Rightarrow> string\"\n  where \"shows_list ss = shows_string (concat (map String.explode ss))\""], ["", "lemma shows_list_literal_code [code]:\n  \"shows_list = foldr (\\<lambda>s. shows_string (String.explode s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_list = foldr (\\<lambda>s. shows_string (literal.explode s))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       shows_list x = foldr (\\<lambda>s. shows_string (literal.explode s)) x", "fix ss"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       shows_list x = foldr (\\<lambda>s. shows_string (literal.explode s)) x", "show \"shows_list ss = foldr (\\<lambda>s. shows_string (String.explode s)) ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_list ss = foldr (\\<lambda>s. shows_string (literal.explode s)) ss", "by (induct ss) (simp_all add: shows_list_literal_def shows_string_def)"], ["proof (state)\nthis:\n  shows_list ss = foldr (\\<lambda>s. shows_string (literal.explode s)) ss\n\ngoal:\nNo subgoals!", "qed"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(String.literal, show_class)", "by standard\n  (simp_all add: shows_prec_literal_def shows_list_literal_def shows_string_def)"], ["", "end"], ["", "text \\<open>\n  Don't use Haskell's existing \"Show\" class for code-generation, since it is not compatible to the\n  formalized class.\n\\<close>"], ["", "code_reserved Haskell \"Show\""], ["", "end"]]}