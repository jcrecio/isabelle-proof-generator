{"file_name": "/home/qj213/afp-2021-10-22/thys/IMAP-CRDT/IMAP-proof-commute.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IMAP-CRDT", "problem_names": ["lemma (in imap) create_create_commute:\n  shows \"\\<langle>Create i1 e1\\<rangle> \\<rhd> \\<langle>Create i2 e2\\<rangle> = \\<langle>Create i2 e2\\<rangle> \\<rhd> \\<langle>Create i1 e1\\<rangle>\"", "lemma (in imap) create_delete_commute:\n  assumes \"i \\<notin> is\"\n  shows \"\\<langle>Create i e1\\<rangle> \\<rhd> \\<langle>Delete is e2\\<rangle> = \\<langle>Delete is e2\\<rangle> \\<rhd> \\<langle>Create i e1\\<rangle>\"", "lemma (in imap) create_append_commute:\n  shows \"\\<langle>Create i1 e1\\<rangle> \\<rhd> \\<langle>Append i2 e2\\<rangle> = \\<langle>Append i2 e2\\<rangle> \\<rhd> \\<langle>Create i1 e1\\<rangle>\"", "lemma (in imap) create_expunge_commute:\n  shows \"\\<langle>Create i1 e1\\<rangle> \\<rhd> \\<langle>Expunge e2 mo i2\\<rangle> = \\<langle>Expunge e2 mo i2\\<rangle> \\<rhd> \\<langle>Create i1 e1\\<rangle>\"", "lemma (in imap) create_store_commute:\n  shows \"\\<langle>Create i1 e1\\<rangle> \\<rhd> \\<langle>Store e2 mo i2\\<rangle> = \\<langle>Store e2 mo i2\\<rangle> \\<rhd> \\<langle>Create i1 e1\\<rangle>\"", "lemma (in imap) delete_delete_commute:\n  shows \"\\<langle>Delete i1 e1\\<rangle> \\<rhd> \\<langle>Delete i2 e2\\<rangle> = \\<langle>Delete i2 e2\\<rangle> \\<rhd> \\<langle>Delete i1 e1\\<rangle>\"", "lemma (in imap) delete_append_commute:\n  assumes \"i \\<notin> is\"\n  shows \"\\<langle>Delete is e1\\<rangle> \\<rhd> \\<langle>Append i e2\\<rangle> = \\<langle>Append i e2\\<rangle> \\<rhd> \\<langle>Delete is e1\\<rangle>\"", "lemma (in imap) delete_expunge_commute:\n  assumes \"i \\<notin> is\"\n  shows \"\\<langle>Delete is e1\\<rangle> \\<rhd> \\<langle>Expunge e2 mo i\\<rangle> = \\<langle>Expunge e2 mo i\\<rangle> \\<rhd> \\<langle>Delete is e1\\<rangle>\"", "lemma (in imap) delete_store_commute:\n  assumes \"i \\<notin> is\"\n  shows \"\\<langle>Delete is e1\\<rangle> \\<rhd> \\<langle>Store e2 mo i\\<rangle> = \\<langle>Store e2 mo i\\<rangle> \\<rhd> \\<langle>Delete is e1\\<rangle>\"", "lemma (in imap) append_append_commute:\n  shows \"\\<langle>Append i1 e1\\<rangle> \\<rhd> \\<langle>Append i2 e2\\<rangle> = \\<langle>Append i2 e2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>\"", "lemma (in imap) append_expunge_commute:\n  assumes \"i1 \\<noteq> mo\"\n  shows \"(\\<langle>Append i1 e1\\<rangle> \\<rhd> \\<langle>Expunge e2 mo i2\\<rangle>) = (\\<langle>Expunge e2 mo i2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>)\"", "lemma (in imap) append_store_commute:\n  assumes \"i1 \\<noteq> mo\"\n  shows \"(\\<langle>Append i1 e1\\<rangle> \\<rhd> \\<langle>Store e2 mo i2\\<rangle>) = (\\<langle>Store e2 mo i2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>)\"", "lemma (in imap) expunge_expunge_commute:\n  shows \"(\\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd> \\<langle>Expunge e2 mo2 i2\\<rangle>) = (\\<langle>Expunge e2 mo2 i2\\<rangle> \\<rhd> \\<langle>Expunge e1 mo1 i1\\<rangle>)\"", "lemma (in imap) expunge_store_commute:\n  assumes \"i1 \\<noteq> mo2\" and \"i2 \\<noteq> mo1\"\n  shows \"(\\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd> \\<langle>Store e2 mo2 i2\\<rangle>) = (\\<langle>Store e2 mo2 i2\\<rangle> \\<rhd> \\<langle>Expunge e1 mo1 i1\\<rangle>)\"", "lemma (in imap) store_store_commute:\n  assumes \"i1 \\<noteq> mo2\" and \"i2 \\<noteq> mo1\"\n  shows \"(\\<langle>Store e1 mo1 i1\\<rangle> \\<rhd> \\<langle>Store e2 mo2 i2\\<rangle>) = (\\<langle>Store e2 mo2 i2\\<rangle> \\<rhd> \\<langle>Store e1 mo1 i1\\<rangle>)\""], "translations": [["", "lemma (in imap) create_create_commute:\n  shows \"\\<langle>Create i1 e1\\<rangle> \\<rhd> \\<langle>Create i2 e2\\<rangle> = \\<langle>Create i2 e2\\<rangle> \\<rhd> \\<langle>Create i1 e1\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Create i1 e1\\<rangle> \\<rhd> \\<langle>Create i2 e2\\<rangle> =\n    \\<langle>Create i2 e2\\<rangle> \\<rhd> \\<langle>Create i1 e1\\<rangle>", "by(auto simp add: interpret_op_def op_elem_def kleisli_def, fastforce)"], ["", "lemma (in imap) create_delete_commute:\n  assumes \"i \\<notin> is\"\n  shows \"\\<langle>Create i e1\\<rangle> \\<rhd> \\<langle>Delete is e2\\<rangle> = \\<langle>Delete is e2\\<rangle> \\<rhd> \\<langle>Create i e1\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Create i e1\\<rangle> \\<rhd> \\<langle>Delete is e2\\<rangle> =\n    \\<langle>Delete is e2\\<rangle> \\<rhd> \\<langle>Create i e1\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  i \\<notin> is\n\ngoal (1 subgoal):\n 1. \\<langle>Create i e1\\<rangle> \\<rhd> \\<langle>Delete is e2\\<rangle> =\n    \\<langle>Delete is e2\\<rangle> \\<rhd> \\<langle>Create i e1\\<rangle>", "by(auto simp add: interpret_op_def kleisli_def op_elem_def, fastforce)"], ["", "lemma (in imap) create_append_commute:\n  shows \"\\<langle>Create i1 e1\\<rangle> \\<rhd> \\<langle>Append i2 e2\\<rangle> = \\<langle>Append i2 e2\\<rangle> \\<rhd> \\<langle>Create i1 e1\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Create i1 e1\\<rangle> \\<rhd> \\<langle>Append i2 e2\\<rangle> =\n    \\<langle>Append i2 e2\\<rangle> \\<rhd> \\<langle>Create i1 e1\\<rangle>", "by(auto simp add: interpret_op_def op_elem_def kleisli_def, fastforce)"], ["", "lemma (in imap) create_expunge_commute:\n  shows \"\\<langle>Create i1 e1\\<rangle> \\<rhd> \\<langle>Expunge e2 mo i2\\<rangle> = \\<langle>Expunge e2 mo i2\\<rangle> \\<rhd> \\<langle>Create i1 e1\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Create i1 e1\\<rangle> \\<rhd>\n    \\<langle>Expunge e2 mo i2\\<rangle> =\n    \\<langle>Expunge e2 mo i2\\<rangle> \\<rhd> \\<langle>Create i1 e1\\<rangle>", "by(auto simp add: interpret_op_def op_elem_def kleisli_def, fastforce)"], ["", "lemma (in imap) create_store_commute:\n  shows \"\\<langle>Create i1 e1\\<rangle> \\<rhd> \\<langle>Store e2 mo i2\\<rangle> = \\<langle>Store e2 mo i2\\<rangle> \\<rhd> \\<langle>Create i1 e1\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Create i1 e1\\<rangle> \\<rhd> \\<langle>Store e2 mo i2\\<rangle> =\n    \\<langle>Store e2 mo i2\\<rangle> \\<rhd> \\<langle>Create i1 e1\\<rangle>", "by(auto simp add: interpret_op_def op_elem_def kleisli_def, fastforce)"], ["", "lemma (in imap) delete_delete_commute:\n  shows \"\\<langle>Delete i1 e1\\<rangle> \\<rhd> \\<langle>Delete i2 e2\\<rangle> = \\<langle>Delete i2 e2\\<rangle> \\<rhd> \\<langle>Delete i1 e1\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Delete i1 e1\\<rangle> \\<rhd> \\<langle>Delete i2 e2\\<rangle> =\n    \\<langle>Delete i2 e2\\<rangle> \\<rhd> \\<langle>Delete i1 e1\\<rangle>", "by(unfold interpret_op_def op_elem_def kleisli_def, fastforce)"], ["", "lemma (in imap) delete_append_commute:\n  assumes \"i \\<notin> is\"\n  shows \"\\<langle>Delete is e1\\<rangle> \\<rhd> \\<langle>Append i e2\\<rangle> = \\<langle>Append i e2\\<rangle> \\<rhd> \\<langle>Delete is e1\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Delete is e1\\<rangle> \\<rhd> \\<langle>Append i e2\\<rangle> =\n    \\<langle>Append i e2\\<rangle> \\<rhd> \\<langle>Delete is e1\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  i \\<notin> is\n\ngoal (1 subgoal):\n 1. \\<langle>Delete is e1\\<rangle> \\<rhd> \\<langle>Append i e2\\<rangle> =\n    \\<langle>Append i e2\\<rangle> \\<rhd> \\<langle>Delete is e1\\<rangle>", "by(auto simp add: interpret_op_def kleisli_def op_elem_def, fastforce)"], ["", "lemma (in imap) delete_expunge_commute:\n  assumes \"i \\<notin> is\"\n  shows \"\\<langle>Delete is e1\\<rangle> \\<rhd> \\<langle>Expunge e2 mo i\\<rangle> = \\<langle>Expunge e2 mo i\\<rangle> \\<rhd> \\<langle>Delete is e1\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Delete is e1\\<rangle> \\<rhd>\n    \\<langle>Expunge e2 mo i\\<rangle> =\n    \\<langle>Expunge e2 mo i\\<rangle> \\<rhd> \\<langle>Delete is e1\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  i \\<notin> is\n\ngoal (1 subgoal):\n 1. \\<langle>Delete is e1\\<rangle> \\<rhd>\n    \\<langle>Expunge e2 mo i\\<rangle> =\n    \\<langle>Expunge e2 mo i\\<rangle> \\<rhd> \\<langle>Delete is e1\\<rangle>", "by(auto simp add: interpret_op_def kleisli_def op_elem_def, fastforce)"], ["", "lemma (in imap) delete_store_commute:\n  assumes \"i \\<notin> is\"\n  shows \"\\<langle>Delete is e1\\<rangle> \\<rhd> \\<langle>Store e2 mo i\\<rangle> = \\<langle>Store e2 mo i\\<rangle> \\<rhd> \\<langle>Delete is e1\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Delete is e1\\<rangle> \\<rhd> \\<langle>Store e2 mo i\\<rangle> =\n    \\<langle>Store e2 mo i\\<rangle> \\<rhd> \\<langle>Delete is e1\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  i \\<notin> is\n\ngoal (1 subgoal):\n 1. \\<langle>Delete is e1\\<rangle> \\<rhd> \\<langle>Store e2 mo i\\<rangle> =\n    \\<langle>Store e2 mo i\\<rangle> \\<rhd> \\<langle>Delete is e1\\<rangle>", "by(auto simp add: interpret_op_def kleisli_def op_elem_def, fastforce)"], ["", "lemma (in imap) append_append_commute:\n  shows \"\\<langle>Append i1 e1\\<rangle> \\<rhd> \\<langle>Append i2 e2\\<rangle> = \\<langle>Append i2 e2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Append i1 e1\\<rangle> \\<rhd> \\<langle>Append i2 e2\\<rangle> =\n    \\<langle>Append i2 e2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>", "by(auto simp add: interpret_op_def op_elem_def kleisli_def, fastforce)"], ["", "lemma (in imap) append_expunge_commute:\n  assumes \"i1 \\<noteq> mo\"\n  shows \"(\\<langle>Append i1 e1\\<rangle> \\<rhd> \\<langle>Expunge e2 mo i2\\<rangle>) = (\\<langle>Expunge e2 mo i2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Append i1 e1\\<rangle> \\<rhd>\n    \\<langle>Expunge e2 mo i2\\<rangle> =\n    \\<langle>Expunge e2 mo i2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<langle>Append i1 e1\\<rangle> \\<rhd>\n        \\<langle>Expunge e2 mo i2\\<rangle>)\n        x =\n       (\\<langle>Expunge e2 mo i2\\<rangle> \\<rhd>\n        \\<langle>Append i1 e1\\<rangle>)\n        x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<langle>Append i1 e1\\<rangle> \\<rhd>\n        \\<langle>Expunge e2 mo i2\\<rangle>)\n        x =\n       (\\<langle>Expunge e2 mo i2\\<rangle> \\<rhd>\n        \\<langle>Append i1 e1\\<rangle>)\n        x", "show \"(\\<langle>Append i1 e1\\<rangle> \\<rhd> \\<langle>Expunge e2 mo i2\\<rangle>) x = (\\<langle>Expunge e2 mo i2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>Append i1 e1\\<rangle> \\<rhd>\n     \\<langle>Expunge e2 mo i2\\<rangle>)\n     x =\n    (\\<langle>Expunge e2 mo i2\\<rangle> \\<rhd>\n     \\<langle>Append i1 e1\\<rangle>)\n     x", "using assms"], ["proof (prove)\nusing this:\n  i1 \\<noteq> mo\n\ngoal (1 subgoal):\n 1. (\\<langle>Append i1 e1\\<rangle> \\<rhd>\n     \\<langle>Expunge e2 mo i2\\<rangle>)\n     x =\n    (\\<langle>Expunge e2 mo i2\\<rangle> \\<rhd>\n     \\<langle>Append i1 e1\\<rangle>)\n     x", "by(auto simp add: interpret_op_def kleisli_def op_elem_def)"], ["proof (state)\nthis:\n  (\\<langle>Append i1 e1\\<rangle> \\<rhd> \\<langle>Expunge e2 mo i2\\<rangle>)\n   x =\n  (\\<langle>Expunge e2 mo i2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>)\n   x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in imap) append_store_commute:\n  assumes \"i1 \\<noteq> mo\"\n  shows \"(\\<langle>Append i1 e1\\<rangle> \\<rhd> \\<langle>Store e2 mo i2\\<rangle>) = (\\<langle>Store e2 mo i2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Append i1 e1\\<rangle> \\<rhd> \\<langle>Store e2 mo i2\\<rangle> =\n    \\<langle>Store e2 mo i2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<langle>Append i1 e1\\<rangle> \\<rhd>\n        \\<langle>Store e2 mo i2\\<rangle>)\n        x =\n       (\\<langle>Store e2 mo i2\\<rangle> \\<rhd>\n        \\<langle>Append i1 e1\\<rangle>)\n        x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<langle>Append i1 e1\\<rangle> \\<rhd>\n        \\<langle>Store e2 mo i2\\<rangle>)\n        x =\n       (\\<langle>Store e2 mo i2\\<rangle> \\<rhd>\n        \\<langle>Append i1 e1\\<rangle>)\n        x", "show \"(\\<langle>Append i1 e1\\<rangle> \\<rhd> \\<langle>Store e2 mo i2\\<rangle>) x = (\\<langle>Store e2 mo i2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>Append i1 e1\\<rangle> \\<rhd> \\<langle>Store e2 mo i2\\<rangle>)\n     x =\n    (\\<langle>Store e2 mo i2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>)\n     x", "using assms"], ["proof (prove)\nusing this:\n  i1 \\<noteq> mo\n\ngoal (1 subgoal):\n 1. (\\<langle>Append i1 e1\\<rangle> \\<rhd> \\<langle>Store e2 mo i2\\<rangle>)\n     x =\n    (\\<langle>Store e2 mo i2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>)\n     x", "by(auto simp add: interpret_op_def kleisli_def op_elem_def)"], ["proof (state)\nthis:\n  (\\<langle>Append i1 e1\\<rangle> \\<rhd> \\<langle>Store e2 mo i2\\<rangle>)\n   x =\n  (\\<langle>Store e2 mo i2\\<rangle> \\<rhd> \\<langle>Append i1 e1\\<rangle>) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in imap) expunge_expunge_commute:\n  shows \"(\\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd> \\<langle>Expunge e2 mo2 i2\\<rangle>) = (\\<langle>Expunge e2 mo2 i2\\<rangle> \\<rhd> \\<langle>Expunge e1 mo1 i1\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd>\n    \\<langle>Expunge e2 mo2 i2\\<rangle> =\n    \\<langle>Expunge e2 mo2 i2\\<rangle> \\<rhd>\n    \\<langle>Expunge e1 mo1 i1\\<rangle>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd>\n        \\<langle>Expunge e2 mo2 i2\\<rangle>)\n        x =\n       (\\<langle>Expunge e2 mo2 i2\\<rangle> \\<rhd>\n        \\<langle>Expunge e1 mo1 i1\\<rangle>)\n        x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd>\n        \\<langle>Expunge e2 mo2 i2\\<rangle>)\n        x =\n       (\\<langle>Expunge e2 mo2 i2\\<rangle> \\<rhd>\n        \\<langle>Expunge e1 mo1 i1\\<rangle>)\n        x", "show \"(\\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd> \\<langle>Expunge e2 mo2 i2\\<rangle>) x \n       = (\\<langle>Expunge e2 mo2 i2\\<rangle> \\<rhd> \\<langle>Expunge e1 mo1 i1\\<rangle>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd>\n     \\<langle>Expunge e2 mo2 i2\\<rangle>)\n     x =\n    (\\<langle>Expunge e2 mo2 i2\\<rangle> \\<rhd>\n     \\<langle>Expunge e1 mo1 i1\\<rangle>)\n     x", "by(auto simp add: interpret_op_def kleisli_def op_elem_def)"], ["proof (state)\nthis:\n  (\\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd>\n   \\<langle>Expunge e2 mo2 i2\\<rangle>)\n   x =\n  (\\<langle>Expunge e2 mo2 i2\\<rangle> \\<rhd>\n   \\<langle>Expunge e1 mo1 i1\\<rangle>)\n   x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in imap) expunge_store_commute:\n  assumes \"i1 \\<noteq> mo2\" and \"i2 \\<noteq> mo1\"\n  shows \"(\\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd> \\<langle>Store e2 mo2 i2\\<rangle>) = (\\<langle>Store e2 mo2 i2\\<rangle> \\<rhd> \\<langle>Expunge e1 mo1 i1\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd>\n    \\<langle>Store e2 mo2 i2\\<rangle> =\n    \\<langle>Store e2 mo2 i2\\<rangle> \\<rhd>\n    \\<langle>Expunge e1 mo1 i1\\<rangle>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd>\n        \\<langle>Store e2 mo2 i2\\<rangle>)\n        x =\n       (\\<langle>Store e2 mo2 i2\\<rangle> \\<rhd>\n        \\<langle>Expunge e1 mo1 i1\\<rangle>)\n        x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd>\n        \\<langle>Store e2 mo2 i2\\<rangle>)\n        x =\n       (\\<langle>Store e2 mo2 i2\\<rangle> \\<rhd>\n        \\<langle>Expunge e1 mo1 i1\\<rangle>)\n        x", "show \"(\\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd> \\<langle>Store e2 mo2 i2\\<rangle>) x = (\\<langle>Store e2 mo2 i2\\<rangle> \\<rhd> \\<langle>Expunge e1 mo1 i1\\<rangle>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd>\n     \\<langle>Store e2 mo2 i2\\<rangle>)\n     x =\n    (\\<langle>Store e2 mo2 i2\\<rangle> \\<rhd>\n     \\<langle>Expunge e1 mo1 i1\\<rangle>)\n     x", "unfolding  interpret_op_def kleisli_def op_elem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let metadata =\n           fst (x (case Expunge e1 mo1 i1 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         files =\n           snd (x (case Expunge e1 mo1 i1 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         after =\n           case Expunge e1 mo1 i1 of\n           Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n           | Delete is e \\<Rightarrow> (metadata - is, files - is)\n           | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n           | Expunge e mo i \\<Rightarrow>\n               (metadata \\<union> {i}, files - {mo})\n           | Store e mo i \\<Rightarrow> (metadata, insert i (files - {mo}))\n     in Some\n         (x(case Expunge e1 mo1 i1 of Create i e \\<Rightarrow> e\n            | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n            | Expunge e mo i \\<Rightarrow> e\n            | Store e mo i \\<Rightarrow> e :=\n              after))) \\<bind>\n    (\\<lambda>y.\n        let metadata =\n              fst (y (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            files =\n              snd (y (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            after =\n              case Store e2 mo2 i2 of\n              Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n              | Delete is e \\<Rightarrow> (metadata - is, files - is)\n              | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n              | Expunge e mo i \\<Rightarrow>\n                  (metadata \\<union> {i}, files - {mo})\n              | Store e mo i \\<Rightarrow>\n                  (metadata, insert i (files - {mo}))\n        in Some\n            (y(case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n               | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n               | Expunge e mo i \\<Rightarrow> e\n               | Store e mo i \\<Rightarrow> e :=\n                 after))) =\n    (let metadata =\n           fst (x (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         files =\n           snd (x (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         after =\n           case Store e2 mo2 i2 of\n           Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n           | Delete is e \\<Rightarrow> (metadata - is, files - is)\n           | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n           | Expunge e mo i \\<Rightarrow>\n               (metadata \\<union> {i}, files - {mo})\n           | Store e mo i \\<Rightarrow> (metadata, insert i (files - {mo}))\n     in Some\n         (x(case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n            | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n            | Expunge e mo i \\<Rightarrow> e\n            | Store e mo i \\<Rightarrow> e :=\n              after))) \\<bind>\n    (\\<lambda>y.\n        let metadata =\n              fst (y (case Expunge e1 mo1 i1 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            files =\n              snd (y (case Expunge e1 mo1 i1 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            after =\n              case Expunge e1 mo1 i1 of\n              Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n              | Delete is e \\<Rightarrow> (metadata - is, files - is)\n              | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n              | Expunge e mo i \\<Rightarrow>\n                  (metadata \\<union> {i}, files - {mo})\n              | Store e mo i \\<Rightarrow>\n                  (metadata, insert i (files - {mo}))\n        in Some\n            (y(case Expunge e1 mo1 i1 of Create i e \\<Rightarrow> e\n               | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n               | Expunge e mo i \\<Rightarrow> e\n               | Store e mo i \\<Rightarrow> e :=\n                 after)))", "using assms(2)"], ["proof (prove)\nusing this:\n  i2 \\<noteq> mo1\n\ngoal (1 subgoal):\n 1. (let metadata =\n           fst (x (case Expunge e1 mo1 i1 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         files =\n           snd (x (case Expunge e1 mo1 i1 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         after =\n           case Expunge e1 mo1 i1 of\n           Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n           | Delete is e \\<Rightarrow> (metadata - is, files - is)\n           | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n           | Expunge e mo i \\<Rightarrow>\n               (metadata \\<union> {i}, files - {mo})\n           | Store e mo i \\<Rightarrow> (metadata, insert i (files - {mo}))\n     in Some\n         (x(case Expunge e1 mo1 i1 of Create i e \\<Rightarrow> e\n            | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n            | Expunge e mo i \\<Rightarrow> e\n            | Store e mo i \\<Rightarrow> e :=\n              after))) \\<bind>\n    (\\<lambda>y.\n        let metadata =\n              fst (y (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            files =\n              snd (y (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            after =\n              case Store e2 mo2 i2 of\n              Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n              | Delete is e \\<Rightarrow> (metadata - is, files - is)\n              | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n              | Expunge e mo i \\<Rightarrow>\n                  (metadata \\<union> {i}, files - {mo})\n              | Store e mo i \\<Rightarrow>\n                  (metadata, insert i (files - {mo}))\n        in Some\n            (y(case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n               | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n               | Expunge e mo i \\<Rightarrow> e\n               | Store e mo i \\<Rightarrow> e :=\n                 after))) =\n    (let metadata =\n           fst (x (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         files =\n           snd (x (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         after =\n           case Store e2 mo2 i2 of\n           Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n           | Delete is e \\<Rightarrow> (metadata - is, files - is)\n           | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n           | Expunge e mo i \\<Rightarrow>\n               (metadata \\<union> {i}, files - {mo})\n           | Store e mo i \\<Rightarrow> (metadata, insert i (files - {mo}))\n     in Some\n         (x(case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n            | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n            | Expunge e mo i \\<Rightarrow> e\n            | Store e mo i \\<Rightarrow> e :=\n              after))) \\<bind>\n    (\\<lambda>y.\n        let metadata =\n              fst (y (case Expunge e1 mo1 i1 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            files =\n              snd (y (case Expunge e1 mo1 i1 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            after =\n              case Expunge e1 mo1 i1 of\n              Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n              | Delete is e \\<Rightarrow> (metadata - is, files - is)\n              | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n              | Expunge e mo i \\<Rightarrow>\n                  (metadata \\<union> {i}, files - {mo})\n              | Store e mo i \\<Rightarrow>\n                  (metadata, insert i (files - {mo}))\n        in Some\n            (y(case Expunge e1 mo1 i1 of Create i e \\<Rightarrow> e\n               | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n               | Expunge e mo i \\<Rightarrow> e\n               | Store e mo i \\<Rightarrow> e :=\n                 after)))", "by (simp, fastforce)"], ["proof (state)\nthis:\n  (\\<langle>Expunge e1 mo1 i1\\<rangle> \\<rhd>\n   \\<langle>Store e2 mo2 i2\\<rangle>)\n   x =\n  (\\<langle>Store e2 mo2 i2\\<rangle> \\<rhd>\n   \\<langle>Expunge e1 mo1 i1\\<rangle>)\n   x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in imap) store_store_commute:\n  assumes \"i1 \\<noteq> mo2\" and \"i2 \\<noteq> mo1\"\n  shows \"(\\<langle>Store e1 mo1 i1\\<rangle> \\<rhd> \\<langle>Store e2 mo2 i2\\<rangle>) = (\\<langle>Store e2 mo2 i2\\<rangle> \\<rhd> \\<langle>Store e1 mo1 i1\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Store e1 mo1 i1\\<rangle> \\<rhd>\n    \\<langle>Store e2 mo2 i2\\<rangle> =\n    \\<langle>Store e2 mo2 i2\\<rangle> \\<rhd>\n    \\<langle>Store e1 mo1 i1\\<rangle>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<langle>Store e1 mo1 i1\\<rangle> \\<rhd>\n        \\<langle>Store e2 mo2 i2\\<rangle>)\n        x =\n       (\\<langle>Store e2 mo2 i2\\<rangle> \\<rhd>\n        \\<langle>Store e1 mo1 i1\\<rangle>)\n        x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<langle>Store e1 mo1 i1\\<rangle> \\<rhd>\n        \\<langle>Store e2 mo2 i2\\<rangle>)\n        x =\n       (\\<langle>Store e2 mo2 i2\\<rangle> \\<rhd>\n        \\<langle>Store e1 mo1 i1\\<rangle>)\n        x", "show \"(\\<langle>Store e1 mo1 i1\\<rangle> \\<rhd> \\<langle>Store e2 mo2 i2\\<rangle>) x = (\\<langle>Store e2 mo2 i2\\<rangle> \\<rhd> \\<langle>Store e1 mo1 i1\\<rangle>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>Store e1 mo1 i1\\<rangle> \\<rhd>\n     \\<langle>Store e2 mo2 i2\\<rangle>)\n     x =\n    (\\<langle>Store e2 mo2 i2\\<rangle> \\<rhd>\n     \\<langle>Store e1 mo1 i1\\<rangle>)\n     x", "unfolding  interpret_op_def kleisli_def op_elem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let metadata =\n           fst (x (case Store e1 mo1 i1 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         files =\n           snd (x (case Store e1 mo1 i1 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         after =\n           case Store e1 mo1 i1 of\n           Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n           | Delete is e \\<Rightarrow> (metadata - is, files - is)\n           | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n           | Expunge e mo i \\<Rightarrow>\n               (metadata \\<union> {i}, files - {mo})\n           | Store e mo i \\<Rightarrow> (metadata, insert i (files - {mo}))\n     in Some\n         (x(case Store e1 mo1 i1 of Create i e \\<Rightarrow> e\n            | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n            | Expunge e mo i \\<Rightarrow> e\n            | Store e mo i \\<Rightarrow> e :=\n              after))) \\<bind>\n    (\\<lambda>y.\n        let metadata =\n              fst (y (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            files =\n              snd (y (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            after =\n              case Store e2 mo2 i2 of\n              Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n              | Delete is e \\<Rightarrow> (metadata - is, files - is)\n              | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n              | Expunge e mo i \\<Rightarrow>\n                  (metadata \\<union> {i}, files - {mo})\n              | Store e mo i \\<Rightarrow>\n                  (metadata, insert i (files - {mo}))\n        in Some\n            (y(case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n               | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n               | Expunge e mo i \\<Rightarrow> e\n               | Store e mo i \\<Rightarrow> e :=\n                 after))) =\n    (let metadata =\n           fst (x (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         files =\n           snd (x (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         after =\n           case Store e2 mo2 i2 of\n           Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n           | Delete is e \\<Rightarrow> (metadata - is, files - is)\n           | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n           | Expunge e mo i \\<Rightarrow>\n               (metadata \\<union> {i}, files - {mo})\n           | Store e mo i \\<Rightarrow> (metadata, insert i (files - {mo}))\n     in Some\n         (x(case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n            | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n            | Expunge e mo i \\<Rightarrow> e\n            | Store e mo i \\<Rightarrow> e :=\n              after))) \\<bind>\n    (\\<lambda>y.\n        let metadata =\n              fst (y (case Store e1 mo1 i1 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            files =\n              snd (y (case Store e1 mo1 i1 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            after =\n              case Store e1 mo1 i1 of\n              Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n              | Delete is e \\<Rightarrow> (metadata - is, files - is)\n              | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n              | Expunge e mo i \\<Rightarrow>\n                  (metadata \\<union> {i}, files - {mo})\n              | Store e mo i \\<Rightarrow>\n                  (metadata, insert i (files - {mo}))\n        in Some\n            (y(case Store e1 mo1 i1 of Create i e \\<Rightarrow> e\n               | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n               | Expunge e mo i \\<Rightarrow> e\n               | Store e mo i \\<Rightarrow> e :=\n                 after)))", "using assms"], ["proof (prove)\nusing this:\n  i1 \\<noteq> mo2\n  i2 \\<noteq> mo1\n\ngoal (1 subgoal):\n 1. (let metadata =\n           fst (x (case Store e1 mo1 i1 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         files =\n           snd (x (case Store e1 mo1 i1 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         after =\n           case Store e1 mo1 i1 of\n           Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n           | Delete is e \\<Rightarrow> (metadata - is, files - is)\n           | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n           | Expunge e mo i \\<Rightarrow>\n               (metadata \\<union> {i}, files - {mo})\n           | Store e mo i \\<Rightarrow> (metadata, insert i (files - {mo}))\n     in Some\n         (x(case Store e1 mo1 i1 of Create i e \\<Rightarrow> e\n            | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n            | Expunge e mo i \\<Rightarrow> e\n            | Store e mo i \\<Rightarrow> e :=\n              after))) \\<bind>\n    (\\<lambda>y.\n        let metadata =\n              fst (y (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            files =\n              snd (y (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            after =\n              case Store e2 mo2 i2 of\n              Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n              | Delete is e \\<Rightarrow> (metadata - is, files - is)\n              | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n              | Expunge e mo i \\<Rightarrow>\n                  (metadata \\<union> {i}, files - {mo})\n              | Store e mo i \\<Rightarrow>\n                  (metadata, insert i (files - {mo}))\n        in Some\n            (y(case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n               | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n               | Expunge e mo i \\<Rightarrow> e\n               | Store e mo i \\<Rightarrow> e :=\n                 after))) =\n    (let metadata =\n           fst (x (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         files =\n           snd (x (case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n                   | Delete is e \\<Rightarrow> e\n                   | Append i e \\<Rightarrow> e\n                   | Expunge e mo i \\<Rightarrow> e\n                   | Store e mo i \\<Rightarrow> e));\n         after =\n           case Store e2 mo2 i2 of\n           Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n           | Delete is e \\<Rightarrow> (metadata - is, files - is)\n           | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n           | Expunge e mo i \\<Rightarrow>\n               (metadata \\<union> {i}, files - {mo})\n           | Store e mo i \\<Rightarrow> (metadata, insert i (files - {mo}))\n     in Some\n         (x(case Store e2 mo2 i2 of Create i e \\<Rightarrow> e\n            | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n            | Expunge e mo i \\<Rightarrow> e\n            | Store e mo i \\<Rightarrow> e :=\n              after))) \\<bind>\n    (\\<lambda>y.\n        let metadata =\n              fst (y (case Store e1 mo1 i1 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            files =\n              snd (y (case Store e1 mo1 i1 of Create i e \\<Rightarrow> e\n                      | Delete is e \\<Rightarrow> e\n                      | Append i e \\<Rightarrow> e\n                      | Expunge e mo i \\<Rightarrow> e\n                      | Store e mo i \\<Rightarrow> e));\n            after =\n              case Store e1 mo1 i1 of\n              Create i e \\<Rightarrow> (metadata \\<union> {i}, files)\n              | Delete is e \\<Rightarrow> (metadata - is, files - is)\n              | Append i e \\<Rightarrow> (metadata, files \\<union> {i})\n              | Expunge e mo i \\<Rightarrow>\n                  (metadata \\<union> {i}, files - {mo})\n              | Store e mo i \\<Rightarrow>\n                  (metadata, insert i (files - {mo}))\n        in Some\n            (y(case Store e1 mo1 i1 of Create i e \\<Rightarrow> e\n               | Delete is e \\<Rightarrow> e | Append i e \\<Rightarrow> e\n               | Expunge e mo i \\<Rightarrow> e\n               | Store e mo i \\<Rightarrow> e :=\n                 after)))", "by (simp, fastforce)"], ["proof (state)\nthis:\n  (\\<langle>Store e1 mo1 i1\\<rangle> \\<rhd>\n   \\<langle>Store e2 mo2 i2\\<rangle>)\n   x =\n  (\\<langle>Store e2 mo2 i2\\<rangle> \\<rhd>\n   \\<langle>Store e1 mo1 i1\\<rangle>)\n   x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}