{"file_name": "/home/qj213/afp-2021-10-22/thys/Regression_Test_Selection/Common/RTS_safe.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Regression_Test_Selection", "problem_names": ["lemma equiv_out_refl: \"equiv_out a a\"", "lemma equiv_out_trans: \"\\<lbrakk> equiv_out a b; equiv_out b c \\<rbrakk> \\<Longrightarrow> equiv_out a c\"", "lemma existence_safe_trans:\nassumes Pst_in: \"Ps \\<noteq> []\" \"set Ps \\<subseteq> progs\" \"t \\<in> tests\" and\n o0: \"o\\<^sub>0 \\<in> out (Ps!0) t\" and\n des: \"\\<forall>n < (length Ps) - 1. deselect (Ps!n) o\\<^sub>0 (Ps!(Suc n))\"\nshows \"\\<exists>o\\<^sub>n \\<in> out (last Ps) t. equiv_out o\\<^sub>0 o\\<^sub>n\""], "translations": [["", "lemma equiv_out_refl: \"equiv_out a a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv_out a a", "using equiv_class_eq_iff equiv_out_equiv"], ["proof (prove)\nusing this:\n  equiv ?A ?r \\<Longrightarrow>\n  ((?x, ?y) \\<in> ?r) =\n  (?r `` {?x} = ?r `` {?y} \\<and> ?x \\<in> ?A \\<and> ?y \\<in> ?A)\n  equiv UNIV {(x, y). equiv_out x y}\n\ngoal (1 subgoal):\n 1. equiv_out a a", "by fastforce"], ["", "lemma equiv_out_trans: \"\\<lbrakk> equiv_out a b; equiv_out b c \\<rbrakk> \\<Longrightarrow> equiv_out a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv_out a b; equiv_out b c\\<rbrakk>\n    \\<Longrightarrow> equiv_out a c", "using equiv_class_eq_iff equiv_out_equiv"], ["proof (prove)\nusing this:\n  equiv ?A ?r \\<Longrightarrow>\n  ((?x, ?y) \\<in> ?r) =\n  (?r `` {?x} = ?r `` {?y} \\<and> ?x \\<in> ?A \\<and> ?y \\<in> ?A)\n  equiv UNIV {(x, y). equiv_out x y}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv_out a b; equiv_out b c\\<rbrakk>\n    \\<Longrightarrow> equiv_out a c", "by fastforce"], ["", "text \"This shows that it is safe to continue deselecting a test based\n on its output under a previous program, to an arbitrary number of\n program changes, as long as the test is continually deselected. This\n is useful because it means changed programs don't need to generate new\n outputs for deselected tests to ensure safety of future deselections.\""], ["", "lemma existence_safe_trans:\nassumes Pst_in: \"Ps \\<noteq> []\" \"set Ps \\<subseteq> progs\" \"t \\<in> tests\" and\n o0: \"o\\<^sub>0 \\<in> out (Ps!0) t\" and\n des: \"\\<forall>n < (length Ps) - 1. deselect (Ps!n) o\\<^sub>0 (Ps!(Suc n))\"\nshows \"\\<exists>o\\<^sub>n \\<in> out (last Ps) t. equiv_out o\\<^sub>0 o\\<^sub>n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>o\\<^sub>n\\<in>out (last Ps) t. equiv_out o\\<^sub>0 o\\<^sub>n", "using assms"], ["proof (prove)\nusing this:\n  Ps \\<noteq> []\n  set Ps \\<subseteq> progs\n  t \\<in> tests\n  o\\<^sub>0 \\<in> out (Ps ! 0) t\n  \\<forall>n<length Ps - 1. deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\n\ngoal (1 subgoal):\n 1. \\<exists>o\\<^sub>n\\<in>out (last Ps) t. equiv_out o\\<^sub>0 o\\<^sub>n", "proof(induct \"length Ps\" arbitrary: Ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ps.\n       \\<lbrakk>0 = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)\n 2. \\<And>x Ps.\n       \\<lbrakk>\\<And>Ps.\n                   \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                    set Ps \\<subseteq> progs; t \\<in> tests;\n                    o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                    \\<forall>n<length Ps - 1.\n                       deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                   \\<Longrightarrow> Bex (out (last Ps) t)\n(equiv_out o\\<^sub>0);\n        Suc x = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "case 0"], ["proof (state)\nthis:\n  0 = length Ps\n  Ps \\<noteq> []\n  set Ps \\<subseteq> progs\n  t \\<in> tests\n  o\\<^sub>0 \\<in> out (Ps ! 0) t\n  \\<forall>n<length Ps - 1. deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>Ps.\n       \\<lbrakk>0 = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)\n 2. \\<And>x Ps.\n       \\<lbrakk>\\<And>Ps.\n                   \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                    set Ps \\<subseteq> progs; t \\<in> tests;\n                    o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                    \\<forall>n<length Ps - 1.\n                       deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                   \\<Longrightarrow> Bex (out (last Ps) t)\n(equiv_out o\\<^sub>0);\n        Suc x = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "with Pst_in"], ["proof (chain)\npicking this:\n  Ps \\<noteq> []\n  set Ps \\<subseteq> progs\n  t \\<in> tests\n  0 = length Ps\n  Ps \\<noteq> []\n  set Ps \\<subseteq> progs\n  t \\<in> tests\n  o\\<^sub>0 \\<in> out (Ps ! 0) t\n  \\<forall>n<length Ps - 1. deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)", "show ?case"], ["proof (prove)\nusing this:\n  Ps \\<noteq> []\n  set Ps \\<subseteq> progs\n  t \\<in> tests\n  0 = length Ps\n  Ps \\<noteq> []\n  set Ps \\<subseteq> progs\n  t \\<in> tests\n  o\\<^sub>0 \\<in> out (Ps ! 0) t\n  \\<forall>n<length Ps - 1. deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>out (last Ps) t. equiv_out o\\<^sub>0 a", "by simp"], ["proof (state)\nthis:\n  \\<exists>a\\<in>out (last Ps) t. equiv_out o\\<^sub>0 a\n\ngoal (1 subgoal):\n 1. \\<And>x Ps.\n       \\<lbrakk>\\<And>Ps.\n                   \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                    set Ps \\<subseteq> progs; t \\<in> tests;\n                    o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                    \\<forall>n<length Ps - 1.\n                       deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                   \\<Longrightarrow> Bex (out (last Ps) t)\n(equiv_out o\\<^sub>0);\n        Suc x = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Ps.\n       \\<lbrakk>\\<And>Ps.\n                   \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                    set Ps \\<subseteq> progs; t \\<in> tests;\n                    o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                    \\<forall>n<length Ps - 1.\n                       deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                   \\<Longrightarrow> Bex (out (last Ps) t)\n(equiv_out o\\<^sub>0);\n        Suc x = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "case (Suc x)"], ["proof (state)\nthis:\n  \\<lbrakk>x = length ?Ps; ?Ps \\<noteq> []; set ?Ps \\<subseteq> progs;\n   t \\<in> tests; o\\<^sub>0 \\<in> out (?Ps ! 0) t;\n   \\<forall>n<length ?Ps - 1.\n      deselect (?Ps ! n) o\\<^sub>0 (?Ps ! Suc n)\\<rbrakk>\n  \\<Longrightarrow> Bex (out (last ?Ps) t) (equiv_out o\\<^sub>0)\n  Suc x = length Ps\n  Ps \\<noteq> []\n  set Ps \\<subseteq> progs\n  t \\<in> tests\n  o\\<^sub>0 \\<in> out (Ps ! 0) t\n  \\<forall>n<length Ps - 1. deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>x Ps.\n       \\<lbrakk>\\<And>Ps.\n                   \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                    set Ps \\<subseteq> progs; t \\<in> tests;\n                    o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                    \\<forall>n<length Ps - 1.\n                       deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                   \\<Longrightarrow> Bex (out (last Ps) t)\n(equiv_out o\\<^sub>0);\n        Suc x = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = length ?Ps; ?Ps \\<noteq> []; set ?Ps \\<subseteq> progs;\n   t \\<in> tests; o\\<^sub>0 \\<in> out (?Ps ! 0) t;\n   \\<forall>n<length ?Ps - 1.\n      deselect (?Ps ! n) o\\<^sub>0 (?Ps ! Suc n)\\<rbrakk>\n  \\<Longrightarrow> Bex (out (last ?Ps) t) (equiv_out o\\<^sub>0)\n  Suc x = length Ps\n  Ps \\<noteq> []\n  set Ps \\<subseteq> progs\n  t \\<in> tests\n  o\\<^sub>0 \\<in> out (Ps ! 0) t\n  \\<forall>n<length Ps - 1. deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = length ?Ps; ?Ps \\<noteq> []; set ?Ps \\<subseteq> progs;\n   t \\<in> tests; o\\<^sub>0 \\<in> out (?Ps ! 0) t;\n   \\<forall>n<length ?Ps - 1.\n      deselect (?Ps ! n) o\\<^sub>0 (?Ps ! Suc n)\\<rbrakk>\n  \\<Longrightarrow> Bex (out (last ?Ps) t) (equiv_out o\\<^sub>0)\n  Suc x = length Ps\n  Ps \\<noteq> []\n  set Ps \\<subseteq> progs\n  t \\<in> tests\n  o\\<^sub>0 \\<in> out (Ps ! 0) t\n  \\<forall>n<length Ps - 1. deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\n\ngoal (1 subgoal):\n 1. Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "proof(induct x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Ps.\n                \\<lbrakk>0 = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n     Suc 0 = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n     t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n     \\<forall>n<length Ps - 1.\n        deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n    \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)\n 2. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "case z: 0"], ["proof (state)\nthis:\n  \\<lbrakk>0 = length ?Ps; ?Ps \\<noteq> []; set ?Ps \\<subseteq> progs;\n   t \\<in> tests; o\\<^sub>0 \\<in> out (?Ps ! 0) t;\n   \\<forall>n<length ?Ps - 1.\n      deselect (?Ps ! n) o\\<^sub>0 (?Ps ! Suc n)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a\\<in>out (last ?Ps) t. equiv_out o\\<^sub>0 a\n  Suc 0 = length Ps\n  Ps \\<noteq> []\n  set Ps \\<subseteq> progs\n  t \\<in> tests\n  o\\<^sub>0 \\<in> out (Ps ! 0) t\n  \\<forall>n<length Ps - 1. deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Ps.\n                \\<lbrakk>0 = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n     Suc 0 = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n     t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n     \\<forall>n<length Ps - 1.\n        deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n    \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)\n 2. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "from z.prems(2,3)"], ["proof (chain)\npicking this:\n  Suc 0 = length Ps\n  Ps \\<noteq> []", "have \"Ps ! (length Ps - 2) = last Ps\""], ["proof (prove)\nusing this:\n  Suc 0 = length Ps\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. Ps ! (length Ps - 2) = last Ps", "by (simp add: last_conv_nth numeral_2_eq_2)"], ["proof (state)\nthis:\n  Ps ! (length Ps - 2) = last Ps\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Ps.\n                \\<lbrakk>0 = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n     Suc 0 = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n     t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n     \\<forall>n<length Ps - 1.\n        deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n    \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)\n 2. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "with equiv_out_refl z.prems(2,6)"], ["proof (chain)\npicking this:\n  equiv_out ?a ?a\n  Suc 0 = length Ps\n  o\\<^sub>0 \\<in> out (Ps ! 0) t\n  Ps ! (length Ps - 2) = last Ps", "show ?case"], ["proof (prove)\nusing this:\n  equiv_out ?a ?a\n  Suc 0 = length Ps\n  o\\<^sub>0 \\<in> out (Ps ! 0) t\n  Ps ! (length Ps - 2) = last Ps\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>out (last Ps) t. equiv_out o\\<^sub>0 a", "by auto"], ["proof (state)\nthis:\n  \\<exists>a\\<in>out (last Ps) t. equiv_out o\\<^sub>0 a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "case Suc':(Suc x')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>Ps.\n              \\<lbrakk>x' = length Ps; Ps \\<noteq> [];\n               set Ps \\<subseteq> progs; t \\<in> tests;\n               o\\<^sub>0 \\<in> out (Ps ! 0) t;\n               \\<forall>n<length Ps - 1.\n                  deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n              \\<Longrightarrow> \\<exists>a\\<in>out (last Ps) t.\n                                   equiv_out o\\<^sub>0 a;\n   Suc x' = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n   t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n   \\<forall>n<length Ps - 1.\n      deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a\\<in>out (last Ps) t. equiv_out o\\<^sub>0 a\n  \\<lbrakk>Suc x' = length ?Ps; ?Ps \\<noteq> []; set ?Ps \\<subseteq> progs;\n   t \\<in> tests; o\\<^sub>0 \\<in> out (?Ps ! 0) t;\n   \\<forall>n<length ?Ps - 1.\n      deselect (?Ps ! n) o\\<^sub>0 (?Ps ! Suc n)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a\\<in>out (last ?Ps) t. equiv_out o\\<^sub>0 a\n  Suc (Suc x') = length Ps\n  Ps \\<noteq> []\n  set Ps \\<subseteq> progs\n  t \\<in> tests\n  o\\<^sub>0 \\<in> out (Ps ! 0) t\n  \\<forall>n<length Ps - 1. deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "let ?Ps = \"take (Suc x') Ps\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "have len': \"Suc x' = length (take (Suc x') Ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc x' = length (take (Suc x') Ps)", "using Suc'.prems(2)"], ["proof (prove)\nusing this:\n  Suc (Suc x') = length Ps\n\ngoal (1 subgoal):\n 1. Suc x' = length (take (Suc x') Ps)", "by auto"], ["proof (state)\nthis:\n  Suc x' = length (take (Suc x') Ps)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "moreover"], ["proof (state)\nthis:\n  Suc x' = length (take (Suc x') Ps)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "have nmt': \"take (Suc x') Ps \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc x') Ps \\<noteq> []", "using len'"], ["proof (prove)\nusing this:\n  Suc x' = length (take (Suc x') Ps)\n\ngoal (1 subgoal):\n 1. take (Suc x') Ps \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  take (Suc x') Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "moreover"], ["proof (state)\nthis:\n  take (Suc x') Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "have sub': \"set (take (Suc x') Ps) \\<subseteq> progs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take (Suc x') Ps) \\<subseteq> progs", "using Suc.prems(2)"], ["proof (prove)\nusing this:\n  set Ps \\<subseteq> progs\n\ngoal (1 subgoal):\n 1. set (take (Suc x') Ps) \\<subseteq> progs", "by (meson order_trans set_take_subset)"], ["proof (state)\nthis:\n  set (take (Suc x') Ps) \\<subseteq> progs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "moreover"], ["proof (state)\nthis:\n  set (take (Suc x') Ps) \\<subseteq> progs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "have \"t \\<in> tests\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> tests", "using Pst_in(3)"], ["proof (prove)\nusing this:\n  t \\<in> tests\n\ngoal (1 subgoal):\n 1. t \\<in> tests", "by simp"], ["proof (state)\nthis:\n  t \\<in> tests\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "moreover"], ["proof (state)\nthis:\n  t \\<in> tests\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "have \"o\\<^sub>0 \\<in> out (take (Suc x') Ps ! 0) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. o\\<^sub>0 \\<in> out (take (Suc x') Ps ! 0) t", "using Suc.prems(4)"], ["proof (prove)\nusing this:\n  o\\<^sub>0 \\<in> out (Ps ! 0) t\n\ngoal (1 subgoal):\n 1. o\\<^sub>0 \\<in> out (take (Suc x') Ps ! 0) t", "by simp"], ["proof (state)\nthis:\n  o\\<^sub>0 \\<in> out (take (Suc x') Ps ! 0) t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "moreover"], ["proof (state)\nthis:\n  o\\<^sub>0 \\<in> out (take (Suc x') Ps ! 0) t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "have \"\\<forall>n<length (take (Suc x') Ps) - 1.\n     deselect (take (Suc x') Ps ! n) o\\<^sub>0 (take (Suc x') Ps ! (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<length (take (Suc x') Ps) - 1.\n       deselect (take (Suc x') Ps ! n) o\\<^sub>0 (take (Suc x') Ps ! Suc n)", "using Suc.prems(5) len'"], ["proof (prove)\nusing this:\n  \\<forall>n<length Ps - 1. deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\n  Suc x' = length (take (Suc x') Ps)\n\ngoal (1 subgoal):\n 1. \\<forall>n<length (take (Suc x') Ps) - 1.\n       deselect (take (Suc x') Ps ! n) o\\<^sub>0 (take (Suc x') Ps ! Suc n)", "by simp"], ["proof (state)\nthis:\n  \\<forall>n<length (take (Suc x') Ps) - 1.\n     deselect (take (Suc x') Ps ! n) o\\<^sub>0 (take (Suc x') Ps ! Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "ultimately"], ["proof (chain)\npicking this:\n  Suc x' = length (take (Suc x') Ps)\n  take (Suc x') Ps \\<noteq> []\n  set (take (Suc x') Ps) \\<subseteq> progs\n  t \\<in> tests\n  o\\<^sub>0 \\<in> out (take (Suc x') Ps ! 0) t\n  \\<forall>n<length (take (Suc x') Ps) - 1.\n     deselect (take (Suc x') Ps ! n) o\\<^sub>0 (take (Suc x') Ps ! Suc n)", "have \"\\<exists>o'\\<in>out (last ?Ps) t. equiv_out o\\<^sub>0 o'\""], ["proof (prove)\nusing this:\n  Suc x' = length (take (Suc x') Ps)\n  take (Suc x') Ps \\<noteq> []\n  set (take (Suc x') Ps) \\<subseteq> progs\n  t \\<in> tests\n  o\\<^sub>0 \\<in> out (take (Suc x') Ps ! 0) t\n  \\<forall>n<length (take (Suc x') Ps) - 1.\n     deselect (take (Suc x') Ps ! n) o\\<^sub>0 (take (Suc x') Ps ! Suc n)\n\ngoal (1 subgoal):\n 1. \\<exists>o'\\<in>out (last (take (Suc x') Ps)) t. equiv_out o\\<^sub>0 o'", "by(rule Suc'.prems(1)[of ?Ps])"], ["proof (state)\nthis:\n  \\<exists>o'\\<in>out (last (take (Suc x') Ps)) t. equiv_out o\\<^sub>0 o'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "then"], ["proof (chain)\npicking this:\n  \\<exists>o'\\<in>out (last (take (Suc x') Ps)) t. equiv_out o\\<^sub>0 o'", "obtain o' where o': \"o' \\<in> out (last ?Ps) t\" and eo: \"equiv_out o\\<^sub>0 o'\""], ["proof (prove)\nusing this:\n  \\<exists>o'\\<in>out (last (take (Suc x') Ps)) t. equiv_out o\\<^sub>0 o'\n\ngoal (1 subgoal):\n 1. (\\<And>o'.\n        \\<lbrakk>o' \\<in> out (last (take (Suc x') Ps)) t;\n         equiv_out o\\<^sub>0 o'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarify"], ["proof (state)\nthis:\n  o' \\<in> out (last (take (Suc x') Ps)) t\n  equiv_out o\\<^sub>0 o'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "from Suc.prems(1) Suc'.prems(2) len' nmt'"], ["proof (chain)\npicking this:\n  Ps \\<noteq> []\n  Suc (Suc x') = length Ps\n  Suc x' = length (take (Suc x') Ps)\n  take (Suc x') Ps \\<noteq> []", "have \"last (take (Suc x') Ps) = Ps!x'\" \"last Ps = Ps!(Suc x')\""], ["proof (prove)\nusing this:\n  Ps \\<noteq> []\n  Suc (Suc x') = length Ps\n  Suc x' = length (take (Suc x') Ps)\n  take (Suc x') Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (take (Suc x') Ps) = Ps ! x' &&& last Ps = Ps ! Suc x'", "by (metis diff_Suc_1 last_conv_nth lessI nth_take)+"], ["proof (state)\nthis:\n  last (take (Suc x') Ps) = Ps ! x'\n  last Ps = Ps ! Suc x'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "moreover"], ["proof (state)\nthis:\n  last (take (Suc x') Ps) = Ps ! x'\n  last Ps = Ps ! Suc x'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "have \"x' < length Ps - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' < length Ps - 1", "using Suc'.prems(2)"], ["proof (prove)\nusing this:\n  Suc (Suc x') = length Ps\n\ngoal (1 subgoal):\n 1. x' < length Ps - 1", "by linarith"], ["proof (state)\nthis:\n  x' < length Ps - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "ultimately"], ["proof (chain)\npicking this:\n  last (take (Suc x') Ps) = Ps ! x'\n  last Ps = Ps ! Suc x'\n  x' < length Ps - 1", "have des':\"deselect (last (take (Suc x') Ps)) o\\<^sub>0 (last Ps)\""], ["proof (prove)\nusing this:\n  last (take (Suc x') Ps) = Ps ! x'\n  last Ps = Ps ! Suc x'\n  x' < length Ps - 1\n\ngoal (1 subgoal):\n 1. deselect (last (take (Suc x') Ps)) o\\<^sub>0 (last Ps)", "using Suc.prems(5)"], ["proof (prove)\nusing this:\n  last (take (Suc x') Ps) = Ps ! x'\n  last Ps = Ps ! Suc x'\n  x' < length Ps - 1\n  \\<forall>n<length Ps - 1. deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\n\ngoal (1 subgoal):\n 1. deselect (last (take (Suc x') Ps)) o\\<^sub>0 (last Ps)", "by simp"], ["proof (state)\nthis:\n  deselect (last (take (Suc x') Ps)) o\\<^sub>0 (last Ps)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "from Suc.prems(1,2) sub' nmt' last_in_set"], ["proof (chain)\npicking this:\n  Ps \\<noteq> []\n  set Ps \\<subseteq> progs\n  set (take (Suc x') Ps) \\<subseteq> progs\n  take (Suc x') Ps \\<noteq> []\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as", "have Ps_in: \"last (take (Suc x') Ps) \\<in> progs\" \"last Ps \\<in> progs\""], ["proof (prove)\nusing this:\n  Ps \\<noteq> []\n  set Ps \\<subseteq> progs\n  set (take (Suc x') Ps) \\<subseteq> progs\n  take (Suc x') Ps \\<noteq> []\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. last (take (Suc x') Ps) \\<in> progs &&& last Ps \\<in> progs", "by blast+"], ["proof (state)\nthis:\n  last (take (Suc x') Ps) \\<in> progs\n  last Ps \\<in> progs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "have \"\\<exists>o\\<^sub>n \\<in> out (last Ps) t. equiv_out o' o\\<^sub>n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>o\\<^sub>n\\<in>out (last Ps) t. equiv_out o' o\\<^sub>n", "by(rule existence_safe[where P=\"last (take (Suc x') Ps)\" and P'=\"last Ps\" and t=t,\n                    OF Ps_in Pst_in(3) o' equiv_out_deselect[OF eo des']])"], ["proof (state)\nthis:\n  \\<exists>o\\<^sub>n\\<in>out (last Ps) t. equiv_out o' o\\<^sub>n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "then"], ["proof (chain)\npicking this:\n  \\<exists>o\\<^sub>n\\<in>out (last Ps) t. equiv_out o' o\\<^sub>n", "obtain o\\<^sub>n where oN: \"o\\<^sub>n \\<in> out (last Ps) t\" and eo': \"equiv_out o' o\\<^sub>n\""], ["proof (prove)\nusing this:\n  \\<exists>o\\<^sub>n\\<in>out (last Ps) t. equiv_out o' o\\<^sub>n\n\ngoal (1 subgoal):\n 1. (\\<And>o\\<^sub>n.\n        \\<lbrakk>o\\<^sub>n \\<in> out (last Ps) t;\n         equiv_out o' o\\<^sub>n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarify"], ["proof (state)\nthis:\n  o\\<^sub>n \\<in> out (last Ps) t\n  equiv_out o' o\\<^sub>n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "moreover"], ["proof (state)\nthis:\n  o\\<^sub>n \\<in> out (last Ps) t\n  equiv_out o' o\\<^sub>n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "from eo eo'"], ["proof (chain)\npicking this:\n  equiv_out o\\<^sub>0 o'\n  equiv_out o' o\\<^sub>n", "have \"equiv_out o\\<^sub>0 o\\<^sub>n\""], ["proof (prove)\nusing this:\n  equiv_out o\\<^sub>0 o'\n  equiv_out o' o\\<^sub>n\n\ngoal (1 subgoal):\n 1. equiv_out o\\<^sub>0 o\\<^sub>n", "by(rule equiv_out_trans)"], ["proof (state)\nthis:\n  equiv_out o\\<^sub>0 o\\<^sub>n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>\\<And>Ps.\n                            \\<lbrakk>x = length Ps; Ps \\<noteq> [];\n                             set Ps \\<subseteq> progs; t \\<in> tests;\n                             o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                             \\<forall>n<length Ps - 1.\n                                deselect (Ps ! n) o\\<^sub>0\n                                 (Ps ! Suc n)\\<rbrakk>\n                            \\<Longrightarrow> Bex (out (last Ps) t)\n         (equiv_out o\\<^sub>0);\n                 Suc x = length Ps; Ps \\<noteq> [];\n                 set Ps \\<subseteq> progs; t \\<in> tests;\n                 o\\<^sub>0 \\<in> out (Ps ! 0) t;\n                 \\<forall>n<length Ps - 1.\n                    deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n                \\<Longrightarrow> Bex (out (last Ps) t)\n                                   (equiv_out o\\<^sub>0);\n        \\<And>Ps.\n           \\<lbrakk>Suc x = length Ps; Ps \\<noteq> [];\n            set Ps \\<subseteq> progs; t \\<in> tests;\n            o\\<^sub>0 \\<in> out (Ps ! 0) t;\n            \\<forall>n<length Ps - 1.\n               deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n           \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0);\n        Suc (Suc x) = length Ps; Ps \\<noteq> []; set Ps \\<subseteq> progs;\n        t \\<in> tests; o\\<^sub>0 \\<in> out (Ps ! 0) t;\n        \\<forall>n<length Ps - 1.\n           deselect (Ps ! n) o\\<^sub>0 (Ps ! Suc n)\\<rbrakk>\n       \\<Longrightarrow> Bex (out (last Ps) t) (equiv_out o\\<^sub>0)", "ultimately"], ["proof (chain)\npicking this:\n  o\\<^sub>n \\<in> out (last Ps) t\n  equiv_out o' o\\<^sub>n\n  equiv_out o\\<^sub>0 o\\<^sub>n", "show ?case"], ["proof (prove)\nusing this:\n  o\\<^sub>n \\<in> out (last Ps) t\n  equiv_out o' o\\<^sub>n\n  equiv_out o\\<^sub>0 o\\<^sub>n\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>out (last Ps) t. equiv_out o\\<^sub>0 a", "by auto"], ["proof (state)\nthis:\n  \\<exists>a\\<in>out (last Ps) t. equiv_out o\\<^sub>0 a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Bex (out (last Ps) t) (equiv_out o\\<^sub>0)\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open> @{text RTS_safe} \\<close>"], ["", "end"]]}