{"file_name": "/home/qj213/afp-2021-10-22/thys/Regression_Test_Selection/JinjaSuppl/JVMExecStepInductive.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Regression_Test_Selection", "problem_names": ["lemma exec_step_input_StepTD[simp]:\nassumes \"exec_step_input P C M pc ics = StepT Cs a\" shows \"ics = Throwing Cs a\"", "lemma exec_step_input_StepCD[simp]:\nassumes \"exec_step_input P C M pc ics = StepC C' Cs\" shows \"ics = Calling C' Cs\"", "lemma exec_step_input_StepC2D[simp]:\nassumes \"exec_step_input P C M pc ics = StepC2 C' Cs\" shows \"ics = Called (C'#Cs)\"", "lemma exec_step_input_StepID:\nassumes \"exec_step_input P C M pc ics = StepI i\"\nshows \"(ics = Called [] \\<or> ics = No_ics) \\<and> instrs_of P C M ! pc = i\"", "lemma exec_step_imp_exec_step_ind:\nassumes es: \"exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\"\nshows \"exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh (xp', h', frs', sh')\"", "lemma exec_step_ind_imp_exec_step:\nassumes esi: \"exec_step_ind si P h stk loc C M pc ics frs sh (xp', h', frs', sh')\"\n  and si: \"exec_step_input P C M pc ics = si\"\nshows \"exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\"", "lemma exec_step_ind_equiv:\n \"exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n   = exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh (xp', h', frs', sh')\""], "translations": [["", "lemma exec_step_input_StepTD[simp]:\nassumes \"exec_step_input P C M pc ics = StepT Cs a\" shows \"ics = Throwing Cs a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ics = Throwing Cs a", "using assms"], ["proof (prove)\nusing this:\n  exec_step_input P C M pc ics = StepT Cs a\n\ngoal (1 subgoal):\n 1. ics = Throwing Cs a", "proof(cases ics)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>exec_step_input P C M pc ics = StepT Cs a;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> ics = Throwing Cs a\n 2. \\<And>x21 x22.\n       \\<lbrakk>exec_step_input P C M pc ics = StepT Cs a;\n        ics = Calling x21 x22\\<rbrakk>\n       \\<Longrightarrow> ics = Throwing Cs a\n 3. \\<And>x3.\n       \\<lbrakk>exec_step_input P C M pc ics = StepT Cs a;\n        ics = Called x3\\<rbrakk>\n       \\<Longrightarrow> ics = Throwing Cs a\n 4. \\<And>x41 x42.\n       \\<lbrakk>exec_step_input P C M pc ics = StepT Cs a;\n        ics = Throwing x41 x42\\<rbrakk>\n       \\<Longrightarrow> ics = Throwing Cs a", "case (Called Cs)"], ["proof (state)\nthis:\n  ics = Called Cs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>exec_step_input P C M pc ics = StepT Cs a;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> ics = Throwing Cs a\n 2. \\<And>x21 x22.\n       \\<lbrakk>exec_step_input P C M pc ics = StepT Cs a;\n        ics = Calling x21 x22\\<rbrakk>\n       \\<Longrightarrow> ics = Throwing Cs a\n 3. \\<And>x3.\n       \\<lbrakk>exec_step_input P C M pc ics = StepT Cs a;\n        ics = Called x3\\<rbrakk>\n       \\<Longrightarrow> ics = Throwing Cs a\n 4. \\<And>x41 x42.\n       \\<lbrakk>exec_step_input P C M pc ics = StepT Cs a;\n        ics = Throwing x41 x42\\<rbrakk>\n       \\<Longrightarrow> ics = Throwing Cs a", "with assms"], ["proof (chain)\npicking this:\n  exec_step_input P C M pc ics = StepT Cs a\n  ics = Called Cs", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_step_input P C M pc ics = StepT Cs a\n  ics = Called Cs\n\ngoal (1 subgoal):\n 1. ics = Throwing Cs a", "by(cases Cs; simp)"], ["proof (state)\nthis:\n  ics = Throwing Cs a\n\ngoal (3 subgoals):\n 1. \\<lbrakk>exec_step_input P C M pc ics = StepT Cs a;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> ics = Throwing Cs a\n 2. \\<And>x21 x22.\n       \\<lbrakk>exec_step_input P C M pc ics = StepT Cs a;\n        ics = Calling x21 x22\\<rbrakk>\n       \\<Longrightarrow> ics = Throwing Cs a\n 3. \\<And>x41 x42.\n       \\<lbrakk>exec_step_input P C M pc ics = StepT Cs a;\n        ics = Throwing x41 x42\\<rbrakk>\n       \\<Longrightarrow> ics = Throwing Cs a", "qed(auto)"], ["", "lemma exec_step_input_StepCD[simp]:\nassumes \"exec_step_input P C M pc ics = StepC C' Cs\" shows \"ics = Calling C' Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ics = Calling C' Cs", "using assms"], ["proof (prove)\nusing this:\n  exec_step_input P C M pc ics = StepC C' Cs\n\ngoal (1 subgoal):\n 1. ics = Calling C' Cs", "proof(cases ics)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>exec_step_input P C M pc ics = StepC C' Cs;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> ics = Calling C' Cs\n 2. \\<And>x21 x22.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC C' Cs;\n        ics = Calling x21 x22\\<rbrakk>\n       \\<Longrightarrow> ics = Calling C' Cs\n 3. \\<And>x3.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC C' Cs;\n        ics = Called x3\\<rbrakk>\n       \\<Longrightarrow> ics = Calling C' Cs\n 4. \\<And>x41 x42.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC C' Cs;\n        ics = Throwing x41 x42\\<rbrakk>\n       \\<Longrightarrow> ics = Calling C' Cs", "case (Called Cs)"], ["proof (state)\nthis:\n  ics = Called Cs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>exec_step_input P C M pc ics = StepC C' Cs;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> ics = Calling C' Cs\n 2. \\<And>x21 x22.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC C' Cs;\n        ics = Calling x21 x22\\<rbrakk>\n       \\<Longrightarrow> ics = Calling C' Cs\n 3. \\<And>x3.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC C' Cs;\n        ics = Called x3\\<rbrakk>\n       \\<Longrightarrow> ics = Calling C' Cs\n 4. \\<And>x41 x42.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC C' Cs;\n        ics = Throwing x41 x42\\<rbrakk>\n       \\<Longrightarrow> ics = Calling C' Cs", "with assms"], ["proof (chain)\npicking this:\n  exec_step_input P C M pc ics = StepC C' Cs\n  ics = Called Cs", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_step_input P C M pc ics = StepC C' Cs\n  ics = Called Cs\n\ngoal (1 subgoal):\n 1. ics = Calling C' Cs", "by(cases Cs; simp)"], ["proof (state)\nthis:\n  ics = Calling C' Cs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>exec_step_input P C M pc ics = StepC C' Cs;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> ics = Calling C' Cs\n 2. \\<And>x21 x22.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC C' Cs;\n        ics = Calling x21 x22\\<rbrakk>\n       \\<Longrightarrow> ics = Calling C' Cs\n 3. \\<And>x41 x42.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC C' Cs;\n        ics = Throwing x41 x42\\<rbrakk>\n       \\<Longrightarrow> ics = Calling C' Cs", "qed(auto)"], ["", "lemma exec_step_input_StepC2D[simp]:\nassumes \"exec_step_input P C M pc ics = StepC2 C' Cs\" shows \"ics = Called (C'#Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ics = Called (C' # Cs)", "using assms"], ["proof (prove)\nusing this:\n  exec_step_input P C M pc ics = StepC2 C' Cs\n\ngoal (1 subgoal):\n 1. ics = Called (C' # Cs)", "proof(cases ics)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>exec_step_input P C M pc ics = StepC2 C' Cs;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> ics = Called (C' # Cs)\n 2. \\<And>x21 x22.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC2 C' Cs;\n        ics = Calling x21 x22\\<rbrakk>\n       \\<Longrightarrow> ics = Called (C' # Cs)\n 3. \\<And>x3.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC2 C' Cs;\n        ics = Called x3\\<rbrakk>\n       \\<Longrightarrow> ics = Called (C' # Cs)\n 4. \\<And>x41 x42.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC2 C' Cs;\n        ics = Throwing x41 x42\\<rbrakk>\n       \\<Longrightarrow> ics = Called (C' # Cs)", "case (Called Cs)"], ["proof (state)\nthis:\n  ics = Called Cs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>exec_step_input P C M pc ics = StepC2 C' Cs;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> ics = Called (C' # Cs)\n 2. \\<And>x21 x22.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC2 C' Cs;\n        ics = Calling x21 x22\\<rbrakk>\n       \\<Longrightarrow> ics = Called (C' # Cs)\n 3. \\<And>x3.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC2 C' Cs;\n        ics = Called x3\\<rbrakk>\n       \\<Longrightarrow> ics = Called (C' # Cs)\n 4. \\<And>x41 x42.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC2 C' Cs;\n        ics = Throwing x41 x42\\<rbrakk>\n       \\<Longrightarrow> ics = Called (C' # Cs)", "with assms"], ["proof (chain)\npicking this:\n  exec_step_input P C M pc ics = StepC2 C' Cs\n  ics = Called Cs", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_step_input P C M pc ics = StepC2 C' Cs\n  ics = Called Cs\n\ngoal (1 subgoal):\n 1. ics = Called (C' # Cs)", "by(cases Cs; simp)"], ["proof (state)\nthis:\n  ics = Called (C' # Cs)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>exec_step_input P C M pc ics = StepC2 C' Cs;\n     ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> ics = Called (C' # Cs)\n 2. \\<And>x21 x22.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC2 C' Cs;\n        ics = Calling x21 x22\\<rbrakk>\n       \\<Longrightarrow> ics = Called (C' # Cs)\n 3. \\<And>x41 x42.\n       \\<lbrakk>exec_step_input P C M pc ics = StepC2 C' Cs;\n        ics = Throwing x41 x42\\<rbrakk>\n       \\<Longrightarrow> ics = Called (C' # Cs)", "qed(auto)"], ["", "lemma exec_step_input_StepID:\nassumes \"exec_step_input P C M pc ics = StepI i\"\nshows \"(ics = Called [] \\<or> ics = No_ics) \\<and> instrs_of P C M ! pc = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ics = Called [] \\<or> ics = No_ics) \\<and> instrs_of P C M ! pc = i", "using assms"], ["proof (prove)\nusing this:\n  exec_step_input P C M pc ics = StepI i\n\ngoal (1 subgoal):\n 1. (ics = Called [] \\<or> ics = No_ics) \\<and> instrs_of P C M ! pc = i", "proof(cases ics)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>exec_step_input P C M pc ics = StepI i; ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> (ics = Called [] \\<or> ics = No_ics) \\<and>\n                      instrs_of P C M ! pc = i\n 2. \\<And>x21 x22.\n       \\<lbrakk>exec_step_input P C M pc ics = StepI i;\n        ics = Calling x21 x22\\<rbrakk>\n       \\<Longrightarrow> (ics = Called [] \\<or> ics = No_ics) \\<and>\n                         instrs_of P C M ! pc = i\n 3. \\<And>x3.\n       \\<lbrakk>exec_step_input P C M pc ics = StepI i;\n        ics = Called x3\\<rbrakk>\n       \\<Longrightarrow> (ics = Called [] \\<or> ics = No_ics) \\<and>\n                         instrs_of P C M ! pc = i\n 4. \\<And>x41 x42.\n       \\<lbrakk>exec_step_input P C M pc ics = StepI i;\n        ics = Throwing x41 x42\\<rbrakk>\n       \\<Longrightarrow> (ics = Called [] \\<or> ics = No_ics) \\<and>\n                         instrs_of P C M ! pc = i", "case (Called Cs)"], ["proof (state)\nthis:\n  ics = Called Cs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>exec_step_input P C M pc ics = StepI i; ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> (ics = Called [] \\<or> ics = No_ics) \\<and>\n                      instrs_of P C M ! pc = i\n 2. \\<And>x21 x22.\n       \\<lbrakk>exec_step_input P C M pc ics = StepI i;\n        ics = Calling x21 x22\\<rbrakk>\n       \\<Longrightarrow> (ics = Called [] \\<or> ics = No_ics) \\<and>\n                         instrs_of P C M ! pc = i\n 3. \\<And>x3.\n       \\<lbrakk>exec_step_input P C M pc ics = StepI i;\n        ics = Called x3\\<rbrakk>\n       \\<Longrightarrow> (ics = Called [] \\<or> ics = No_ics) \\<and>\n                         instrs_of P C M ! pc = i\n 4. \\<And>x41 x42.\n       \\<lbrakk>exec_step_input P C M pc ics = StepI i;\n        ics = Throwing x41 x42\\<rbrakk>\n       \\<Longrightarrow> (ics = Called [] \\<or> ics = No_ics) \\<and>\n                         instrs_of P C M ! pc = i", "with assms"], ["proof (chain)\npicking this:\n  exec_step_input P C M pc ics = StepI i\n  ics = Called Cs", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_step_input P C M pc ics = StepI i\n  ics = Called Cs\n\ngoal (1 subgoal):\n 1. (ics = Called [] \\<or> ics = No_ics) \\<and> instrs_of P C M ! pc = i", "by(cases Cs; simp)"], ["proof (state)\nthis:\n  (ics = Called [] \\<or> ics = No_ics) \\<and> instrs_of P C M ! pc = i\n\ngoal (3 subgoals):\n 1. \\<lbrakk>exec_step_input P C M pc ics = StepI i; ics = No_ics\\<rbrakk>\n    \\<Longrightarrow> (ics = Called [] \\<or> ics = No_ics) \\<and>\n                      instrs_of P C M ! pc = i\n 2. \\<And>x21 x22.\n       \\<lbrakk>exec_step_input P C M pc ics = StepI i;\n        ics = Calling x21 x22\\<rbrakk>\n       \\<Longrightarrow> (ics = Called [] \\<or> ics = No_ics) \\<and>\n                         instrs_of P C M ! pc = i\n 3. \\<And>x41 x42.\n       \\<lbrakk>exec_step_input P C M pc ics = StepI i;\n        ics = Throwing x41 x42\\<rbrakk>\n       \\<Longrightarrow> (ics = Called [] \\<or> ics = No_ics) \\<and>\n                         instrs_of P C M ! pc = i", "qed(auto)"], ["", "subsection \"Equivalence of @{term exec_step} and @{term exec_step_input}\""], ["", "lemma exec_step_imp_exec_step_ind:\nassumes es: \"exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\"\nshows \"exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh (xp', h', frs', sh')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases \"exec_step_input P C M pc ics\")"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x21 x22.\n       exec_step_input P C M pc ics = StepC x21 x22 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x31 x32.\n       exec_step_input P C M pc ics = StepC2 x31 x32 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x41 x42.\n       exec_step_input P C M pc ics = StepT x41 x42 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "case (StepT Cs a)"], ["proof (state)\nthis:\n  exec_step_input P C M pc ics = StepT Cs a\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x21 x22.\n       exec_step_input P C M pc ics = StepC x21 x22 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x31 x32.\n       exec_step_input P C M pc ics = StepC2 x31 x32 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x41 x42.\n       exec_step_input P C M pc ics = StepT x41 x42 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C M pc ics = StepT Cs a", "have \"ics = Throwing Cs a\""], ["proof (prove)\nusing this:\n  exec_step_input P C M pc ics = StepT Cs a\n\ngoal (1 subgoal):\n 1. ics = Throwing Cs a", "by simp"], ["proof (state)\nthis:\n  ics = Throwing Cs a\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x21 x22.\n       exec_step_input P C M pc ics = StepC x21 x22 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x31 x32.\n       exec_step_input P C M pc ics = StepC2 x31 x32 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x41 x42.\n       exec_step_input P C M pc ics = StepT x41 x42 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  ics = Throwing Cs a", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Throwing Cs a\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_InitThrow exec_step_ind_InitThrow_End StepT es"], ["proof (prove)\nusing this:\n  ics = Throwing Cs a\n  exec_step_ind (StepT (?C # ?Cs) ?a) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0\n   ?pc ?ics ?frs ?sh\n   (None, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, Throwing ?Cs ?a) # ?frs, ?sh\n    (?C \\<mapsto> (fst (the (?sh ?C)), Error)))\n  exec_step_ind (StepT [] ?a) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics\n   ?frs ?sh\n   (\\<lfloor>?a\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, No_ics) # ?frs, ?sh)\n  exec_step_input P C M pc ics = StepT Cs a\n  exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(cases Cs, auto)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x21 x22.\n       exec_step_input P C M pc ics = StepC x21 x22 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x31 x32.\n       exec_step_input P C M pc ics = StepC2 x31 x32 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x21 x22.\n       exec_step_input P C M pc ics = StepC x21 x22 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x31 x32.\n       exec_step_input P C M pc ics = StepC2 x31 x32 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "case (StepC C1 Cs)"], ["proof (state)\nthis:\n  exec_step_input P C M pc ics = StepC C1 Cs\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x21 x22.\n       exec_step_input P C M pc ics = StepC x21 x22 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x31 x32.\n       exec_step_input P C M pc ics = StepC2 x31 x32 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C M pc ics = StepC C1 Cs", "have ics: \"ics = Calling C1 Cs\""], ["proof (prove)\nusing this:\n  exec_step_input P C M pc ics = StepC C1 Cs\n\ngoal (1 subgoal):\n 1. ics = Calling C1 Cs", "by simp"], ["proof (state)\nthis:\n  ics = Calling C1 Cs\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x21 x22.\n       exec_step_input P C M pc ics = StepC x21 x22 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x31 x32.\n       exec_step_input P C M pc ics = StepC2 x31 x32 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "obtain D b Ts T m where lets: \"method P C1 clinit = (D,b,Ts,T,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D b Ts T m.\n        method P C1 clinit = (D, b, Ts, T, m) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"method P C1 clinit\")"], ["proof (state)\nthis:\n  method P C1 clinit = (D, b, Ts, T, m)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x21 x22.\n       exec_step_input P C M pc ics = StepC x21 x22 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x31 x32.\n       exec_step_input P C M pc ics = StepC2 x31 x32 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  method P C1 clinit = (D, b, Ts, T, m)", "obtain mxs mxl\\<^sub>0 ins xt where m: \"m = (mxs,mxl\\<^sub>0,ins,xt)\""], ["proof (prove)\nusing this:\n  method P C1 clinit = (D, b, Ts, T, m)\n\ngoal (1 subgoal):\n 1. (\\<And>mxs mxl\\<^sub>0 ins xt.\n        m = (mxs, mxl\\<^sub>0, ins, xt) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases m)"], ["proof (state)\nthis:\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x21 x22.\n       exec_step_input P C M pc ics = StepC x21 x22 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x31 x32.\n       exec_step_input P C M pc ics = StepC2 x31 x32 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases \"sh C1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sh C1 = None \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>a.\n       sh C1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "case None"], ["proof (state)\nthis:\n  sh C1 = None\n\ngoal (2 subgoals):\n 1. sh C1 = None \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>a.\n       sh C1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  sh C1 = None", "show ?thesis"], ["proof (prove)\nusing this:\n  sh C1 = None\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Init_None_Called ics assms"], ["proof (prove)\nusing this:\n  sh C1 = None\n  ?sh ?C = None \\<Longrightarrow>\n  exec_step_ind (StepC ?C ?Cs) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc\n   ?ics ?frs ?sh\n   (None, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, Calling ?C ?Cs) # ?frs, ?sh\n    (?C \\<mapsto> (sblank ?P ?C, Prepared)))\n  ics = Calling C1 Cs\n  exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by auto"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh C1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh C1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "case (Some a)"], ["proof (state)\nthis:\n  sh C1 = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh C1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  sh C1 = \\<lfloor>a\\<rfloor>", "obtain sfs i where sfsi: \"a = (sfs,i)\""], ["proof (prove)\nusing this:\n  sh C1 = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>sfs i. a = (sfs, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases a)"], ["proof (state)\nthis:\n  a = (sfs, i)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh C1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  a = (sfs, i)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = (sfs, i)\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Init_Done exec_step_ind_Init_Processing\n      exec_step_ind_Init_Error m lets Some ics assms"], ["proof (prove)\nusing this:\n  a = (sfs, i)\n  ?sh ?C = \\<lfloor>(?sfs, Done)\\<rfloor> \\<Longrightarrow>\n  exec_step_ind (StepC ?C ?Cs) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc\n   ?ics ?frs ?sh\n   (None, ?h, (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, Called ?Cs) # ?frs,\n    ?sh)\n  ?sh ?C = \\<lfloor>(?sfs, Processing)\\<rfloor> \\<Longrightarrow>\n  exec_step_ind (StepC ?C ?Cs) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc\n   ?ics ?frs ?sh\n   (None, ?h, (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, Called ?Cs) # ?frs,\n    ?sh)\n  ?sh ?C = \\<lfloor>(?sfs, Error)\\<rfloor> \\<Longrightarrow>\n  exec_step_ind (StepC ?C ?Cs) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc\n   ?ics ?frs ?sh\n   (None, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n     Throwing ?Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n    ?frs,\n    ?sh)\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n  method P C1 clinit = (D, b, Ts, T, m)\n  sh C1 = \\<lfloor>a\\<rfloor>\n  ics = Calling C1 Cs\n  exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases i)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>a = (sfs, i);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Error)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h,\n          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n           Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n          frs,\n          sh);\n     m = (mxs, mxl\\<^sub>0, ins, xt); method P C1 clinit = (D, b, Ts, T, m);\n     sh C1 = \\<lfloor>a\\<rfloor>; ics = Calling C1 Cs;\n     exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>a = (sfs, i);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Error)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h,\n          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n           Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n          frs,\n          sh);\n     m = (mxs, mxl\\<^sub>0, ins, xt); method P C1 clinit = (D, b, Ts, T, m);\n     sh C1 = \\<lfloor>a\\<rfloor>; ics = Calling C1 Cs;\n     exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Processing\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>a = (sfs, i);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Error)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h,\n          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n           Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n          frs,\n          sh);\n     m = (mxs, mxl\\<^sub>0, ins, xt); method P C1 clinit = (D, b, Ts, T, m);\n     sh C1 = \\<lfloor>a\\<rfloor>; ics = Calling C1 Cs;\n     exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 4. \\<lbrakk>a = (sfs, i);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Error)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h,\n          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n           Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n          frs,\n          sh);\n     m = (mxs, mxl\\<^sub>0, ins, xt); method P C1 clinit = (D, b, Ts, T, m);\n     sh C1 = \\<lfloor>a\\<rfloor>; ics = Calling C1 Cs;\n     exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case Prepared"], ["proof (state)\nthis:\n  i = Prepared\n\ngoal (4 subgoals):\n 1. \\<lbrakk>a = (sfs, i);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Error)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h,\n          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n           Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n          frs,\n          sh);\n     m = (mxs, mxl\\<^sub>0, ins, xt); method P C1 clinit = (D, b, Ts, T, m);\n     sh C1 = \\<lfloor>a\\<rfloor>; ics = Calling C1 Cs;\n     exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>a = (sfs, i);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Error)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h,\n          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n           Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n          frs,\n          sh);\n     m = (mxs, mxl\\<^sub>0, ins, xt); method P C1 clinit = (D, b, Ts, T, m);\n     sh C1 = \\<lfloor>a\\<rfloor>; ics = Calling C1 Cs;\n     exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Processing\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>a = (sfs, i);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Error)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h,\n          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n           Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n          frs,\n          sh);\n     m = (mxs, mxl\\<^sub>0, ins, xt); method P C1 clinit = (D, b, Ts, T, m);\n     sh C1 = \\<lfloor>a\\<rfloor>; ics = Calling C1 Cs;\n     exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 4. \\<lbrakk>a = (sfs, i);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Error)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h,\n          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n           Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n          frs,\n          sh);\n     m = (mxs, mxl\\<^sub>0, ins, xt); method P C1 clinit = (D, b, Ts, T, m);\n     sh C1 = \\<lfloor>a\\<rfloor>; ics = Calling C1 Cs;\n     exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Init_Prepared_Object[where P=P] exec_step_ind_Init_Prepared_nObject\n       sfsi m lets Prepared Some ics assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?sh ?C = \\<lfloor>(?sfs, Prepared)\\<rfloor>;\n   ?sh' = ?sh(?C \\<mapsto> (fst (the (?sh ?C)), Processing));\n   ?C = Object\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepC ?C ?Cs) P ?h ?stk ?loc ?C\\<^sub>0\n                     ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Called (?C # ?Cs)) #\n                      ?frs,\n                      ?sh')\n  \\<lbrakk>?sh ?C = \\<lfloor>(?sfs, Prepared)\\<rfloor>;\n   ?sh' = ?sh(?C \\<mapsto> (fst (the (?sh ?C)), Processing));\n   ?C \\<noteq> Object; ?D = fst (the (class ?P ?C))\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepC ?C ?Cs) ?P ?h ?stk ?loc ?C\\<^sub>0\n                     ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling ?D (?C # ?Cs)) #\n                      ?frs,\n                      ?sh')\n  a = (sfs, i)\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n  method P C1 clinit = (D, b, Ts, T, m)\n  i = Prepared\n  sh C1 = \\<lfloor>a\\<rfloor>\n  ics = Calling C1 Cs\n  exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (3 subgoals):\n 1. \\<lbrakk>a = (sfs, i);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Error)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h,\n          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n           Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n          frs,\n          sh);\n     m = (mxs, mxl\\<^sub>0, ins, xt); method P C1 clinit = (D, b, Ts, T, m);\n     sh C1 = \\<lfloor>a\\<rfloor>; ics = Calling C1 Cs;\n     exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>a = (sfs, i);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Error)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h,\n          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n           Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n          frs,\n          sh);\n     m = (mxs, mxl\\<^sub>0, ins, xt); method P C1 clinit = (D, b, Ts, T, m);\n     sh C1 = \\<lfloor>a\\<rfloor>; ics = Calling C1 Cs;\n     exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Processing\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>a = (sfs, i);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Done)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Processing)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n          sh);\n     \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        sh C = \\<lfloor>(sfs, Error)\\<rfloor> \\<Longrightarrow>\n        exec_step_ind (StepC C Cs) P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n         frs sh\n         (None, h,\n          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n           Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n          frs,\n          sh);\n     m = (mxs, mxl\\<^sub>0, ins, xt); method P C1 clinit = (D, b, Ts, T, m);\n     sh C1 = \\<lfloor>a\\<rfloor>; ics = Calling C1 Cs;\n     exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "qed(auto)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x31 x32.\n       exec_step_input P C M pc ics = StepC2 x31 x32 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x31 x32.\n       exec_step_input P C M pc ics = StepC2 x31 x32 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "case (StepC2 C1 Cs)"], ["proof (state)\nthis:\n  exec_step_input P C M pc ics = StepC2 C1 Cs\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x31 x32.\n       exec_step_input P C M pc ics = StepC2 x31 x32 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C M pc ics = StepC2 C1 Cs", "have ics: \"ics = Called (C1#Cs)\""], ["proof (prove)\nusing this:\n  exec_step_input P C M pc ics = StepC2 C1 Cs\n\ngoal (1 subgoal):\n 1. ics = Called (C1 # Cs)", "by simp"], ["proof (state)\nthis:\n  ics = Called (C1 # Cs)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x31 x32.\n       exec_step_input P C M pc ics = StepC2 x31 x32 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  ics = Called (C1 # Cs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Called (C1 # Cs)\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Init assms"], ["proof (prove)\nusing this:\n  ics = Called (C1 # Cs)\n  exec_step_ind (StepC2 ?C ?Cs) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc\n   ?ics ?frs ?sh\n   (None, ?h,\n    create_init_frame ?P ?C #\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, Called ?Cs) # ?frs,\n    ?sh)\n  exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by auto"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "case (StepI i)"], ["proof (state)\nthis:\n  exec_step_input P C M pc ics = StepI i\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C M pc ics = StepI i", "have\n    ics: \"ics = Called [] \\<or> ics = No_ics\" and\n    exec_instr: \"exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\""], ["proof (prove)\nusing this:\n  exec_step_input P C M pc ics = StepI i\n\ngoal (1 subgoal):\n 1. ics = Called [] \\<or> ics = No_ics &&&\n    exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')", "using assms"], ["proof (prove)\nusing this:\n  exec_step_input P C M pc ics = StepI i\n  exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. ics = Called [] \\<or> ics = No_ics &&&\n    exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')", "by(auto dest!: exec_step_input_StepID)"], ["proof (state)\nthis:\n  ics = Called [] \\<or> ics = No_ics\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       exec_step_input P C M pc ics = StepI x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases i)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>x1.\n       i = Load x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x2.\n       i = Store x2 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x3.\n       i = Push x3 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x4.\n       i = New x4 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. \\<And>x101 x102.\n        i = Invoke x101 x102 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 18 subgoals...", "case (Load x1)"], ["proof (state)\nthis:\n  i = Load x1\n\ngoal (18 subgoals):\n 1. \\<And>x1.\n       i = Load x1 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x2.\n       i = Store x2 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x3.\n       i = Push x3 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x4.\n       i = New x4 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. \\<And>x101 x102.\n        i = Invoke x101 x102 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = Load x1", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Load x1\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_instr exec_step_ind_Load StepI"], ["proof (prove)\nusing this:\n  i = Load x1\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_ind (StepI (Load ?n)) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc\n   ?ics ?frs ?sh\n   (None, ?h,\n    (?loc ! ?n # ?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, Suc ?pc, ?ics) # ?frs,\n    ?sh)\n  exec_step_input P C M pc ics = StepI i\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by auto"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (17 subgoals):\n 1. \\<And>x2.\n       i = Store x2 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x3.\n       i = Push x3 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x4.\n       i = New x4 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. \\<And>x111 x112 x113.\n        i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>x2.\n       i = Store x2 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x3.\n       i = Push x3 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x4.\n       i = New x4 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. \\<And>x111 x112 x113.\n        i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 17 subgoals...", "case (Store x2)"], ["proof (state)\nthis:\n  i = Store x2\n\ngoal (17 subgoals):\n 1. \\<And>x2.\n       i = Store x2 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x3.\n       i = Push x3 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x4.\n       i = New x4 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. \\<And>x111 x112 x113.\n        i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = Store x2", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Store x2\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_instr exec_step_ind_Store StepI"], ["proof (prove)\nusing this:\n  i = Store x2\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_ind (StepI (Store ?n)) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc\n   ?ics ?frs ?sh\n   (None, ?h,\n    (tl ?stk, ?loc[?n := hd ?stk], ?C\\<^sub>0, ?M\\<^sub>0, Suc ?pc, ?ics) #\n    ?frs,\n    ?sh)\n  exec_step_input P C M pc ics = StepI i\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by auto"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (16 subgoals):\n 1. \\<And>x3.\n       i = Push x3 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x4.\n       i = New x4 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. i = Return \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>x3.\n       i = Push x3 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x4.\n       i = New x4 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. i = Return \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 16 subgoals...", "case (Push x3)"], ["proof (state)\nthis:\n  i = Push x3\n\ngoal (16 subgoals):\n 1. \\<And>x3.\n       i = Push x3 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x4.\n       i = New x4 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. i = Return \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = Push x3", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Push x3\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_instr exec_step_ind_Push StepI"], ["proof (prove)\nusing this:\n  i = Push x3\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_ind (StepI (Push ?v)) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc\n   ?ics ?frs ?sh\n   (None, ?h,\n    (?v # ?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, Suc ?pc, ?ics) # ?frs, ?sh)\n  exec_step_input P C M pc ics = StepI i\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by auto"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (15 subgoals):\n 1. \\<And>x4.\n       i = New x4 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. i = Pop \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x4.\n       i = New x4 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. i = Pop \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 15 subgoals...", "case (New C1)"], ["proof (state)\nthis:\n  i = New C1\n\ngoal (15 subgoals):\n 1. \\<And>x4.\n       i = New x4 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. i = Pop \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = New C1", "obtain sfs i where sfsi: \"the(sh C1) = (sfs,i)\""], ["proof (prove)\nusing this:\n  i = New C1\n\ngoal (1 subgoal):\n 1. (\\<And>sfs i.\n        the (sh C1) = (sfs, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"the(sh C1)\")"], ["proof (state)\nthis:\n  the (sh C1) = (sfs, i)\n\ngoal (15 subgoals):\n 1. \\<And>x4.\n       i__ = New x4 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x51 x52.\n       i__ = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x61 x62 x63.\n       i__ = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x71 x72.\n       i__ = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x81 x82 x83.\n       i__ = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x9.\n       i__ = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x101 x102.\n       i__ = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. \\<And>x111 x112 x113.\n       i__ = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. i__ = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. i__ = Pop \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  the (sh C1) = (sfs, i)", "show ?thesis"], ["proof (prove)\nusing this:\n  the (sh C1) = (sfs, i)\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_New_Called exec_step_ind_NewOOM_Called\n       exec_step_ind_New_Done exec_step_ind_NewOOM_Done\n       exec_step_ind_New_Init sfsi New StepI exec_instr ics"], ["proof (prove)\nusing this:\n  the (sh C1) = (sfs, i)\n  new_Addr ?h = \\<lfloor>?a\\<rfloor> \\<Longrightarrow>\n  exec_step_ind (StepI (New ?C)) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc\n   (Called ?Cs) ?frs ?sh\n   (None, ?h(?a \\<mapsto> blank ?P ?C),\n    (Addr ?a # ?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, Suc ?pc, No_ics) # ?frs,\n    ?sh)\n  new_Addr ?h = None \\<Longrightarrow>\n  exec_step_ind (StepI (New ?C)) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc\n   (Called ?Cs) ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, No_ics) # ?frs, ?sh)\n  \\<lbrakk>?sh ?C = \\<lfloor>(?obj, Done)\\<rfloor>;\n   new_Addr ?h = \\<lfloor>?a\\<rfloor>;\n   \\<forall>Cs. ?ics \\<noteq> Called Cs\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (New ?C)) ?P ?h ?stk ?loc\n                     ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h(?a \\<mapsto> blank ?P ?C),\n                      (Addr ?a # ?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0,\n                       Suc ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>?sh ?C = \\<lfloor>(?obj, Done)\\<rfloor>; new_Addr ?h = None;\n   \\<forall>Cs. ?ics \\<noteq> Called Cs\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (New ?C)) ?P ?h ?stk ?loc\n                     ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>\\<forall>obj. ?sh ?C \\<noteq> \\<lfloor>(obj, Done)\\<rfloor>;\n   \\<forall>Cs. ?ics \\<noteq> Called Cs\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (New ?C)) ?P ?h ?stk ?loc\n                     ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling ?C []) #\n                      ?frs,\n                      ?sh)\n  the (sh C1) = (sfs, i)\n  i__ = New C1\n  exec_step_input P C M pc ics = StepI i__\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: init_state.splits)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (14 subgoals):\n 1. \\<And>x51 x52.\n       i__ = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x61 x62 x63.\n       i__ = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x71 x72.\n       i__ = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x81 x82 x83.\n       i__ = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x9.\n       i__ = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x101 x102.\n       i__ = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x111 x112 x113.\n       i__ = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. i__ = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. i__ = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. i__ = IAdd \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. i = IAdd \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 14 subgoals...", "case (Getfield F1 C1)"], ["proof (state)\nthis:\n  i = Getfield F1 C1\n\ngoal (14 subgoals):\n 1. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. i = IAdd \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = Getfield F1 C1", "obtain D fs D' b t where lets: \"the(h(the_Addr (hd stk))) = (D,fs)\"\n      \"field P C1 F1 = (D',b,t)\""], ["proof (prove)\nusing this:\n  i = Getfield F1 C1\n\ngoal (1 subgoal):\n 1. (\\<And>D fs D' b t.\n        \\<lbrakk>the (h (the_Addr (hd stk))) = (D, fs);\n         field P C1 F1 = (D', b, t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"the(h(the_Addr (hd stk)))\", cases \"field P C1 F1\")"], ["proof (state)\nthis:\n  the (h (the_Addr (hd stk))) = (D, fs)\n  field P C1 F1 = (D', b, t)\n\ngoal (14 subgoals):\n 1. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. i = IAdd \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  the (h (the_Addr (hd stk))) = (D, fs)\n  field P C1 F1 = (D', b, t)", "have \"\\<And>b' t'. P \\<turnstile> D has F1,b':t' in C1 \\<Longrightarrow> (D', b, t) = (C1, b', t')\""], ["proof (prove)\nusing this:\n  the (h (the_Addr (hd stk))) = (D, fs)\n  field P C1 F1 = (D', b, t)\n\ngoal (1 subgoal):\n 1. \\<And>b' t'.\n       P \\<turnstile> D has F1,b':t' in C1 \\<Longrightarrow>\n       (D', b, t) = (C1, b', t')", "using field_def2 has_field_idemp has_field_sees"], ["proof (prove)\nusing this:\n  the (h (the_Addr (hd stk))) = (D, fs)\n  field P C1 F1 = (D', b, t)\n  ?P \\<turnstile> ?C sees ?F,?b:?T in ?D \\<Longrightarrow>\n  field ?P ?C ?F = (?D, ?b, ?T)\n  ?P \\<turnstile> ?C has ?F,?b:?T in ?D \\<Longrightarrow>\n  ?P \\<turnstile> ?D has ?F,?b:?T in ?D\n  ?P \\<turnstile> ?C has ?F,?b:?T in ?C \\<Longrightarrow>\n  ?P \\<turnstile> ?C sees ?F,?b:?T in ?C\n\ngoal (1 subgoal):\n 1. \\<And>b' t'.\n       P \\<turnstile> D has F1,b':t' in C1 \\<Longrightarrow>\n       (D', b, t) = (C1, b', t')", "by fastforce"], ["proof (state)\nthis:\n  P \\<turnstile> D has F1,?b':?t' in C1 \\<Longrightarrow>\n  (D', b, t) = (C1, ?b', ?t')\n\ngoal (14 subgoals):\n 1. \\<And>x51 x52.\n       i = Getfield x51 x52 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. i = IAdd \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has F1,?b':?t' in C1 \\<Longrightarrow>\n  (D', b, t) = (C1, ?b', ?t')", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> D has F1,?b':?t' in C1 \\<Longrightarrow>\n  (D', b, t) = (C1, ?b', ?t')\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Getfield_Null exec_step_ind_Getfield_NoField\n       exec_step_ind_Getfield_Static exec_step_ind_Getfield lets Getfield StepI exec_instr"], ["proof (prove)\nusing this:\n  P \\<turnstile> D has F1,?b':?t' in C1 \\<Longrightarrow>\n  (D', b, t) = (C1, ?b', ?t')\n  hd ?stk = Null \\<Longrightarrow>\n  exec_step_ind (StepI (Getfield ?F ?C)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>?v = hd ?stk; (?D, ?fs) = the (?h (the_Addr ?v));\n   ?v \\<noteq> Null;\n   \\<nexists>t b. ?P \\<turnstile> ?D has ?F,b:t in ?C\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Getfield ?F ?C)) ?P ?h ?stk ?loc\n                     ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>?v = hd ?stk; (?D, ?fs) = the (?h (the_Addr ?v));\n   ?v \\<noteq> Null; ?P \\<turnstile> ?D has ?F,Static:?t in ?C\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Getfield ?F ?C)) ?P ?h ?stk ?loc\n                     ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt\n                                IncompatibleClassChangeError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>?v = hd ?stk; (?D, ?fs) = the (?h (the_Addr ?v));\n   (?D', ?b, ?t) = field ?P ?C ?F; ?v \\<noteq> Null;\n   ?P \\<turnstile> ?D has ?F,NonStatic:?t in ?C\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Getfield ?F ?C)) ?P ?h ?stk ?loc\n                     ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h,\n                      (the (?fs (?F, ?C)) # tl ?stk, ?loc, ?C\\<^sub>0,\n                       ?M\\<^sub>0, ?pc + 1, ?ics) #\n                      ?frs,\n                      ?sh)\n  the (h (the_Addr (hd stk))) = (D, fs)\n  field P C1 F1 = (D', b, t)\n  i = Getfield F1 C1\n  exec_step_input P C M pc ics = StepI i\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm staticb.splits) metis+"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (13 subgoals):\n 1. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. \\<And>x15.\n        i = Goto x15 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. \\<And>x15.\n        i = Goto x15 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 13 subgoals...", "case (Getstatic C1 F1 D1)"], ["proof (state)\nthis:\n  i = Getstatic C1 F1 D1\n\ngoal (13 subgoals):\n 1. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. \\<And>x15.\n        i = Goto x15 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = Getstatic C1 F1 D1", "obtain D' b t where lets: \"field P D1 F1 = (D',b,t)\""], ["proof (prove)\nusing this:\n  i = Getstatic C1 F1 D1\n\ngoal (1 subgoal):\n 1. (\\<And>D' b t.\n        field P D1 F1 = (D', b, t) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"field P D1 F1\")"], ["proof (state)\nthis:\n  field P D1 F1 = (D', b, t)\n\ngoal (13 subgoals):\n 1. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. \\<And>x15.\n        i = Goto x15 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  field P D1 F1 = (D', b, t)", "have field: \"\\<And>b' t'. P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow> (D', b, t) = (D1, b', t')\""], ["proof (prove)\nusing this:\n  field P D1 F1 = (D', b, t)\n\ngoal (1 subgoal):\n 1. \\<And>b' t'.\n       P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n       (D', b, t) = (D1, b', t')", "using field_def2 has_field_idemp has_field_sees"], ["proof (prove)\nusing this:\n  field P D1 F1 = (D', b, t)\n  ?P \\<turnstile> ?C sees ?F,?b:?T in ?D \\<Longrightarrow>\n  field ?P ?C ?F = (?D, ?b, ?T)\n  ?P \\<turnstile> ?C has ?F,?b:?T in ?D \\<Longrightarrow>\n  ?P \\<turnstile> ?D has ?F,?b:?T in ?D\n  ?P \\<turnstile> ?C has ?F,?b:?T in ?C \\<Longrightarrow>\n  ?P \\<turnstile> ?C sees ?F,?b:?T in ?C\n\ngoal (1 subgoal):\n 1. \\<And>b' t'.\n       P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n       (D', b, t) = (D1, b', t')", "by fastforce"], ["proof (state)\nthis:\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n\ngoal (13 subgoals):\n 1. \\<And>x61 x62 x63.\n       i = Getstatic x61 x62 x63 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. \\<And>x15.\n        i = Goto x15 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 13 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases b)"], ["proof (state)\ngoal (2 subgoals):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. b = NonStatic \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case NonStatic"], ["proof (state)\nthis:\n  b = NonStatic\n\ngoal (2 subgoals):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. b = NonStatic \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  b = NonStatic", "show ?thesis"], ["proof (prove)\nusing this:\n  b = NonStatic\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Getstatic_NoField exec_step_ind_Getstatic_NonStatic\n        field lets Getstatic exec_instr StepI"], ["proof (prove)\nusing this:\n  b = NonStatic\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  ?P \\<turnstile> ?C has ?F,NonStatic:?t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt IncompatibleClassChangeError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  i = Getstatic C1 F1 D1\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm) fastforce"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case Static"], ["proof (state)\nthis:\n  b = Static\n\ngoal (1 subgoal):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases \"ics = Called []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ics = Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case True"], ["proof (state)\nthis:\n  ics = Called []\n\ngoal (2 subgoals):\n 1. ics = Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  ics = Called []", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Called []\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Getstatic_NoField\n          exec_step_ind_Getstatic_Called exec_step_ind_Getstatic_Init\n          Static field lets Getstatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  ics = Called []\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>(?D', ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D;\n   ?v = the (fst (the (?sh ?D')) ?F)\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc (Called ?Cs) ?frs ?sh\n                     (None, ?h,\n                      (?v # ?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, Suc ?pc,\n                       No_ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>(?D', ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D;\n   \\<forall>sfs. ?sh ?D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n   \\<forall>Cs. ?ics \\<noteq> Called Cs\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling ?D' []) #\n                      ?frs,\n                      ?sh)\n  b = Static\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  i = Getstatic C1 F1 D1\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto simp: split_beta split: if_split_asm) metis"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case False"], ["proof (state)\nthis:\n  ics \\<noteq> Called []\n\ngoal (1 subgoal):\n 1. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  ics \\<noteq> Called []", "have nCalled: \"\\<forall>Cs. ics \\<noteq> Called Cs\""], ["proof (prove)\nusing this:\n  ics \\<noteq> Called []\n\ngoal (1 subgoal):\n 1. \\<forall>Cs. ics \\<noteq> Called Cs", "using ics"], ["proof (prove)\nusing this:\n  ics \\<noteq> Called []\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. \\<forall>Cs. ics \\<noteq> Called Cs", "by simp"], ["proof (state)\nthis:\n  \\<forall>Cs. ics \\<noteq> Called Cs\n\ngoal (1 subgoal):\n 1. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases \"sh D1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sh D1 = None \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>a.\n       sh D1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "case None"], ["proof (state)\nthis:\n  sh D1 = None\n\ngoal (2 subgoals):\n 1. sh D1 = None \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>a.\n       sh D1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  sh D1 = None", "have nDone: \"\\<forall>sfs. sh D1 \\<noteq> Some(sfs, Done)\""], ["proof (prove)\nusing this:\n  sh D1 = None\n\ngoal (1 subgoal):\n 1. \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (2 subgoals):\n 1. sh D1 = None \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>a.\n       sh D1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Getstatic_NoField\n            exec_step_ind_Getstatic_Init[where sh=sh, OF _ _ nDone nCalled]\n            field lets None False Static Getstatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>(D1, ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling D1 []) #\n                      ?frs,\n                      sh)\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  sh D1 = None\n  ics \\<noteq> Called []\n  b = Static\n  i = Getstatic C1 F1 D1\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm) metis"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh D1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh D1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "case (Some a)"], ["proof (state)\nthis:\n  sh D1 = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh D1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  sh D1 = \\<lfloor>a\\<rfloor>", "obtain sfs i where sfsi: \"a=(sfs,i)\""], ["proof (prove)\nusing this:\n  sh D1 = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>sfs i. a = (sfs, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases a)"], ["proof (state)\nthis:\n  a = (sfs, i)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh D1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Getstatic_NoField\n            exec_step_ind_Getstatic_Init sfsi False Static Some field lets Getstatic exec_instr"], ["proof (prove)\nusing this:\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>(?D', ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D;\n   \\<forall>sfs. ?sh ?D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n   \\<forall>Cs. ?ics \\<noteq> Called Cs\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling ?D' []) #\n                      ?frs,\n                      ?sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D1 = \\<lfloor>a\\<rfloor>\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  i__ = Getstatic C1 F1 D1\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases \"i = Done\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Getstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Getstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Getstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Getstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Getstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Getstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case True"], ["proof (state)\nthis:\n  i = Done\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Getstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Getstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Getstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Getstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Getstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Getstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Done", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Done\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Getstatic_NoField\n              exec_step_ind_Getstatic_Done[OF _ _ nCalled] exec_step_ind_Getstatic_Init\n              sfsi False Static Some field lets Getstatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  i = Done\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>(?D', ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D;\n   ?sh ?D' = \\<lfloor>(?sfs, Done)\\<rfloor>; ?v = the (?sfs ?F)\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs ?sh\n                     (None, ?h,\n                      (?v # ?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, Suc ?pc,\n                       ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>(?D', ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D;\n   \\<forall>sfs. ?sh ?D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n   \\<forall>Cs. ?ics \\<noteq> Called Cs\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling ?D' []) #\n                      ?frs,\n                      ?sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D1 = \\<lfloor>a\\<rfloor>\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  i__ = Getstatic C1 F1 D1\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i__\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm) metis"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Getstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Getstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Getstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Getstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Getstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Getstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case nD: False"], ["proof (state)\nthis:\n  i \\<noteq> Done\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Getstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Getstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Getstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> Done", "have nDone: \"\\<forall>sfs. sh D1 \\<noteq> Some(sfs, Done)\""], ["proof (prove)\nusing this:\n  i \\<noteq> Done\n\ngoal (1 subgoal):\n 1. \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "using sfsi Some"], ["proof (prove)\nusing this:\n  i \\<noteq> Done\n  a = (sfs, i)\n  sh D1 = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Getstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Getstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Getstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using nD"], ["proof (prove)\nusing this:\n  i \\<noteq> Done\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases i)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Processing\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 4. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case Processing"], ["proof (state)\nthis:\n  i = Processing\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Processing\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 4. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Processing", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Processing\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Getstatic_NoField\n                exec_step_ind_Getstatic_Init[where sh=sh, OF _ _ nDone nCalled]\n                sfsi False Static Some field lets Getstatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  i = Processing\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>(D1, ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling D1 []) #\n                      ?frs,\n                      sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D1 = \\<lfloor>a\\<rfloor>\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  i__ = Getstatic C1 F1 D1\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i__\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm) metis"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case Prepared"], ["proof (state)\nthis:\n  i = Prepared\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Prepared", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Prepared\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Getstatic_NoField\n                exec_step_ind_Getstatic_Init[where sh=sh, OF _ _ nDone nCalled]\n                sfsi False Static Some field lets Getstatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  i = Prepared\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>(D1, ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling D1 []) #\n                      ?frs,\n                      sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D1 = \\<lfloor>a\\<rfloor>\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  i__ = Getstatic C1 F1 D1\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i__\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm) metis"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case Error"], ["proof (state)\nthis:\n  i = Error\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Error", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Error\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Getstatic_NoField\n                exec_step_ind_Getstatic_Init[where sh=sh, OF _ _ nDone nCalled]\n                sfsi False Static Some field lets Getstatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  i = Error\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>(D1, ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Getstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling D1 []) #\n                      ?frs,\n                      sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D1 = \\<lfloor>a\\<rfloor>\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  i__ = Getstatic C1 F1 D1\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i__\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm) metis"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "qed(simp)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (12 subgoals):\n 1. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. i = CmpEq \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. i = CmpEq \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 12 subgoals...", "case (Putfield F1 C1)"], ["proof (state)\nthis:\n  i = Putfield F1 C1\n\ngoal (12 subgoals):\n 1. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. i = CmpEq \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = Putfield F1 C1", "obtain D fs D' b t where lets: \"the(h(the_Addr (hd(tl stk)))) = (D,fs)\"\n      \"field P C1 F1 = (D',b,t)\""], ["proof (prove)\nusing this:\n  i = Putfield F1 C1\n\ngoal (1 subgoal):\n 1. (\\<And>D fs D' b t.\n        \\<lbrakk>the (h (the_Addr (hd (tl stk)))) = (D, fs);\n         field P C1 F1 = (D', b, t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"the(h(the_Addr (hd(tl stk))))\", cases \"field P C1 F1\")"], ["proof (state)\nthis:\n  the (h (the_Addr (hd (tl stk)))) = (D, fs)\n  field P C1 F1 = (D', b, t)\n\ngoal (12 subgoals):\n 1. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. i = CmpEq \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  the (h (the_Addr (hd (tl stk)))) = (D, fs)\n  field P C1 F1 = (D', b, t)", "have \"\\<And>b' t'. P \\<turnstile> D has F1,b':t' in C1 \\<Longrightarrow> (D', b, t) = (C1, b', t')\""], ["proof (prove)\nusing this:\n  the (h (the_Addr (hd (tl stk)))) = (D, fs)\n  field P C1 F1 = (D', b, t)\n\ngoal (1 subgoal):\n 1. \\<And>b' t'.\n       P \\<turnstile> D has F1,b':t' in C1 \\<Longrightarrow>\n       (D', b, t) = (C1, b', t')", "using field_def2 has_field_idemp has_field_sees"], ["proof (prove)\nusing this:\n  the (h (the_Addr (hd (tl stk)))) = (D, fs)\n  field P C1 F1 = (D', b, t)\n  ?P \\<turnstile> ?C sees ?F,?b:?T in ?D \\<Longrightarrow>\n  field ?P ?C ?F = (?D, ?b, ?T)\n  ?P \\<turnstile> ?C has ?F,?b:?T in ?D \\<Longrightarrow>\n  ?P \\<turnstile> ?D has ?F,?b:?T in ?D\n  ?P \\<turnstile> ?C has ?F,?b:?T in ?C \\<Longrightarrow>\n  ?P \\<turnstile> ?C sees ?F,?b:?T in ?C\n\ngoal (1 subgoal):\n 1. \\<And>b' t'.\n       P \\<turnstile> D has F1,b':t' in C1 \\<Longrightarrow>\n       (D', b, t) = (C1, b', t')", "by fastforce"], ["proof (state)\nthis:\n  P \\<turnstile> D has F1,?b':?t' in C1 \\<Longrightarrow>\n  (D', b, t) = (C1, ?b', ?t')\n\ngoal (12 subgoals):\n 1. \\<And>x71 x72.\n       i = Putfield x71 x72 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. i = CmpEq \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> D has F1,?b':?t' in C1 \\<Longrightarrow>\n  (D', b, t) = (C1, ?b', ?t')", "show ?thesis"], ["proof (prove)\nusing this:\n  P \\<turnstile> D has F1,?b':?t' in C1 \\<Longrightarrow>\n  (D', b, t) = (C1, ?b', ?t')\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Putfield_Null exec_step_ind_Putfield_NoField\n       exec_step_ind_Putfield_Static exec_step_ind_Putfield lets Putfield exec_instr StepI"], ["proof (prove)\nusing this:\n  P \\<turnstile> D has F1,?b':?t' in C1 \\<Longrightarrow>\n  (D', b, t) = (C1, ?b', ?t')\n  hd (tl ?stk) = Null \\<Longrightarrow>\n  exec_step_ind (StepI (Putfield ?F ?C)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>?r = hd (tl ?stk); ?a = the_Addr ?r; (?D, ?fs) = the (?h ?a);\n   ?r \\<noteq> Null;\n   \\<nexists>t b. ?P \\<turnstile> ?D has ?F,b:t in ?C\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Putfield ?F ?C)) ?P ?h ?stk ?loc\n                     ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>?r = hd (tl ?stk); ?a = the_Addr ?r; (?D, ?fs) = the (?h ?a);\n   ?r \\<noteq> Null; ?P \\<turnstile> ?D has ?F,Static:?t in ?C\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Putfield ?F ?C)) ?P ?h ?stk ?loc\n                     ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt\n                                IncompatibleClassChangeError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>?v = hd ?stk; ?r = hd (tl ?stk); ?a = the_Addr ?r;\n   (?D, ?fs) = the (?h ?a); (?D', ?b, ?t) = field ?P ?C ?F;\n   ?r \\<noteq> Null; ?P \\<turnstile> ?D has ?F,NonStatic:?t in ?C\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Putfield ?F ?C)) ?P ?h ?stk ?loc\n                     ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h(?a \\<mapsto>\n                      (?D, ?fs((?F, ?C) \\<mapsto> ?v))),\n                      (tl (tl ?stk), ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc + 1,\n                       ?ics) #\n                      ?frs,\n                      ?sh)\n  the (h (the_Addr (hd (tl stk)))) = (D, fs)\n  field P C1 F1 = (D', b, t)\n  i = Putfield F1 C1\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm staticb.splits) metis+"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (11 subgoals):\n 1. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. \\<And>x17.\n        i = IfFalse x17 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. \\<And>x17.\n        i = IfFalse x17 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 11 subgoals...", "case (Putstatic C1 F1 D1)"], ["proof (state)\nthis:\n  i = Putstatic C1 F1 D1\n\ngoal (11 subgoals):\n 1. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. \\<And>x17.\n        i = IfFalse x17 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  i = Putstatic C1 F1 D1", "obtain D' b t where lets: \"field P D1 F1 = (D',b,t)\""], ["proof (prove)\nusing this:\n  i = Putstatic C1 F1 D1\n\ngoal (1 subgoal):\n 1. (\\<And>D' b t.\n        field P D1 F1 = (D', b, t) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"field P D1 F1\")"], ["proof (state)\nthis:\n  field P D1 F1 = (D', b, t)\n\ngoal (11 subgoals):\n 1. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. \\<And>x17.\n        i = IfFalse x17 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  field P D1 F1 = (D', b, t)", "have field: \"\\<And>b' t'. P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow> (D', b, t) = (D1, b', t')\""], ["proof (prove)\nusing this:\n  field P D1 F1 = (D', b, t)\n\ngoal (1 subgoal):\n 1. \\<And>b' t'.\n       P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n       (D', b, t) = (D1, b', t')", "using field_def2 has_field_idemp has_field_sees"], ["proof (prove)\nusing this:\n  field P D1 F1 = (D', b, t)\n  ?P \\<turnstile> ?C sees ?F,?b:?T in ?D \\<Longrightarrow>\n  field ?P ?C ?F = (?D, ?b, ?T)\n  ?P \\<turnstile> ?C has ?F,?b:?T in ?D \\<Longrightarrow>\n  ?P \\<turnstile> ?D has ?F,?b:?T in ?D\n  ?P \\<turnstile> ?C has ?F,?b:?T in ?C \\<Longrightarrow>\n  ?P \\<turnstile> ?C sees ?F,?b:?T in ?C\n\ngoal (1 subgoal):\n 1. \\<And>b' t'.\n       P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n       (D', b, t) = (D1, b', t')", "by fastforce"], ["proof (state)\nthis:\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n\ngoal (11 subgoals):\n 1. \\<And>x81 x82 x83.\n       i = Putstatic x81 x82 x83 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 10. \\<And>x17.\n        i = IfFalse x17 \\<Longrightarrow>\n        exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n         frs sh (xp', h', frs', sh')\nA total of 11 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases b)"], ["proof (state)\ngoal (2 subgoals):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. b = NonStatic \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case NonStatic"], ["proof (state)\nthis:\n  b = NonStatic\n\ngoal (2 subgoals):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. b = NonStatic \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  b = NonStatic", "show ?thesis"], ["proof (prove)\nusing this:\n  b = NonStatic\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Putstatic_NoField exec_step_ind_Putstatic_NonStatic\n        field lets Putstatic exec_instr StepI"], ["proof (prove)\nusing this:\n  b = NonStatic\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  ?P \\<turnstile> ?C has ?F,NonStatic:?t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt IncompatibleClassChangeError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  i = Putstatic C1 F1 D1\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm) fastforce"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case Static"], ["proof (state)\nthis:\n  b = Static\n\ngoal (1 subgoal):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases \"ics = Called []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ics = Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case True"], ["proof (state)\nthis:\n  ics = Called []\n\ngoal (2 subgoals):\n 1. ics = Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  ics = Called []", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Called []\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Putstatic_NoField\n          exec_step_ind_Putstatic_Called exec_step_ind_Putstatic_Init\n          Static field lets Putstatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  ics = Called []\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>(?D', ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D;\n   the (?sh ?D') = (?sfs, ?i)\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc (Called ?Cs) ?frs ?sh\n                     (None, ?h,\n                      (tl ?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, Suc ?pc,\n                       No_ics) #\n                      ?frs,\n                      ?sh(?D' \\<mapsto> (?sfs(?F \\<mapsto> hd ?stk), ?i)))\n  \\<lbrakk>(?D', ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D;\n   \\<forall>sfs. ?sh ?D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n   \\<forall>Cs. ?ics \\<noteq> Called Cs\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling ?D' []) #\n                      ?frs,\n                      ?sh)\n  b = Static\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  i = Putstatic C1 F1 D1\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(cases \"the(sh D1)\", auto split: if_split_asm) metis"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case False"], ["proof (state)\nthis:\n  ics \\<noteq> Called []\n\ngoal (1 subgoal):\n 1. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  ics \\<noteq> Called []", "have nCalled: \"\\<forall>Cs. ics \\<noteq> Called Cs\""], ["proof (prove)\nusing this:\n  ics \\<noteq> Called []\n\ngoal (1 subgoal):\n 1. \\<forall>Cs. ics \\<noteq> Called Cs", "using ics"], ["proof (prove)\nusing this:\n  ics \\<noteq> Called []\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. \\<forall>Cs. ics \\<noteq> Called Cs", "by simp"], ["proof (state)\nthis:\n  \\<forall>Cs. ics \\<noteq> Called Cs\n\ngoal (1 subgoal):\n 1. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases \"sh D1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sh D1 = None \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>a.\n       sh D1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "case None"], ["proof (state)\nthis:\n  sh D1 = None\n\ngoal (2 subgoals):\n 1. sh D1 = None \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>a.\n       sh D1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  sh D1 = None", "have nDone: \"\\<forall>sfs. sh D1 \\<noteq> Some(sfs, Done)\""], ["proof (prove)\nusing this:\n  sh D1 = None\n\ngoal (1 subgoal):\n 1. \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (2 subgoals):\n 1. sh D1 = None \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>a.\n       sh D1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Putstatic_NoField\n            exec_step_ind_Putstatic_Init[where sh=sh, OF _ _ nDone nCalled]\n            field lets None False Static Putstatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>(D1, ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling D1 []) #\n                      ?frs,\n                      sh)\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  sh D1 = None\n  ics \\<noteq> Called []\n  b = Static\n  i = Putstatic C1 F1 D1\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm) metis"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh D1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh D1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "case (Some a)"], ["proof (state)\nthis:\n  sh D1 = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh D1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  sh D1 = \\<lfloor>a\\<rfloor>", "obtain sfs i where sfsi: \"a=(sfs,i)\""], ["proof (prove)\nusing this:\n  sh D1 = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>sfs i. a = (sfs, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases a)"], ["proof (state)\nthis:\n  a = (sfs, i)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh D1 = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Putstatic_NoField\n            exec_step_ind_Putstatic_Init sfsi False Static Some field lets Putstatic exec_instr"], ["proof (prove)\nusing this:\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>(?D', ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D;\n   \\<forall>sfs. ?sh ?D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n   \\<forall>Cs. ?ics \\<noteq> Called Cs\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling ?D' []) #\n                      ?frs,\n                      ?sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D1 = \\<lfloor>a\\<rfloor>\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  i__ = Putstatic C1 F1 D1\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases \"i = Done\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Putstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Putstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Putstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Putstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Putstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Putstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case True"], ["proof (state)\nthis:\n  i = Done\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Putstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Putstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Putstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Putstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Putstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Putstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Done", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Done\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Putstatic_NoField\n              exec_step_ind_Putstatic_Done[OF _ _ nCalled] exec_step_ind_Putstatic_Init\n              sfsi False Static Some field lets Putstatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  i = Done\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>(?D', ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D;\n   ?sh ?D' = \\<lfloor>(?sfs, Done)\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs ?sh\n                     (None, ?h,\n                      (tl ?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, Suc ?pc,\n                       ics) #\n                      ?frs,\n                      ?sh(?D' \\<mapsto> (?sfs(?F \\<mapsto> hd ?stk), Done)))\n  \\<lbrakk>(?D', ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D;\n   \\<forall>sfs. ?sh ?D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n   \\<forall>Cs. ?ics \\<noteq> Called Cs\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling ?D' []) #\n                      ?frs,\n                      ?sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D1 = \\<lfloor>a\\<rfloor>\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  i__ = Putstatic C1 F1 D1\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i__\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm) metis"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Putstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Putstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Putstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Putstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Putstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Putstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case nD: False"], ["proof (state)\nthis:\n  i \\<noteq> Done\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Putstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Putstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Putstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> Done", "have nDone: \"\\<forall>sfs. sh D1 \\<noteq> Some(sfs, Done)\""], ["proof (prove)\nusing this:\n  i \\<noteq> Done\n\ngoal (1 subgoal):\n 1. \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "using sfsi Some"], ["proof (prove)\nusing this:\n  i \\<noteq> Done\n  a = (sfs, i)\n  sh D1 = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<forall>sfs. sh D1 \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<nexists>t b.\n                   P \\<turnstile> C has F,b:t in D \\<Longrightarrow>\n                exec_step_ind (StepI (Putstatic C F D)) P h stk loc\n                 C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                 (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n                  (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh);\n     \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Putstatic C F D)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D' []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D1 = \\<lfloor>a\\<rfloor>;\n     \\<And>b' t'.\n        P \\<turnstile> C1 has F1,b':t' in D1 \\<Longrightarrow>\n        (D', b, t) = (D1, b', t');\n     field P D1 F1 = (D', b, t); i__ = Putstatic C1 F1 D1;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using nD"], ["proof (prove)\nusing this:\n  i \\<noteq> Done\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases i)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Processing\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 4. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case Processing"], ["proof (state)\nthis:\n  i = Processing\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Processing\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 4. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Processing", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Processing\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Putstatic_NoField\n                exec_step_ind_Putstatic_Init[where sh=sh, OF _ _ nDone nCalled]\n                sfsi False Static Some field lets Putstatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  i = Processing\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>(D1, ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling D1 []) #\n                      ?frs,\n                      sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D1 = \\<lfloor>a\\<rfloor>\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  i__ = Putstatic C1 F1 D1\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i__\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm) metis"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case Prepared"], ["proof (state)\nthis:\n  i = Prepared\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Prepared", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Prepared\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Putstatic_NoField\n                exec_step_ind_Putstatic_Init[where sh=sh, OF _ _ nDone nCalled]\n                sfsi False Static Some field lets Putstatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  i = Prepared\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>(D1, ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling D1 []) #\n                      ?frs,\n                      sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D1 = \\<lfloor>a\\<rfloor>\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  i__ = Putstatic C1 F1 D1\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i__\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm) metis"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case Error"], ["proof (state)\nthis:\n  i = Error\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Error", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Error\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Putstatic_NoField\n                exec_step_ind_Putstatic_Init[where sh=sh, OF _ _ nDone nCalled]\n                sfsi False Static Some field lets Putstatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  i = Error\n  \\<nexists>t b. ?P \\<turnstile> ?C has ?F,b:t in ?D \\<Longrightarrow>\n  exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk ?loc ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  \\<lbrakk>(D1, ?b, ?t) = field ?P ?D ?F;\n   ?P \\<turnstile> ?C has ?F,Static:?t in ?D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Putstatic ?C ?F ?D)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling D1 []) #\n                      ?frs,\n                      sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D1 = \\<lfloor>a\\<rfloor>\n  P \\<turnstile> C1 has F1,?b':?t' in D1 \\<Longrightarrow>\n  (D', b, t) = (D1, ?b', ?t')\n  field P D1 F1 = (D', b, t)\n  i__ = Putstatic C1 F1 D1\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i__\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm) metis"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "qed(simp)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (10 subgoals):\n 1. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. i = Throw \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. i = Throw \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')", "case Checkcast"], ["proof (state)\nthis:\n  i = Checkcast x9_\n\ngoal (10 subgoals):\n 1. \\<And>x9.\n       i = Checkcast x9 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 9. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 10. i = Throw \\<Longrightarrow>\n     exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n      sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Checkcast x9_", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Checkcast x9_\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Checkcast exec_step_ind_Checkcast_Error exec_instr StepI"], ["proof (prove)\nusing this:\n  i = Checkcast x9_\n  cast_ok ?P ?C ?h (hd ?stk) \\<Longrightarrow>\n  exec_step_ind (StepI (Checkcast ?C)) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0\n   ?pc ?ics ?frs ?sh\n   (None, ?h, (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, Suc ?pc, ?ics) # ?frs,\n    ?sh)\n  \\<not> cast_ok ?P ?C ?h (hd ?stk) \\<Longrightarrow>\n  exec_step_ind (StepI (Checkcast ?C)) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0\n   ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (9 subgoals):\n 1. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case (Invoke M1 n)"], ["proof (state)\nthis:\n  i = Invoke M1 n\n\ngoal (9 subgoals):\n 1. \\<And>x101 x102.\n       i = Invoke x101 x102 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 8. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 9. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases \"stk!n = Null\")"], ["proof (state)\ngoal (2 subgoals):\n 1. stk ! n = Null \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. stk ! n \\<noteq> Null \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case True"], ["proof (state)\nthis:\n  stk ! n = Null\n\ngoal (2 subgoals):\n 1. stk ! n = Null \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. stk ! n \\<noteq> Null \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  stk ! n = Null", "show ?thesis"], ["proof (prove)\nusing this:\n  stk ! n = Null\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Invoke_Null Invoke exec_instr StepI"], ["proof (prove)\nusing this:\n  stk ! n = Null\n  ?stk ! ?n = Null \\<Longrightarrow>\n  exec_step_ind (StepI (Invoke ?M ?n)) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0\n   ?pc ?ics ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  i = Invoke M1 n\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by clarsimp"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case False"], ["proof (state)\nthis:\n  stk ! n \\<noteq> Null\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "let ?C = \"cname_of h (the_Addr (stk ! n))\""], ["proof (state)\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "obtain D b Ts T m where method: \"method P ?C M1 = (D,b,Ts,T,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D b Ts T m.\n        method P (cname_of h (the_Addr (stk ! n))) M1 =\n        (D, b, Ts, T, m) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"method P ?C M1\")"], ["proof (state)\nthis:\n  method P (cname_of h (the_Addr (stk ! n))) M1 = (D, b, Ts, T, m)\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  method P (cname_of h (the_Addr (stk ! n))) M1 = (D, b, Ts, T, m)", "obtain mxs mxl\\<^sub>0 ins xt where \"m = (mxs,mxl\\<^sub>0,ins,xt)\""], ["proof (prove)\nusing this:\n  method P (cname_of h (the_Addr (stk ! n))) M1 = (D, b, Ts, T, m)\n\ngoal (1 subgoal):\n 1. (\\<And>mxs mxl\\<^sub>0 ins xt.\n        m = (mxs, mxl\\<^sub>0, ins, xt) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases m)"], ["proof (state)\nthis:\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n\ngoal (1 subgoal):\n 1. stk ! n \\<noteq> Null \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  m = (mxs, mxl\\<^sub>0, ins, xt)", "show ?thesis"], ["proof (prove)\nusing this:\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Invoke_NoMethod\n        exec_step_ind_Invoke_Static exec_step_ind_Invoke method False Invoke exec_instr StepI"], ["proof (prove)\nusing this:\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n  \\<lbrakk>?r = ?stk ! ?n; ?C = cname_of ?h (the_Addr ?r); ?r \\<noteq> Null;\n   \\<nexists>Ts T m D b.\n      ?P \\<turnstile> ?C sees ?M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invoke ?M ?n)) ?P ?h ?stk ?loc\n                     ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt NoSuchMethodError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>?r = ?stk ! ?n; ?C = cname_of ?h (the_Addr ?r);\n   (?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) = method ?P ?C ?M;\n   ?r \\<noteq> Null;\n   ?P \\<turnstile> ?C sees ?M, Static :  ?Ts\\<rightarrow>?T = ?m in ?D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invoke ?M ?n)) ?P ?h ?stk ?loc\n                     ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt\n                                IncompatibleClassChangeError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>?ps = take ?n ?stk; ?r = ?stk ! ?n;\n   ?C = cname_of ?h (the_Addr ?r);\n   (?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) = method ?P ?C ?M;\n   ?r \\<noteq> Null;\n   ?P \\<turnstile> ?C sees ?M, NonStatic :  ?Ts\\<rightarrow>?T = ?m in ?D;\n   ?f' =\n   ([], [?r] @ rev ?ps @ replicate ?mxl\\<^sub>0 undefined, ?D, ?M, 0,\n    No_ics)\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invoke ?M ?n)) ?P ?h ?stk ?loc\n                     ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h,\n                      ?f' #\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  method P (cname_of h (the_Addr (stk ! n))) M1 = (D, b, Ts, T, m)\n  stk ! n \\<noteq> Null\n  i = Invoke M1 n\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm staticb.splits)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (8 subgoals):\n 1. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case (Invokestatic C1 M1 n)"], ["proof (state)\nthis:\n  i = Invokestatic C1 M1 n\n\ngoal (8 subgoals):\n 1. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "obtain D b Ts T m where lets: \"method P C1 M1 = (D,b,Ts,T,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D b Ts T m.\n        method P C1 M1 = (D, b, Ts, T, m) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"method P C1 M1\")"], ["proof (state)\nthis:\n  method P C1 M1 = (D, b, Ts, T, m)\n\ngoal (8 subgoals):\n 1. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  method P C1 M1 = (D, b, Ts, T, m)", "obtain mxs mxl\\<^sub>0 ins xt where m: \"m = (mxs,mxl\\<^sub>0,ins,xt)\""], ["proof (prove)\nusing this:\n  method P C1 M1 = (D, b, Ts, T, m)\n\ngoal (1 subgoal):\n 1. (\\<And>mxs mxl\\<^sub>0 ins xt.\n        m = (mxs, mxl\\<^sub>0, ins, xt) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases m)"], ["proof (state)\nthis:\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n\ngoal (8 subgoals):\n 1. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "have method: \"\\<And>b' Ts' t' m' D'. P \\<turnstile> C1 sees M1,b':Ts' \\<rightarrow> t' = m' in D'\n     \\<Longrightarrow> (D,b,Ts,T,m) = (D',b',Ts',t',m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b' Ts' t' m' D'.\n       P \\<turnstile> C1 sees M1, b' :  Ts'\\<rightarrow>t' = m' in D' \\<Longrightarrow>\n       (D, b, Ts, T, m) = (D', b', Ts', t', m')", "using lets"], ["proof (prove)\nusing this:\n  method P C1 M1 = (D, b, Ts, T, m)\n\ngoal (1 subgoal):\n 1. \\<And>b' Ts' t' m' D'.\n       P \\<turnstile> C1 sees M1, b' :  Ts'\\<rightarrow>t' = m' in D' \\<Longrightarrow>\n       (D, b, Ts, T, m) = (D', b', Ts', t', m')", "by auto"], ["proof (state)\nthis:\n  P \\<turnstile> C1 sees M1, ?b' :  ?Ts'\\<rightarrow>?t' = ?m' in ?D' \\<Longrightarrow>\n  (D, b, Ts, T, m) = (?D', ?b', ?Ts', ?t', ?m')\n\ngoal (8 subgoals):\n 1. \\<And>x111 x112 x113.\n       i = Invokestatic x111 x112 x113 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 7. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 8. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases b)"], ["proof (state)\ngoal (2 subgoals):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. b = NonStatic \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case NonStatic"], ["proof (state)\nthis:\n  b = NonStatic\n\ngoal (2 subgoals):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. b = NonStatic \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  b = NonStatic", "show ?thesis"], ["proof (prove)\nusing this:\n  b = NonStatic\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Invokestatic_NoMethod exec_step_ind_Invokestatic_NonStatic\n        m method lets Invokestatic exec_instr StepI"], ["proof (prove)\nusing this:\n  b = NonStatic\n  \\<lbrakk>(?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   \\<nexists>Ts T m D b.\n      ?P \\<turnstile> ?C sees ?M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt NoSuchMethodError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>(?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   ?P \\<turnstile> ?C sees ?M, NonStatic :  ?Ts\\<rightarrow>?T = ?m in ?D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt\n                                IncompatibleClassChangeError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n  P \\<turnstile> C1 sees M1, ?b' :  ?Ts'\\<rightarrow>?t' = ?m' in ?D' \\<Longrightarrow>\n  (D, b, Ts, T, m) = (?D', ?b', ?Ts', ?t', ?m')\n  method P C1 M1 = (D, b, Ts, T, m)\n  i = Invokestatic C1 M1 n\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case Static"], ["proof (state)\nthis:\n  b = Static\n\ngoal (1 subgoal):\n 1. b = Static \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases \"ics = Called []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ics = Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case True"], ["proof (state)\nthis:\n  ics = Called []\n\ngoal (2 subgoals):\n 1. ics = Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  ics = Called []", "show ?thesis"], ["proof (prove)\nusing this:\n  ics = Called []\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Invokestatic_NoMethod\n          exec_step_ind_Invokestatic_Called exec_step_ind_Invokestatic_Init\n          Static m method lets Invokestatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  ics = Called []\n  \\<lbrakk>(?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   \\<nexists>Ts T m D b.\n      ?P \\<turnstile> ?C sees ?M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt NoSuchMethodError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>?ps = take ?n ?stk;\n   (?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) = method ?P ?C ?M;\n   ?P \\<turnstile> ?C sees ?M, Static :  ?Ts\\<rightarrow>?T = ?m in ?D;\n   ?f' =\n   ([], rev ?ps @ replicate ?mxl\\<^sub>0 undefined, ?D, ?M, 0,\n    No_ics)\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc (Called ?Cs) ?frs ?sh\n                     (None, ?h,\n                      ?f' #\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, No_ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>(?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   ?P \\<turnstile> ?C sees ?M, Static :  ?Ts\\<rightarrow>?T = ?m in ?D;\n   \\<forall>sfs. ?sh ?D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n   \\<forall>Cs. ?ics \\<noteq> Called Cs\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling ?D []) #\n                      ?frs,\n                      ?sh)\n  b = Static\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n  P \\<turnstile> C1 sees M1, ?b' :  ?Ts'\\<rightarrow>?t' = ?m' in ?D' \\<Longrightarrow>\n  (D, b, Ts, T, m) = (?D', ?b', ?Ts', ?t', ?m')\n  method P C1 M1 = (D, b, Ts, T, m)\n  i = Invokestatic C1 M1 n\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case False"], ["proof (state)\nthis:\n  ics \\<noteq> Called []\n\ngoal (1 subgoal):\n 1. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  ics \\<noteq> Called []", "have nCalled: \"\\<forall>Cs. ics \\<noteq> Called Cs\""], ["proof (prove)\nusing this:\n  ics \\<noteq> Called []\n\ngoal (1 subgoal):\n 1. \\<forall>Cs. ics \\<noteq> Called Cs", "using ics"], ["proof (prove)\nusing this:\n  ics \\<noteq> Called []\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. \\<forall>Cs. ics \\<noteq> Called Cs", "by simp"], ["proof (state)\nthis:\n  \\<forall>Cs. ics \\<noteq> Called Cs\n\ngoal (1 subgoal):\n 1. ics \\<noteq> Called [] \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases \"sh D\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sh D = None \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>a.\n       sh D = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "case None"], ["proof (state)\nthis:\n  sh D = None\n\ngoal (2 subgoals):\n 1. sh D = None \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>a.\n       sh D = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  sh D = None", "have nDone: \"\\<forall>sfs. sh D \\<noteq> Some(sfs, Done)\""], ["proof (prove)\nusing this:\n  sh D = None\n\ngoal (1 subgoal):\n 1. \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (2 subgoals):\n 1. sh D = None \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>a.\n       sh D = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Invokestatic_NoMethod\n            exec_step_ind_Invokestatic_Init[where sh=sh, OF _ _ nDone nCalled]\n            method m lets None False Static Invokestatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   \\<nexists>Ts T m D b.\n      ?P \\<turnstile> ?C sees ?M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt NoSuchMethodError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>(D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   ?P \\<turnstile> ?C sees ?M, Static :  ?Ts\\<rightarrow>?T = ?m in D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling D []) #\n                      ?frs,\n                      sh)\n  P \\<turnstile> C1 sees M1, ?b' :  ?Ts'\\<rightarrow>?t' = ?m' in ?D' \\<Longrightarrow>\n  (D, b, Ts, T, m) = (?D', ?b', ?Ts', ?t', ?m')\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n  method P C1 M1 = (D, b, Ts, T, m)\n  sh D = None\n  ics \\<noteq> Called []\n  b = Static\n  i = Invokestatic C1 M1 n\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh D = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh D = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "case (Some a)"], ["proof (state)\nthis:\n  sh D = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh D = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  sh D = \\<lfloor>a\\<rfloor>", "obtain sfs i where sfsi: \"a=(sfs,i)\""], ["proof (prove)\nusing this:\n  sh D = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>sfs i. a = (sfs, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases a)"], ["proof (state)\nthis:\n  a = (sfs, i)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       sh D = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Invokestatic_NoMethod\n            exec_step_ind_Invokestatic_Init sfsi False Static Some method lets Invokestatic exec_instr"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   \\<nexists>Ts T m D b.\n      ?P \\<turnstile> ?C sees ?M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt NoSuchMethodError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>(?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   ?P \\<turnstile> ?C sees ?M, Static :  ?Ts\\<rightarrow>?T = ?m in ?D;\n   \\<forall>sfs. ?sh ?D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n   \\<forall>Cs. ?ics \\<noteq> Called Cs\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling ?D []) #\n                      ?frs,\n                      ?sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D = \\<lfloor>a\\<rfloor>\n  P \\<turnstile> C1 sees M1, ?b' :  ?Ts'\\<rightarrow>?t' = ?m' in ?D' \\<Longrightarrow>\n  (D, b, Ts, T, m) = (?D', ?b', ?Ts', ?t', ?m')\n  method P C1 M1 = (D, b, Ts, T, m)\n  i__ = Invokestatic C1 M1 n\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases \"i = Done\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc\n                C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) =\n                         method P C M;\n                 \\<nexists>Ts T m D b.\n                    P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n                \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n))\n                                   P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                                   frs sh\n                                   (\\<lfloor>addr_of_sys_xcpt\n        NoSuchMethodError\\<rfloor>,\n                                    h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n  ics) #\n frs,\n                                    sh);\n     \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m sh ics n h stk loc\n        C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n         \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D = \\<lfloor>a\\<rfloor>;\n     \\<And>b' Ts' t' m' D'.\n        P \\<turnstile> C1 sees M1, b' :  Ts'\\<rightarrow>t' = m' in D' \\<Longrightarrow>\n        (D, b, Ts, T, m) = (D', b', Ts', t', m');\n     method P C1 M1 = (D, b, Ts, T, m); i__ = Invokestatic C1 M1 n;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>\\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc\n                C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) =\n                         method P C M;\n                 \\<nexists>Ts T m D b.\n                    P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n                \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n))\n                                   P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                                   frs sh\n                                   (\\<lfloor>addr_of_sys_xcpt\n        NoSuchMethodError\\<rfloor>,\n                                    h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n  ics) #\n frs,\n                                    sh);\n     \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m sh ics n h stk loc\n        C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n         \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D = \\<lfloor>a\\<rfloor>;\n     \\<And>b' Ts' t' m' D'.\n        P \\<turnstile> C1 sees M1, b' :  Ts'\\<rightarrow>t' = m' in D' \\<Longrightarrow>\n        (D, b, Ts, T, m) = (D', b', Ts', t', m');\n     method P C1 M1 = (D, b, Ts, T, m); i__ = Invokestatic C1 M1 n;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case True"], ["proof (state)\nthis:\n  i = Done\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc\n                C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) =\n                         method P C M;\n                 \\<nexists>Ts T m D b.\n                    P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n                \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n))\n                                   P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                                   frs sh\n                                   (\\<lfloor>addr_of_sys_xcpt\n        NoSuchMethodError\\<rfloor>,\n                                    h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n  ics) #\n frs,\n                                    sh);\n     \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m sh ics n h stk loc\n        C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n         \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D = \\<lfloor>a\\<rfloor>;\n     \\<And>b' Ts' t' m' D'.\n        P \\<turnstile> C1 sees M1, b' :  Ts'\\<rightarrow>t' = m' in D' \\<Longrightarrow>\n        (D, b, Ts, T, m) = (D', b', Ts', t', m');\n     method P C1 M1 = (D, b, Ts, T, m); i__ = Invokestatic C1 M1 n;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>\\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc\n                C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) =\n                         method P C M;\n                 \\<nexists>Ts T m D b.\n                    P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n                \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n))\n                                   P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                                   frs sh\n                                   (\\<lfloor>addr_of_sys_xcpt\n        NoSuchMethodError\\<rfloor>,\n                                    h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n  ics) #\n frs,\n                                    sh);\n     \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m sh ics n h stk loc\n        C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n         \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D = \\<lfloor>a\\<rfloor>;\n     \\<And>b' Ts' t' m' D'.\n        P \\<turnstile> C1 sees M1, b' :  Ts'\\<rightarrow>t' = m' in D' \\<Longrightarrow>\n        (D, b, Ts, T, m) = (D', b', Ts', t', m');\n     method P C1 M1 = (D, b, Ts, T, m); i__ = Invokestatic C1 M1 n;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Done", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Done\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Invokestatic_NoMethod\n              exec_step_ind_Invokestatic_Done[OF _ _ _ nCalled] exec_step_ind_Invokestatic_Init\n              sfsi False Static Some m method lets Invokestatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  i = Done\n  \\<lbrakk>(?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   \\<nexists>Ts T m D b.\n      ?P \\<turnstile> ?C sees ?M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt NoSuchMethodError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>?ps = take ?n ?stk;\n   (?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) = method ?P ?C ?M;\n   ?P \\<turnstile> ?C sees ?M, Static :  ?Ts\\<rightarrow>?T = ?m in ?D;\n   ?sh ?D = \\<lfloor>(?sfs, Done)\\<rfloor>;\n   ?f' =\n   ([], rev ?ps @ replicate ?mxl\\<^sub>0 undefined, ?D, ?M, 0,\n    No_ics)\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs ?sh\n                     (None, ?h,\n                      ?f' #\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ics) # ?frs,\n                      ?sh)\n  \\<lbrakk>(?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   ?P \\<turnstile> ?C sees ?M, Static :  ?Ts\\<rightarrow>?T = ?m in ?D;\n   \\<forall>sfs. ?sh ?D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n   \\<forall>Cs. ?ics \\<noteq> Called Cs\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling ?D []) #\n                      ?frs,\n                      ?sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D = \\<lfloor>a\\<rfloor>\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n  P \\<turnstile> C1 sees M1, ?b' :  ?Ts'\\<rightarrow>?t' = ?m' in ?D' \\<Longrightarrow>\n  (D, b, Ts, T, m) = (?D', ?b', ?Ts', ?t', ?m')\n  method P C1 M1 = (D, b, Ts, T, m)\n  i__ = Invokestatic C1 M1 n\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i__\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc\n                C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) =\n                         method P C M;\n                 \\<nexists>Ts T m D b.\n                    P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n                \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n))\n                                   P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                                   frs sh\n                                   (\\<lfloor>addr_of_sys_xcpt\n        NoSuchMethodError\\<rfloor>,\n                                    h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n  ics) #\n frs,\n                                    sh);\n     \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m sh ics n h stk loc\n        C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n         \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D = \\<lfloor>a\\<rfloor>;\n     \\<And>b' Ts' t' m' D'.\n        P \\<turnstile> C1 sees M1, b' :  Ts'\\<rightarrow>t' = m' in D' \\<Longrightarrow>\n        (D, b, Ts, T, m) = (D', b', Ts', t', m');\n     method P C1 M1 = (D, b, Ts, T, m); i__ = Invokestatic C1 M1 n;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc\n                C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) =\n                         method P C M;\n                 \\<nexists>Ts T m D b.\n                    P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n                \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n))\n                                   P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                                   frs sh\n                                   (\\<lfloor>addr_of_sys_xcpt\n        NoSuchMethodError\\<rfloor>,\n                                    h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n  ics) #\n frs,\n                                    sh);\n     \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m sh ics n h stk loc\n        C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n         \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D = \\<lfloor>a\\<rfloor>;\n     \\<And>b' Ts' t' m' D'.\n        P \\<turnstile> C1 sees M1, b' :  Ts'\\<rightarrow>t' = m' in D' \\<Longrightarrow>\n        (D, b, Ts, T, m) = (D', b', Ts', t', m');\n     method P C1 M1 = (D, b, Ts, T, m); i__ = Invokestatic C1 M1 n;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case nD: False"], ["proof (state)\nthis:\n  i \\<noteq> Done\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc\n                C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) =\n                         method P C M;\n                 \\<nexists>Ts T m D b.\n                    P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n                \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n))\n                                   P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                                   frs sh\n                                   (\\<lfloor>addr_of_sys_xcpt\n        NoSuchMethodError\\<rfloor>,\n                                    h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n  ics) #\n frs,\n                                    sh);\n     \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m sh ics n h stk loc\n        C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n         \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D = \\<lfloor>a\\<rfloor>;\n     \\<And>b' Ts' t' m' D'.\n        P \\<turnstile> C1 sees M1, b' :  Ts'\\<rightarrow>t' = m' in D' \\<Longrightarrow>\n        (D, b, Ts, T, m) = (D', b', Ts', t', m');\n     method P C1 M1 = (D, b, Ts, T, m); i__ = Invokestatic C1 M1 n;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> Done", "have nDone: \"\\<forall>sfs. sh D \\<noteq> Some(sfs, Done)\""], ["proof (prove)\nusing this:\n  i \\<noteq> Done\n\ngoal (1 subgoal):\n 1. \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "using sfsi Some"], ["proof (prove)\nusing this:\n  i \\<noteq> Done\n  a = (sfs, i)\n  sh D = \\<lfloor>a\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc\n                C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n                \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) =\n                         method P C M;\n                 \\<nexists>Ts T m D b.\n                    P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n                \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n))\n                                   P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                                   frs sh\n                                   (\\<lfloor>addr_of_sys_xcpt\n        NoSuchMethodError\\<rfloor>,\n                                    h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n  ics) #\n frs,\n                                    sh);\n     \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m sh ics n h stk loc\n        C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n         \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step_ind (StepI (Invokestatic C M n)) P h stk\n                           loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh\n                           (None, h,\n                            (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                             Calling D []) #\n                            frs,\n                            sh);\n     a = (sfs, i); ics \\<noteq> Called []; b = Static;\n     sh D = \\<lfloor>a\\<rfloor>;\n     \\<And>b' Ts' t' m' D'.\n        P \\<turnstile> C1 sees M1, b' :  Ts'\\<rightarrow>t' = m' in D' \\<Longrightarrow>\n        (D, b, Ts, T, m) = (D', b', Ts', t', m');\n     method P C1 M1 = (D, b, Ts, T, m); i__ = Invokestatic C1 M1 n;\n     exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh');\n     i \\<noteq> Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using nD"], ["proof (prove)\nusing this:\n  i \\<noteq> Done\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "proof(cases i)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Processing\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 4. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case Processing"], ["proof (state)\nthis:\n  i = Processing\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Processing\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 4. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Processing", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Processing\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Invokestatic_NoMethod\n                exec_step_ind_Invokestatic_Init[where sh=sh, OF _ _ nDone nCalled]\n                sfsi False Static Some m method lets Invokestatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  i = Processing\n  \\<lbrakk>(?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   \\<nexists>Ts T m D b.\n      ?P \\<turnstile> ?C sees ?M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt NoSuchMethodError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>(D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   ?P \\<turnstile> ?C sees ?M, Static :  ?Ts\\<rightarrow>?T = ?m in D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling D []) #\n                      ?frs,\n                      sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D = \\<lfloor>a\\<rfloor>\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n  P \\<turnstile> C1 sees M1, ?b' :  ?Ts'\\<rightarrow>?t' = ?m' in ?D' \\<Longrightarrow>\n  (D, b, Ts, T, m) = (?D', ?b', ?Ts', ?t', ?m')\n  method P C1 M1 = (D, b, Ts, T, m)\n  i__ = Invokestatic C1 M1 n\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i__\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case Prepared"], ["proof (state)\nthis:\n  i = Prepared\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Prepared\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 3. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Prepared", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Prepared\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Invokestatic_NoMethod\n                exec_step_ind_Invokestatic_Init[where sh=sh, OF _ _ nDone nCalled]\n                sfsi False Static Some m method lets Invokestatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  i = Prepared\n  \\<lbrakk>(?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   \\<nexists>Ts T m D b.\n      ?P \\<turnstile> ?C sees ?M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt NoSuchMethodError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>(D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   ?P \\<turnstile> ?C sees ?M, Static :  ?Ts\\<rightarrow>?T = ?m in D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling D []) #\n                      ?frs,\n                      sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D = \\<lfloor>a\\<rfloor>\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n  P \\<turnstile> C1 sees M1, ?b' :  ?Ts'\\<rightarrow>?t' = ?m' in ?D' \\<Longrightarrow>\n  (D, b, Ts, T, m) = (?D', ?b', ?Ts', ?t', ?m')\n  method P C1 M1 = (D, b, Ts, T, m)\n  i__ = Invokestatic C1 M1 n\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i__\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "case Error"], ["proof (state)\nthis:\n  i = Error\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')\n 2. \\<lbrakk>i \\<noteq> Done; i = Error\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Error", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Error\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Invokestatic_NoMethod\n                exec_step_ind_Invokestatic_Init[where sh=sh, OF _ _ nDone nCalled]\n                sfsi False Static Some m method lets Invokestatic exec_instr StepI ics"], ["proof (prove)\nusing this:\n  i = Error\n  \\<lbrakk>(?D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   \\<nexists>Ts T m D b.\n      ?P \\<turnstile> ?C sees ?M, b :  Ts\\<rightarrow>T = m in D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics ?frs ?sh\n                     (\\<lfloor>addr_of_sys_xcpt NoSuchMethodError\\<rfloor>,\n                      ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) #\n                      ?frs,\n                      ?sh)\n  \\<lbrakk>(D, ?b, ?Ts, ?T, ?mxs, ?mxl\\<^sub>0, ?ins, ?xt) =\n           method ?P ?C ?M;\n   ?P \\<turnstile> ?C sees ?M, Static :  ?Ts\\<rightarrow>?T = ?m in D\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI (Invokestatic ?C ?M ?n)) ?P ?h ?stk\n                     ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ics ?frs sh\n                     (None, ?h,\n                      (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc,\n                       Calling D []) #\n                      ?frs,\n                      sh)\n  a = (sfs, i)\n  ics \\<noteq> Called []\n  b = Static\n  sh D = \\<lfloor>a\\<rfloor>\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n  P \\<turnstile> C1 sees M1, ?b' :  ?Ts'\\<rightarrow>?t' = ?m' in ?D' \\<Longrightarrow>\n  (D, b, Ts, T, m) = (?D', ?b', ?Ts', ?t', ?m')\n  method P C1 M1 = (D, b, Ts, T, m)\n  i__ = Invokestatic C1 M1 n\n  exec_instr i__ P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i__\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> Done; i = Done\\<rbrakk>\n    \\<Longrightarrow> exec_step_ind (exec_step_input P C M pc ics) P h stk\n                       loc C M pc ics frs sh (xp', h', frs', sh')", "qed(simp)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (7 subgoals):\n 1. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case Return"], ["proof (state)\nthis:\n  i = Return\n\ngoal (7 subgoals):\n 1. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "obtain D b Ts T m where method: \"method P C M = (D,b,Ts,T,m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D b Ts T m.\n        method P C M = (D, b, Ts, T, m) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"method P C M\")"], ["proof (state)\nthis:\n  method P C M = (D, b, Ts, T, m)\n\ngoal (7 subgoals):\n 1. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  method P C M = (D, b, Ts, T, m)", "obtain mxs mxl\\<^sub>0 ins xt where \"m = (mxs,mxl\\<^sub>0,ins,xt)\""], ["proof (prove)\nusing this:\n  method P C M = (D, b, Ts, T, m)\n\ngoal (1 subgoal):\n 1. (\\<And>mxs mxl\\<^sub>0 ins xt.\n        m = (mxs, mxl\\<^sub>0, ins, xt) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases m)"], ["proof (state)\nthis:\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n\ngoal (7 subgoals):\n 1. i = Return \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 6. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 7. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  m = (mxs, mxl\\<^sub>0, ins, xt)", "show ?thesis"], ["proof (prove)\nusing this:\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_ind_Return_Last_Init exec_step_ind_Return_Last\n      exec_step_ind_Return_Init exec_step_ind_Return_NonStatic exec_step_ind_Return_Static\n       method Return exec_instr StepI ics"], ["proof (prove)\nusing this:\n  m = (mxs, mxl\\<^sub>0, ins, xt)\n  exec_step_ind (StepI Return) ?P ?h ?stk\\<^sub>0 ?loc\\<^sub>0 ?C\\<^sub>0\n   clinit ?pc ?ics [] ?sh\n   (None, ?h, [], ?sh(?C\\<^sub>0 \\<mapsto>\n    (fst (the (?sh ?C\\<^sub>0)), Done)))\n  ?M\\<^sub>0 \\<noteq> clinit \\<Longrightarrow>\n  exec_step_ind (StepI Return) ?P ?h ?stk\\<^sub>0 ?loc\\<^sub>0 ?C\\<^sub>0\n   ?M\\<^sub>0 ?pc ?ics [] ?sh (None, ?h, [], ?sh)\n  (?D, ?b, ?Ts, ?T, ?m) = method ?P ?C\\<^sub>0 clinit \\<Longrightarrow>\n  exec_step_ind (StepI Return) ?P ?h ?stk\\<^sub>0 ?loc\\<^sub>0 ?C\\<^sub>0\n   clinit ?pc ?ics ((?stk', ?loc', ?C', ?m', ?pc', ?ics') # ?frs') ?sh\n   (None, ?h, (?stk', ?loc', ?C', ?m', ?pc', ?ics') # ?frs', ?sh(?C\\<^sub>0 \n    \\<mapsto> (fst (the (?sh ?C\\<^sub>0)), Done)))\n  \\<lbrakk>(?D, NonStatic, ?Ts, ?T, ?m) = method ?P ?C\\<^sub>0 ?M\\<^sub>0;\n   ?M\\<^sub>0 \\<noteq> clinit\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI Return) ?P ?h ?stk\\<^sub>0\n                     ?loc\\<^sub>0 ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics\n                     ((?stk', ?loc', ?C', ?m', ?pc', ?ics') # ?frs') ?sh\n                     (None, ?h,\n                      (hd ?stk\\<^sub>0 # drop (length ?Ts + 1) ?stk', ?loc',\n                       ?C', ?m', Suc ?pc', ?ics') #\n                      ?frs',\n                      ?sh)\n  \\<lbrakk>(?D, Static, ?Ts, ?T, ?m) = method ?P ?C\\<^sub>0 ?M\\<^sub>0;\n   ?M\\<^sub>0 \\<noteq> clinit\\<rbrakk>\n  \\<Longrightarrow> exec_step_ind (StepI Return) ?P ?h ?stk\\<^sub>0\n                     ?loc\\<^sub>0 ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics\n                     ((?stk', ?loc', ?C', ?m', ?pc', ?ics') # ?frs') ?sh\n                     (None, ?h,\n                      (hd ?stk\\<^sub>0 # drop (length ?Ts) ?stk', ?loc',\n                       ?C', ?m', Suc ?pc', ?ics') #\n                      ?frs',\n                      ?sh)\n  method P C M = (D, b, Ts, T, m)\n  i = Return\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n  ics = Called [] \\<or> ics = No_ics\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: if_split_asm staticb.splits bool.splits list.splits)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (6 subgoals):\n 1. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case Pop"], ["proof (state)\nthis:\n  i = Pop\n\ngoal (6 subgoals):\n 1. i = Pop \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 5. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 6. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Pop", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Pop\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_instr StepI exec_step_ind_Pop"], ["proof (prove)\nusing this:\n  i = Pop\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n  exec_step_ind (StepI Pop) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics\n   ?frs ?sh\n   (None, ?h, (tl ?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, Suc ?pc, ?ics) # ?frs,\n    ?sh)\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by auto"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (5 subgoals):\n 1. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case IAdd"], ["proof (state)\nthis:\n  i = IAdd\n\ngoal (5 subgoals):\n 1. i = IAdd \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 4. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 5. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = IAdd", "show ?thesis"], ["proof (prove)\nusing this:\n  i = IAdd\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_instr StepI exec_step_ind_IAdd"], ["proof (prove)\nusing this:\n  i = IAdd\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n  exec_step_ind (StepI IAdd) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics\n   ?frs ?sh\n   (None, ?h,\n    (Intg (the_Intg (hd (tl ?stk)) + the_Intg (hd ?stk)) # tl (tl ?stk),\n     ?loc, ?C\\<^sub>0, ?M\\<^sub>0, Suc ?pc, ?ics) #\n    ?frs,\n    ?sh)\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by auto"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (4 subgoals):\n 1. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case Goto"], ["proof (state)\nthis:\n  i = Goto x15_\n\ngoal (4 subgoals):\n 1. \\<And>x15.\n       i = Goto x15 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 3. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 4. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Goto x15_", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Goto x15_\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_instr StepI exec_step_ind_Goto"], ["proof (prove)\nusing this:\n  i = Goto x15_\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n  exec_step_ind (StepI (Goto ?i)) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc\n   ?ics ?frs ?sh\n   (None, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, nat (int ?pc + ?i), ?ics) # ?frs,\n    ?sh)\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by auto"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (3 subgoals):\n 1. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case CmpEq"], ["proof (state)\nthis:\n  i = CmpEq\n\ngoal (3 subgoals):\n 1. i = CmpEq \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')\n 2. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 3. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = CmpEq", "show ?thesis"], ["proof (prove)\nusing this:\n  i = CmpEq\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_instr StepI exec_step_ind_CmpEq"], ["proof (prove)\nusing this:\n  i = CmpEq\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n  exec_step_ind (StepI CmpEq) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics\n   ?frs ?sh\n   (None, ?h,\n    (Bool (hd (tl ?stk) = hd ?stk) # tl (tl ?stk), ?loc, ?C\\<^sub>0,\n     ?M\\<^sub>0, Suc ?pc, ?ics) #\n    ?frs,\n    ?sh)\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by auto"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (2 subgoals):\n 1. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case (IfFalse x17)"], ["proof (state)\nthis:\n  i = IfFalse x17\n\ngoal (2 subgoals):\n 1. \\<And>x17.\n       i = IfFalse x17 \\<Longrightarrow>\n       exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics\n        frs sh (xp', h', frs', sh')\n 2. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = IfFalse x17", "show ?thesis"], ["proof (prove)\nusing this:\n  i = IfFalse x17\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_instr StepI exec_step_ind_IfFalse_nFalse exec_step_ind_IfFalse_False\n       exec_instr StepI"], ["proof (prove)\nusing this:\n  i = IfFalse x17\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n  hd ?stk \\<noteq> Bool False \\<Longrightarrow>\n  exec_step_ind (StepI (IfFalse ?i)) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0\n   ?pc ?ics ?frs ?sh\n   (None, ?h, (tl ?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, Suc ?pc, ?ics) # ?frs,\n    ?sh)\n  hd ?stk = Bool False \\<Longrightarrow>\n  exec_step_ind (StepI (IfFalse ?i)) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0\n   ?pc ?ics ?frs ?sh\n   (None, ?h,\n    (tl ?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, nat (int ?pc + ?i), ?ics) #\n    ?frs,\n    ?sh)\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: val.splits staticb.splits)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal (1 subgoal):\n 1. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "case Throw"], ["proof (state)\nthis:\n  i = Throw\n\ngoal (1 subgoal):\n 1. i = Throw \\<Longrightarrow>\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "then"], ["proof (chain)\npicking this:\n  i = Throw", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Throw\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_instr StepI exec_step_ind_Throw exec_step_ind_Throw_Null"], ["proof (prove)\nusing this:\n  i = Throw\n  exec_instr i P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n  exec_step_input P C M pc ics = StepI i\n  hd ?stk \\<noteq> Null \\<Longrightarrow>\n  exec_step_ind (StepI Throw) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics\n   ?frs ?sh\n   (\\<lfloor>the_Addr (hd ?stk)\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n  hd ?stk = Null \\<Longrightarrow>\n  exec_step_ind (StepI Throw) ?P ?h ?stk ?loc ?C\\<^sub>0 ?M\\<^sub>0 ?pc ?ics\n   ?frs ?sh\n   (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, ?h,\n    (?stk, ?loc, ?C\\<^sub>0, ?M\\<^sub>0, ?pc, ?ics) # ?frs, ?sh)\n\ngoal (1 subgoal):\n 1. exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by(auto split: val.splits)"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh\n   (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_step_ind_imp_exec_step:\nassumes esi: \"exec_step_ind si P h stk loc C M pc ics frs sh (xp', h', frs', sh')\"\n  and si: \"exec_step_input P C M pc ics = si\"\nshows \"exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')", "have StepI:\n   \"\\<And>P C M pc Cs i . exec_step_input P C M pc (Called Cs) = StepI i\n           \\<Longrightarrow> instrs_of P C M ! pc = i \\<and> Cs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P C M pc Cs i.\n       exec_step_input P C M pc (Called Cs) = StepI i \\<Longrightarrow>\n       instrs_of P C M ! pc = i \\<and> Cs = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P C M pc Cs i.\n       exec_step_input P C M pc (Called Cs) = StepI i \\<Longrightarrow>\n       instrs_of P C M ! pc = i \\<and> Cs = []", "fix P C M pc Cs i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P C M pc Cs i.\n       exec_step_input P C M pc (Called Cs) = StepI i \\<Longrightarrow>\n       instrs_of P C M ! pc = i \\<and> Cs = []", "show \"exec_step_input P C M pc (Called Cs) = StepI i\n           \\<Longrightarrow> instrs_of P C M ! pc = i \\<and> Cs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step_input P C M pc (Called Cs) = StepI i \\<Longrightarrow>\n    instrs_of P C M ! pc = i \\<and> Cs = []", "by(cases Cs; simp)"], ["proof (state)\nthis:\n  exec_step_input P C M pc (Called Cs) = StepI i \\<Longrightarrow>\n  instrs_of P C M ! pc = i \\<and> Cs = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step_input ?P ?C ?M ?pc (Called ?Cs) = StepI ?i \\<Longrightarrow>\n  instrs_of ?P ?C ?M ! ?pc = ?i \\<and> ?Cs = []\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')", "have StepC:\n   \"\\<And>P C M pc ics C' Cs. exec_step_input P C M pc ics = StepC C' Cs \\<Longrightarrow> ics = Calling C' Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P C M pc ics C' Cs.\n       exec_step_input P C M pc ics = StepC C' Cs \\<Longrightarrow>\n       ics = Calling C' Cs", "by simp"], ["proof (state)\nthis:\n  exec_step_input ?P ?C ?M ?pc ?ics = StepC ?C' ?Cs \\<Longrightarrow>\n  ?ics = Calling ?C' ?Cs\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')", "have StepT:\n   \"\\<And>P C M pc ics Cs a. exec_step_input P C M pc ics = StepT Cs a \\<Longrightarrow> ics = Throwing Cs a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P C M pc ics Cs a.\n       exec_step_input P C M pc ics = StepT Cs a \\<Longrightarrow>\n       ics = Throwing Cs a", "by simp"], ["proof (state)\nthis:\n  exec_step_input ?P ?C ?M ?pc ?ics = StepT ?Cs ?a \\<Longrightarrow>\n  ?ics = Throwing ?Cs ?a\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')", "using assms"], ["proof (prove)\nusing this:\n  exec_step_ind si P h stk loc C M pc ics frs sh (xp', h', frs', sh')\n  exec_step_input P C M pc ics = si\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')", "proof(induct rule: exec_step_ind.induct)"], ["proof (state)\ngoal (59 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>sh C obj h ics P stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>sh C = \\<lfloor>(obj, Done)\\<rfloor>; new_Addr h = None;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 7. \\<And>sh C obj h a ics P stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>sh C = \\<lfloor>(obj, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           ics) #\n                          frs,\n                          sh)\n 8. \\<And>sh C ics P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>\\<forall>obj. sh C \\<noteq> \\<lfloor>(obj, Done)\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C []) #\n                          frs,\n                          sh)\n 9. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 10. \\<And>v stk D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n         v \\<noteq> Null; \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchFieldError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 59 subgoals...", "case (exec_step_ind_NewOOM_Done sh C obj h ics P stk loc C\\<^sub>0 M\\<^sub>0 pc frs)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(obj, Done)\\<rfloor>\n  new_Addr h = None\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (New C)\n\ngoal (59 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>sh C obj h ics P stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>sh C = \\<lfloor>(obj, Done)\\<rfloor>; new_Addr h = None;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 7. \\<And>sh C obj h a ics P stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>sh C = \\<lfloor>(obj, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           ics) #\n                          frs,\n                          sh)\n 8. \\<And>sh C ics P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>\\<forall>obj. sh C \\<noteq> \\<lfloor>(obj, Done)\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C []) #\n                          frs,\n                          sh)\n 9. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 10. \\<And>v stk D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n         v \\<noteq> Null; \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchFieldError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 59 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>(obj, Done)\\<rfloor>\n  new_Addr h = None\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (New C)", "show ?case"], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>(obj, Done)\\<rfloor>\n  new_Addr h = None\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (New C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases ics, auto)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (58 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>sh C obj h a ics P stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>sh C = \\<lfloor>(obj, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           ics) #\n                          frs,\n                          sh)\n 7. \\<And>sh C ics P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>\\<forall>obj. sh C \\<noteq> \\<lfloor>(obj, Done)\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C []) #\n                          frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>v stk D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>v stk D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n         v \\<noteq> Null; P \\<turnstile> D has F,Static:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 58 subgoals...", "next"], ["proof (state)\ngoal (58 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>sh C obj h a ics P stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>sh C = \\<lfloor>(obj, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           ics) #\n                          frs,\n                          sh)\n 7. \\<And>sh C ics P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>\\<forall>obj. sh C \\<noteq> \\<lfloor>(obj, Done)\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C []) #\n                          frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>v stk D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>v stk D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n         v \\<noteq> Null; P \\<turnstile> D has F,Static:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 58 subgoals...", "case (exec_step_ind_New_Done sh C obj h a ics P stk loc C\\<^sub>0 M\\<^sub>0 pc frs)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(obj, Done)\\<rfloor>\n  new_Addr h = \\<lfloor>a\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (New C)\n\ngoal (58 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>sh C obj h a ics P stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>sh C = \\<lfloor>(obj, Done)\\<rfloor>;\n        new_Addr h = \\<lfloor>a\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           ics) #\n                          frs,\n                          sh)\n 7. \\<And>sh C ics P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>\\<forall>obj. sh C \\<noteq> \\<lfloor>(obj, Done)\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C []) #\n                          frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>v stk D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>v stk D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n         v \\<noteq> Null; P \\<turnstile> D has F,Static:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 58 subgoals...", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>(obj, Done)\\<rfloor>\n  new_Addr h = \\<lfloor>a\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (New C)", "show ?case"], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>(obj, Done)\\<rfloor>\n  new_Addr h = \\<lfloor>a\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (New C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h(a \\<mapsto> blank P C),\n     (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)", "by(cases ics, auto)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h(a \\<mapsto> blank P C),\n   (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n\ngoal (57 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>sh C ics P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>\\<forall>obj. sh C \\<noteq> \\<lfloor>(obj, Done)\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C []) #\n                          frs,\n                          sh)\n 7. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>v stk D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>v stk D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        P \\<turnstile> D has F,Static:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>v stk D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n         (D', b, t) = field P C F; v \\<noteq> Null;\n         P \\<turnstile> D has F,NonStatic:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (the (fs (F, C)) # tl stk, loc, C\\<^sub>0,\n                            M\\<^sub>0, pc + 1, ics) #\n                           frs,\n                           sh)\nA total of 57 subgoals...", "next"], ["proof (state)\ngoal (57 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>sh C ics P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>\\<forall>obj. sh C \\<noteq> \\<lfloor>(obj, Done)\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C []) #\n                          frs,\n                          sh)\n 7. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>v stk D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>v stk D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        P \\<turnstile> D has F,Static:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>v stk D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n         (D', b, t) = field P C F; v \\<noteq> Null;\n         P \\<turnstile> D has F,NonStatic:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (the (fs (F, C)) # tl stk, loc, C\\<^sub>0,\n                            M\\<^sub>0, pc + 1, ics) #\n                           frs,\n                           sh)\nA total of 57 subgoals...", "case (exec_step_ind_New_Init sh C ics P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs)"], ["proof (state)\nthis:\n  \\<forall>obj. sh C \\<noteq> \\<lfloor>(obj, Done)\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (New C)\n\ngoal (57 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>sh C ics P h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>\\<forall>obj. sh C \\<noteq> \\<lfloor>(obj, Done)\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C []) #\n                          frs,\n                          sh)\n 7. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>v stk D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>v stk D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        P \\<turnstile> D has F,Static:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>v stk D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n         (D', b, t) = field P C F; v \\<noteq> Null;\n         P \\<turnstile> D has F,NonStatic:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (the (fs (F, C)) # tl stk, loc, C\\<^sub>0,\n                            M\\<^sub>0, pc + 1, ics) #\n                           frs,\n                           sh)\nA total of 57 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<forall>obj. sh C \\<noteq> \\<lfloor>(obj, Done)\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (New C)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>obj. sh C \\<noteq> \\<lfloor>(obj, Done)\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (New C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Calling C []) # frs, sh)", "by(cases ics, auto split: init_state.splits)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Calling C []) # frs, sh)\n\ngoal (56 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>v stk D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>v stk D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        P \\<turnstile> D has F,Static:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>v stk D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n        (D', b, t) = field P C F; v \\<noteq> Null;\n        P \\<turnstile> D has F,NonStatic:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (the (fs (F, C)) # tl stk, loc, C\\<^sub>0,\n                           M\\<^sub>0, pc + 1, ics) #\n                          frs,\n                          sh)\n 10. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchFieldError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 56 subgoals...", "next"], ["proof (state)\ngoal (56 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>v stk D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>v stk D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        P \\<turnstile> D has F,Static:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>v stk D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n        (D', b, t) = field P C F; v \\<noteq> Null;\n        P \\<turnstile> D has F,NonStatic:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (the (fs (F, C)) # tl stk, loc, C\\<^sub>0,\n                           M\\<^sub>0, pc + 1, ics) #\n                          frs,\n                          sh)\n 10. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchFieldError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 56 subgoals...", "case (exec_step_ind_Getfield_NoField v stk D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  v = hd stk\n  (D, fs) = the (h (the_Addr v))\n  v \\<noteq> Null\n  \\<nexists>t b. P \\<turnstile> D has F,b:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getfield F C)\n\ngoal (56 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>v stk D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>v stk D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        P \\<turnstile> D has F,Static:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>v stk D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n        (D', b, t) = field P C F; v \\<noteq> Null;\n        P \\<turnstile> D has F,NonStatic:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (the (fs (F, C)) # tl stk, loc, C\\<^sub>0,\n                           M\\<^sub>0, pc + 1, ics) #\n                          frs,\n                          sh)\n 10. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchFieldError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 56 subgoals...", "then"], ["proof (chain)\npicking this:\n  v = hd stk\n  (D, fs) = the (h (the_Addr v))\n  v \\<noteq> Null\n  \\<nexists>t b. P \\<turnstile> D has F,b:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getfield F C)", "show ?case"], ["proof (prove)\nusing this:\n  v = hd stk\n  (D, fs) = the (h (the_Addr v))\n  v \\<noteq> Null\n  \\<nexists>t b. P \\<turnstile> D has F,b:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getfield F C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases \"the (h (the_Addr (hd stk)))\", cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (55 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>v stk D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        P \\<turnstile> D has F,Static:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>v stk D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n        (D', b, t) = field P C F; v \\<noteq> Null;\n        P \\<turnstile> D has F,NonStatic:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (the (fs (F, C)) # tl stk, loc, C\\<^sub>0,\n                           M\\<^sub>0, pc + 1, ics) #\n                          frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C F t D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>P \\<turnstile> C has F,NonStatic:t in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 55 subgoals...", "next"], ["proof (state)\ngoal (55 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>v stk D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        P \\<turnstile> D has F,Static:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>v stk D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n        (D', b, t) = field P C F; v \\<noteq> Null;\n        P \\<turnstile> D has F,NonStatic:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (the (fs (F, C)) # tl stk, loc, C\\<^sub>0,\n                           M\\<^sub>0, pc + 1, ics) #\n                          frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C F t D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>P \\<turnstile> C has F,NonStatic:t in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 55 subgoals...", "case (exec_step_ind_Getfield_Static v stk D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  v = hd stk\n  (D, fs) = the (h (the_Addr v))\n  v \\<noteq> Null\n  P \\<turnstile> D has F,Static:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getfield F C)\n\ngoal (55 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>v stk D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v)); v \\<noteq> Null;\n        P \\<turnstile> D has F,Static:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>v stk D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n        (D', b, t) = field P C F; v \\<noteq> Null;\n        P \\<turnstile> D has F,NonStatic:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (the (fs (F, C)) # tl stk, loc, C\\<^sub>0,\n                           M\\<^sub>0, pc + 1, ics) #\n                          frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C F t D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>P \\<turnstile> C has F,NonStatic:t in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 55 subgoals...", "then"], ["proof (chain)\npicking this:\n  v = hd stk\n  (D, fs) = the (h (the_Addr v))\n  v \\<noteq> Null\n  P \\<turnstile> D has F,Static:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getfield F C)", "show ?case"], ["proof (prove)\nusing this:\n  v = hd stk\n  (D, fs) = the (h (the_Addr v))\n  v \\<noteq> Null\n  P \\<turnstile> D has F,Static:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getfield F C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt IncompatibleClassChangeError\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases \"the (h (the_Addr (hd stk)))\", cases \"fst(snd(field P C F))\",\n        cases ics, auto simp: split_beta dest: has_field_sees[OF has_field_idemp] dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt IncompatibleClassChangeError\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (54 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>v stk D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n        (D', b, t) = field P C F; v \\<noteq> Null;\n        P \\<turnstile> D has F,NonStatic:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (the (fs (F, C)) # tl stk, loc, C\\<^sub>0,\n                           M\\<^sub>0, pc + 1, ics) #\n                          frs,\n                          sh)\n 8. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>P C F t D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>P \\<turnstile> C has F,NonStatic:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D' b t P D F C v sh h stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         v = the (fst (the (sh D')) F);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                           (Called Cs) frs sh =\n                          (None, h,\n                           (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                            No_ics) #\n                           frs,\n                           sh)\nA total of 54 subgoals...", "next"], ["proof (state)\ngoal (54 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>v stk D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n        (D', b, t) = field P C F; v \\<noteq> Null;\n        P \\<turnstile> D has F,NonStatic:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (the (fs (F, C)) # tl stk, loc, C\\<^sub>0,\n                           M\\<^sub>0, pc + 1, ics) #\n                          frs,\n                          sh)\n 8. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>P C F t D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>P \\<turnstile> C has F,NonStatic:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D' b t P D F C v sh h stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         v = the (fst (the (sh D')) F);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                           (Called Cs) frs sh =\n                          (None, h,\n                           (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                            No_ics) #\n                           frs,\n                           sh)\nA total of 54 subgoals...", "case (exec_step_ind_Getfield v stk D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  v = hd stk\n  (D, fs) = the (h (the_Addr v))\n  (D', b, t) = field P C F\n  v \\<noteq> Null\n  P \\<turnstile> D has F,NonStatic:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getfield F C)\n\ngoal (54 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>v stk D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>v = hd stk; (D, fs) = the (h (the_Addr v));\n        (D', b, t) = field P C F; v \\<noteq> Null;\n        P \\<turnstile> D has F,NonStatic:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (the (fs (F, C)) # tl stk, loc, C\\<^sub>0,\n                           M\\<^sub>0, pc + 1, ics) #\n                          frs,\n                          sh)\n 8. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>P C F t D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>P \\<turnstile> C has F,NonStatic:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D' b t P D F C v sh h stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         v = the (fst (the (sh D')) F);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                           (Called Cs) frs sh =\n                          (None, h,\n                           (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                            No_ics) #\n                           frs,\n                           sh)\nA total of 54 subgoals...", "then"], ["proof (chain)\npicking this:\n  v = hd stk\n  (D, fs) = the (h (the_Addr v))\n  (D', b, t) = field P C F\n  v \\<noteq> Null\n  P \\<turnstile> D has F,NonStatic:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getfield F C)", "show ?case"], ["proof (prove)\nusing this:\n  v = hd stk\n  (D, fs) = the (h (the_Addr v))\n  (D', b, t) = field P C F\n  v \\<noteq> Null\n  P \\<turnstile> D has F,NonStatic:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getfield F C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h,\n     (the (fs (F, C)) # tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1, ics) #\n     frs,\n     sh)", "by(cases \"the (h (the_Addr (hd stk)))\",\n        cases ics; fastforce simp: split_beta dest: has_field_sees[OF has_field_idemp] dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h,\n   (the (fs (F, C)) # tl stk, loc, C\\<^sub>0, M\\<^sub>0, pc + 1, ics) # frs,\n   sh)\n\ngoal (53 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>P C F t D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>P \\<turnstile> C has F,NonStatic:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>D' b t P D F C v sh h stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D; v = the (fst (the (sh D')) F);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h,\n                          (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 10. \\<And>D' b t P D F C ics sh sfs v h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>Cs. ics \\<noteq> Called Cs;\n         sh D' = \\<lfloor>(sfs, Done)\\<rfloor>; v = the (sfs F);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                            ics) #\n                           frs,\n                           sh)\nA total of 53 subgoals...", "next"], ["proof (state)\ngoal (53 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>P C F t D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>P \\<turnstile> C has F,NonStatic:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>D' b t P D F C v sh h stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D; v = the (fst (the (sh D')) F);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h,\n                          (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 10. \\<And>D' b t P D F C ics sh sfs v h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>Cs. ics \\<noteq> Called Cs;\n         sh D' = \\<lfloor>(sfs, Done)\\<rfloor>; v = the (sfs F);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                            ics) #\n                           frs,\n                           sh)\nA total of 53 subgoals...", "case (exec_step_ind_Getstatic_NonStatic P C F t D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  P \\<turnstile> C has F,NonStatic:t in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getstatic C F D)\n\ngoal (53 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>P C F t D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>P \\<turnstile> C has F,NonStatic:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>D' b t P D F C v sh h stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D; v = the (fst (the (sh D')) F);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h,\n                          (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 10. \\<And>D' b t P D F C ics sh sfs v h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>Cs. ics \\<noteq> Called Cs;\n         sh D' = \\<lfloor>(sfs, Done)\\<rfloor>; v = the (sfs F);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                            ics) #\n                           frs,\n                           sh)\nA total of 53 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has F,NonStatic:t in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getstatic C F D)", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has F,NonStatic:t in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getstatic C F D)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt IncompatibleClassChangeError\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases ics; fastforce simp: split_beta split: staticb.splits\n                             dest: has_field_sees[OF has_field_idemp] dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt IncompatibleClassChangeError\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (52 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D' b t P D F C v sh h stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D; v = the (fst (the (sh D')) F);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h,\n                          (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 9. \\<And>D' b t P D F C ics sh sfs v h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        sh D' = \\<lfloor>(sfs, Done)\\<rfloor>; v = the (sfs F);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           ics) #\n                          frs,\n                          sh)\n 10. \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Calling D' []) #\n                           frs,\n                           sh)\nA total of 52 subgoals...", "next"], ["proof (state)\ngoal (52 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D' b t P D F C v sh h stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D; v = the (fst (the (sh D')) F);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h,\n                          (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 9. \\<And>D' b t P D F C ics sh sfs v h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        sh D' = \\<lfloor>(sfs, Done)\\<rfloor>; v = the (sfs F);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           ics) #\n                          frs,\n                          sh)\n 10. \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Calling D' []) #\n                           frs,\n                           sh)\nA total of 52 subgoals...", "case exec_step_ind_Getstatic_Called"], ["proof (state)\nthis:\n  (D'_, b_, t_) = field P_ D_ F_\n  P_ \\<turnstile> C_ has F_,Static:t_ in D_\n  v_ = the (fst (the (sh_ D'_)) F_)\n  exec_step_input P_ C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) =\n  StepI (Getstatic C_ F_ D_)\n\ngoal (52 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D' b t P D F C v sh h stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D; v = the (fst (the (sh D')) F);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h,\n                          (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 9. \\<And>D' b t P D F C ics sh sfs v h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        sh D' = \\<lfloor>(sfs, Done)\\<rfloor>; v = the (sfs F);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           ics) #\n                          frs,\n                          sh)\n 10. \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Getstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Calling D' []) #\n                           frs,\n                           sh)\nA total of 52 subgoals...", "then"], ["proof (chain)\npicking this:\n  (D'_, b_, t_) = field P_ D_ F_\n  P_ \\<turnstile> C_ has F_,Static:t_ in D_\n  v_ = the (fst (the (sh_ D'_)) F_)\n  exec_step_input P_ C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) =\n  StepI (Getstatic C_ F_ D_)", "show ?case"], ["proof (prove)\nusing this:\n  (D'_, b_, t_) = field P_ D_ F_\n  P_ \\<turnstile> C_ has F_,Static:t_ in D_\n  v_ = the (fst (the (sh_ D'_)) F_)\n  exec_step_input P_ C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) =\n  StepI (Getstatic C_ F_ D_)\n\ngoal (1 subgoal):\n 1. exec_step P_ h_ stk_ loc_ C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) frs_\n     sh_ =\n    (None, h_,\n     (v_ # stk_, loc_, C\\<^sub>0_, M\\<^sub>0_, Suc pc_, No_ics) # frs_, sh_)", "by(fastforce simp: split_beta split: staticb.splits dest!: StepI\n                                 dest: has_field_sees[OF has_field_idemp])"], ["proof (state)\nthis:\n  exec_step P_ h_ stk_ loc_ C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) frs_\n   sh_ =\n  (None, h_,\n   (v_ # stk_, loc_, C\\<^sub>0_, M\\<^sub>0_, Suc pc_, No_ics) # frs_, sh_)\n\ngoal (51 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D' b t P D F C ics sh sfs v h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        sh D' = \\<lfloor>(sfs, Done)\\<rfloor>; v = the (sfs F);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           ics) #\n                          frs,\n                          sh)\n 9. \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D;\n        \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D' []) #\n                          frs,\n                          sh)\n 10. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>hd (tl stk) = Null;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 51 subgoals...", "next"], ["proof (state)\ngoal (51 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D' b t P D F C ics sh sfs v h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        sh D' = \\<lfloor>(sfs, Done)\\<rfloor>; v = the (sfs F);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           ics) #\n                          frs,\n                          sh)\n 9. \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D;\n        \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D' []) #\n                          frs,\n                          sh)\n 10. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>hd (tl stk) = Null;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 51 subgoals...", "case (exec_step_ind_Getstatic_Done D' b t P D F C ics sh sfs v h stk loc C\\<^sub>0 M\\<^sub>0 pc frs)"], ["proof (state)\nthis:\n  (D', b, t) = field P D F\n  P \\<turnstile> C has F,Static:t in D\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  sh D' = \\<lfloor>(sfs, Done)\\<rfloor>\n  v = the (sfs F)\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getstatic C F D)\n\ngoal (51 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D' b t P D F C ics sh sfs v h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        sh D' = \\<lfloor>(sfs, Done)\\<rfloor>; v = the (sfs F);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           ics) #\n                          frs,\n                          sh)\n 9. \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D;\n        \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D' []) #\n                          frs,\n                          sh)\n 10. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>hd (tl stk) = Null;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 51 subgoals...", "then"], ["proof (chain)\npicking this:\n  (D', b, t) = field P D F\n  P \\<turnstile> C has F,Static:t in D\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  sh D' = \\<lfloor>(sfs, Done)\\<rfloor>\n  v = the (sfs F)\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getstatic C F D)", "show ?case"], ["proof (prove)\nusing this:\n  (D', b, t) = field P D F\n  P \\<turnstile> C has F,Static:t in D\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  sh D' = \\<lfloor>(sfs, Done)\\<rfloor>\n  v = the (sfs F)\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getstatic C F D)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)", "by(cases ics, auto simp: split_beta split: staticb.splits\n                                       dest: has_field_sees[OF has_field_idemp])"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n\ngoal (50 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D;\n        \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D' []) #\n                          frs,\n                          sh)\n 9. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 10. \\<And>r stk a D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>r = hd (tl stk); a = the_Addr r; (D, fs) = the (h a);\n         r \\<noteq> Null; \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchFieldError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 50 subgoals...", "next"], ["proof (state)\ngoal (50 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D;\n        \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D' []) #\n                          frs,\n                          sh)\n 9. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 10. \\<And>r stk a D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>r = hd (tl stk); a = the_Addr r; (D, fs) = the (h a);\n         r \\<noteq> Null; \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchFieldError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 50 subgoals...", "case (exec_step_ind_Getstatic_Init D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs)"], ["proof (state)\nthis:\n  (D', b, t) = field P D F\n  P \\<turnstile> C has F,Static:t in D\n  \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getstatic C F D)\n\ngoal (50 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n       \\<lbrakk>(D', b, t) = field P D F;\n        P \\<turnstile> C has F,Static:t in D;\n        \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n        \\<forall>Cs. ics \\<noteq> Called Cs;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D' []) #\n                          frs,\n                          sh)\n 9. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 10. \\<And>r stk a D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>r = hd (tl stk); a = the_Addr r; (D, fs) = the (h a);\n         r \\<noteq> Null; \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchFieldError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 50 subgoals...", "then"], ["proof (chain)\npicking this:\n  (D', b, t) = field P D F\n  P \\<turnstile> C has F,Static:t in D\n  \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getstatic C F D)", "show ?case"], ["proof (prove)\nusing this:\n  (D', b, t) = field P D F\n  P \\<turnstile> C has F,Static:t in D\n  \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getstatic C F D)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Calling D' []) # frs, sh)", "by(cases ics, auto simp: split_beta split: init_state.splits staticb.splits\n                          dest: has_field_sees[OF has_field_idemp])"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Calling D' []) # frs, sh)\n\ngoal (49 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>r stk a D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = hd (tl stk); a = the_Addr r; (D, fs) = the (h a);\n        r \\<noteq> Null; \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>r stk a D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>r = hd (tl stk); a = the_Addr r; (D, fs) = the (h a);\n         r \\<noteq> Null; P \\<turnstile> D has F,Static:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 49 subgoals...", "next"], ["proof (state)\ngoal (49 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>r stk a D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = hd (tl stk); a = the_Addr r; (D, fs) = the (h a);\n        r \\<noteq> Null; \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>r stk a D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>r = hd (tl stk); a = the_Addr r; (D, fs) = the (h a);\n         r \\<noteq> Null; P \\<turnstile> D has F,Static:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 49 subgoals...", "case (exec_step_ind_Putfield_NoField r stk a D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  r = hd (tl stk)\n  a = the_Addr r\n  (D, fs) = the (h a)\n  r \\<noteq> Null\n  \\<nexists>t b. P \\<turnstile> D has F,b:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putfield F C)\n\ngoal (49 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>r stk a D fs h P F C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = hd (tl stk); a = the_Addr r; (D, fs) = the (h a);\n        r \\<noteq> Null; \\<nexists>t b. P \\<turnstile> D has F,b:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>r stk a D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>r = hd (tl stk); a = the_Addr r; (D, fs) = the (h a);\n         r \\<noteq> Null; P \\<turnstile> D has F,Static:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 49 subgoals...", "then"], ["proof (chain)\npicking this:\n  r = hd (tl stk)\n  a = the_Addr r\n  (D, fs) = the (h a)\n  r \\<noteq> Null\n  \\<nexists>t b. P \\<turnstile> D has F,b:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putfield F C)", "show ?case"], ["proof (prove)\nusing this:\n  r = hd (tl stk)\n  a = the_Addr r\n  (D, fs) = the (h a)\n  r \\<noteq> Null\n  \\<nexists>t b. P \\<turnstile> D has F,b:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putfield F C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases \"the (h (the_Addr (hd(tl stk))))\", cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (48 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>r stk a D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = hd (tl stk); a = the_Addr r; (D, fs) = the (h a);\n        r \\<noteq> Null; P \\<turnstile> D has F,Static:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>v stk r a D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs\n        sh.\n        \\<lbrakk>v = hd stk; r = hd (tl stk); a = the_Addr r;\n         (D, fs) = the (h a); (D', b, t) = field P C F; r \\<noteq> Null;\n         P \\<turnstile> D has F,NonStatic:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h(a \\<mapsto> (D, fs((F, C) \\<mapsto> v))),\n                           (tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1,\n                            ics) #\n                           frs,\n                           sh)\nA total of 48 subgoals...", "next"], ["proof (state)\ngoal (48 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>r stk a D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = hd (tl stk); a = the_Addr r; (D, fs) = the (h a);\n        r \\<noteq> Null; P \\<turnstile> D has F,Static:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>v stk r a D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs\n        sh.\n        \\<lbrakk>v = hd stk; r = hd (tl stk); a = the_Addr r;\n         (D, fs) = the (h a); (D', b, t) = field P C F; r \\<noteq> Null;\n         P \\<turnstile> D has F,NonStatic:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h(a \\<mapsto> (D, fs((F, C) \\<mapsto> v))),\n                           (tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1,\n                            ics) #\n                           frs,\n                           sh)\nA total of 48 subgoals...", "case (exec_step_ind_Putfield_Static r stk a D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  r = hd (tl stk)\n  a = the_Addr r\n  (D, fs) = the (h a)\n  r \\<noteq> Null\n  P \\<turnstile> D has F,Static:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putfield F C)\n\ngoal (48 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>r stk a D fs h P F t C loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = hd (tl stk); a = the_Addr r; (D, fs) = the (h a);\n        r \\<noteq> Null; P \\<turnstile> D has F,Static:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>v stk r a D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs\n        sh.\n        \\<lbrakk>v = hd stk; r = hd (tl stk); a = the_Addr r;\n         (D, fs) = the (h a); (D', b, t) = field P C F; r \\<noteq> Null;\n         P \\<turnstile> D has F,NonStatic:t in C;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putfield F C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h(a \\<mapsto> (D, fs((F, C) \\<mapsto> v))),\n                           (tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1,\n                            ics) #\n                           frs,\n                           sh)\nA total of 48 subgoals...", "then"], ["proof (chain)\npicking this:\n  r = hd (tl stk)\n  a = the_Addr r\n  (D, fs) = the (h a)\n  r \\<noteq> Null\n  P \\<turnstile> D has F,Static:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putfield F C)", "show ?case"], ["proof (prove)\nusing this:\n  r = hd (tl stk)\n  a = the_Addr r\n  (D, fs) = the (h a)\n  r \\<noteq> Null\n  P \\<turnstile> D has F,Static:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putfield F C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt IncompatibleClassChangeError\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases \"the (h (the_Addr (hd(tl stk))))\", cases \"fst(snd(field P C F))\",\n        cases ics, auto simp: split_beta dest: has_field_sees[OF has_field_idemp] dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt IncompatibleClassChangeError\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (47 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>v stk r a D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs\n       sh.\n       \\<lbrakk>v = hd stk; r = hd (tl stk); a = the_Addr r;\n        (D, fs) = the (h a); (D', b, t) = field P C F; r \\<noteq> Null;\n        P \\<turnstile> D has F,NonStatic:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h(a \\<mapsto> (D, fs((F, C) \\<mapsto> v))),\n                          (tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1,\n                           ics) #\n                          frs,\n                          sh)\n 10. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchFieldError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 47 subgoals...", "next"], ["proof (state)\ngoal (47 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>v stk r a D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs\n       sh.\n       \\<lbrakk>v = hd stk; r = hd (tl stk); a = the_Addr r;\n        (D, fs) = the (h a); (D', b, t) = field P C F; r \\<noteq> Null;\n        P \\<turnstile> D has F,NonStatic:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h(a \\<mapsto> (D, fs((F, C) \\<mapsto> v))),\n                          (tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1,\n                           ics) #\n                          frs,\n                          sh)\n 10. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchFieldError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 47 subgoals...", "case (exec_step_ind_Putfield v stk r a D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  v = hd stk\n  r = hd (tl stk)\n  a = the_Addr r\n  (D, fs) = the (h a)\n  (D', b, t) = field P C F\n  r \\<noteq> Null\n  P \\<turnstile> D has F,NonStatic:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putfield F C)\n\ngoal (47 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>v stk r a D fs h D' b t P C F loc C\\<^sub>0 M\\<^sub>0 pc ics frs\n       sh.\n       \\<lbrakk>v = hd stk; r = hd (tl stk); a = the_Addr r;\n        (D, fs) = the (h a); (D', b, t) = field P C F; r \\<noteq> Null;\n        P \\<turnstile> D has F,NonStatic:t in C;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h(a \\<mapsto> (D, fs((F, C) \\<mapsto> v))),\n                          (tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1,\n                           ics) #\n                          frs,\n                          sh)\n 10. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchFieldError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 47 subgoals...", "then"], ["proof (chain)\npicking this:\n  v = hd stk\n  r = hd (tl stk)\n  a = the_Addr r\n  (D, fs) = the (h a)\n  (D', b, t) = field P C F\n  r \\<noteq> Null\n  P \\<turnstile> D has F,NonStatic:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putfield F C)", "show ?case"], ["proof (prove)\nusing this:\n  v = hd stk\n  r = hd (tl stk)\n  a = the_Addr r\n  (D, fs) = the (h a)\n  (D', b, t) = field P C F\n  r \\<noteq> Null\n  P \\<turnstile> D has F,NonStatic:t in C\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putfield F C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h(a \\<mapsto> (D, fs((F, C) \\<mapsto> v))),\n     (tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1, ics) # frs, sh)", "by(cases \"the (h (the_Addr (hd(tl stk))))\",\n        cases ics; fastforce simp: split_beta dest: has_field_sees[OF has_field_idemp] dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h(a \\<mapsto> (D, fs((F, C) \\<mapsto> v))),\n   (tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0, pc + 1, ics) # frs, sh)\n\ngoal (46 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C F t D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>P \\<turnstile> C has F,NonStatic:t in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 46 subgoals...", "next"], ["proof (state)\ngoal (46 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C F t D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>P \\<turnstile> C has F,NonStatic:t in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 46 subgoals...", "case (exec_step_ind_Putstatic_NonStatic P C F t D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  P \\<turnstile> C has F,NonStatic:t in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putstatic C F D)\n\ngoal (46 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C F t D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>P \\<turnstile> C has F,NonStatic:t in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 46 subgoals...", "then"], ["proof (chain)\npicking this:\n  P \\<turnstile> C has F,NonStatic:t in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putstatic C F D)", "show ?case"], ["proof (prove)\nusing this:\n  P \\<turnstile> C has F,NonStatic:t in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putstatic C F D)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt IncompatibleClassChangeError\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases ics; fastforce simp: split_beta split: staticb.splits\n                             dest: has_field_sees[OF has_field_idemp] dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt IncompatibleClassChangeError\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (45 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D' b t P D F C sh sfs i h stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D; the (sh D') = (sfs, i);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                           (Called Cs) frs sh =\n                          (None, h,\n                           (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                            No_ics) #\n                           frs,\n                           sh(D' \\<mapsto> (sfs(F \\<mapsto> hd stk), i)))\nA total of 45 subgoals...", "next"], ["proof (state)\ngoal (45 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D' b t P D F C sh sfs i h stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D; the (sh D') = (sfs, i);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                           (Called Cs) frs sh =\n                          (None, h,\n                           (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                            No_ics) #\n                           frs,\n                           sh(D' \\<mapsto> (sfs(F \\<mapsto> hd stk), i)))\nA total of 45 subgoals...", "case exec_step_ind_Putstatic_Called"], ["proof (state)\nthis:\n  (D'_, b_, t_) = field P_ D_ F_\n  P_ \\<turnstile> C_ has F_,Static:t_ in D_\n  the (sh_ D'_) = (sfs_, i_)\n  exec_step_input P_ C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) =\n  StepI (Putstatic C_ F_ D_)\n\ngoal (45 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D' b t P D F C sh sfs i h stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D; the (sh D') = (sfs, i);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                           (Called Cs) frs sh =\n                          (None, h,\n                           (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                            No_ics) #\n                           frs,\n                           sh(D' \\<mapsto> (sfs(F \\<mapsto> hd stk), i)))\nA total of 45 subgoals...", "then"], ["proof (chain)\npicking this:\n  (D'_, b_, t_) = field P_ D_ F_\n  P_ \\<turnstile> C_ has F_,Static:t_ in D_\n  the (sh_ D'_) = (sfs_, i_)\n  exec_step_input P_ C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) =\n  StepI (Putstatic C_ F_ D_)", "show ?case"], ["proof (prove)\nusing this:\n  (D'_, b_, t_) = field P_ D_ F_\n  P_ \\<turnstile> C_ has F_,Static:t_ in D_\n  the (sh_ D'_) = (sfs_, i_)\n  exec_step_input P_ C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) =\n  StepI (Putstatic C_ F_ D_)\n\ngoal (1 subgoal):\n 1. exec_step P_ h_ stk_ loc_ C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) frs_\n     sh_ =\n    (None, h_,\n     (tl stk_, loc_, C\\<^sub>0_, M\\<^sub>0_, Suc pc_, No_ics) # frs_, sh_\n     (D'_ \\<mapsto> (sfs_(F_ \\<mapsto> hd stk_), i_)))", "by(fastforce simp: split_beta split: staticb.splits dest!: StepI\n                                 dest: has_field_sees[OF has_field_idemp])"], ["proof (state)\nthis:\n  exec_step P_ h_ stk_ loc_ C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) frs_\n   sh_ =\n  (None, h_,\n   (tl stk_, loc_, C\\<^sub>0_, M\\<^sub>0_, Suc pc_, No_ics) # frs_, sh_(D'_ \n   \\<mapsto> (sfs_(F_ \\<mapsto> hd stk_), i_)))\n\ngoal (44 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D' b t P D F C ics sh sfs h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>Cs. ics \\<noteq> Called Cs;\n         sh D' = \\<lfloor>(sfs, Done)\\<rfloor>;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                            ics) #\n                           frs,\n                           sh(D' \\<mapsto> (sfs(F \\<mapsto> hd stk), Done)))\nA total of 44 subgoals...", "next"], ["proof (state)\ngoal (44 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D' b t P D F C ics sh sfs h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>Cs. ics \\<noteq> Called Cs;\n         sh D' = \\<lfloor>(sfs, Done)\\<rfloor>;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                            ics) #\n                           frs,\n                           sh(D' \\<mapsto> (sfs(F \\<mapsto> hd stk), Done)))\nA total of 44 subgoals...", "case (exec_step_ind_Putstatic_Done D' b t P D F C ics sh sfs h stk loc C\\<^sub>0 M\\<^sub>0 pc frs)"], ["proof (state)\nthis:\n  (D', b, t) = field P D F\n  P \\<turnstile> C has F,Static:t in D\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  sh D' = \\<lfloor>(sfs, Done)\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putstatic C F D)\n\ngoal (44 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D' b t P D F C ics sh sfs h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>Cs. ics \\<noteq> Called Cs;\n         sh D' = \\<lfloor>(sfs, Done)\\<rfloor>;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                            ics) #\n                           frs,\n                           sh(D' \\<mapsto> (sfs(F \\<mapsto> hd stk), Done)))\nA total of 44 subgoals...", "then"], ["proof (chain)\npicking this:\n  (D', b, t) = field P D F\n  P \\<turnstile> C has F,Static:t in D\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  sh D' = \\<lfloor>(sfs, Done)\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putstatic C F D)", "show ?case"], ["proof (prove)\nusing this:\n  (D', b, t) = field P D F\n  P \\<turnstile> C has F,Static:t in D\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  sh D' = \\<lfloor>(sfs, Done)\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putstatic C F D)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh(D' \n     \\<mapsto> (sfs(F \\<mapsto> hd stk), Done)))", "by(cases ics, auto simp: split_beta split: staticb.splits\n                                       dest: has_field_sees[OF has_field_idemp])"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh(D' \n   \\<mapsto> (sfs(F \\<mapsto> hd stk), Done)))\n\ngoal (43 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Calling D' []) #\n                           frs,\n                           sh)\nA total of 43 subgoals...", "next"], ["proof (state)\ngoal (43 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Calling D' []) #\n                           frs,\n                           sh)\nA total of 43 subgoals...", "case (exec_step_ind_Putstatic_Init D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs)"], ["proof (state)\nthis:\n  (D', b, t) = field P D F\n  P \\<turnstile> C has F,Static:t in D\n  \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putstatic C F D)\n\ngoal (43 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D' b t P D F C sh ics h stk loc C\\<^sub>0 M\\<^sub>0 pc frs.\n        \\<lbrakk>(D', b, t) = field P D F;\n         P \\<turnstile> C has F,Static:t in D;\n         \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>;\n         \\<forall>Cs. ics \\<noteq> Called Cs;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Putstatic C F D)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Calling D' []) #\n                           frs,\n                           sh)\nA total of 43 subgoals...", "then"], ["proof (chain)\npicking this:\n  (D', b, t) = field P D F\n  P \\<turnstile> C has F,Static:t in D\n  \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putstatic C F D)", "show ?case"], ["proof (prove)\nusing this:\n  (D', b, t) = field P D F\n  P \\<turnstile> C has F,Static:t in D\n  \\<forall>sfs. sh D' \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putstatic C F D)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Calling D' []) # frs, sh)", "by(cases ics, auto simp: split_beta split: staticb.splits init_state.splits\n                        dest: has_field_sees[OF has_field_idemp])"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Calling D' []) # frs, sh)\n\ngoal (42 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 42 subgoals...", "next"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 42 subgoals...", "case (exec_step_ind_Invoke ps n stk r C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m f' loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  ps = take n stk\n  r = stk ! n\n  C = cname_of h (the_Addr r)\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  r \\<noteq> Null\n  P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D\n  f' = ([], [r] @ rev ps @ replicate mxl\\<^sub>0 undefined, D, M, 0, No_ics)\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invoke M n)\n\ngoal (42 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 42 subgoals...", "then"], ["proof (chain)\npicking this:\n  ps = take n stk\n  r = stk ! n\n  C = cname_of h (the_Addr r)\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  r \\<noteq> Null\n  P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D\n  f' = ([], [r] @ rev ps @ replicate mxl\\<^sub>0 undefined, D, M, 0, No_ics)\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invoke M n)", "show ?case"], ["proof (prove)\nusing this:\n  ps = take n stk\n  r = stk ! n\n  C = cname_of h (the_Addr r)\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  r \\<noteq> Null\n  P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D\n  f' = ([], [r] @ rev ps @ replicate mxl\\<^sub>0 undefined, D, M, 0, No_ics)\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invoke M n)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, f' # (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases ics; fastforce dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, f' # (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (41 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 41 subgoals...", "next"], ["proof (state)\ngoal (41 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 41 subgoals...", "case (exec_step_ind_Invokestatic_Called ps n stk D b Ts T mxs mxl\\<^sub>0 ins xt P C M m ics ics' sh)"], ["proof (state)\nthis:\n  ps = take n stk\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D\n  ics = ([], rev ps @ replicate mxl\\<^sub>0 undefined, D, M, 0, No_ics)\n  exec_step_input P C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) =\n  StepI (Invokestatic C M n)\n\ngoal (41 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 41 subgoals...", "then"], ["proof (chain)\npicking this:\n  ps = take n stk\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D\n  ics = ([], rev ps @ replicate mxl\\<^sub>0 undefined, D, M, 0, No_ics)\n  exec_step_input P C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) =\n  StepI (Invokestatic C M n)", "show ?case"], ["proof (prove)\nusing this:\n  ps = take n stk\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D\n  ics = ([], rev ps @ replicate mxl\\<^sub>0 undefined, D, M, 0, No_ics)\n  exec_step_input P C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) =\n  StepI (Invokestatic C M n)\n\ngoal (1 subgoal):\n 1. exec_step P ics' stk sh C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) frs_\n     sh_ =\n    (None, ics',\n     ics # (stk, sh, C\\<^sub>0_, M\\<^sub>0_, pc_, No_ics) # frs_, sh_)", "by(cases ics; fastforce dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P ics' stk sh C\\<^sub>0_ M\\<^sub>0_ pc_ (Called Cs_) frs_ sh_ =\n  (None, ics', ics # (stk, sh, C\\<^sub>0_, M\\<^sub>0_, pc_, No_ics) # frs_,\n   sh_)\n\ngoal (40 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 40 subgoals...", "next"], ["proof (state)\ngoal (40 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 40 subgoals...", "case (exec_step_ind_Invokestatic_Done ps n stk D b Ts T mxs mxl\\<^sub>0 ins xt P C M m ics sh sfs f')"], ["proof (state)\nthis:\n  ps = take n stk\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  sh D = \\<lfloor>(sfs, Done)\\<rfloor>\n  f' = ([], rev ps @ replicate mxl\\<^sub>0 undefined, D, M, 0, No_ics)\n  exec_step_input P C\\<^sub>0_ M\\<^sub>0_ pc_ ics =\n  StepI (Invokestatic C M n)\n\ngoal (40 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 40 subgoals...", "then"], ["proof (chain)\npicking this:\n  ps = take n stk\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  sh D = \\<lfloor>(sfs, Done)\\<rfloor>\n  f' = ([], rev ps @ replicate mxl\\<^sub>0 undefined, D, M, 0, No_ics)\n  exec_step_input P C\\<^sub>0_ M\\<^sub>0_ pc_ ics =\n  StepI (Invokestatic C M n)", "show ?case"], ["proof (prove)\nusing this:\n  ps = take n stk\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  sh D = \\<lfloor>(sfs, Done)\\<rfloor>\n  f' = ([], rev ps @ replicate mxl\\<^sub>0 undefined, D, M, 0, No_ics)\n  exec_step_input P C\\<^sub>0_ M\\<^sub>0_ pc_ ics =\n  StepI (Invokestatic C M n)\n\ngoal (1 subgoal):\n 1. exec_step P h_ stk loc_ C\\<^sub>0_ M\\<^sub>0_ pc_ ics frs_ sh =\n    (None, h_, f' # (stk, loc_, C\\<^sub>0_, M\\<^sub>0_, pc_, ics) # frs_,\n     sh)", "by(cases ics; fastforce)"], ["proof (state)\nthis:\n  exec_step P h_ stk loc_ C\\<^sub>0_ M\\<^sub>0_ pc_ ics frs_ sh =\n  (None, h_, f' # (stk, loc_, C\\<^sub>0_, M\\<^sub>0_, pc_, ics) # frs_, sh)\n\ngoal (39 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 39 subgoals...", "next"], ["proof (state)\ngoal (39 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 39 subgoals...", "case (exec_step_ind_Invokestatic_Init D b Ts T mxs mxl\\<^sub>0 ins xt P C M m sh ics n h stk loc C\\<^sub>0 M\\<^sub>0 pc frs)"], ["proof (state)\nthis:\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D\n  \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invokestatic C M n)\n\ngoal (39 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 39 subgoals...", "then"], ["proof (chain)\npicking this:\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D\n  \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invokestatic C M n)", "show ?case"], ["proof (prove)\nusing this:\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D\n  \\<forall>sfs. sh D \\<noteq> \\<lfloor>(sfs, Done)\\<rfloor>\n  \\<forall>Cs. ics \\<noteq> Called Cs\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invokestatic C M n)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Calling D []) # frs, sh)", "by(cases ics; fastforce split: init_state.splits)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Calling D []) # frs, sh)\n\ngoal (38 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 38 subgoals...", "next"], ["proof (state)\ngoal (38 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 38 subgoals...", "case (exec_step_ind_Return_NonStatic D Ts T m P C\\<^sub>0 M\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc' C' m' pc' ics' frs' sh)"], ["proof (state)\nthis:\n  (D, NonStatic, Ts, T, m) = method P C\\<^sub>0 M\\<^sub>0\n  M\\<^sub>0 \\<noteq> clinit\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\n\ngoal (38 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 38 subgoals...", "then"], ["proof (chain)\npicking this:\n  (D, NonStatic, Ts, T, m) = method P C\\<^sub>0 M\\<^sub>0\n  M\\<^sub>0 \\<noteq> clinit\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return", "show ?case"], ["proof (prove)\nusing this:\n  (D, NonStatic, Ts, T, m) = method P C\\<^sub>0 M\\<^sub>0\n  M\\<^sub>0 \\<noteq> clinit\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\n\ngoal (1 subgoal):\n 1. exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 M\\<^sub>0 pc ics\n     ((stk', loc', C', m', pc', ics') # frs') sh =\n    (None, h,\n     (hd stk\\<^sub>0 # drop (length Ts + 1) stk', loc', C', m', Suc pc',\n      ics') #\n     frs',\n     sh)", "by(cases \"method P C\\<^sub>0 M\\<^sub>0\", cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 M\\<^sub>0 pc ics\n   ((stk', loc', C', m', pc', ics') # frs') sh =\n  (None, h,\n   (hd stk\\<^sub>0 # drop (length Ts + 1) stk', loc', C', m', Suc pc',\n    ics') #\n   frs',\n   sh)\n\ngoal (37 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 37 subgoals...", "next"], ["proof (state)\ngoal (37 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 37 subgoals...", "case (exec_step_ind_Return_Static D Ts T m P C\\<^sub>0 M\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc' C' m' pc' ics' frs' sh)"], ["proof (state)\nthis:\n  (D, Static, Ts, T, m) = method P C\\<^sub>0 M\\<^sub>0\n  M\\<^sub>0 \\<noteq> clinit\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\n\ngoal (37 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 37 subgoals...", "then"], ["proof (chain)\npicking this:\n  (D, Static, Ts, T, m) = method P C\\<^sub>0 M\\<^sub>0\n  M\\<^sub>0 \\<noteq> clinit\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return", "show ?case"], ["proof (prove)\nusing this:\n  (D, Static, Ts, T, m) = method P C\\<^sub>0 M\\<^sub>0\n  M\\<^sub>0 \\<noteq> clinit\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\n\ngoal (1 subgoal):\n 1. exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 M\\<^sub>0 pc ics\n     ((stk', loc', C', m', pc', ics') # frs') sh =\n    (None, h,\n     (hd stk\\<^sub>0 # drop (length Ts) stk', loc', C', m', Suc pc', ics') #\n     frs',\n     sh)", "by(cases \"method P C\\<^sub>0 M\\<^sub>0\", cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 M\\<^sub>0 pc ics\n   ((stk', loc', C', m', pc', ics') # frs') sh =\n  (None, h,\n   (hd stk\\<^sub>0 # drop (length Ts) stk', loc', C', m', Suc pc', ics') #\n   frs',\n   sh)\n\ngoal (36 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 36 subgoals...", "next"], ["proof (state)\ngoal (36 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 36 subgoals...", "case (exec_step_ind_IfFalse_nFalse stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  hd stk \\<noteq> Bool False\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (IfFalse i)\n\ngoal (36 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 36 subgoals...", "then"], ["proof (chain)\npicking this:\n  hd stk \\<noteq> Bool False\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (IfFalse i)", "show ?case"], ["proof (prove)\nusing this:\n  hd stk \\<noteq> Bool False\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (IfFalse i)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)", "by(cases \"hd stk\"; cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n\ngoal (35 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 35 subgoals...", "next"], ["proof (state)\ngoal (35 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 35 subgoals...", "case (exec_step_ind_Throw_Null stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  hd stk = Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\n\ngoal (35 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 35 subgoals...", "then"], ["proof (chain)\npicking this:\n  hd stk = Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw", "show ?case"], ["proof (prove)\nusing this:\n  hd stk = Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases \"hd stk\"; cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (34 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 34 subgoals...", "next"], ["proof (state)\ngoal (34 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 34 subgoals...", "case (exec_step_ind_Init C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC2 C Cs\n\ngoal (34 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 34 subgoals...", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC2 C Cs", "have \"ics = Called (C#Cs)\""], ["proof (prove)\nusing this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC2 C Cs\n\ngoal (1 subgoal):\n 1. ics = Called (C # Cs)", "by simp"], ["proof (state)\nthis:\n  ics = Called (C # Cs)\n\ngoal (34 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 34 subgoals...", "then"], ["proof (chain)\npicking this:\n  ics = Called (C # Cs)", "show ?case"], ["proof (prove)\nusing this:\n  ics = Called (C # Cs)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h,\n     create_init_frame P C #\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n     sh)", "by auto"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h,\n   create_init_frame P C #\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n   sh)\n\ngoal (33 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 33 subgoals...", "(***)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h,\n   create_init_frame P C #\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs,\n   sh)\n\ngoal (33 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 33 subgoals...", "next"], ["proof (state)\ngoal (33 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 33 subgoals...", "case (exec_step_ind_Load n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Load n)\n\ngoal (33 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Load n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 4. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                           frs,\n                           sh)\nA total of 33 subgoals...", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Load n)", "show ?case"], ["proof (prove)\nusing this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Load n)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n     sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (loc ! n # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n   sh)\n\ngoal (32 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 2. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 4. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                           sh)\nA total of 32 subgoals...", "next"], ["proof (state)\ngoal (32 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 2. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 4. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                           sh)\nA total of 32 subgoals...", "case (exec_step_ind_Store n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Store n)\n\ngoal (32 subgoals):\n 1. \\<And>n P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Store n) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 2. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 3. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 4. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 5. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 10. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Checkcast C)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                           sh)\nA total of 32 subgoals...", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Store n)", "show ?case"], ["proof (prove)\nusing this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Store n)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h,\n     (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n     sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h,\n   (tl stk, loc[n := hd stk], C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n\ngoal (31 subgoals):\n 1. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 2. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 3. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 4. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 9. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 10. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>stk ! n = Null;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invoke M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 31 subgoals...", "next"], ["proof (state)\ngoal (31 subgoals):\n 1. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 2. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 3. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 4. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 9. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 10. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>stk ! n = Null;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invoke M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 31 subgoals...", "case (exec_step_ind_Push v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Push v)\n\ngoal (31 subgoals):\n 1. \\<And>v P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Push v) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n        sh)\n 2. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 3. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 4. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 9. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 10. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>stk ! n = Null;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invoke M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 31 subgoals...", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Push v)", "show ?case"], ["proof (prove)\nusing this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Push v)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (v # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n\ngoal (30 subgoals):\n 1. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 2. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 3. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 8. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 10. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n         \\<nexists>Ts T m D b.\n            P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invoke M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchMethodError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 30 subgoals...", "next"], ["proof (state)\ngoal (30 subgoals):\n 1. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 2. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 3. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 8. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 10. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n         \\<nexists>Ts T m D b.\n            P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invoke M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchMethodError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 30 subgoals...", "case (exec_step_ind_NewOOM_Called h C P stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh ics')"], ["proof (state)\nthis:\n  new_Addr h = None\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called frs) = StepI (New C)\n\ngoal (30 subgoals):\n 1. \\<And>h C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) #\n                          frs,\n                          sh)\n 2. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 3. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 8. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 10. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n         \\<nexists>Ts T m D b.\n            P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invoke M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchMethodError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 30 subgoals...", "then"], ["proof (chain)\npicking this:\n  new_Addr h = None\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called frs) = StepI (New C)", "show ?case"], ["proof (prove)\nusing this:\n  new_Addr h = None\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called frs) = StepI (New C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc (Called frs) sh ics' =\n    (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # sh, ics')", "by(auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc (Called frs) sh ics' =\n  (\\<lfloor>addr_of_sys_xcpt OutOfMemory\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # sh, ics')\n\ngoal (29 subgoals):\n 1. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 2. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 7. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n        M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n         (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         r \\<noteq> Null;\n         P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invoke M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 29 subgoals...", "next"], ["proof (state)\ngoal (29 subgoals):\n 1. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 2. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 7. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n        M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n         (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         r \\<noteq> Null;\n         P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invoke M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 29 subgoals...", "case (exec_step_ind_New_Called h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc frs sh ics')"], ["proof (state)\nthis:\n  new_Addr h = \\<lfloor>a\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called frs) = StepI (New C)\n\ngoal (29 subgoals):\n 1. \\<And>h a C P stk loc C\\<^sub>0 M\\<^sub>0 pc Cs frs sh.\n       \\<lbrakk>new_Addr h = \\<lfloor>a\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called Cs) =\n        StepI (New C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc\n                          (Called Cs) frs sh =\n                         (None, h(a \\<mapsto> blank P C),\n                          (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc,\n                           No_ics) #\n                          frs,\n                          sh)\n 2. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 7. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n        M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n         (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         r \\<noteq> Null;\n         P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invoke M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 29 subgoals...", "then"], ["proof (chain)\npicking this:\n  new_Addr h = \\<lfloor>a\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called frs) = StepI (New C)", "show ?case"], ["proof (prove)\nusing this:\n  new_Addr h = \\<lfloor>a\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc (Called frs) = StepI (New C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc (Called frs) sh ics' =\n    (None, h(a \\<mapsto> blank P C),\n     (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, No_ics) # sh, ics')", "by(auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc (Called frs) sh ics' =\n  (None, h(a \\<mapsto> blank P C),\n   (Addr a # stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, No_ics) # sh, ics')\n\ngoal (28 subgoals):\n 1. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 6. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n        M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         \\<nexists>Ts T m D b.\n            P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invokestatic C M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchMethodError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 28 subgoals...", "next"], ["proof (state)\ngoal (28 subgoals):\n 1. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 6. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n        M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         \\<nexists>Ts T m D b.\n            P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invokestatic C M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchMethodError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 28 subgoals...", "case (exec_step_ind_Getfield_Null stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  hd stk = Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getfield F C)\n\ngoal (28 subgoals):\n 1. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 6. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n        M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         \\<nexists>Ts T m D b.\n            P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invokestatic C M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     NoSuchMethodError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 28 subgoals...", "then"], ["proof (chain)\npicking this:\n  hd stk = Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getfield F C)", "show ?case"], ["proof (prove)\nusing this:\n  hd stk = Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getfield F C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (27 subgoals):\n 1. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 5. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n        M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invokestatic C M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 27 subgoals...", "next"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 5. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n        M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invokestatic C M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 27 subgoals...", "case (exec_step_ind_Getstatic_NoField P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  \\<nexists>t b. P \\<turnstile> C has F,b:t in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getstatic C F D)\n\ngoal (27 subgoals):\n 1. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Getstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 5. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n        M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n         P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (Invokestatic C M n)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>addr_of_sys_xcpt\n                                     IncompatibleClassChangeError\\<rfloor>,\n                           h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                              frs,\n                           sh)\nA total of 27 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<nexists>t b. P \\<turnstile> C has F,b:t in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getstatic C F D)", "show ?case"], ["proof (prove)\nusing this:\n  \\<nexists>t b. P \\<turnstile> C has F,b:t in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Getstatic C F D)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (26 subgoals):\n 1. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 4. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n        exec_step_input P C\\<^sub>0 clinit pc ics =\n        StepI Return \\<Longrightarrow>\n        exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics []\n         sh =\n        (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n         (fst (the (sh C\\<^sub>0)), Done)))\nA total of 26 subgoals...", "next"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 4. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n        exec_step_input P C\\<^sub>0 clinit pc ics =\n        StepI Return \\<Longrightarrow>\n        exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics []\n         sh =\n        (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n         (fst (the (sh C\\<^sub>0)), Done)))\nA total of 26 subgoals...", "case (exec_step_ind_Putfield_Null stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  hd (tl stk) = Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putfield F C)\n\ngoal (26 subgoals):\n 1. \\<And>stk F C P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd (tl stk) = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putfield F C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 4. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 10. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n        exec_step_input P C\\<^sub>0 clinit pc ics =\n        StepI Return \\<Longrightarrow>\n        exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics []\n         sh =\n        (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n         (fst (the (sh C\\<^sub>0)), Done)))\nA total of 26 subgoals...", "then"], ["proof (chain)\npicking this:\n  hd (tl stk) = Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putfield F C)", "show ?case"], ["proof (prove)\nusing this:\n  hd (tl stk) = Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putfield F C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (25 subgoals):\n 1. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 3. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 10. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n        \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI Return\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                           M\\<^sub>0 pc ics [] sh =\n                          (None, h, [], sh)\nA total of 25 subgoals...", "next"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 3. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 10. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n        \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI Return\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                           M\\<^sub>0 pc ics [] sh =\n                          (None, h, [], sh)\nA total of 25 subgoals...", "case (exec_step_ind_Putstatic_NoField P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  \\<nexists>t b. P \\<turnstile> C has F,b:t in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putstatic C F D)\n\ngoal (25 subgoals):\n 1. \\<And>P C F D h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<nexists>t b. P \\<turnstile> C has F,b:t in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Putstatic C F D)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchFieldError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 3. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 9. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 10. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n        \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI Return\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                           M\\<^sub>0 pc ics [] sh =\n                          (None, h, [], sh)\nA total of 25 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<nexists>t b. P \\<turnstile> C has F,b:t in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putstatic C F D)", "show ?case"], ["proof (prove)\nusing this:\n  \\<nexists>t b. P \\<turnstile> C has F,b:t in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Putstatic C F D)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt NoSuchFieldError\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (24 subgoals):\n 1. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 2. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 9. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 10. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n        C' m' pc' ics' frs' sh.\n        \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n         exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                           clinit pc ics\n                           ((stk', loc', C', m', pc', ics') # frs') sh =\n                          (None, h, (stk', loc', C', m', pc', ics') # frs',\n                           sh(C\\<^sub>0 \\<mapsto>\n                           (fst (the (sh C\\<^sub>0)), Done)))\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 2. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 9. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 10. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n        C' m' pc' ics' frs' sh.\n        \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n         exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                           clinit pc ics\n                           ((stk', loc', C', m', pc', ics') # frs') sh =\n                          (None, h, (stk', loc', C', m', pc', ics') # frs',\n                           sh(C\\<^sub>0 \\<mapsto>\n                           (fst (the (sh C\\<^sub>0)), Done)))\nA total of 24 subgoals...", "case (exec_step_ind_Checkcast P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  cast_ok P C h (hd stk)\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Checkcast C)\n\ngoal (24 subgoals):\n 1. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n                          frs,\n                          sh)\n 2. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 8. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 9. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 10. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n        C' m' pc' ics' frs' sh.\n        \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n         exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                           clinit pc ics\n                           ((stk', loc', C', m', pc', ics') # frs') sh =\n                          (None, h, (stk', loc', C', m', pc', ics') # frs',\n                           sh(C\\<^sub>0 \\<mapsto>\n                           (fst (the (sh C\\<^sub>0)), Done)))\nA total of 24 subgoals...", "then"], ["proof (chain)\npicking this:\n  cast_ok P C h (hd stk)\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Checkcast C)", "show ?case"], ["proof (prove)\nusing this:\n  cast_ok P C h (hd stk)\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Checkcast C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n\ngoal (23 subgoals):\n 1. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 8. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 9. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 10. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI Pop \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n         sh)\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 8. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 9. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 10. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI Pop \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n         sh)\nA total of 23 subgoals...", "case (exec_step_ind_Checkcast_Error P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  \\<not> cast_ok P C h (hd stk)\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Checkcast C)\n\ngoal (23 subgoals):\n 1. \\<And>P C h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>\\<not> cast_ok P C h (hd stk);\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Checkcast C)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 7. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 8. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 9. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 10. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI Pop \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs,\n         sh)\nA total of 23 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<not> cast_ok P C h (hd stk)\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Checkcast C)", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> cast_ok P C h (hd stk)\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Checkcast C)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt ClassCast\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (22 subgoals):\n 1. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 7. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 8. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 9. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 10. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI IAdd \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h,\n         (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n          loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n         frs,\n         sh)\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 7. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 8. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 9. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 10. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI IAdd \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h,\n         (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n          loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n         frs,\n         sh)\nA total of 22 subgoals...", "case (exec_step_ind_Invoke_Null stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  stk ! n = Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invoke M n)\n\ngoal (22 subgoals):\n 1. \\<And>stk n M P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>stk ! n = Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 6. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 7. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 8. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 9. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 10. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI IAdd \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h,\n         (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n          loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n         frs,\n         sh)\nA total of 22 subgoals...", "then"], ["proof (chain)\npicking this:\n  stk ! n = Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invoke M n)", "show ?case"], ["proof (prove)\nusing this:\n  stk ! n = Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invoke M n)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt NullPointer\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (21 subgoals):\n 1. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 6. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 7. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 8. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 9. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 10. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>hd stk = Bool False;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (IfFalse i)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                            nat (int pc + i), ics) #\n                           frs,\n                           sh)\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 6. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 7. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 8. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 9. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 10. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>hd stk = Bool False;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (IfFalse i)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                            nat (int pc + i), ics) #\n                           frs,\n                           sh)\nA total of 21 subgoals...", "case (exec_step_ind_Invoke_NoMethod r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  r = stk ! n\n  C = cname_of h (the_Addr r)\n  r \\<noteq> Null\n  \\<nexists>Ts T m D b.\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invoke M n)\n\ngoal (21 subgoals):\n 1. \\<And>r stk n C h P M loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r); r \\<noteq> Null;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 5. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 6. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 7. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 8. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 9. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 10. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>hd stk = Bool False;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n         StepI (IfFalse i)\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                            nat (int pc + i), ics) #\n                           frs,\n                           sh)\nA total of 21 subgoals...", "then"], ["proof (chain)\npicking this:\n  r = stk ! n\n  C = cname_of h (the_Addr r)\n  r \\<noteq> Null\n  \\<nexists>Ts T m D b.\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invoke M n)", "show ?case"], ["proof (prove)\nusing this:\n  r = stk ! n\n  C = cname_of h (the_Addr r)\n  r \\<noteq> Null\n  \\<nexists>Ts T m D b.\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invoke M n)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>addr_of_sys_xcpt NoSuchMethodError\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>addr_of_sys_xcpt NoSuchMethodError\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (20 subgoals):\n 1. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 5. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 6. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 7. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 8. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 9. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 10. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI CmpEq \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h,\n         (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n          M\\<^sub>0, Suc pc, ics) #\n         frs,\n         sh)\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 5. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 6. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 7. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 8. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 9. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 10. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI CmpEq \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h,\n         (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n          M\\<^sub>0, Suc pc, ics) #\n         frs,\n         sh)\nA total of 20 subgoals...", "case (exec_step_ind_Invoke_Static r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0 M\\<^sub>0 pc ics)"], ["proof (state)\nthis:\n  r = stk ! n\n  C = cname_of h (the_Addr r)\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  r \\<noteq> Null\n  P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invoke M n)\n\ngoal (20 subgoals):\n 1. \\<And>r stk n C h D b Ts T mxs mxl\\<^sub>0 ins xt P M m loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>r = stk ! n; C = cname_of h (the_Addr r);\n        (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        r \\<noteq> Null;\n        P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invoke M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 4. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 5. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 6. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 7. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 8. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 9. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 10. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI CmpEq \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h,\n         (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n          M\\<^sub>0, Suc pc, ics) #\n         frs,\n         sh)\nA total of 20 subgoals...", "then"], ["proof (chain)\npicking this:\n  r = stk ! n\n  C = cname_of h (the_Addr r)\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  r \\<noteq> Null\n  P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invoke M n)", "show ?case"], ["proof (prove)\nusing this:\n  r = stk ! n\n  C = cname_of h (the_Addr r)\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  r \\<noteq> Null\n  P \\<turnstile> C sees M, Static :  Ts\\<rightarrow>T = m in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invoke M n)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs_ sh_ =\n    (\\<lfloor>addr_of_sys_xcpt IncompatibleClassChangeError\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs_, sh_)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs_ sh_ =\n  (\\<lfloor>addr_of_sys_xcpt IncompatibleClassChangeError\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs_, sh_)\n\ngoal (19 subgoals):\n 1. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 4. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 5. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 6. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 7. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 8. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 9. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 10. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Goto i) \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h,\n         (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 4. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 5. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 6. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 7. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 8. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 9. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 10. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Goto i) \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h,\n         (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\nA total of 19 subgoals...", "case (exec_step_ind_Invokestatic_NoMethod D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0 M\\<^sub>0 pc ics)"], ["proof (state)\nthis:\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  \\<nexists>Ts T m D b.\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invokestatic C M n)\n\ngoal (19 subgoals):\n 1. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        \\<nexists>Ts T m D b.\n           P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    NoSuchMethodError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 3. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 4. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 5. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 6. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 7. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 8. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 9. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 10. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Goto i) \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h,\n         (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\nA total of 19 subgoals...", "then"], ["proof (chain)\npicking this:\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  \\<nexists>Ts T m D b.\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invokestatic C M n)", "show ?case"], ["proof (prove)\nusing this:\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  \\<nexists>Ts T m D b.\n     P \\<turnstile> C sees M, b :  Ts\\<rightarrow>T = m in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invokestatic C M n)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs_ sh_ =\n    (\\<lfloor>addr_of_sys_xcpt NoSuchMethodError\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs_, sh_)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs_ sh_ =\n  (\\<lfloor>addr_of_sys_xcpt NoSuchMethodError\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs_, sh_)\n\ngoal (18 subgoals):\n 1. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 3. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 4. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 5. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 6. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 7. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 8. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 9. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 10. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>hd stk \\<noteq> Null;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                           sh)\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 3. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 4. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 5. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 6. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 7. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 8. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 9. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 10. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>hd stk \\<noteq> Null;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                           sh)\nA total of 18 subgoals...", "case (exec_step_ind_Invokestatic_NonStatic D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0 M\\<^sub>0 pc ics)"], ["proof (state)\nthis:\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invokestatic C M n)\n\ngoal (18 subgoals):\n 1. \\<And>D b Ts T mxs mxl\\<^sub>0 ins xt P C M m n h stk loc C\\<^sub>0\n       M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>(D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M;\n        P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (Invokestatic C M n)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>addr_of_sys_xcpt\n                                    IncompatibleClassChangeError\\<rfloor>,\n                          h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) #\n                             frs,\n                          sh)\n 2. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 3. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 4. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 5. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 6. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 7. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 8. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 9. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 10. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        \\<lbrakk>hd stk \\<noteq> Null;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                           sh)\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invokestatic C M n)", "show ?case"], ["proof (prove)\nusing this:\n  (D, b, Ts, T, mxs, mxl\\<^sub>0, ins, xt) = method P C M\n  P \\<turnstile> C sees M, NonStatic :  Ts\\<rightarrow>T = m in D\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Invokestatic C M n)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs_ sh_ =\n    (\\<lfloor>addr_of_sys_xcpt IncompatibleClassChangeError\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs_, sh_)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs_ sh_ =\n  (\\<lfloor>addr_of_sys_xcpt IncompatibleClassChangeError\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs_, sh_)\n\ngoal (17 subgoals):\n 1. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 2. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 3. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 4. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 5. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 6. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 7. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 8. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 9. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 10. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = None;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Calling C Cs) #\n                           frs,\n                           sh(C \\<mapsto> (sblank P C, Prepared)))\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 2. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 3. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 4. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 5. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 6. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 7. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 8. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 9. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 10. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = None;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Calling C Cs) #\n                           frs,\n                           sh(C \\<mapsto> (sblank P C, Prepared)))\nA total of 17 subgoals...", "case (exec_step_ind_Return_Last_Init P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh)"], ["proof (state)\nthis:\n  exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\n\ngoal (17 subgoals):\n 1. \\<And>P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       exec_step_input P C\\<^sub>0 clinit pc ics =\n       StepI Return \\<Longrightarrow>\n       exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n       (None, h, [], sh(C\\<^sub>0 \\<mapsto>\n        (fst (the (sh C\\<^sub>0)), Done)))\n 2. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 3. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 4. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 5. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 6. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 7. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 8. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 9. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 10. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = None;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Calling C Cs) #\n                           frs,\n                           sh(C \\<mapsto> (sblank P C, Prepared)))\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return", "show ?case"], ["proof (prove)\nusing this:\n  exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\n\ngoal (1 subgoal):\n 1. exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n    (None, h, [], sh(C\\<^sub>0 \\<mapsto> (fst (the (sh C\\<^sub>0)), Done)))", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics [] sh =\n  (None, h, [], sh(C\\<^sub>0 \\<mapsto> (fst (the (sh C\\<^sub>0)), Done)))\n\ngoal (16 subgoals):\n 1. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 2. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 3. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 4. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 5. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 6. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 7. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 8. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 10. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                           frs,\n                           sh)\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 2. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 3. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 4. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 5. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 6. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 7. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 8. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 10. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                           frs,\n                           sh)\nA total of 16 subgoals...", "case (exec_step_ind_Return_Last M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh)"], ["proof (state)\nthis:\n  M\\<^sub>0 \\<noteq> clinit\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\n\ngoal (16 subgoals):\n 1. \\<And>M\\<^sub>0 P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 pc ics sh.\n       \\<lbrakk>M\\<^sub>0 \\<noteq> clinit;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          M\\<^sub>0 pc ics [] sh =\n                         (None, h, [], sh)\n 2. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 3. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 4. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 5. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 6. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 7. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 8. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 9. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 10. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                           frs,\n                           sh)\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  M\\<^sub>0 \\<noteq> clinit\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return", "show ?case"], ["proof (prove)\nusing this:\n  M\\<^sub>0 \\<noteq> clinit\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Return\n\ngoal (1 subgoal):\n 1. exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 M\\<^sub>0 pc ics [] sh =\n    (None, h, [], sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 M\\<^sub>0 pc ics [] sh =\n  (None, h, [], sh)\n\ngoal (15 subgoals):\n 1. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 2. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 3. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 4. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 5. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 6. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 7. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 9. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 10. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                           frs,\n                           sh)\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 2. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 3. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 4. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 5. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 6. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 7. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 9. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 10. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                           frs,\n                           sh)\nA total of 15 subgoals...", "case (exec_step_ind_Return_Init D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc' C' m' pc' ics')"], ["proof (state)\nthis:\n  (D, b, Ts, T, m) = method P C\\<^sub>0 clinit\n  exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\n\ngoal (15 subgoals):\n 1. \\<And>D b Ts T m P C\\<^sub>0 h stk\\<^sub>0 loc\\<^sub>0 pc ics stk' loc'\n       C' m' pc' ics' frs' sh.\n       \\<lbrakk>(D, b, Ts, T, m) = method P C\\<^sub>0 clinit;\n        exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0\n                          clinit pc ics\n                          ((stk', loc', C', m', pc', ics') # frs') sh =\n                         (None, h, (stk', loc', C', m', pc', ics') # frs',\n                          sh(C\\<^sub>0 \\<mapsto>\n                          (fst (the (sh C\\<^sub>0)), Done)))\n 2. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 3. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 4. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 5. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 6. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 7. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 8. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 9. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 10. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                           frs,\n                           sh)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  (D, b, Ts, T, m) = method P C\\<^sub>0 clinit\n  exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return", "show ?case"], ["proof (prove)\nusing this:\n  (D, b, Ts, T, m) = method P C\\<^sub>0 clinit\n  exec_step_input P C\\<^sub>0 clinit pc ics = StepI Return\n\ngoal (1 subgoal):\n 1. exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics\n     ((stk', loc', C', m', pc', ics') # frs'_) sh_ =\n    (None, h, (stk', loc', C', m', pc', ics') # frs'_, sh_(C\\<^sub>0 \n     \\<mapsto> (fst (the (sh_ C\\<^sub>0)), Done)))", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk\\<^sub>0 loc\\<^sub>0 C\\<^sub>0 clinit pc ics\n   ((stk', loc', C', m', pc', ics') # frs'_) sh_ =\n  (None, h, (stk', loc', C', m', pc', ics') # frs'_, sh_(C\\<^sub>0 \\<mapsto>\n   (fst (the (sh_ C\\<^sub>0)), Done)))\n\ngoal (14 subgoals):\n 1. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 3. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 4. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 5. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 6. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 8. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 9. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 10. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Throwing Cs\n                             (addr_of_sys_xcpt NoClassDefFoundError)) #\n                           frs,\n                           sh)\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 3. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 4. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 5. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 6. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 8. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 9. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 10. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Throwing Cs\n                             (addr_of_sys_xcpt NoClassDefFoundError)) #\n                           frs,\n                           sh)\nA total of 14 subgoals...", "case (exec_step_ind_Pop P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Pop\n\ngoal (14 subgoals):\n 1. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI Pop \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n 2. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 3. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 4. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 5. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 6. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 7. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 8. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 9. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 10. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Throwing Cs\n                             (addr_of_sys_xcpt NoClassDefFoundError)) #\n                           frs,\n                           sh)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Pop", "show ?case"], ["proof (prove)\nusing this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Pop\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (tl stk, loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) # frs, sh)\n\ngoal (13 subgoals):\n 1. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 2. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 3. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 4. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 5. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 7. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 8. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 9. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 10. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n         sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Called (C # Cs)) #\n                           frs,\n                           sh')\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 2. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 3. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 4. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 5. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 7. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 8. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 9. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 10. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n         sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Called (C # Cs)) #\n                           frs,\n                           sh')\nA total of 13 subgoals...", "case (exec_step_ind_IAdd P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI IAdd\n\ngoal (13 subgoals):\n 1. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI IAdd \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk),\n         loc, C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 2. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 3. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 4. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 5. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 6. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 7. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 8. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 9. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 10. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n         sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Called (C # Cs)) #\n                           frs,\n                           sh')\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI IAdd", "show ?case"], ["proof (prove)\nusing this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI IAdd\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h,\n     (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk), loc,\n      C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n     frs,\n     sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h,\n   (Intg (the_Intg (hd (tl stk)) + the_Intg (hd stk)) # tl (tl stk), loc,\n    C\\<^sub>0, M\\<^sub>0, Suc pc, ics) #\n   frs,\n   sh)\n\ngoal (12 subgoals):\n 1. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 2. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 3. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 4. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 6. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 7. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 8. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 9. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 10. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n         sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n         C \\<noteq> Object; D = fst (the (class P C));\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Calling D (C # Cs)) #\n                           frs,\n                           sh')\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 2. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 3. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 4. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 6. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 7. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 8. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 9. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 10. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n         sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n         C \\<noteq> Object; D = fst (the (class P C));\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Calling D (C # Cs)) #\n                           frs,\n                           sh')\nA total of 12 subgoals...", "case (exec_step_ind_IfFalse_False stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  hd stk = Bool False\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (IfFalse i)\n\ngoal (12 subgoals):\n 1. \\<And>stk i P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk = Bool False;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepI (IfFalse i)\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (tl stk, loc, C\\<^sub>0, M\\<^sub>0,\n                           nat (int pc + i), ics) #\n                          frs,\n                          sh)\n 2. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 3. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 4. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 5. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 6. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 7. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 8. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 9. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 10. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n        \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n         sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n         C \\<noteq> Object; D = fst (the (class P C));\n         exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n        \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                           frs sh =\n                          (None, h,\n                           (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                            Calling D (C # Cs)) #\n                           frs,\n                           sh')\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  hd stk = Bool False\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (IfFalse i)", "show ?case"], ["proof (prove)\nusing this:\n  hd stk = Bool False\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (IfFalse i)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h,\n     (tl stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h,\n   (tl stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n\ngoal (11 subgoals):\n 1. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 2. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 3. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 5. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 6. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 7. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 8. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 9. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 10. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepT (C # Cs) a \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n         sh(C \\<mapsto> (fst (the (sh C)), Error)))\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 2. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 3. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 5. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 6. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 7. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 8. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 9. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 10. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepT (C # Cs) a \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n         sh(C \\<mapsto> (fst (the (sh C)), Error)))\nA total of 11 subgoals...", "case (exec_step_ind_CmpEq P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI CmpEq\n\ngoal (11 subgoals):\n 1. \\<And>P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI CmpEq \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0,\n         M\\<^sub>0, Suc pc, ics) #\n        frs,\n        sh)\n 2. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 3. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 4. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 5. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 6. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 7. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 8. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 9. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 10. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepT (C # Cs) a \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n         sh(C \\<mapsto> (fst (the (sh C)), Error)))\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI CmpEq", "show ?case"], ["proof (prove)\nusing this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI CmpEq\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h,\n     (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0,\n      Suc pc, ics) #\n     frs,\n     sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h,\n   (Bool (hd (tl stk) = hd stk) # tl (tl stk), loc, C\\<^sub>0, M\\<^sub>0,\n    Suc pc, ics) #\n   frs,\n   sh)\n\ngoal (10 subgoals):\n 1. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 2. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 4. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 5. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 6. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 7. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 8. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 9. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 10. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepT [] a \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (\\<lfloor>a\\<rfloor>, h,\n         (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 2. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 4. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 5. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 6. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 7. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 8. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 9. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 10. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepT [] a \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (\\<lfloor>a\\<rfloor>, h,\n         (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "case (exec_step_ind_Goto i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Goto i)\n\ngoal (10 subgoals):\n 1. \\<And>i P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepI (Goto i) \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs, sh)\n 2. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 3. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 4. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 5. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 6. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 7. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 8. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 9. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 10. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n        StepT [] a \\<Longrightarrow>\n        exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n        (\\<lfloor>a\\<rfloor>, h,\n         (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Goto i)", "show ?case"], ["proof (prove)\nusing this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI (Goto i)\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs,\n     sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, nat (int pc + i), ics) # frs,\n   sh)\n\ngoal (9 subgoals):\n 1. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 3. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 4. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 5. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 6. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 7. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 8. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 9. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 3. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 4. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 5. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 6. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 7. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 8. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 9. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "case (exec_step_ind_Throw stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  hd stk \\<noteq> Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\n\ngoal (9 subgoals):\n 1. \\<And>stk P h loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       \\<lbrakk>hd stk \\<noteq> Null;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs,\n                          sh)\n 2. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 3. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 4. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 5. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 6. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 7. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 8. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 9. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "then"], ["proof (chain)\npicking this:\n  hd stk \\<noteq> Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw", "show ?case"], ["proof (prove)\nusing this:\n  hd stk \\<noteq> Null\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepI Throw\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)", "by(cases ics, auto dest!: StepI)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>the_Addr (hd stk)\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, ics) # frs, sh)\n\ngoal (8 subgoals):\n 1. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 2. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 3. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 4. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 5. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 6. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 7. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 8. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 2. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 3. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 4. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 5. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 6. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 7. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 8. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "case (exec_step_ind_Init_None_Called sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs)"], ["proof (state)\nthis:\n  sh C = None\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\n\ngoal (8 subgoals):\n 1. \\<And>sh C Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = None;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling C Cs) #\n                          frs,\n                          sh(C \\<mapsto> (sblank P C, Prepared)))\n 2. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 3. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 4. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 5. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 6. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 7. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 8. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "then"], ["proof (chain)\npicking this:\n  sh C = None\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs", "show ?case"], ["proof (prove)\nusing this:\n  sh C = None\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Calling C Cs) # frs, sh\n     (C \\<mapsto> (sblank P C, Prepared)))", "by(auto dest!: StepC)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Calling C Cs) # frs, sh(C \n   \\<mapsto> (sblank P C, Prepared)))\n\ngoal (7 subgoals):\n 1. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 2. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 3. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 4. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 5. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 6. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 7. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 2. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 3. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 4. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 5. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 6. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 7. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "case (exec_step_ind_Init_Done sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\n\ngoal (7 subgoals):\n 1. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Done)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 2. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 3. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 4. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 5. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 6. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 7. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs", "show ?case"], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>(sfs, Done)\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs, sh)", "by(auto dest!: StepC)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs, sh)\n\ngoal (6 subgoals):\n 1. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 2. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 3. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 4. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 5. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 6. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 2. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 3. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 4. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 5. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 6. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "case (exec_step_ind_Init_Processing sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\n\ngoal (6 subgoals):\n 1. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Processing)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) #\n                          frs,\n                          sh)\n 2. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 3. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 4. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 5. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 6. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs", "show ?case"], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>(sfs, Processing)\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs, sh)", "by(auto dest!: StepC)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called Cs) # frs, sh)\n\ngoal (5 subgoals):\n 1. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 2. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 3. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 4. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 5. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 2. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 3. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 4. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 5. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "case (exec_step_ind_Init_Error sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(sfs, Error)\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\n\ngoal (5 subgoals):\n 1. \\<And>sh C sfs Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Error)\\<rfloor>;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Throwing Cs\n                            (addr_of_sys_xcpt NoClassDefFoundError)) #\n                          frs,\n                          sh)\n 2. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 3. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 4. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 5. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>(sfs, Error)\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs", "show ?case"], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>(sfs, Error)\\<rfloor>\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n      Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n     frs,\n     sh)", "by(auto dest!: StepC)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n    Throwing Cs (addr_of_sys_xcpt NoClassDefFoundError)) #\n   frs,\n   sh)\n\ngoal (4 subgoals):\n 1. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 2. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 3. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 4. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 2. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 3. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 4. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "case (exec_step_ind_Init_Prepared_Object sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing))\n  C = Object\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\n\ngoal (4 subgoals):\n 1. \\<And>sh C sfs sh' Cs P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing)); C = Object;\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Called (C # Cs)) #\n                          frs,\n                          sh')\n 2. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 3. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 4. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing))\n  C = Object\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs", "show ?case"], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing))\n  C = Object\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called (C # Cs)) # frs,\n     sh')", "by(auto dest!: StepC)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Called (C # Cs)) # frs,\n   sh')\n\ngoal (3 subgoals):\n 1. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 2. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 3. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 2. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 3. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "case (exec_step_ind_Init_Prepared_nObject sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs)"], ["proof (state)\nthis:\n  sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing))\n  C \\<noteq> Object\n  D = fst (the (class P C))\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\n\ngoal (3 subgoals):\n 1. \\<And>sh C sfs sh' D P Cs h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs.\n       \\<lbrakk>sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>;\n        sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing));\n        C \\<noteq> Object; D = fst (the (class P C));\n        exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\\<rbrakk>\n       \\<Longrightarrow> exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics\n                          frs sh =\n                         (None, h,\n                          (stk, loc, C\\<^sub>0, M\\<^sub>0, pc,\n                           Calling D (C # Cs)) #\n                          frs,\n                          sh')\n 2. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 3. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "then"], ["proof (chain)\npicking this:\n  sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing))\n  C \\<noteq> Object\n  D = fst (the (class P C))\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs", "show ?case"], ["proof (prove)\nusing this:\n  sh C = \\<lfloor>(sfs, Prepared)\\<rfloor>\n  sh' = sh(C \\<mapsto> (fst (the (sh C)), Processing))\n  C \\<noteq> Object\n  D = fst (the (class P C))\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepC C Cs\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Calling D (C # Cs)) # frs, sh')", "by(auto dest!: StepC)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Calling D (C # Cs)) # frs,\n   sh')\n\ngoal (2 subgoals):\n 1. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 2. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 2. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "case (exec_step_ind_InitThrow C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepT (C # Cs) a\n\ngoal (2 subgoals):\n 1. \\<And>C Cs a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT (C # Cs) a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs,\n        sh(C \\<mapsto> (fst (the (sh C)), Error)))\n 2. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepT (C # Cs) a", "show ?case"], ["proof (prove)\nusing this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepT (C # Cs) a\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs, sh\n     (C \\<mapsto> (fst (the (sh C)), Error)))", "by(auto dest!: StepT)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (None, h, (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, Throwing Cs a) # frs, sh(C \n   \\<mapsto> (fst (the (sh C)), Error)))\n\ngoal (1 subgoal):\n 1. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "case (exec_step_ind_InitThrow_End a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh)"], ["proof (state)\nthis:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepT [] a\n\ngoal (1 subgoal):\n 1. \\<And>a P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh.\n       exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics =\n       StepT [] a \\<Longrightarrow>\n       exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n       (\\<lfloor>a\\<rfloor>, h,\n        (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "then"], ["proof (chain)\npicking this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepT [] a", "show ?case"], ["proof (prove)\nusing this:\n  exec_step_input P C\\<^sub>0 M\\<^sub>0 pc ics = StepT [] a\n\ngoal (1 subgoal):\n 1. exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n    (\\<lfloor>a\\<rfloor>, h,\n     (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)", "by(auto dest!: StepT)"], ["proof (state)\nthis:\n  exec_step P h stk loc C\\<^sub>0 M\\<^sub>0 pc ics frs sh =\n  (\\<lfloor>a\\<rfloor>, h,\n   (stk, loc, C\\<^sub>0, M\\<^sub>0, pc, No_ics) # frs, sh)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> @{term exec_step} and @{term exec_step_ind} reach the same result given equivalent input \\<close>"], ["", "lemma exec_step_ind_equiv:\n \"exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')\n   = exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs sh (xp', h', frs', sh')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')) =\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "using exec_step_imp_exec_step_ind exec_step_ind_imp_exec_step"], ["proof (prove)\nusing this:\n  exec_step ?P ?h ?stk ?loc ?C ?M ?pc ?ics ?frs ?sh =\n  (?xp', ?h', ?frs', ?sh') \\<Longrightarrow>\n  exec_step_ind (exec_step_input ?P ?C ?M ?pc ?ics) ?P ?h ?stk ?loc ?C ?M\n   ?pc ?ics ?frs ?sh (?xp', ?h', ?frs', ?sh')\n  \\<lbrakk>exec_step_ind ?si ?P ?h ?stk ?loc ?C ?M ?pc ?ics ?frs ?sh\n            (?xp', ?h', ?frs', ?sh');\n   exec_step_input ?P ?C ?M ?pc ?ics = ?si\\<rbrakk>\n  \\<Longrightarrow> exec_step ?P ?h ?stk ?loc ?C ?M ?pc ?ics ?frs ?sh =\n                    (?xp', ?h', ?frs', ?sh')\n\ngoal (1 subgoal):\n 1. (exec_step P h stk loc C M pc ics frs sh = (xp', h', frs', sh')) =\n    exec_step_ind (exec_step_input P C M pc ics) P h stk loc C M pc ics frs\n     sh (xp', h', frs', sh')", "by auto"], ["", "end"]]}