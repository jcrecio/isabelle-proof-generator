{"file_name": "/home/qj213/afp-2021-10-22/thys/Native_Word/More_Bits_Int.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Native_Word", "problem_names": ["lemma last_rev' [simp]: \"last (rev xs) = hd xs\" \\<comment> \\<open>TODO define \\<open>last []\\<close> as \\<open>hd []\\<close>?\\<close>", "lemma nat_LEAST_True: \"(LEAST _ :: nat. True) = 0\"", "lemma int_of_integer_symbolic_aux_code [code nbe]:\n  \"int_of_integer_symbolic 0 = 0\"\n  \"int_of_integer_symbolic (Code_Numeral.Pos n) = Int.Pos n\"\n  \"int_of_integer_symbolic (Code_Numeral.Neg n) = Int.Neg n\"", "lemma int_numeral_bitOR_num: \"numeral n OR numeral m = (numeral (bitOR_num n m) :: int)\"", "lemma int_numeral_bitAND_num: \"numeral n AND numeral m = (case bitAND_num n m of None \\<Rightarrow> 0 :: int | Some n' \\<Rightarrow> numeral n')\"", "lemma int_numeral_bitXOR_num:\n  \"numeral m XOR numeral n = (case bitXOR_num m n of None \\<Rightarrow> 0 :: int | Some n' \\<Rightarrow> numeral n')\"", "lemma int_or_not_bitORN_num:\n  \"numeral n OR NOT (numeral m) = (- numeral (bitORN_num n m) :: int)\"", "lemma int_and_not_bitANDN_num:\n  \"numeral n AND NOT (numeral m) = (case bitANDN_num n m of None \\<Rightarrow> 0 :: int | Some n' \\<Rightarrow> numeral n')\"", "lemma int_not_and_bitANDN_num:\n  \"NOT (numeral m) AND numeral n = (case bitANDN_num n m of None \\<Rightarrow> 0 :: int | Some n' \\<Rightarrow> numeral n')\""], "translations": [["", "lemma last_rev' [simp]: \"last (rev xs) = hd xs\" \\<comment> \\<open>TODO define \\<open>last []\\<close> as \\<open>hd []\\<close>?\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (rev xs) = hd xs", "by (cases xs) (simp add: last_def hd_def, simp)"], ["", "lemma nat_LEAST_True: \"(LEAST _ :: nat. True) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST _. True) = 0", "by (rule Least_equality) simp_all"], ["", "text \\<open>\n  Use this function to convert numeral @{typ integer}s quickly into @{typ int}s.\n  By default, it works only for symbolic evaluation; normally generated code raises\n  an exception at run-time. If theory \\<open>Code_Target_Bits_Int\\<close> is imported,\n  it works again, because then @{typ int} is implemented in terms of @{typ integer}\n  even for symbolic evaluation.\n\\<close>"], ["", "definition int_of_integer_symbolic :: \"integer \\<Rightarrow> int\"\n  where \"int_of_integer_symbolic = int_of_integer\""], ["", "lemma int_of_integer_symbolic_aux_code [code nbe]:\n  \"int_of_integer_symbolic 0 = 0\"\n  \"int_of_integer_symbolic (Code_Numeral.Pos n) = Int.Pos n\"\n  \"int_of_integer_symbolic (Code_Numeral.Neg n) = Int.Neg n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_integer_symbolic 0 = 0 &&&\n    int_of_integer_symbolic (Code_Numeral.Pos n) = Int.Pos n &&&\n    int_of_integer_symbolic (Code_Numeral.Neg n) = Int.Neg n", "by (simp_all add: int_of_integer_symbolic_def)"], ["", "section \\<open>Symbolic bit operations on numerals and @{typ int}s\\<close>"], ["", "fun bitOR_num :: \"num \\<Rightarrow> num \\<Rightarrow> num\"\nwhere\n  \"bitOR_num num.One num.One = num.One\"\n| \"bitOR_num num.One (num.Bit0 n) = num.Bit1 n\"\n| \"bitOR_num num.One (num.Bit1 n) = num.Bit1 n\"\n| \"bitOR_num (num.Bit0 m) num.One = num.Bit1 m\"\n| \"bitOR_num (num.Bit0 m) (num.Bit0 n) = num.Bit0 (bitOR_num m n)\"\n| \"bitOR_num (num.Bit0 m) (num.Bit1 n) = num.Bit1 (bitOR_num m n)\"\n| \"bitOR_num (num.Bit1 m) num.One = num.Bit1 m\"\n| \"bitOR_num (num.Bit1 m) (num.Bit0 n) = num.Bit1 (bitOR_num m n)\"\n| \"bitOR_num (num.Bit1 m) (num.Bit1 n) = num.Bit1 (bitOR_num m n)\""], ["", "fun bitAND_num :: \"num \\<Rightarrow> num \\<Rightarrow> num option\"\nwhere\n  \"bitAND_num num.One num.One = Some num.One\"\n| \"bitAND_num num.One (num.Bit0 n) = None\"\n| \"bitAND_num num.One (num.Bit1 n) = Some num.One\"\n| \"bitAND_num (num.Bit0 m) num.One = None\"\n| \"bitAND_num (num.Bit0 m) (num.Bit0 n) = map_option num.Bit0 (bitAND_num m n)\"\n| \"bitAND_num (num.Bit0 m) (num.Bit1 n) = map_option num.Bit0 (bitAND_num m n)\"\n| \"bitAND_num (num.Bit1 m) num.One = Some num.One\"\n| \"bitAND_num (num.Bit1 m) (num.Bit0 n) = map_option num.Bit0 (bitAND_num m n)\"\n| \"bitAND_num (num.Bit1 m) (num.Bit1 n) = (case bitAND_num m n of None \\<Rightarrow> Some num.One | Some n' \\<Rightarrow> Some (num.Bit1 n'))\""], ["", "fun bitXOR_num :: \"num \\<Rightarrow> num \\<Rightarrow> num option\"\nwhere\n  \"bitXOR_num num.One num.One = None\"\n| \"bitXOR_num num.One (num.Bit0 n) = Some (num.Bit1 n)\"\n| \"bitXOR_num num.One (num.Bit1 n) = Some (num.Bit0 n)\"\n| \"bitXOR_num (num.Bit0 m) num.One = Some (num.Bit1 m)\"\n| \"bitXOR_num (num.Bit0 m) (num.Bit0 n) = map_option num.Bit0 (bitXOR_num m n)\"\n| \"bitXOR_num (num.Bit0 m) (num.Bit1 n) = Some (case bitXOR_num m n of None \\<Rightarrow> num.One | Some n' \\<Rightarrow> num.Bit1 n')\"\n| \"bitXOR_num (num.Bit1 m) num.One = Some (num.Bit0 m)\"\n| \"bitXOR_num (num.Bit1 m) (num.Bit0 n) = Some (case bitXOR_num m n of None \\<Rightarrow> num.One | Some n' \\<Rightarrow> num.Bit1 n')\"\n| \"bitXOR_num (num.Bit1 m) (num.Bit1 n) = map_option num.Bit0 (bitXOR_num m n)\""], ["", "fun bitORN_num :: \"num \\<Rightarrow> num \\<Rightarrow> num\"\nwhere\n  \"bitORN_num num.One num.One = num.One\"\n| \"bitORN_num num.One (num.Bit0 m) = num.Bit1 m\"\n| \"bitORN_num num.One (num.Bit1 m) = num.Bit1 m\"\n| \"bitORN_num (num.Bit0 n) num.One = num.Bit0 num.One\"\n| \"bitORN_num (num.Bit0 n) (num.Bit0 m) = Num.BitM (bitORN_num n m)\"\n| \"bitORN_num (num.Bit0 n) (num.Bit1 m) = num.Bit0 (bitORN_num n m)\"\n| \"bitORN_num (num.Bit1 n) num.One = num.One\"\n| \"bitORN_num (num.Bit1 n) (num.Bit0 m) = Num.BitM (bitORN_num n m)\"\n| \"bitORN_num (num.Bit1 n) (num.Bit1 m) = Num.BitM (bitORN_num n m)\""], ["", "fun bitANDN_num :: \"num \\<Rightarrow> num \\<Rightarrow> num option\"\nwhere\n  \"bitANDN_num num.One num.One = None\"\n| \"bitANDN_num num.One (num.Bit0 n) = Some num.One\"\n| \"bitANDN_num num.One (num.Bit1 n) = None\"\n| \"bitANDN_num (num.Bit0 m) num.One = Some (num.Bit0 m)\"\n| \"bitANDN_num (num.Bit0 m) (num.Bit0 n) = map_option num.Bit0 (bitANDN_num m n)\"\n| \"bitANDN_num (num.Bit0 m) (num.Bit1 n) = map_option num.Bit0 (bitANDN_num m n)\"\n| \"bitANDN_num (num.Bit1 m) num.One = Some (num.Bit0 m)\"\n| \"bitANDN_num (num.Bit1 m) (num.Bit0 n) = (case bitANDN_num m n of None \\<Rightarrow> Some num.One | Some n' \\<Rightarrow> Some (num.Bit1 n'))\"\n| \"bitANDN_num (num.Bit1 m) (num.Bit1 n) = map_option num.Bit0 (bitANDN_num m n)\""], ["", "lemma int_numeral_bitOR_num: \"numeral n OR numeral m = (numeral (bitOR_num n m) :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n OR numeral m = numeral (bitOR_num n m)", "by(induct n m rule: bitOR_num.induct) simp_all"], ["", "lemma int_numeral_bitAND_num: \"numeral n AND numeral m = (case bitAND_num n m of None \\<Rightarrow> 0 :: int | Some n' \\<Rightarrow> numeral n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n AND numeral m =\n    (case bitAND_num n m of None \\<Rightarrow> 0\n     | Some n' \\<Rightarrow> numeral n')", "by(induct n m rule: bitAND_num.induct)(simp_all split: option.split)"], ["", "lemma int_numeral_bitXOR_num:\n  \"numeral m XOR numeral n = (case bitXOR_num m n of None \\<Rightarrow> 0 :: int | Some n' \\<Rightarrow> numeral n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral m XOR numeral n =\n    (case bitXOR_num m n of None \\<Rightarrow> 0\n     | Some n' \\<Rightarrow> numeral n')", "by(induct m n rule: bitXOR_num.induct)(simp_all split: option.split)"], ["", "lemma int_or_not_bitORN_num:\n  \"numeral n OR NOT (numeral m) = (- numeral (bitORN_num n m) :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n OR NOT (numeral m) = - numeral (bitORN_num n m)", "by (induction n m rule: bitORN_num.induct) (simp_all add: add_One BitM_inc_eq)"], ["", "lemma int_and_not_bitANDN_num:\n  \"numeral n AND NOT (numeral m) = (case bitANDN_num n m of None \\<Rightarrow> 0 :: int | Some n' \\<Rightarrow> numeral n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n AND NOT (numeral m) =\n    (case bitANDN_num n m of None \\<Rightarrow> 0\n     | Some n' \\<Rightarrow> numeral n')", "by (induction n m rule: bitANDN_num.induct) (simp_all add: add_One BitM_inc_eq split: option.split)"], ["", "lemma int_not_and_bitANDN_num:\n  \"NOT (numeral m) AND numeral n = (case bitANDN_num n m of None \\<Rightarrow> 0 :: int | Some n' \\<Rightarrow> numeral n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT (numeral m) AND numeral n =\n    (case bitANDN_num n m of None \\<Rightarrow> 0\n     | Some n' \\<Rightarrow> numeral n')", "by(simp add: int_and_not_bitANDN_num[symmetric] int_and_comm)"], ["", "code_identifier\n  code_module More_Bits_Int \\<rightharpoonup>\n  (SML) Bit_Operations and (OCaml) Bit_Operations and (Haskell) Bit_Operations and (Scala) Bit_Operations"], ["", "end"]]}