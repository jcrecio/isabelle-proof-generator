{"file_name": "/home/qj213/afp-2021-10-22/thys/Native_Word/Bits_Integer.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Native_Word", "problem_names": ["lemmas [transfer_rule] =\n  identity_quotient\n  fun_quotient\n  Quotient_integer[folded integer.pcr_cr_eq]", "lemma undefined_transfer:\n  assumes \"Quotient R Abs Rep T\"\n  shows \"T (Rep undefined) undefined\"", "lemma bitval_integer_transfer [transfer_rule]:\n  \"(rel_fun (=) pcr_integer) of_bool of_bool\"", "lemma integer_of_nat_less_0_conv [simp]: \"\\<not> integer_of_nat n < 0\"", "lemma int_of_integer_pow: \"int_of_integer (x ^ n) = int_of_integer x ^ n\"", "lemma pow_integer_transfer [transfer_rule]:\n  \"(rel_fun pcr_integer (rel_fun (=) pcr_integer)) (^) (^)\"", "lemma sub1_lt_0_iff [simp]: \"Code_Numeral.sub n num.One < 0 \\<longleftrightarrow> False\"", "lemma nat_of_integer_numeral [simp]: \"nat_of_integer (numeral n) = numeral n\"", "lemma nat_of_integer_sub1_conv_pred_numeral [simp]:\n  \"nat_of_integer (Code_Numeral.sub n num.One) = pred_numeral n\"", "lemma nat_of_integer_1 [simp]: \"nat_of_integer 1 = 1\"", "lemma dup_1 [simp]: \"Code_Numeral.dup 1 = 2\"", "lemma test_bit_integer_transfer [transfer_rule]:\n  \\<open>(pcr_integer ===> (=)) bit (!!)\\<close>", "lemma shiftl_integer_transfer [transfer_rule]:\n  \\<open>(pcr_integer ===> (=) ===> pcr_integer) (\\<lambda>k n. push_bit n k) (<<)\\<close>", "lemma shiftr_integer_transfer [transfer_rule]:\n  \\<open>(pcr_integer ===> (=) ===> pcr_integer) (\\<lambda>k n. drop_bit n k) (>>)\\<close>", "lemma bitNOT_integer_code [code]:\n  fixes i :: integer shows\n  \"NOT i = - i - 1\"", "lemma bin_rest_integer_code [code nbe]:\n  \"bin_rest_integer i = i div 2\"", "lemma bin_last_integer_code [code]:\n  \"bin_last_integer i \\<longleftrightarrow> i AND 1 \\<noteq> 0\"", "lemma bin_last_integer_nbe [code nbe]:\n  \"bin_last_integer i \\<longleftrightarrow> i mod 2 \\<noteq> 0\"", "lemma bitval_bin_last_integer [code_unfold]:\n  \"of_bool (bin_last_integer i) = i AND 1\"", "lemma bit_integer_code [code]:\n  \"bit x n \\<longleftrightarrow> integer_test_bit x (integer_of_nat n)\"", "lemma integer_test_bit_code [code]:\n  \"integer_test_bit x (Code_Numeral.Neg n) = undefined x (Code_Numeral.Neg n)\"\n  \"integer_test_bit 0 0 = False\"\n  \"integer_test_bit 0 (Code_Numeral.Pos n) = False\"\n  \"integer_test_bit (Code_Numeral.Pos num.One)      0 = True\"\n  \"integer_test_bit (Code_Numeral.Pos (num.Bit0 n)) 0 = False\"\n  \"integer_test_bit (Code_Numeral.Pos (num.Bit1 n)) 0 = True\"\n  \"integer_test_bit (Code_Numeral.Pos num.One)      (Code_Numeral.Pos n') = False\"\n  \"integer_test_bit (Code_Numeral.Pos (num.Bit0 n)) (Code_Numeral.Pos n') =\n   integer_test_bit (Code_Numeral.Pos n) (Code_Numeral.sub n' num.One)\"\n  \"integer_test_bit (Code_Numeral.Pos (num.Bit1 n)) (Code_Numeral.Pos n') =\n   integer_test_bit (Code_Numeral.Pos n) (Code_Numeral.sub n' num.One)\"\n  \"integer_test_bit (Code_Numeral.Neg num.One)      0 = True\"\n  \"integer_test_bit (Code_Numeral.Neg (num.Bit0 n)) 0 = False\"\n  \"integer_test_bit (Code_Numeral.Neg (num.Bit1 n)) 0 = True\"\n  \"integer_test_bit (Code_Numeral.Neg num.One)      (Code_Numeral.Pos n') = True\"\n  \"integer_test_bit (Code_Numeral.Neg (num.Bit0 n)) (Code_Numeral.Pos n') =\n   integer_test_bit (Code_Numeral.Neg n) (Code_Numeral.sub n' num.One)\"\n  \"integer_test_bit (Code_Numeral.Neg (num.Bit1 n)) (Code_Numeral.Pos n') =\n   integer_test_bit (Code_Numeral.Neg (n + num.One)) (Code_Numeral.sub n' num.One)\"", "lemma lsb_integer_code [code]:\n  fixes x :: integer shows\n  \"lsb x = bit x 0\"", "lemma set_bit_integer_code [code]:\n  \"set_bit x i b = integer_set_bit x (integer_of_nat i) b\"", "lemma set_bit_integer_conv_masks:\n  fixes x :: integer shows\n  \"set_bit x i b = (if b then x OR (1 << i) else x AND NOT (1 << i))\"", "lemma integer_set_bit_code [code]:\n  \"integer_set_bit x n b =\n  (if n < 0 then undefined x n b else\n   if b then x OR (push_bit (nat_of_integer n) 1)\n   else x AND NOT (push_bit (nat_of_integer n) 1))\"", "lemma shiftl_integer_code [code]:\n  fixes x :: integer shows\n  \"push_bit n x = integer_shiftl x (integer_of_nat n)\"", "lemma shiftl_integer_conv_mult_pow2:\n  fixes x :: integer shows\n  \"x << n = x * 2 ^ n\"", "lemma integer_shiftl_code [code]:\n  \"integer_shiftl x (Code_Numeral.Neg n) = undefined x (Code_Numeral.Neg n)\"\n  \"integer_shiftl x 0 = x\"\n  \"integer_shiftl x (Code_Numeral.Pos n) = integer_shiftl (Code_Numeral.dup x) (Code_Numeral.sub n num.One)\"\n  \"integer_shiftl 0 (Code_Numeral.Pos n) = 0\"", "lemma shiftr_integer_conv_div_pow2:\n  includes integer.lifting fixes x :: integer shows\n  \"x >> n = x div 2 ^ n\"", "lemma shiftr_integer_code [code]:\n  fixes x :: integer shows\n  \"drop_bit n x = integer_shiftr x (integer_of_nat n)\"", "lemma integer_shiftr_code [code]:\n  includes integer.lifting\n  shows\n  \"integer_shiftr x (Code_Numeral.Neg n) = undefined x (Code_Numeral.Neg n)\"\n  \"integer_shiftr x 0 = x\"\n  \"integer_shiftr 0 (Code_Numeral.Pos n) = 0\"\n  \"integer_shiftr (Code_Numeral.Pos num.One) (Code_Numeral.Pos n) = 0\"\n  \"integer_shiftr (Code_Numeral.Pos (num.Bit0 n')) (Code_Numeral.Pos n) =\n   integer_shiftr (Code_Numeral.Pos n') (Code_Numeral.sub n num.One)\"\n  \"integer_shiftr (Code_Numeral.Pos (num.Bit1 n')) (Code_Numeral.Pos n) =\n   integer_shiftr (Code_Numeral.Pos n') (Code_Numeral.sub n num.One)\"\n  \"integer_shiftr (Code_Numeral.Neg num.One) (Code_Numeral.Pos n) = -1\"\n  \"integer_shiftr (Code_Numeral.Neg (num.Bit0 n')) (Code_Numeral.Pos n) =\n   integer_shiftr (Code_Numeral.Neg n') (Code_Numeral.sub n num.One)\"\n  \"integer_shiftr (Code_Numeral.Neg (num.Bit1 n')) (Code_Numeral.Pos n) =\n   integer_shiftr (Code_Numeral.Neg (Num.inc n')) (Code_Numeral.sub n num.One)\"", "lemma Bit_integer_code [code]:\n  \"Bit_integer i False = push_bit 1 i\"\n  \"Bit_integer i True = (push_bit 1 i) + 1\"", "lemma msb_integer_code [code]:\n  \"msb (x :: integer) \\<longleftrightarrow> x < 0\"", "lemma bitAND_integer_unfold [code]:\n  \"x AND y =\n   (if x = 0 then 0\n    else if x = - 1 then y\n    else Bit_integer (bin_rest_integer x AND bin_rest_integer y) (bin_last_integer x \\<and> bin_last_integer y))\"", "lemma bitOR_integer_unfold [code]:\n  \"x OR y =\n   (if x = 0 then y\n    else if x = - 1 then - 1\n    else Bit_integer (bin_rest_integer x OR bin_rest_integer y) (bin_last_integer x \\<or> bin_last_integer y))\"", "lemma bitXOR_integer_unfold [code]:\n  \"x XOR y =\n   (if x = 0 then y\n    else if x = - 1 then NOT y\n    else Bit_integer (bin_rest_integer x XOR bin_rest_integer y)\n      (\\<not> bin_last_integer x \\<longleftrightarrow> bin_last_integer y))\"", "lemma \"x AND y = x OR (y :: integer)\"", "lemma \"(x :: integer) AND x = x OR x\"", "lemma \"(f :: integer \\<Rightarrow> unit) = g\""], "translations": [["", "lemmas [transfer_rule] =\n  identity_quotient\n  fun_quotient\n  Quotient_integer[folded integer.pcr_cr_eq]"], ["", "lemma undefined_transfer:\n  assumes \"Quotient R Abs Rep T\"\n  shows \"T (Rep undefined) undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T (Rep undefined) undefined", "using assms"], ["proof (prove)\nusing this:\n  Quotient R Abs Rep T\n\ngoal (1 subgoal):\n 1. T (Rep undefined) undefined", "unfolding Quotient_alt_def"], ["proof (prove)\nusing this:\n  (\\<forall>a b. T a b \\<longrightarrow> Abs a = b) \\<and>\n  (\\<forall>b. T (Rep b) b) \\<and>\n  (\\<forall>x y.\n      R x y = (T x (Abs x) \\<and> T y (Abs y) \\<and> Abs x = Abs y))\n\ngoal (1 subgoal):\n 1. T (Rep undefined) undefined", "by blast"], ["", "bundle undefined_transfer = undefined_transfer[transfer_rule]"], ["", "section \\<open>More lemmas about @{typ integer}s\\<close>"], ["", "context\nincludes integer.lifting\nbegin"], ["", "lemma bitval_integer_transfer [transfer_rule]:\n  \"(rel_fun (=) pcr_integer) of_bool of_bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=) pcr_integer of_bool of_bool", "by(auto simp add: of_bool_def integer.pcr_cr_eq cr_integer_def)"], ["", "lemma integer_of_nat_less_0_conv [simp]: \"\\<not> integer_of_nat n < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> integer_of_nat n < 0", "by(transfer) simp"], ["", "lemma int_of_integer_pow: \"int_of_integer (x ^ n) = int_of_integer x ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_of_integer (x ^ n) = int_of_integer x ^ n", "by(induct n) simp_all"], ["", "lemma pow_integer_transfer [transfer_rule]:\n  \"(rel_fun pcr_integer (rel_fun (=) pcr_integer)) (^) (^)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun pcr_integer (rel_fun (=) pcr_integer) (^) (^)", "by(auto 4 3 simp add: integer.pcr_cr_eq cr_integer_def int_of_integer_pow)"], ["", "lemma sub1_lt_0_iff [simp]: \"Code_Numeral.sub n num.One < 0 \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Code_Numeral.sub n num.One < 0) = False", "by(cases n)(simp_all add: Code_Numeral.sub_code)"], ["", "lemma nat_of_integer_numeral [simp]: \"nat_of_integer (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_integer (numeral n) = numeral n", "by transfer simp"], ["", "lemma nat_of_integer_sub1_conv_pred_numeral [simp]:\n  \"nat_of_integer (Code_Numeral.sub n num.One) = pred_numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_integer (Code_Numeral.sub n num.One) = pred_numeral n", "by(cases n)(simp_all add: Code_Numeral.sub_code)"], ["", "lemma nat_of_integer_1 [simp]: \"nat_of_integer 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_integer 1 = 1", "by transfer simp"], ["", "lemma dup_1 [simp]: \"Code_Numeral.dup 1 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Code_Numeral.dup 1 = 2", "by transfer simp"], ["", "section \\<open>Bit operations on @{typ integer}\\<close>"], ["", "text \\<open>Bit operations on @{typ integer} are the same as on @{typ int}\\<close>"], ["", "lift_definition bin_rest_integer :: \"integer \\<Rightarrow> integer\" is bin_rest"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition bin_last_integer :: \"integer \\<Rightarrow> bool\" is bin_last"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition Bit_integer :: \"integer \\<Rightarrow> bool \\<Rightarrow> integer\" is \\<open>\\<lambda>k b. of_bool b + 2 * k\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "instance integer :: semiring_bit_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(integer, semiring_bit_syntax_class)", ".."], ["", "context\n  includes lifting_syntax integer.lifting\nbegin"], ["", "lemma test_bit_integer_transfer [transfer_rule]:\n  \\<open>(pcr_integer ===> (=)) bit (!!)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_integer ===> (=)) bit (!!)", "unfolding test_bit_eq_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_integer ===> (=)) bit bit", "by transfer_prover"], ["", "lemma shiftl_integer_transfer [transfer_rule]:\n  \\<open>(pcr_integer ===> (=) ===> pcr_integer) (\\<lambda>k n. push_bit n k) (<<)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_integer ===> (=) ===> pcr_integer) (\\<lambda>k n. push_bit n k)\n     (<<)", "unfolding shiftl_eq_push_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_integer ===> (=) ===> pcr_integer) (\\<lambda>k n. push_bit n k)\n     (\\<lambda>a n. push_bit n a)", "by transfer_prover"], ["", "lemma shiftr_integer_transfer [transfer_rule]:\n  \\<open>(pcr_integer ===> (=) ===> pcr_integer) (\\<lambda>k n. drop_bit n k) (>>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_integer ===> (=) ===> pcr_integer) (\\<lambda>k n. drop_bit n k)\n     (>>)", "unfolding shiftr_eq_drop_bit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_integer ===> (=) ===> pcr_integer) (\\<lambda>k n. drop_bit n k)\n     (\\<lambda>a n. drop_bit n a)", "by transfer_prover"], ["", "end"], ["", "instantiation integer :: lsb begin"], ["", "context includes integer.lifting begin"], ["", "lift_definition lsb_integer :: \"integer \\<Rightarrow> bool\" is lsb"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(integer, lsb_class)", "by (standard; transfer) (fact lsb_odd)"], ["", "end"], ["", "end"], ["", "instantiation integer :: msb begin"], ["", "context includes integer.lifting begin"], ["", "lift_definition msb_integer :: \"integer \\<Rightarrow> bool\" is msb"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(integer, msb_class)", ".."], ["", "end"], ["", "end"], ["", "instantiation integer :: set_bit begin"], ["", "context includes integer.lifting begin"], ["", "lift_definition set_bit_integer :: \"integer \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> integer\" is set_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(integer, set_bit_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m b n.\n       bit (set_bit_class.set_bit a m b) n =\n       ((if m = n then b else bit a n) \\<and> 2 ^ n \\<noteq> 0)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a m b n.\n       bit (set_bit_class.set_bit a m b) n =\n       ((if m = n then b else bit a n) \\<and> 2 ^ n \\<noteq> 0)", "apply (simp add: bit_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"], ["", "abbreviation (input) wf_set_bits_integer\nwhere \"wf_set_bits_integer \\<equiv> wf_set_bits_int\""], ["", "section \\<open>Target language implementations\\<close>"], ["", "text \\<open>\n  Unfortunately, this is not straightforward,\n  because these API functions have different signatures and preconditions on the parameters:\n\n  \\begin{description}\n  \\item[Standard ML] Shifts in IntInf are given as word, but not IntInf.\n  \\item[Haskell] In the Data.Bits.Bits type class, shifts and bit indices are given as Int rather than Integer.\n  \\end{description}\n\n  Additional constants take only parameters of type @{typ integer} rather than @{typ nat}\n  and check the preconditions as far as possible (e.g., being non-negative) in a portable way.\n  Manual implementations inside code\\_printing perform the remaining range checks and convert\n  these @{typ integer}s into the right type.\n\n  For normalisation by evaluation, we derive custom code equations, because NBE\n  does not know these code\\_printing serialisations and would otherwise loop.\n\\<close>"], ["", "code_identifier code_module Bits_Integer \\<rightharpoonup>\n  (SML) Bits_Int and (OCaml) Bits_Int and (Haskell) Bits_Int and (Scala) Bits_Int"], ["", "code_printing code_module Bits_Integer \\<rightharpoonup> (SML)\n\\<open>structure Bits_Integer : sig\n  val set_bit : IntInf.int -> IntInf.int -> bool -> IntInf.int\n  val shiftl : IntInf.int -> IntInf.int -> IntInf.int\n  val shiftr : IntInf.int -> IntInf.int -> IntInf.int\n  val test_bit : IntInf.int -> IntInf.int -> bool\nend = struct\n\nval maxWord = IntInf.pow (2, Word.wordSize);\n\nfun set_bit x n b =\n  if n < maxWord then\n    if b then IntInf.orb (x, IntInf.<< (1, Word.fromLargeInt (IntInf.toLarge n)))\n    else IntInf.andb (x, IntInf.notb (IntInf.<< (1, Word.fromLargeInt (IntInf.toLarge n))))\n  else raise (Fail (\"Bit index too large: \" ^ IntInf.toString n));\n\nfun shiftl x n =\n  if n < maxWord then IntInf.<< (x, Word.fromLargeInt (IntInf.toLarge n))\n  else raise (Fail (\"Shift operand too large: \" ^ IntInf.toString n));\n\nfun shiftr x n =\n  if n < maxWord then IntInf.~>> (x, Word.fromLargeInt (IntInf.toLarge n))\n  else raise (Fail (\"Shift operand too large: \" ^ IntInf.toString n));\n\nfun test_bit x n =\n  if n < maxWord then IntInf.andb (x, IntInf.<< (1, Word.fromLargeInt (IntInf.toLarge n))) <> 0\n  else raise (Fail (\"Bit index too large: \" ^ IntInf.toString n));\n\nend; (*struct Bits_Integer*)\\<close>"], ["", "code_reserved SML Bits_Integer"], ["", "code_printing code_module Bits_Integer \\<rightharpoonup> (OCaml)\n\\<open>module Bits_Integer : sig\n  val shiftl : Z.t -> Z.t -> Z.t\n  val shiftr : Z.t -> Z.t -> Z.t\n  val test_bit : Z.t -> Z.t -> bool\nend = struct\n\n(* We do not need an explicit range checks here,\n   because Big_int.int_of_big_int raises Failure\n   if the argument does not fit into an int. *)\nlet shiftl x n = Z.shift_left x (Z.to_int n);;\n\nlet shiftr x n = Z.shift_right x (Z.to_int n);;\n\nlet test_bit x n =  Z.testbit x (Z.to_int n);;\n\nend;; (*struct Bits_Integer*)\\<close>"], ["", "code_reserved OCaml Bits_Integer"], ["", "code_printing code_module Data_Bits \\<rightharpoonup> (Haskell)\n\\<open>\nmodule Data_Bits where {\n\nimport qualified Data.Bits;\n\n{-\n  The ...Bounded functions assume that the Integer argument for the shift\n  or bit index fits into an Int, is non-negative and (for types of fixed bit width)\n  less than bitSize\n-}\n\ninfixl 7 .&.;\ninfixl 6 `xor`;\ninfixl 5 .|.;\n\n(.&.) :: Data.Bits.Bits a => a -> a -> a;\n(.&.) = (Data.Bits..&.);\n\nxor :: Data.Bits.Bits a => a -> a -> a;\nxor = Data.Bits.xor;\n\n(.|.) :: Data.Bits.Bits a => a -> a -> a;\n(.|.) = (Data.Bits..|.);\n\ncomplement :: Data.Bits.Bits a => a -> a;\ncomplement = Data.Bits.complement;\n\ntestBitUnbounded :: Data.Bits.Bits a => a -> Integer -> Bool;\ntestBitUnbounded x b\n  | b <= toInteger (Prelude.maxBound :: Int) = Data.Bits.testBit x (fromInteger b)\n  | otherwise = error (\"Bit index too large: \" ++ show b)\n;\n\ntestBitBounded :: Data.Bits.Bits a => a -> Integer -> Bool;\ntestBitBounded x b = Data.Bits.testBit x (fromInteger b);\n\nsetBitUnbounded :: Data.Bits.Bits a => a -> Integer -> Bool -> a;\nsetBitUnbounded x n b\n  | n <= toInteger (Prelude.maxBound :: Int) =\n    if b then Data.Bits.setBit x (fromInteger n) else Data.Bits.clearBit x (fromInteger n)\n  | otherwise = error (\"Bit index too large: \" ++ show n)\n;\n\nsetBitBounded :: Data.Bits.Bits a => a -> Integer -> Bool -> a;\nsetBitBounded x n True = Data.Bits.setBit x (fromInteger n);\nsetBitBounded x n False = Data.Bits.clearBit x (fromInteger n);\n\nshiftlUnbounded :: Data.Bits.Bits a => a -> Integer -> a;\nshiftlUnbounded x n\n  | n <= toInteger (Prelude.maxBound :: Int) = Data.Bits.shiftL x (fromInteger n)\n  | otherwise = error (\"Shift operand too large: \" ++ show n)\n;\n\nshiftlBounded :: Data.Bits.Bits a => a -> Integer -> a;\nshiftlBounded x n = Data.Bits.shiftL x (fromInteger n);\n\nshiftrUnbounded :: Data.Bits.Bits a => a -> Integer -> a;\nshiftrUnbounded x n\n  | n <= toInteger (Prelude.maxBound :: Int) = Data.Bits.shiftR x (fromInteger n)\n  | otherwise = error (\"Shift operand too large: \" ++ show n)\n;\n\nshiftrBounded :: (Ord a, Data.Bits.Bits a) => a -> Integer -> a;\nshiftrBounded x n = Data.Bits.shiftR x (fromInteger n);\n\n}\\<close>\n\n  and \\<comment> \\<open>@{theory HOL.Quickcheck_Narrowing} maps @{typ integer} to\n            Haskell's Prelude.Int type instead of Integer. For compatibility\n            with the Haskell target, we nevertheless provide bounded and\n            unbounded functions.\\<close>\n  (Haskell_Quickcheck)\n\\<open>\nmodule Data_Bits where {\n\nimport qualified Data.Bits;\n\n{-\n  The functions assume that the Int argument for the shift or bit index is\n  non-negative and (for types of fixed bit width) less than bitSize\n-}\n\ninfixl 7 .&.;\ninfixl 6 `xor`;\ninfixl 5 .|.;\n\n(.&.) :: Data.Bits.Bits a => a -> a -> a;\n(.&.) = (Data.Bits..&.);\n\nxor :: Data.Bits.Bits a => a -> a -> a;\nxor = Data.Bits.xor;\n\n(.|.) :: Data.Bits.Bits a => a -> a -> a;\n(.|.) = (Data.Bits..|.);\n\ncomplement :: Data.Bits.Bits a => a -> a;\ncomplement = Data.Bits.complement;\n\ntestBitUnbounded :: Data.Bits.Bits a => a -> Prelude.Int -> Bool;\ntestBitUnbounded = Data.Bits.testBit;\n\ntestBitBounded :: Data.Bits.Bits a => a -> Prelude.Int -> Bool;\ntestBitBounded = Data.Bits.testBit;\n\nsetBitUnbounded :: Data.Bits.Bits a => a -> Prelude.Int -> Bool -> a;\nsetBitUnbounded x n True = Data.Bits.setBit x n;\nsetBitUnbounded x n False = Data.Bits.clearBit x n;\n\nsetBitBounded :: Data.Bits.Bits a => a -> Prelude.Int -> Bool -> a;\nsetBitBounded x n True = Data.Bits.setBit x n;\nsetBitBounded x n False = Data.Bits.clearBit x n;\n\nshiftlUnbounded :: Data.Bits.Bits a => a -> Prelude.Int -> a;\nshiftlUnbounded = Data.Bits.shiftL;\n\nshiftlBounded :: Data.Bits.Bits a => a -> Prelude.Int -> a;\nshiftlBounded = Data.Bits.shiftL;\n\nshiftrUnbounded :: Data.Bits.Bits a => a -> Prelude.Int -> a;\nshiftrUnbounded = Data.Bits.shiftR;\n\nshiftrBounded :: (Ord a, Data.Bits.Bits a) => a -> Prelude.Int -> a;\nshiftrBounded = Data.Bits.shiftR;\n\n}\\<close>"], ["", "code_reserved Haskell Data_Bits"], ["", "code_printing code_module Bits_Integer \\<rightharpoonup> (Scala)\n\\<open>object Bits_Integer {\n\ndef setBit(x: BigInt, n: BigInt, b: Boolean) : BigInt =\n  if (n.isValidInt)\n    if (b)\n      x.setBit(n.toInt)\n    else\n      x.clearBit(n.toInt)\n  else\n    sys.error(\"Bit index too large: \" + n.toString)\n\ndef shiftl(x: BigInt, n: BigInt) : BigInt =\n  if (n.isValidInt)\n    x << n.toInt\n  else\n    sys.error(\"Shift index too large: \" + n.toString)\n\ndef shiftr(x: BigInt, n: BigInt) : BigInt =\n  if (n.isValidInt)\n    x << n.toInt\n  else\n    sys.error(\"Shift index too large: \" + n.toString)\n\ndef testBit(x: BigInt, n: BigInt) : Boolean =\n  if (n.isValidInt)\n    x.testBit(n.toInt)\n  else\n    sys.error(\"Bit index too large: \" + n.toString)\n\n} /* object Bits_Integer */\\<close>"], ["", "code_printing\n  constant \"(AND) :: integer \\<Rightarrow> integer \\<Rightarrow> integer\" \\<rightharpoonup>\n  (SML) \"IntInf.andb ((_),/ (_))\" and\n  (OCaml) \"Z.logand\" and\n  (Haskell) \"((Data'_Bits..&.) :: Integer -> Integer -> Integer)\" and\n  (Haskell_Quickcheck) \"((Data'_Bits..&.) :: Prelude.Int -> Prelude.Int -> Prelude.Int)\" and\n  (Scala) infixl 3 \"&\"\n| constant \"(OR) :: integer \\<Rightarrow> integer \\<Rightarrow> integer\" \\<rightharpoonup>\n  (SML) \"IntInf.orb ((_),/ (_))\" and\n  (OCaml) \"Z.logor\" and\n  (Haskell) \"((Data'_Bits..|.) :: Integer -> Integer -> Integer)\" and\n  (Haskell_Quickcheck) \"((Data'_Bits..|.) :: Prelude.Int -> Prelude.Int -> Prelude.Int)\" and\n  (Scala) infixl 1 \"|\"\n| constant \"(XOR) :: integer \\<Rightarrow> integer \\<Rightarrow> integer\" \\<rightharpoonup>\n  (SML) \"IntInf.xorb ((_),/ (_))\" and\n  (OCaml) \"Z.logxor\" and\n  (Haskell) \"(Data'_Bits.xor :: Integer -> Integer -> Integer)\" and\n  (Haskell_Quickcheck) \"(Data'_Bits.xor :: Prelude.Int -> Prelude.Int -> Prelude.Int)\" and\n  (Scala) infixl 2 \"^\"\n| constant \"NOT :: integer \\<Rightarrow> integer\" \\<rightharpoonup>\n  (SML) \"IntInf.notb\" and\n  (OCaml) \"Z.lognot\" and\n  (Haskell) \"(Data'_Bits.complement :: Integer -> Integer)\" and\n  (Haskell_Quickcheck) \"(Data'_Bits.complement :: Prelude.Int -> Prelude.Int)\" and\n  (Scala) \"_.unary'_~\""], ["", "code_printing constant bin_rest_integer \\<rightharpoonup>\n  (SML) \"IntInf.div ((_), 2)\" and\n  (OCaml) \"Z.shift'_right/ _/ 1\" and\n  (Haskell) \"(Data'_Bits.shiftrUnbounded _ 1 :: Integer)\" and\n  (Haskell_Quickcheck) \"(Data'_Bits.shiftrUnbounded _ 1 :: Prelude.Int)\" and\n  (Scala) \"_ >> 1\""], ["", "context\nincludes integer.lifting\nbegin"], ["", "lemma bitNOT_integer_code [code]:\n  fixes i :: integer shows\n  \"NOT i = - i - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOT i = - i - 1", "by transfer(simp add: int_not_def)"], ["", "lemma bin_rest_integer_code [code nbe]:\n  \"bin_rest_integer i = i div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_rest_integer i = i div 2", "by transfer rule"], ["", "lemma bin_last_integer_code [code]:\n  \"bin_last_integer i \\<longleftrightarrow> i AND 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_last_integer i = (i AND 1 \\<noteq> 0)", "by transfer (rule bin_last_conv_AND)"], ["", "lemma bin_last_integer_nbe [code nbe]:\n  \"bin_last_integer i \\<longleftrightarrow> i mod 2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bin_last_integer i = (i mod 2 \\<noteq> 0)", "by transfer(simp add: bin_last_def)"], ["", "lemma bitval_bin_last_integer [code_unfold]:\n  \"of_bool (bin_last_integer i) = i AND 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_bool (bin_last_integer i) = i AND 1", "by transfer(rule bitval_bin_last)"], ["", "end"], ["", "definition integer_test_bit :: \"integer \\<Rightarrow> integer \\<Rightarrow> bool\"\n  where \"integer_test_bit x n = (if n < 0 then undefined x n else bit x (nat_of_integer n))\""], ["", "declare [[code drop: \\<open>bit :: integer \\<Rightarrow> nat \\<Rightarrow> bool\\<close>]]"], ["", "lemma bit_integer_code [code]:\n  \"bit x n \\<longleftrightarrow> integer_test_bit x (integer_of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bit x n = integer_test_bit x (integer_of_nat n)", "by (simp add: integer_test_bit_def)"], ["", "lemma integer_test_bit_code [code]:\n  \"integer_test_bit x (Code_Numeral.Neg n) = undefined x (Code_Numeral.Neg n)\"\n  \"integer_test_bit 0 0 = False\"\n  \"integer_test_bit 0 (Code_Numeral.Pos n) = False\"\n  \"integer_test_bit (Code_Numeral.Pos num.One)      0 = True\"\n  \"integer_test_bit (Code_Numeral.Pos (num.Bit0 n)) 0 = False\"\n  \"integer_test_bit (Code_Numeral.Pos (num.Bit1 n)) 0 = True\"\n  \"integer_test_bit (Code_Numeral.Pos num.One)      (Code_Numeral.Pos n') = False\"\n  \"integer_test_bit (Code_Numeral.Pos (num.Bit0 n)) (Code_Numeral.Pos n') =\n   integer_test_bit (Code_Numeral.Pos n) (Code_Numeral.sub n' num.One)\"\n  \"integer_test_bit (Code_Numeral.Pos (num.Bit1 n)) (Code_Numeral.Pos n') =\n   integer_test_bit (Code_Numeral.Pos n) (Code_Numeral.sub n' num.One)\"\n  \"integer_test_bit (Code_Numeral.Neg num.One)      0 = True\"\n  \"integer_test_bit (Code_Numeral.Neg (num.Bit0 n)) 0 = False\"\n  \"integer_test_bit (Code_Numeral.Neg (num.Bit1 n)) 0 = True\"\n  \"integer_test_bit (Code_Numeral.Neg num.One)      (Code_Numeral.Pos n') = True\"\n  \"integer_test_bit (Code_Numeral.Neg (num.Bit0 n)) (Code_Numeral.Pos n') =\n   integer_test_bit (Code_Numeral.Neg n) (Code_Numeral.sub n' num.One)\"\n  \"integer_test_bit (Code_Numeral.Neg (num.Bit1 n)) (Code_Numeral.Pos n') =\n   integer_test_bit (Code_Numeral.Neg (n + num.One)) (Code_Numeral.sub n' num.One)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((integer_test_bit x (Code_Numeral.Neg n) =\n      undefined x (Code_Numeral.Neg n) &&&\n      integer_test_bit 0 0 = False &&&\n      integer_test_bit 0 (Code_Numeral.Pos n) = False) &&&\n     (integer_test_bit (Code_Numeral.Pos num.One) 0 = True &&&\n      integer_test_bit (Code_Numeral.Pos (num.Bit0 n)) 0 = False) &&&\n     integer_test_bit (Code_Numeral.Pos (num.Bit1 n)) 0 = True &&&\n     integer_test_bit (Code_Numeral.Pos num.One) (Code_Numeral.Pos n') =\n     False) &&&\n    ((integer_test_bit (Code_Numeral.Pos (num.Bit0 n))\n       (Code_Numeral.Pos n') =\n      integer_test_bit (Code_Numeral.Pos n)\n       (Code_Numeral.sub n' num.One) &&&\n      integer_test_bit (Code_Numeral.Pos (num.Bit1 n))\n       (Code_Numeral.Pos n') =\n      integer_test_bit (Code_Numeral.Pos n)\n       (Code_Numeral.sub n' num.One)) &&&\n     integer_test_bit (Code_Numeral.Neg num.One) 0 = True &&&\n     integer_test_bit (Code_Numeral.Neg (num.Bit0 n)) 0 = False) &&&\n    (integer_test_bit (Code_Numeral.Neg (num.Bit1 n)) 0 = True &&&\n     integer_test_bit (Code_Numeral.Neg num.One) (Code_Numeral.Pos n') =\n     True) &&&\n    integer_test_bit (Code_Numeral.Neg (num.Bit0 n)) (Code_Numeral.Pos n') =\n    integer_test_bit (Code_Numeral.Neg n) (Code_Numeral.sub n' num.One) &&&\n    integer_test_bit (Code_Numeral.Neg (num.Bit1 n)) (Code_Numeral.Pos n') =\n    integer_test_bit (Code_Numeral.Neg (n + num.One))\n     (Code_Numeral.sub n' num.One)", "apply (simp_all add: integer_test_bit_def bit_integer_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> bit (numeral n) (pred_numeral n')) =\n    bit (- numeral (n + num.One)) (pred_numeral n')", "using bin_nth_numeral_simps bit_numeral_int_simps(6)"], ["proof (prove)\nusing this:\n  bit (- numeral (num.Bit1 ?w)) (numeral ?n) =\n  bit (- numeral (?w + num.One)) (pred_numeral ?n)\n  bit (- numeral (num.Bit1 ?w)) (numeral ?n) =\n  (\\<not> bit (numeral ?w) (pred_numeral ?n))\n\ngoal (1 subgoal):\n 1. (\\<not> bit (numeral n) (pred_numeral n')) =\n    bit (- numeral (n + num.One)) (pred_numeral n')", "by presburger"], ["", "code_printing constant integer_test_bit \\<rightharpoonup>\n  (SML) \"Bits'_Integer.test'_bit\" and\n  (OCaml) \"Bits'_Integer.test'_bit\" and\n  (Haskell) \"(Data'_Bits.testBitUnbounded :: Integer -> Integer -> Bool)\" and\n  (Haskell_Quickcheck) \"(Data'_Bits.testBitUnbounded :: Prelude.Int -> Prelude.Int -> Bool)\" and\n  (Scala) \"Bits'_Integer.testBit\""], ["", "context\nincludes integer.lifting\nbegin"], ["", "lemma lsb_integer_code [code]:\n  fixes x :: integer shows\n  \"lsb x = bit x 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsb x = bit x 0", "by transfer(simp add: lsb_int_def)"], ["", "definition integer_set_bit :: \"integer \\<Rightarrow> integer \\<Rightarrow> bool \\<Rightarrow> integer\"\nwhere [code del]: \"integer_set_bit x n b = (if n < 0 then undefined x n b else set_bit x (nat_of_integer n) b)\""], ["", "lemma set_bit_integer_code [code]:\n  \"set_bit x i b = integer_set_bit x (integer_of_nat i) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x i b = integer_set_bit x (integer_of_nat i) b", "by(simp add: integer_set_bit_def)"], ["", "lemma set_bit_integer_conv_masks:\n  fixes x :: integer shows\n  \"set_bit x i b = (if b then x OR (1 << i) else x AND NOT (1 << i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bit_class.set_bit x i b =\n    (if b then x OR (1 << i) else x AND NOT (1 << i))", "by transfer (simp add: int_set_bit_False_conv_NAND int_set_bit_True_conv_OR shiftl_eq_push_bit)"], ["", "end"], ["", "code_printing constant integer_set_bit \\<rightharpoonup>\n  (SML) \"Bits'_Integer.set'_bit\" and\n  (Haskell) \"(Data'_Bits.setBitUnbounded :: Integer -> Integer -> Bool -> Integer)\" and\n  (Haskell_Quickcheck) \"(Data'_Bits.setBitUnbounded :: Prelude.Int -> Prelude.Int -> Bool -> Prelude.Int)\" and\n  (Scala) \"Bits'_Integer.setBit\""], ["", "text \\<open>\n  OCaml.Big\\_int does not have a method for changing an individual bit, so we emulate that with masks.\n  We prefer an Isabelle implementation, because this then takes care of the signs for AND and OR.\n\\<close>"], ["", "lemma integer_set_bit_code [code]:\n  \"integer_set_bit x n b =\n  (if n < 0 then undefined x n b else\n   if b then x OR (push_bit (nat_of_integer n) 1)\n   else x AND NOT (push_bit (nat_of_integer n) 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integer_set_bit x n b =\n    (if n < 0 then undefined x n b\n     else if b then x OR push_bit (nat_of_integer n) 1\n          else x AND NOT (push_bit (nat_of_integer n) 1))", "by (auto simp add: integer_set_bit_def not_less set_bit_eq set_bit_def unset_bit_def)"], ["", "definition integer_shiftl :: \"integer \\<Rightarrow> integer \\<Rightarrow> integer\"\nwhere [code del]: \"integer_shiftl x n = (if n < 0 then undefined x n else push_bit (nat_of_integer n) x)\""], ["", "declare [[code drop: \\<open>push_bit :: nat \\<Rightarrow> integer \\<Rightarrow> integer\\<close>]]"], ["", "lemma shiftl_integer_code [code]:\n  fixes x :: integer shows\n  \"push_bit n x = integer_shiftl x (integer_of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit n x = integer_shiftl x (integer_of_nat n)", "by(auto simp add: integer_shiftl_def)"], ["", "context\nincludes integer.lifting\nbegin"], ["", "lemma shiftl_integer_conv_mult_pow2:\n  fixes x :: integer shows\n  \"x << n = x * 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x << n = x * 2 ^ n", "by (simp add: push_bit_eq_mult shiftl_eq_push_bit)"], ["", "lemma integer_shiftl_code [code]:\n  \"integer_shiftl x (Code_Numeral.Neg n) = undefined x (Code_Numeral.Neg n)\"\n  \"integer_shiftl x 0 = x\"\n  \"integer_shiftl x (Code_Numeral.Pos n) = integer_shiftl (Code_Numeral.dup x) (Code_Numeral.sub n num.One)\"\n  \"integer_shiftl 0 (Code_Numeral.Pos n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (integer_shiftl x (Code_Numeral.Neg n) =\n     undefined x (Code_Numeral.Neg n) &&&\n     integer_shiftl x 0 = x) &&&\n    integer_shiftl x (Code_Numeral.Pos n) =\n    integer_shiftl (Code_Numeral.dup x) (Code_Numeral.sub n num.One) &&&\n    integer_shiftl 0 (Code_Numeral.Pos n) = 0", "apply (simp_all add: integer_shiftl_def numeral_eq_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_bit (pred_numeral n) (x * 2) =\n    push_bit (pred_numeral n) (Code_Numeral.dup x)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       push_bit (pred_numeral n) (x * 2) = push_bit (pred_numeral n) (x + x)", "apply (simp add: ac_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "code_printing constant integer_shiftl \\<rightharpoonup>\n  (SML) \"Bits'_Integer.shiftl\" and\n  (OCaml) \"Bits'_Integer.shiftl\" and\n  (Haskell) \"(Data'_Bits.shiftlUnbounded :: Integer -> Integer -> Integer)\" and\n  (Haskell_Quickcheck) \"(Data'_Bits.shiftlUnbounded :: Prelude.Int -> Prelude.Int -> Prelude.Int)\" and\n  (Scala) \"Bits'_Integer.shiftl\""], ["", "definition integer_shiftr :: \"integer \\<Rightarrow> integer \\<Rightarrow> integer\"\nwhere [code del]: \"integer_shiftr x n = (if n < 0 then undefined x n else drop_bit (nat_of_integer n) x)\""], ["", "declare [[code drop: \\<open>drop_bit :: nat \\<Rightarrow> integer \\<Rightarrow> integer\\<close>]]"], ["", "lemma shiftr_integer_conv_div_pow2:\n  includes integer.lifting fixes x :: integer shows\n  \"x >> n = x div 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x >> n = x div 2 ^ n", "by (simp add: drop_bit_eq_div shiftr_eq_drop_bit)"], ["", "lemma shiftr_integer_code [code]:\n  fixes x :: integer shows\n  \"drop_bit n x = integer_shiftr x (integer_of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit n x = integer_shiftr x (integer_of_nat n)", "by(auto simp add: integer_shiftr_def)"], ["", "code_printing constant integer_shiftr \\<rightharpoonup>\n  (SML) \"Bits'_Integer.shiftr\" and\n  (OCaml) \"Bits'_Integer.shiftr\" and\n  (Haskell) \"(Data'_Bits.shiftrUnbounded :: Integer -> Integer -> Integer)\" and\n  (Haskell_Quickcheck) \"(Data'_Bits.shiftrUnbounded :: Prelude.Int -> Prelude.Int -> Prelude.Int)\" and\n  (Scala) \"Bits'_Integer.shiftr\""], ["", "lemma integer_shiftr_code [code]:\n  includes integer.lifting\n  shows\n  \"integer_shiftr x (Code_Numeral.Neg n) = undefined x (Code_Numeral.Neg n)\"\n  \"integer_shiftr x 0 = x\"\n  \"integer_shiftr 0 (Code_Numeral.Pos n) = 0\"\n  \"integer_shiftr (Code_Numeral.Pos num.One) (Code_Numeral.Pos n) = 0\"\n  \"integer_shiftr (Code_Numeral.Pos (num.Bit0 n')) (Code_Numeral.Pos n) =\n   integer_shiftr (Code_Numeral.Pos n') (Code_Numeral.sub n num.One)\"\n  \"integer_shiftr (Code_Numeral.Pos (num.Bit1 n')) (Code_Numeral.Pos n) =\n   integer_shiftr (Code_Numeral.Pos n') (Code_Numeral.sub n num.One)\"\n  \"integer_shiftr (Code_Numeral.Neg num.One) (Code_Numeral.Pos n) = -1\"\n  \"integer_shiftr (Code_Numeral.Neg (num.Bit0 n')) (Code_Numeral.Pos n) =\n   integer_shiftr (Code_Numeral.Neg n') (Code_Numeral.sub n num.One)\"\n  \"integer_shiftr (Code_Numeral.Neg (num.Bit1 n')) (Code_Numeral.Pos n) =\n   integer_shiftr (Code_Numeral.Neg (Num.inc n')) (Code_Numeral.sub n num.One)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((integer_shiftr x (Code_Numeral.Neg n) =\n      undefined x (Code_Numeral.Neg n) &&&\n      integer_shiftr x 0 = x) &&&\n     integer_shiftr 0 (Code_Numeral.Pos n) = 0 &&&\n     integer_shiftr (Code_Numeral.Pos num.One) (Code_Numeral.Pos n) = 0) &&&\n    (integer_shiftr (Code_Numeral.Pos (num.Bit0 n')) (Code_Numeral.Pos n) =\n     integer_shiftr (Code_Numeral.Pos n') (Code_Numeral.sub n num.One) &&&\n     integer_shiftr (Code_Numeral.Pos (num.Bit1 n')) (Code_Numeral.Pos n) =\n     integer_shiftr (Code_Numeral.Pos n') (Code_Numeral.sub n num.One)) &&&\n    integer_shiftr (Code_Numeral.Neg num.One) (Code_Numeral.Pos n) = - 1 &&&\n    integer_shiftr (Code_Numeral.Neg (num.Bit0 n')) (Code_Numeral.Pos n) =\n    integer_shiftr (Code_Numeral.Neg n') (Code_Numeral.sub n num.One) &&&\n    integer_shiftr (Code_Numeral.Neg (num.Bit1 n')) (Code_Numeral.Pos n) =\n    integer_shiftr (Code_Numeral.Neg (Num.inc n'))\n     (Code_Numeral.sub n num.One)", "apply (simp_all add: integer_shiftr_def numeral_eq_Suc drop_bit_Suc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. drop_bit (pred_numeral n) (- 1) = - 1\n 2. drop_bit (pred_numeral n) (- numeral (num.Bit0 n') div 2) =\n    drop_bit (pred_numeral n) (- numeral n')\n 3. drop_bit (pred_numeral n) (- numeral (num.Bit1 n') div 2) =\n    drop_bit (pred_numeral n) (- numeral (Num.inc n'))", "apply transfer"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n. drop_bit (pred_numeral n) (- 1) = - 1\n 2. drop_bit (pred_numeral n) (- numeral (num.Bit0 n') div 2) =\n    drop_bit (pred_numeral n) (- numeral n')\n 3. drop_bit (pred_numeral n) (- numeral (num.Bit1 n') div 2) =\n    drop_bit (pred_numeral n) (- numeral (Num.inc n'))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. drop_bit (pred_numeral n) (- numeral (num.Bit0 n') div 2) =\n    drop_bit (pred_numeral n) (- numeral n')\n 2. drop_bit (pred_numeral n) (- numeral (num.Bit1 n') div 2) =\n    drop_bit (pred_numeral n) (- numeral (Num.inc n'))", "apply transfer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n n'.\n       drop_bit (pred_numeral n) (- numeral (num.Bit0 n') div 2) =\n       drop_bit (pred_numeral n) (- numeral n')\n 2. drop_bit (pred_numeral n) (- numeral (num.Bit1 n') div 2) =\n    drop_bit (pred_numeral n) (- numeral (Num.inc n'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. drop_bit (pred_numeral n) (- numeral (num.Bit1 n') div 2) =\n    drop_bit (pred_numeral n) (- numeral (Num.inc n'))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       drop_bit (pred_numeral n) (- numeral (num.Bit1 n') div 2) =\n       drop_bit (pred_numeral n) (- numeral (Num.inc n'))", "apply (simp add: add_One)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context\nincludes integer.lifting\nbegin"], ["", "lemma Bit_integer_code [code]:\n  \"Bit_integer i False = push_bit 1 i\"\n  \"Bit_integer i True = (push_bit 1 i) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bit_integer i False = push_bit 1 i &&&\n    Bit_integer i True = push_bit 1 i + 1", "by (transfer; simp add: shiftl_int_def)+"], ["", "lemma msb_integer_code [code]:\n  \"msb (x :: integer) \\<longleftrightarrow> x < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msb x = (x < 0)", "by transfer(simp add: msb_int_def)"], ["", "end"], ["", "context\nincludes integer.lifting natural.lifting\nbegin"], ["", "lemma bitAND_integer_unfold [code]:\n  \"x AND y =\n   (if x = 0 then 0\n    else if x = - 1 then y\n    else Bit_integer (bin_rest_integer x AND bin_rest_integer y) (bin_last_integer x \\<and> bin_last_integer y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND y =\n    (if x = 0 then 0\n     else if x = - 1 then y\n          else Bit_integer (bin_rest_integer x AND bin_rest_integer y)\n                (bin_last_integer x \\<and> bin_last_integer y))", "by transfer\n    (auto simp add: algebra_simps\n      and_int_rec [of _ \\<open>_ * 2\\<close>] and_int_rec [of \\<open>_ * 2\\<close>] and_int_rec [of \\<open>1 + _ * 2\\<close>]\n      elim!: evenE oddE)"], ["", "lemma bitOR_integer_unfold [code]:\n  \"x OR y =\n   (if x = 0 then y\n    else if x = - 1 then - 1\n    else Bit_integer (bin_rest_integer x OR bin_rest_integer y) (bin_last_integer x \\<or> bin_last_integer y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x OR y =\n    (if x = 0 then y\n     else if x = - 1 then - 1\n          else Bit_integer (bin_rest_integer x OR bin_rest_integer y)\n                (bin_last_integer x \\<or> bin_last_integer y))", "by transfer\n    (auto simp add: algebra_simps\n      or_int_rec [of _ \\<open>_ * 2\\<close>] or_int_rec [of _ \\<open>1 + _ * 2\\<close>] or_int_rec [of \\<open>1 + _ * 2\\<close>]\n      elim!: evenE oddE)"], ["", "lemma bitXOR_integer_unfold [code]:\n  \"x XOR y =\n   (if x = 0 then y\n    else if x = - 1 then NOT y\n    else Bit_integer (bin_rest_integer x XOR bin_rest_integer y)\n      (\\<not> bin_last_integer x \\<longleftrightarrow> bin_last_integer y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x XOR y =\n    (if x = 0 then y\n     else if x = - 1 then NOT y\n          else Bit_integer (bin_rest_integer x XOR bin_rest_integer y)\n                ((\\<not> bin_last_integer x) = bin_last_integer y))", "by transfer\n    (auto simp add: algebra_simps\n      xor_int_rec [of _ \\<open>_ * 2\\<close>] xor_int_rec [of \\<open>_ * 2\\<close>] xor_int_rec [of \\<open>1 + _ * 2\\<close>]\n      elim!: evenE oddE)"], ["", "end"], ["", "section \\<open>Test code generator setup\\<close>"], ["", "definition bit_integer_test :: \"bool\" where\n  \"bit_integer_test =\n  (([ -1 AND 3, 1 AND -3, 3 AND 5, -3 AND (- 5)\n    , -3 OR 1, 1 OR -3, 3 OR 5, -3 OR (- 5)\n    , NOT 1, NOT (- 3)\n    , -1 XOR 3, 1 XOR (- 3), 3 XOR 5, -5 XOR (- 3)\n    , set_bit 5 4 True, set_bit (- 5) 2 True, set_bit 5 0 False, set_bit (- 5) 1 False\n    , 1 << 2, -1 << 3\n    , 100 >> 3, -100 >> 3] :: integer list)\n  = [ 3, 1, 1, -7\n    , -3, -3, 7, -1\n    , -2, 2\n    , -4, -4, 6, 6\n    , 21, -1, 4, -7\n    , 4, -8\n    , 12, -13] \\<and>\n    [ (5 :: integer) !! 4, (5 :: integer) !! 2, (-5 :: integer) !! 4, (-5 :: integer) !! 2\n    , lsb (5 :: integer), lsb (4 :: integer), lsb (-1 :: integer), lsb (-2 :: integer),\n      msb (5 :: integer), msb (0 :: integer), msb (-1 :: integer), msb (-2 :: integer)]\n  = [ False, True, True, False,\n      True, False, True, False,\n      False, False, True, True])\""], ["", "export_code bit_integer_test checking SML Haskell? Haskell_Quickcheck? OCaml? Scala"], ["", "notepad begin"], ["proof (state)", "have bit_integer_test"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit_integer_test", "by eval"], ["proof (state)\nthis:\n  bit_integer_test", "have bit_integer_test"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit_integer_test", "by normalization"], ["proof (state)\nthis:\n  bit_integer_test", "have bit_integer_test"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit_integer_test", "by code_simp"], ["proof (state)\nthis:\n  bit_integer_test", "end"], ["", "ML_val \\<open>val true = @{code bit_integer_test}\\<close>"], ["", "lemma \"x AND y = x OR (y :: integer)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND y = x OR y", "quickcheck[random, expect=counterexample]"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND y = x OR y", "quickcheck[exhaustive, expect=counterexample]"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND y = x OR y", "oops"], ["", "lemma \"(x :: integer) AND x = x OR x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND x = x OR x", "quickcheck[narrowing, expect=no_counterexample]"], ["proof (prove)\ngoal (1 subgoal):\n 1. x AND x = x OR x", "oops"], ["", "lemma \"(f :: integer \\<Rightarrow> unit) = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g", "quickcheck[narrowing, size=3, expect=no_counterexample]"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g", "by(simp add: fun_eq_iff)"], ["", "hide_const bit_integer_test"], ["", "hide_fact bit_integer_test_def"], ["", "end"]]}